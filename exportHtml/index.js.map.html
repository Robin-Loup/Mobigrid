<html>
<head>
<title>index.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
.s1 { color: #6a8759;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
index.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s2">:</span><span class="s3">3</span><span class="s2">,</span><span class="s1">&quot;file&quot;</span><span class="s2">:</span><span class="s1">&quot;index.js&quot;</span><span class="s2">,</span><span class="s1">&quot;sources&quot;</span><span class="s2">:</span><span class="s0">[</span><span class="s1">&quot;../src/options.ts&quot;</span><span class="s2">,</span><span class="s1">&quot;../src/tokenizer/context.ts&quot;</span><span class="s2">,</span><span class="s1">&quot;../src/tokenizer/types.ts&quot;</span><span class="s2">,</span><span class="s1">&quot;../src/util/location.ts&quot;</span><span class="s2">,</span><span class="s1">&quot;../src/parse-error/credentials.ts&quot;</span><span class="s2">,</span><span class="s1">&quot;../src/parse-error/module-errors.ts&quot;</span><span class="s2">,</span><span class="s1">&quot;../src/parse-error/to-node-description.ts&quot;</span><span class="s2">,</span><span class="s1">&quot;../src/parse-error/standard-errors.ts&quot;</span><span class="s2">,</span><span class="s1">&quot;../src/parse-error/strict-mode-errors.ts&quot;</span><span class="s2">,</span><span class="s1">&quot;../src/parse-error/pipeline-operator-errors.ts&quot;</span><span class="s2">,</span><span class="s1">&quot;../src/parse-error.ts&quot;</span><span class="s2">,</span><span class="s1">&quot;../src/plugins/estree.ts&quot;</span><span class="s2">,</span><span class="s1">&quot;../../babel-helper-validator-identifier/src/identifier.ts&quot;</span><span class="s2">,</span><span class="s1">&quot;../../babel-helper-validator-identifier/src/keyword.ts&quot;</span><span class="s2">,</span><span class="s1">&quot;../src/util/identifier.ts&quot;</span><span class="s2">,</span><span class="s1">&quot;../src/util/scopeflags.ts&quot;</span><span class="s2">,</span><span class="s1">&quot;../src/util/scope.ts&quot;</span><span class="s2">,</span><span class="s1">&quot;../src/plugins/flow/scope.ts&quot;</span><span class="s2">,</span><span class="s1">&quot;../src/parser/base.ts&quot;</span><span class="s2">,</span><span class="s1">&quot;../src/parser/comments.ts&quot;</span><span class="s2">,</span><span class="s1">&quot;../src/util/whitespace.ts&quot;</span><span class="s2">,</span><span class="s1">&quot;../src/tokenizer/state.ts&quot;</span><span class="s2">,</span><span class="s1">&quot;../../babel-helper-string-parser/src/index.ts&quot;</span><span class="s2">,</span><span class="s1">&quot;../src/tokenizer/index.ts&quot;</span><span class="s2">,</span><span class="s1">&quot;../src/util/class-scope.ts&quot;</span><span class="s2">,</span><span class="s1">&quot;../src/util/expression-scope.ts&quot;</span><span class="s2">,</span><span class="s1">&quot;../src/util/production-parameter.ts&quot;</span><span class="s2">,</span><span class="s1">&quot;../src/parser/util.ts&quot;</span><span class="s2">,</span><span class="s1">&quot;../src/parser/node.ts&quot;</span><span class="s2">,</span><span class="s1">&quot;../src/plugins/flow/index.ts&quot;</span><span class="s2">,</span><span class="s1">&quot;../src/plugins/jsx/xhtml.ts&quot;</span><span class="s2">,</span><span class="s1">&quot;../src/plugins/jsx/index.ts&quot;</span><span class="s2">,</span><span class="s1">&quot;../src/plugins/typescript/scope.ts&quot;</span><span class="s2">,</span><span class="s1">&quot;../src/parser/lval.ts&quot;</span><span class="s2">,</span><span class="s1">&quot;../src/plugins/typescript/index.ts&quot;</span><span class="s2">,</span><span class="s1">&quot;../src/plugins/placeholders.ts&quot;</span><span class="s2">,</span><span class="s1">&quot;../src/plugins/v8intrinsic.ts&quot;</span><span class="s2">,</span><span class="s1">&quot;../src/plugin-utils.ts&quot;</span><span class="s2">,</span><span class="s1">&quot;../src/parser/expression.ts&quot;</span><span class="s2">,</span><span class="s1">&quot;../src/parser/statement.ts&quot;</span><span class="s2">,</span><span class="s1">&quot;../src/parser/index.ts&quot;</span><span class="s2">,</span><span class="s1">&quot;../src/index.ts&quot;</span><span class="s0">]</span><span class="s2">,</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s2">:</span><span class="s0">[</span><span class="s1">&quot;import type { PluginList } from </span><span class="s2">\&quot;</span><span class="s1">./plugin-utils</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">// A second optional argument can be given to further configure</span><span class="s2">\n</span><span class="s1">// the parser process. These options are recognized:</span><span class="s2">\n\n</span><span class="s1">export type SourceType = </span><span class="s2">\&quot;</span><span class="s1">script</span><span class="s2">\&quot; </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">module</span><span class="s2">\&quot; </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">unambiguous</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">export type Options = {</span><span class="s2">\n  </span><span class="s1">sourceType: SourceType;</span><span class="s2">\n  </span><span class="s1">sourceFilename?: string;</span><span class="s2">\n  </span><span class="s1">startColumn: number;</span><span class="s2">\n  </span><span class="s1">startLine: number;</span><span class="s2">\n  </span><span class="s1">allowAwaitOutsideFunction: boolean;</span><span class="s2">\n  </span><span class="s1">allowReturnOutsideFunction: boolean;</span><span class="s2">\n  </span><span class="s1">allowNewTargetOutsideFunction: boolean;</span><span class="s2">\n  </span><span class="s1">allowImportExportEverywhere: boolean;</span><span class="s2">\n  </span><span class="s1">allowSuperOutsideMethod: boolean;</span><span class="s2">\n  </span><span class="s1">allowUndeclaredExports: boolean;</span><span class="s2">\n  </span><span class="s1">plugins: PluginList;</span><span class="s2">\n  </span><span class="s1">strictMode: boolean | undefined | null;</span><span class="s2">\n  </span><span class="s1">ranges: boolean;</span><span class="s2">\n  </span><span class="s1">tokens: boolean;</span><span class="s2">\n  </span><span class="s1">createParenthesizedExpressions: boolean;</span><span class="s2">\n  </span><span class="s1">errorRecovery: boolean;</span><span class="s2">\n  </span><span class="s1">attachComment: boolean;</span><span class="s2">\n  </span><span class="s1">annexB: boolean;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">export const defaultOptions: Options = {</span><span class="s2">\n  </span><span class="s1">// Source type (</span><span class="s2">\&quot;</span><span class="s1">script</span><span class="s2">\&quot; </span><span class="s1">or </span><span class="s2">\&quot;</span><span class="s1">module</span><span class="s2">\&quot;</span><span class="s1">) for different semantics</span><span class="s2">\n  </span><span class="s1">sourceType: </span><span class="s2">\&quot;</span><span class="s1">script</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">// Source filename.</span><span class="s2">\n  </span><span class="s1">sourceFilename: undefined,</span><span class="s2">\n  </span><span class="s1">// Column (0-based) from which to start counting source. Useful for</span><span class="s2">\n  </span><span class="s1">// integration with other tools.</span><span class="s2">\n  </span><span class="s1">startColumn: 0,</span><span class="s2">\n  </span><span class="s1">// Line (1-based) from which to start counting source. Useful for</span><span class="s2">\n  </span><span class="s1">// integration with other tools.</span><span class="s2">\n  </span><span class="s1">startLine: 1,</span><span class="s2">\n  </span><span class="s1">// When enabled, await at the top level is not considered an</span><span class="s2">\n  </span><span class="s1">// error.</span><span class="s2">\n  </span><span class="s1">allowAwaitOutsideFunction: false,</span><span class="s2">\n  </span><span class="s1">// When enabled, a return at the top level is not considered an</span><span class="s2">\n  </span><span class="s1">// error.</span><span class="s2">\n  </span><span class="s1">allowReturnOutsideFunction: false,</span><span class="s2">\n  </span><span class="s1">// When enabled, new.target outside a function or class is not</span><span class="s2">\n  </span><span class="s1">// considered an error.</span><span class="s2">\n  </span><span class="s1">allowNewTargetOutsideFunction: false,</span><span class="s2">\n  </span><span class="s1">// When enabled, import/export statements are not constrained to</span><span class="s2">\n  </span><span class="s1">// appearing at the top of the program.</span><span class="s2">\n  </span><span class="s1">allowImportExportEverywhere: false,</span><span class="s2">\n  </span><span class="s1">// TODO</span><span class="s2">\n  </span><span class="s1">allowSuperOutsideMethod: false,</span><span class="s2">\n  </span><span class="s1">// When enabled, export statements can reference undeclared variables.</span><span class="s2">\n  </span><span class="s1">allowUndeclaredExports: false,</span><span class="s2">\n  </span><span class="s1">// An array of plugins to enable</span><span class="s2">\n  </span><span class="s1">plugins: [],</span><span class="s2">\n  </span><span class="s1">// TODO</span><span class="s2">\n  </span><span class="s1">strictMode: null,</span><span class="s2">\n  </span><span class="s1">// Nodes have their start and end characters offsets recorded in</span><span class="s2">\n  </span><span class="s1">// `start` and `end` properties (directly on the node, rather than</span><span class="s2">\n  </span><span class="s1">// the `loc` object, which holds line/column data. To also add a</span><span class="s2">\n  </span><span class="s1">// [semi-standardized][range] `range` property holding a `[start,</span><span class="s2">\n  </span><span class="s1">// end]` array with the same numbers, set the `ranges` option to</span><span class="s2">\n  </span><span class="s1">// `true`.</span><span class="s2">\n  </span><span class="s1">//</span><span class="s2">\n  </span><span class="s1">// [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678</span><span class="s2">\n  </span><span class="s1">ranges: false,</span><span class="s2">\n  </span><span class="s1">// Adds all parsed tokens to a `tokens` property on the `File` node</span><span class="s2">\n  </span><span class="s1">tokens: false,</span><span class="s2">\n  </span><span class="s1">// Whether to create ParenthesizedExpression AST nodes (if false</span><span class="s2">\n  </span><span class="s1">// the parser sets extra.parenthesized on the expression nodes instead).</span><span class="s2">\n  </span><span class="s1">createParenthesizedExpressions: false,</span><span class="s2">\n  </span><span class="s1">// When enabled, errors are attached to the AST instead of being directly thrown.</span><span class="s2">\n  </span><span class="s1">// Some errors will still throw, because @babel/parser can't always recover.</span><span class="s2">\n  </span><span class="s1">errorRecovery: false,</span><span class="s2">\n  </span><span class="s1">// When enabled, comments will be attached to adjacent AST nodes as one of</span><span class="s2">\n  </span><span class="s1">// `leadingComments`, `trailingComments` and `innerComments`. The comment attachment</span><span class="s2">\n  </span><span class="s1">// is vital to preserve comments after transform. If you don't print AST back,</span><span class="s2">\n  </span><span class="s1">// consider set this option to `false` for performance</span><span class="s2">\n  </span><span class="s1">attachComment: true,</span><span class="s2">\n  </span><span class="s1">// When enabled, the parser will support Annex B syntax.</span><span class="s2">\n  </span><span class="s1">// https://tc39.es/ecma262/#sec-additional-ecmascript-features-for-web-browsers</span><span class="s2">\n  </span><span class="s1">annexB: true,</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">// Interpret and default an options object</span><span class="s2">\n\n</span><span class="s1">export function getOptions(opts?: Options | null): Options {</span><span class="s2">\n  </span><span class="s1">if (opts &amp;&amp; opts.annexB != null &amp;&amp; opts.annexB !== false) {</span><span class="s2">\n    </span><span class="s1">throw new Error(</span><span class="s2">\&quot;</span><span class="s1">The `annexB` option can only be set to `false`.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">const options: any = {};</span><span class="s2">\n  </span><span class="s1">for (const key of Object.keys(defaultOptions)) {</span><span class="s2">\n    </span><span class="s1">// @ts-expect-error key may not exist in opts</span><span class="s2">\n    </span><span class="s1">options[key] = opts &amp;&amp; opts[key] != null ? opts[key] : defaultOptions[key];</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return options;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">&quot;</span><span class="s2">,</span><span class="s1">&quot;// The token context is used in JSX plugin to track</span><span class="s2">\n</span><span class="s1">// jsx tag / jsx text / normal JavaScript expression</span><span class="s2">\n\n</span><span class="s1">export class TokContext {</span><span class="s2">\n  </span><span class="s1">constructor(token: string, preserveSpace?: boolean) {</span><span class="s2">\n    </span><span class="s1">this.token = token;</span><span class="s2">\n    </span><span class="s1">this.preserveSpace = !!preserveSpace;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">token: string;</span><span class="s2">\n  </span><span class="s1">preserveSpace: boolean;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">const types: {</span><span class="s2">\n  </span><span class="s1">[key: string]: TokContext;</span><span class="s2">\n</span><span class="s1">} = {</span><span class="s2">\n  </span><span class="s1">brace: new TokContext(</span><span class="s2">\&quot;</span><span class="s1">{</span><span class="s2">\&quot;</span><span class="s1">), // normal JavaScript expression</span><span class="s2">\n  </span><span class="s1">j_oTag: new TokContext(</span><span class="s2">\&quot;</span><span class="s1">&lt;tag</span><span class="s2">\&quot;</span><span class="s1">), // JSX opening tag</span><span class="s2">\n  </span><span class="s1">j_cTag: new TokContext(</span><span class="s2">\&quot;</span><span class="s1">&lt;/tag</span><span class="s2">\&quot;</span><span class="s1">), // JSX closing tag</span><span class="s2">\n  </span><span class="s1">j_expr: new TokContext(</span><span class="s2">\&quot;</span><span class="s1">&lt;tag&gt;...&lt;/tag&gt;</span><span class="s2">\&quot;</span><span class="s1">, true), // JSX expressions</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">if (!process.env.BABEL_8_BREAKING) {</span><span class="s2">\n  </span><span class="s1">types.template = new TokContext(</span><span class="s2">\&quot;</span><span class="s1">`</span><span class="s2">\&quot;</span><span class="s1">, true);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">export { types };</span><span class="s2">\n</span><span class="s1">&quot;</span><span class="s2">,</span><span class="s1">&quot;import { types as tc, type TokContext } from </span><span class="s2">\&quot;</span><span class="s1">./context</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">// ## Token types</span><span class="s2">\n\n</span><span class="s1">// The assignment of fine-grained, information-carrying type objects</span><span class="s2">\n</span><span class="s1">// allows the tokenizer to store the information it has about a</span><span class="s2">\n</span><span class="s1">// token in a way that is very cheap for the parser to look up.</span><span class="s2">\n\n</span><span class="s1">// All token type variables start with an underscore, to make them</span><span class="s2">\n</span><span class="s1">// easy to recognize.</span><span class="s2">\n\n</span><span class="s1">// The `beforeExpr` property is used to disambiguate between 1) binary</span><span class="s2">\n</span><span class="s1">// expression (&lt;) and JSX Tag start (&lt;name&gt;); 2) object literal and JSX</span><span class="s2">\n</span><span class="s1">// texts. It is set on the `updateContext` function in the JSX plugin.</span><span class="s2">\n\n</span><span class="s1">// The `startsExpr` property is used to determine whether an expression</span><span class="s2">\n</span><span class="s1">// may be the “argument” subexpression of a `yield` expression or</span><span class="s2">\n</span><span class="s1">// `yield` statement. It is set on all token types that may be at the</span><span class="s2">\n</span><span class="s1">// start of a subexpression.</span><span class="s2">\n\n</span><span class="s1">// `isLoop` marks a keyword as starting a loop, which is important</span><span class="s2">\n</span><span class="s1">// to know when parsing a label, in order to allow or disallow</span><span class="s2">\n</span><span class="s1">// continue jumps to that label.</span><span class="s2">\n\n</span><span class="s1">const beforeExpr = true;</span><span class="s2">\n</span><span class="s1">const startsExpr = true;</span><span class="s2">\n</span><span class="s1">const isLoop = true;</span><span class="s2">\n</span><span class="s1">const isAssign = true;</span><span class="s2">\n</span><span class="s1">const prefix = true;</span><span class="s2">\n</span><span class="s1">const postfix = true;</span><span class="s2">\n\n</span><span class="s1">type TokenOptions = {</span><span class="s2">\n  </span><span class="s1">keyword?: string;</span><span class="s2">\n  </span><span class="s1">beforeExpr?: boolean;</span><span class="s2">\n  </span><span class="s1">startsExpr?: boolean;</span><span class="s2">\n  </span><span class="s1">rightAssociative?: boolean;</span><span class="s2">\n  </span><span class="s1">isLoop?: boolean;</span><span class="s2">\n  </span><span class="s1">isAssign?: boolean;</span><span class="s2">\n  </span><span class="s1">prefix?: boolean;</span><span class="s2">\n  </span><span class="s1">postfix?: boolean;</span><span class="s2">\n  </span><span class="s1">binop?: number | null;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">// Internally the tokenizer stores token as a number</span><span class="s2">\n</span><span class="s1">export type TokenType = number;</span><span class="s2">\n\n</span><span class="s1">// The `ExportedTokenType` is exported via `tokTypes` and accessible</span><span class="s2">\n</span><span class="s1">// when `tokens: true` is enabled. Unlike internal token type, it provides</span><span class="s2">\n</span><span class="s1">// metadata of the tokens.</span><span class="s2">\n</span><span class="s1">export class ExportedTokenType {</span><span class="s2">\n  </span><span class="s1">label: string;</span><span class="s2">\n  </span><span class="s1">keyword: string | undefined | null;</span><span class="s2">\n  </span><span class="s1">beforeExpr: boolean;</span><span class="s2">\n  </span><span class="s1">startsExpr: boolean;</span><span class="s2">\n  </span><span class="s1">rightAssociative: boolean;</span><span class="s2">\n  </span><span class="s1">isLoop: boolean;</span><span class="s2">\n  </span><span class="s1">isAssign: boolean;</span><span class="s2">\n  </span><span class="s1">prefix: boolean;</span><span class="s2">\n  </span><span class="s1">postfix: boolean;</span><span class="s2">\n  </span><span class="s1">binop: number | undefined | null;</span><span class="s2">\n  </span><span class="s1">// todo(Babel 8): remove updateContext from exposed token layout</span><span class="s2">\n  </span><span class="s1">declare updateContext:</span><span class="s2">\n    </span><span class="s1">| ((context: Array&lt;TokContext&gt;) =&gt; void)</span><span class="s2">\n    </span><span class="s1">| undefined</span><span class="s2">\n    </span><span class="s1">| null;</span><span class="s2">\n\n  </span><span class="s1">constructor(label: string, conf: TokenOptions = {}) {</span><span class="s2">\n    </span><span class="s1">this.label = label;</span><span class="s2">\n    </span><span class="s1">this.keyword = conf.keyword;</span><span class="s2">\n    </span><span class="s1">this.beforeExpr = !!conf.beforeExpr;</span><span class="s2">\n    </span><span class="s1">this.startsExpr = !!conf.startsExpr;</span><span class="s2">\n    </span><span class="s1">this.rightAssociative = !!conf.rightAssociative;</span><span class="s2">\n    </span><span class="s1">this.isLoop = !!conf.isLoop;</span><span class="s2">\n    </span><span class="s1">this.isAssign = !!conf.isAssign;</span><span class="s2">\n    </span><span class="s1">this.prefix = !!conf.prefix;</span><span class="s2">\n    </span><span class="s1">this.postfix = !!conf.postfix;</span><span class="s2">\n    </span><span class="s1">this.binop = conf.binop != null ? conf.binop : null;</span><span class="s2">\n    </span><span class="s1">if (!process.env.BABEL_8_BREAKING) {</span><span class="s2">\n      </span><span class="s1">this.updateContext = null;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// A map from keyword/keyword-like string value to the token type</span><span class="s2">\n</span><span class="s1">export const keywords = new Map&lt;string, TokenType&gt;();</span><span class="s2">\n\n</span><span class="s1">function createKeyword(name: string, options: TokenOptions = {}): TokenType {</span><span class="s2">\n  </span><span class="s1">options.keyword = name;</span><span class="s2">\n  </span><span class="s1">const token = createToken(name, options);</span><span class="s2">\n  </span><span class="s1">keywords.set(name, token);</span><span class="s2">\n  </span><span class="s1">return token;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function createBinop(name: string, binop: number) {</span><span class="s2">\n  </span><span class="s1">return createToken(name, { beforeExpr, binop });</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">let tokenTypeCounter = -1;</span><span class="s2">\n</span><span class="s1">export const tokenTypes: ExportedTokenType[] = [];</span><span class="s2">\n</span><span class="s1">const tokenLabels: string[] = [];</span><span class="s2">\n</span><span class="s1">const tokenBinops: number[] = [];</span><span class="s2">\n</span><span class="s1">const tokenBeforeExprs: boolean[] = [];</span><span class="s2">\n</span><span class="s1">const tokenStartsExprs: boolean[] = [];</span><span class="s2">\n</span><span class="s1">const tokenPrefixes: boolean[] = [];</span><span class="s2">\n\n</span><span class="s1">function createToken(name: string, options: TokenOptions = {}): TokenType {</span><span class="s2">\n  </span><span class="s1">++tokenTypeCounter;</span><span class="s2">\n  </span><span class="s1">tokenLabels.push(name);</span><span class="s2">\n  </span><span class="s1">tokenBinops.push(options.binop ?? -1);</span><span class="s2">\n  </span><span class="s1">tokenBeforeExprs.push(options.beforeExpr ?? false);</span><span class="s2">\n  </span><span class="s1">tokenStartsExprs.push(options.startsExpr ?? false);</span><span class="s2">\n  </span><span class="s1">tokenPrefixes.push(options.prefix ?? false);</span><span class="s2">\n  </span><span class="s1">tokenTypes.push(new ExportedTokenType(name, options));</span><span class="s2">\n\n  </span><span class="s1">return tokenTypeCounter;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function createKeywordLike(</span><span class="s2">\n  </span><span class="s1">name: string,</span><span class="s2">\n  </span><span class="s1">options: TokenOptions = {},</span><span class="s2">\n</span><span class="s1">): TokenType {</span><span class="s2">\n  </span><span class="s1">++tokenTypeCounter;</span><span class="s2">\n  </span><span class="s1">keywords.set(name, tokenTypeCounter);</span><span class="s2">\n  </span><span class="s1">tokenLabels.push(name);</span><span class="s2">\n  </span><span class="s1">tokenBinops.push(options.binop ?? -1);</span><span class="s2">\n  </span><span class="s1">tokenBeforeExprs.push(options.beforeExpr ?? false);</span><span class="s2">\n  </span><span class="s1">tokenStartsExprs.push(options.startsExpr ?? false);</span><span class="s2">\n  </span><span class="s1">tokenPrefixes.push(options.prefix ?? false);</span><span class="s2">\n  </span><span class="s1">// In the exported token type, we set the label as </span><span class="s2">\&quot;</span><span class="s1">name</span><span class="s2">\&quot; </span><span class="s1">for backward compatibility with Babel 7</span><span class="s2">\n  </span><span class="s1">tokenTypes.push(new ExportedTokenType(</span><span class="s2">\&quot;</span><span class="s1">name</span><span class="s2">\&quot;</span><span class="s1">, options));</span><span class="s2">\n\n  </span><span class="s1">return tokenTypeCounter;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// For performance the token type helpers depend on the following declarations order.</span><span class="s2">\n</span><span class="s1">// When adding new token types, please also check if the token helpers need update.</span><span class="s2">\n\n</span><span class="s1">export type InternalTokenTypes = typeof tt;</span><span class="s2">\n\n</span><span class="s1">export const tt = {</span><span class="s2">\n  </span><span class="s1">// Punctuation token types.</span><span class="s2">\n  </span><span class="s1">bracketL: createToken(</span><span class="s2">\&quot;</span><span class="s1">[</span><span class="s2">\&quot;</span><span class="s1">, { beforeExpr, startsExpr }),</span><span class="s2">\n  </span><span class="s1">bracketHashL: createToken(</span><span class="s2">\&quot;</span><span class="s1">#[</span><span class="s2">\&quot;</span><span class="s1">, { beforeExpr, startsExpr }),</span><span class="s2">\n  </span><span class="s1">bracketBarL: createToken(</span><span class="s2">\&quot;</span><span class="s1">[|</span><span class="s2">\&quot;</span><span class="s1">, { beforeExpr, startsExpr }),</span><span class="s2">\n  </span><span class="s1">bracketR: createToken(</span><span class="s2">\&quot;</span><span class="s1">]</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n  </span><span class="s1">bracketBarR: createToken(</span><span class="s2">\&quot;</span><span class="s1">|]</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n  </span><span class="s1">braceL: createToken(</span><span class="s2">\&quot;</span><span class="s1">{</span><span class="s2">\&quot;</span><span class="s1">, { beforeExpr, startsExpr }),</span><span class="s2">\n  </span><span class="s1">braceBarL: createToken(</span><span class="s2">\&quot;</span><span class="s1">{|</span><span class="s2">\&quot;</span><span class="s1">, { beforeExpr, startsExpr }),</span><span class="s2">\n  </span><span class="s1">braceHashL: createToken(</span><span class="s2">\&quot;</span><span class="s1">#{</span><span class="s2">\&quot;</span><span class="s1">, { beforeExpr, startsExpr }),</span><span class="s2">\n  </span><span class="s1">braceR: createToken(</span><span class="s2">\&quot;</span><span class="s1">}</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n  </span><span class="s1">braceBarR: createToken(</span><span class="s2">\&quot;</span><span class="s1">|}</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n  </span><span class="s1">parenL: createToken(</span><span class="s2">\&quot;</span><span class="s1">(</span><span class="s2">\&quot;</span><span class="s1">, { beforeExpr, startsExpr }),</span><span class="s2">\n  </span><span class="s1">parenR: createToken(</span><span class="s2">\&quot;</span><span class="s1">)</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n  </span><span class="s1">comma: createToken(</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\&quot;</span><span class="s1">, { beforeExpr }),</span><span class="s2">\n  </span><span class="s1">semi: createToken(</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\&quot;</span><span class="s1">, { beforeExpr }),</span><span class="s2">\n  </span><span class="s1">colon: createToken(</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\&quot;</span><span class="s1">, { beforeExpr }),</span><span class="s2">\n  </span><span class="s1">doubleColon: createToken(</span><span class="s2">\&quot;</span><span class="s1">::</span><span class="s2">\&quot;</span><span class="s1">, { beforeExpr }),</span><span class="s2">\n  </span><span class="s1">dot: createToken(</span><span class="s2">\&quot;</span><span class="s1">.</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n  </span><span class="s1">question: createToken(</span><span class="s2">\&quot;</span><span class="s1">?</span><span class="s2">\&quot;</span><span class="s1">, { beforeExpr }),</span><span class="s2">\n  </span><span class="s1">questionDot: createToken(</span><span class="s2">\&quot;</span><span class="s1">?.</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n  </span><span class="s1">arrow: createToken(</span><span class="s2">\&quot;</span><span class="s1">=&gt;</span><span class="s2">\&quot;</span><span class="s1">, { beforeExpr }),</span><span class="s2">\n  </span><span class="s1">template: createToken(</span><span class="s2">\&quot;</span><span class="s1">template</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n  </span><span class="s1">ellipsis: createToken(</span><span class="s2">\&quot;</span><span class="s1">...</span><span class="s2">\&quot;</span><span class="s1">, { beforeExpr }),</span><span class="s2">\n  </span><span class="s1">backQuote: createToken(</span><span class="s2">\&quot;</span><span class="s1">`</span><span class="s2">\&quot;</span><span class="s1">, { startsExpr }),</span><span class="s2">\n  </span><span class="s1">dollarBraceL: createToken(</span><span class="s2">\&quot;</span><span class="s1">${</span><span class="s2">\&quot;</span><span class="s1">, { beforeExpr, startsExpr }),</span><span class="s2">\n  </span><span class="s1">// start: isTemplate</span><span class="s2">\n  </span><span class="s1">templateTail: createToken(</span><span class="s2">\&quot;</span><span class="s1">...`</span><span class="s2">\&quot;</span><span class="s1">, { startsExpr }),</span><span class="s2">\n  </span><span class="s1">templateNonTail: createToken(</span><span class="s2">\&quot;</span><span class="s1">...${</span><span class="s2">\&quot;</span><span class="s1">, { beforeExpr, startsExpr }),</span><span class="s2">\n  </span><span class="s1">// end: isTemplate</span><span class="s2">\n  </span><span class="s1">at: createToken(</span><span class="s2">\&quot;</span><span class="s1">@</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n  </span><span class="s1">hash: createToken(</span><span class="s2">\&quot;</span><span class="s1">#</span><span class="s2">\&quot;</span><span class="s1">, { startsExpr }),</span><span class="s2">\n\n  </span><span class="s1">// Special hashbang token.</span><span class="s2">\n  </span><span class="s1">interpreterDirective: createToken(</span><span class="s2">\&quot;</span><span class="s1">#!...</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n\n  </span><span class="s1">// Operators. These carry several kinds of properties to help the</span><span class="s2">\n  </span><span class="s1">// parser use them properly (the presence of these properties is</span><span class="s2">\n  </span><span class="s1">// what categorizes them as operators).</span><span class="s2">\n  </span><span class="s1">//</span><span class="s2">\n  </span><span class="s1">// `binop`, when present, specifies that this operator is a binary</span><span class="s2">\n  </span><span class="s1">// operator, and will refer to its precedence.</span><span class="s2">\n  </span><span class="s1">//</span><span class="s2">\n  </span><span class="s1">// `prefix` and `postfix` mark the operator as a prefix or postfix</span><span class="s2">\n  </span><span class="s1">// unary operator.</span><span class="s2">\n  </span><span class="s1">//</span><span class="s2">\n  </span><span class="s1">// `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as</span><span class="s2">\n  </span><span class="s1">// binary operators with a very low precedence, that should result</span><span class="s2">\n  </span><span class="s1">// in AssignmentExpression nodes.</span><span class="s2">\n\n  </span><span class="s1">// start: isAssign</span><span class="s2">\n  </span><span class="s1">eq: createToken(</span><span class="s2">\&quot;</span><span class="s1">=</span><span class="s2">\&quot;</span><span class="s1">, { beforeExpr, isAssign }),</span><span class="s2">\n  </span><span class="s1">assign: createToken(</span><span class="s2">\&quot;</span><span class="s1">_=</span><span class="s2">\&quot;</span><span class="s1">, { beforeExpr, isAssign }),</span><span class="s2">\n  </span><span class="s1">slashAssign: createToken(</span><span class="s2">\&quot;</span><span class="s1">_=</span><span class="s2">\&quot;</span><span class="s1">, { beforeExpr, isAssign }),</span><span class="s2">\n  </span><span class="s1">// These are only needed to support % and ^ as a Hack-pipe topic token.</span><span class="s2">\n  </span><span class="s1">// When the proposal settles on a token, the others can be merged with</span><span class="s2">\n  </span><span class="s1">// tt.assign.</span><span class="s2">\n  </span><span class="s1">xorAssign: createToken(</span><span class="s2">\&quot;</span><span class="s1">_=</span><span class="s2">\&quot;</span><span class="s1">, { beforeExpr, isAssign }),</span><span class="s2">\n  </span><span class="s1">moduloAssign: createToken(</span><span class="s2">\&quot;</span><span class="s1">_=</span><span class="s2">\&quot;</span><span class="s1">, { beforeExpr, isAssign }),</span><span class="s2">\n  </span><span class="s1">// end: isAssign</span><span class="s2">\n\n  </span><span class="s1">incDec: createToken(</span><span class="s2">\&quot;</span><span class="s1">++/--</span><span class="s2">\&quot;</span><span class="s1">, { prefix, postfix, startsExpr }),</span><span class="s2">\n  </span><span class="s1">bang: createToken(</span><span class="s2">\&quot;</span><span class="s1">!</span><span class="s2">\&quot;</span><span class="s1">, { beforeExpr, prefix, startsExpr }),</span><span class="s2">\n  </span><span class="s1">tilde: createToken(</span><span class="s2">\&quot;</span><span class="s1">~</span><span class="s2">\&quot;</span><span class="s1">, { beforeExpr, prefix, startsExpr }),</span><span class="s2">\n\n  </span><span class="s1">// More possible topic tokens.</span><span class="s2">\n  </span><span class="s1">// When the proposal settles on a token, at least one of these may be removed.</span><span class="s2">\n  </span><span class="s1">doubleCaret: createToken(</span><span class="s2">\&quot;</span><span class="s1">^^</span><span class="s2">\&quot;</span><span class="s1">, { startsExpr }),</span><span class="s2">\n  </span><span class="s1">doubleAt: createToken(</span><span class="s2">\&quot;</span><span class="s1">@@</span><span class="s2">\&quot;</span><span class="s1">, { startsExpr }),</span><span class="s2">\n\n  </span><span class="s1">// start: isBinop</span><span class="s2">\n  </span><span class="s1">pipeline: createBinop(</span><span class="s2">\&quot;</span><span class="s1">|&gt;</span><span class="s2">\&quot;</span><span class="s1">, 0),</span><span class="s2">\n  </span><span class="s1">nullishCoalescing: createBinop(</span><span class="s2">\&quot;</span><span class="s1">??</span><span class="s2">\&quot;</span><span class="s1">, 1),</span><span class="s2">\n  </span><span class="s1">logicalOR: createBinop(</span><span class="s2">\&quot;</span><span class="s1">||</span><span class="s2">\&quot;</span><span class="s1">, 1),</span><span class="s2">\n  </span><span class="s1">logicalAND: createBinop(</span><span class="s2">\&quot;</span><span class="s1">&amp;&amp;</span><span class="s2">\&quot;</span><span class="s1">, 2),</span><span class="s2">\n  </span><span class="s1">bitwiseOR: createBinop(</span><span class="s2">\&quot;</span><span class="s1">|</span><span class="s2">\&quot;</span><span class="s1">, 3),</span><span class="s2">\n  </span><span class="s1">bitwiseXOR: createBinop(</span><span class="s2">\&quot;</span><span class="s1">^</span><span class="s2">\&quot;</span><span class="s1">, 4),</span><span class="s2">\n  </span><span class="s1">bitwiseAND: createBinop(</span><span class="s2">\&quot;</span><span class="s1">&amp;</span><span class="s2">\&quot;</span><span class="s1">, 5),</span><span class="s2">\n  </span><span class="s1">equality: createBinop(</span><span class="s2">\&quot;</span><span class="s1">==/!=/===/!==</span><span class="s2">\&quot;</span><span class="s1">, 6),</span><span class="s2">\n  </span><span class="s1">lt: createBinop(</span><span class="s2">\&quot;</span><span class="s1">&lt;/&gt;/&lt;=/&gt;=</span><span class="s2">\&quot;</span><span class="s1">, 7),</span><span class="s2">\n  </span><span class="s1">gt: createBinop(</span><span class="s2">\&quot;</span><span class="s1">&lt;/&gt;/&lt;=/&gt;=</span><span class="s2">\&quot;</span><span class="s1">, 7),</span><span class="s2">\n  </span><span class="s1">relational: createBinop(</span><span class="s2">\&quot;</span><span class="s1">&lt;/&gt;/&lt;=/&gt;=</span><span class="s2">\&quot;</span><span class="s1">, 7),</span><span class="s2">\n  </span><span class="s1">bitShift: createBinop(</span><span class="s2">\&quot;</span><span class="s1">&lt;&lt;/&gt;&gt;/&gt;&gt;&gt;</span><span class="s2">\&quot;</span><span class="s1">, 8),</span><span class="s2">\n  </span><span class="s1">bitShiftL: createBinop(</span><span class="s2">\&quot;</span><span class="s1">&lt;&lt;/&gt;&gt;/&gt;&gt;&gt;</span><span class="s2">\&quot;</span><span class="s1">, 8),</span><span class="s2">\n  </span><span class="s1">bitShiftR: createBinop(</span><span class="s2">\&quot;</span><span class="s1">&lt;&lt;/&gt;&gt;/&gt;&gt;&gt;</span><span class="s2">\&quot;</span><span class="s1">, 8),</span><span class="s2">\n  </span><span class="s1">plusMin: createToken(</span><span class="s2">\&quot;</span><span class="s1">+/-</span><span class="s2">\&quot;</span><span class="s1">, { beforeExpr, binop: 9, prefix, startsExpr }),</span><span class="s2">\n  </span><span class="s1">// startsExpr: required by v8intrinsic plugin</span><span class="s2">\n  </span><span class="s1">modulo: createToken(</span><span class="s2">\&quot;</span><span class="s1">%</span><span class="s2">\&quot;</span><span class="s1">, { binop: 10, startsExpr }),</span><span class="s2">\n  </span><span class="s1">// unset `beforeExpr` as it can be `function *`</span><span class="s2">\n  </span><span class="s1">star: createToken(</span><span class="s2">\&quot;</span><span class="s1">*</span><span class="s2">\&quot;</span><span class="s1">, { binop: 10 }),</span><span class="s2">\n  </span><span class="s1">slash: createBinop(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">, 10),</span><span class="s2">\n  </span><span class="s1">exponent: createToken(</span><span class="s2">\&quot;</span><span class="s1">**</span><span class="s2">\&quot;</span><span class="s1">, {</span><span class="s2">\n    </span><span class="s1">beforeExpr,</span><span class="s2">\n    </span><span class="s1">binop: 11,</span><span class="s2">\n    </span><span class="s1">rightAssociative: true,</span><span class="s2">\n  </span><span class="s1">}),</span><span class="s2">\n\n  </span><span class="s1">// Keywords</span><span class="s2">\n  </span><span class="s1">// Don't forget to update packages/babel-helper-validator-identifier/src/keyword.js</span><span class="s2">\n  </span><span class="s1">// when new keywords are added</span><span class="s2">\n  </span><span class="s1">// start: isLiteralPropertyName</span><span class="s2">\n  </span><span class="s1">// start: isKeyword</span><span class="s2">\n  </span><span class="s1">_in: createKeyword(</span><span class="s2">\&quot;</span><span class="s1">in</span><span class="s2">\&quot;</span><span class="s1">, { beforeExpr, binop: 7 }),</span><span class="s2">\n  </span><span class="s1">_instanceof: createKeyword(</span><span class="s2">\&quot;</span><span class="s1">instanceof</span><span class="s2">\&quot;</span><span class="s1">, { beforeExpr, binop: 7 }),</span><span class="s2">\n  </span><span class="s1">// end: isBinop</span><span class="s2">\n  </span><span class="s1">_break: createKeyword(</span><span class="s2">\&quot;</span><span class="s1">break</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n  </span><span class="s1">_case: createKeyword(</span><span class="s2">\&quot;</span><span class="s1">case</span><span class="s2">\&quot;</span><span class="s1">, { beforeExpr }),</span><span class="s2">\n  </span><span class="s1">_catch: createKeyword(</span><span class="s2">\&quot;</span><span class="s1">catch</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n  </span><span class="s1">_continue: createKeyword(</span><span class="s2">\&quot;</span><span class="s1">continue</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n  </span><span class="s1">_debugger: createKeyword(</span><span class="s2">\&quot;</span><span class="s1">debugger</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n  </span><span class="s1">_default: createKeyword(</span><span class="s2">\&quot;</span><span class="s1">default</span><span class="s2">\&quot;</span><span class="s1">, { beforeExpr }),</span><span class="s2">\n  </span><span class="s1">_else: createKeyword(</span><span class="s2">\&quot;</span><span class="s1">else</span><span class="s2">\&quot;</span><span class="s1">, { beforeExpr }),</span><span class="s2">\n  </span><span class="s1">_finally: createKeyword(</span><span class="s2">\&quot;</span><span class="s1">finally</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n  </span><span class="s1">_function: createKeyword(</span><span class="s2">\&quot;</span><span class="s1">function</span><span class="s2">\&quot;</span><span class="s1">, { startsExpr }),</span><span class="s2">\n  </span><span class="s1">_if: createKeyword(</span><span class="s2">\&quot;</span><span class="s1">if</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n  </span><span class="s1">_return: createKeyword(</span><span class="s2">\&quot;</span><span class="s1">return</span><span class="s2">\&quot;</span><span class="s1">, { beforeExpr }),</span><span class="s2">\n  </span><span class="s1">_switch: createKeyword(</span><span class="s2">\&quot;</span><span class="s1">switch</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n  </span><span class="s1">_throw: createKeyword(</span><span class="s2">\&quot;</span><span class="s1">throw</span><span class="s2">\&quot;</span><span class="s1">, { beforeExpr, prefix, startsExpr }),</span><span class="s2">\n  </span><span class="s1">_try: createKeyword(</span><span class="s2">\&quot;</span><span class="s1">try</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n  </span><span class="s1">_var: createKeyword(</span><span class="s2">\&quot;</span><span class="s1">var</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n  </span><span class="s1">_const: createKeyword(</span><span class="s2">\&quot;</span><span class="s1">const</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n  </span><span class="s1">_with: createKeyword(</span><span class="s2">\&quot;</span><span class="s1">with</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n  </span><span class="s1">_new: createKeyword(</span><span class="s2">\&quot;</span><span class="s1">new</span><span class="s2">\&quot;</span><span class="s1">, { beforeExpr, startsExpr }),</span><span class="s2">\n  </span><span class="s1">_this: createKeyword(</span><span class="s2">\&quot;</span><span class="s1">this</span><span class="s2">\&quot;</span><span class="s1">, { startsExpr }),</span><span class="s2">\n  </span><span class="s1">_super: createKeyword(</span><span class="s2">\&quot;</span><span class="s1">super</span><span class="s2">\&quot;</span><span class="s1">, { startsExpr }),</span><span class="s2">\n  </span><span class="s1">_class: createKeyword(</span><span class="s2">\&quot;</span><span class="s1">class</span><span class="s2">\&quot;</span><span class="s1">, { startsExpr }),</span><span class="s2">\n  </span><span class="s1">_extends: createKeyword(</span><span class="s2">\&quot;</span><span class="s1">extends</span><span class="s2">\&quot;</span><span class="s1">, { beforeExpr }),</span><span class="s2">\n  </span><span class="s1">_export: createKeyword(</span><span class="s2">\&quot;</span><span class="s1">export</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n  </span><span class="s1">_import: createKeyword(</span><span class="s2">\&quot;</span><span class="s1">import</span><span class="s2">\&quot;</span><span class="s1">, { startsExpr }),</span><span class="s2">\n  </span><span class="s1">_null: createKeyword(</span><span class="s2">\&quot;</span><span class="s1">null</span><span class="s2">\&quot;</span><span class="s1">, { startsExpr }),</span><span class="s2">\n  </span><span class="s1">_true: createKeyword(</span><span class="s2">\&quot;</span><span class="s1">true</span><span class="s2">\&quot;</span><span class="s1">, { startsExpr }),</span><span class="s2">\n  </span><span class="s1">_false: createKeyword(</span><span class="s2">\&quot;</span><span class="s1">false</span><span class="s2">\&quot;</span><span class="s1">, { startsExpr }),</span><span class="s2">\n  </span><span class="s1">_typeof: createKeyword(</span><span class="s2">\&quot;</span><span class="s1">typeof</span><span class="s2">\&quot;</span><span class="s1">, { beforeExpr, prefix, startsExpr }),</span><span class="s2">\n  </span><span class="s1">_void: createKeyword(</span><span class="s2">\&quot;</span><span class="s1">void</span><span class="s2">\&quot;</span><span class="s1">, { beforeExpr, prefix, startsExpr }),</span><span class="s2">\n  </span><span class="s1">_delete: createKeyword(</span><span class="s2">\&quot;</span><span class="s1">delete</span><span class="s2">\&quot;</span><span class="s1">, { beforeExpr, prefix, startsExpr }),</span><span class="s2">\n  </span><span class="s1">// start: isLoop</span><span class="s2">\n  </span><span class="s1">_do: createKeyword(</span><span class="s2">\&quot;</span><span class="s1">do</span><span class="s2">\&quot;</span><span class="s1">, { isLoop, beforeExpr }),</span><span class="s2">\n  </span><span class="s1">_for: createKeyword(</span><span class="s2">\&quot;</span><span class="s1">for</span><span class="s2">\&quot;</span><span class="s1">, { isLoop }),</span><span class="s2">\n  </span><span class="s1">_while: createKeyword(</span><span class="s2">\&quot;</span><span class="s1">while</span><span class="s2">\&quot;</span><span class="s1">, { isLoop }),</span><span class="s2">\n  </span><span class="s1">// end: isLoop</span><span class="s2">\n  </span><span class="s1">// end: isKeyword</span><span class="s2">\n\n  </span><span class="s1">// Primary literals</span><span class="s2">\n  </span><span class="s1">// start: isIdentifier</span><span class="s2">\n  </span><span class="s1">_as: createKeywordLike(</span><span class="s2">\&quot;</span><span class="s1">as</span><span class="s2">\&quot;</span><span class="s1">, { startsExpr }),</span><span class="s2">\n  </span><span class="s1">_assert: createKeywordLike(</span><span class="s2">\&quot;</span><span class="s1">assert</span><span class="s2">\&quot;</span><span class="s1">, { startsExpr }),</span><span class="s2">\n  </span><span class="s1">_async: createKeywordLike(</span><span class="s2">\&quot;</span><span class="s1">async</span><span class="s2">\&quot;</span><span class="s1">, { startsExpr }),</span><span class="s2">\n  </span><span class="s1">_await: createKeywordLike(</span><span class="s2">\&quot;</span><span class="s1">await</span><span class="s2">\&quot;</span><span class="s1">, { startsExpr }),</span><span class="s2">\n  </span><span class="s1">_from: createKeywordLike(</span><span class="s2">\&quot;</span><span class="s1">from</span><span class="s2">\&quot;</span><span class="s1">, { startsExpr }),</span><span class="s2">\n  </span><span class="s1">_get: createKeywordLike(</span><span class="s2">\&quot;</span><span class="s1">get</span><span class="s2">\&quot;</span><span class="s1">, { startsExpr }),</span><span class="s2">\n  </span><span class="s1">_let: createKeywordLike(</span><span class="s2">\&quot;</span><span class="s1">let</span><span class="s2">\&quot;</span><span class="s1">, { startsExpr }),</span><span class="s2">\n  </span><span class="s1">_meta: createKeywordLike(</span><span class="s2">\&quot;</span><span class="s1">meta</span><span class="s2">\&quot;</span><span class="s1">, { startsExpr }),</span><span class="s2">\n  </span><span class="s1">_of: createKeywordLike(</span><span class="s2">\&quot;</span><span class="s1">of</span><span class="s2">\&quot;</span><span class="s1">, { startsExpr }),</span><span class="s2">\n  </span><span class="s1">_sent: createKeywordLike(</span><span class="s2">\&quot;</span><span class="s1">sent</span><span class="s2">\&quot;</span><span class="s1">, { startsExpr }),</span><span class="s2">\n  </span><span class="s1">_set: createKeywordLike(</span><span class="s2">\&quot;</span><span class="s1">set</span><span class="s2">\&quot;</span><span class="s1">, { startsExpr }),</span><span class="s2">\n  </span><span class="s1">_static: createKeywordLike(</span><span class="s2">\&quot;</span><span class="s1">static</span><span class="s2">\&quot;</span><span class="s1">, { startsExpr }),</span><span class="s2">\n  </span><span class="s1">_using: createKeywordLike(</span><span class="s2">\&quot;</span><span class="s1">using</span><span class="s2">\&quot;</span><span class="s1">, { startsExpr }),</span><span class="s2">\n  </span><span class="s1">_yield: createKeywordLike(</span><span class="s2">\&quot;</span><span class="s1">yield</span><span class="s2">\&quot;</span><span class="s1">, { startsExpr }),</span><span class="s2">\n\n  </span><span class="s1">// Flow and TypeScript Keywordlike</span><span class="s2">\n  </span><span class="s1">_asserts: createKeywordLike(</span><span class="s2">\&quot;</span><span class="s1">asserts</span><span class="s2">\&quot;</span><span class="s1">, { startsExpr }),</span><span class="s2">\n  </span><span class="s1">_checks: createKeywordLike(</span><span class="s2">\&quot;</span><span class="s1">checks</span><span class="s2">\&quot;</span><span class="s1">, { startsExpr }),</span><span class="s2">\n  </span><span class="s1">_exports: createKeywordLike(</span><span class="s2">\&quot;</span><span class="s1">exports</span><span class="s2">\&quot;</span><span class="s1">, { startsExpr }),</span><span class="s2">\n  </span><span class="s1">_global: createKeywordLike(</span><span class="s2">\&quot;</span><span class="s1">global</span><span class="s2">\&quot;</span><span class="s1">, { startsExpr }),</span><span class="s2">\n  </span><span class="s1">_implements: createKeywordLike(</span><span class="s2">\&quot;</span><span class="s1">implements</span><span class="s2">\&quot;</span><span class="s1">, { startsExpr }),</span><span class="s2">\n  </span><span class="s1">_intrinsic: createKeywordLike(</span><span class="s2">\&quot;</span><span class="s1">intrinsic</span><span class="s2">\&quot;</span><span class="s1">, { startsExpr }),</span><span class="s2">\n  </span><span class="s1">_infer: createKeywordLike(</span><span class="s2">\&quot;</span><span class="s1">infer</span><span class="s2">\&quot;</span><span class="s1">, { startsExpr }),</span><span class="s2">\n  </span><span class="s1">_is: createKeywordLike(</span><span class="s2">\&quot;</span><span class="s1">is</span><span class="s2">\&quot;</span><span class="s1">, { startsExpr }),</span><span class="s2">\n  </span><span class="s1">_mixins: createKeywordLike(</span><span class="s2">\&quot;</span><span class="s1">mixins</span><span class="s2">\&quot;</span><span class="s1">, { startsExpr }),</span><span class="s2">\n  </span><span class="s1">_proto: createKeywordLike(</span><span class="s2">\&quot;</span><span class="s1">proto</span><span class="s2">\&quot;</span><span class="s1">, { startsExpr }),</span><span class="s2">\n  </span><span class="s1">_require: createKeywordLike(</span><span class="s2">\&quot;</span><span class="s1">require</span><span class="s2">\&quot;</span><span class="s1">, { startsExpr }),</span><span class="s2">\n  </span><span class="s1">_satisfies: createKeywordLike(</span><span class="s2">\&quot;</span><span class="s1">satisfies</span><span class="s2">\&quot;</span><span class="s1">, { startsExpr }),</span><span class="s2">\n  </span><span class="s1">// start: isTSTypeOperator</span><span class="s2">\n  </span><span class="s1">_keyof: createKeywordLike(</span><span class="s2">\&quot;</span><span class="s1">keyof</span><span class="s2">\&quot;</span><span class="s1">, { startsExpr }),</span><span class="s2">\n  </span><span class="s1">_readonly: createKeywordLike(</span><span class="s2">\&quot;</span><span class="s1">readonly</span><span class="s2">\&quot;</span><span class="s1">, { startsExpr }),</span><span class="s2">\n  </span><span class="s1">_unique: createKeywordLike(</span><span class="s2">\&quot;</span><span class="s1">unique</span><span class="s2">\&quot;</span><span class="s1">, { startsExpr }),</span><span class="s2">\n  </span><span class="s1">// end: isTSTypeOperator</span><span class="s2">\n  </span><span class="s1">// start: isTSDeclarationStart</span><span class="s2">\n  </span><span class="s1">_abstract: createKeywordLike(</span><span class="s2">\&quot;</span><span class="s1">abstract</span><span class="s2">\&quot;</span><span class="s1">, { startsExpr }),</span><span class="s2">\n  </span><span class="s1">_declare: createKeywordLike(</span><span class="s2">\&quot;</span><span class="s1">declare</span><span class="s2">\&quot;</span><span class="s1">, { startsExpr }),</span><span class="s2">\n  </span><span class="s1">_enum: createKeywordLike(</span><span class="s2">\&quot;</span><span class="s1">enum</span><span class="s2">\&quot;</span><span class="s1">, { startsExpr }),</span><span class="s2">\n  </span><span class="s1">_module: createKeywordLike(</span><span class="s2">\&quot;</span><span class="s1">module</span><span class="s2">\&quot;</span><span class="s1">, { startsExpr }),</span><span class="s2">\n  </span><span class="s1">_namespace: createKeywordLike(</span><span class="s2">\&quot;</span><span class="s1">namespace</span><span class="s2">\&quot;</span><span class="s1">, { startsExpr }),</span><span class="s2">\n  </span><span class="s1">// start: isFlowInterfaceOrTypeOrOpaque</span><span class="s2">\n  </span><span class="s1">_interface: createKeywordLike(</span><span class="s2">\&quot;</span><span class="s1">interface</span><span class="s2">\&quot;</span><span class="s1">, { startsExpr }),</span><span class="s2">\n  </span><span class="s1">_type: createKeywordLike(</span><span class="s2">\&quot;</span><span class="s1">type</span><span class="s2">\&quot;</span><span class="s1">, { startsExpr }),</span><span class="s2">\n  </span><span class="s1">// end: isTSDeclarationStart</span><span class="s2">\n  </span><span class="s1">_opaque: createKeywordLike(</span><span class="s2">\&quot;</span><span class="s1">opaque</span><span class="s2">\&quot;</span><span class="s1">, { startsExpr }),</span><span class="s2">\n  </span><span class="s1">// end: isFlowInterfaceOrTypeOrOpaque</span><span class="s2">\n  </span><span class="s1">name: createToken(</span><span class="s2">\&quot;</span><span class="s1">name</span><span class="s2">\&quot;</span><span class="s1">, { startsExpr }),</span><span class="s2">\n  </span><span class="s1">// end: isIdentifier</span><span class="s2">\n\n  </span><span class="s1">string: createToken(</span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot;</span><span class="s1">, { startsExpr }),</span><span class="s2">\n  </span><span class="s1">num: createToken(</span><span class="s2">\&quot;</span><span class="s1">num</span><span class="s2">\&quot;</span><span class="s1">, { startsExpr }),</span><span class="s2">\n  </span><span class="s1">bigint: createToken(</span><span class="s2">\&quot;</span><span class="s1">bigint</span><span class="s2">\&quot;</span><span class="s1">, { startsExpr }),</span><span class="s2">\n  </span><span class="s1">decimal: createToken(</span><span class="s2">\&quot;</span><span class="s1">decimal</span><span class="s2">\&quot;</span><span class="s1">, { startsExpr }),</span><span class="s2">\n  </span><span class="s1">// end: isLiteralPropertyName</span><span class="s2">\n  </span><span class="s1">regexp: createToken(</span><span class="s2">\&quot;</span><span class="s1">regexp</span><span class="s2">\&quot;</span><span class="s1">, { startsExpr }),</span><span class="s2">\n  </span><span class="s1">privateName: createToken(</span><span class="s2">\&quot;</span><span class="s1">#name</span><span class="s2">\&quot;</span><span class="s1">, { startsExpr }),</span><span class="s2">\n  </span><span class="s1">eof: createToken(</span><span class="s2">\&quot;</span><span class="s1">eof</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n\n  </span><span class="s1">// jsx plugin</span><span class="s2">\n  </span><span class="s1">jsxName: createToken(</span><span class="s2">\&quot;</span><span class="s1">jsxName</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n  </span><span class="s1">jsxText: createToken(</span><span class="s2">\&quot;</span><span class="s1">jsxText</span><span class="s2">\&quot;</span><span class="s1">, { beforeExpr: true }),</span><span class="s2">\n  </span><span class="s1">jsxTagStart: createToken(</span><span class="s2">\&quot;</span><span class="s1">jsxTagStart</span><span class="s2">\&quot;</span><span class="s1">, { startsExpr: true }),</span><span class="s2">\n  </span><span class="s1">jsxTagEnd: createToken(</span><span class="s2">\&quot;</span><span class="s1">jsxTagEnd</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n\n  </span><span class="s1">// placeholder plugin</span><span class="s2">\n  </span><span class="s1">placeholder: createToken(</span><span class="s2">\&quot;</span><span class="s1">%%</span><span class="s2">\&quot;</span><span class="s1">, { startsExpr: true }),</span><span class="s2">\n</span><span class="s1">} as const;</span><span class="s2">\n\n</span><span class="s1">export function tokenIsIdentifier(token: TokenType): boolean {</span><span class="s2">\n  </span><span class="s1">return token &gt;= tt._as &amp;&amp; token &lt;= tt.name;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">export function tokenKeywordOrIdentifierIsKeyword(token: TokenType): boolean {</span><span class="s2">\n  </span><span class="s1">// we can remove the token &gt;= tt._in check when we</span><span class="s2">\n  </span><span class="s1">// know a token is either keyword or identifier</span><span class="s2">\n  </span><span class="s1">return token &lt;= tt._while;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">export function tokenIsKeywordOrIdentifier(token: TokenType): boolean {</span><span class="s2">\n  </span><span class="s1">return token &gt;= tt._in &amp;&amp; token &lt;= tt.name;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">export function tokenIsLiteralPropertyName(token: TokenType): boolean {</span><span class="s2">\n  </span><span class="s1">return token &gt;= tt._in &amp;&amp; token &lt;= tt.decimal;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">export function tokenComesBeforeExpression(token: TokenType): boolean {</span><span class="s2">\n  </span><span class="s1">return tokenBeforeExprs[token];</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">export function tokenCanStartExpression(token: TokenType): boolean {</span><span class="s2">\n  </span><span class="s1">return tokenStartsExprs[token];</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">export function tokenIsAssignment(token: TokenType): boolean {</span><span class="s2">\n  </span><span class="s1">return token &gt;= tt.eq &amp;&amp; token &lt;= tt.moduloAssign;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">export function tokenIsFlowInterfaceOrTypeOrOpaque(token: TokenType): boolean {</span><span class="s2">\n  </span><span class="s1">return token &gt;= tt._interface &amp;&amp; token &lt;= tt._opaque;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">export function tokenIsLoop(token: TokenType): boolean {</span><span class="s2">\n  </span><span class="s1">return token &gt;= tt._do &amp;&amp; token &lt;= tt._while;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">export function tokenIsKeyword(token: TokenType): boolean {</span><span class="s2">\n  </span><span class="s1">return token &gt;= tt._in &amp;&amp; token &lt;= tt._while;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">export function tokenIsOperator(token: TokenType): boolean {</span><span class="s2">\n  </span><span class="s1">return token &gt;= tt.pipeline &amp;&amp; token &lt;= tt._instanceof;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">export function tokenIsPostfix(token: TokenType): boolean {</span><span class="s2">\n  </span><span class="s1">return token === tt.incDec;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">export function tokenIsPrefix(token: TokenType): boolean {</span><span class="s2">\n  </span><span class="s1">return tokenPrefixes[token];</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">export function tokenIsTSTypeOperator(token: TokenType): boolean {</span><span class="s2">\n  </span><span class="s1">return token &gt;= tt._keyof &amp;&amp; token &lt;= tt._unique;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">export function tokenIsTSDeclarationStart(token: TokenType): boolean {</span><span class="s2">\n  </span><span class="s1">return token &gt;= tt._abstract &amp;&amp; token &lt;= tt._type;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">export function tokenLabelName(token: TokenType): string {</span><span class="s2">\n  </span><span class="s1">return tokenLabels[token];</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">export function tokenOperatorPrecedence(token: TokenType): number {</span><span class="s2">\n  </span><span class="s1">return tokenBinops[token];</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">export function tokenIsBinaryOperator(token: TokenType): boolean {</span><span class="s2">\n  </span><span class="s1">return tokenBinops[token] !== -1;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">export function tokenIsRightAssociative(token: TokenType): boolean {</span><span class="s2">\n  </span><span class="s1">return token === tt.exponent;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">export function tokenIsTemplate(token: TokenType): boolean {</span><span class="s2">\n  </span><span class="s1">return token &gt;= tt.templateTail &amp;&amp; token &lt;= tt.templateNonTail;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">export function getExportedToken(token: TokenType): ExportedTokenType {</span><span class="s2">\n  </span><span class="s1">return tokenTypes[token];</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">export function isTokenType(obj: any): boolean {</span><span class="s2">\n  </span><span class="s1">return typeof obj === </span><span class="s2">\&quot;</span><span class="s1">number</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">if (!process.env.BABEL_8_BREAKING) {</span><span class="s2">\n  </span><span class="s1">tokenTypes[tt.braceR].updateContext = context =&gt; {</span><span class="s2">\n    </span><span class="s1">context.pop();</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n\n  </span><span class="s1">tokenTypes[tt.braceL].updateContext =</span><span class="s2">\n    </span><span class="s1">tokenTypes[tt.braceHashL].updateContext =</span><span class="s2">\n    </span><span class="s1">tokenTypes[tt.dollarBraceL].updateContext =</span><span class="s2">\n      </span><span class="s1">context =&gt; {</span><span class="s2">\n        </span><span class="s1">context.push(tc.brace);</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n\n  </span><span class="s1">tokenTypes[tt.backQuote].updateContext = context =&gt; {</span><span class="s2">\n    </span><span class="s1">if (context[context.length - 1] === tc.template) {</span><span class="s2">\n      </span><span class="s1">context.pop();</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">context.push(tc.template);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n\n  </span><span class="s1">tokenTypes[tt.jsxTagStart].updateContext = context =&gt; {</span><span class="s2">\n    </span><span class="s1">context.push(tc.j_expr, tc.j_oTag);</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">&quot;</span><span class="s2">,</span><span class="s1">&quot;export type Pos = {</span><span class="s2">\n  </span><span class="s1">start: number;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">// These are used when `options.locations` is on, for the</span><span class="s2">\n</span><span class="s1">// `startLoc` and `endLoc` properties.</span><span class="s2">\n\n</span><span class="s1">export class Position {</span><span class="s2">\n  </span><span class="s1">line: number;</span><span class="s2">\n  </span><span class="s1">column: number;</span><span class="s2">\n  </span><span class="s1">index: number;</span><span class="s2">\n\n  </span><span class="s1">constructor(line: number, col: number, index: number) {</span><span class="s2">\n    </span><span class="s1">this.line = line;</span><span class="s2">\n    </span><span class="s1">this.column = col;</span><span class="s2">\n    </span><span class="s1">this.index = index;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">export class SourceLocation {</span><span class="s2">\n  </span><span class="s1">start: Position;</span><span class="s2">\n  </span><span class="s1">end: Position;</span><span class="s2">\n  </span><span class="s1">filename: string;</span><span class="s2">\n  </span><span class="s1">identifierName: string | undefined | null;</span><span class="s2">\n\n  </span><span class="s1">constructor(start: Position, end?: Position) {</span><span class="s2">\n    </span><span class="s1">this.start = start;</span><span class="s2">\n    </span><span class="s1">// (may start as null, but initialized later)</span><span class="s2">\n    </span><span class="s1">this.end = end;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* creates a new position with a non-zero column offset from the given position.</span><span class="s2">\n </span><span class="s1">* This function should be only be used when we create AST node out of the token</span><span class="s2">\n </span><span class="s1">* boundaries, such as TemplateElement ends before tt.templateNonTail. This</span><span class="s2">\n </span><span class="s1">* function does not skip whitespaces.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">export function createPositionWithColumnOffset(</span><span class="s2">\n  </span><span class="s1">position: Position,</span><span class="s2">\n  </span><span class="s1">columnOffset: number,</span><span class="s2">\n</span><span class="s1">) {</span><span class="s2">\n  </span><span class="s1">const { line, column, index } = position;</span><span class="s2">\n  </span><span class="s1">return new Position(line, column + columnOffset, index + columnOffset);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">&quot;</span><span class="s2">,</span><span class="s1">&quot;export const enum ParseErrorCode {</span><span class="s2">\n  </span><span class="s1">SyntaxError = </span><span class="s2">\&quot;</span><span class="s1">BABEL_PARSER_SYNTAX_ERROR</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">SourceTypeModuleError = </span><span class="s2">\&quot;</span><span class="s1">BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">export type SyntaxPlugin =</span><span class="s2">\n  </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">flow</span><span class="s2">\&quot;\n  </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">typescript</span><span class="s2">\&quot;\n  </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">jsx</span><span class="s2">\&quot;\n  </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">pipelineOperator</span><span class="s2">\&quot;\n  </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">placeholders</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">export type ToMessage&lt;ErrorDetails&gt; = (self: ErrorDetails) =&gt; string;</span><span class="s2">\n\n</span><span class="s1">export type ParseErrorCredentials&lt;ErrorDetails&gt; = {</span><span class="s2">\n  </span><span class="s1">code: ParseErrorCode;</span><span class="s2">\n  </span><span class="s1">reasonCode: string;</span><span class="s2">\n  </span><span class="s1">syntaxPlugin?: SyntaxPlugin;</span><span class="s2">\n  </span><span class="s1">toMessage: ToMessage&lt;ErrorDetails&gt;;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">const reflect = (keys: string[], last = keys.length - 1) =&gt; ({</span><span class="s2">\n  </span><span class="s1">get(this: unknown): unknown {</span><span class="s2">\n    </span><span class="s1">return keys.reduce(</span><span class="s2">\n      </span><span class="s1">(object, key) =&gt;</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error key should index object</span><span class="s2">\n        </span><span class="s1">object[key],</span><span class="s2">\n      </span><span class="s1">this,</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">},</span><span class="s2">\n  </span><span class="s1">set(this: unknown, value: unknown) {</span><span class="s2">\n    </span><span class="s1">keys.reduce(</span><span class="s2">\n      </span><span class="s1">// @ts-expect-error key should index item</span><span class="s2">\n      </span><span class="s1">(item, key, i) =&gt; (i === last ? (item[key] = value) : item[key]),</span><span class="s2">\n      </span><span class="s1">this,</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">},</span><span class="s2">\n</span><span class="s1">});</span><span class="s2">\n\n</span><span class="s1">const instantiate = &lt;T&gt;(</span><span class="s2">\n  </span><span class="s1">constructor: new () =&gt; T,</span><span class="s2">\n  </span><span class="s1">properties: any,</span><span class="s2">\n  </span><span class="s1">descriptors: any,</span><span class="s2">\n</span><span class="s1">) =&gt;</span><span class="s2">\n  </span><span class="s1">Object.keys(descriptors)</span><span class="s2">\n    </span><span class="s1">.map(key =&gt; [key, descriptors[key]])</span><span class="s2">\n    </span><span class="s1">.filter(([, descriptor]) =&gt; !!descriptor)</span><span class="s2">\n    </span><span class="s1">.map(([key, descriptor]) =&gt; [</span><span class="s2">\n      </span><span class="s1">key,</span><span class="s2">\n      </span><span class="s1">typeof descriptor === </span><span class="s2">\&quot;</span><span class="s1">function</span><span class="s2">\&quot;\n        </span><span class="s1">? { value: descriptor, enumerable: false }</span><span class="s2">\n        </span><span class="s1">: typeof descriptor.reflect === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot;\n        </span><span class="s1">? { ...descriptor, ...reflect(descriptor.reflect.split(</span><span class="s2">\&quot;</span><span class="s1">.</span><span class="s2">\&quot;</span><span class="s1">)) }</span><span class="s2">\n        </span><span class="s1">: descriptor,</span><span class="s2">\n    </span><span class="s1">])</span><span class="s2">\n    </span><span class="s1">.reduce(</span><span class="s2">\n      </span><span class="s1">(instance, [key, descriptor]) =&gt;</span><span class="s2">\n        </span><span class="s1">Object.defineProperty(instance, key, {</span><span class="s2">\n          </span><span class="s1">configurable: true,</span><span class="s2">\n          </span><span class="s1">...descriptor,</span><span class="s2">\n        </span><span class="s1">}),</span><span class="s2">\n      </span><span class="s1">Object.assign(new constructor(), properties),</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n\n</span><span class="s1">export { instantiate };</span><span class="s2">\n</span><span class="s1">&quot;</span><span class="s2">,</span><span class="s1">&quot;import { ParseErrorCode } from </span><span class="s2">\&quot;</span><span class="s1">../parse-error</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">export default {</span><span class="s2">\n  </span><span class="s1">ImportMetaOutsideModule: {</span><span class="s2">\n    </span><span class="s1">message: `import.meta may appear only with 'sourceType: </span><span class="s2">\&quot;</span><span class="s1">module</span><span class="s2">\&quot;</span><span class="s1">'`,</span><span class="s2">\n    </span><span class="s1">code: ParseErrorCode.SourceTypeModuleError,</span><span class="s2">\n  </span><span class="s1">},</span><span class="s2">\n  </span><span class="s1">ImportOutsideModule: {</span><span class="s2">\n    </span><span class="s1">message: `'import' and 'export' may appear only with 'sourceType: </span><span class="s2">\&quot;</span><span class="s1">module</span><span class="s2">\&quot;</span><span class="s1">'`,</span><span class="s2">\n    </span><span class="s1">code: ParseErrorCode.SourceTypeModuleError,</span><span class="s2">\n  </span><span class="s1">},</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">&quot;</span><span class="s2">,</span><span class="s1">&quot;const NodeDescriptions = {</span><span class="s2">\n  </span><span class="s1">ArrayPattern: </span><span class="s2">\&quot;</span><span class="s1">array destructuring pattern</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">AssignmentExpression: </span><span class="s2">\&quot;</span><span class="s1">assignment expression</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">AssignmentPattern: </span><span class="s2">\&quot;</span><span class="s1">assignment expression</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ArrowFunctionExpression: </span><span class="s2">\&quot;</span><span class="s1">arrow function expression</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ConditionalExpression: </span><span class="s2">\&quot;</span><span class="s1">conditional expression</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">CatchClause: </span><span class="s2">\&quot;</span><span class="s1">catch clause</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ForOfStatement: </span><span class="s2">\&quot;</span><span class="s1">for-of statement</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ForInStatement: </span><span class="s2">\&quot;</span><span class="s1">for-in statement</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ForStatement: </span><span class="s2">\&quot;</span><span class="s1">for-loop</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">FormalParameters: </span><span class="s2">\&quot;</span><span class="s1">function parameter list</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">Identifier: </span><span class="s2">\&quot;</span><span class="s1">identifier</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ImportSpecifier: </span><span class="s2">\&quot;</span><span class="s1">import specifier</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ImportDefaultSpecifier: </span><span class="s2">\&quot;</span><span class="s1">import default specifier</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ImportNamespaceSpecifier: </span><span class="s2">\&quot;</span><span class="s1">import namespace specifier</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ObjectPattern: </span><span class="s2">\&quot;</span><span class="s1">object destructuring pattern</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ParenthesizedExpression: </span><span class="s2">\&quot;</span><span class="s1">parenthesized expression</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">RestElement: </span><span class="s2">\&quot;</span><span class="s1">rest element</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">UpdateExpression: {</span><span class="s2">\n    </span><span class="s1">true: </span><span class="s2">\&quot;</span><span class="s1">prefix operation</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">false: </span><span class="s2">\&quot;</span><span class="s1">postfix operation</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">},</span><span class="s2">\n  </span><span class="s1">VariableDeclarator: </span><span class="s2">\&quot;</span><span class="s1">variable declaration</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">YieldExpression: </span><span class="s2">\&quot;</span><span class="s1">yield expression</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">type NodeTypesWithDescriptions = keyof Omit&lt;</span><span class="s2">\n  </span><span class="s1">typeof NodeDescriptions,</span><span class="s2">\n  \&quot;</span><span class="s1">UpdateExpression</span><span class="s2">\&quot;\n</span><span class="s1">&gt;;</span><span class="s2">\n\n</span><span class="s1">type NodeWithDescription =</span><span class="s2">\n  </span><span class="s1">| {</span><span class="s2">\n      </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">UpdateExpression</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n      </span><span class="s1">prefix: boolean;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">| {</span><span class="s2">\n      </span><span class="s1">type: NodeTypesWithDescriptions;</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">// @ts-expect-error prefix is specified only when type is UpdateExpression</span><span class="s2">\n</span><span class="s1">// eslint-disable-next-line no-confusing-arrow</span><span class="s2">\n</span><span class="s1">const toNodeDescription = ({ type, prefix }: NodeWithDescription) =&gt;</span><span class="s2">\n  </span><span class="s1">type === </span><span class="s2">\&quot;</span><span class="s1">UpdateExpression</span><span class="s2">\&quot;\n    </span><span class="s1">? NodeDescriptions.UpdateExpression[String(prefix) as </span><span class="s2">\&quot;</span><span class="s1">true</span><span class="s2">\&quot; </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">false</span><span class="s2">\&quot;</span><span class="s1">]</span><span class="s2">\n    </span><span class="s1">: NodeDescriptions[type];</span><span class="s2">\n\n</span><span class="s1">export default toNodeDescription;</span><span class="s2">\n</span><span class="s1">&quot;</span><span class="s2">,</span><span class="s1">&quot;import toNodeDescription from </span><span class="s2">\&quot;</span><span class="s1">./to-node-description</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">export type LValAncestor =</span><span class="s2">\n  </span><span class="s1">| { type: </span><span class="s2">\&quot;</span><span class="s1">UpdateExpression</span><span class="s2">\&quot;</span><span class="s1">; prefix: boolean }</span><span class="s2">\n  </span><span class="s1">| {</span><span class="s2">\n      </span><span class="s1">type:</span><span class="s2">\n        </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">ArrayPattern</span><span class="s2">\&quot;\n        </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">AssignmentExpression</span><span class="s2">\&quot;\n        </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">CatchClause</span><span class="s2">\&quot;\n        </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">ForOfStatement</span><span class="s2">\&quot;\n        </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">FormalParameters</span><span class="s2">\&quot;\n        </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">ForInStatement</span><span class="s2">\&quot;\n        </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">ForStatement</span><span class="s2">\&quot;\n        </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">ImportSpecifier</span><span class="s2">\&quot;\n        </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">ImportNamespaceSpecifier</span><span class="s2">\&quot;\n        </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">ImportDefaultSpecifier</span><span class="s2">\&quot;\n        </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">ParenthesizedExpression</span><span class="s2">\&quot;\n        </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">ObjectPattern</span><span class="s2">\&quot;\n        </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">RestElement</span><span class="s2">\&quot;\n        </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">VariableDeclarator</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">export default {</span><span class="s2">\n  </span><span class="s1">AccessorIsGenerator: ({ kind }: { kind: </span><span class="s2">\&quot;</span><span class="s1">get</span><span class="s2">\&quot; </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">set</span><span class="s2">\&quot; </span><span class="s1">}) =&gt;</span><span class="s2">\n    </span><span class="s1">`A ${kind}ter cannot be a generator.`,</span><span class="s2">\n  </span><span class="s1">ArgumentsInClass:</span><span class="s2">\n    \&quot;</span><span class="s1">'arguments' is only allowed in functions and class methods.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">AsyncFunctionInSingleStatementContext:</span><span class="s2">\n    \&quot;</span><span class="s1">Async functions can only be declared at the top level or inside a block.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">AwaitBindingIdentifier:</span><span class="s2">\n    \&quot;</span><span class="s1">Can not use 'await' as identifier inside an async function.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">AwaitBindingIdentifierInStaticBlock:</span><span class="s2">\n    \&quot;</span><span class="s1">Can not use 'await' as identifier inside a static block.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">AwaitExpressionFormalParameter:</span><span class="s2">\n    \&quot;</span><span class="s1">'await' is not allowed in async function parameters.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">AwaitInUsingBinding:</span><span class="s2">\n    \&quot;</span><span class="s1">'await' is not allowed to be used as a name in 'using' declarations.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">AwaitNotInAsyncContext:</span><span class="s2">\n    \&quot;</span><span class="s1">'await' is only allowed within async functions and at the top levels of modules.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">AwaitNotInAsyncFunction: </span><span class="s2">\&quot;</span><span class="s1">'await' is only allowed within async functions.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">BadGetterArity: </span><span class="s2">\&quot;</span><span class="s1">A 'get' accessor must not have any formal parameters.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">BadSetterArity: </span><span class="s2">\&quot;</span><span class="s1">A 'set' accessor must have exactly one formal parameter.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">BadSetterRestParameter:</span><span class="s2">\n    \&quot;</span><span class="s1">A 'set' accessor function argument must not be a rest parameter.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ConstructorClassField: </span><span class="s2">\&quot;</span><span class="s1">Classes may not have a field named 'constructor'.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ConstructorClassPrivateField:</span><span class="s2">\n    \&quot;</span><span class="s1">Classes may not have a private field named '#constructor'.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ConstructorIsAccessor: </span><span class="s2">\&quot;</span><span class="s1">Class constructor may not be an accessor.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ConstructorIsAsync: </span><span class="s2">\&quot;</span><span class="s1">Constructor can't be an async function.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ConstructorIsGenerator: </span><span class="s2">\&quot;</span><span class="s1">Constructor can't be a generator.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">DeclarationMissingInitializer: ({</span><span class="s2">\n    </span><span class="s1">kind,</span><span class="s2">\n  </span><span class="s1">}: {</span><span class="s2">\n    </span><span class="s1">kind: </span><span class="s2">\&quot;</span><span class="s1">const</span><span class="s2">\&quot; </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">destructuring</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">}) =&gt; `Missing initializer in ${kind} declaration.`,</span><span class="s2">\n  </span><span class="s1">DecoratorArgumentsOutsideParentheses:</span><span class="s2">\n    \&quot;</span><span class="s1">Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">DecoratorBeforeExport:</span><span class="s2">\n    \&quot;</span><span class="s1">Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">DecoratorsBeforeAfterExport:</span><span class="s2">\n    \&quot;</span><span class="s1">Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">DecoratorConstructor:</span><span class="s2">\n    \&quot;</span><span class="s1">Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">DecoratorExportClass:</span><span class="s2">\n    \&quot;</span><span class="s1">Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">DecoratorSemicolon: </span><span class="s2">\&quot;</span><span class="s1">Decorators must not be followed by a semicolon.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">DecoratorStaticBlock: </span><span class="s2">\&quot;</span><span class="s1">Decorators can't be used with a static block.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">DeletePrivateField: </span><span class="s2">\&quot;</span><span class="s1">Deleting a private field is not allowed.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">DestructureNamedImport:</span><span class="s2">\n    \&quot;</span><span class="s1">ES2015 named imports do not destructure. Use another statement for destructuring after the import.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">DuplicateConstructor: </span><span class="s2">\&quot;</span><span class="s1">Duplicate constructor in the same class.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">DuplicateDefaultExport: </span><span class="s2">\&quot;</span><span class="s1">Only one default export allowed per module.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">DuplicateExport: ({ exportName }: { exportName: string }) =&gt;</span><span class="s2">\n    </span><span class="s1">`</span><span class="s2">\\</span><span class="s1">`${exportName}</span><span class="s2">\\</span><span class="s1">` has already been exported. Exported identifiers must be unique.`,</span><span class="s2">\n  </span><span class="s1">DuplicateProto: </span><span class="s2">\&quot;</span><span class="s1">Redefinition of __proto__ property.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">DuplicateRegExpFlags: </span><span class="s2">\&quot;</span><span class="s1">Duplicate regular expression flag.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ElementAfterRest: </span><span class="s2">\&quot;</span><span class="s1">Rest element must be last element.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">EscapedCharNotAnIdentifier: </span><span class="s2">\&quot;</span><span class="s1">Invalid Unicode escape.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ExportBindingIsString: ({</span><span class="s2">\n    </span><span class="s1">localName,</span><span class="s2">\n    </span><span class="s1">exportName,</span><span class="s2">\n  </span><span class="s1">}: {</span><span class="s2">\n    </span><span class="s1">localName: string;</span><span class="s2">\n    </span><span class="s1">exportName: string;</span><span class="s2">\n  </span><span class="s1">}) =&gt;</span><span class="s2">\n    </span><span class="s1">`A string literal cannot be used as an exported binding without </span><span class="s2">\\</span><span class="s1">`from</span><span class="s2">\\</span><span class="s1">`.</span><span class="s2">\\</span><span class="s1">n- Did you mean </span><span class="s2">\\</span><span class="s1">`export { '${localName}' as '${exportName}' } from 'some-module'</span><span class="s2">\\</span><span class="s1">`?`,</span><span class="s2">\n  </span><span class="s1">ExportDefaultFromAsIdentifier:</span><span class="s2">\n    \&quot;</span><span class="s1">'from' is not allowed as an identifier after 'export default'.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n\n  </span><span class="s1">ForInOfLoopInitializer: ({</span><span class="s2">\n    </span><span class="s1">type,</span><span class="s2">\n  </span><span class="s1">}: {</span><span class="s2">\n    </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">ForInStatement</span><span class="s2">\&quot; </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">ForOfStatement</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">}) =&gt;</span><span class="s2">\n    </span><span class="s1">`'${</span><span class="s2">\n      </span><span class="s1">type === </span><span class="s2">\&quot;</span><span class="s1">ForInStatement</span><span class="s2">\&quot; </span><span class="s1">? </span><span class="s2">\&quot;</span><span class="s1">for-in</span><span class="s2">\&quot; </span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">for-of</span><span class="s2">\&quot;\n    </span><span class="s1">}' loop variable declaration may not have an initializer.`,</span><span class="s2">\n  </span><span class="s1">ForInUsing: </span><span class="s2">\&quot;</span><span class="s1">For-in loop may not start with 'using' declaration.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n\n  </span><span class="s1">ForOfAsync: </span><span class="s2">\&quot;</span><span class="s1">The left-hand side of a for-of loop may not be 'async'.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ForOfLet: </span><span class="s2">\&quot;</span><span class="s1">The left-hand side of a for-of loop may not start with 'let'.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">GeneratorInSingleStatementContext:</span><span class="s2">\n    \&quot;</span><span class="s1">Generators can only be declared at the top level or inside a block.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n\n  </span><span class="s1">IllegalBreakContinue: ({</span><span class="s2">\n    </span><span class="s1">type,</span><span class="s2">\n  </span><span class="s1">}: {</span><span class="s2">\n    </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">BreakStatement</span><span class="s2">\&quot; </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">ContinueStatement</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">}) =&gt; `Unsyntactic ${type === </span><span class="s2">\&quot;</span><span class="s1">BreakStatement</span><span class="s2">\&quot; </span><span class="s1">? </span><span class="s2">\&quot;</span><span class="s1">break</span><span class="s2">\&quot; </span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">continue</span><span class="s2">\&quot;</span><span class="s1">}.`,</span><span class="s2">\n\n  </span><span class="s1">IllegalLanguageModeDirective:</span><span class="s2">\n    \&quot;</span><span class="s1">Illegal 'use strict' directive in function with non-simple parameter list.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">IllegalReturn: </span><span class="s2">\&quot;</span><span class="s1">'return' outside of function.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ImportBindingIsString: ({ importName }: { importName: string }) =&gt;</span><span class="s2">\n    </span><span class="s1">`A string literal cannot be used as an imported binding.</span><span class="s2">\\</span><span class="s1">n- Did you mean </span><span class="s2">\\</span><span class="s1">`import { </span><span class="s2">\&quot;</span><span class="s1">${importName}</span><span class="s2">\&quot; </span><span class="s1">as foo }</span><span class="s2">\\</span><span class="s1">`?`,</span><span class="s2">\n  </span><span class="s1">ImportCallArgumentTrailingComma:</span><span class="s2">\n    \&quot;</span><span class="s1">Trailing comma is disallowed inside import(...) arguments.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ImportCallArity: ({ maxArgumentCount }: { maxArgumentCount: 1 | 2 }) =&gt;</span><span class="s2">\n    </span><span class="s1">`</span><span class="s2">\\</span><span class="s1">`import()</span><span class="s2">\\</span><span class="s1">` requires exactly ${</span><span class="s2">\n      </span><span class="s1">maxArgumentCount === 1 ? </span><span class="s2">\&quot;</span><span class="s1">one argument</span><span class="s2">\&quot; </span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">one or two arguments</span><span class="s2">\&quot;\n    </span><span class="s1">}.`,</span><span class="s2">\n  </span><span class="s1">ImportCallNotNewExpression: </span><span class="s2">\&quot;</span><span class="s1">Cannot use new with import(...).</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ImportCallSpreadArgument: </span><span class="s2">\&quot;</span><span class="s1">`...` is not allowed in `import()`.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ImportJSONBindingNotDefault:</span><span class="s2">\n    \&quot;</span><span class="s1">A JSON module can only be imported with `default`.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ImportReflectionHasAssertion: </span><span class="s2">\&quot;</span><span class="s1">`import module x` cannot have assertions.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ImportReflectionNotBinding:</span><span class="s2">\n    </span><span class="s1">'Only `import module x from </span><span class="s2">\&quot;</span><span class="s1">./module</span><span class="s2">\&quot;</span><span class="s1">` is valid.',</span><span class="s2">\n  </span><span class="s1">IncompatibleRegExpUVFlags:</span><span class="s2">\n    \&quot;</span><span class="s1">The 'u' and 'v' regular expression flags cannot be enabled at the same time.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">InvalidBigIntLiteral: </span><span class="s2">\&quot;</span><span class="s1">Invalid BigIntLiteral.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">InvalidCodePoint: </span><span class="s2">\&quot;</span><span class="s1">Code point out of bounds.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">InvalidCoverInitializedName: </span><span class="s2">\&quot;</span><span class="s1">Invalid shorthand property initializer.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">InvalidDecimal: </span><span class="s2">\&quot;</span><span class="s1">Invalid decimal.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">InvalidDigit: ({ radix }: { radix: number }) =&gt;</span><span class="s2">\n    </span><span class="s1">`Expected number in radix ${radix}.`,</span><span class="s2">\n  </span><span class="s1">InvalidEscapeSequence: </span><span class="s2">\&quot;</span><span class="s1">Bad character escape sequence.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">InvalidEscapeSequenceTemplate: </span><span class="s2">\&quot;</span><span class="s1">Invalid escape sequence in template.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">InvalidEscapedReservedWord: ({ reservedWord }: { reservedWord: string }) =&gt;</span><span class="s2">\n    </span><span class="s1">`Escape sequence in keyword ${reservedWord}.`,</span><span class="s2">\n  </span><span class="s1">InvalidIdentifier: ({ identifierName }: { identifierName: string }) =&gt;</span><span class="s2">\n    </span><span class="s1">`Invalid identifier ${identifierName}.`,</span><span class="s2">\n  </span><span class="s1">InvalidLhs: ({ ancestor }: { ancestor: LValAncestor }) =&gt;</span><span class="s2">\n    </span><span class="s1">`Invalid left-hand side in ${toNodeDescription(ancestor)}.`,</span><span class="s2">\n  </span><span class="s1">InvalidLhsBinding: ({ ancestor }: { ancestor: LValAncestor }) =&gt;</span><span class="s2">\n    </span><span class="s1">`Binding invalid left-hand side in ${toNodeDescription(ancestor)}.`,</span><span class="s2">\n  </span><span class="s1">InvalidNumber: </span><span class="s2">\&quot;</span><span class="s1">Invalid number.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">InvalidOrMissingExponent:</span><span class="s2">\n    \&quot;</span><span class="s1">Floating-point numbers require a valid exponent after the 'e'.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">InvalidOrUnexpectedToken: ({ unexpected }: { unexpected: string }) =&gt;</span><span class="s2">\n    </span><span class="s1">`Unexpected character '${unexpected}'.`,</span><span class="s2">\n  </span><span class="s1">InvalidParenthesizedAssignment: </span><span class="s2">\&quot;</span><span class="s1">Invalid parenthesized assignment pattern.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">InvalidPrivateFieldResolution: ({</span><span class="s2">\n    </span><span class="s1">identifierName,</span><span class="s2">\n  </span><span class="s1">}: {</span><span class="s2">\n    </span><span class="s1">identifierName: string;</span><span class="s2">\n  </span><span class="s1">}) =&gt; `Private name #${identifierName} is not defined.`,</span><span class="s2">\n  </span><span class="s1">InvalidPropertyBindingPattern: </span><span class="s2">\&quot;</span><span class="s1">Binding member expression.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">InvalidRecordProperty:</span><span class="s2">\n    \&quot;</span><span class="s1">Only properties and spread elements are allowed in record definitions.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">InvalidRestAssignmentPattern: </span><span class="s2">\&quot;</span><span class="s1">Invalid rest operator's argument.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">LabelRedeclaration: ({ labelName }: { labelName: string }) =&gt;</span><span class="s2">\n    </span><span class="s1">`Label '${labelName}' is already declared.`,</span><span class="s2">\n  </span><span class="s1">LetInLexicalBinding:</span><span class="s2">\n    \&quot;</span><span class="s1">'let' is not allowed to be used as a name in 'let' or 'const' declarations.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">LineTerminatorBeforeArrow: </span><span class="s2">\&quot;</span><span class="s1">No line break is allowed before '=&gt;'.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">MalformedRegExpFlags: </span><span class="s2">\&quot;</span><span class="s1">Invalid regular expression flag.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">MissingClassName: </span><span class="s2">\&quot;</span><span class="s1">A class name is required.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">MissingEqInAssignment:</span><span class="s2">\n    \&quot;</span><span class="s1">Only '=' operator can be used for specifying default value.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">MissingSemicolon: </span><span class="s2">\&quot;</span><span class="s1">Missing semicolon.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">MissingPlugin: ({ missingPlugin }: { missingPlugin: [string] }) =&gt;</span><span class="s2">\n    </span><span class="s1">`This experimental syntax requires enabling the parser plugin: ${missingPlugin</span><span class="s2">\n      </span><span class="s1">.map(name =&gt; JSON.stringify(name))</span><span class="s2">\n      </span><span class="s1">.join(</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">)}.`,</span><span class="s2">\n  </span><span class="s1">// FIXME: Would be nice to make this </span><span class="s2">\&quot;</span><span class="s1">missingPlugins</span><span class="s2">\&quot; </span><span class="s1">instead.</span><span class="s2">\n  </span><span class="s1">// Also, seems like we can drop the </span><span class="s2">\&quot;</span><span class="s1">(s)</span><span class="s2">\&quot; </span><span class="s1">from the message and just make it </span><span class="s2">\&quot;</span><span class="s1">s</span><span class="s2">\&quot;</span><span class="s1">.</span><span class="s2">\n  </span><span class="s1">MissingOneOfPlugins: ({ missingPlugin }: { missingPlugin: string[] }) =&gt;</span><span class="s2">\n    </span><span class="s1">`This experimental syntax requires enabling one of the following parser plugin(s): ${missingPlugin</span><span class="s2">\n      </span><span class="s1">.map(name =&gt; JSON.stringify(name))</span><span class="s2">\n      </span><span class="s1">.join(</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">)}.`,</span><span class="s2">\n  </span><span class="s1">MissingUnicodeEscape: </span><span class="s2">\&quot;</span><span class="s1">Expecting Unicode escape sequence </span><span class="s2">\\\\</span><span class="s1">uXXXX.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">MixingCoalesceWithLogical:</span><span class="s2">\n    \&quot;</span><span class="s1">Nullish coalescing operator(??) requires parens when mixing with logical operators.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ModuleAttributeDifferentFromType:</span><span class="s2">\n    \&quot;</span><span class="s1">The only accepted module attribute is `type`.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ModuleAttributeInvalidValue:</span><span class="s2">\n    \&quot;</span><span class="s1">Only string literals are allowed as module attribute values.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ModuleAttributesWithDuplicateKeys: ({ key }: { key: string }) =&gt;</span><span class="s2">\n    </span><span class="s1">`Duplicate key </span><span class="s2">\&quot;</span><span class="s1">${key}</span><span class="s2">\&quot; </span><span class="s1">is not allowed in module attributes.`,</span><span class="s2">\n  </span><span class="s1">ModuleExportNameHasLoneSurrogate: ({</span><span class="s2">\n    </span><span class="s1">surrogateCharCode,</span><span class="s2">\n  </span><span class="s1">}: {</span><span class="s2">\n    </span><span class="s1">surrogateCharCode: number;</span><span class="s2">\n  </span><span class="s1">}) =&gt;</span><span class="s2">\n    </span><span class="s1">`An export name cannot include a lone surrogate, found '</span><span class="s2">\\\\</span><span class="s1">u${surrogateCharCode.toString(</span><span class="s2">\n      </span><span class="s1">16,</span><span class="s2">\n    </span><span class="s1">)}'.`,</span><span class="s2">\n  </span><span class="s1">ModuleExportUndefined: ({ localName }: { localName: string }) =&gt;</span><span class="s2">\n    </span><span class="s1">`Export '${localName}' is not defined.`,</span><span class="s2">\n  </span><span class="s1">MultipleDefaultsInSwitch: </span><span class="s2">\&quot;</span><span class="s1">Multiple default clauses.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">NewlineAfterThrow: </span><span class="s2">\&quot;</span><span class="s1">Illegal newline after throw.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">NoCatchOrFinally: </span><span class="s2">\&quot;</span><span class="s1">Missing catch or finally clause.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">NumberIdentifier: </span><span class="s2">\&quot;</span><span class="s1">Identifier directly after number.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">NumericSeparatorInEscapeSequence:</span><span class="s2">\n    \&quot;</span><span class="s1">Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ObsoleteAwaitStar:</span><span class="s2">\n    \&quot;</span><span class="s1">'await*' has been removed from the async functions proposal. Use Promise.all() instead.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">OptionalChainingNoNew:</span><span class="s2">\n    \&quot;</span><span class="s1">Constructors in/after an Optional Chain are not allowed.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">OptionalChainingNoTemplate:</span><span class="s2">\n    \&quot;</span><span class="s1">Tagged Template Literals are not allowed in optionalChain.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">OverrideOnConstructor:</span><span class="s2">\n    \&quot;</span><span class="s1">'override' modifier cannot appear on a constructor declaration.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ParamDupe: </span><span class="s2">\&quot;</span><span class="s1">Argument name clash.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">PatternHasAccessor: </span><span class="s2">\&quot;</span><span class="s1">Object pattern can't contain getter or setter.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">PatternHasMethod: </span><span class="s2">\&quot;</span><span class="s1">Object pattern can't contain methods.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">PrivateInExpectedIn: ({ identifierName }: { identifierName: string }) =&gt;</span><span class="s2">\n    </span><span class="s1">`Private names are only allowed in property accesses (</span><span class="s2">\\</span><span class="s1">`obj.#${identifierName}</span><span class="s2">\\</span><span class="s1">`) or in </span><span class="s2">\\</span><span class="s1">`in</span><span class="s2">\\</span><span class="s1">` expressions (</span><span class="s2">\\</span><span class="s1">`#${identifierName} in obj</span><span class="s2">\\</span><span class="s1">`).`,</span><span class="s2">\n  </span><span class="s1">PrivateNameRedeclaration: ({ identifierName }: { identifierName: string }) =&gt;</span><span class="s2">\n    </span><span class="s1">`Duplicate private name #${identifierName}.`,</span><span class="s2">\n  </span><span class="s1">RecordExpressionBarIncorrectEndSyntaxType:</span><span class="s2">\n    \&quot;</span><span class="s1">Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">RecordExpressionBarIncorrectStartSyntaxType:</span><span class="s2">\n    \&quot;</span><span class="s1">Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">RecordExpressionHashIncorrectStartSyntaxType:</span><span class="s2">\n    \&quot;</span><span class="s1">Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">RecordNoProto: </span><span class="s2">\&quot;</span><span class="s1">'__proto__' is not allowed in Record expressions.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">RestTrailingComma: </span><span class="s2">\&quot;</span><span class="s1">Unexpected trailing comma after rest element.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">SloppyFunction:</span><span class="s2">\n    \&quot;</span><span class="s1">In non-strict mode code, functions can only be declared at top level or inside a block.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">SloppyFunctionAnnexB:</span><span class="s2">\n    \&quot;</span><span class="s1">In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">StaticPrototype: </span><span class="s2">\&quot;</span><span class="s1">Classes may not have static property named prototype.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">SuperNotAllowed:</span><span class="s2">\n    \&quot;</span><span class="s1">`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">SuperPrivateField: </span><span class="s2">\&quot;</span><span class="s1">Private fields can't be accessed on super.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">TrailingDecorator: </span><span class="s2">\&quot;</span><span class="s1">Decorators must be attached to a class element.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">TupleExpressionBarIncorrectEndSyntaxType:</span><span class="s2">\n    \&quot;</span><span class="s1">Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">TupleExpressionBarIncorrectStartSyntaxType:</span><span class="s2">\n    \&quot;</span><span class="s1">Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">TupleExpressionHashIncorrectStartSyntaxType:</span><span class="s2">\n    \&quot;</span><span class="s1">Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">UnexpectedArgumentPlaceholder: </span><span class="s2">\&quot;</span><span class="s1">Unexpected argument placeholder.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">UnexpectedAwaitAfterPipelineBody:</span><span class="s2">\n    </span><span class="s1">'Unexpected </span><span class="s2">\&quot;</span><span class="s1">await</span><span class="s2">\&quot; </span><span class="s1">after pipeline body; await must have parentheses in minimal proposal.',</span><span class="s2">\n  </span><span class="s1">UnexpectedDigitAfterHash: </span><span class="s2">\&quot;</span><span class="s1">Unexpected digit after hash token.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">UnexpectedImportExport:</span><span class="s2">\n    \&quot;</span><span class="s1">'import' and 'export' may only appear at the top level.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">UnexpectedKeyword: ({ keyword }: { keyword: string }) =&gt;</span><span class="s2">\n    </span><span class="s1">`Unexpected keyword '${keyword}'.`,</span><span class="s2">\n  </span><span class="s1">UnexpectedLeadingDecorator:</span><span class="s2">\n    \&quot;</span><span class="s1">Leading decorators must be attached to a class declaration.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">UnexpectedLexicalDeclaration:</span><span class="s2">\n    \&quot;</span><span class="s1">Lexical declaration cannot appear in a single-statement context.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">UnexpectedNewTarget:</span><span class="s2">\n    \&quot;</span><span class="s1">`new.target` can only be used in functions or class properties.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">UnexpectedNumericSeparator:</span><span class="s2">\n    \&quot;</span><span class="s1">A numeric separator is only allowed between two digits.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">UnexpectedPrivateField: </span><span class="s2">\&quot;</span><span class="s1">Unexpected private name.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">UnexpectedReservedWord: ({ reservedWord }: { reservedWord: string }) =&gt;</span><span class="s2">\n    </span><span class="s1">`Unexpected reserved word '${reservedWord}'.`,</span><span class="s2">\n  </span><span class="s1">UnexpectedSuper: </span><span class="s2">\&quot;</span><span class="s1">'super' is only allowed in object methods and classes.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">UnexpectedToken: ({</span><span class="s2">\n    </span><span class="s1">expected,</span><span class="s2">\n    </span><span class="s1">unexpected,</span><span class="s2">\n  </span><span class="s1">}: {</span><span class="s2">\n    </span><span class="s1">expected?: string | null;</span><span class="s2">\n    </span><span class="s1">unexpected?: string | null;</span><span class="s2">\n  </span><span class="s1">}) =&gt;</span><span class="s2">\n    </span><span class="s1">`Unexpected token${unexpected ? ` '${unexpected}'.` : </span><span class="s2">\&quot;\&quot;</span><span class="s1">}${</span><span class="s2">\n      </span><span class="s1">expected ? `, expected </span><span class="s2">\&quot;</span><span class="s1">${expected}</span><span class="s2">\&quot;</span><span class="s1">` : </span><span class="s2">\&quot;\&quot;\n    </span><span class="s1">}`,</span><span class="s2">\n  </span><span class="s1">UnexpectedTokenUnaryExponentiation:</span><span class="s2">\n    \&quot;</span><span class="s1">Illegal expression. Wrap left hand side or entire exponentiation in parentheses.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">UnexpectedUsingDeclaration:</span><span class="s2">\n    \&quot;</span><span class="s1">Using declaration cannot appear in the top level when source type is `script`.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">UnsupportedBind: </span><span class="s2">\&quot;</span><span class="s1">Binding should be performed on object property.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">UnsupportedDecoratorExport:</span><span class="s2">\n    \&quot;</span><span class="s1">A decorated export must export a class declaration.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">UnsupportedDefaultExport:</span><span class="s2">\n    \&quot;</span><span class="s1">Only expressions, functions or classes are allowed as the `default` export.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">UnsupportedImport:</span><span class="s2">\n    \&quot;</span><span class="s1">`import` can only be used in `import()` or `import.meta`.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">UnsupportedMetaProperty: ({</span><span class="s2">\n    </span><span class="s1">target,</span><span class="s2">\n    </span><span class="s1">onlyValidPropertyName,</span><span class="s2">\n  </span><span class="s1">}: {</span><span class="s2">\n    </span><span class="s1">target: string;</span><span class="s2">\n    </span><span class="s1">onlyValidPropertyName: string;</span><span class="s2">\n  </span><span class="s1">}) =&gt;</span><span class="s2">\n    </span><span class="s1">`The only valid meta property for ${target} is ${target}.${onlyValidPropertyName}.`,</span><span class="s2">\n  </span><span class="s1">UnsupportedParameterDecorator:</span><span class="s2">\n    \&quot;</span><span class="s1">Decorators cannot be used to decorate parameters.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">UnsupportedPropertyDecorator:</span><span class="s2">\n    \&quot;</span><span class="s1">Decorators cannot be used to decorate object literal properties.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">UnsupportedSuper:</span><span class="s2">\n    \&quot;</span><span class="s1">'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">UnterminatedComment: </span><span class="s2">\&quot;</span><span class="s1">Unterminated comment.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">UnterminatedRegExp: </span><span class="s2">\&quot;</span><span class="s1">Unterminated regular expression.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">UnterminatedString: </span><span class="s2">\&quot;</span><span class="s1">Unterminated string constant.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">UnterminatedTemplate: </span><span class="s2">\&quot;</span><span class="s1">Unterminated template.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">UsingDeclarationHasBindingPattern:</span><span class="s2">\n    \&quot;</span><span class="s1">Using declaration cannot have destructuring patterns.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">VarRedeclaration: ({ identifierName }: { identifierName: string }) =&gt;</span><span class="s2">\n    </span><span class="s1">`Identifier '${identifierName}' has already been declared.`,</span><span class="s2">\n  </span><span class="s1">YieldBindingIdentifier:</span><span class="s2">\n    \&quot;</span><span class="s1">Can not use 'yield' as identifier inside a generator.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">YieldInParameter: </span><span class="s2">\&quot;</span><span class="s1">Yield expression is not allowed in formal parameters.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ZeroDigitNumericSeparator:</span><span class="s2">\n    \&quot;</span><span class="s1">Numeric separator can not be used after leading 0.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">&quot;</span><span class="s2">,</span><span class="s1">&quot;export default {</span><span class="s2">\n  </span><span class="s1">StrictDelete: </span><span class="s2">\&quot;</span><span class="s1">Deleting local variable in strict mode.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n\n  </span><span class="s1">// `referenceName` is the StringValue[1] of an IdentifierReference[2], which</span><span class="s2">\n  </span><span class="s1">// is represented as just an `Identifier`[3] in the Babel AST.</span><span class="s2">\n  </span><span class="s1">// 1. https://tc39.es/ecma262/#sec-static-semantics-stringvalue</span><span class="s2">\n  </span><span class="s1">// 2. https://tc39.es/ecma262/#prod-IdentifierReference</span><span class="s2">\n  </span><span class="s1">// 3. https://github.com/babel/babel/blob/main/packages/babel-parser/ast/spec.md#identifier</span><span class="s2">\n  </span><span class="s1">StrictEvalArguments: ({ referenceName }: { referenceName: string }) =&gt;</span><span class="s2">\n    </span><span class="s1">`Assigning to '${referenceName}' in strict mode.`,</span><span class="s2">\n\n  </span><span class="s1">// `bindingName` is the StringValue[1] of a BindingIdentifier[2], which is</span><span class="s2">\n  </span><span class="s1">// represented as just an `Identifier`[3] in the Babel AST.</span><span class="s2">\n  </span><span class="s1">// 1. https://tc39.es/ecma262/#sec-static-semantics-stringvalue</span><span class="s2">\n  </span><span class="s1">// 2. https://tc39.es/ecma262/#prod-BindingIdentifier</span><span class="s2">\n  </span><span class="s1">// 3. https://github.com/babel/babel/blob/main/packages/babel-parser/ast/spec.md#identifier</span><span class="s2">\n  </span><span class="s1">StrictEvalArgumentsBinding: ({ bindingName }: { bindingName: string }) =&gt;</span><span class="s2">\n    </span><span class="s1">`Binding '${bindingName}' in strict mode.`,</span><span class="s2">\n\n  </span><span class="s1">StrictFunction:</span><span class="s2">\n    \&quot;</span><span class="s1">In strict mode code, functions can only be declared at top level or inside a block.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n\n  </span><span class="s1">StrictNumericEscape: </span><span class="s2">\&quot;</span><span class="s1">The only valid numeric escape in strict mode is '</span><span class="s2">\\\\</span><span class="s1">0'.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n\n  </span><span class="s1">StrictOctalLiteral: </span><span class="s2">\&quot;</span><span class="s1">Legacy octal literals are not allowed in strict mode.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n\n  </span><span class="s1">StrictWith: </span><span class="s2">\&quot;</span><span class="s1">'with' in strict mode.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">&quot;</span><span class="s2">,</span><span class="s1">&quot;import toNodeDescription from </span><span class="s2">\&quot;</span><span class="s1">./to-node-description</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">export const UnparenthesizedPipeBodyDescriptions = new Set([</span><span class="s2">\n  \&quot;</span><span class="s1">ArrowFunctionExpression</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">AssignmentExpression</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">ConditionalExpression</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">YieldExpression</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n</span><span class="s1">] as const);</span><span class="s2">\n\n</span><span class="s1">type GetSetMemberType&lt;T extends Set&lt;any&gt;&gt; = T extends Set&lt;infer M&gt;</span><span class="s2">\n  </span><span class="s1">? M</span><span class="s2">\n  </span><span class="s1">: unknown;</span><span class="s2">\n\n</span><span class="s1">type UnparenthesizedPipeBodyTypes = GetSetMemberType&lt;</span><span class="s2">\n  </span><span class="s1">typeof UnparenthesizedPipeBodyDescriptions</span><span class="s2">\n</span><span class="s1">&gt;;</span><span class="s2">\n\n</span><span class="s1">export default {</span><span class="s2">\n  </span><span class="s1">// This error is only used by the smart-mix proposal</span><span class="s2">\n  </span><span class="s1">PipeBodyIsTighter:</span><span class="s2">\n    \&quot;</span><span class="s1">Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">PipeTopicRequiresHackPipes:</span><span class="s2">\n    </span><span class="s1">'Topic reference is used, but the pipelineOperator plugin was not passed a </span><span class="s2">\&quot;</span><span class="s1">proposal</span><span class="s2">\&quot;</span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">hack</span><span class="s2">\&quot; </span><span class="s1">or </span><span class="s2">\&quot;</span><span class="s1">smart</span><span class="s2">\&quot; </span><span class="s1">option.',</span><span class="s2">\n  </span><span class="s1">PipeTopicUnbound:</span><span class="s2">\n    \&quot;</span><span class="s1">Topic reference is unbound; it must be inside a pipe body.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">PipeTopicUnconfiguredToken: ({ token }: { token: string }) =&gt;</span><span class="s2">\n    </span><span class="s1">`Invalid topic token ${token}. In order to use ${token} as a topic reference, the pipelineOperator plugin must be configured with { </span><span class="s2">\&quot;</span><span class="s1">proposal</span><span class="s2">\&quot;</span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">hack</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">topicToken</span><span class="s2">\&quot;</span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">${token}</span><span class="s2">\&quot; </span><span class="s1">}.`,</span><span class="s2">\n  </span><span class="s1">PipeTopicUnused:</span><span class="s2">\n    \&quot;</span><span class="s1">Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">PipeUnparenthesizedBody: ({ type }: { type: UnparenthesizedPipeBodyTypes }) =&gt;</span><span class="s2">\n    </span><span class="s1">`Hack-style pipe body cannot be an unparenthesized ${toNodeDescription({</span><span class="s2">\n      </span><span class="s1">type,</span><span class="s2">\n    </span><span class="s1">})}; please wrap it in parentheses.`,</span><span class="s2">\n\n  </span><span class="s1">// Messages whose codes start with “Pipeline” or “PrimaryTopic”</span><span class="s2">\n  </span><span class="s1">// are retained for backwards compatibility</span><span class="s2">\n  </span><span class="s1">// with the deprecated smart-mix pipe operator proposal plugin.</span><span class="s2">\n  </span><span class="s1">// They are subject to removal in a future major version.</span><span class="s2">\n  </span><span class="s1">PipelineBodyNoArrow:</span><span class="s2">\n    </span><span class="s1">'Unexpected arrow </span><span class="s2">\&quot;</span><span class="s1">=&gt;</span><span class="s2">\&quot; </span><span class="s1">after pipeline body; arrow function in pipeline body must be parenthesized.',</span><span class="s2">\n  </span><span class="s1">PipelineBodySequenceExpression:</span><span class="s2">\n    \&quot;</span><span class="s1">Pipeline body may not be a comma-separated sequence expression.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">PipelineHeadSequenceExpression:</span><span class="s2">\n    \&quot;</span><span class="s1">Pipeline head should not be a comma-separated sequence expression.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">PipelineTopicUnused:</span><span class="s2">\n    \&quot;</span><span class="s1">Pipeline is in topic style but does not use topic reference.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">PrimaryTopicNotAllowed:</span><span class="s2">\n    \&quot;</span><span class="s1">Topic reference was used in a lexical context without topic binding.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">PrimaryTopicRequiresSmartPipeline:</span><span class="s2">\n    </span><span class="s1">'Topic reference is used, but the pipelineOperator plugin was not passed a </span><span class="s2">\&quot;</span><span class="s1">proposal</span><span class="s2">\&quot;</span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">hack</span><span class="s2">\&quot; </span><span class="s1">or </span><span class="s2">\&quot;</span><span class="s1">smart</span><span class="s2">\&quot; </span><span class="s1">option.',</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">&quot;</span><span class="s2">,</span><span class="s1">&quot;import { Position } from </span><span class="s2">\&quot;</span><span class="s1">./util/location</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import {</span><span class="s2">\n  </span><span class="s1">instantiate,</span><span class="s2">\n  </span><span class="s1">ParseErrorCode,</span><span class="s2">\n  </span><span class="s1">type ParseErrorCredentials,</span><span class="s2">\n  </span><span class="s1">type ToMessage,</span><span class="s2">\n  </span><span class="s1">type SyntaxPlugin,</span><span class="s2">\n</span><span class="s1">} from </span><span class="s2">\&quot;</span><span class="s1">./parse-error/credentials</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type { Undone } from </span><span class="s2">\&quot;</span><span class="s1">./parser/node</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type { Node } from </span><span class="s2">\&quot;</span><span class="s1">./types</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">// Babel uses </span><span class="s2">\&quot;</span><span class="s1">normal</span><span class="s2">\&quot; </span><span class="s1">SyntaxErrors for it's errors, but adds some extra</span><span class="s2">\n</span><span class="s1">// functionality. This functionality is defined in the</span><span class="s2">\n</span><span class="s1">// `ParseErrorSpecification` interface below. We may choose to change to someday</span><span class="s2">\n</span><span class="s1">// give our errors their own full-blown class, but until then this allow us to</span><span class="s2">\n</span><span class="s1">// keep all the desirable properties of SyntaxErrors (like their name in stack</span><span class="s2">\n</span><span class="s1">// traces, etc.), and also allows us to punt on any publicly facing</span><span class="s2">\n</span><span class="s1">// class-hierarchy decisions until Babel 8.</span><span class="s2">\n</span><span class="s1">interface ParseErrorSpecification&lt;ErrorDetails&gt; {</span><span class="s2">\n  </span><span class="s1">// Look, these *could* be readonly, but then Flow complains when we initially</span><span class="s2">\n  </span><span class="s1">// set them. We could do a whole dance and make a special interface that's not</span><span class="s2">\n  </span><span class="s1">// readonly for when we create the error, then cast it to the readonly</span><span class="s2">\n  </span><span class="s1">// interface for public use, but the previous implementation didn't have them</span><span class="s2">\n  </span><span class="s1">// as readonly, so let's just not worry about it for now.</span><span class="s2">\n  </span><span class="s1">code: ParseErrorCode;</span><span class="s2">\n  </span><span class="s1">reasonCode: string;</span><span class="s2">\n  </span><span class="s1">syntaxPlugin?: SyntaxPlugin;</span><span class="s2">\n  </span><span class="s1">missingPlugin?: string | string[];</span><span class="s2">\n  </span><span class="s1">loc: Position;</span><span class="s2">\n  </span><span class="s1">details: ErrorDetails;</span><span class="s2">\n\n  </span><span class="s1">// We should consider removing this as it now just contains the same</span><span class="s2">\n  </span><span class="s1">// information as `loc.index`.</span><span class="s2">\n  </span><span class="s1">// pos: number;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">export type ParseError&lt;ErrorDetails&gt; = SyntaxError &amp;</span><span class="s2">\n  </span><span class="s1">ParseErrorSpecification&lt;ErrorDetails&gt;;</span><span class="s2">\n\n</span><span class="s1">// By `ParseErrorConstructor`, we mean something like the new-less style</span><span class="s2">\n</span><span class="s1">// `ErrorConstructor`[1], since `ParseError`'s are not themselves actually</span><span class="s2">\n</span><span class="s1">// separate classes from `SyntaxError`'s.</span><span class="s2">\n</span><span class="s1">//</span><span class="s2">\n</span><span class="s1">// 1. https://github.com/microsoft/TypeScript/blob/v4.5.5/lib/lib.es5.d.ts#L1027</span><span class="s2">\n</span><span class="s1">export type ParseErrorConstructor&lt;ErrorDetails&gt; = (a: {</span><span class="s2">\n  </span><span class="s1">loc: Position;</span><span class="s2">\n  </span><span class="s1">details: ErrorDetails;</span><span class="s2">\n</span><span class="s1">}) =&gt; ParseError&lt;ErrorDetails&gt;;</span><span class="s2">\n\n</span><span class="s1">function toParseErrorConstructor&lt;ErrorDetails extends object&gt;({</span><span class="s2">\n  </span><span class="s1">toMessage,</span><span class="s2">\n  </span><span class="s1">...properties</span><span class="s2">\n</span><span class="s1">}: ParseErrorCredentials&lt;ErrorDetails&gt;): ParseErrorConstructor&lt;ErrorDetails&gt; {</span><span class="s2">\n  </span><span class="s1">type ConstructorArgument = {</span><span class="s2">\n    </span><span class="s1">loc: Position;</span><span class="s2">\n    </span><span class="s1">details: ErrorDetails;</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n\n  </span><span class="s1">return function constructor({ loc, details }: ConstructorArgument) {</span><span class="s2">\n    </span><span class="s1">return instantiate(</span><span class="s2">\n      </span><span class="s1">SyntaxError,</span><span class="s2">\n      </span><span class="s1">{ ...properties, loc },</span><span class="s2">\n      </span><span class="s1">{</span><span class="s2">\n        </span><span class="s1">clone(</span><span class="s2">\n          </span><span class="s1">overrides: {</span><span class="s2">\n            </span><span class="s1">loc?: Position;</span><span class="s2">\n            </span><span class="s1">details?: ErrorDetails;</span><span class="s2">\n          </span><span class="s1">} = {},</span><span class="s2">\n        </span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">const loc = (overrides.loc || {}) as Partial&lt;Position&gt;;</span><span class="s2">\n          </span><span class="s1">return constructor({</span><span class="s2">\n            </span><span class="s1">loc: new Position(</span><span class="s2">\n              \&quot;</span><span class="s1">line</span><span class="s2">\&quot; </span><span class="s1">in loc ? loc.line : this.loc.line,</span><span class="s2">\n              \&quot;</span><span class="s1">column</span><span class="s2">\&quot; </span><span class="s1">in loc ? loc.column : this.loc.column,</span><span class="s2">\n              \&quot;</span><span class="s1">index</span><span class="s2">\&quot; </span><span class="s1">in loc ? loc.index : this.loc.index,</span><span class="s2">\n            </span><span class="s1">),</span><span class="s2">\n            </span><span class="s1">details: { ...this.details, ...overrides.details },</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">details: { value: details, enumerable: false },</span><span class="s2">\n        </span><span class="s1">message: {</span><span class="s2">\n          </span><span class="s1">get(this: ConstructorArgument): string {</span><span class="s2">\n            </span><span class="s1">return `${toMessage(this.details)} (${this.loc.line}:${</span><span class="s2">\n              </span><span class="s1">this.loc.column</span><span class="s2">\n            </span><span class="s1">})`;</span><span class="s2">\n          </span><span class="s1">},</span><span class="s2">\n          </span><span class="s1">set(value: string) {</span><span class="s2">\n            </span><span class="s1">Object.defineProperty(this, </span><span class="s2">\&quot;</span><span class="s1">message</span><span class="s2">\&quot;</span><span class="s1">, { value });</span><span class="s2">\n          </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">pos: { reflect: </span><span class="s2">\&quot;</span><span class="s1">loc.index</span><span class="s2">\&quot;</span><span class="s1">, enumerable: true },</span><span class="s2">\n        </span><span class="s1">missingPlugin: </span><span class="s2">\&quot;</span><span class="s1">missingPlugin</span><span class="s2">\&quot; </span><span class="s1">in details &amp;&amp; {</span><span class="s2">\n          </span><span class="s1">reflect: </span><span class="s2">\&quot;</span><span class="s1">details.missingPlugin</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n          </span><span class="s1">enumerable: true,</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n      </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">) as ParseError&lt;ErrorDetails&gt;;</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">type ParseErrorTemplate =</span><span class="s2">\n  </span><span class="s1">| string</span><span class="s2">\n  </span><span class="s1">| ToMessage&lt;any&gt;</span><span class="s2">\n  </span><span class="s1">| { message: string | ToMessage&lt;any&gt; };</span><span class="s2">\n\n</span><span class="s1">type ParseErrorTemplates = { [reasonCode: string]: ParseErrorTemplate };</span><span class="s2">\n\n</span><span class="s1">// This is the templated form of `ParseErrorEnum`.</span><span class="s2">\n</span><span class="s1">//</span><span class="s2">\n</span><span class="s1">// Note: We could factor out the return type calculation into something like</span><span class="s2">\n</span><span class="s1">// `ParseErrorConstructor&lt;T extends ParseErrorTemplates&gt;`, and then we could</span><span class="s2">\n</span><span class="s1">// reuse it in the non-templated form of `ParseErrorEnum`, but TypeScript</span><span class="s2">\n</span><span class="s1">// doesn't seem to drill down that far when showing you the computed type of</span><span class="s2">\n</span><span class="s1">// an object in an editor, so we'll leave it inlined for now.</span><span class="s2">\n</span><span class="s1">export function ParseErrorEnum(a: TemplateStringsArray): &lt;</span><span class="s2">\n  </span><span class="s1">T extends ParseErrorTemplates,</span><span class="s2">\n</span><span class="s1">&gt;(</span><span class="s2">\n  </span><span class="s1">parseErrorTemplates: T,</span><span class="s2">\n</span><span class="s1">) =&gt; {</span><span class="s2">\n  </span><span class="s1">[K in keyof T]: ParseErrorConstructor&lt;</span><span class="s2">\n    </span><span class="s1">T[K] extends { message: string | ToMessage&lt;any&gt; }</span><span class="s2">\n      </span><span class="s1">? T[K][</span><span class="s2">\&quot;</span><span class="s1">message</span><span class="s2">\&quot;</span><span class="s1">] extends ToMessage&lt;any&gt;</span><span class="s2">\n        </span><span class="s1">? Parameters&lt;T[K][</span><span class="s2">\&quot;</span><span class="s1">message</span><span class="s2">\&quot;</span><span class="s1">]&gt;[0]</span><span class="s2">\n        </span><span class="s1">: {}</span><span class="s2">\n      </span><span class="s1">: T[K] extends ToMessage&lt;any&gt;</span><span class="s2">\n      </span><span class="s1">? Parameters&lt;T[K]&gt;[0]</span><span class="s2">\n      </span><span class="s1">: {}</span><span class="s2">\n  </span><span class="s1">&gt;;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">export function ParseErrorEnum&lt;T extends ParseErrorTemplates&gt;(</span><span class="s2">\n  </span><span class="s1">parseErrorTemplates: T,</span><span class="s2">\n  </span><span class="s1">syntaxPlugin?: SyntaxPlugin,</span><span class="s2">\n</span><span class="s1">): {</span><span class="s2">\n  </span><span class="s1">[K in keyof T]: ParseErrorConstructor&lt;</span><span class="s2">\n    </span><span class="s1">T[K] extends { message: string | ToMessage&lt;any&gt; }</span><span class="s2">\n      </span><span class="s1">? T[K][</span><span class="s2">\&quot;</span><span class="s1">message</span><span class="s2">\&quot;</span><span class="s1">] extends ToMessage&lt;any&gt;</span><span class="s2">\n        </span><span class="s1">? Parameters&lt;T[K][</span><span class="s2">\&quot;</span><span class="s1">message</span><span class="s2">\&quot;</span><span class="s1">]&gt;[0]</span><span class="s2">\n        </span><span class="s1">: {}</span><span class="s2">\n      </span><span class="s1">: T[K] extends ToMessage&lt;any&gt;</span><span class="s2">\n      </span><span class="s1">? Parameters&lt;T[K]&gt;[0]</span><span class="s2">\n      </span><span class="s1">: {}</span><span class="s2">\n  </span><span class="s1">&gt;;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">// You call `ParseErrorEnum` with a mapping from `ReasonCode`'s to either:</span><span class="s2">\n</span><span class="s1">//</span><span class="s2">\n</span><span class="s1">// 1. a static error message,</span><span class="s2">\n</span><span class="s1">// 2. `toMessage` functions that define additional necessary `details` needed by</span><span class="s2">\n</span><span class="s1">//    the `ParseError`, or</span><span class="s2">\n</span><span class="s1">// 3. Objects that contain a `message` of one of the above and overridden `code`</span><span class="s2">\n</span><span class="s1">//    and/or `reasonCode`:</span><span class="s2">\n</span><span class="s1">//</span><span class="s2">\n</span><span class="s1">// ParseErrorEnum `optionalSyntaxPlugin` ({</span><span class="s2">\n</span><span class="s1">//   ErrorWithStaticMessage: </span><span class="s2">\&quot;</span><span class="s1">message</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n</span><span class="s1">//   ErrorWithDynamicMessage: ({ type } : { type: string }) =&gt; `${type}`),</span><span class="s2">\n</span><span class="s1">//   ErrorWithOverriddenCodeAndOrReasonCode: {</span><span class="s2">\n</span><span class="s1">//     message: ({ type }: { type: string }) =&gt; `${type}`),</span><span class="s2">\n</span><span class="s1">//     code: ParseErrorCode.SourceTypeModuleError,</span><span class="s2">\n</span><span class="s1">//     ...(BABEL_8_BREAKING ? { } : { reasonCode: </span><span class="s2">\&quot;</span><span class="s1">CustomErrorReasonCode</span><span class="s2">\&quot; </span><span class="s1">})</span><span class="s2">\n</span><span class="s1">//   }</span><span class="s2">\n</span><span class="s1">// });</span><span class="s2">\n</span><span class="s1">//</span><span class="s2">\n</span><span class="s1">export function ParseErrorEnum(</span><span class="s2">\n  </span><span class="s1">argument: TemplateStringsArray | ParseErrorTemplates,</span><span class="s2">\n  </span><span class="s1">syntaxPlugin?: SyntaxPlugin,</span><span class="s2">\n</span><span class="s1">) {</span><span class="s2">\n  </span><span class="s1">// If the first parameter is an array, that means we were called with a tagged</span><span class="s2">\n  </span><span class="s1">// template literal. Extract the syntaxPlugin from this, and call again in</span><span class="s2">\n  </span><span class="s1">// the </span><span class="s2">\&quot;</span><span class="s1">normalized</span><span class="s2">\&quot; </span><span class="s1">form.</span><span class="s2">\n  </span><span class="s1">if (Array.isArray(argument)) {</span><span class="s2">\n    </span><span class="s1">return (parseErrorTemplates: ParseErrorTemplates) =&gt;</span><span class="s2">\n      </span><span class="s1">ParseErrorEnum(parseErrorTemplates, argument[0]);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">const ParseErrorConstructors = {} as Record&lt;</span><span class="s2">\n    </span><span class="s1">string,</span><span class="s2">\n    </span><span class="s1">ParseErrorConstructor&lt;unknown&gt;</span><span class="s2">\n  </span><span class="s1">&gt;;</span><span class="s2">\n\n  </span><span class="s1">for (const reasonCode of Object.keys(argument)) {</span><span class="s2">\n    </span><span class="s1">const template = (argument as ParseErrorTemplates)[reasonCode];</span><span class="s2">\n    </span><span class="s1">const { message, ...rest } =</span><span class="s2">\n      </span><span class="s1">typeof template === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot;\n        </span><span class="s1">? { message: () =&gt; template }</span><span class="s2">\n        </span><span class="s1">: typeof template === </span><span class="s2">\&quot;</span><span class="s1">function</span><span class="s2">\&quot;\n        </span><span class="s1">? { message: template }</span><span class="s2">\n        </span><span class="s1">: template;</span><span class="s2">\n    </span><span class="s1">const toMessage = typeof message === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">? () =&gt; message : message;</span><span class="s2">\n\n    </span><span class="s1">ParseErrorConstructors[reasonCode] = toParseErrorConstructor({</span><span class="s2">\n      </span><span class="s1">code: ParseErrorCode.SyntaxError,</span><span class="s2">\n      </span><span class="s1">reasonCode,</span><span class="s2">\n      </span><span class="s1">toMessage,</span><span class="s2">\n      </span><span class="s1">...(syntaxPlugin ? { syntaxPlugin } : {}),</span><span class="s2">\n      </span><span class="s1">...rest,</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">return ParseErrorConstructors;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">export type RaiseProperties&lt;ErrorDetails&gt; = {</span><span class="s2">\n  </span><span class="s1">at: Position | Undone&lt;Node&gt;;</span><span class="s2">\n</span><span class="s1">} &amp; ErrorDetails;</span><span class="s2">\n\n</span><span class="s1">import ModuleErrors from </span><span class="s2">\&quot;</span><span class="s1">./parse-error/module-errors</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import StandardErrors from </span><span class="s2">\&quot;</span><span class="s1">./parse-error/standard-errors</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import StrictModeErrors from </span><span class="s2">\&quot;</span><span class="s1">./parse-error/strict-mode-errors</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import PipelineOperatorErrors from </span><span class="s2">\&quot;</span><span class="s1">./parse-error/pipeline-operator-errors</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">export const Errors = {</span><span class="s2">\n  </span><span class="s1">...ParseErrorEnum(ModuleErrors),</span><span class="s2">\n  </span><span class="s1">...ParseErrorEnum(StandardErrors),</span><span class="s2">\n  </span><span class="s1">...ParseErrorEnum(StrictModeErrors),</span><span class="s2">\n  </span><span class="s1">...ParseErrorEnum`pipelineOperator`(PipelineOperatorErrors),</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">export type { LValAncestor } from </span><span class="s2">\&quot;</span><span class="s1">./parse-error/standard-errors</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">export * from </span><span class="s2">\&quot;</span><span class="s1">./parse-error/credentials</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">&quot;</span><span class="s2">,</span><span class="s1">&quot;import { type TokenType } from </span><span class="s2">\&quot;</span><span class="s1">../tokenizer/types</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type Parser from </span><span class="s2">\&quot;</span><span class="s1">../parser</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type { ExpressionErrors } from </span><span class="s2">\&quot;</span><span class="s1">../parser/util</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type * as N from </span><span class="s2">\&quot;</span><span class="s1">../types</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type { Node as NodeType, NodeBase, File } from </span><span class="s2">\&quot;</span><span class="s1">../types</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type { Position } from </span><span class="s2">\&quot;</span><span class="s1">../util/location</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import { Errors } from </span><span class="s2">\&quot;</span><span class="s1">../parse-error</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type { Undone } from </span><span class="s2">\&quot;</span><span class="s1">../parser/node</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type { BindingTypes } from </span><span class="s2">\&quot;</span><span class="s1">../util/scopeflags</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">const { defineProperty } = Object;</span><span class="s2">\n</span><span class="s1">const toUnenumerable = (object: any, key: string) =&gt;</span><span class="s2">\n  </span><span class="s1">defineProperty(object, key, { enumerable: false, value: object[key] });</span><span class="s2">\n\n</span><span class="s1">function toESTreeLocation(node: any) {</span><span class="s2">\n  </span><span class="s1">node.loc.start &amp;&amp; toUnenumerable(node.loc.start, </span><span class="s2">\&quot;</span><span class="s1">index</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">node.loc.end &amp;&amp; toUnenumerable(node.loc.end, </span><span class="s2">\&quot;</span><span class="s1">index</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n\n  </span><span class="s1">return node;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">export default (superClass: typeof Parser) =&gt;</span><span class="s2">\n  </span><span class="s1">class ESTreeParserMixin extends superClass implements Parser {</span><span class="s2">\n    </span><span class="s1">parse(): File {</span><span class="s2">\n      </span><span class="s1">const file = toESTreeLocation(super.parse());</span><span class="s2">\n\n      </span><span class="s1">if (this.options.tokens) {</span><span class="s2">\n        </span><span class="s1">file.tokens = file.tokens.map(toESTreeLocation);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return file;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// @ts-expect-error ESTree plugin changes node types</span><span class="s2">\n    </span><span class="s1">parseRegExpLiteral({ pattern, flags }): N.EstreeRegExpLiteral {</span><span class="s2">\n      </span><span class="s1">let regex: RegExp | null = null;</span><span class="s2">\n      </span><span class="s1">try {</span><span class="s2">\n        </span><span class="s1">regex = new RegExp(pattern, flags);</span><span class="s2">\n      </span><span class="s1">} catch (e) {</span><span class="s2">\n        </span><span class="s1">// In environments that don't support these flags value will</span><span class="s2">\n        </span><span class="s1">// be null as the regex can't be represented natively.</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">const node = this.estreeParseLiteral&lt;N.EstreeRegExpLiteral&gt;(regex);</span><span class="s2">\n      </span><span class="s1">node.regex = { pattern, flags };</span><span class="s2">\n\n      </span><span class="s1">return node;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// @ts-expect-error ESTree plugin changes node types</span><span class="s2">\n    </span><span class="s1">parseBigIntLiteral(value: any): N.Node {</span><span class="s2">\n      </span><span class="s1">// https://github.com/estree/estree/blob/master/es2020.md#bigintliteral</span><span class="s2">\n      </span><span class="s1">let bigInt: BigInt | null;</span><span class="s2">\n      </span><span class="s1">try {</span><span class="s2">\n        </span><span class="s1">bigInt = BigInt(value);</span><span class="s2">\n      </span><span class="s1">} catch {</span><span class="s2">\n        </span><span class="s1">bigInt = null;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">const node = this.estreeParseLiteral&lt;N.EstreeBigIntLiteral&gt;(bigInt);</span><span class="s2">\n      </span><span class="s1">node.bigint = String(node.value || value);</span><span class="s2">\n\n      </span><span class="s1">return node;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// @ts-expect-error ESTree plugin changes node types</span><span class="s2">\n    </span><span class="s1">parseDecimalLiteral(value: any): N.Node {</span><span class="s2">\n      </span><span class="s1">// https://github.com/estree/estree/blob/master/experimental/decimal.md</span><span class="s2">\n      </span><span class="s1">// todo: use BigDecimal when node supports it.</span><span class="s2">\n      </span><span class="s1">const decimal: null = null;</span><span class="s2">\n      </span><span class="s1">const node = this.estreeParseLiteral(decimal);</span><span class="s2">\n      </span><span class="s1">node.decimal = String(node.value || value);</span><span class="s2">\n\n      </span><span class="s1">return node;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">estreeParseLiteral&lt;T extends N.Node&gt;(value: any) {</span><span class="s2">\n      </span><span class="s1">// @ts-expect-error ESTree plugin changes node types</span><span class="s2">\n      </span><span class="s1">return this.parseLiteral&lt;T&gt;(value, </span><span class="s2">\&quot;</span><span class="s1">Literal</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// @ts-expect-error ESTree plugin changes node types</span><span class="s2">\n    </span><span class="s1">parseStringLiteral(value: any): N.Node {</span><span class="s2">\n      </span><span class="s1">return this.estreeParseLiteral(value);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseNumericLiteral(value: any): any {</span><span class="s2">\n      </span><span class="s1">return this.estreeParseLiteral(value);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// @ts-expect-error ESTree plugin changes node types</span><span class="s2">\n    </span><span class="s1">parseNullLiteral(): N.Node {</span><span class="s2">\n      </span><span class="s1">return this.estreeParseLiteral(null);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseBooleanLiteral(value: boolean): N.BooleanLiteral {</span><span class="s2">\n      </span><span class="s1">return this.estreeParseLiteral(value);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// Cast a Directive to an ExpressionStatement. Mutates the input Directive.</span><span class="s2">\n    </span><span class="s1">directiveToStmt(directive: N.Directive): N.ExpressionStatement {</span><span class="s2">\n      </span><span class="s1">const expression = directive.value as any as N.EstreeLiteral;</span><span class="s2">\n      </span><span class="s1">delete directive.value;</span><span class="s2">\n\n      </span><span class="s1">expression.type = </span><span class="s2">\&quot;</span><span class="s1">Literal</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n      </span><span class="s1">// @ts-expect-error N.EstreeLiteral.raw is not defined.</span><span class="s2">\n      </span><span class="s1">expression.raw = expression.extra.raw;</span><span class="s2">\n      </span><span class="s1">expression.value = expression.extra.expressionValue;</span><span class="s2">\n\n      </span><span class="s1">const stmt = directive as any as N.ExpressionStatement;</span><span class="s2">\n      </span><span class="s1">stmt.type = </span><span class="s2">\&quot;</span><span class="s1">ExpressionStatement</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n      </span><span class="s1">stmt.expression = expression;</span><span class="s2">\n      </span><span class="s1">// @ts-expect-error N.ExpressionStatement.directive is not defined</span><span class="s2">\n      </span><span class="s1">stmt.directive = expression.extra.rawValue;</span><span class="s2">\n\n      </span><span class="s1">delete expression.extra;</span><span class="s2">\n\n      </span><span class="s1">return stmt;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// ==================================</span><span class="s2">\n    </span><span class="s1">// Overrides</span><span class="s2">\n    </span><span class="s1">// ==================================</span><span class="s2">\n\n    </span><span class="s1">initFunction(node: N.BodilessFunctionOrMethodBase, isAsync: boolean): void {</span><span class="s2">\n      </span><span class="s1">super.initFunction(node, isAsync);</span><span class="s2">\n      </span><span class="s1">node.expression = false;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">checkDeclaration(node: N.Pattern | N.ObjectProperty): void {</span><span class="s2">\n      </span><span class="s1">if (node != null &amp;&amp; this.isObjectProperty(node)) {</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error plugin typings</span><span class="s2">\n        </span><span class="s1">this.checkDeclaration((node as unknown as N.EstreeProperty).value);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">super.checkDeclaration(node);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">getObjectOrClassMethodParams(method: N.ObjectMethod | N.ClassMethod) {</span><span class="s2">\n      </span><span class="s1">return (method as any as N.EstreeProperty | N.EstreeMethodDefinition)</span><span class="s2">\n        </span><span class="s1">.value.params;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">isValidDirective(stmt: N.Statement): boolean {</span><span class="s2">\n      </span><span class="s1">return (</span><span class="s2">\n        </span><span class="s1">stmt.type === </span><span class="s2">\&quot;</span><span class="s1">ExpressionStatement</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n        </span><span class="s1">stmt.expression.type === </span><span class="s2">\&quot;</span><span class="s1">Literal</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n        </span><span class="s1">typeof stmt.expression.value === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n        </span><span class="s1">!stmt.expression.extra?.parenthesized</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseBlockBody(</span><span class="s2">\n      </span><span class="s1">node: N.BlockStatementLike,</span><span class="s2">\n      </span><span class="s1">allowDirectives: boolean | undefined | null,</span><span class="s2">\n      </span><span class="s1">topLevel: boolean,</span><span class="s2">\n      </span><span class="s1">end: TokenType,</span><span class="s2">\n      </span><span class="s1">afterBlockParse?: (hasStrictModeDirective: boolean) =&gt; void,</span><span class="s2">\n    </span><span class="s1">): void {</span><span class="s2">\n      </span><span class="s1">super.parseBlockBody(</span><span class="s2">\n        </span><span class="s1">node,</span><span class="s2">\n        </span><span class="s1">allowDirectives,</span><span class="s2">\n        </span><span class="s1">topLevel,</span><span class="s2">\n        </span><span class="s1">end,</span><span class="s2">\n        </span><span class="s1">afterBlockParse,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n\n      </span><span class="s1">const directiveStatements = node.directives.map(d =&gt;</span><span class="s2">\n        </span><span class="s1">this.directiveToStmt(d),</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">// @ts-expect-error estree plugin typings</span><span class="s2">\n      </span><span class="s1">node.body = directiveStatements.concat(node.body);</span><span class="s2">\n      </span><span class="s1">delete node.directives;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">pushClassMethod(</span><span class="s2">\n      </span><span class="s1">classBody: N.ClassBody,</span><span class="s2">\n      </span><span class="s1">method: N.ClassMethod,</span><span class="s2">\n      </span><span class="s1">isGenerator: boolean,</span><span class="s2">\n      </span><span class="s1">isAsync: boolean,</span><span class="s2">\n      </span><span class="s1">isConstructor: boolean,</span><span class="s2">\n      </span><span class="s1">allowsDirectSuper: boolean,</span><span class="s2">\n    </span><span class="s1">): void {</span><span class="s2">\n      </span><span class="s1">this.parseMethod(</span><span class="s2">\n        </span><span class="s1">method,</span><span class="s2">\n        </span><span class="s1">isGenerator,</span><span class="s2">\n        </span><span class="s1">isAsync,</span><span class="s2">\n        </span><span class="s1">isConstructor,</span><span class="s2">\n        </span><span class="s1">allowsDirectSuper,</span><span class="s2">\n        \&quot;</span><span class="s1">ClassMethod</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">true,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">if (method.typeParameters) {</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error mutate AST types</span><span class="s2">\n        </span><span class="s1">method.value.typeParameters = method.typeParameters;</span><span class="s2">\n        </span><span class="s1">delete method.typeParameters;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">classBody.body.push(method);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parsePrivateName(): any {</span><span class="s2">\n      </span><span class="s1">const node = super.parsePrivateName();</span><span class="s2">\n      </span><span class="s1">if (!process.env.BABEL_8_BREAKING) {</span><span class="s2">\n        </span><span class="s1">if (!this.getPluginOption(</span><span class="s2">\&quot;</span><span class="s1">estree</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">classFeatures</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n          </span><span class="s1">return node;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return this.convertPrivateNameToPrivateIdentifier(node);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">convertPrivateNameToPrivateIdentifier(</span><span class="s2">\n      </span><span class="s1">node: N.PrivateName,</span><span class="s2">\n    </span><span class="s1">): N.EstreePrivateIdentifier {</span><span class="s2">\n      </span><span class="s1">const name = super.getPrivateNameSV(node);</span><span class="s2">\n      </span><span class="s1">node = node as any;</span><span class="s2">\n      </span><span class="s1">delete node.id;</span><span class="s2">\n      </span><span class="s1">// @ts-expect-error mutate AST types</span><span class="s2">\n      </span><span class="s1">node.name = name;</span><span class="s2">\n      </span><span class="s1">// @ts-expect-error mutate AST types</span><span class="s2">\n      </span><span class="s1">node.type = </span><span class="s2">\&quot;</span><span class="s1">PrivateIdentifier</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n      </span><span class="s1">return node as unknown as N.EstreePrivateIdentifier;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">isPrivateName(node: N.Node): boolean {</span><span class="s2">\n      </span><span class="s1">if (!process.env.BABEL_8_BREAKING) {</span><span class="s2">\n        </span><span class="s1">if (!this.getPluginOption(</span><span class="s2">\&quot;</span><span class="s1">estree</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">classFeatures</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n          </span><span class="s1">return super.isPrivateName(node);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return node.type === </span><span class="s2">\&quot;</span><span class="s1">PrivateIdentifier</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">getPrivateNameSV(node: N.Node): string {</span><span class="s2">\n      </span><span class="s1">if (!process.env.BABEL_8_BREAKING) {</span><span class="s2">\n        </span><span class="s1">if (!this.getPluginOption(</span><span class="s2">\&quot;</span><span class="s1">estree</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">classFeatures</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n          </span><span class="s1">return super.getPrivateNameSV(node);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return node.name;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// @ts-expect-error plugin may override interfaces</span><span class="s2">\n    </span><span class="s1">parseLiteral&lt;T extends N.Literal&gt;(value: any, type: T[</span><span class="s2">\&quot;</span><span class="s1">type</span><span class="s2">\&quot;</span><span class="s1">]): T {</span><span class="s2">\n      </span><span class="s1">const node = super.parseLiteral&lt;T&gt;(value, type);</span><span class="s2">\n      </span><span class="s1">// @ts-expect-error mutating AST types</span><span class="s2">\n      </span><span class="s1">node.raw = node.extra.raw;</span><span class="s2">\n      </span><span class="s1">delete node.extra;</span><span class="s2">\n\n      </span><span class="s1">return node;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseFunctionBody(</span><span class="s2">\n      </span><span class="s1">node: N.Function,</span><span class="s2">\n      </span><span class="s1">allowExpression?: boolean | null,</span><span class="s2">\n      </span><span class="s1">isMethod: boolean = false,</span><span class="s2">\n    </span><span class="s1">): void {</span><span class="s2">\n      </span><span class="s1">super.parseFunctionBody(node, allowExpression, isMethod);</span><span class="s2">\n      </span><span class="s1">node.expression = node.body.type !== </span><span class="s2">\&quot;</span><span class="s1">BlockStatement</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// @ts-expect-error plugin may override interfaces</span><span class="s2">\n    </span><span class="s1">parseMethod&lt;</span><span class="s2">\n      </span><span class="s1">T extends N.ClassPrivateMethod | N.ObjectMethod | N.ClassMethod,</span><span class="s2">\n    </span><span class="s1">&gt;(</span><span class="s2">\n      </span><span class="s1">node: Undone&lt;T&gt;,</span><span class="s2">\n      </span><span class="s1">isGenerator: boolean,</span><span class="s2">\n      </span><span class="s1">isAsync: boolean,</span><span class="s2">\n      </span><span class="s1">isConstructor: boolean,</span><span class="s2">\n      </span><span class="s1">allowDirectSuper: boolean,</span><span class="s2">\n      </span><span class="s1">type: T[</span><span class="s2">\&quot;</span><span class="s1">type</span><span class="s2">\&quot;</span><span class="s1">],</span><span class="s2">\n      </span><span class="s1">inClassScope: boolean = false,</span><span class="s2">\n    </span><span class="s1">): N.EstreeMethodDefinition {</span><span class="s2">\n      </span><span class="s1">let funcNode = this.startNode&lt;N.MethodLike&gt;();</span><span class="s2">\n      </span><span class="s1">funcNode.kind = node.kind; // provide kind, so super method correctly sets state</span><span class="s2">\n      </span><span class="s1">funcNode = super.parseMethod(</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts)</span><span class="s2">\n        </span><span class="s1">funcNode,</span><span class="s2">\n        </span><span class="s1">isGenerator,</span><span class="s2">\n        </span><span class="s1">isAsync,</span><span class="s2">\n        </span><span class="s1">isConstructor,</span><span class="s2">\n        </span><span class="s1">allowDirectSuper,</span><span class="s2">\n        </span><span class="s1">type,</span><span class="s2">\n        </span><span class="s1">inClassScope,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">// @ts-expect-error mutate AST types</span><span class="s2">\n      </span><span class="s1">funcNode.type = </span><span class="s2">\&quot;</span><span class="s1">FunctionExpression</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n      </span><span class="s1">delete funcNode.kind;</span><span class="s2">\n      </span><span class="s1">// @ts-expect-error mutate AST types</span><span class="s2">\n      </span><span class="s1">node.value = funcNode;</span><span class="s2">\n      </span><span class="s1">if (type === </span><span class="s2">\&quot;</span><span class="s1">ClassPrivateMethod</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">node.computed = false;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return this.finishNode(</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error cast methods to estree types</span><span class="s2">\n        </span><span class="s1">node as Undone&lt;N.EstreeMethodDefinition&gt;,</span><span class="s2">\n        \&quot;</span><span class="s1">MethodDefinition</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseClassProperty(...args: [N.ClassProperty]): any {</span><span class="s2">\n      </span><span class="s1">const propertyNode = super.parseClassProperty(...args) as any;</span><span class="s2">\n      </span><span class="s1">if (!process.env.BABEL_8_BREAKING) {</span><span class="s2">\n        </span><span class="s1">if (!this.getPluginOption(</span><span class="s2">\&quot;</span><span class="s1">estree</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">classFeatures</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n          </span><span class="s1">return propertyNode as N.EstreePropertyDefinition;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">propertyNode.type = </span><span class="s2">\&quot;</span><span class="s1">PropertyDefinition</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n      </span><span class="s1">return propertyNode as N.EstreePropertyDefinition;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseClassPrivateProperty(...args: [N.ClassPrivateProperty]): any {</span><span class="s2">\n      </span><span class="s1">const propertyNode = super.parseClassPrivateProperty(...args) as any;</span><span class="s2">\n      </span><span class="s1">if (!process.env.BABEL_8_BREAKING) {</span><span class="s2">\n        </span><span class="s1">if (!this.getPluginOption(</span><span class="s2">\&quot;</span><span class="s1">estree</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">classFeatures</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n          </span><span class="s1">return propertyNode as N.EstreePropertyDefinition;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">propertyNode.type = </span><span class="s2">\&quot;</span><span class="s1">PropertyDefinition</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n      </span><span class="s1">propertyNode.computed = false;</span><span class="s2">\n      </span><span class="s1">return propertyNode as N.EstreePropertyDefinition;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseObjectMethod(</span><span class="s2">\n      </span><span class="s1">prop: N.ObjectMethod,</span><span class="s2">\n      </span><span class="s1">isGenerator: boolean,</span><span class="s2">\n      </span><span class="s1">isAsync: boolean,</span><span class="s2">\n      </span><span class="s1">isPattern: boolean,</span><span class="s2">\n      </span><span class="s1">isAccessor: boolean,</span><span class="s2">\n    </span><span class="s1">): N.ObjectMethod | undefined | null {</span><span class="s2">\n      </span><span class="s1">const node: N.EstreeProperty = super.parseObjectMethod(</span><span class="s2">\n        </span><span class="s1">prop,</span><span class="s2">\n        </span><span class="s1">isGenerator,</span><span class="s2">\n        </span><span class="s1">isAsync,</span><span class="s2">\n        </span><span class="s1">isPattern,</span><span class="s2">\n        </span><span class="s1">isAccessor,</span><span class="s2">\n      </span><span class="s1">) as any;</span><span class="s2">\n\n      </span><span class="s1">if (node) {</span><span class="s2">\n        </span><span class="s1">node.type = </span><span class="s2">\&quot;</span><span class="s1">Property</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n        </span><span class="s1">if ((node as any as N.ClassMethod).kind === </span><span class="s2">\&quot;</span><span class="s1">method</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">node.kind = </span><span class="s2">\&quot;</span><span class="s1">init</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">node.shorthand = false;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return node as any;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseObjectProperty(</span><span class="s2">\n      </span><span class="s1">prop: N.ObjectProperty,</span><span class="s2">\n      </span><span class="s1">startLoc: Position | undefined | null,</span><span class="s2">\n      </span><span class="s1">isPattern: boolean,</span><span class="s2">\n      </span><span class="s1">refExpressionErrors?: ExpressionErrors | null,</span><span class="s2">\n    </span><span class="s1">): N.ObjectProperty | undefined | null {</span><span class="s2">\n      </span><span class="s1">const node: N.EstreeProperty = super.parseObjectProperty(</span><span class="s2">\n        </span><span class="s1">prop,</span><span class="s2">\n        </span><span class="s1">startLoc,</span><span class="s2">\n        </span><span class="s1">isPattern,</span><span class="s2">\n        </span><span class="s1">refExpressionErrors,</span><span class="s2">\n      </span><span class="s1">) as any;</span><span class="s2">\n\n      </span><span class="s1">if (node) {</span><span class="s2">\n        </span><span class="s1">node.kind = </span><span class="s2">\&quot;</span><span class="s1">init</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n        </span><span class="s1">node.type = </span><span class="s2">\&quot;</span><span class="s1">Property</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return node as any;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">isValidLVal(</span><span class="s2">\n      </span><span class="s1">type: string,</span><span class="s2">\n      </span><span class="s1">isUnparenthesizedInAssign: boolean,</span><span class="s2">\n      </span><span class="s1">binding: BindingTypes,</span><span class="s2">\n    </span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">return type === </span><span class="s2">\&quot;</span><span class="s1">Property</span><span class="s2">\&quot;\n        </span><span class="s1">? </span><span class="s2">\&quot;</span><span class="s1">value</span><span class="s2">\&quot;\n        </span><span class="s1">: super.isValidLVal(type, isUnparenthesizedInAssign, binding);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">isAssignable(node: N.Node, isBinding?: boolean): boolean {</span><span class="s2">\n      </span><span class="s1">if (node != null &amp;&amp; this.isObjectProperty(node)) {</span><span class="s2">\n        </span><span class="s1">return this.isAssignable(node.value, isBinding);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return super.isAssignable(node, isBinding);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">toAssignable(node: N.Node, isLHS: boolean = false): void {</span><span class="s2">\n      </span><span class="s1">if (node != null &amp;&amp; this.isObjectProperty(node)) {</span><span class="s2">\n        </span><span class="s1">const { key, value } = node;</span><span class="s2">\n        </span><span class="s1">if (this.isPrivateName(key)) {</span><span class="s2">\n          </span><span class="s1">this.classScope.usePrivateName(</span><span class="s2">\n            </span><span class="s1">this.getPrivateNameSV(key),</span><span class="s2">\n            </span><span class="s1">key.loc.start,</span><span class="s2">\n          </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">this.toAssignable(value, isLHS);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">super.toAssignable(node, isLHS);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">toAssignableObjectExpressionProp(</span><span class="s2">\n      </span><span class="s1">prop: N.Node,</span><span class="s2">\n      </span><span class="s1">isLast: boolean,</span><span class="s2">\n      </span><span class="s1">isLHS: boolean,</span><span class="s2">\n    </span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">if (prop.kind === </span><span class="s2">\&quot;</span><span class="s1">get</span><span class="s2">\&quot; </span><span class="s1">|| prop.kind === </span><span class="s2">\&quot;</span><span class="s1">set</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">this.raise(Errors.PatternHasAccessor, { at: prop.key });</span><span class="s2">\n      </span><span class="s1">} else if (prop.method) {</span><span class="s2">\n        </span><span class="s1">this.raise(Errors.PatternHasMethod, { at: prop.key });</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">super.toAssignableObjectExpressionProp(prop, isLast, isLHS);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">finishCallExpression&lt;T extends N.CallExpression | N.OptionalCallExpression&gt;(</span><span class="s2">\n      </span><span class="s1">unfinished: Undone&lt;T&gt;,</span><span class="s2">\n      </span><span class="s1">optional: boolean,</span><span class="s2">\n    </span><span class="s1">): T {</span><span class="s2">\n      </span><span class="s1">const node = super.finishCallExpression(unfinished, optional);</span><span class="s2">\n\n      </span><span class="s1">if (node.callee.type === </span><span class="s2">\&quot;</span><span class="s1">Import</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">(node as N.Node as N.EstreeImportExpression).type = </span><span class="s2">\&quot;</span><span class="s1">ImportExpression</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n        </span><span class="s1">(node as N.Node as N.EstreeImportExpression).source = node.arguments[0];</span><span class="s2">\n        </span><span class="s1">if (this.hasPlugin(</span><span class="s2">\&quot;</span><span class="s1">importAssertions</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n          </span><span class="s1">(node as N.Node as N.EstreeImportExpression).attributes =</span><span class="s2">\n            </span><span class="s1">node.arguments[1] ?? null;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// arguments isn't optional in the type definition</span><span class="s2">\n        </span><span class="s1">delete node.arguments;</span><span class="s2">\n        </span><span class="s1">// callee isn't optional in the type definition</span><span class="s2">\n        </span><span class="s1">delete node.callee;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return node;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">toReferencedArguments(</span><span class="s2">\n      </span><span class="s1">node:</span><span class="s2">\n        </span><span class="s1">| N.CallExpression</span><span class="s2">\n        </span><span class="s1">| N.OptionalCallExpression</span><span class="s2">\n        </span><span class="s1">| N.EstreeImportExpression,</span><span class="s2">\n      </span><span class="s1">/* isParenthesizedExpr?: boolean, */</span><span class="s2">\n    </span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">// ImportExpressions do not have an arguments array.</span><span class="s2">\n      </span><span class="s1">if (node.type === </span><span class="s2">\&quot;</span><span class="s1">ImportExpression</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">super.toReferencedArguments(node);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseExport(</span><span class="s2">\n      </span><span class="s1">unfinished: Undone&lt;N.AnyExport&gt;,</span><span class="s2">\n      </span><span class="s1">decorators: N.Decorator[] | null,</span><span class="s2">\n    </span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">const exportStartLoc = this.state.lastTokStartLoc;</span><span class="s2">\n      </span><span class="s1">const node = super.parseExport(unfinished, decorators);</span><span class="s2">\n\n      </span><span class="s1">switch (node.type) {</span><span class="s2">\n        </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">ExportAllDeclaration</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n          </span><span class="s1">// @ts-expect-error mutating AST types</span><span class="s2">\n          </span><span class="s1">node.exported = null;</span><span class="s2">\n          </span><span class="s1">break;</span><span class="s2">\n\n        </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">ExportNamedDeclaration</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n          </span><span class="s1">if (</span><span class="s2">\n            </span><span class="s1">node.specifiers.length === 1 &amp;&amp;</span><span class="s2">\n            </span><span class="s1">// @ts-expect-error mutating AST types</span><span class="s2">\n            </span><span class="s1">node.specifiers[0].type === </span><span class="s2">\&quot;</span><span class="s1">ExportNamespaceSpecifier</span><span class="s2">\&quot;\n          </span><span class="s1">) {</span><span class="s2">\n            </span><span class="s1">// @ts-expect-error mutating AST types</span><span class="s2">\n            </span><span class="s1">node.type = </span><span class="s2">\&quot;</span><span class="s1">ExportAllDeclaration</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n            </span><span class="s1">// @ts-expect-error mutating AST types</span><span class="s2">\n            </span><span class="s1">node.exported = node.specifiers[0].exported;</span><span class="s2">\n            </span><span class="s1">delete node.specifiers;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">// fallthrough</span><span class="s2">\n        </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">ExportDefaultDeclaration</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n          </span><span class="s1">{</span><span class="s2">\n            </span><span class="s1">const { declaration } = node;</span><span class="s2">\n            </span><span class="s1">if (</span><span class="s2">\n              </span><span class="s1">declaration?.type === </span><span class="s2">\&quot;</span><span class="s1">ClassDeclaration</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n              </span><span class="s1">declaration.decorators?.length &gt; 0 &amp;&amp;</span><span class="s2">\n              </span><span class="s1">// decorator comes before export</span><span class="s2">\n              </span><span class="s1">declaration.start === node.start</span><span class="s2">\n            </span><span class="s1">) {</span><span class="s2">\n              </span><span class="s1">this.resetStartLocation(</span><span class="s2">\n                </span><span class="s1">node,</span><span class="s2">\n                </span><span class="s1">// For compatibility with ESLint's keyword-spacing rule, which assumes that an</span><span class="s2">\n                </span><span class="s1">// export declaration must start with export.</span><span class="s2">\n                </span><span class="s1">// https://github.com/babel/babel/issues/15085</span><span class="s2">\n                </span><span class="s1">// Here we reset export declaration's start to be the start of the export token</span><span class="s2">\n                </span><span class="s1">exportStartLoc,</span><span class="s2">\n              </span><span class="s1">);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n\n          </span><span class="s1">break;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return node;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseSubscript(</span><span class="s2">\n      </span><span class="s1">base: N.Expression,</span><span class="s2">\n      </span><span class="s1">startLoc: Position,</span><span class="s2">\n      </span><span class="s1">noCalls: boolean | undefined | null,</span><span class="s2">\n      </span><span class="s1">state: N.ParseSubscriptState,</span><span class="s2">\n    </span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">const node = super.parseSubscript(base, startLoc, noCalls, state);</span><span class="s2">\n\n      </span><span class="s1">if (state.optionalChainMember) {</span><span class="s2">\n        </span><span class="s1">// https://github.com/estree/estree/blob/master/es2020.md#chainexpression</span><span class="s2">\n        </span><span class="s1">if (</span><span class="s2">\n          </span><span class="s1">node.type === </span><span class="s2">\&quot;</span><span class="s1">OptionalMemberExpression</span><span class="s2">\&quot; </span><span class="s1">||</span><span class="s2">\n          </span><span class="s1">node.type === </span><span class="s2">\&quot;</span><span class="s1">OptionalCallExpression</span><span class="s2">\&quot;\n        </span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">node.type = node.type.substring(8); // strip Optional prefix</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (state.stop) {</span><span class="s2">\n          </span><span class="s1">const chain = this.startNodeAtNode(node);</span><span class="s2">\n          </span><span class="s1">chain.expression = node;</span><span class="s2">\n          </span><span class="s1">return this.finishNode(chain, </span><span class="s2">\&quot;</span><span class="s1">ChainExpression</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">} else if (</span><span class="s2">\n        </span><span class="s1">node.type === </span><span class="s2">\&quot;</span><span class="s1">MemberExpression</span><span class="s2">\&quot; </span><span class="s1">||</span><span class="s2">\n        </span><span class="s1">node.type === </span><span class="s2">\&quot;</span><span class="s1">CallExpression</span><span class="s2">\&quot;\n      </span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">node.optional = false;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return node;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">hasPropertyAsPrivateName(node: N.Node): boolean {</span><span class="s2">\n      </span><span class="s1">if (node.type === </span><span class="s2">\&quot;</span><span class="s1">ChainExpression</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">node = node.expression;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return super.hasPropertyAsPrivateName(node);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// @ts-expect-error override interfaces</span><span class="s2">\n    </span><span class="s1">isObjectProperty(node: N.Node): boolean {</span><span class="s2">\n      </span><span class="s1">return node.type === </span><span class="s2">\&quot;</span><span class="s1">Property</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; node.kind === </span><span class="s2">\&quot;</span><span class="s1">init</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; !node.method;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">isObjectMethod(node: N.Node): boolean {</span><span class="s2">\n      </span><span class="s1">return node.method || node.kind === </span><span class="s2">\&quot;</span><span class="s1">get</span><span class="s2">\&quot; </span><span class="s1">|| node.kind === </span><span class="s2">\&quot;</span><span class="s1">set</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">finishNodeAt&lt;T extends NodeType&gt;(</span><span class="s2">\n      </span><span class="s1">node: Undone&lt;T&gt;,</span><span class="s2">\n      </span><span class="s1">type: T[</span><span class="s2">\&quot;</span><span class="s1">type</span><span class="s2">\&quot;</span><span class="s1">],</span><span class="s2">\n      </span><span class="s1">endLoc: Position,</span><span class="s2">\n    </span><span class="s1">): T {</span><span class="s2">\n      </span><span class="s1">return toESTreeLocation(super.finishNodeAt(node, type, endLoc));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">resetStartLocation(node: N.Node, startLoc: Position) {</span><span class="s2">\n      </span><span class="s1">super.resetStartLocation(node, startLoc);</span><span class="s2">\n      </span><span class="s1">toESTreeLocation(node);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">resetEndLocation(</span><span class="s2">\n      </span><span class="s1">node: NodeBase,</span><span class="s2">\n      </span><span class="s1">endLoc: Position = this.state.lastTokEndLoc,</span><span class="s2">\n    </span><span class="s1">): void {</span><span class="s2">\n      </span><span class="s1">super.resetEndLocation(node, endLoc);</span><span class="s2">\n      </span><span class="s1">toESTreeLocation(node);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">&quot;</span><span class="s2">,</span><span class="s1">&quot;import * as charCodes from </span><span class="s2">\&quot;</span><span class="s1">charcodes</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">// ## Character categories</span><span class="s2">\n\n</span><span class="s1">// Big ugly regular expressions that match characters in the</span><span class="s2">\n</span><span class="s1">// whitespace, identifier, and identifier-start categories. These</span><span class="s2">\n</span><span class="s1">// are only applied when a character is found to actually have a</span><span class="s2">\n</span><span class="s1">// code point between 0x80 and 0xffff.</span><span class="s2">\n</span><span class="s1">// Generated by `scripts/generate-identifier-regex.js`.</span><span class="s2">\n\n</span><span class="s1">/* prettier-ignore */</span><span class="s2">\n</span><span class="s1">let nonASCIIidentifierStartChars = </span><span class="s2">\&quot;\\</span><span class="s1">xaa</span><span class="s2">\\</span><span class="s1">xb5</span><span class="s2">\\</span><span class="s1">xba</span><span class="s2">\\</span><span class="s1">xc0-</span><span class="s2">\\</span><span class="s1">xd6</span><span class="s2">\\</span><span class="s1">xd8-</span><span class="s2">\\</span><span class="s1">xf6</span><span class="s2">\\</span><span class="s1">xf8-</span><span class="s2">\\</span><span class="s1">u02c1</span><span class="s2">\\</span><span class="s1">u02c6-</span><span class="s2">\\</span><span class="s1">u02d1</span><span class="s2">\\</span><span class="s1">u02e0-</span><span class="s2">\\</span><span class="s1">u02e4</span><span class="s2">\\</span><span class="s1">u02ec</span><span class="s2">\\</span><span class="s1">u02ee</span><span class="s2">\\</span><span class="s1">u0370-</span><span class="s2">\\</span><span class="s1">u0374</span><span class="s2">\\</span><span class="s1">u0376</span><span class="s2">\\</span><span class="s1">u0377</span><span class="s2">\\</span><span class="s1">u037a-</span><span class="s2">\\</span><span class="s1">u037d</span><span class="s2">\\</span><span class="s1">u037f</span><span class="s2">\\</span><span class="s1">u0386</span><span class="s2">\\</span><span class="s1">u0388-</span><span class="s2">\\</span><span class="s1">u038a</span><span class="s2">\\</span><span class="s1">u038c</span><span class="s2">\\</span><span class="s1">u038e-</span><span class="s2">\\</span><span class="s1">u03a1</span><span class="s2">\\</span><span class="s1">u03a3-</span><span class="s2">\\</span><span class="s1">u03f5</span><span class="s2">\\</span><span class="s1">u03f7-</span><span class="s2">\\</span><span class="s1">u0481</span><span class="s2">\\</span><span class="s1">u048a-</span><span class="s2">\\</span><span class="s1">u052f</span><span class="s2">\\</span><span class="s1">u0531-</span><span class="s2">\\</span><span class="s1">u0556</span><span class="s2">\\</span><span class="s1">u0559</span><span class="s2">\\</span><span class="s1">u0560-</span><span class="s2">\\</span><span class="s1">u0588</span><span class="s2">\\</span><span class="s1">u05d0-</span><span class="s2">\\</span><span class="s1">u05ea</span><span class="s2">\\</span><span class="s1">u05ef-</span><span class="s2">\\</span><span class="s1">u05f2</span><span class="s2">\\</span><span class="s1">u0620-</span><span class="s2">\\</span><span class="s1">u064a</span><span class="s2">\\</span><span class="s1">u066e</span><span class="s2">\\</span><span class="s1">u066f</span><span class="s2">\\</span><span class="s1">u0671-</span><span class="s2">\\</span><span class="s1">u06d3</span><span class="s2">\\</span><span class="s1">u06d5</span><span class="s2">\\</span><span class="s1">u06e5</span><span class="s2">\\</span><span class="s1">u06e6</span><span class="s2">\\</span><span class="s1">u06ee</span><span class="s2">\\</span><span class="s1">u06ef</span><span class="s2">\\</span><span class="s1">u06fa-</span><span class="s2">\\</span><span class="s1">u06fc</span><span class="s2">\\</span><span class="s1">u06ff</span><span class="s2">\\</span><span class="s1">u0710</span><span class="s2">\\</span><span class="s1">u0712-</span><span class="s2">\\</span><span class="s1">u072f</span><span class="s2">\\</span><span class="s1">u074d-</span><span class="s2">\\</span><span class="s1">u07a5</span><span class="s2">\\</span><span class="s1">u07b1</span><span class="s2">\\</span><span class="s1">u07ca-</span><span class="s2">\\</span><span class="s1">u07ea</span><span class="s2">\\</span><span class="s1">u07f4</span><span class="s2">\\</span><span class="s1">u07f5</span><span class="s2">\\</span><span class="s1">u07fa</span><span class="s2">\\</span><span class="s1">u0800-</span><span class="s2">\\</span><span class="s1">u0815</span><span class="s2">\\</span><span class="s1">u081a</span><span class="s2">\\</span><span class="s1">u0824</span><span class="s2">\\</span><span class="s1">u0828</span><span class="s2">\\</span><span class="s1">u0840-</span><span class="s2">\\</span><span class="s1">u0858</span><span class="s2">\\</span><span class="s1">u0860-</span><span class="s2">\\</span><span class="s1">u086a</span><span class="s2">\\</span><span class="s1">u0870-</span><span class="s2">\\</span><span class="s1">u0887</span><span class="s2">\\</span><span class="s1">u0889-</span><span class="s2">\\</span><span class="s1">u088e</span><span class="s2">\\</span><span class="s1">u08a0-</span><span class="s2">\\</span><span class="s1">u08c9</span><span class="s2">\\</span><span class="s1">u0904-</span><span class="s2">\\</span><span class="s1">u0939</span><span class="s2">\\</span><span class="s1">u093d</span><span class="s2">\\</span><span class="s1">u0950</span><span class="s2">\\</span><span class="s1">u0958-</span><span class="s2">\\</span><span class="s1">u0961</span><span class="s2">\\</span><span class="s1">u0971-</span><span class="s2">\\</span><span class="s1">u0980</span><span class="s2">\\</span><span class="s1">u0985-</span><span class="s2">\\</span><span class="s1">u098c</span><span class="s2">\\</span><span class="s1">u098f</span><span class="s2">\\</span><span class="s1">u0990</span><span class="s2">\\</span><span class="s1">u0993-</span><span class="s2">\\</span><span class="s1">u09a8</span><span class="s2">\\</span><span class="s1">u09aa-</span><span class="s2">\\</span><span class="s1">u09b0</span><span class="s2">\\</span><span class="s1">u09b2</span><span class="s2">\\</span><span class="s1">u09b6-</span><span class="s2">\\</span><span class="s1">u09b9</span><span class="s2">\\</span><span class="s1">u09bd</span><span class="s2">\\</span><span class="s1">u09ce</span><span class="s2">\\</span><span class="s1">u09dc</span><span class="s2">\\</span><span class="s1">u09dd</span><span class="s2">\\</span><span class="s1">u09df-</span><span class="s2">\\</span><span class="s1">u09e1</span><span class="s2">\\</span><span class="s1">u09f0</span><span class="s2">\\</span><span class="s1">u09f1</span><span class="s2">\\</span><span class="s1">u09fc</span><span class="s2">\\</span><span class="s1">u0a05-</span><span class="s2">\\</span><span class="s1">u0a0a</span><span class="s2">\\</span><span class="s1">u0a0f</span><span class="s2">\\</span><span class="s1">u0a10</span><span class="s2">\\</span><span class="s1">u0a13-</span><span class="s2">\\</span><span class="s1">u0a28</span><span class="s2">\\</span><span class="s1">u0a2a-</span><span class="s2">\\</span><span class="s1">u0a30</span><span class="s2">\\</span><span class="s1">u0a32</span><span class="s2">\\</span><span class="s1">u0a33</span><span class="s2">\\</span><span class="s1">u0a35</span><span class="s2">\\</span><span class="s1">u0a36</span><span class="s2">\\</span><span class="s1">u0a38</span><span class="s2">\\</span><span class="s1">u0a39</span><span class="s2">\\</span><span class="s1">u0a59-</span><span class="s2">\\</span><span class="s1">u0a5c</span><span class="s2">\\</span><span class="s1">u0a5e</span><span class="s2">\\</span><span class="s1">u0a72-</span><span class="s2">\\</span><span class="s1">u0a74</span><span class="s2">\\</span><span class="s1">u0a85-</span><span class="s2">\\</span><span class="s1">u0a8d</span><span class="s2">\\</span><span class="s1">u0a8f-</span><span class="s2">\\</span><span class="s1">u0a91</span><span class="s2">\\</span><span class="s1">u0a93-</span><span class="s2">\\</span><span class="s1">u0aa8</span><span class="s2">\\</span><span class="s1">u0aaa-</span><span class="s2">\\</span><span class="s1">u0ab0</span><span class="s2">\\</span><span class="s1">u0ab2</span><span class="s2">\\</span><span class="s1">u0ab3</span><span class="s2">\\</span><span class="s1">u0ab5-</span><span class="s2">\\</span><span class="s1">u0ab9</span><span class="s2">\\</span><span class="s1">u0abd</span><span class="s2">\\</span><span class="s1">u0ad0</span><span class="s2">\\</span><span class="s1">u0ae0</span><span class="s2">\\</span><span class="s1">u0ae1</span><span class="s2">\\</span><span class="s1">u0af9</span><span class="s2">\\</span><span class="s1">u0b05-</span><span class="s2">\\</span><span class="s1">u0b0c</span><span class="s2">\\</span><span class="s1">u0b0f</span><span class="s2">\\</span><span class="s1">u0b10</span><span class="s2">\\</span><span class="s1">u0b13-</span><span class="s2">\\</span><span class="s1">u0b28</span><span class="s2">\\</span><span class="s1">u0b2a-</span><span class="s2">\\</span><span class="s1">u0b30</span><span class="s2">\\</span><span class="s1">u0b32</span><span class="s2">\\</span><span class="s1">u0b33</span><span class="s2">\\</span><span class="s1">u0b35-</span><span class="s2">\\</span><span class="s1">u0b39</span><span class="s2">\\</span><span class="s1">u0b3d</span><span class="s2">\\</span><span class="s1">u0b5c</span><span class="s2">\\</span><span class="s1">u0b5d</span><span class="s2">\\</span><span class="s1">u0b5f-</span><span class="s2">\\</span><span class="s1">u0b61</span><span class="s2">\\</span><span class="s1">u0b71</span><span class="s2">\\</span><span class="s1">u0b83</span><span class="s2">\\</span><span class="s1">u0b85-</span><span class="s2">\\</span><span class="s1">u0b8a</span><span class="s2">\\</span><span class="s1">u0b8e-</span><span class="s2">\\</span><span class="s1">u0b90</span><span class="s2">\\</span><span class="s1">u0b92-</span><span class="s2">\\</span><span class="s1">u0b95</span><span class="s2">\\</span><span class="s1">u0b99</span><span class="s2">\\</span><span class="s1">u0b9a</span><span class="s2">\\</span><span class="s1">u0b9c</span><span class="s2">\\</span><span class="s1">u0b9e</span><span class="s2">\\</span><span class="s1">u0b9f</span><span class="s2">\\</span><span class="s1">u0ba3</span><span class="s2">\\</span><span class="s1">u0ba4</span><span class="s2">\\</span><span class="s1">u0ba8-</span><span class="s2">\\</span><span class="s1">u0baa</span><span class="s2">\\</span><span class="s1">u0bae-</span><span class="s2">\\</span><span class="s1">u0bb9</span><span class="s2">\\</span><span class="s1">u0bd0</span><span class="s2">\\</span><span class="s1">u0c05-</span><span class="s2">\\</span><span class="s1">u0c0c</span><span class="s2">\\</span><span class="s1">u0c0e-</span><span class="s2">\\</span><span class="s1">u0c10</span><span class="s2">\\</span><span class="s1">u0c12-</span><span class="s2">\\</span><span class="s1">u0c28</span><span class="s2">\\</span><span class="s1">u0c2a-</span><span class="s2">\\</span><span class="s1">u0c39</span><span class="s2">\\</span><span class="s1">u0c3d</span><span class="s2">\\</span><span class="s1">u0c58-</span><span class="s2">\\</span><span class="s1">u0c5a</span><span class="s2">\\</span><span class="s1">u0c5d</span><span class="s2">\\</span><span class="s1">u0c60</span><span class="s2">\\</span><span class="s1">u0c61</span><span class="s2">\\</span><span class="s1">u0c80</span><span class="s2">\\</span><span class="s1">u0c85-</span><span class="s2">\\</span><span class="s1">u0c8c</span><span class="s2">\\</span><span class="s1">u0c8e-</span><span class="s2">\\</span><span class="s1">u0c90</span><span class="s2">\\</span><span class="s1">u0c92-</span><span class="s2">\\</span><span class="s1">u0ca8</span><span class="s2">\\</span><span class="s1">u0caa-</span><span class="s2">\\</span><span class="s1">u0cb3</span><span class="s2">\\</span><span class="s1">u0cb5-</span><span class="s2">\\</span><span class="s1">u0cb9</span><span class="s2">\\</span><span class="s1">u0cbd</span><span class="s2">\\</span><span class="s1">u0cdd</span><span class="s2">\\</span><span class="s1">u0cde</span><span class="s2">\\</span><span class="s1">u0ce0</span><span class="s2">\\</span><span class="s1">u0ce1</span><span class="s2">\\</span><span class="s1">u0cf1</span><span class="s2">\\</span><span class="s1">u0cf2</span><span class="s2">\\</span><span class="s1">u0d04-</span><span class="s2">\\</span><span class="s1">u0d0c</span><span class="s2">\\</span><span class="s1">u0d0e-</span><span class="s2">\\</span><span class="s1">u0d10</span><span class="s2">\\</span><span class="s1">u0d12-</span><span class="s2">\\</span><span class="s1">u0d3a</span><span class="s2">\\</span><span class="s1">u0d3d</span><span class="s2">\\</span><span class="s1">u0d4e</span><span class="s2">\\</span><span class="s1">u0d54-</span><span class="s2">\\</span><span class="s1">u0d56</span><span class="s2">\\</span><span class="s1">u0d5f-</span><span class="s2">\\</span><span class="s1">u0d61</span><span class="s2">\\</span><span class="s1">u0d7a-</span><span class="s2">\\</span><span class="s1">u0d7f</span><span class="s2">\\</span><span class="s1">u0d85-</span><span class="s2">\\</span><span class="s1">u0d96</span><span class="s2">\\</span><span class="s1">u0d9a-</span><span class="s2">\\</span><span class="s1">u0db1</span><span class="s2">\\</span><span class="s1">u0db3-</span><span class="s2">\\</span><span class="s1">u0dbb</span><span class="s2">\\</span><span class="s1">u0dbd</span><span class="s2">\\</span><span class="s1">u0dc0-</span><span class="s2">\\</span><span class="s1">u0dc6</span><span class="s2">\\</span><span class="s1">u0e01-</span><span class="s2">\\</span><span class="s1">u0e30</span><span class="s2">\\</span><span class="s1">u0e32</span><span class="s2">\\</span><span class="s1">u0e33</span><span class="s2">\\</span><span class="s1">u0e40-</span><span class="s2">\\</span><span class="s1">u0e46</span><span class="s2">\\</span><span class="s1">u0e81</span><span class="s2">\\</span><span class="s1">u0e82</span><span class="s2">\\</span><span class="s1">u0e84</span><span class="s2">\\</span><span class="s1">u0e86-</span><span class="s2">\\</span><span class="s1">u0e8a</span><span class="s2">\\</span><span class="s1">u0e8c-</span><span class="s2">\\</span><span class="s1">u0ea3</span><span class="s2">\\</span><span class="s1">u0ea5</span><span class="s2">\\</span><span class="s1">u0ea7-</span><span class="s2">\\</span><span class="s1">u0eb0</span><span class="s2">\\</span><span class="s1">u0eb2</span><span class="s2">\\</span><span class="s1">u0eb3</span><span class="s2">\\</span><span class="s1">u0ebd</span><span class="s2">\\</span><span class="s1">u0ec0-</span><span class="s2">\\</span><span class="s1">u0ec4</span><span class="s2">\\</span><span class="s1">u0ec6</span><span class="s2">\\</span><span class="s1">u0edc-</span><span class="s2">\\</span><span class="s1">u0edf</span><span class="s2">\\</span><span class="s1">u0f00</span><span class="s2">\\</span><span class="s1">u0f40-</span><span class="s2">\\</span><span class="s1">u0f47</span><span class="s2">\\</span><span class="s1">u0f49-</span><span class="s2">\\</span><span class="s1">u0f6c</span><span class="s2">\\</span><span class="s1">u0f88-</span><span class="s2">\\</span><span class="s1">u0f8c</span><span class="s2">\\</span><span class="s1">u1000-</span><span class="s2">\\</span><span class="s1">u102a</span><span class="s2">\\</span><span class="s1">u103f</span><span class="s2">\\</span><span class="s1">u1050-</span><span class="s2">\\</span><span class="s1">u1055</span><span class="s2">\\</span><span class="s1">u105a-</span><span class="s2">\\</span><span class="s1">u105d</span><span class="s2">\\</span><span class="s1">u1061</span><span class="s2">\\</span><span class="s1">u1065</span><span class="s2">\\</span><span class="s1">u1066</span><span class="s2">\\</span><span class="s1">u106e-</span><span class="s2">\\</span><span class="s1">u1070</span><span class="s2">\\</span><span class="s1">u1075-</span><span class="s2">\\</span><span class="s1">u1081</span><span class="s2">\\</span><span class="s1">u108e</span><span class="s2">\\</span><span class="s1">u10a0-</span><span class="s2">\\</span><span class="s1">u10c5</span><span class="s2">\\</span><span class="s1">u10c7</span><span class="s2">\\</span><span class="s1">u10cd</span><span class="s2">\\</span><span class="s1">u10d0-</span><span class="s2">\\</span><span class="s1">u10fa</span><span class="s2">\\</span><span class="s1">u10fc-</span><span class="s2">\\</span><span class="s1">u1248</span><span class="s2">\\</span><span class="s1">u124a-</span><span class="s2">\\</span><span class="s1">u124d</span><span class="s2">\\</span><span class="s1">u1250-</span><span class="s2">\\</span><span class="s1">u1256</span><span class="s2">\\</span><span class="s1">u1258</span><span class="s2">\\</span><span class="s1">u125a-</span><span class="s2">\\</span><span class="s1">u125d</span><span class="s2">\\</span><span class="s1">u1260-</span><span class="s2">\\</span><span class="s1">u1288</span><span class="s2">\\</span><span class="s1">u128a-</span><span class="s2">\\</span><span class="s1">u128d</span><span class="s2">\\</span><span class="s1">u1290-</span><span class="s2">\\</span><span class="s1">u12b0</span><span class="s2">\\</span><span class="s1">u12b2-</span><span class="s2">\\</span><span class="s1">u12b5</span><span class="s2">\\</span><span class="s1">u12b8-</span><span class="s2">\\</span><span class="s1">u12be</span><span class="s2">\\</span><span class="s1">u12c0</span><span class="s2">\\</span><span class="s1">u12c2-</span><span class="s2">\\</span><span class="s1">u12c5</span><span class="s2">\\</span><span class="s1">u12c8-</span><span class="s2">\\</span><span class="s1">u12d6</span><span class="s2">\\</span><span class="s1">u12d8-</span><span class="s2">\\</span><span class="s1">u1310</span><span class="s2">\\</span><span class="s1">u1312-</span><span class="s2">\\</span><span class="s1">u1315</span><span class="s2">\\</span><span class="s1">u1318-</span><span class="s2">\\</span><span class="s1">u135a</span><span class="s2">\\</span><span class="s1">u1380-</span><span class="s2">\\</span><span class="s1">u138f</span><span class="s2">\\</span><span class="s1">u13a0-</span><span class="s2">\\</span><span class="s1">u13f5</span><span class="s2">\\</span><span class="s1">u13f8-</span><span class="s2">\\</span><span class="s1">u13fd</span><span class="s2">\\</span><span class="s1">u1401-</span><span class="s2">\\</span><span class="s1">u166c</span><span class="s2">\\</span><span class="s1">u166f-</span><span class="s2">\\</span><span class="s1">u167f</span><span class="s2">\\</span><span class="s1">u1681-</span><span class="s2">\\</span><span class="s1">u169a</span><span class="s2">\\</span><span class="s1">u16a0-</span><span class="s2">\\</span><span class="s1">u16ea</span><span class="s2">\\</span><span class="s1">u16ee-</span><span class="s2">\\</span><span class="s1">u16f8</span><span class="s2">\\</span><span class="s1">u1700-</span><span class="s2">\\</span><span class="s1">u1711</span><span class="s2">\\</span><span class="s1">u171f-</span><span class="s2">\\</span><span class="s1">u1731</span><span class="s2">\\</span><span class="s1">u1740-</span><span class="s2">\\</span><span class="s1">u1751</span><span class="s2">\\</span><span class="s1">u1760-</span><span class="s2">\\</span><span class="s1">u176c</span><span class="s2">\\</span><span class="s1">u176e-</span><span class="s2">\\</span><span class="s1">u1770</span><span class="s2">\\</span><span class="s1">u1780-</span><span class="s2">\\</span><span class="s1">u17b3</span><span class="s2">\\</span><span class="s1">u17d7</span><span class="s2">\\</span><span class="s1">u17dc</span><span class="s2">\\</span><span class="s1">u1820-</span><span class="s2">\\</span><span class="s1">u1878</span><span class="s2">\\</span><span class="s1">u1880-</span><span class="s2">\\</span><span class="s1">u18a8</span><span class="s2">\\</span><span class="s1">u18aa</span><span class="s2">\\</span><span class="s1">u18b0-</span><span class="s2">\\</span><span class="s1">u18f5</span><span class="s2">\\</span><span class="s1">u1900-</span><span class="s2">\\</span><span class="s1">u191e</span><span class="s2">\\</span><span class="s1">u1950-</span><span class="s2">\\</span><span class="s1">u196d</span><span class="s2">\\</span><span class="s1">u1970-</span><span class="s2">\\</span><span class="s1">u1974</span><span class="s2">\\</span><span class="s1">u1980-</span><span class="s2">\\</span><span class="s1">u19ab</span><span class="s2">\\</span><span class="s1">u19b0-</span><span class="s2">\\</span><span class="s1">u19c9</span><span class="s2">\\</span><span class="s1">u1a00-</span><span class="s2">\\</span><span class="s1">u1a16</span><span class="s2">\\</span><span class="s1">u1a20-</span><span class="s2">\\</span><span class="s1">u1a54</span><span class="s2">\\</span><span class="s1">u1aa7</span><span class="s2">\\</span><span class="s1">u1b05-</span><span class="s2">\\</span><span class="s1">u1b33</span><span class="s2">\\</span><span class="s1">u1b45-</span><span class="s2">\\</span><span class="s1">u1b4c</span><span class="s2">\\</span><span class="s1">u1b83-</span><span class="s2">\\</span><span class="s1">u1ba0</span><span class="s2">\\</span><span class="s1">u1bae</span><span class="s2">\\</span><span class="s1">u1baf</span><span class="s2">\\</span><span class="s1">u1bba-</span><span class="s2">\\</span><span class="s1">u1be5</span><span class="s2">\\</span><span class="s1">u1c00-</span><span class="s2">\\</span><span class="s1">u1c23</span><span class="s2">\\</span><span class="s1">u1c4d-</span><span class="s2">\\</span><span class="s1">u1c4f</span><span class="s2">\\</span><span class="s1">u1c5a-</span><span class="s2">\\</span><span class="s1">u1c7d</span><span class="s2">\\</span><span class="s1">u1c80-</span><span class="s2">\\</span><span class="s1">u1c88</span><span class="s2">\\</span><span class="s1">u1c90-</span><span class="s2">\\</span><span class="s1">u1cba</span><span class="s2">\\</span><span class="s1">u1cbd-</span><span class="s2">\\</span><span class="s1">u1cbf</span><span class="s2">\\</span><span class="s1">u1ce9-</span><span class="s2">\\</span><span class="s1">u1cec</span><span class="s2">\\</span><span class="s1">u1cee-</span><span class="s2">\\</span><span class="s1">u1cf3</span><span class="s2">\\</span><span class="s1">u1cf5</span><span class="s2">\\</span><span class="s1">u1cf6</span><span class="s2">\\</span><span class="s1">u1cfa</span><span class="s2">\\</span><span class="s1">u1d00-</span><span class="s2">\\</span><span class="s1">u1dbf</span><span class="s2">\\</span><span class="s1">u1e00-</span><span class="s2">\\</span><span class="s1">u1f15</span><span class="s2">\\</span><span class="s1">u1f18-</span><span class="s2">\\</span><span class="s1">u1f1d</span><span class="s2">\\</span><span class="s1">u1f20-</span><span class="s2">\\</span><span class="s1">u1f45</span><span class="s2">\\</span><span class="s1">u1f48-</span><span class="s2">\\</span><span class="s1">u1f4d</span><span class="s2">\\</span><span class="s1">u1f50-</span><span class="s2">\\</span><span class="s1">u1f57</span><span class="s2">\\</span><span class="s1">u1f59</span><span class="s2">\\</span><span class="s1">u1f5b</span><span class="s2">\\</span><span class="s1">u1f5d</span><span class="s2">\\</span><span class="s1">u1f5f-</span><span class="s2">\\</span><span class="s1">u1f7d</span><span class="s2">\\</span><span class="s1">u1f80-</span><span class="s2">\\</span><span class="s1">u1fb4</span><span class="s2">\\</span><span class="s1">u1fb6-</span><span class="s2">\\</span><span class="s1">u1fbc</span><span class="s2">\\</span><span class="s1">u1fbe</span><span class="s2">\\</span><span class="s1">u1fc2-</span><span class="s2">\\</span><span class="s1">u1fc4</span><span class="s2">\\</span><span class="s1">u1fc6-</span><span class="s2">\\</span><span class="s1">u1fcc</span><span class="s2">\\</span><span class="s1">u1fd0-</span><span class="s2">\\</span><span class="s1">u1fd3</span><span class="s2">\\</span><span class="s1">u1fd6-</span><span class="s2">\\</span><span class="s1">u1fdb</span><span class="s2">\\</span><span class="s1">u1fe0-</span><span class="s2">\\</span><span class="s1">u1fec</span><span class="s2">\\</span><span class="s1">u1ff2-</span><span class="s2">\\</span><span class="s1">u1ff4</span><span class="s2">\\</span><span class="s1">u1ff6-</span><span class="s2">\\</span><span class="s1">u1ffc</span><span class="s2">\\</span><span class="s1">u2071</span><span class="s2">\\</span><span class="s1">u207f</span><span class="s2">\\</span><span class="s1">u2090-</span><span class="s2">\\</span><span class="s1">u209c</span><span class="s2">\\</span><span class="s1">u2102</span><span class="s2">\\</span><span class="s1">u2107</span><span class="s2">\\</span><span class="s1">u210a-</span><span class="s2">\\</span><span class="s1">u2113</span><span class="s2">\\</span><span class="s1">u2115</span><span class="s2">\\</span><span class="s1">u2118-</span><span class="s2">\\</span><span class="s1">u211d</span><span class="s2">\\</span><span class="s1">u2124</span><span class="s2">\\</span><span class="s1">u2126</span><span class="s2">\\</span><span class="s1">u2128</span><span class="s2">\\</span><span class="s1">u212a-</span><span class="s2">\\</span><span class="s1">u2139</span><span class="s2">\\</span><span class="s1">u213c-</span><span class="s2">\\</span><span class="s1">u213f</span><span class="s2">\\</span><span class="s1">u2145-</span><span class="s2">\\</span><span class="s1">u2149</span><span class="s2">\\</span><span class="s1">u214e</span><span class="s2">\\</span><span class="s1">u2160-</span><span class="s2">\\</span><span class="s1">u2188</span><span class="s2">\\</span><span class="s1">u2c00-</span><span class="s2">\\</span><span class="s1">u2ce4</span><span class="s2">\\</span><span class="s1">u2ceb-</span><span class="s2">\\</span><span class="s1">u2cee</span><span class="s2">\\</span><span class="s1">u2cf2</span><span class="s2">\\</span><span class="s1">u2cf3</span><span class="s2">\\</span><span class="s1">u2d00-</span><span class="s2">\\</span><span class="s1">u2d25</span><span class="s2">\\</span><span class="s1">u2d27</span><span class="s2">\\</span><span class="s1">u2d2d</span><span class="s2">\\</span><span class="s1">u2d30-</span><span class="s2">\\</span><span class="s1">u2d67</span><span class="s2">\\</span><span class="s1">u2d6f</span><span class="s2">\\</span><span class="s1">u2d80-</span><span class="s2">\\</span><span class="s1">u2d96</span><span class="s2">\\</span><span class="s1">u2da0-</span><span class="s2">\\</span><span class="s1">u2da6</span><span class="s2">\\</span><span class="s1">u2da8-</span><span class="s2">\\</span><span class="s1">u2dae</span><span class="s2">\\</span><span class="s1">u2db0-</span><span class="s2">\\</span><span class="s1">u2db6</span><span class="s2">\\</span><span class="s1">u2db8-</span><span class="s2">\\</span><span class="s1">u2dbe</span><span class="s2">\\</span><span class="s1">u2dc0-</span><span class="s2">\\</span><span class="s1">u2dc6</span><span class="s2">\\</span><span class="s1">u2dc8-</span><span class="s2">\\</span><span class="s1">u2dce</span><span class="s2">\\</span><span class="s1">u2dd0-</span><span class="s2">\\</span><span class="s1">u2dd6</span><span class="s2">\\</span><span class="s1">u2dd8-</span><span class="s2">\\</span><span class="s1">u2dde</span><span class="s2">\\</span><span class="s1">u3005-</span><span class="s2">\\</span><span class="s1">u3007</span><span class="s2">\\</span><span class="s1">u3021-</span><span class="s2">\\</span><span class="s1">u3029</span><span class="s2">\\</span><span class="s1">u3031-</span><span class="s2">\\</span><span class="s1">u3035</span><span class="s2">\\</span><span class="s1">u3038-</span><span class="s2">\\</span><span class="s1">u303c</span><span class="s2">\\</span><span class="s1">u3041-</span><span class="s2">\\</span><span class="s1">u3096</span><span class="s2">\\</span><span class="s1">u309b-</span><span class="s2">\\</span><span class="s1">u309f</span><span class="s2">\\</span><span class="s1">u30a1-</span><span class="s2">\\</span><span class="s1">u30fa</span><span class="s2">\\</span><span class="s1">u30fc-</span><span class="s2">\\</span><span class="s1">u30ff</span><span class="s2">\\</span><span class="s1">u3105-</span><span class="s2">\\</span><span class="s1">u312f</span><span class="s2">\\</span><span class="s1">u3131-</span><span class="s2">\\</span><span class="s1">u318e</span><span class="s2">\\</span><span class="s1">u31a0-</span><span class="s2">\\</span><span class="s1">u31bf</span><span class="s2">\\</span><span class="s1">u31f0-</span><span class="s2">\\</span><span class="s1">u31ff</span><span class="s2">\\</span><span class="s1">u3400-</span><span class="s2">\\</span><span class="s1">u4dbf</span><span class="s2">\\</span><span class="s1">u4e00-</span><span class="s2">\\</span><span class="s1">ua48c</span><span class="s2">\\</span><span class="s1">ua4d0-</span><span class="s2">\\</span><span class="s1">ua4fd</span><span class="s2">\\</span><span class="s1">ua500-</span><span class="s2">\\</span><span class="s1">ua60c</span><span class="s2">\\</span><span class="s1">ua610-</span><span class="s2">\\</span><span class="s1">ua61f</span><span class="s2">\\</span><span class="s1">ua62a</span><span class="s2">\\</span><span class="s1">ua62b</span><span class="s2">\\</span><span class="s1">ua640-</span><span class="s2">\\</span><span class="s1">ua66e</span><span class="s2">\\</span><span class="s1">ua67f-</span><span class="s2">\\</span><span class="s1">ua69d</span><span class="s2">\\</span><span class="s1">ua6a0-</span><span class="s2">\\</span><span class="s1">ua6ef</span><span class="s2">\\</span><span class="s1">ua717-</span><span class="s2">\\</span><span class="s1">ua71f</span><span class="s2">\\</span><span class="s1">ua722-</span><span class="s2">\\</span><span class="s1">ua788</span><span class="s2">\\</span><span class="s1">ua78b-</span><span class="s2">\\</span><span class="s1">ua7ca</span><span class="s2">\\</span><span class="s1">ua7d0</span><span class="s2">\\</span><span class="s1">ua7d1</span><span class="s2">\\</span><span class="s1">ua7d3</span><span class="s2">\\</span><span class="s1">ua7d5-</span><span class="s2">\\</span><span class="s1">ua7d9</span><span class="s2">\\</span><span class="s1">ua7f2-</span><span class="s2">\\</span><span class="s1">ua801</span><span class="s2">\\</span><span class="s1">ua803-</span><span class="s2">\\</span><span class="s1">ua805</span><span class="s2">\\</span><span class="s1">ua807-</span><span class="s2">\\</span><span class="s1">ua80a</span><span class="s2">\\</span><span class="s1">ua80c-</span><span class="s2">\\</span><span class="s1">ua822</span><span class="s2">\\</span><span class="s1">ua840-</span><span class="s2">\\</span><span class="s1">ua873</span><span class="s2">\\</span><span class="s1">ua882-</span><span class="s2">\\</span><span class="s1">ua8b3</span><span class="s2">\\</span><span class="s1">ua8f2-</span><span class="s2">\\</span><span class="s1">ua8f7</span><span class="s2">\\</span><span class="s1">ua8fb</span><span class="s2">\\</span><span class="s1">ua8fd</span><span class="s2">\\</span><span class="s1">ua8fe</span><span class="s2">\\</span><span class="s1">ua90a-</span><span class="s2">\\</span><span class="s1">ua925</span><span class="s2">\\</span><span class="s1">ua930-</span><span class="s2">\\</span><span class="s1">ua946</span><span class="s2">\\</span><span class="s1">ua960-</span><span class="s2">\\</span><span class="s1">ua97c</span><span class="s2">\\</span><span class="s1">ua984-</span><span class="s2">\\</span><span class="s1">ua9b2</span><span class="s2">\\</span><span class="s1">ua9cf</span><span class="s2">\\</span><span class="s1">ua9e0-</span><span class="s2">\\</span><span class="s1">ua9e4</span><span class="s2">\\</span><span class="s1">ua9e6-</span><span class="s2">\\</span><span class="s1">ua9ef</span><span class="s2">\\</span><span class="s1">ua9fa-</span><span class="s2">\\</span><span class="s1">ua9fe</span><span class="s2">\\</span><span class="s1">uaa00-</span><span class="s2">\\</span><span class="s1">uaa28</span><span class="s2">\\</span><span class="s1">uaa40-</span><span class="s2">\\</span><span class="s1">uaa42</span><span class="s2">\\</span><span class="s1">uaa44-</span><span class="s2">\\</span><span class="s1">uaa4b</span><span class="s2">\\</span><span class="s1">uaa60-</span><span class="s2">\\</span><span class="s1">uaa76</span><span class="s2">\\</span><span class="s1">uaa7a</span><span class="s2">\\</span><span class="s1">uaa7e-</span><span class="s2">\\</span><span class="s1">uaaaf</span><span class="s2">\\</span><span class="s1">uaab1</span><span class="s2">\\</span><span class="s1">uaab5</span><span class="s2">\\</span><span class="s1">uaab6</span><span class="s2">\\</span><span class="s1">uaab9-</span><span class="s2">\\</span><span class="s1">uaabd</span><span class="s2">\\</span><span class="s1">uaac0</span><span class="s2">\\</span><span class="s1">uaac2</span><span class="s2">\\</span><span class="s1">uaadb-</span><span class="s2">\\</span><span class="s1">uaadd</span><span class="s2">\\</span><span class="s1">uaae0-</span><span class="s2">\\</span><span class="s1">uaaea</span><span class="s2">\\</span><span class="s1">uaaf2-</span><span class="s2">\\</span><span class="s1">uaaf4</span><span class="s2">\\</span><span class="s1">uab01-</span><span class="s2">\\</span><span class="s1">uab06</span><span class="s2">\\</span><span class="s1">uab09-</span><span class="s2">\\</span><span class="s1">uab0e</span><span class="s2">\\</span><span class="s1">uab11-</span><span class="s2">\\</span><span class="s1">uab16</span><span class="s2">\\</span><span class="s1">uab20-</span><span class="s2">\\</span><span class="s1">uab26</span><span class="s2">\\</span><span class="s1">uab28-</span><span class="s2">\\</span><span class="s1">uab2e</span><span class="s2">\\</span><span class="s1">uab30-</span><span class="s2">\\</span><span class="s1">uab5a</span><span class="s2">\\</span><span class="s1">uab5c-</span><span class="s2">\\</span><span class="s1">uab69</span><span class="s2">\\</span><span class="s1">uab70-</span><span class="s2">\\</span><span class="s1">uabe2</span><span class="s2">\\</span><span class="s1">uac00-</span><span class="s2">\\</span><span class="s1">ud7a3</span><span class="s2">\\</span><span class="s1">ud7b0-</span><span class="s2">\\</span><span class="s1">ud7c6</span><span class="s2">\\</span><span class="s1">ud7cb-</span><span class="s2">\\</span><span class="s1">ud7fb</span><span class="s2">\\</span><span class="s1">uf900-</span><span class="s2">\\</span><span class="s1">ufa6d</span><span class="s2">\\</span><span class="s1">ufa70-</span><span class="s2">\\</span><span class="s1">ufad9</span><span class="s2">\\</span><span class="s1">ufb00-</span><span class="s2">\\</span><span class="s1">ufb06</span><span class="s2">\\</span><span class="s1">ufb13-</span><span class="s2">\\</span><span class="s1">ufb17</span><span class="s2">\\</span><span class="s1">ufb1d</span><span class="s2">\\</span><span class="s1">ufb1f-</span><span class="s2">\\</span><span class="s1">ufb28</span><span class="s2">\\</span><span class="s1">ufb2a-</span><span class="s2">\\</span><span class="s1">ufb36</span><span class="s2">\\</span><span class="s1">ufb38-</span><span class="s2">\\</span><span class="s1">ufb3c</span><span class="s2">\\</span><span class="s1">ufb3e</span><span class="s2">\\</span><span class="s1">ufb40</span><span class="s2">\\</span><span class="s1">ufb41</span><span class="s2">\\</span><span class="s1">ufb43</span><span class="s2">\\</span><span class="s1">ufb44</span><span class="s2">\\</span><span class="s1">ufb46-</span><span class="s2">\\</span><span class="s1">ufbb1</span><span class="s2">\\</span><span class="s1">ufbd3-</span><span class="s2">\\</span><span class="s1">ufd3d</span><span class="s2">\\</span><span class="s1">ufd50-</span><span class="s2">\\</span><span class="s1">ufd8f</span><span class="s2">\\</span><span class="s1">ufd92-</span><span class="s2">\\</span><span class="s1">ufdc7</span><span class="s2">\\</span><span class="s1">ufdf0-</span><span class="s2">\\</span><span class="s1">ufdfb</span><span class="s2">\\</span><span class="s1">ufe70-</span><span class="s2">\\</span><span class="s1">ufe74</span><span class="s2">\\</span><span class="s1">ufe76-</span><span class="s2">\\</span><span class="s1">ufefc</span><span class="s2">\\</span><span class="s1">uff21-</span><span class="s2">\\</span><span class="s1">uff3a</span><span class="s2">\\</span><span class="s1">uff41-</span><span class="s2">\\</span><span class="s1">uff5a</span><span class="s2">\\</span><span class="s1">uff66-</span><span class="s2">\\</span><span class="s1">uffbe</span><span class="s2">\\</span><span class="s1">uffc2-</span><span class="s2">\\</span><span class="s1">uffc7</span><span class="s2">\\</span><span class="s1">uffca-</span><span class="s2">\\</span><span class="s1">uffcf</span><span class="s2">\\</span><span class="s1">uffd2-</span><span class="s2">\\</span><span class="s1">uffd7</span><span class="s2">\\</span><span class="s1">uffda-</span><span class="s2">\\</span><span class="s1">uffdc</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">/* prettier-ignore */</span><span class="s2">\n</span><span class="s1">let nonASCIIidentifierChars = </span><span class="s2">\&quot;\\</span><span class="s1">u200c</span><span class="s2">\\</span><span class="s1">u200d</span><span class="s2">\\</span><span class="s1">xb7</span><span class="s2">\\</span><span class="s1">u0300-</span><span class="s2">\\</span><span class="s1">u036f</span><span class="s2">\\</span><span class="s1">u0387</span><span class="s2">\\</span><span class="s1">u0483-</span><span class="s2">\\</span><span class="s1">u0487</span><span class="s2">\\</span><span class="s1">u0591-</span><span class="s2">\\</span><span class="s1">u05bd</span><span class="s2">\\</span><span class="s1">u05bf</span><span class="s2">\\</span><span class="s1">u05c1</span><span class="s2">\\</span><span class="s1">u05c2</span><span class="s2">\\</span><span class="s1">u05c4</span><span class="s2">\\</span><span class="s1">u05c5</span><span class="s2">\\</span><span class="s1">u05c7</span><span class="s2">\\</span><span class="s1">u0610-</span><span class="s2">\\</span><span class="s1">u061a</span><span class="s2">\\</span><span class="s1">u064b-</span><span class="s2">\\</span><span class="s1">u0669</span><span class="s2">\\</span><span class="s1">u0670</span><span class="s2">\\</span><span class="s1">u06d6-</span><span class="s2">\\</span><span class="s1">u06dc</span><span class="s2">\\</span><span class="s1">u06df-</span><span class="s2">\\</span><span class="s1">u06e4</span><span class="s2">\\</span><span class="s1">u06e7</span><span class="s2">\\</span><span class="s1">u06e8</span><span class="s2">\\</span><span class="s1">u06ea-</span><span class="s2">\\</span><span class="s1">u06ed</span><span class="s2">\\</span><span class="s1">u06f0-</span><span class="s2">\\</span><span class="s1">u06f9</span><span class="s2">\\</span><span class="s1">u0711</span><span class="s2">\\</span><span class="s1">u0730-</span><span class="s2">\\</span><span class="s1">u074a</span><span class="s2">\\</span><span class="s1">u07a6-</span><span class="s2">\\</span><span class="s1">u07b0</span><span class="s2">\\</span><span class="s1">u07c0-</span><span class="s2">\\</span><span class="s1">u07c9</span><span class="s2">\\</span><span class="s1">u07eb-</span><span class="s2">\\</span><span class="s1">u07f3</span><span class="s2">\\</span><span class="s1">u07fd</span><span class="s2">\\</span><span class="s1">u0816-</span><span class="s2">\\</span><span class="s1">u0819</span><span class="s2">\\</span><span class="s1">u081b-</span><span class="s2">\\</span><span class="s1">u0823</span><span class="s2">\\</span><span class="s1">u0825-</span><span class="s2">\\</span><span class="s1">u0827</span><span class="s2">\\</span><span class="s1">u0829-</span><span class="s2">\\</span><span class="s1">u082d</span><span class="s2">\\</span><span class="s1">u0859-</span><span class="s2">\\</span><span class="s1">u085b</span><span class="s2">\\</span><span class="s1">u0898-</span><span class="s2">\\</span><span class="s1">u089f</span><span class="s2">\\</span><span class="s1">u08ca-</span><span class="s2">\\</span><span class="s1">u08e1</span><span class="s2">\\</span><span class="s1">u08e3-</span><span class="s2">\\</span><span class="s1">u0903</span><span class="s2">\\</span><span class="s1">u093a-</span><span class="s2">\\</span><span class="s1">u093c</span><span class="s2">\\</span><span class="s1">u093e-</span><span class="s2">\\</span><span class="s1">u094f</span><span class="s2">\\</span><span class="s1">u0951-</span><span class="s2">\\</span><span class="s1">u0957</span><span class="s2">\\</span><span class="s1">u0962</span><span class="s2">\\</span><span class="s1">u0963</span><span class="s2">\\</span><span class="s1">u0966-</span><span class="s2">\\</span><span class="s1">u096f</span><span class="s2">\\</span><span class="s1">u0981-</span><span class="s2">\\</span><span class="s1">u0983</span><span class="s2">\\</span><span class="s1">u09bc</span><span class="s2">\\</span><span class="s1">u09be-</span><span class="s2">\\</span><span class="s1">u09c4</span><span class="s2">\\</span><span class="s1">u09c7</span><span class="s2">\\</span><span class="s1">u09c8</span><span class="s2">\\</span><span class="s1">u09cb-</span><span class="s2">\\</span><span class="s1">u09cd</span><span class="s2">\\</span><span class="s1">u09d7</span><span class="s2">\\</span><span class="s1">u09e2</span><span class="s2">\\</span><span class="s1">u09e3</span><span class="s2">\\</span><span class="s1">u09e6-</span><span class="s2">\\</span><span class="s1">u09ef</span><span class="s2">\\</span><span class="s1">u09fe</span><span class="s2">\\</span><span class="s1">u0a01-</span><span class="s2">\\</span><span class="s1">u0a03</span><span class="s2">\\</span><span class="s1">u0a3c</span><span class="s2">\\</span><span class="s1">u0a3e-</span><span class="s2">\\</span><span class="s1">u0a42</span><span class="s2">\\</span><span class="s1">u0a47</span><span class="s2">\\</span><span class="s1">u0a48</span><span class="s2">\\</span><span class="s1">u0a4b-</span><span class="s2">\\</span><span class="s1">u0a4d</span><span class="s2">\\</span><span class="s1">u0a51</span><span class="s2">\\</span><span class="s1">u0a66-</span><span class="s2">\\</span><span class="s1">u0a71</span><span class="s2">\\</span><span class="s1">u0a75</span><span class="s2">\\</span><span class="s1">u0a81-</span><span class="s2">\\</span><span class="s1">u0a83</span><span class="s2">\\</span><span class="s1">u0abc</span><span class="s2">\\</span><span class="s1">u0abe-</span><span class="s2">\\</span><span class="s1">u0ac5</span><span class="s2">\\</span><span class="s1">u0ac7-</span><span class="s2">\\</span><span class="s1">u0ac9</span><span class="s2">\\</span><span class="s1">u0acb-</span><span class="s2">\\</span><span class="s1">u0acd</span><span class="s2">\\</span><span class="s1">u0ae2</span><span class="s2">\\</span><span class="s1">u0ae3</span><span class="s2">\\</span><span class="s1">u0ae6-</span><span class="s2">\\</span><span class="s1">u0aef</span><span class="s2">\\</span><span class="s1">u0afa-</span><span class="s2">\\</span><span class="s1">u0aff</span><span class="s2">\\</span><span class="s1">u0b01-</span><span class="s2">\\</span><span class="s1">u0b03</span><span class="s2">\\</span><span class="s1">u0b3c</span><span class="s2">\\</span><span class="s1">u0b3e-</span><span class="s2">\\</span><span class="s1">u0b44</span><span class="s2">\\</span><span class="s1">u0b47</span><span class="s2">\\</span><span class="s1">u0b48</span><span class="s2">\\</span><span class="s1">u0b4b-</span><span class="s2">\\</span><span class="s1">u0b4d</span><span class="s2">\\</span><span class="s1">u0b55-</span><span class="s2">\\</span><span class="s1">u0b57</span><span class="s2">\\</span><span class="s1">u0b62</span><span class="s2">\\</span><span class="s1">u0b63</span><span class="s2">\\</span><span class="s1">u0b66-</span><span class="s2">\\</span><span class="s1">u0b6f</span><span class="s2">\\</span><span class="s1">u0b82</span><span class="s2">\\</span><span class="s1">u0bbe-</span><span class="s2">\\</span><span class="s1">u0bc2</span><span class="s2">\\</span><span class="s1">u0bc6-</span><span class="s2">\\</span><span class="s1">u0bc8</span><span class="s2">\\</span><span class="s1">u0bca-</span><span class="s2">\\</span><span class="s1">u0bcd</span><span class="s2">\\</span><span class="s1">u0bd7</span><span class="s2">\\</span><span class="s1">u0be6-</span><span class="s2">\\</span><span class="s1">u0bef</span><span class="s2">\\</span><span class="s1">u0c00-</span><span class="s2">\\</span><span class="s1">u0c04</span><span class="s2">\\</span><span class="s1">u0c3c</span><span class="s2">\\</span><span class="s1">u0c3e-</span><span class="s2">\\</span><span class="s1">u0c44</span><span class="s2">\\</span><span class="s1">u0c46-</span><span class="s2">\\</span><span class="s1">u0c48</span><span class="s2">\\</span><span class="s1">u0c4a-</span><span class="s2">\\</span><span class="s1">u0c4d</span><span class="s2">\\</span><span class="s1">u0c55</span><span class="s2">\\</span><span class="s1">u0c56</span><span class="s2">\\</span><span class="s1">u0c62</span><span class="s2">\\</span><span class="s1">u0c63</span><span class="s2">\\</span><span class="s1">u0c66-</span><span class="s2">\\</span><span class="s1">u0c6f</span><span class="s2">\\</span><span class="s1">u0c81-</span><span class="s2">\\</span><span class="s1">u0c83</span><span class="s2">\\</span><span class="s1">u0cbc</span><span class="s2">\\</span><span class="s1">u0cbe-</span><span class="s2">\\</span><span class="s1">u0cc4</span><span class="s2">\\</span><span class="s1">u0cc6-</span><span class="s2">\\</span><span class="s1">u0cc8</span><span class="s2">\\</span><span class="s1">u0cca-</span><span class="s2">\\</span><span class="s1">u0ccd</span><span class="s2">\\</span><span class="s1">u0cd5</span><span class="s2">\\</span><span class="s1">u0cd6</span><span class="s2">\\</span><span class="s1">u0ce2</span><span class="s2">\\</span><span class="s1">u0ce3</span><span class="s2">\\</span><span class="s1">u0ce6-</span><span class="s2">\\</span><span class="s1">u0cef</span><span class="s2">\\</span><span class="s1">u0cf3</span><span class="s2">\\</span><span class="s1">u0d00-</span><span class="s2">\\</span><span class="s1">u0d03</span><span class="s2">\\</span><span class="s1">u0d3b</span><span class="s2">\\</span><span class="s1">u0d3c</span><span class="s2">\\</span><span class="s1">u0d3e-</span><span class="s2">\\</span><span class="s1">u0d44</span><span class="s2">\\</span><span class="s1">u0d46-</span><span class="s2">\\</span><span class="s1">u0d48</span><span class="s2">\\</span><span class="s1">u0d4a-</span><span class="s2">\\</span><span class="s1">u0d4d</span><span class="s2">\\</span><span class="s1">u0d57</span><span class="s2">\\</span><span class="s1">u0d62</span><span class="s2">\\</span><span class="s1">u0d63</span><span class="s2">\\</span><span class="s1">u0d66-</span><span class="s2">\\</span><span class="s1">u0d6f</span><span class="s2">\\</span><span class="s1">u0d81-</span><span class="s2">\\</span><span class="s1">u0d83</span><span class="s2">\\</span><span class="s1">u0dca</span><span class="s2">\\</span><span class="s1">u0dcf-</span><span class="s2">\\</span><span class="s1">u0dd4</span><span class="s2">\\</span><span class="s1">u0dd6</span><span class="s2">\\</span><span class="s1">u0dd8-</span><span class="s2">\\</span><span class="s1">u0ddf</span><span class="s2">\\</span><span class="s1">u0de6-</span><span class="s2">\\</span><span class="s1">u0def</span><span class="s2">\\</span><span class="s1">u0df2</span><span class="s2">\\</span><span class="s1">u0df3</span><span class="s2">\\</span><span class="s1">u0e31</span><span class="s2">\\</span><span class="s1">u0e34-</span><span class="s2">\\</span><span class="s1">u0e3a</span><span class="s2">\\</span><span class="s1">u0e47-</span><span class="s2">\\</span><span class="s1">u0e4e</span><span class="s2">\\</span><span class="s1">u0e50-</span><span class="s2">\\</span><span class="s1">u0e59</span><span class="s2">\\</span><span class="s1">u0eb1</span><span class="s2">\\</span><span class="s1">u0eb4-</span><span class="s2">\\</span><span class="s1">u0ebc</span><span class="s2">\\</span><span class="s1">u0ec8-</span><span class="s2">\\</span><span class="s1">u0ece</span><span class="s2">\\</span><span class="s1">u0ed0-</span><span class="s2">\\</span><span class="s1">u0ed9</span><span class="s2">\\</span><span class="s1">u0f18</span><span class="s2">\\</span><span class="s1">u0f19</span><span class="s2">\\</span><span class="s1">u0f20-</span><span class="s2">\\</span><span class="s1">u0f29</span><span class="s2">\\</span><span class="s1">u0f35</span><span class="s2">\\</span><span class="s1">u0f37</span><span class="s2">\\</span><span class="s1">u0f39</span><span class="s2">\\</span><span class="s1">u0f3e</span><span class="s2">\\</span><span class="s1">u0f3f</span><span class="s2">\\</span><span class="s1">u0f71-</span><span class="s2">\\</span><span class="s1">u0f84</span><span class="s2">\\</span><span class="s1">u0f86</span><span class="s2">\\</span><span class="s1">u0f87</span><span class="s2">\\</span><span class="s1">u0f8d-</span><span class="s2">\\</span><span class="s1">u0f97</span><span class="s2">\\</span><span class="s1">u0f99-</span><span class="s2">\\</span><span class="s1">u0fbc</span><span class="s2">\\</span><span class="s1">u0fc6</span><span class="s2">\\</span><span class="s1">u102b-</span><span class="s2">\\</span><span class="s1">u103e</span><span class="s2">\\</span><span class="s1">u1040-</span><span class="s2">\\</span><span class="s1">u1049</span><span class="s2">\\</span><span class="s1">u1056-</span><span class="s2">\\</span><span class="s1">u1059</span><span class="s2">\\</span><span class="s1">u105e-</span><span class="s2">\\</span><span class="s1">u1060</span><span class="s2">\\</span><span class="s1">u1062-</span><span class="s2">\\</span><span class="s1">u1064</span><span class="s2">\\</span><span class="s1">u1067-</span><span class="s2">\\</span><span class="s1">u106d</span><span class="s2">\\</span><span class="s1">u1071-</span><span class="s2">\\</span><span class="s1">u1074</span><span class="s2">\\</span><span class="s1">u1082-</span><span class="s2">\\</span><span class="s1">u108d</span><span class="s2">\\</span><span class="s1">u108f-</span><span class="s2">\\</span><span class="s1">u109d</span><span class="s2">\\</span><span class="s1">u135d-</span><span class="s2">\\</span><span class="s1">u135f</span><span class="s2">\\</span><span class="s1">u1369-</span><span class="s2">\\</span><span class="s1">u1371</span><span class="s2">\\</span><span class="s1">u1712-</span><span class="s2">\\</span><span class="s1">u1715</span><span class="s2">\\</span><span class="s1">u1732-</span><span class="s2">\\</span><span class="s1">u1734</span><span class="s2">\\</span><span class="s1">u1752</span><span class="s2">\\</span><span class="s1">u1753</span><span class="s2">\\</span><span class="s1">u1772</span><span class="s2">\\</span><span class="s1">u1773</span><span class="s2">\\</span><span class="s1">u17b4-</span><span class="s2">\\</span><span class="s1">u17d3</span><span class="s2">\\</span><span class="s1">u17dd</span><span class="s2">\\</span><span class="s1">u17e0-</span><span class="s2">\\</span><span class="s1">u17e9</span><span class="s2">\\</span><span class="s1">u180b-</span><span class="s2">\\</span><span class="s1">u180d</span><span class="s2">\\</span><span class="s1">u180f-</span><span class="s2">\\</span><span class="s1">u1819</span><span class="s2">\\</span><span class="s1">u18a9</span><span class="s2">\\</span><span class="s1">u1920-</span><span class="s2">\\</span><span class="s1">u192b</span><span class="s2">\\</span><span class="s1">u1930-</span><span class="s2">\\</span><span class="s1">u193b</span><span class="s2">\\</span><span class="s1">u1946-</span><span class="s2">\\</span><span class="s1">u194f</span><span class="s2">\\</span><span class="s1">u19d0-</span><span class="s2">\\</span><span class="s1">u19da</span><span class="s2">\\</span><span class="s1">u1a17-</span><span class="s2">\\</span><span class="s1">u1a1b</span><span class="s2">\\</span><span class="s1">u1a55-</span><span class="s2">\\</span><span class="s1">u1a5e</span><span class="s2">\\</span><span class="s1">u1a60-</span><span class="s2">\\</span><span class="s1">u1a7c</span><span class="s2">\\</span><span class="s1">u1a7f-</span><span class="s2">\\</span><span class="s1">u1a89</span><span class="s2">\\</span><span class="s1">u1a90-</span><span class="s2">\\</span><span class="s1">u1a99</span><span class="s2">\\</span><span class="s1">u1ab0-</span><span class="s2">\\</span><span class="s1">u1abd</span><span class="s2">\\</span><span class="s1">u1abf-</span><span class="s2">\\</span><span class="s1">u1ace</span><span class="s2">\\</span><span class="s1">u1b00-</span><span class="s2">\\</span><span class="s1">u1b04</span><span class="s2">\\</span><span class="s1">u1b34-</span><span class="s2">\\</span><span class="s1">u1b44</span><span class="s2">\\</span><span class="s1">u1b50-</span><span class="s2">\\</span><span class="s1">u1b59</span><span class="s2">\\</span><span class="s1">u1b6b-</span><span class="s2">\\</span><span class="s1">u1b73</span><span class="s2">\\</span><span class="s1">u1b80-</span><span class="s2">\\</span><span class="s1">u1b82</span><span class="s2">\\</span><span class="s1">u1ba1-</span><span class="s2">\\</span><span class="s1">u1bad</span><span class="s2">\\</span><span class="s1">u1bb0-</span><span class="s2">\\</span><span class="s1">u1bb9</span><span class="s2">\\</span><span class="s1">u1be6-</span><span class="s2">\\</span><span class="s1">u1bf3</span><span class="s2">\\</span><span class="s1">u1c24-</span><span class="s2">\\</span><span class="s1">u1c37</span><span class="s2">\\</span><span class="s1">u1c40-</span><span class="s2">\\</span><span class="s1">u1c49</span><span class="s2">\\</span><span class="s1">u1c50-</span><span class="s2">\\</span><span class="s1">u1c59</span><span class="s2">\\</span><span class="s1">u1cd0-</span><span class="s2">\\</span><span class="s1">u1cd2</span><span class="s2">\\</span><span class="s1">u1cd4-</span><span class="s2">\\</span><span class="s1">u1ce8</span><span class="s2">\\</span><span class="s1">u1ced</span><span class="s2">\\</span><span class="s1">u1cf4</span><span class="s2">\\</span><span class="s1">u1cf7-</span><span class="s2">\\</span><span class="s1">u1cf9</span><span class="s2">\\</span><span class="s1">u1dc0-</span><span class="s2">\\</span><span class="s1">u1dff</span><span class="s2">\\</span><span class="s1">u203f</span><span class="s2">\\</span><span class="s1">u2040</span><span class="s2">\\</span><span class="s1">u2054</span><span class="s2">\\</span><span class="s1">u20d0-</span><span class="s2">\\</span><span class="s1">u20dc</span><span class="s2">\\</span><span class="s1">u20e1</span><span class="s2">\\</span><span class="s1">u20e5-</span><span class="s2">\\</span><span class="s1">u20f0</span><span class="s2">\\</span><span class="s1">u2cef-</span><span class="s2">\\</span><span class="s1">u2cf1</span><span class="s2">\\</span><span class="s1">u2d7f</span><span class="s2">\\</span><span class="s1">u2de0-</span><span class="s2">\\</span><span class="s1">u2dff</span><span class="s2">\\</span><span class="s1">u302a-</span><span class="s2">\\</span><span class="s1">u302f</span><span class="s2">\\</span><span class="s1">u3099</span><span class="s2">\\</span><span class="s1">u309a</span><span class="s2">\\</span><span class="s1">ua620-</span><span class="s2">\\</span><span class="s1">ua629</span><span class="s2">\\</span><span class="s1">ua66f</span><span class="s2">\\</span><span class="s1">ua674-</span><span class="s2">\\</span><span class="s1">ua67d</span><span class="s2">\\</span><span class="s1">ua69e</span><span class="s2">\\</span><span class="s1">ua69f</span><span class="s2">\\</span><span class="s1">ua6f0</span><span class="s2">\\</span><span class="s1">ua6f1</span><span class="s2">\\</span><span class="s1">ua802</span><span class="s2">\\</span><span class="s1">ua806</span><span class="s2">\\</span><span class="s1">ua80b</span><span class="s2">\\</span><span class="s1">ua823-</span><span class="s2">\\</span><span class="s1">ua827</span><span class="s2">\\</span><span class="s1">ua82c</span><span class="s2">\\</span><span class="s1">ua880</span><span class="s2">\\</span><span class="s1">ua881</span><span class="s2">\\</span><span class="s1">ua8b4-</span><span class="s2">\\</span><span class="s1">ua8c5</span><span class="s2">\\</span><span class="s1">ua8d0-</span><span class="s2">\\</span><span class="s1">ua8d9</span><span class="s2">\\</span><span class="s1">ua8e0-</span><span class="s2">\\</span><span class="s1">ua8f1</span><span class="s2">\\</span><span class="s1">ua8ff-</span><span class="s2">\\</span><span class="s1">ua909</span><span class="s2">\\</span><span class="s1">ua926-</span><span class="s2">\\</span><span class="s1">ua92d</span><span class="s2">\\</span><span class="s1">ua947-</span><span class="s2">\\</span><span class="s1">ua953</span><span class="s2">\\</span><span class="s1">ua980-</span><span class="s2">\\</span><span class="s1">ua983</span><span class="s2">\\</span><span class="s1">ua9b3-</span><span class="s2">\\</span><span class="s1">ua9c0</span><span class="s2">\\</span><span class="s1">ua9d0-</span><span class="s2">\\</span><span class="s1">ua9d9</span><span class="s2">\\</span><span class="s1">ua9e5</span><span class="s2">\\</span><span class="s1">ua9f0-</span><span class="s2">\\</span><span class="s1">ua9f9</span><span class="s2">\\</span><span class="s1">uaa29-</span><span class="s2">\\</span><span class="s1">uaa36</span><span class="s2">\\</span><span class="s1">uaa43</span><span class="s2">\\</span><span class="s1">uaa4c</span><span class="s2">\\</span><span class="s1">uaa4d</span><span class="s2">\\</span><span class="s1">uaa50-</span><span class="s2">\\</span><span class="s1">uaa59</span><span class="s2">\\</span><span class="s1">uaa7b-</span><span class="s2">\\</span><span class="s1">uaa7d</span><span class="s2">\\</span><span class="s1">uaab0</span><span class="s2">\\</span><span class="s1">uaab2-</span><span class="s2">\\</span><span class="s1">uaab4</span><span class="s2">\\</span><span class="s1">uaab7</span><span class="s2">\\</span><span class="s1">uaab8</span><span class="s2">\\</span><span class="s1">uaabe</span><span class="s2">\\</span><span class="s1">uaabf</span><span class="s2">\\</span><span class="s1">uaac1</span><span class="s2">\\</span><span class="s1">uaaeb-</span><span class="s2">\\</span><span class="s1">uaaef</span><span class="s2">\\</span><span class="s1">uaaf5</span><span class="s2">\\</span><span class="s1">uaaf6</span><span class="s2">\\</span><span class="s1">uabe3-</span><span class="s2">\\</span><span class="s1">uabea</span><span class="s2">\\</span><span class="s1">uabec</span><span class="s2">\\</span><span class="s1">uabed</span><span class="s2">\\</span><span class="s1">uabf0-</span><span class="s2">\\</span><span class="s1">uabf9</span><span class="s2">\\</span><span class="s1">ufb1e</span><span class="s2">\\</span><span class="s1">ufe00-</span><span class="s2">\\</span><span class="s1">ufe0f</span><span class="s2">\\</span><span class="s1">ufe20-</span><span class="s2">\\</span><span class="s1">ufe2f</span><span class="s2">\\</span><span class="s1">ufe33</span><span class="s2">\\</span><span class="s1">ufe34</span><span class="s2">\\</span><span class="s1">ufe4d-</span><span class="s2">\\</span><span class="s1">ufe4f</span><span class="s2">\\</span><span class="s1">uff10-</span><span class="s2">\\</span><span class="s1">uff19</span><span class="s2">\\</span><span class="s1">uff3f</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">const nonASCIIidentifierStart = new RegExp(</span><span class="s2">\n  \&quot;</span><span class="s1">[</span><span class="s2">\&quot; </span><span class="s1">+ nonASCIIidentifierStartChars + </span><span class="s2">\&quot;</span><span class="s1">]</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n</span><span class="s1">);</span><span class="s2">\n</span><span class="s1">const nonASCIIidentifier = new RegExp(</span><span class="s2">\n  \&quot;</span><span class="s1">[</span><span class="s2">\&quot; </span><span class="s1">+ nonASCIIidentifierStartChars + nonASCIIidentifierChars + </span><span class="s2">\&quot;</span><span class="s1">]</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n</span><span class="s1">);</span><span class="s2">\n\n</span><span class="s1">nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;</span><span class="s2">\n\n</span><span class="s1">// These are a run-length and offset-encoded representation of the</span><span class="s2">\n</span><span class="s1">// &gt;0xffff code points that are a valid part of identifiers. The</span><span class="s2">\n</span><span class="s1">// offset starts at 0x10000, and each pair of numbers represents an</span><span class="s2">\n</span><span class="s1">// offset to the next range, and then a size of the range. They were</span><span class="s2">\n</span><span class="s1">// generated by `scripts/generate-identifier-regex.js`.</span><span class="s2">\n</span><span class="s1">/* prettier-ignore */</span><span class="s2">\n</span><span class="s1">const astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,13,10,2,14,2,6,2,1,2,10,2,14,2,6,2,1,68,310,10,21,11,7,25,5,2,41,2,8,70,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,349,41,7,1,79,28,11,0,9,21,43,17,47,20,28,22,13,52,58,1,3,0,14,44,33,24,27,35,30,0,3,0,9,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,20,1,64,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,21,2,31,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,38,6,186,43,117,63,32,7,3,0,3,7,2,1,2,23,16,0,2,0,95,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,19,72,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,16,0,2,12,2,33,125,0,80,921,103,110,18,195,2637,96,16,1071,18,5,4026,582,8634,568,8,30,18,78,18,29,19,47,17,3,32,20,6,18,689,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,1237,43,8,8936,3,2,6,2,1,2,290,16,0,30,2,3,0,15,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,1845,30,7,5,262,61,147,44,11,6,17,0,322,29,19,43,485,27,757,6,2,3,2,1,2,14,2,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42719,33,4153,7,221,3,5761,15,7472,3104,541,1507,4938,6,4191];</span><span class="s2">\n</span><span class="s1">/* prettier-ignore */</span><span class="s2">\n</span><span class="s1">const astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,370,1,81,2,71,10,50,3,123,2,54,14,32,10,3,1,11,3,46,10,8,0,46,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,2,11,83,11,7,0,3,0,158,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,71,5,2,1,3,3,2,0,2,1,13,9,120,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,10,1,2,0,49,6,4,4,14,9,5351,0,7,14,13835,9,87,9,39,4,60,6,26,9,1014,0,2,54,8,3,82,0,12,1,19628,1,4706,45,3,22,543,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,101,0,161,6,10,9,357,0,62,13,499,13,983,6,110,6,6,9,4759,9,787719,239];</span><span class="s2">\n\n</span><span class="s1">// This has a complexity linear to the value of the code. The</span><span class="s2">\n</span><span class="s1">// assumption is that looking up astral identifier characters is</span><span class="s2">\n</span><span class="s1">// rare.</span><span class="s2">\n</span><span class="s1">function isInAstralSet(code: number, set: readonly number[]): boolean {</span><span class="s2">\n  </span><span class="s1">let pos = 0x10000;</span><span class="s2">\n  </span><span class="s1">for (let i = 0, length = set.length; i &lt; length; i += 2) {</span><span class="s2">\n    </span><span class="s1">pos += set[i];</span><span class="s2">\n    </span><span class="s1">if (pos &gt; code) return false;</span><span class="s2">\n\n    </span><span class="s1">pos += set[i + 1];</span><span class="s2">\n    </span><span class="s1">if (pos &gt;= code) return true;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return false;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// Test whether a given character code starts an identifier.</span><span class="s2">\n\n</span><span class="s1">export function isIdentifierStart(code: number): boolean {</span><span class="s2">\n  </span><span class="s1">if (code &lt; charCodes.uppercaseA) return code === charCodes.dollarSign;</span><span class="s2">\n  </span><span class="s1">if (code &lt;= charCodes.uppercaseZ) return true;</span><span class="s2">\n  </span><span class="s1">if (code &lt; charCodes.lowercaseA) return code === charCodes.underscore;</span><span class="s2">\n  </span><span class="s1">if (code &lt;= charCodes.lowercaseZ) return true;</span><span class="s2">\n  </span><span class="s1">if (code &lt;= 0xffff) {</span><span class="s2">\n    </span><span class="s1">return (</span><span class="s2">\n      </span><span class="s1">code &gt;= 0xaa &amp;&amp; nonASCIIidentifierStart.test(String.fromCharCode(code))</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return isInAstralSet(code, astralIdentifierStartCodes);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// Test whether a given character is part of an identifier.</span><span class="s2">\n\n</span><span class="s1">export function isIdentifierChar(code: number): boolean {</span><span class="s2">\n  </span><span class="s1">if (code &lt; charCodes.digit0) return code === charCodes.dollarSign;</span><span class="s2">\n  </span><span class="s1">if (code &lt; charCodes.colon) return true;</span><span class="s2">\n  </span><span class="s1">if (code &lt; charCodes.uppercaseA) return false;</span><span class="s2">\n  </span><span class="s1">if (code &lt;= charCodes.uppercaseZ) return true;</span><span class="s2">\n  </span><span class="s1">if (code &lt; charCodes.lowercaseA) return code === charCodes.underscore;</span><span class="s2">\n  </span><span class="s1">if (code &lt;= charCodes.lowercaseZ) return true;</span><span class="s2">\n  </span><span class="s1">if (code &lt;= 0xffff) {</span><span class="s2">\n    </span><span class="s1">return code &gt;= 0xaa &amp;&amp; nonASCIIidentifier.test(String.fromCharCode(code));</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return (</span><span class="s2">\n    </span><span class="s1">isInAstralSet(code, astralIdentifierStartCodes) ||</span><span class="s2">\n    </span><span class="s1">isInAstralSet(code, astralIdentifierCodes)</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// Test whether a given string is a valid identifier name</span><span class="s2">\n\n</span><span class="s1">export function isIdentifierName(name: string): boolean {</span><span class="s2">\n  </span><span class="s1">let isFirst = true;</span><span class="s2">\n  </span><span class="s1">for (let i = 0; i &lt; name.length; i++) {</span><span class="s2">\n    </span><span class="s1">// The implementation is based on</span><span class="s2">\n    </span><span class="s1">// https://source.chromium.org/chromium/chromium/src/+/master:v8/src/builtins/builtins-string-gen.cc;l=1455;drc=221e331b49dfefadbc6fa40b0c68e6f97606d0b3;bpv=0;bpt=1</span><span class="s2">\n    </span><span class="s1">// We reimplement `codePointAt` because `codePointAt` is a V8 builtin which is not inlined by TurboFan (as of M91)</span><span class="s2">\n    </span><span class="s1">// since `name` is mostly ASCII, an inlined `charCodeAt` wins here</span><span class="s2">\n    </span><span class="s1">let cp = name.charCodeAt(i);</span><span class="s2">\n    </span><span class="s1">if ((cp &amp; 0xfc00) === 0xd800 &amp;&amp; i + 1 &lt; name.length) {</span><span class="s2">\n      </span><span class="s1">const trail = name.charCodeAt(++i);</span><span class="s2">\n      </span><span class="s1">if ((trail &amp; 0xfc00) === 0xdc00) {</span><span class="s2">\n        </span><span class="s1">cp = 0x10000 + ((cp &amp; 0x3ff) &lt;&lt; 10) + (trail &amp; 0x3ff);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (isFirst) {</span><span class="s2">\n      </span><span class="s1">isFirst = false;</span><span class="s2">\n      </span><span class="s1">if (!isIdentifierStart(cp)) {</span><span class="s2">\n        </span><span class="s1">return false;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else if (!isIdentifierChar(cp)) {</span><span class="s2">\n      </span><span class="s1">return false;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return !isFirst;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">&quot;</span><span class="s2">,</span><span class="s1">&quot;const reservedWords = {</span><span class="s2">\n  </span><span class="s1">keyword: [</span><span class="s2">\n    \&quot;</span><span class="s1">break</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    \&quot;</span><span class="s1">case</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    \&quot;</span><span class="s1">catch</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    \&quot;</span><span class="s1">continue</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    \&quot;</span><span class="s1">debugger</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    \&quot;</span><span class="s1">default</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    \&quot;</span><span class="s1">do</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    \&quot;</span><span class="s1">else</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    \&quot;</span><span class="s1">finally</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    \&quot;</span><span class="s1">for</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    \&quot;</span><span class="s1">function</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    \&quot;</span><span class="s1">if</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    \&quot;</span><span class="s1">return</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    \&quot;</span><span class="s1">switch</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    \&quot;</span><span class="s1">throw</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    \&quot;</span><span class="s1">try</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    \&quot;</span><span class="s1">var</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    \&quot;</span><span class="s1">const</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    \&quot;</span><span class="s1">while</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    \&quot;</span><span class="s1">with</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    \&quot;</span><span class="s1">new</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    \&quot;</span><span class="s1">this</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    \&quot;</span><span class="s1">super</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    \&quot;</span><span class="s1">class</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    \&quot;</span><span class="s1">extends</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    \&quot;</span><span class="s1">export</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    \&quot;</span><span class="s1">import</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    \&quot;</span><span class="s1">null</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    \&quot;</span><span class="s1">true</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    \&quot;</span><span class="s1">false</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    \&quot;</span><span class="s1">in</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    \&quot;</span><span class="s1">instanceof</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    \&quot;</span><span class="s1">typeof</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    \&quot;</span><span class="s1">void</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    \&quot;</span><span class="s1">delete</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">],</span><span class="s2">\n  </span><span class="s1">strict: [</span><span class="s2">\n    \&quot;</span><span class="s1">implements</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    \&quot;</span><span class="s1">interface</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    \&quot;</span><span class="s1">let</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    \&quot;</span><span class="s1">package</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    \&quot;</span><span class="s1">private</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    \&quot;</span><span class="s1">protected</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    \&quot;</span><span class="s1">public</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    \&quot;</span><span class="s1">static</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    \&quot;</span><span class="s1">yield</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">],</span><span class="s2">\n  </span><span class="s1">strictBind: [</span><span class="s2">\&quot;</span><span class="s1">eval</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">arguments</span><span class="s2">\&quot;</span><span class="s1">],</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">const keywords = new Set(reservedWords.keyword);</span><span class="s2">\n</span><span class="s1">const reservedWordsStrictSet = new Set(reservedWords.strict);</span><span class="s2">\n</span><span class="s1">const reservedWordsStrictBindSet = new Set(reservedWords.strictBind);</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Checks if word is a reserved word in non-strict mode</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">export function isReservedWord(word: string, inModule: boolean): boolean {</span><span class="s2">\n  </span><span class="s1">return (inModule &amp;&amp; word === </span><span class="s2">\&quot;</span><span class="s1">await</span><span class="s2">\&quot;</span><span class="s1">) || word === </span><span class="s2">\&quot;</span><span class="s1">enum</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Checks if word is a reserved word in non-binding strict mode</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* Includes non-strict reserved words</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">export function isStrictReservedWord(word: string, inModule: boolean): boolean {</span><span class="s2">\n  </span><span class="s1">return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Checks if word is a reserved word in binding strict mode, but it is allowed as</span><span class="s2">\n </span><span class="s1">* a normal identifier.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">export function isStrictBindOnlyReservedWord(word: string): boolean {</span><span class="s2">\n  </span><span class="s1">return reservedWordsStrictBindSet.has(word);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Checks if word is a reserved word in binding strict mode</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* Includes non-strict reserved words and non-binding strict reserved words</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">export function isStrictBindReservedWord(</span><span class="s2">\n  </span><span class="s1">word: string,</span><span class="s2">\n  </span><span class="s1">inModule: boolean,</span><span class="s2">\n</span><span class="s1">): boolean {</span><span class="s2">\n  </span><span class="s1">return (</span><span class="s2">\n    </span><span class="s1">isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word)</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">export function isKeyword(word: string): boolean {</span><span class="s2">\n  </span><span class="s1">return keywords.has(word);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">&quot;</span><span class="s2">,</span><span class="s1">&quot;/* eslint max-len: 0 */</span><span class="s2">\n\n</span><span class="s1">import * as charCodes from </span><span class="s2">\&quot;</span><span class="s1">charcodes</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import { isIdentifierStart } from </span><span class="s2">\&quot;</span><span class="s1">@babel/helper-validator-identifier</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">export {</span><span class="s2">\n  </span><span class="s1">isIdentifierStart,</span><span class="s2">\n  </span><span class="s1">isIdentifierChar,</span><span class="s2">\n  </span><span class="s1">isReservedWord,</span><span class="s2">\n  </span><span class="s1">isStrictBindOnlyReservedWord,</span><span class="s2">\n  </span><span class="s1">isStrictBindReservedWord,</span><span class="s2">\n  </span><span class="s1">isStrictReservedWord,</span><span class="s2">\n  </span><span class="s1">isKeyword,</span><span class="s2">\n</span><span class="s1">} from </span><span class="s2">\&quot;</span><span class="s1">@babel/helper-validator-identifier</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">export const keywordRelationalOperator = /^in(stanceof)?$/;</span><span class="s2">\n\n</span><span class="s1">// Test whether a current state character code and next character code is @</span><span class="s2">\n\n</span><span class="s1">export function isIteratorStart(</span><span class="s2">\n  </span><span class="s1">current: number,</span><span class="s2">\n  </span><span class="s1">next: number,</span><span class="s2">\n  </span><span class="s1">next2: number,</span><span class="s2">\n</span><span class="s1">): boolean {</span><span class="s2">\n  </span><span class="s1">return (</span><span class="s2">\n    </span><span class="s1">current === charCodes.atSign &amp;&amp;</span><span class="s2">\n    </span><span class="s1">next === charCodes.atSign &amp;&amp;</span><span class="s2">\n    </span><span class="s1">isIdentifierStart(next2)</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// This is the comprehensive set of JavaScript reserved words</span><span class="s2">\n</span><span class="s1">// If a word is in this set, it could be a reserved word,</span><span class="s2">\n</span><span class="s1">// depending on sourceType/strictMode/binding info. In other words</span><span class="s2">\n</span><span class="s1">// if a word is not in this set, it is not a reserved word under</span><span class="s2">\n</span><span class="s1">// any circumstance.</span><span class="s2">\n</span><span class="s1">const reservedWordLikeSet = new Set([</span><span class="s2">\n  \&quot;</span><span class="s1">break</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">case</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">catch</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">continue</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">debugger</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">default</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">do</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">else</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">finally</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">for</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">function</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">if</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">return</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">switch</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">throw</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">try</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">var</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">const</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">while</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">with</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">new</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">this</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">super</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">class</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">extends</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">export</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">import</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">null</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">true</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">false</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">in</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">instanceof</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">typeof</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">void</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">delete</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">// strict</span><span class="s2">\n  \&quot;</span><span class="s1">implements</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">interface</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">let</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">package</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">private</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">protected</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">public</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">static</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">yield</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">// strictBind</span><span class="s2">\n  \&quot;</span><span class="s1">eval</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">arguments</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">// reservedWorkLike</span><span class="s2">\n  \&quot;</span><span class="s1">enum</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">await</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n</span><span class="s1">]);</span><span class="s2">\n\n</span><span class="s1">export function canBeReservedWord(word: string): boolean {</span><span class="s2">\n  </span><span class="s1">return reservedWordLikeSet.has(word);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">&quot;</span><span class="s2">,</span><span class="s1">&quot;// Each scope gets a bitset that may contain these flags</span><span class="s2">\n</span><span class="s1">// prettier-ignore</span><span class="s2">\n</span><span class="s1">export const SCOPE_OTHER        = 0b000000000,</span><span class="s2">\n             </span><span class="s1">SCOPE_PROGRAM      = 0b000000001,</span><span class="s2">\n             </span><span class="s1">SCOPE_FUNCTION     = 0b000000010,</span><span class="s2">\n             </span><span class="s1">SCOPE_ARROW        = 0b000000100,</span><span class="s2">\n             </span><span class="s1">SCOPE_SIMPLE_CATCH = 0b000001000,</span><span class="s2">\n             </span><span class="s1">SCOPE_SUPER        = 0b000010000,</span><span class="s2">\n             </span><span class="s1">SCOPE_DIRECT_SUPER = 0b000100000,</span><span class="s2">\n             </span><span class="s1">SCOPE_CLASS        = 0b001000000,</span><span class="s2">\n             </span><span class="s1">SCOPE_STATIC_BLOCK = 0b010000000,</span><span class="s2">\n             </span><span class="s1">SCOPE_TS_MODULE    = 0b100000000,</span><span class="s2">\n             </span><span class="s1">SCOPE_VAR = SCOPE_PROGRAM | SCOPE_FUNCTION | SCOPE_STATIC_BLOCK | SCOPE_TS_MODULE;</span><span class="s2">\n\n</span><span class="s1">export type ScopeFlags =</span><span class="s2">\n  </span><span class="s1">| typeof SCOPE_OTHER</span><span class="s2">\n  </span><span class="s1">| typeof SCOPE_PROGRAM</span><span class="s2">\n  </span><span class="s1">| typeof SCOPE_FUNCTION</span><span class="s2">\n  </span><span class="s1">| typeof SCOPE_VAR</span><span class="s2">\n  </span><span class="s1">| typeof SCOPE_ARROW</span><span class="s2">\n  </span><span class="s1">| typeof SCOPE_SIMPLE_CATCH</span><span class="s2">\n  </span><span class="s1">| typeof SCOPE_SUPER</span><span class="s2">\n  </span><span class="s1">| typeof SCOPE_DIRECT_SUPER</span><span class="s2">\n  </span><span class="s1">| typeof SCOPE_CLASS</span><span class="s2">\n  </span><span class="s1">| typeof SCOPE_STATIC_BLOCK;</span><span class="s2">\n\n</span><span class="s1">// These flags are meant to be _only_ used inside the Scope class (or subclasses).</span><span class="s2">\n</span><span class="s1">// prettier-ignore</span><span class="s2">\n</span><span class="s1">export const BIND_KIND_VALUE            = 0b0000000_0000_01,</span><span class="s2">\n             </span><span class="s1">BIND_KIND_TYPE             = 0b0000000_0000_10,</span><span class="s2">\n             </span><span class="s1">// Used in checkLVal and declareName to determine the type of a binding</span><span class="s2">\n             </span><span class="s1">BIND_SCOPE_VAR             = 0b0000000_0001_00, // Var-style binding</span><span class="s2">\n             </span><span class="s1">BIND_SCOPE_LEXICAL         = 0b0000000_0010_00, // Let- or const-style binding</span><span class="s2">\n             </span><span class="s1">BIND_SCOPE_FUNCTION        = 0b0000000_0100_00, // Function declaration</span><span class="s2">\n             </span><span class="s1">BIND_SCOPE_OUTSIDE         = 0b0000000_1000_00, // Special case for function names as</span><span class="s2">\n                                                   </span><span class="s1">// bound inside the function</span><span class="s2">\n             </span><span class="s1">// Misc flags</span><span class="s2">\n             </span><span class="s1">BIND_FLAGS_NONE            = 0b00000001_0000_00,</span><span class="s2">\n             </span><span class="s1">BIND_FLAGS_CLASS           = 0b00000010_0000_00,</span><span class="s2">\n             </span><span class="s1">BIND_FLAGS_TS_ENUM         = 0b00000100_0000_00,</span><span class="s2">\n             </span><span class="s1">BIND_FLAGS_TS_CONST_ENUM   = 0b00001000_0000_00,</span><span class="s2">\n             </span><span class="s1">BIND_FLAGS_TS_EXPORT_ONLY  = 0b00010000_0000_00,</span><span class="s2">\n             </span><span class="s1">BIND_FLAGS_FLOW_DECLARE_FN = 0b00100000_0000_00,</span><span class="s2">\n             </span><span class="s1">BIND_FLAGS_TS_IMPORT       = 0b01000000_0000_00,</span><span class="s2">\n             </span><span class="s1">// Whether </span><span class="s2">\&quot;</span><span class="s1">let</span><span class="s2">\&quot; </span><span class="s1">should be allowed in bound names in sloppy mode</span><span class="s2">\n             </span><span class="s1">BIND_FLAGS_NO_LET_IN_LEXICAL = 0b10000000_0000_00;</span><span class="s2">\n\n</span><span class="s1">// These flags are meant to be _only_ used by Scope consumers</span><span class="s2">\n</span><span class="s1">// prettier-ignore</span><span class="s2">\n</span><span class="s1">/*                              =    is value?    |    is type?    |      scope          |    misc flags    */</span><span class="s2">\n</span><span class="s1">export const BIND_CLASS         = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL  | BIND_FLAGS_CLASS|BIND_FLAGS_NO_LET_IN_LEXICAL,</span><span class="s2">\n             </span><span class="s1">BIND_LEXICAL       = BIND_KIND_VALUE | 0              | BIND_SCOPE_LEXICAL  | BIND_FLAGS_NO_LET_IN_LEXICAL,</span><span class="s2">\n             </span><span class="s1">BIND_CATCH_PARAM   = BIND_KIND_VALUE | 0              | BIND_SCOPE_LEXICAL  | 0                 ,</span><span class="s2">\n             </span><span class="s1">BIND_VAR           = BIND_KIND_VALUE | 0              | BIND_SCOPE_VAR      | 0                 ,</span><span class="s2">\n             </span><span class="s1">BIND_FUNCTION      = BIND_KIND_VALUE | 0              | BIND_SCOPE_FUNCTION | 0                 ,</span><span class="s2">\n             </span><span class="s1">BIND_TS_INTERFACE  = 0               | BIND_KIND_TYPE | 0                   | BIND_FLAGS_CLASS  ,</span><span class="s2">\n             </span><span class="s1">BIND_TS_TYPE       = 0               | BIND_KIND_TYPE | 0                   | 0                 ,</span><span class="s2">\n             </span><span class="s1">BIND_TS_ENUM       = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL  | BIND_FLAGS_TS_ENUM|BIND_FLAGS_NO_LET_IN_LEXICAL,</span><span class="s2">\n             </span><span class="s1">BIND_TS_AMBIENT    = 0               | 0              | 0            | BIND_FLAGS_TS_EXPORT_ONLY,</span><span class="s2">\n             </span><span class="s1">// These bindings don't introduce anything in the scope. They are used for assignments and</span><span class="s2">\n             </span><span class="s1">// function expressions IDs.</span><span class="s2">\n             </span><span class="s1">BIND_NONE          = 0               | 0              | 0                   | BIND_FLAGS_NONE          ,</span><span class="s2">\n             </span><span class="s1">BIND_OUTSIDE       = BIND_KIND_VALUE | 0              | 0                   | BIND_FLAGS_NONE          ,</span><span class="s2">\n\n             </span><span class="s1">BIND_TS_CONST_ENUM = BIND_TS_ENUM    | BIND_FLAGS_TS_CONST_ENUM                                        ,</span><span class="s2">\n             </span><span class="s1">BIND_TS_NAMESPACE  = 0               | 0              | 0                   | BIND_FLAGS_TS_EXPORT_ONLY,</span><span class="s2">\n             </span><span class="s1">BIND_TS_TYPE_IMPORT= 0               | BIND_KIND_TYPE | 0                   | BIND_FLAGS_TS_IMPORT     ,</span><span class="s2">\n\n             </span><span class="s1">BIND_FLOW_DECLARE_FN = BIND_FLAGS_FLOW_DECLARE_FN;</span><span class="s2">\n\n</span><span class="s1">export type BindingTypes =</span><span class="s2">\n  </span><span class="s1">| typeof BIND_NONE</span><span class="s2">\n  </span><span class="s1">| typeof BIND_OUTSIDE</span><span class="s2">\n  </span><span class="s1">| typeof BIND_VAR</span><span class="s2">\n  </span><span class="s1">| typeof BIND_LEXICAL</span><span class="s2">\n  </span><span class="s1">| typeof BIND_CLASS</span><span class="s2">\n  </span><span class="s1">| typeof BIND_FUNCTION</span><span class="s2">\n  </span><span class="s1">| typeof BIND_TS_INTERFACE</span><span class="s2">\n  </span><span class="s1">| typeof BIND_TS_TYPE</span><span class="s2">\n  </span><span class="s1">| typeof BIND_TS_ENUM</span><span class="s2">\n  </span><span class="s1">| typeof BIND_TS_AMBIENT</span><span class="s2">\n  </span><span class="s1">| typeof BIND_TS_NAMESPACE;</span><span class="s2">\n\n</span><span class="s1">// prettier-ignore</span><span class="s2">\n</span><span class="s1">export const CLASS_ELEMENT_FLAG_STATIC = 0b1_00,</span><span class="s2">\n             </span><span class="s1">CLASS_ELEMENT_KIND_GETTER = 0b0_10,</span><span class="s2">\n             </span><span class="s1">CLASS_ELEMENT_KIND_SETTER = 0b0_01,</span><span class="s2">\n             </span><span class="s1">CLASS_ELEMENT_KIND_ACCESSOR = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_KIND_SETTER;</span><span class="s2">\n\n</span><span class="s1">// prettier-ignore</span><span class="s2">\n</span><span class="s1">export const CLASS_ELEMENT_STATIC_GETTER   = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_FLAG_STATIC,</span><span class="s2">\n             </span><span class="s1">CLASS_ELEMENT_STATIC_SETTER   = CLASS_ELEMENT_KIND_SETTER | CLASS_ELEMENT_FLAG_STATIC,</span><span class="s2">\n             </span><span class="s1">CLASS_ELEMENT_INSTANCE_GETTER = CLASS_ELEMENT_KIND_GETTER,</span><span class="s2">\n             </span><span class="s1">CLASS_ELEMENT_INSTANCE_SETTER = CLASS_ELEMENT_KIND_SETTER,</span><span class="s2">\n             </span><span class="s1">CLASS_ELEMENT_OTHER           = 0;</span><span class="s2">\n\n</span><span class="s1">export type ClassElementTypes =</span><span class="s2">\n  </span><span class="s1">| typeof CLASS_ELEMENT_STATIC_GETTER</span><span class="s2">\n  </span><span class="s1">| typeof CLASS_ELEMENT_STATIC_SETTER</span><span class="s2">\n  </span><span class="s1">| typeof CLASS_ELEMENT_INSTANCE_GETTER</span><span class="s2">\n  </span><span class="s1">| typeof CLASS_ELEMENT_INSTANCE_SETTER</span><span class="s2">\n  </span><span class="s1">| typeof CLASS_ELEMENT_OTHER;</span><span class="s2">\n</span><span class="s1">&quot;</span><span class="s2">,</span><span class="s1">&quot;import {</span><span class="s2">\n  </span><span class="s1">SCOPE_ARROW,</span><span class="s2">\n  </span><span class="s1">SCOPE_DIRECT_SUPER,</span><span class="s2">\n  </span><span class="s1">SCOPE_FUNCTION,</span><span class="s2">\n  </span><span class="s1">SCOPE_SIMPLE_CATCH,</span><span class="s2">\n  </span><span class="s1">SCOPE_SUPER,</span><span class="s2">\n  </span><span class="s1">SCOPE_PROGRAM,</span><span class="s2">\n  </span><span class="s1">SCOPE_VAR,</span><span class="s2">\n  </span><span class="s1">SCOPE_CLASS,</span><span class="s2">\n  </span><span class="s1">SCOPE_STATIC_BLOCK,</span><span class="s2">\n  </span><span class="s1">BIND_SCOPE_FUNCTION,</span><span class="s2">\n  </span><span class="s1">BIND_SCOPE_VAR,</span><span class="s2">\n  </span><span class="s1">BIND_SCOPE_LEXICAL,</span><span class="s2">\n  </span><span class="s1">BIND_KIND_VALUE,</span><span class="s2">\n  </span><span class="s1">type ScopeFlags,</span><span class="s2">\n  </span><span class="s1">type BindingTypes,</span><span class="s2">\n</span><span class="s1">} from </span><span class="s2">\&quot;</span><span class="s1">./scopeflags</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type { Position } from </span><span class="s2">\&quot;</span><span class="s1">./location</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type * as N from </span><span class="s2">\&quot;</span><span class="s1">../types</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import { Errors } from </span><span class="s2">\&quot;</span><span class="s1">../parse-error</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type Tokenizer from </span><span class="s2">\&quot;</span><span class="s1">../tokenizer</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">// Start an AST node, attaching a start offset.</span><span class="s2">\n</span><span class="s1">export class Scope {</span><span class="s2">\n  </span><span class="s1">declare flags: ScopeFlags;</span><span class="s2">\n  </span><span class="s1">// A set of var-declared names in the current lexical scope</span><span class="s2">\n  </span><span class="s1">var: Set&lt;string&gt; = new Set();</span><span class="s2">\n  </span><span class="s1">// A set of lexically-declared names in the current lexical scope</span><span class="s2">\n  </span><span class="s1">lexical: Set&lt;string&gt; = new Set();</span><span class="s2">\n  </span><span class="s1">// A set of lexically-declared FunctionDeclaration names in the current lexical scope</span><span class="s2">\n  </span><span class="s1">functions: Set&lt;string&gt; = new Set();</span><span class="s2">\n\n  </span><span class="s1">constructor(flags: ScopeFlags) {</span><span class="s2">\n    </span><span class="s1">this.flags = flags;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// The functions in this module keep track of declared variables in the</span><span class="s2">\n</span><span class="s1">// current scope in order to detect duplicate variable names.</span><span class="s2">\n</span><span class="s1">export default class ScopeHandler&lt;IScope extends Scope = Scope&gt; {</span><span class="s2">\n  </span><span class="s1">parser: Tokenizer;</span><span class="s2">\n  </span><span class="s1">scopeStack: Array&lt;IScope&gt; = [];</span><span class="s2">\n  </span><span class="s1">inModule: boolean;</span><span class="s2">\n  </span><span class="s1">undefinedExports: Map&lt;string, Position&gt; = new Map();</span><span class="s2">\n\n  </span><span class="s1">constructor(parser: Tokenizer, inModule: boolean) {</span><span class="s2">\n    </span><span class="s1">this.parser = parser;</span><span class="s2">\n    </span><span class="s1">this.inModule = inModule;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">get inTopLevel() {</span><span class="s2">\n    </span><span class="s1">return (this.currentScope().flags &amp; SCOPE_PROGRAM) &gt; 0;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">get inFunction() {</span><span class="s2">\n    </span><span class="s1">return (this.currentVarScopeFlags() &amp; SCOPE_FUNCTION) &gt; 0;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">get allowSuper() {</span><span class="s2">\n    </span><span class="s1">return (this.currentThisScopeFlags() &amp; SCOPE_SUPER) &gt; 0;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">get allowDirectSuper() {</span><span class="s2">\n    </span><span class="s1">return (this.currentThisScopeFlags() &amp; SCOPE_DIRECT_SUPER) &gt; 0;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">get inClass() {</span><span class="s2">\n    </span><span class="s1">return (this.currentThisScopeFlags() &amp; SCOPE_CLASS) &gt; 0;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">get inClassAndNotInNonArrowFunction() {</span><span class="s2">\n    </span><span class="s1">const flags = this.currentThisScopeFlags();</span><span class="s2">\n    </span><span class="s1">return (flags &amp; SCOPE_CLASS) &gt; 0 &amp;&amp; (flags &amp; SCOPE_FUNCTION) === 0;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">get inStaticBlock() {</span><span class="s2">\n    </span><span class="s1">for (let i = this.scopeStack.length - 1; ; i--) {</span><span class="s2">\n      </span><span class="s1">const { flags } = this.scopeStack[i];</span><span class="s2">\n      </span><span class="s1">if (flags &amp; SCOPE_STATIC_BLOCK) {</span><span class="s2">\n        </span><span class="s1">return true;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (flags &amp; (SCOPE_VAR | SCOPE_CLASS)) {</span><span class="s2">\n        </span><span class="s1">// function body, module body, class property initializers</span><span class="s2">\n        </span><span class="s1">return false;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">get inNonArrowFunction() {</span><span class="s2">\n    </span><span class="s1">return (this.currentThisScopeFlags() &amp; SCOPE_FUNCTION) &gt; 0;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">get treatFunctionsAsVar() {</span><span class="s2">\n    </span><span class="s1">return this.treatFunctionsAsVarInScope(this.currentScope());</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">createScope(flags: ScopeFlags): Scope {</span><span class="s2">\n    </span><span class="s1">return new Scope(flags);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">enter(flags: ScopeFlags) {</span><span class="s2">\n    </span><span class="s1">/*:: +createScope: (flags: ScopeFlags) =&gt; IScope; */</span><span class="s2">\n    </span><span class="s1">// @ts-expect-error This method will be overwritten by subclasses</span><span class="s2">\n    </span><span class="s1">this.scopeStack.push(this.createScope(flags));</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">exit(): ScopeFlags {</span><span class="s2">\n    </span><span class="s1">const scope = this.scopeStack.pop();</span><span class="s2">\n    </span><span class="s1">return scope.flags;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// The spec says:</span><span class="s2">\n  </span><span class="s1">// &gt; At the top level of a function, or script, function declarations are</span><span class="s2">\n  </span><span class="s1">// &gt; treated like var declarations rather than like lexical declarations.</span><span class="s2">\n  </span><span class="s1">treatFunctionsAsVarInScope(scope: IScope): boolean {</span><span class="s2">\n    </span><span class="s1">return !!(</span><span class="s2">\n      </span><span class="s1">scope.flags &amp; (SCOPE_FUNCTION | SCOPE_STATIC_BLOCK) ||</span><span class="s2">\n      </span><span class="s1">(!this.parser.inModule &amp;&amp; scope.flags &amp; SCOPE_PROGRAM)</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">declareName(name: string, bindingType: BindingTypes, loc: Position) {</span><span class="s2">\n    </span><span class="s1">let scope = this.currentScope();</span><span class="s2">\n    </span><span class="s1">if (bindingType &amp; BIND_SCOPE_LEXICAL || bindingType &amp; BIND_SCOPE_FUNCTION) {</span><span class="s2">\n      </span><span class="s1">this.checkRedeclarationInScope(scope, name, bindingType, loc);</span><span class="s2">\n\n      </span><span class="s1">if (bindingType &amp; BIND_SCOPE_FUNCTION) {</span><span class="s2">\n        </span><span class="s1">scope.functions.add(name);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">scope.lexical.add(name);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">if (bindingType &amp; BIND_SCOPE_LEXICAL) {</span><span class="s2">\n        </span><span class="s1">this.maybeExportDefined(scope, name);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else if (bindingType &amp; BIND_SCOPE_VAR) {</span><span class="s2">\n      </span><span class="s1">for (let i = this.scopeStack.length - 1; i &gt;= 0; --i) {</span><span class="s2">\n        </span><span class="s1">scope = this.scopeStack[i];</span><span class="s2">\n        </span><span class="s1">this.checkRedeclarationInScope(scope, name, bindingType, loc);</span><span class="s2">\n        </span><span class="s1">scope.var.add(name);</span><span class="s2">\n        </span><span class="s1">this.maybeExportDefined(scope, name);</span><span class="s2">\n\n        </span><span class="s1">if (scope.flags &amp; SCOPE_VAR) break;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (this.parser.inModule &amp;&amp; scope.flags &amp; SCOPE_PROGRAM) {</span><span class="s2">\n      </span><span class="s1">this.undefinedExports.delete(name);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">maybeExportDefined(scope: IScope, name: string) {</span><span class="s2">\n    </span><span class="s1">if (this.parser.inModule &amp;&amp; scope.flags &amp; SCOPE_PROGRAM) {</span><span class="s2">\n      </span><span class="s1">this.undefinedExports.delete(name);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">checkRedeclarationInScope(</span><span class="s2">\n    </span><span class="s1">scope: IScope,</span><span class="s2">\n    </span><span class="s1">name: string,</span><span class="s2">\n    </span><span class="s1">bindingType: BindingTypes,</span><span class="s2">\n    </span><span class="s1">loc: Position,</span><span class="s2">\n  </span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">if (this.isRedeclaredInScope(scope, name, bindingType)) {</span><span class="s2">\n      </span><span class="s1">this.parser.raise(Errors.VarRedeclaration, {</span><span class="s2">\n        </span><span class="s1">at: loc,</span><span class="s2">\n        </span><span class="s1">identifierName: name,</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">isRedeclaredInScope(</span><span class="s2">\n    </span><span class="s1">scope: IScope,</span><span class="s2">\n    </span><span class="s1">name: string,</span><span class="s2">\n    </span><span class="s1">bindingType: BindingTypes,</span><span class="s2">\n  </span><span class="s1">): boolean {</span><span class="s2">\n    </span><span class="s1">if (!(bindingType &amp; BIND_KIND_VALUE)) return false;</span><span class="s2">\n\n    </span><span class="s1">if (bindingType &amp; BIND_SCOPE_LEXICAL) {</span><span class="s2">\n      </span><span class="s1">return (</span><span class="s2">\n        </span><span class="s1">scope.lexical.has(name) ||</span><span class="s2">\n        </span><span class="s1">scope.functions.has(name) ||</span><span class="s2">\n        </span><span class="s1">scope.var.has(name)</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">if (bindingType &amp; BIND_SCOPE_FUNCTION) {</span><span class="s2">\n      </span><span class="s1">return (</span><span class="s2">\n        </span><span class="s1">scope.lexical.has(name) ||</span><span class="s2">\n        </span><span class="s1">(!this.treatFunctionsAsVarInScope(scope) &amp;&amp; scope.var.has(name))</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">return (</span><span class="s2">\n      </span><span class="s1">(scope.lexical.has(name) &amp;&amp;</span><span class="s2">\n        </span><span class="s1">// Annex B.3.4</span><span class="s2">\n        </span><span class="s1">// https://tc39.es/ecma262/#sec-variablestatements-in-catch-blocks</span><span class="s2">\n        </span><span class="s1">!(</span><span class="s2">\n          </span><span class="s1">scope.flags &amp; SCOPE_SIMPLE_CATCH &amp;&amp;</span><span class="s2">\n          </span><span class="s1">scope.lexical.values().next().value === name</span><span class="s2">\n        </span><span class="s1">)) ||</span><span class="s2">\n      </span><span class="s1">(!this.treatFunctionsAsVarInScope(scope) &amp;&amp; scope.functions.has(name))</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">checkLocalExport(id: N.Identifier) {</span><span class="s2">\n    </span><span class="s1">const { name } = id;</span><span class="s2">\n    </span><span class="s1">const topLevelScope = this.scopeStack[0];</span><span class="s2">\n    </span><span class="s1">if (</span><span class="s2">\n      </span><span class="s1">!topLevelScope.lexical.has(name) &amp;&amp;</span><span class="s2">\n      </span><span class="s1">!topLevelScope.var.has(name) &amp;&amp;</span><span class="s2">\n      </span><span class="s1">// In strict mode, scope.functions will always be empty.</span><span class="s2">\n      </span><span class="s1">// Modules are strict by default, but the `scriptMode` option</span><span class="s2">\n      </span><span class="s1">// can overwrite this behavior.</span><span class="s2">\n      </span><span class="s1">!topLevelScope.functions.has(name)</span><span class="s2">\n    </span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">this.undefinedExports.set(name, id.loc.start);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">currentScope(): IScope {</span><span class="s2">\n    </span><span class="s1">return this.scopeStack[this.scopeStack.length - 1];</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">currentVarScopeFlags(): ScopeFlags {</span><span class="s2">\n    </span><span class="s1">for (let i = this.scopeStack.length - 1; ; i--) {</span><span class="s2">\n      </span><span class="s1">const { flags } = this.scopeStack[i];</span><span class="s2">\n      </span><span class="s1">if (flags &amp; SCOPE_VAR) {</span><span class="s2">\n        </span><span class="s1">return flags;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Could be useful for `arguments`, `this`, `new.target`, `super()`, `super.property`, and `super[property]`.</span><span class="s2">\n  </span><span class="s1">currentThisScopeFlags(): ScopeFlags {</span><span class="s2">\n    </span><span class="s1">for (let i = this.scopeStack.length - 1; ; i--) {</span><span class="s2">\n      </span><span class="s1">const { flags } = this.scopeStack[i];</span><span class="s2">\n      </span><span class="s1">if (flags &amp; (SCOPE_VAR | SCOPE_CLASS) &amp;&amp; !(flags &amp; SCOPE_ARROW)) {</span><span class="s2">\n        </span><span class="s1">return flags;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">&quot;</span><span class="s2">,</span><span class="s1">&quot;import type { Position } from </span><span class="s2">\&quot;</span><span class="s1">../../util/location</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import ScopeHandler, { Scope } from </span><span class="s2">\&quot;</span><span class="s1">../../util/scope</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import {</span><span class="s2">\n  </span><span class="s1">BIND_FLAGS_FLOW_DECLARE_FN,</span><span class="s2">\n  </span><span class="s1">type ScopeFlags,</span><span class="s2">\n  </span><span class="s1">type BindingTypes,</span><span class="s2">\n</span><span class="s1">} from </span><span class="s2">\&quot;</span><span class="s1">../../util/scopeflags</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type * as N from </span><span class="s2">\&quot;</span><span class="s1">../../types</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">// Reference implementation: https://github.com/facebook/flow/blob/23aeb2a2ef6eb4241ce178fde5d8f17c5f747fb5/src/typing/env.ml#L536-L584</span><span class="s2">\n</span><span class="s1">class FlowScope extends Scope {</span><span class="s2">\n  </span><span class="s1">// declare function foo(): type;</span><span class="s2">\n  </span><span class="s1">declareFunctions: Set&lt;string&gt; = new Set();</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">export default class FlowScopeHandler extends ScopeHandler&lt;FlowScope&gt; {</span><span class="s2">\n  </span><span class="s1">createScope(flags: ScopeFlags): FlowScope {</span><span class="s2">\n    </span><span class="s1">return new FlowScope(flags);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">declareName(name: string, bindingType: BindingTypes, loc: Position) {</span><span class="s2">\n    </span><span class="s1">const scope = this.currentScope();</span><span class="s2">\n    </span><span class="s1">if (bindingType &amp; BIND_FLAGS_FLOW_DECLARE_FN) {</span><span class="s2">\n      </span><span class="s1">this.checkRedeclarationInScope(scope, name, bindingType, loc);</span><span class="s2">\n      </span><span class="s1">this.maybeExportDefined(scope, name);</span><span class="s2">\n      </span><span class="s1">scope.declareFunctions.add(name);</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">super.declareName(name, bindingType, loc);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">isRedeclaredInScope(</span><span class="s2">\n    </span><span class="s1">scope: FlowScope,</span><span class="s2">\n    </span><span class="s1">name: string,</span><span class="s2">\n    </span><span class="s1">bindingType: BindingTypes,</span><span class="s2">\n  </span><span class="s1">): boolean {</span><span class="s2">\n    </span><span class="s1">if (super.isRedeclaredInScope(scope, name, bindingType)) return true;</span><span class="s2">\n\n    </span><span class="s1">if (bindingType &amp; BIND_FLAGS_FLOW_DECLARE_FN) {</span><span class="s2">\n      </span><span class="s1">return (</span><span class="s2">\n        </span><span class="s1">!scope.declareFunctions.has(name) &amp;&amp;</span><span class="s2">\n        </span><span class="s1">(scope.lexical.has(name) || scope.functions.has(name))</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">return false;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">checkLocalExport(id: N.Identifier) {</span><span class="s2">\n    </span><span class="s1">if (!this.scopeStack[0].declareFunctions.has(id.name)) {</span><span class="s2">\n      </span><span class="s1">super.checkLocalExport(id);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">&quot;</span><span class="s2">,</span><span class="s1">&quot;import type { Options } from </span><span class="s2">\&quot;</span><span class="s1">../options</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type State from </span><span class="s2">\&quot;</span><span class="s1">../tokenizer/state</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type { PluginsMap } from </span><span class="s2">\&quot;</span><span class="s1">./index</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type ScopeHandler from </span><span class="s2">\&quot;</span><span class="s1">../util/scope</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type ExpressionScopeHandler from </span><span class="s2">\&quot;</span><span class="s1">../util/expression-scope</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type ClassScopeHandler from </span><span class="s2">\&quot;</span><span class="s1">../util/class-scope</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type ProductionParameterHandler from </span><span class="s2">\&quot;</span><span class="s1">../util/production-parameter</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type {</span><span class="s2">\n  </span><span class="s1">ParserPluginWithOptions,</span><span class="s2">\n  </span><span class="s1">PluginConfig,</span><span class="s2">\n  </span><span class="s1">PluginOptions,</span><span class="s2">\n</span><span class="s1">} from </span><span class="s2">\&quot;</span><span class="s1">../typings</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">export default class BaseParser {</span><span class="s2">\n  </span><span class="s1">// Properties set by constructor in index.js</span><span class="s2">\n  </span><span class="s1">declare options: Options;</span><span class="s2">\n  </span><span class="s1">declare inModule: boolean;</span><span class="s2">\n  </span><span class="s1">declare scope: ScopeHandler&lt;any&gt;;</span><span class="s2">\n  </span><span class="s1">declare classScope: ClassScopeHandler;</span><span class="s2">\n  </span><span class="s1">declare prodParam: ProductionParameterHandler;</span><span class="s2">\n  </span><span class="s1">declare expressionScope: ExpressionScopeHandler;</span><span class="s2">\n  </span><span class="s1">declare plugins: PluginsMap;</span><span class="s2">\n  </span><span class="s1">declare filename: string | undefined | null;</span><span class="s2">\n  </span><span class="s1">// Names of exports store. `default` is stored as a name for both</span><span class="s2">\n  </span><span class="s1">// `export default foo;` and `export { foo as default };`.</span><span class="s2">\n  </span><span class="s1">declare exportedIdentifiers: Set&lt;string&gt;;</span><span class="s2">\n  </span><span class="s1">sawUnambiguousESM: boolean = false;</span><span class="s2">\n  </span><span class="s1">ambiguousScriptDifferentAst: boolean = false;</span><span class="s2">\n\n  </span><span class="s1">// Initialized by Tokenizer</span><span class="s2">\n  </span><span class="s1">declare state: State;</span><span class="s2">\n  </span><span class="s1">// input and length are not in state as they are constant and we do</span><span class="s2">\n  </span><span class="s1">// not want to ever copy them, which happens if state gets cloned</span><span class="s2">\n  </span><span class="s1">declare input: string;</span><span class="s2">\n  </span><span class="s1">declare length: number;</span><span class="s2">\n\n  </span><span class="s1">// This method accepts either a string (plugin name) or an array pair</span><span class="s2">\n  </span><span class="s1">// (plugin name and options object). If an options object is given,</span><span class="s2">\n  </span><span class="s1">// then each value is non-recursively checked for identity with that</span><span class="s2">\n  </span><span class="s1">// plugin’s actual option value.</span><span class="s2">\n  </span><span class="s1">hasPlugin(pluginConfig: PluginConfig): boolean {</span><span class="s2">\n    </span><span class="s1">if (typeof pluginConfig === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">return this.plugins.has(pluginConfig);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">const [pluginName, pluginOptions] = pluginConfig;</span><span class="s2">\n      </span><span class="s1">if (!this.hasPlugin(pluginName)) {</span><span class="s2">\n        </span><span class="s1">return false;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">const actualOptions = this.plugins.get(pluginName);</span><span class="s2">\n      </span><span class="s1">for (const key of Object.keys(</span><span class="s2">\n        </span><span class="s1">pluginOptions,</span><span class="s2">\n      </span><span class="s1">) as (keyof typeof pluginOptions)[]) {</span><span class="s2">\n        </span><span class="s1">if (actualOptions?.[key] !== pluginOptions[key]) {</span><span class="s2">\n          </span><span class="s1">return false;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return true;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">getPluginOption&lt;</span><span class="s2">\n    </span><span class="s1">PluginName extends ParserPluginWithOptions[0],</span><span class="s2">\n    </span><span class="s1">OptionName extends keyof PluginOptions&lt;PluginName&gt;,</span><span class="s2">\n  </span><span class="s1">&gt;(plugin: PluginName, name: OptionName) {</span><span class="s2">\n    </span><span class="s1">return (this.plugins.get(plugin) as null | PluginOptions&lt;PluginName&gt;)?.[</span><span class="s2">\n      </span><span class="s1">name</span><span class="s2">\n    </span><span class="s1">];</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">&quot;</span><span class="s2">,</span><span class="s1">&quot;/*:: declare var invariant; */</span><span class="s2">\n\n</span><span class="s1">import BaseParser from </span><span class="s2">\&quot;</span><span class="s1">./base</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type { Comment, Node } from </span><span class="s2">\&quot;</span><span class="s1">../types</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import * as charCodes from </span><span class="s2">\&quot;</span><span class="s1">charcodes</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type { Undone } from </span><span class="s2">\&quot;</span><span class="s1">./node</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* A whitespace token containing comments</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">export type CommentWhitespace = {</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* the start of the whitespace token.</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">start: number;</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* the end of the whitespace token.</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">end: number;</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* the containing comments</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">comments: Array&lt;Comment&gt;;</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* the immediately preceding AST node of the whitespace token</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">leadingNode: Node | null;</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* the immediately following AST node of the whitespace token</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">trailingNode: Node | null;</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* the innermost AST node containing the whitespace with minimal size (|end - start|)</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">containingNode: Node | null;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Merge comments with node's trailingComments or assign comments to be</span><span class="s2">\n </span><span class="s1">* trailingComments. New comments will be placed before old comments</span><span class="s2">\n </span><span class="s1">* because the commentStack is enumerated reversely.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function setTrailingComments(node: Undone&lt;Node&gt;, comments: Array&lt;Comment&gt;) {</span><span class="s2">\n  </span><span class="s1">if (node.trailingComments === undefined) {</span><span class="s2">\n    </span><span class="s1">node.trailingComments = comments;</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">node.trailingComments.unshift(...comments);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Merge comments with node's leadingComments or assign comments to be</span><span class="s2">\n </span><span class="s1">* leadingComments. New comments will be placed before old comments</span><span class="s2">\n </span><span class="s1">* because the commentStack is enumerated reversely.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function setLeadingComments(node: Undone&lt;Node&gt;, comments: Array&lt;Comment&gt;) {</span><span class="s2">\n  </span><span class="s1">if (node.leadingComments === undefined) {</span><span class="s2">\n    </span><span class="s1">node.leadingComments = comments;</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">node.leadingComments.unshift(...comments);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Merge comments with node's innerComments or assign comments to be</span><span class="s2">\n </span><span class="s1">* innerComments. New comments will be placed before old comments</span><span class="s2">\n </span><span class="s1">* because the commentStack is enumerated reversely.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">export function setInnerComments(</span><span class="s2">\n  </span><span class="s1">node: Undone&lt;Node&gt;,</span><span class="s2">\n  </span><span class="s1">comments?: Array&lt;Comment&gt;,</span><span class="s2">\n</span><span class="s1">) {</span><span class="s2">\n  </span><span class="s1">if (node.innerComments === undefined) {</span><span class="s2">\n    </span><span class="s1">node.innerComments = comments;</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">node.innerComments.unshift(...comments);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Given node and elements array, if elements has non-null element,</span><span class="s2">\n </span><span class="s1">* merge comments to its trailingComments, otherwise merge comments</span><span class="s2">\n </span><span class="s1">* to node's innerComments</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function adjustInnerComments(</span><span class="s2">\n  </span><span class="s1">node: Undone&lt;Node&gt;,</span><span class="s2">\n  </span><span class="s1">elements: Array&lt;Node&gt;,</span><span class="s2">\n  </span><span class="s1">commentWS: CommentWhitespace,</span><span class="s2">\n</span><span class="s1">) {</span><span class="s2">\n  </span><span class="s1">let lastElement = null;</span><span class="s2">\n  </span><span class="s1">let i = elements.length;</span><span class="s2">\n  </span><span class="s1">while (lastElement === null &amp;&amp; i &gt; 0) {</span><span class="s2">\n    </span><span class="s1">lastElement = elements[--i];</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (lastElement === null || lastElement.start &gt; commentWS.start) {</span><span class="s2">\n    </span><span class="s1">setInnerComments(node, commentWS.comments);</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">setTrailingComments(lastElement, commentWS.comments);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">export default class CommentsParser extends BaseParser {</span><span class="s2">\n  </span><span class="s1">addComment(comment: Comment): void {</span><span class="s2">\n    </span><span class="s1">if (this.filename) comment.loc.filename = this.filename;</span><span class="s2">\n    </span><span class="s1">this.state.comments.push(comment);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* Given a newly created AST node _n_, attach _n_ to a comment whitespace _w_ if applicable</span><span class="s2">\n   </span><span class="s1">* {@see {@link CommentWhitespace}}</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">processComment(node: Node): void {</span><span class="s2">\n    </span><span class="s1">const { commentStack } = this.state;</span><span class="s2">\n    </span><span class="s1">const commentStackLength = commentStack.length;</span><span class="s2">\n    </span><span class="s1">if (commentStackLength === 0) return;</span><span class="s2">\n    </span><span class="s1">let i = commentStackLength - 1;</span><span class="s2">\n    </span><span class="s1">const lastCommentWS = commentStack[i];</span><span class="s2">\n\n    </span><span class="s1">if (lastCommentWS.start === node.end) {</span><span class="s2">\n      </span><span class="s1">lastCommentWS.leadingNode = node;</span><span class="s2">\n      </span><span class="s1">i--;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">const { start: nodeStart } = node;</span><span class="s2">\n    </span><span class="s1">// invariant: for all 0 &lt;= j &lt;= i, let c = commentStack[j], c must satisfy c.end &lt; node.end</span><span class="s2">\n    </span><span class="s1">for (; i &gt;= 0; i--) {</span><span class="s2">\n      </span><span class="s1">const commentWS = commentStack[i];</span><span class="s2">\n      </span><span class="s1">const commentEnd = commentWS.end;</span><span class="s2">\n      </span><span class="s1">if (commentEnd &gt; nodeStart) {</span><span class="s2">\n        </span><span class="s1">// by definition of commentWhiteSpace, this implies commentWS.start &gt; nodeStart</span><span class="s2">\n        </span><span class="s1">// so node can be a containingNode candidate. At this time we can finalize the comment</span><span class="s2">\n        </span><span class="s1">// whitespace, because</span><span class="s2">\n        </span><span class="s1">// 1) its leadingNode or trailingNode, if exists, will not change</span><span class="s2">\n        </span><span class="s1">// 2) its containingNode have been assigned and will not change because it is the</span><span class="s2">\n        </span><span class="s1">//    innermost minimal-sized AST node</span><span class="s2">\n        </span><span class="s1">commentWS.containingNode = node;</span><span class="s2">\n        </span><span class="s1">this.finalizeComment(commentWS);</span><span class="s2">\n        </span><span class="s1">commentStack.splice(i, 1);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">if (commentEnd === nodeStart) {</span><span class="s2">\n          </span><span class="s1">commentWS.trailingNode = node;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// stop the loop when commentEnd &lt;= nodeStart</span><span class="s2">\n        </span><span class="s1">break;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* Assign the comments of comment whitespaces to related AST nodes.</span><span class="s2">\n   </span><span class="s1">* Also adjust innerComments following trailing comma.</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">finalizeComment(commentWS: CommentWhitespace) {</span><span class="s2">\n    </span><span class="s1">const { comments } = commentWS;</span><span class="s2">\n    </span><span class="s1">if (commentWS.leadingNode !== null || commentWS.trailingNode !== null) {</span><span class="s2">\n      </span><span class="s1">if (commentWS.leadingNode !== null) {</span><span class="s2">\n        </span><span class="s1">setTrailingComments(commentWS.leadingNode, comments);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (commentWS.trailingNode !== null) {</span><span class="s2">\n        </span><span class="s1">setLeadingComments(commentWS.trailingNode, comments);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">/*:: invariant(commentWS.containingNode !== null) */</span><span class="s2">\n      </span><span class="s1">const { containingNode: node, start: commentStart } = commentWS;</span><span class="s2">\n      </span><span class="s1">if (this.input.charCodeAt(commentStart - 1) === charCodes.comma) {</span><span class="s2">\n        </span><span class="s1">// If a commentWhitespace follows a comma and the containingNode allows</span><span class="s2">\n        </span><span class="s1">// list structures with trailing comma, merge it to the trailingComment</span><span class="s2">\n        </span><span class="s1">// of the last non-null list element</span><span class="s2">\n        </span><span class="s1">switch (node.type) {</span><span class="s2">\n          </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">ObjectExpression</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n          </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">ObjectPattern</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n          </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">RecordExpression</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n            </span><span class="s1">adjustInnerComments(node, node.properties, commentWS);</span><span class="s2">\n            </span><span class="s1">break;</span><span class="s2">\n          </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">CallExpression</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n          </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">OptionalCallExpression</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n            </span><span class="s1">adjustInnerComments(node, node.arguments, commentWS);</span><span class="s2">\n            </span><span class="s1">break;</span><span class="s2">\n          </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">FunctionDeclaration</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n          </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">FunctionExpression</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n          </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">ArrowFunctionExpression</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n          </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">ObjectMethod</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n          </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">ClassMethod</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n          </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">ClassPrivateMethod</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n            </span><span class="s1">adjustInnerComments(node, node.params, commentWS);</span><span class="s2">\n            </span><span class="s1">break;</span><span class="s2">\n          </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">ArrayExpression</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n          </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">ArrayPattern</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n          </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">TupleExpression</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n            </span><span class="s1">adjustInnerComments(node, node.elements, commentWS);</span><span class="s2">\n            </span><span class="s1">break;</span><span class="s2">\n          </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">ExportNamedDeclaration</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n          </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">ImportDeclaration</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n            </span><span class="s1">adjustInnerComments(node, node.specifiers, commentWS);</span><span class="s2">\n            </span><span class="s1">break;</span><span class="s2">\n          </span><span class="s1">default: {</span><span class="s2">\n            </span><span class="s1">setInnerComments(node, comments);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">setInnerComments(node, comments);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* Drains remaining commentStack and applies finalizeComment</span><span class="s2">\n   </span><span class="s1">* to each comment whitespace. Used only in parseExpression</span><span class="s2">\n   </span><span class="s1">* where the top level AST node is _not_ Program</span><span class="s2">\n   </span><span class="s1">* {@see {@link CommentsParser#finalizeComment}}</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">finalizeRemainingComments() {</span><span class="s2">\n    </span><span class="s1">const { commentStack } = this.state;</span><span class="s2">\n    </span><span class="s1">for (let i = commentStack.length - 1; i &gt;= 0; i--) {</span><span class="s2">\n      </span><span class="s1">this.finalizeComment(commentStack[i]);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">this.state.commentStack = [];</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">/* eslint-disable no-irregular-whitespace */</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* Reset previous node trailing comments. Used in object / class</span><span class="s2">\n   </span><span class="s1">* property parsing. We parse `async`, `static`, `set` and `get`</span><span class="s2">\n   </span><span class="s1">* as an identifier but may reinterpret it into an async/static/accessor</span><span class="s2">\n   </span><span class="s1">* method later. In this case the identifier is not part of the AST and we</span><span class="s2">\n   </span><span class="s1">* should sync the knowledge to commentStacks</span><span class="s2">\n   </span><span class="s1">*</span><span class="s2">\n   </span><span class="s1">* For example, when parsing</span><span class="s2">\n   </span><span class="s1">* ```</span><span class="s2">\n   </span><span class="s1">* async /* 1 *​/ function f() {}</span><span class="s2">\n   </span><span class="s1">* ```</span><span class="s2">\n   </span><span class="s1">* the comment whitespace `/* 1 *​/` has leading node Identifier(async). When</span><span class="s2">\n   </span><span class="s1">* we see the function token, we create a Function node and mark `/* 1 *​/` as</span><span class="s2">\n   </span><span class="s1">* inner comments. So `/* 1 *​/` should be detached from the Identifier node.</span><span class="s2">\n   </span><span class="s1">*</span><span class="s2">\n   </span><span class="s1">* @param node the last finished AST node _before_ current token</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">/* eslint-enable no-irregular-whitespace */</span><span class="s2">\n  </span><span class="s1">resetPreviousNodeTrailingComments(node: Node) {</span><span class="s2">\n    </span><span class="s1">const { commentStack } = this.state;</span><span class="s2">\n    </span><span class="s1">const { length } = commentStack;</span><span class="s2">\n    </span><span class="s1">if (length === 0) return;</span><span class="s2">\n    </span><span class="s1">const commentWS = commentStack[length - 1];</span><span class="s2">\n    </span><span class="s1">if (commentWS.leadingNode === node) {</span><span class="s2">\n      </span><span class="s1">commentWS.leadingNode = null;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* Attach a node to the comment whitespaces right before/after</span><span class="s2">\n   </span><span class="s1">* the given range.</span><span class="s2">\n   </span><span class="s1">*</span><span class="s2">\n   </span><span class="s1">* This is used to properly attach comments around parenthesized</span><span class="s2">\n   </span><span class="s1">* expressions as leading/trailing comments of the inner expression.</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">takeSurroundingComments(node: Node, start: number, end: number) {</span><span class="s2">\n    </span><span class="s1">const { commentStack } = this.state;</span><span class="s2">\n    </span><span class="s1">const commentStackLength = commentStack.length;</span><span class="s2">\n    </span><span class="s1">if (commentStackLength === 0) return;</span><span class="s2">\n    </span><span class="s1">let i = commentStackLength - 1;</span><span class="s2">\n\n    </span><span class="s1">for (; i &gt;= 0; i--) {</span><span class="s2">\n      </span><span class="s1">const commentWS = commentStack[i];</span><span class="s2">\n      </span><span class="s1">const commentEnd = commentWS.end;</span><span class="s2">\n      </span><span class="s1">const commentStart = commentWS.start;</span><span class="s2">\n\n      </span><span class="s1">if (commentStart === end) {</span><span class="s2">\n        </span><span class="s1">commentWS.leadingNode = node;</span><span class="s2">\n      </span><span class="s1">} else if (commentEnd === start) {</span><span class="s2">\n        </span><span class="s1">commentWS.trailingNode = node;</span><span class="s2">\n      </span><span class="s1">} else if (commentEnd &lt; start) {</span><span class="s2">\n        </span><span class="s1">break;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">&quot;</span><span class="s2">,</span><span class="s1">&quot;import * as charCodes from </span><span class="s2">\&quot;</span><span class="s1">charcodes</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">// Matches a whole line break (where CRLF is considered a single</span><span class="s2">\n</span><span class="s1">// line break). Used to count lines.</span><span class="s2">\n</span><span class="s1">export const lineBreak = /</span><span class="s2">\\</span><span class="s1">r</span><span class="s2">\\</span><span class="s1">n?|[</span><span class="s2">\\</span><span class="s1">n</span><span class="s2">\\</span><span class="s1">u2028</span><span class="s2">\\</span><span class="s1">u2029]/;</span><span class="s2">\n</span><span class="s1">export const lineBreakG = new RegExp(lineBreak.source, </span><span class="s2">\&quot;</span><span class="s1">g</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n\n</span><span class="s1">// https://tc39.github.io/ecma262/#sec-line-terminators</span><span class="s2">\n</span><span class="s1">export function isNewLine(code: number): boolean {</span><span class="s2">\n  </span><span class="s1">switch (code) {</span><span class="s2">\n    </span><span class="s1">case charCodes.lineFeed:</span><span class="s2">\n    </span><span class="s1">case charCodes.carriageReturn:</span><span class="s2">\n    </span><span class="s1">case charCodes.lineSeparator:</span><span class="s2">\n    </span><span class="s1">case charCodes.paragraphSeparator:</span><span class="s2">\n      </span><span class="s1">return true;</span><span class="s2">\n\n    </span><span class="s1">default:</span><span class="s2">\n      </span><span class="s1">return false;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">export const skipWhiteSpace = /(?:</span><span class="s2">\\</span><span class="s1">s|</span><span class="s2">\\</span><span class="s1">/</span><span class="s2">\\</span><span class="s1">/.*|</span><span class="s2">\\</span><span class="s1">/</span><span class="s2">\\</span><span class="s1">*[^]*?</span><span class="s2">\\</span><span class="s1">*</span><span class="s2">\\</span><span class="s1">/)*/g;</span><span class="s2">\n\n</span><span class="s1">export const skipWhiteSpaceInLine =</span><span class="s2">\n  </span><span class="s1">/(?:[^</span><span class="s2">\\</span><span class="s1">S</span><span class="s2">\\</span><span class="s1">n</span><span class="s2">\\</span><span class="s1">r</span><span class="s2">\\</span><span class="s1">u2028</span><span class="s2">\\</span><span class="s1">u2029]|</span><span class="s2">\\</span><span class="s1">/</span><span class="s2">\\</span><span class="s1">/.*|</span><span class="s2">\\</span><span class="s1">/</span><span class="s2">\\</span><span class="s1">*.*?</span><span class="s2">\\</span><span class="s1">*</span><span class="s2">\\</span><span class="s1">/)*/g;</span><span class="s2">\n\n</span><span class="s1">// Skip whitespace and single-line comments, including /* no newline here */.</span><span class="s2">\n</span><span class="s1">// After this RegExp matches, its lastIndex points to a line terminator, or</span><span class="s2">\n</span><span class="s1">// the start of multi-line comment (which is effectively a line terminator),</span><span class="s2">\n</span><span class="s1">// or the end of string.</span><span class="s2">\n</span><span class="s1">export const skipWhiteSpaceToLineBreak = new RegExp(</span><span class="s2">\n  </span><span class="s1">// Unfortunately JS doesn't support Perl's atomic /(?&gt;pattern)/ or</span><span class="s2">\n  </span><span class="s1">// possessive quantifiers, so we use a trick to prevent backtracking</span><span class="s2">\n  </span><span class="s1">// when the look-ahead for line terminator fails.</span><span class="s2">\n  \&quot;</span><span class="s1">(?=(</span><span class="s2">\&quot; </span><span class="s1">+</span><span class="s2">\n    </span><span class="s1">// Capture the whitespace and comments that should be skipped inside</span><span class="s2">\n    </span><span class="s1">// a look-ahead assertion, and then re-match the group as a unit.</span><span class="s2">\n    </span><span class="s1">skipWhiteSpaceInLine.source +</span><span class="s2">\n    \&quot;</span><span class="s1">))</span><span class="s2">\\\\</span><span class="s1">1</span><span class="s2">\&quot; </span><span class="s1">+</span><span class="s2">\n    </span><span class="s1">// Look-ahead for either line terminator, start of multi-line comment,</span><span class="s2">\n    </span><span class="s1">// or end of string.</span><span class="s2">\n    </span><span class="s1">/(?=[</span><span class="s2">\\</span><span class="s1">n</span><span class="s2">\\</span><span class="s1">r</span><span class="s2">\\</span><span class="s1">u2028</span><span class="s2">\\</span><span class="s1">u2029]|</span><span class="s2">\\</span><span class="s1">/</span><span class="s2">\\</span><span class="s1">*(?!.*?</span><span class="s2">\\</span><span class="s1">*</span><span class="s2">\\</span><span class="s1">/)|$)/.source,</span><span class="s2">\n  \&quot;</span><span class="s1">y</span><span class="s2">\&quot;</span><span class="s1">, // sticky</span><span class="s2">\n</span><span class="s1">);</span><span class="s2">\n\n</span><span class="s1">// https://tc39.github.io/ecma262/#sec-white-space</span><span class="s2">\n</span><span class="s1">export function isWhitespace(code: number): boolean {</span><span class="s2">\n  </span><span class="s1">switch (code) {</span><span class="s2">\n    </span><span class="s1">case 0x0009: // CHARACTER TABULATION</span><span class="s2">\n    </span><span class="s1">case 0x000b: // LINE TABULATION</span><span class="s2">\n    </span><span class="s1">case 0x000c: // FORM FEED</span><span class="s2">\n    </span><span class="s1">case charCodes.space:</span><span class="s2">\n    </span><span class="s1">case charCodes.nonBreakingSpace:</span><span class="s2">\n    </span><span class="s1">case charCodes.oghamSpaceMark:</span><span class="s2">\n    </span><span class="s1">case 0x2000: // EN QUAD</span><span class="s2">\n    </span><span class="s1">case 0x2001: // EM QUAD</span><span class="s2">\n    </span><span class="s1">case 0x2002: // EN SPACE</span><span class="s2">\n    </span><span class="s1">case 0x2003: // EM SPACE</span><span class="s2">\n    </span><span class="s1">case 0x2004: // THREE-PER-EM SPACE</span><span class="s2">\n    </span><span class="s1">case 0x2005: // FOUR-PER-EM SPACE</span><span class="s2">\n    </span><span class="s1">case 0x2006: // SIX-PER-EM SPACE</span><span class="s2">\n    </span><span class="s1">case 0x2007: // FIGURE SPACE</span><span class="s2">\n    </span><span class="s1">case 0x2008: // PUNCTUATION SPACE</span><span class="s2">\n    </span><span class="s1">case 0x2009: // THIN SPACE</span><span class="s2">\n    </span><span class="s1">case 0x200a: // HAIR SPACE</span><span class="s2">\n    </span><span class="s1">case 0x202f: // NARROW NO-BREAK SPACE</span><span class="s2">\n    </span><span class="s1">case 0x205f: // MEDIUM MATHEMATICAL SPACE</span><span class="s2">\n    </span><span class="s1">case 0x3000: // IDEOGRAPHIC SPACE</span><span class="s2">\n    </span><span class="s1">case 0xfeff: // ZERO WIDTH NO-BREAK SPACE</span><span class="s2">\n      </span><span class="s1">return true;</span><span class="s2">\n\n    </span><span class="s1">default:</span><span class="s2">\n      </span><span class="s1">return false;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">&quot;</span><span class="s2">,</span><span class="s1">&quot;import type { Options } from </span><span class="s2">\&quot;</span><span class="s1">../options</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type * as N from </span><span class="s2">\&quot;</span><span class="s1">../types</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type { CommentWhitespace } from </span><span class="s2">\&quot;</span><span class="s1">../parser/comments</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import { Position } from </span><span class="s2">\&quot;</span><span class="s1">../util/location</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">import { types as ct, type TokContext } from </span><span class="s2">\&quot;</span><span class="s1">./context</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import { tt, type TokenType } from </span><span class="s2">\&quot;</span><span class="s1">./types</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type { Errors } from </span><span class="s2">\&quot;</span><span class="s1">../parse-error</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import { type ParseError } from </span><span class="s2">\&quot;</span><span class="s1">../parse-error</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">export type DeferredStrictError =</span><span class="s2">\n  </span><span class="s1">| typeof Errors.StrictNumericEscape</span><span class="s2">\n  </span><span class="s1">| typeof Errors.StrictOctalLiteral;</span><span class="s2">\n\n</span><span class="s1">type TopicContextState = {</span><span class="s2">\n  </span><span class="s1">// When a topic binding has been currently established,</span><span class="s2">\n  </span><span class="s1">// then this is 1. Otherwise, it is 0. This is forwards compatible</span><span class="s2">\n  </span><span class="s1">// with a future plugin for multiple lexical topics.</span><span class="s2">\n  </span><span class="s1">maxNumOfResolvableTopics: number;</span><span class="s2">\n  </span><span class="s1">// When a topic binding has been currently established, and if that binding</span><span class="s2">\n  </span><span class="s1">// has been used as a topic reference `#`, then this is 0. Otherwise, it is</span><span class="s2">\n  </span><span class="s1">// `null`. This is forwards compatible with a future plugin for multiple</span><span class="s2">\n  </span><span class="s1">// lexical topics.</span><span class="s2">\n  </span><span class="s1">maxTopicIndex: null | 0;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">export default class State {</span><span class="s2">\n  </span><span class="s1">strict: boolean;</span><span class="s2">\n  </span><span class="s1">curLine: number;</span><span class="s2">\n  </span><span class="s1">lineStart: number;</span><span class="s2">\n\n  </span><span class="s1">// And, if locations are used, the {line, column} object</span><span class="s2">\n  </span><span class="s1">// corresponding to those offsets</span><span class="s2">\n  </span><span class="s1">startLoc: Position;</span><span class="s2">\n  </span><span class="s1">endLoc: Position;</span><span class="s2">\n\n  </span><span class="s1">init({ strictMode, sourceType, startLine, startColumn }: Options): void {</span><span class="s2">\n    </span><span class="s1">this.strict =</span><span class="s2">\n      </span><span class="s1">strictMode === false</span><span class="s2">\n        </span><span class="s1">? false</span><span class="s2">\n        </span><span class="s1">: strictMode === true</span><span class="s2">\n        </span><span class="s1">? true</span><span class="s2">\n        </span><span class="s1">: sourceType === </span><span class="s2">\&quot;</span><span class="s1">module</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n    </span><span class="s1">this.curLine = startLine;</span><span class="s2">\n    </span><span class="s1">this.lineStart = -startColumn;</span><span class="s2">\n    </span><span class="s1">this.startLoc = this.endLoc = new Position(startLine, startColumn, 0);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">errors: ParseError&lt;any&gt;[] = [];</span><span class="s2">\n\n  </span><span class="s1">// Used to signify the start of a potential arrow function</span><span class="s2">\n  </span><span class="s1">potentialArrowAt: number = -1;</span><span class="s2">\n\n  </span><span class="s1">// Used to signify the start of an expression which looks like a</span><span class="s2">\n  </span><span class="s1">// typed arrow function, but it isn't</span><span class="s2">\n  </span><span class="s1">// e.g. a ? (b) : c =&gt; d</span><span class="s2">\n  </span><span class="s1">//          ^</span><span class="s2">\n  </span><span class="s1">noArrowAt: number[] = [];</span><span class="s2">\n\n  </span><span class="s1">// Used to signify the start of an expression whose params, if it looks like</span><span class="s2">\n  </span><span class="s1">// an arrow function, shouldn't be converted to assignable nodes.</span><span class="s2">\n  </span><span class="s1">// This is used to defer the validation of typed arrow functions inside</span><span class="s2">\n  </span><span class="s1">// conditional expressions.</span><span class="s2">\n  </span><span class="s1">// e.g. a ? (b) : c =&gt; d</span><span class="s2">\n  </span><span class="s1">//          ^</span><span class="s2">\n  </span><span class="s1">noArrowParamsConversionAt: number[] = [];</span><span class="s2">\n\n  </span><span class="s1">// Flags to track</span><span class="s2">\n  </span><span class="s1">maybeInArrowParameters: boolean = false;</span><span class="s2">\n  </span><span class="s1">inType: boolean = false;</span><span class="s2">\n  </span><span class="s1">noAnonFunctionType: boolean = false;</span><span class="s2">\n  </span><span class="s1">hasFlowComment: boolean = false;</span><span class="s2">\n  </span><span class="s1">isAmbientContext: boolean = false;</span><span class="s2">\n  </span><span class="s1">inAbstractClass: boolean = false;</span><span class="s2">\n  </span><span class="s1">inDisallowConditionalTypesContext: boolean = false;</span><span class="s2">\n\n  </span><span class="s1">// For the Hack-style pipelines plugin</span><span class="s2">\n  </span><span class="s1">topicContext: TopicContextState = {</span><span class="s2">\n    </span><span class="s1">maxNumOfResolvableTopics: 0,</span><span class="s2">\n    </span><span class="s1">maxTopicIndex: null,</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n\n  </span><span class="s1">// For the F#-style pipelines plugin</span><span class="s2">\n  </span><span class="s1">soloAwait: boolean = false;</span><span class="s2">\n  </span><span class="s1">inFSharpPipelineDirectBody: boolean = false;</span><span class="s2">\n\n  </span><span class="s1">// Labels in scope.</span><span class="s2">\n  </span><span class="s1">labels: Array&lt;{</span><span class="s2">\n    </span><span class="s1">kind: </span><span class="s2">\&quot;</span><span class="s1">loop</span><span class="s2">\&quot; </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">switch</span><span class="s2">\&quot; </span><span class="s1">| undefined | null;</span><span class="s2">\n    </span><span class="s1">name?: string | null;</span><span class="s2">\n    </span><span class="s1">statementStart?: number;</span><span class="s2">\n  </span><span class="s1">}&gt; = [];</span><span class="s2">\n\n  </span><span class="s1">// Comment store for Program.comments</span><span class="s2">\n  </span><span class="s1">comments: Array&lt;N.Comment&gt; = [];</span><span class="s2">\n\n  </span><span class="s1">// Comment attachment store</span><span class="s2">\n  </span><span class="s1">commentStack: Array&lt;CommentWhitespace&gt; = [];</span><span class="s2">\n\n  </span><span class="s1">// The current position of the tokenizer in the input.</span><span class="s2">\n  </span><span class="s1">pos: number = 0;</span><span class="s2">\n\n  </span><span class="s1">// Properties of the current token:</span><span class="s2">\n  </span><span class="s1">// Its type</span><span class="s2">\n  </span><span class="s1">type: TokenType = tt.eof;</span><span class="s2">\n\n  </span><span class="s1">// For tokens that include more information than their type, the value</span><span class="s2">\n  </span><span class="s1">value: any = null;</span><span class="s2">\n\n  </span><span class="s1">// Its start and end offset</span><span class="s2">\n  </span><span class="s1">start: number = 0;</span><span class="s2">\n  </span><span class="s1">end: number = 0;</span><span class="s2">\n\n  </span><span class="s1">// Position information for the previous token</span><span class="s2">\n  </span><span class="s1">// this is initialized when generating the second token.</span><span class="s2">\n  </span><span class="s1">lastTokEndLoc: Position = null;</span><span class="s2">\n  </span><span class="s1">// this is initialized when generating the second token.</span><span class="s2">\n  </span><span class="s1">lastTokStartLoc: Position = null;</span><span class="s2">\n  </span><span class="s1">lastTokStart: number = 0;</span><span class="s2">\n\n  </span><span class="s1">// The context stack is used to track whether the apostrophe </span><span class="s2">\&quot;</span><span class="s1">`</span><span class="s2">\&quot; </span><span class="s1">starts</span><span class="s2">\n  </span><span class="s1">// or ends a string template</span><span class="s2">\n  </span><span class="s1">context: Array&lt;TokContext&gt; = [ct.brace];</span><span class="s2">\n  </span><span class="s1">// Used to track whether a JSX element is allowed to form</span><span class="s2">\n  </span><span class="s1">canStartJSXElement: boolean = true;</span><span class="s2">\n\n  </span><span class="s1">// Used to signal to callers of `readWord1` whether the word</span><span class="s2">\n  </span><span class="s1">// contained any escape sequences. This is needed because words with</span><span class="s2">\n  </span><span class="s1">// escape sequences must not be interpreted as keywords.</span><span class="s2">\n  </span><span class="s1">containsEsc: boolean = false;</span><span class="s2">\n\n  </span><span class="s1">// Used to track invalid escape sequences in template literals,</span><span class="s2">\n  </span><span class="s1">// that must be reported if the template is not tagged.</span><span class="s2">\n  </span><span class="s1">firstInvalidTemplateEscapePos: null | Position = null;</span><span class="s2">\n\n  </span><span class="s1">// This property is used to track the following errors</span><span class="s2">\n  </span><span class="s1">// - StrictNumericEscape</span><span class="s2">\n  </span><span class="s1">// - StrictOctalLiteral</span><span class="s2">\n  </span><span class="s1">//</span><span class="s2">\n  </span><span class="s1">// in a literal that occurs prior to/immediately after a </span><span class="s2">\&quot;</span><span class="s1">use strict</span><span class="s2">\&quot; </span><span class="s1">directive.</span><span class="s2">\n\n  </span><span class="s1">// todo(JLHwung): set strictErrors to null and avoid recording string errors</span><span class="s2">\n  </span><span class="s1">// after a non-directive is parsed</span><span class="s2">\n  </span><span class="s1">strictErrors: Map&lt;number, [DeferredStrictError, Position]&gt; = new Map();</span><span class="s2">\n\n  </span><span class="s1">// Tokens length in token store</span><span class="s2">\n  </span><span class="s1">tokensLength: number = 0;</span><span class="s2">\n\n  </span><span class="s1">curPosition(): Position {</span><span class="s2">\n    </span><span class="s1">return new Position(this.curLine, this.pos - this.lineStart, this.pos);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">clone(skipArrays?: boolean): State {</span><span class="s2">\n    </span><span class="s1">const state = new State();</span><span class="s2">\n    </span><span class="s1">const keys = Object.keys(this) as (keyof State)[];</span><span class="s2">\n    </span><span class="s1">for (let i = 0, length = keys.length; i &lt; length; i++) {</span><span class="s2">\n      </span><span class="s1">const key = keys[i];</span><span class="s2">\n      </span><span class="s1">let val = this[key];</span><span class="s2">\n\n      </span><span class="s1">if (!skipArrays &amp;&amp; Array.isArray(val)) {</span><span class="s2">\n        </span><span class="s1">val = val.slice();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">// @ts-expect-error val must conform to S[key]</span><span class="s2">\n      </span><span class="s1">state[key] = val;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">return state;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">export type LookaheadState = {</span><span class="s2">\n  </span><span class="s1">pos: number;</span><span class="s2">\n  </span><span class="s1">value: any;</span><span class="s2">\n  </span><span class="s1">type: TokenType;</span><span class="s2">\n  </span><span class="s1">start: number;</span><span class="s2">\n  </span><span class="s1">end: number;</span><span class="s2">\n  </span><span class="s1">context: TokContext[];</span><span class="s2">\n  </span><span class="s1">startLoc: Position;</span><span class="s2">\n  </span><span class="s1">lastTokEndLoc: Position;</span><span class="s2">\n  </span><span class="s1">curLine: number;</span><span class="s2">\n  </span><span class="s1">lineStart: number;</span><span class="s2">\n  </span><span class="s1">curPosition: () =&gt; Position;</span><span class="s2">\n  </span><span class="s1">/* Used only in readToken_mult_modulo */</span><span class="s2">\n  </span><span class="s1">inType: boolean;</span><span class="s2">\n  </span><span class="s1">// These boolean properties are not initialized in createLookaheadState()</span><span class="s2">\n  </span><span class="s1">// instead they will only be set by the tokenizer</span><span class="s2">\n  </span><span class="s1">containsEsc?: boolean;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">&quot;</span><span class="s2">,</span><span class="s1">&quot;import * as charCodes from </span><span class="s2">\&quot;</span><span class="s1">charcodes</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">// The following character codes are forbidden from being</span><span class="s2">\n</span><span class="s1">// an immediate sibling of NumericLiteralSeparator _</span><span class="s2">\n</span><span class="s1">const forbiddenNumericSeparatorSiblings = {</span><span class="s2">\n  </span><span class="s1">decBinOct: new Set&lt;number&gt;([</span><span class="s2">\n    </span><span class="s1">charCodes.dot,</span><span class="s2">\n    </span><span class="s1">charCodes.uppercaseB,</span><span class="s2">\n    </span><span class="s1">charCodes.uppercaseE,</span><span class="s2">\n    </span><span class="s1">charCodes.uppercaseO,</span><span class="s2">\n    </span><span class="s1">charCodes.underscore, // multiple separators are not allowed</span><span class="s2">\n    </span><span class="s1">charCodes.lowercaseB,</span><span class="s2">\n    </span><span class="s1">charCodes.lowercaseE,</span><span class="s2">\n    </span><span class="s1">charCodes.lowercaseO,</span><span class="s2">\n  </span><span class="s1">]),</span><span class="s2">\n  </span><span class="s1">hex: new Set&lt;number&gt;([</span><span class="s2">\n    </span><span class="s1">charCodes.dot,</span><span class="s2">\n    </span><span class="s1">charCodes.uppercaseX,</span><span class="s2">\n    </span><span class="s1">charCodes.underscore, // multiple separators are not allowed</span><span class="s2">\n    </span><span class="s1">charCodes.lowercaseX,</span><span class="s2">\n  </span><span class="s1">]),</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">const isAllowedNumericSeparatorSibling = {</span><span class="s2">\n  </span><span class="s1">// 0 - 1</span><span class="s2">\n  </span><span class="s1">bin: (ch: number) =&gt; ch === charCodes.digit0 || ch === charCodes.digit1,</span><span class="s2">\n\n  </span><span class="s1">// 0 - 7</span><span class="s2">\n  </span><span class="s1">oct: (ch: number) =&gt; ch &gt;= charCodes.digit0 &amp;&amp; ch &lt;= charCodes.digit7,</span><span class="s2">\n\n  </span><span class="s1">// 0 - 9</span><span class="s2">\n  </span><span class="s1">dec: (ch: number) =&gt; ch &gt;= charCodes.digit0 &amp;&amp; ch &lt;= charCodes.digit9,</span><span class="s2">\n\n  </span><span class="s1">// 0 - 9, A - F, a - f,</span><span class="s2">\n  </span><span class="s1">hex: (ch: number) =&gt;</span><span class="s2">\n    </span><span class="s1">(ch &gt;= charCodes.digit0 &amp;&amp; ch &lt;= charCodes.digit9) ||</span><span class="s2">\n    </span><span class="s1">(ch &gt;= charCodes.uppercaseA &amp;&amp; ch &lt;= charCodes.uppercaseF) ||</span><span class="s2">\n    </span><span class="s1">(ch &gt;= charCodes.lowercaseA &amp;&amp; ch &lt;= charCodes.lowercaseF),</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">export type StringContentsErrorHandlers = EscapedCharErrorHandlers &amp; {</span><span class="s2">\n  </span><span class="s1">unterminated(</span><span class="s2">\n    </span><span class="s1">initialPos: number,</span><span class="s2">\n    </span><span class="s1">initialLineStart: number,</span><span class="s2">\n    </span><span class="s1">initialCurLine: number,</span><span class="s2">\n  </span><span class="s1">): void;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">export function readStringContents(</span><span class="s2">\n  </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">single</span><span class="s2">\&quot; </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">double</span><span class="s2">\&quot; </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">template</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">input: string,</span><span class="s2">\n  </span><span class="s1">pos: number,</span><span class="s2">\n  </span><span class="s1">lineStart: number,</span><span class="s2">\n  </span><span class="s1">curLine: number,</span><span class="s2">\n  </span><span class="s1">errors: StringContentsErrorHandlers,</span><span class="s2">\n</span><span class="s1">) {</span><span class="s2">\n  </span><span class="s1">const initialPos = pos;</span><span class="s2">\n  </span><span class="s1">const initialLineStart = lineStart;</span><span class="s2">\n  </span><span class="s1">const initialCurLine = curLine;</span><span class="s2">\n\n  </span><span class="s1">let out = </span><span class="s2">\&quot;\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">let firstInvalidLoc = null;</span><span class="s2">\n  </span><span class="s1">let chunkStart = pos;</span><span class="s2">\n  </span><span class="s1">const { length } = input;</span><span class="s2">\n  </span><span class="s1">for (;;) {</span><span class="s2">\n    </span><span class="s1">if (pos &gt;= length) {</span><span class="s2">\n      </span><span class="s1">errors.unterminated(initialPos, initialLineStart, initialCurLine);</span><span class="s2">\n      </span><span class="s1">out += input.slice(chunkStart, pos);</span><span class="s2">\n      </span><span class="s1">break;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">const ch = input.charCodeAt(pos);</span><span class="s2">\n    </span><span class="s1">if (isStringEnd(type, ch, input, pos)) {</span><span class="s2">\n      </span><span class="s1">out += input.slice(chunkStart, pos);</span><span class="s2">\n      </span><span class="s1">break;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (ch === charCodes.backslash) {</span><span class="s2">\n      </span><span class="s1">out += input.slice(chunkStart, pos);</span><span class="s2">\n      </span><span class="s1">const res = readEscapedChar(</span><span class="s2">\n        </span><span class="s1">input,</span><span class="s2">\n        </span><span class="s1">pos,</span><span class="s2">\n        </span><span class="s1">lineStart,</span><span class="s2">\n        </span><span class="s1">curLine,</span><span class="s2">\n        </span><span class="s1">type === </span><span class="s2">\&quot;</span><span class="s1">template</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">errors,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">if (res.ch === null &amp;&amp; !firstInvalidLoc) {</span><span class="s2">\n        </span><span class="s1">firstInvalidLoc = { pos, lineStart, curLine };</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">out += res.ch;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">({ pos, lineStart, curLine } = res);</span><span class="s2">\n      </span><span class="s1">chunkStart = pos;</span><span class="s2">\n    </span><span class="s1">} else if (</span><span class="s2">\n      </span><span class="s1">ch === charCodes.lineSeparator ||</span><span class="s2">\n      </span><span class="s1">ch === charCodes.paragraphSeparator</span><span class="s2">\n    </span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">++pos;</span><span class="s2">\n      </span><span class="s1">++curLine;</span><span class="s2">\n      </span><span class="s1">lineStart = pos;</span><span class="s2">\n    </span><span class="s1">} else if (ch === charCodes.lineFeed || ch === charCodes.carriageReturn) {</span><span class="s2">\n      </span><span class="s1">if (type === </span><span class="s2">\&quot;</span><span class="s1">template</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">out += input.slice(chunkStart, pos) + </span><span class="s2">\&quot;\\</span><span class="s1">n</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n        </span><span class="s1">++pos;</span><span class="s2">\n        </span><span class="s1">if (</span><span class="s2">\n          </span><span class="s1">ch === charCodes.carriageReturn &amp;&amp;</span><span class="s2">\n          </span><span class="s1">input.charCodeAt(pos) === charCodes.lineFeed</span><span class="s2">\n        </span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">++pos;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">++curLine;</span><span class="s2">\n        </span><span class="s1">chunkStart = lineStart = pos;</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">errors.unterminated(initialPos, initialLineStart, initialCurLine);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">++pos;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return {</span><span class="s2">\n    </span><span class="s1">pos,</span><span class="s2">\n    </span><span class="s1">str: out,</span><span class="s2">\n    </span><span class="s1">firstInvalidLoc,</span><span class="s2">\n    </span><span class="s1">lineStart,</span><span class="s2">\n    </span><span class="s1">curLine,</span><span class="s2">\n\n    </span><span class="s1">// TODO(Babel 8): This is only needed for backwards compatibility,</span><span class="s2">\n    </span><span class="s1">// we can remove it.</span><span class="s2">\n    </span><span class="s1">containsInvalid: !!firstInvalidLoc,</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function isStringEnd(</span><span class="s2">\n  </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">single</span><span class="s2">\&quot; </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">double</span><span class="s2">\&quot; </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">template</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ch: number,</span><span class="s2">\n  </span><span class="s1">input: string,</span><span class="s2">\n  </span><span class="s1">pos: number,</span><span class="s2">\n</span><span class="s1">) {</span><span class="s2">\n  </span><span class="s1">if (type === </span><span class="s2">\&quot;</span><span class="s1">template</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">return (</span><span class="s2">\n      </span><span class="s1">ch === charCodes.graveAccent ||</span><span class="s2">\n      </span><span class="s1">(ch === charCodes.dollarSign &amp;&amp;</span><span class="s2">\n        </span><span class="s1">input.charCodeAt(pos + 1) === charCodes.leftCurlyBrace)</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return (</span><span class="s2">\n    </span><span class="s1">ch === (type === </span><span class="s2">\&quot;</span><span class="s1">double</span><span class="s2">\&quot; </span><span class="s1">? charCodes.quotationMark : charCodes.apostrophe)</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">type EscapedCharErrorHandlers = HexCharErrorHandlers &amp;</span><span class="s2">\n  </span><span class="s1">CodePointErrorHandlers &amp; {</span><span class="s2">\n    </span><span class="s1">strictNumericEscape(pos: number, lineStart: number, curLine: number): void;</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">function readEscapedChar(</span><span class="s2">\n  </span><span class="s1">input: string,</span><span class="s2">\n  </span><span class="s1">pos: number,</span><span class="s2">\n  </span><span class="s1">lineStart: number,</span><span class="s2">\n  </span><span class="s1">curLine: number,</span><span class="s2">\n  </span><span class="s1">inTemplate: boolean,</span><span class="s2">\n  </span><span class="s1">errors: EscapedCharErrorHandlers,</span><span class="s2">\n</span><span class="s1">) {</span><span class="s2">\n  </span><span class="s1">const throwOnInvalid = !inTemplate;</span><span class="s2">\n  </span><span class="s1">pos++; // skip '</span><span class="s2">\\</span><span class="s1">'</span><span class="s2">\n\n  </span><span class="s1">const res = (ch: string | null) =&gt; ({ pos, ch, lineStart, curLine });</span><span class="s2">\n\n  </span><span class="s1">const ch = input.charCodeAt(pos++);</span><span class="s2">\n  </span><span class="s1">switch (ch) {</span><span class="s2">\n    </span><span class="s1">case charCodes.lowercaseN:</span><span class="s2">\n      </span><span class="s1">return res(</span><span class="s2">\&quot;\\</span><span class="s1">n</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">case charCodes.lowercaseR:</span><span class="s2">\n      </span><span class="s1">return res(</span><span class="s2">\&quot;\\</span><span class="s1">r</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">case charCodes.lowercaseX: {</span><span class="s2">\n      </span><span class="s1">let code;</span><span class="s2">\n      </span><span class="s1">({ code, pos } = readHexChar(</span><span class="s2">\n        </span><span class="s1">input,</span><span class="s2">\n        </span><span class="s1">pos,</span><span class="s2">\n        </span><span class="s1">lineStart,</span><span class="s2">\n        </span><span class="s1">curLine,</span><span class="s2">\n        </span><span class="s1">2,</span><span class="s2">\n        </span><span class="s1">false,</span><span class="s2">\n        </span><span class="s1">throwOnInvalid,</span><span class="s2">\n        </span><span class="s1">errors,</span><span class="s2">\n      </span><span class="s1">));</span><span class="s2">\n      </span><span class="s1">return res(code === null ? null : String.fromCharCode(code));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">case charCodes.lowercaseU: {</span><span class="s2">\n      </span><span class="s1">let code;</span><span class="s2">\n      </span><span class="s1">({ code, pos } = readCodePoint(</span><span class="s2">\n        </span><span class="s1">input,</span><span class="s2">\n        </span><span class="s1">pos,</span><span class="s2">\n        </span><span class="s1">lineStart,</span><span class="s2">\n        </span><span class="s1">curLine,</span><span class="s2">\n        </span><span class="s1">throwOnInvalid,</span><span class="s2">\n        </span><span class="s1">errors,</span><span class="s2">\n      </span><span class="s1">));</span><span class="s2">\n      </span><span class="s1">return res(code === null ? null : String.fromCodePoint(code));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">case charCodes.lowercaseT:</span><span class="s2">\n      </span><span class="s1">return res(</span><span class="s2">\&quot;\\</span><span class="s1">t</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">case charCodes.lowercaseB:</span><span class="s2">\n      </span><span class="s1">return res(</span><span class="s2">\&quot;\\</span><span class="s1">b</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">case charCodes.lowercaseV:</span><span class="s2">\n      </span><span class="s1">return res(</span><span class="s2">\&quot;\\</span><span class="s1">u000b</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">case charCodes.lowercaseF:</span><span class="s2">\n      </span><span class="s1">return res(</span><span class="s2">\&quot;\\</span><span class="s1">f</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">case charCodes.carriageReturn:</span><span class="s2">\n      </span><span class="s1">if (input.charCodeAt(pos) === charCodes.lineFeed) {</span><span class="s2">\n        </span><span class="s1">++pos;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// fall through</span><span class="s2">\n    </span><span class="s1">case charCodes.lineFeed:</span><span class="s2">\n      </span><span class="s1">lineStart = pos;</span><span class="s2">\n      </span><span class="s1">++curLine;</span><span class="s2">\n    </span><span class="s1">// fall through</span><span class="s2">\n    </span><span class="s1">case charCodes.lineSeparator:</span><span class="s2">\n    </span><span class="s1">case charCodes.paragraphSeparator:</span><span class="s2">\n      </span><span class="s1">return res(</span><span class="s2">\&quot;\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">case charCodes.digit8:</span><span class="s2">\n    </span><span class="s1">case charCodes.digit9:</span><span class="s2">\n      </span><span class="s1">if (inTemplate) {</span><span class="s2">\n        </span><span class="s1">return res(null);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">errors.strictNumericEscape(pos - 1, lineStart, curLine);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// fall through</span><span class="s2">\n    </span><span class="s1">default:</span><span class="s2">\n      </span><span class="s1">if (ch &gt;= charCodes.digit0 &amp;&amp; ch &lt;= charCodes.digit7) {</span><span class="s2">\n        </span><span class="s1">const startPos = pos - 1;</span><span class="s2">\n        </span><span class="s1">const match = input.slice(startPos, pos + 2).match(/^[0-7]+/)!;</span><span class="s2">\n\n        </span><span class="s1">let octalStr = match[0];</span><span class="s2">\n\n        </span><span class="s1">let octal = parseInt(octalStr, 8);</span><span class="s2">\n        </span><span class="s1">if (octal &gt; 255) {</span><span class="s2">\n          </span><span class="s1">octalStr = octalStr.slice(0, -1);</span><span class="s2">\n          </span><span class="s1">octal = parseInt(octalStr, 8);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">pos += octalStr.length - 1;</span><span class="s2">\n        </span><span class="s1">const next = input.charCodeAt(pos);</span><span class="s2">\n        </span><span class="s1">if (</span><span class="s2">\n          </span><span class="s1">octalStr !== </span><span class="s2">\&quot;</span><span class="s1">0</span><span class="s2">\&quot; </span><span class="s1">||</span><span class="s2">\n          </span><span class="s1">next === charCodes.digit8 ||</span><span class="s2">\n          </span><span class="s1">next === charCodes.digit9</span><span class="s2">\n        </span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">if (inTemplate) {</span><span class="s2">\n            </span><span class="s1">return res(null);</span><span class="s2">\n          </span><span class="s1">} else {</span><span class="s2">\n            </span><span class="s1">errors.strictNumericEscape(startPos, lineStart, curLine);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">return res(String.fromCharCode(octal));</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return res(String.fromCharCode(ch));</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">type HexCharErrorHandlers = IntErrorHandlers &amp; {</span><span class="s2">\n  </span><span class="s1">invalidEscapeSequence(pos: number, lineStart: number, curLine: number): void;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">// Used to read character escape sequences ('</span><span class="s2">\\</span><span class="s1">x', '</span><span class="s2">\\</span><span class="s1">u').</span><span class="s2">\n</span><span class="s1">function readHexChar(</span><span class="s2">\n  </span><span class="s1">input: string,</span><span class="s2">\n  </span><span class="s1">pos: number,</span><span class="s2">\n  </span><span class="s1">lineStart: number,</span><span class="s2">\n  </span><span class="s1">curLine: number,</span><span class="s2">\n  </span><span class="s1">len: number,</span><span class="s2">\n  </span><span class="s1">forceLen: boolean,</span><span class="s2">\n  </span><span class="s1">throwOnInvalid: boolean,</span><span class="s2">\n  </span><span class="s1">errors: HexCharErrorHandlers,</span><span class="s2">\n</span><span class="s1">) {</span><span class="s2">\n  </span><span class="s1">const initialPos = pos;</span><span class="s2">\n  </span><span class="s1">let n;</span><span class="s2">\n  </span><span class="s1">({ n, pos } = readInt(</span><span class="s2">\n    </span><span class="s1">input,</span><span class="s2">\n    </span><span class="s1">pos,</span><span class="s2">\n    </span><span class="s1">lineStart,</span><span class="s2">\n    </span><span class="s1">curLine,</span><span class="s2">\n    </span><span class="s1">16,</span><span class="s2">\n    </span><span class="s1">len,</span><span class="s2">\n    </span><span class="s1">forceLen,</span><span class="s2">\n    </span><span class="s1">false,</span><span class="s2">\n    </span><span class="s1">errors,</span><span class="s2">\n    </span><span class="s1">/* bailOnError */ !throwOnInvalid,</span><span class="s2">\n  </span><span class="s1">));</span><span class="s2">\n  </span><span class="s1">if (n === null) {</span><span class="s2">\n    </span><span class="s1">if (throwOnInvalid) {</span><span class="s2">\n      </span><span class="s1">errors.invalidEscapeSequence(initialPos, lineStart, curLine);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">pos = initialPos - 1;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return { code: n, pos };</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">export type IntErrorHandlers = {</span><span class="s2">\n  </span><span class="s1">numericSeparatorInEscapeSequence(</span><span class="s2">\n    </span><span class="s1">pos: number,</span><span class="s2">\n    </span><span class="s1">lineStart: number,</span><span class="s2">\n    </span><span class="s1">curLine: number,</span><span class="s2">\n  </span><span class="s1">): void;</span><span class="s2">\n  </span><span class="s1">unexpectedNumericSeparator(</span><span class="s2">\n    </span><span class="s1">pos: number,</span><span class="s2">\n    </span><span class="s1">lineStart: number,</span><span class="s2">\n    </span><span class="s1">curLine: number,</span><span class="s2">\n  </span><span class="s1">): void;</span><span class="s2">\n  </span><span class="s1">// It can return </span><span class="s2">\&quot;</span><span class="s1">true</span><span class="s2">\&quot; </span><span class="s1">to indicate that the error was handled</span><span class="s2">\n  </span><span class="s1">// and the int parsing should continue.</span><span class="s2">\n  </span><span class="s1">invalidDigit(</span><span class="s2">\n    </span><span class="s1">pos: number,</span><span class="s2">\n    </span><span class="s1">lineStart: number,</span><span class="s2">\n    </span><span class="s1">curLine: number,</span><span class="s2">\n    </span><span class="s1">radix: number,</span><span class="s2">\n  </span><span class="s1">): boolean;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">export function readInt(</span><span class="s2">\n  </span><span class="s1">input: string,</span><span class="s2">\n  </span><span class="s1">pos: number,</span><span class="s2">\n  </span><span class="s1">lineStart: number,</span><span class="s2">\n  </span><span class="s1">curLine: number,</span><span class="s2">\n  </span><span class="s1">radix: number,</span><span class="s2">\n  </span><span class="s1">len: number | undefined,</span><span class="s2">\n  </span><span class="s1">forceLen: boolean,</span><span class="s2">\n  </span><span class="s1">allowNumSeparator: boolean | </span><span class="s2">\&quot;</span><span class="s1">bail</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">errors: IntErrorHandlers,</span><span class="s2">\n  </span><span class="s1">bailOnError: boolean,</span><span class="s2">\n</span><span class="s1">) {</span><span class="s2">\n  </span><span class="s1">const start = pos;</span><span class="s2">\n  </span><span class="s1">const forbiddenSiblings =</span><span class="s2">\n    </span><span class="s1">radix === 16</span><span class="s2">\n      </span><span class="s1">? forbiddenNumericSeparatorSiblings.hex</span><span class="s2">\n      </span><span class="s1">: forbiddenNumericSeparatorSiblings.decBinOct;</span><span class="s2">\n  </span><span class="s1">const isAllowedSibling =</span><span class="s2">\n    </span><span class="s1">radix === 16</span><span class="s2">\n      </span><span class="s1">? isAllowedNumericSeparatorSibling.hex</span><span class="s2">\n      </span><span class="s1">: radix === 10</span><span class="s2">\n      </span><span class="s1">? isAllowedNumericSeparatorSibling.dec</span><span class="s2">\n      </span><span class="s1">: radix === 8</span><span class="s2">\n      </span><span class="s1">? isAllowedNumericSeparatorSibling.oct</span><span class="s2">\n      </span><span class="s1">: isAllowedNumericSeparatorSibling.bin;</span><span class="s2">\n\n  </span><span class="s1">let invalid = false;</span><span class="s2">\n  </span><span class="s1">let total = 0;</span><span class="s2">\n\n  </span><span class="s1">for (let i = 0, e = len == null ? Infinity : len; i &lt; e; ++i) {</span><span class="s2">\n    </span><span class="s1">const code = input.charCodeAt(pos);</span><span class="s2">\n    </span><span class="s1">let val;</span><span class="s2">\n\n    </span><span class="s1">if (code === charCodes.underscore &amp;&amp; allowNumSeparator !== </span><span class="s2">\&quot;</span><span class="s1">bail</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">const prev = input.charCodeAt(pos - 1);</span><span class="s2">\n      </span><span class="s1">const next = input.charCodeAt(pos + 1);</span><span class="s2">\n\n      </span><span class="s1">if (!allowNumSeparator) {</span><span class="s2">\n        </span><span class="s1">if (bailOnError) return { n: null, pos };</span><span class="s2">\n        </span><span class="s1">errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);</span><span class="s2">\n      </span><span class="s1">} else if (</span><span class="s2">\n        </span><span class="s1">Number.isNaN(next) ||</span><span class="s2">\n        </span><span class="s1">!isAllowedSibling(next) ||</span><span class="s2">\n        </span><span class="s1">forbiddenSiblings.has(prev) ||</span><span class="s2">\n        </span><span class="s1">forbiddenSiblings.has(next)</span><span class="s2">\n      </span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">if (bailOnError) return { n: null, pos };</span><span class="s2">\n        </span><span class="s1">errors.unexpectedNumericSeparator(pos, lineStart, curLine);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">// Ignore this _ character</span><span class="s2">\n      </span><span class="s1">++pos;</span><span class="s2">\n      </span><span class="s1">continue;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">if (code &gt;= charCodes.lowercaseA) {</span><span class="s2">\n      </span><span class="s1">val = code - charCodes.lowercaseA + charCodes.lineFeed;</span><span class="s2">\n    </span><span class="s1">} else if (code &gt;= charCodes.uppercaseA) {</span><span class="s2">\n      </span><span class="s1">val = code - charCodes.uppercaseA + charCodes.lineFeed;</span><span class="s2">\n    </span><span class="s1">} else if (charCodes.isDigit(code)) {</span><span class="s2">\n      </span><span class="s1">val = code - charCodes.digit0; // 0-9</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">val = Infinity;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (val &gt;= radix) {</span><span class="s2">\n      </span><span class="s1">// If we found a digit which is too big, errors.invalidDigit can return true to avoid</span><span class="s2">\n      </span><span class="s1">// breaking the loop (this is used for error recovery).</span><span class="s2">\n      </span><span class="s1">if (val &lt;= 9 &amp;&amp; bailOnError) {</span><span class="s2">\n        </span><span class="s1">return { n: null, pos };</span><span class="s2">\n      </span><span class="s1">} else if (</span><span class="s2">\n        </span><span class="s1">val &lt;= 9 &amp;&amp;</span><span class="s2">\n        </span><span class="s1">errors.invalidDigit(pos, lineStart, curLine, radix)</span><span class="s2">\n      </span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">val = 0;</span><span class="s2">\n      </span><span class="s1">} else if (forceLen) {</span><span class="s2">\n        </span><span class="s1">val = 0;</span><span class="s2">\n        </span><span class="s1">invalid = true;</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">break;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">++pos;</span><span class="s2">\n    </span><span class="s1">total = total * radix + val;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (pos === start || (len != null &amp;&amp; pos - start !== len) || invalid) {</span><span class="s2">\n    </span><span class="s1">return { n: null, pos };</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">return { n: total, pos };</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">export type CodePointErrorHandlers = HexCharErrorHandlers &amp; {</span><span class="s2">\n  </span><span class="s1">invalidCodePoint(pos: number, lineStart: number, curLine: number): void;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">export function readCodePoint(</span><span class="s2">\n  </span><span class="s1">input: string,</span><span class="s2">\n  </span><span class="s1">pos: number,</span><span class="s2">\n  </span><span class="s1">lineStart: number,</span><span class="s2">\n  </span><span class="s1">curLine: number,</span><span class="s2">\n  </span><span class="s1">throwOnInvalid: boolean,</span><span class="s2">\n  </span><span class="s1">errors: CodePointErrorHandlers,</span><span class="s2">\n</span><span class="s1">) {</span><span class="s2">\n  </span><span class="s1">const ch = input.charCodeAt(pos);</span><span class="s2">\n  </span><span class="s1">let code;</span><span class="s2">\n\n  </span><span class="s1">if (ch === charCodes.leftCurlyBrace) {</span><span class="s2">\n    </span><span class="s1">++pos;</span><span class="s2">\n    </span><span class="s1">({ code, pos } = readHexChar(</span><span class="s2">\n      </span><span class="s1">input,</span><span class="s2">\n      </span><span class="s1">pos,</span><span class="s2">\n      </span><span class="s1">lineStart,</span><span class="s2">\n      </span><span class="s1">curLine,</span><span class="s2">\n      </span><span class="s1">input.indexOf(</span><span class="s2">\&quot;</span><span class="s1">}</span><span class="s2">\&quot;</span><span class="s1">, pos) - pos,</span><span class="s2">\n      </span><span class="s1">true,</span><span class="s2">\n      </span><span class="s1">throwOnInvalid,</span><span class="s2">\n      </span><span class="s1">errors,</span><span class="s2">\n    </span><span class="s1">));</span><span class="s2">\n    </span><span class="s1">++pos;</span><span class="s2">\n    </span><span class="s1">if (code !== null &amp;&amp; code &gt; 0x10ffff) {</span><span class="s2">\n      </span><span class="s1">if (throwOnInvalid) {</span><span class="s2">\n        </span><span class="s1">errors.invalidCodePoint(pos, lineStart, curLine);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">return { code: null, pos };</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">({ code, pos } = readHexChar(</span><span class="s2">\n      </span><span class="s1">input,</span><span class="s2">\n      </span><span class="s1">pos,</span><span class="s2">\n      </span><span class="s1">lineStart,</span><span class="s2">\n      </span><span class="s1">curLine,</span><span class="s2">\n      </span><span class="s1">4,</span><span class="s2">\n      </span><span class="s1">false,</span><span class="s2">\n      </span><span class="s1">throwOnInvalid,</span><span class="s2">\n      </span><span class="s1">errors,</span><span class="s2">\n    </span><span class="s1">));</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return { code, pos };</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">&quot;</span><span class="s2">,</span><span class="s1">&quot;/*:: declare var invariant; */</span><span class="s2">\n\n</span><span class="s1">import type { Options } from </span><span class="s2">\&quot;</span><span class="s1">../options</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import {</span><span class="s2">\n  </span><span class="s1">Position,</span><span class="s2">\n  </span><span class="s1">SourceLocation,</span><span class="s2">\n  </span><span class="s1">createPositionWithColumnOffset,</span><span class="s2">\n</span><span class="s1">} from </span><span class="s2">\&quot;</span><span class="s1">../util/location</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import CommentsParser, { type CommentWhitespace } from </span><span class="s2">\&quot;</span><span class="s1">../parser/comments</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type * as N from </span><span class="s2">\&quot;</span><span class="s1">../types</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import * as charCodes from </span><span class="s2">\&quot;</span><span class="s1">charcodes</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import { isIdentifierStart, isIdentifierChar } from </span><span class="s2">\&quot;</span><span class="s1">../util/identifier</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import {</span><span class="s2">\n  </span><span class="s1">tokenIsKeyword,</span><span class="s2">\n  </span><span class="s1">tokenLabelName,</span><span class="s2">\n  </span><span class="s1">tt,</span><span class="s2">\n  </span><span class="s1">keywords as keywordTypes,</span><span class="s2">\n  </span><span class="s1">type TokenType,</span><span class="s2">\n</span><span class="s1">} from </span><span class="s2">\&quot;</span><span class="s1">./types</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import { type TokContext } from </span><span class="s2">\&quot;</span><span class="s1">./context</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import {</span><span class="s2">\n  </span><span class="s1">Errors,</span><span class="s2">\n  </span><span class="s1">type ParseError,</span><span class="s2">\n  </span><span class="s1">type ParseErrorConstructor,</span><span class="s2">\n  </span><span class="s1">type RaiseProperties,</span><span class="s2">\n</span><span class="s1">} from </span><span class="s2">\&quot;</span><span class="s1">../parse-error</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import {</span><span class="s2">\n  </span><span class="s1">lineBreakG,</span><span class="s2">\n  </span><span class="s1">isNewLine,</span><span class="s2">\n  </span><span class="s1">isWhitespace,</span><span class="s2">\n  </span><span class="s1">skipWhiteSpace,</span><span class="s2">\n  </span><span class="s1">skipWhiteSpaceInLine,</span><span class="s2">\n</span><span class="s1">} from </span><span class="s2">\&quot;</span><span class="s1">../util/whitespace</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import State from </span><span class="s2">\&quot;</span><span class="s1">./state</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type { LookaheadState, DeferredStrictError } from </span><span class="s2">\&quot;</span><span class="s1">./state</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">import {</span><span class="s2">\n  </span><span class="s1">readInt,</span><span class="s2">\n  </span><span class="s1">readCodePoint,</span><span class="s2">\n  </span><span class="s1">readStringContents,</span><span class="s2">\n  </span><span class="s1">type IntErrorHandlers,</span><span class="s2">\n  </span><span class="s1">type CodePointErrorHandlers,</span><span class="s2">\n  </span><span class="s1">type StringContentsErrorHandlers,</span><span class="s2">\n</span><span class="s1">} from </span><span class="s2">\&quot;</span><span class="s1">@babel/helper-string-parser</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">import type { Plugin } from </span><span class="s2">\&quot;</span><span class="s1">../typings</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">function buildPosition(pos: number, lineStart: number, curLine: number) {</span><span class="s2">\n  </span><span class="s1">return new Position(curLine, pos - lineStart, pos);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">const VALID_REGEX_FLAGS = new Set([</span><span class="s2">\n  </span><span class="s1">charCodes.lowercaseG,</span><span class="s2">\n  </span><span class="s1">charCodes.lowercaseM,</span><span class="s2">\n  </span><span class="s1">charCodes.lowercaseS,</span><span class="s2">\n  </span><span class="s1">charCodes.lowercaseI,</span><span class="s2">\n  </span><span class="s1">charCodes.lowercaseY,</span><span class="s2">\n  </span><span class="s1">charCodes.lowercaseU,</span><span class="s2">\n  </span><span class="s1">charCodes.lowercaseD,</span><span class="s2">\n  </span><span class="s1">// This is only valid when using the regexpUnicodeSets plugin</span><span class="s2">\n  </span><span class="s1">charCodes.lowercaseV,</span><span class="s2">\n</span><span class="s1">]);</span><span class="s2">\n\n</span><span class="s1">// Object type used to represent tokens. Note that normally, tokens</span><span class="s2">\n</span><span class="s1">// simply exist as properties on the parser object. This is only</span><span class="s2">\n</span><span class="s1">// used for the onToken callback and the external tokenizer.</span><span class="s2">\n\n</span><span class="s1">export class Token {</span><span class="s2">\n  </span><span class="s1">constructor(state: State) {</span><span class="s2">\n    </span><span class="s1">this.type = state.type;</span><span class="s2">\n    </span><span class="s1">this.value = state.value;</span><span class="s2">\n    </span><span class="s1">this.start = state.start;</span><span class="s2">\n    </span><span class="s1">this.end = state.end;</span><span class="s2">\n    </span><span class="s1">this.loc = new SourceLocation(state.startLoc, state.endLoc);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">declare type: TokenType;</span><span class="s2">\n  </span><span class="s1">declare value: any;</span><span class="s2">\n  </span><span class="s1">declare start: number;</span><span class="s2">\n  </span><span class="s1">declare end: number;</span><span class="s2">\n  </span><span class="s1">declare loc: SourceLocation;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// ## Tokenizer</span><span class="s2">\n\n</span><span class="s1">export default abstract class Tokenizer extends CommentsParser {</span><span class="s2">\n  </span><span class="s1">isLookahead: boolean;</span><span class="s2">\n\n  </span><span class="s1">// Token store.</span><span class="s2">\n  </span><span class="s1">tokens: Array&lt;Token | N.Comment&gt; = [];</span><span class="s2">\n\n  </span><span class="s1">constructor(options: Options, input: string) {</span><span class="s2">\n    </span><span class="s1">super();</span><span class="s2">\n    </span><span class="s1">this.state = new State();</span><span class="s2">\n    </span><span class="s1">this.state.init(options);</span><span class="s2">\n    </span><span class="s1">this.input = input;</span><span class="s2">\n    </span><span class="s1">this.length = input.length;</span><span class="s2">\n    </span><span class="s1">this.isLookahead = false;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">pushToken(token: Token | N.Comment) {</span><span class="s2">\n    </span><span class="s1">// Pop out invalid tokens trapped by try-catch parsing.</span><span class="s2">\n    </span><span class="s1">// Those parsing branches are mainly created by typescript and flow plugins.</span><span class="s2">\n    </span><span class="s1">this.tokens.length = this.state.tokensLength;</span><span class="s2">\n    </span><span class="s1">this.tokens.push(token);</span><span class="s2">\n    </span><span class="s1">++this.state.tokensLength;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Move to the next token</span><span class="s2">\n\n  </span><span class="s1">next(): void {</span><span class="s2">\n    </span><span class="s1">this.checkKeywordEscapes();</span><span class="s2">\n    </span><span class="s1">if (this.options.tokens) {</span><span class="s2">\n      </span><span class="s1">this.pushToken(new Token(this.state));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">this.state.lastTokStart = this.state.start;</span><span class="s2">\n    </span><span class="s1">this.state.lastTokEndLoc = this.state.endLoc;</span><span class="s2">\n    </span><span class="s1">this.state.lastTokStartLoc = this.state.startLoc;</span><span class="s2">\n    </span><span class="s1">this.nextToken();</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">eat(type: TokenType): boolean {</span><span class="s2">\n    </span><span class="s1">if (this.match(type)) {</span><span class="s2">\n      </span><span class="s1">this.next();</span><span class="s2">\n      </span><span class="s1">return true;</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">return false;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* Whether current token matches given type</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">match(type: TokenType): boolean {</span><span class="s2">\n    </span><span class="s1">return this.state.type === type;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* Create a LookaheadState from current parser state</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">createLookaheadState(state: State): LookaheadState {</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n      </span><span class="s1">pos: state.pos,</span><span class="s2">\n      </span><span class="s1">value: null,</span><span class="s2">\n      </span><span class="s1">type: state.type,</span><span class="s2">\n      </span><span class="s1">start: state.start,</span><span class="s2">\n      </span><span class="s1">end: state.end,</span><span class="s2">\n      </span><span class="s1">context: [this.curContext()],</span><span class="s2">\n      </span><span class="s1">inType: state.inType,</span><span class="s2">\n      </span><span class="s1">startLoc: state.startLoc,</span><span class="s2">\n      </span><span class="s1">lastTokEndLoc: state.lastTokEndLoc,</span><span class="s2">\n      </span><span class="s1">curLine: state.curLine,</span><span class="s2">\n      </span><span class="s1">lineStart: state.lineStart,</span><span class="s2">\n      </span><span class="s1">curPosition: state.curPosition,</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* lookahead peeks the next token, skipping changes to token context and</span><span class="s2">\n   </span><span class="s1">* comment stack. For performance it returns a limited LookaheadState</span><span class="s2">\n   </span><span class="s1">* instead of full parser state.</span><span class="s2">\n   </span><span class="s1">*</span><span class="s2">\n   </span><span class="s1">* The { column, line } Loc info is not included in lookahead since such usage</span><span class="s2">\n   </span><span class="s1">* is rare. Although it may return other location properties e.g. `curLine` and</span><span class="s2">\n   </span><span class="s1">* `lineStart`, these properties are not listed in the LookaheadState interface</span><span class="s2">\n   </span><span class="s1">* and thus the returned value is _NOT_ reliable.</span><span class="s2">\n   </span><span class="s1">*</span><span class="s2">\n   </span><span class="s1">* The tokenizer should make best efforts to avoid using any parser state</span><span class="s2">\n   </span><span class="s1">* other than those defined in LookaheadState</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">lookahead(): LookaheadState {</span><span class="s2">\n    </span><span class="s1">const old = this.state;</span><span class="s2">\n    </span><span class="s1">// @ts-expect-error For performance we use a simplified tokenizer state structure</span><span class="s2">\n    </span><span class="s1">this.state = this.createLookaheadState(old);</span><span class="s2">\n\n    </span><span class="s1">this.isLookahead = true;</span><span class="s2">\n    </span><span class="s1">this.nextToken();</span><span class="s2">\n    </span><span class="s1">this.isLookahead = false;</span><span class="s2">\n\n    </span><span class="s1">const curr = this.state;</span><span class="s2">\n    </span><span class="s1">this.state = old;</span><span class="s2">\n    </span><span class="s1">return curr;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">nextTokenStart(): number {</span><span class="s2">\n    </span><span class="s1">return this.nextTokenStartSince(this.state.pos);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">nextTokenStartSince(pos: number): number {</span><span class="s2">\n    </span><span class="s1">skipWhiteSpace.lastIndex = pos;</span><span class="s2">\n    </span><span class="s1">return skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">lookaheadCharCode(): number {</span><span class="s2">\n    </span><span class="s1">return this.input.charCodeAt(this.nextTokenStart());</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* Similar to nextToken, but it will stop at line break when it is seen before the next token</span><span class="s2">\n   </span><span class="s1">*</span><span class="s2">\n   </span><span class="s1">* @returns {number} position of the next token start or line break, whichever is seen first.</span><span class="s2">\n   </span><span class="s1">* @memberof Tokenizer</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">nextTokenInLineStart(): number {</span><span class="s2">\n    </span><span class="s1">return this.nextTokenInLineStartSince(this.state.pos);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">nextTokenInLineStartSince(pos: number): number {</span><span class="s2">\n    </span><span class="s1">skipWhiteSpaceInLine.lastIndex = pos;</span><span class="s2">\n    </span><span class="s1">return skipWhiteSpaceInLine.test(this.input)</span><span class="s2">\n      </span><span class="s1">? skipWhiteSpaceInLine.lastIndex</span><span class="s2">\n      </span><span class="s1">: pos;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* Similar to lookaheadCharCode, but it will return the char code of line break if it is</span><span class="s2">\n   </span><span class="s1">* seen before the next token</span><span class="s2">\n   </span><span class="s1">*</span><span class="s2">\n   </span><span class="s1">* @returns {number} char code of the next token start or line break, whichever is seen first.</span><span class="s2">\n   </span><span class="s1">* @memberof Tokenizer</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">lookaheadInLineCharCode(): number {</span><span class="s2">\n    </span><span class="s1">return this.input.charCodeAt(this.nextTokenInLineStart());</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">codePointAtPos(pos: number): number {</span><span class="s2">\n    </span><span class="s1">// The implementation is based on</span><span class="s2">\n    </span><span class="s1">// https://source.chromium.org/chromium/chromium/src/+/master:v8/src/builtins/builtins-string-gen.cc;l=1455;drc=221e331b49dfefadbc6fa40b0c68e6f97606d0b3;bpv=0;bpt=1</span><span class="s2">\n    </span><span class="s1">// We reimplement `codePointAt` because `codePointAt` is a V8 builtin which is not inlined by TurboFan (as of M91)</span><span class="s2">\n    </span><span class="s1">// since `input` is mostly ASCII, an inlined `charCodeAt` wins here</span><span class="s2">\n    </span><span class="s1">let cp = this.input.charCodeAt(pos);</span><span class="s2">\n    </span><span class="s1">if ((cp &amp; 0xfc00) === 0xd800 &amp;&amp; ++pos &lt; this.input.length) {</span><span class="s2">\n      </span><span class="s1">const trail = this.input.charCodeAt(pos);</span><span class="s2">\n      </span><span class="s1">if ((trail &amp; 0xfc00) === 0xdc00) {</span><span class="s2">\n        </span><span class="s1">cp = 0x10000 + ((cp &amp; 0x3ff) &lt;&lt; 10) + (trail &amp; 0x3ff);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return cp;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Toggle strict mode. Re-reads the next number or string to please</span><span class="s2">\n  </span><span class="s1">// pedantic tests (`</span><span class="s2">\&quot;</span><span class="s1">use strict</span><span class="s2">\&quot;</span><span class="s1">; 010;` should fail).</span><span class="s2">\n\n  </span><span class="s1">setStrict(strict: boolean): void {</span><span class="s2">\n    </span><span class="s1">this.state.strict = strict;</span><span class="s2">\n    </span><span class="s1">if (strict) {</span><span class="s2">\n      </span><span class="s1">// Throw an error for any string decimal escape found before/immediately</span><span class="s2">\n      </span><span class="s1">// after a </span><span class="s2">\&quot;</span><span class="s1">use strict</span><span class="s2">\&quot; </span><span class="s1">directive. Strict mode will be set at parse</span><span class="s2">\n      </span><span class="s1">// time for any literals that occur after the next node of the strict</span><span class="s2">\n      </span><span class="s1">// directive.</span><span class="s2">\n      </span><span class="s1">this.state.strictErrors.forEach(([toParseError, at]) =&gt;</span><span class="s2">\n        </span><span class="s1">this.raise(toParseError, { at }),</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">this.state.strictErrors.clear();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">curContext(): TokContext {</span><span class="s2">\n    </span><span class="s1">return this.state.context[this.state.context.length - 1];</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Read a single token, updating the parser object's token-related properties.</span><span class="s2">\n  </span><span class="s1">nextToken(): void {</span><span class="s2">\n    </span><span class="s1">this.skipSpace();</span><span class="s2">\n    </span><span class="s1">this.state.start = this.state.pos;</span><span class="s2">\n    </span><span class="s1">if (!this.isLookahead) this.state.startLoc = this.state.curPosition();</span><span class="s2">\n    </span><span class="s1">if (this.state.pos &gt;= this.length) {</span><span class="s2">\n      </span><span class="s1">this.finishToken(tt.eof);</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">this.getTokenFromCode(this.codePointAtPos(this.state.pos));</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Skips a block comment, whose end is marked by commentEnd.</span><span class="s2">\n  </span><span class="s1">// *-/ is used by the Flow plugin, when parsing block comments nested</span><span class="s2">\n  </span><span class="s1">// inside Flow comments.</span><span class="s2">\n  </span><span class="s1">skipBlockComment(commentEnd: </span><span class="s2">\&quot;</span><span class="s1">*/</span><span class="s2">\&quot; </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">*-/</span><span class="s2">\&quot;</span><span class="s1">): N.CommentBlock | undefined {</span><span class="s2">\n    </span><span class="s1">let startLoc;</span><span class="s2">\n    </span><span class="s1">if (!this.isLookahead) startLoc = this.state.curPosition();</span><span class="s2">\n    </span><span class="s1">const start = this.state.pos;</span><span class="s2">\n    </span><span class="s1">const end = this.input.indexOf(commentEnd, start + 2);</span><span class="s2">\n    </span><span class="s1">if (end === -1) {</span><span class="s2">\n      </span><span class="s1">// We have to call this again here because startLoc may not be set...</span><span class="s2">\n      </span><span class="s1">// This seems to be for performance reasons:</span><span class="s2">\n      </span><span class="s1">// https://github.com/babel/babel/commit/acf2a10899f696a8aaf34df78bf9725b5ea7f2da</span><span class="s2">\n      </span><span class="s1">throw this.raise(Errors.UnterminatedComment, {</span><span class="s2">\n        </span><span class="s1">at: this.state.curPosition(),</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">this.state.pos = end + commentEnd.length;</span><span class="s2">\n    </span><span class="s1">lineBreakG.lastIndex = start + 2;</span><span class="s2">\n    </span><span class="s1">while (lineBreakG.test(this.input) &amp;&amp; lineBreakG.lastIndex &lt;= end) {</span><span class="s2">\n      </span><span class="s1">++this.state.curLine;</span><span class="s2">\n      </span><span class="s1">this.state.lineStart = lineBreakG.lastIndex;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// If we are doing a lookahead right now we need to advance the position (above code)</span><span class="s2">\n    </span><span class="s1">// but we do not want to push the comment to the state.</span><span class="s2">\n    </span><span class="s1">if (this.isLookahead) return;</span><span class="s2">\n    </span><span class="s1">/*:: invariant(startLoc) */</span><span class="s2">\n\n    </span><span class="s1">const comment: N.CommentBlock = {</span><span class="s2">\n      </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">CommentBlock</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">value: this.input.slice(start + 2, end),</span><span class="s2">\n      </span><span class="s1">start,</span><span class="s2">\n      </span><span class="s1">end: end + commentEnd.length,</span><span class="s2">\n      </span><span class="s1">loc: new SourceLocation(startLoc, this.state.curPosition()),</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">if (this.options.tokens) this.pushToken(comment);</span><span class="s2">\n    </span><span class="s1">return comment;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">skipLineComment(startSkip: number): N.CommentLine | undefined {</span><span class="s2">\n    </span><span class="s1">const start = this.state.pos;</span><span class="s2">\n    </span><span class="s1">let startLoc;</span><span class="s2">\n    </span><span class="s1">if (!this.isLookahead) startLoc = this.state.curPosition();</span><span class="s2">\n    </span><span class="s1">let ch = this.input.charCodeAt((this.state.pos += startSkip));</span><span class="s2">\n    </span><span class="s1">if (this.state.pos &lt; this.length) {</span><span class="s2">\n      </span><span class="s1">while (!isNewLine(ch) &amp;&amp; ++this.state.pos &lt; this.length) {</span><span class="s2">\n        </span><span class="s1">ch = this.input.charCodeAt(this.state.pos);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// If we are doing a lookahead right now we need to advance the position (above code)</span><span class="s2">\n    </span><span class="s1">// but we do not want to push the comment to the state.</span><span class="s2">\n    </span><span class="s1">if (this.isLookahead) return;</span><span class="s2">\n    </span><span class="s1">/*:: invariant(startLoc) */</span><span class="s2">\n\n    </span><span class="s1">const end = this.state.pos;</span><span class="s2">\n    </span><span class="s1">const value = this.input.slice(start + startSkip, end);</span><span class="s2">\n\n    </span><span class="s1">const comment: N.CommentLine = {</span><span class="s2">\n      </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">CommentLine</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">value,</span><span class="s2">\n      </span><span class="s1">start,</span><span class="s2">\n      </span><span class="s1">end,</span><span class="s2">\n      </span><span class="s1">loc: new SourceLocation(startLoc, this.state.curPosition()),</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">if (this.options.tokens) this.pushToken(comment);</span><span class="s2">\n    </span><span class="s1">return comment;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Called at the start of the parse and after every token. Skips</span><span class="s2">\n  </span><span class="s1">// whitespace and comments, and.</span><span class="s2">\n\n  </span><span class="s1">skipSpace(): void {</span><span class="s2">\n    </span><span class="s1">const spaceStart = this.state.pos;</span><span class="s2">\n    </span><span class="s1">const comments = [];</span><span class="s2">\n    </span><span class="s1">loop: while (this.state.pos &lt; this.length) {</span><span class="s2">\n      </span><span class="s1">const ch = this.input.charCodeAt(this.state.pos);</span><span class="s2">\n      </span><span class="s1">switch (ch) {</span><span class="s2">\n        </span><span class="s1">case charCodes.space:</span><span class="s2">\n        </span><span class="s1">case charCodes.nonBreakingSpace:</span><span class="s2">\n        </span><span class="s1">case charCodes.tab:</span><span class="s2">\n          </span><span class="s1">++this.state.pos;</span><span class="s2">\n          </span><span class="s1">break;</span><span class="s2">\n        </span><span class="s1">case charCodes.carriageReturn:</span><span class="s2">\n          </span><span class="s1">if (</span><span class="s2">\n            </span><span class="s1">this.input.charCodeAt(this.state.pos + 1) === charCodes.lineFeed</span><span class="s2">\n          </span><span class="s1">) {</span><span class="s2">\n            </span><span class="s1">++this.state.pos;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// fall through</span><span class="s2">\n        </span><span class="s1">case charCodes.lineFeed:</span><span class="s2">\n        </span><span class="s1">case charCodes.lineSeparator:</span><span class="s2">\n        </span><span class="s1">case charCodes.paragraphSeparator:</span><span class="s2">\n          </span><span class="s1">++this.state.pos;</span><span class="s2">\n          </span><span class="s1">++this.state.curLine;</span><span class="s2">\n          </span><span class="s1">this.state.lineStart = this.state.pos;</span><span class="s2">\n          </span><span class="s1">break;</span><span class="s2">\n\n        </span><span class="s1">case charCodes.slash:</span><span class="s2">\n          </span><span class="s1">switch (this.input.charCodeAt(this.state.pos + 1)) {</span><span class="s2">\n            </span><span class="s1">case charCodes.asterisk: {</span><span class="s2">\n              </span><span class="s1">const comment = this.skipBlockComment(</span><span class="s2">\&quot;</span><span class="s1">*/</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n              </span><span class="s1">if (comment !== undefined) {</span><span class="s2">\n                </span><span class="s1">this.addComment(comment);</span><span class="s2">\n                </span><span class="s1">if (this.options.attachComment) comments.push(comment);</span><span class="s2">\n              </span><span class="s1">}</span><span class="s2">\n              </span><span class="s1">break;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n\n            </span><span class="s1">case charCodes.slash: {</span><span class="s2">\n              </span><span class="s1">const comment = this.skipLineComment(2);</span><span class="s2">\n              </span><span class="s1">if (comment !== undefined) {</span><span class="s2">\n                </span><span class="s1">this.addComment(comment);</span><span class="s2">\n                </span><span class="s1">if (this.options.attachComment) comments.push(comment);</span><span class="s2">\n              </span><span class="s1">}</span><span class="s2">\n              </span><span class="s1">break;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n\n            </span><span class="s1">default:</span><span class="s2">\n              </span><span class="s1">break loop;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">break;</span><span class="s2">\n\n        </span><span class="s1">default:</span><span class="s2">\n          </span><span class="s1">if (isWhitespace(ch)) {</span><span class="s2">\n            </span><span class="s1">++this.state.pos;</span><span class="s2">\n          </span><span class="s1">} else if (</span><span class="s2">\n            </span><span class="s1">ch === charCodes.dash &amp;&amp;</span><span class="s2">\n            </span><span class="s1">!this.inModule &amp;&amp;</span><span class="s2">\n            </span><span class="s1">this.options.annexB</span><span class="s2">\n          </span><span class="s1">) {</span><span class="s2">\n            </span><span class="s1">const pos = this.state.pos;</span><span class="s2">\n            </span><span class="s1">if (</span><span class="s2">\n              </span><span class="s1">this.input.charCodeAt(pos + 1) === charCodes.dash &amp;&amp;</span><span class="s2">\n              </span><span class="s1">this.input.charCodeAt(pos + 2) === charCodes.greaterThan &amp;&amp;</span><span class="s2">\n              </span><span class="s1">(spaceStart === 0 || this.state.lineStart &gt; spaceStart)</span><span class="s2">\n            </span><span class="s1">) {</span><span class="s2">\n              </span><span class="s1">// A `--&gt;` line comment</span><span class="s2">\n              </span><span class="s1">const comment = this.skipLineComment(3);</span><span class="s2">\n              </span><span class="s1">if (comment !== undefined) {</span><span class="s2">\n                </span><span class="s1">this.addComment(comment);</span><span class="s2">\n                </span><span class="s1">if (this.options.attachComment) comments.push(comment);</span><span class="s2">\n              </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">} else {</span><span class="s2">\n              </span><span class="s1">break loop;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">} else if (</span><span class="s2">\n            </span><span class="s1">ch === charCodes.lessThan &amp;&amp;</span><span class="s2">\n            </span><span class="s1">!this.inModule &amp;&amp;</span><span class="s2">\n            </span><span class="s1">this.options.annexB</span><span class="s2">\n          </span><span class="s1">) {</span><span class="s2">\n            </span><span class="s1">const pos = this.state.pos;</span><span class="s2">\n            </span><span class="s1">if (</span><span class="s2">\n              </span><span class="s1">this.input.charCodeAt(pos + 1) === charCodes.exclamationMark &amp;&amp;</span><span class="s2">\n              </span><span class="s1">this.input.charCodeAt(pos + 2) === charCodes.dash &amp;&amp;</span><span class="s2">\n              </span><span class="s1">this.input.charCodeAt(pos + 3) === charCodes.dash</span><span class="s2">\n            </span><span class="s1">) {</span><span class="s2">\n              </span><span class="s1">// `&lt;!--`, an XML-style comment that should be interpreted as a line comment</span><span class="s2">\n              </span><span class="s1">const comment = this.skipLineComment(4);</span><span class="s2">\n              </span><span class="s1">if (comment !== undefined) {</span><span class="s2">\n                </span><span class="s1">this.addComment(comment);</span><span class="s2">\n                </span><span class="s1">if (this.options.attachComment) comments.push(comment);</span><span class="s2">\n              </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">} else {</span><span class="s2">\n              </span><span class="s1">break loop;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">} else {</span><span class="s2">\n            </span><span class="s1">break loop;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">if (comments.length &gt; 0) {</span><span class="s2">\n      </span><span class="s1">const end = this.state.pos;</span><span class="s2">\n      </span><span class="s1">const commentWhitespace: CommentWhitespace = {</span><span class="s2">\n        </span><span class="s1">start: spaceStart,</span><span class="s2">\n        </span><span class="s1">end,</span><span class="s2">\n        </span><span class="s1">comments,</span><span class="s2">\n        </span><span class="s1">leadingNode: null,</span><span class="s2">\n        </span><span class="s1">trailingNode: null,</span><span class="s2">\n        </span><span class="s1">containingNode: null,</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">this.state.commentStack.push(commentWhitespace);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Called at the end of every token. Sets `end`, `val`, and</span><span class="s2">\n  </span><span class="s1">// maintains `context` and `canStartJSXElement`, and skips the space after</span><span class="s2">\n  </span><span class="s1">// the token, so that the next one's `start` will point at the</span><span class="s2">\n  </span><span class="s1">// right position.</span><span class="s2">\n\n  </span><span class="s1">finishToken(type: TokenType, val?: any): void {</span><span class="s2">\n    </span><span class="s1">this.state.end = this.state.pos;</span><span class="s2">\n    </span><span class="s1">this.state.endLoc = this.state.curPosition();</span><span class="s2">\n    </span><span class="s1">const prevType = this.state.type;</span><span class="s2">\n    </span><span class="s1">this.state.type = type;</span><span class="s2">\n    </span><span class="s1">this.state.value = val;</span><span class="s2">\n\n    </span><span class="s1">if (!this.isLookahead) {</span><span class="s2">\n      </span><span class="s1">this.updateContext(prevType);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">replaceToken(type: TokenType): void {</span><span class="s2">\n    </span><span class="s1">this.state.type = type;</span><span class="s2">\n    </span><span class="s1">// @ts-expect-error the prevType of updateContext is required</span><span class="s2">\n    </span><span class="s1">// only when the new type is tt.slash/tt.jsxTagEnd</span><span class="s2">\n    </span><span class="s1">this.updateContext();</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// ### Token reading</span><span class="s2">\n\n  </span><span class="s1">// This is the function that is called to fetch the next token. It</span><span class="s2">\n  </span><span class="s1">// is somewhat obscure, because it works in character codes rather</span><span class="s2">\n  </span><span class="s1">// than characters, and because operator parsing has been inlined</span><span class="s2">\n  </span><span class="s1">// into it.</span><span class="s2">\n  </span><span class="s1">//</span><span class="s2">\n  </span><span class="s1">// All in the name of speed.</span><span class="s2">\n\n  </span><span class="s1">// number sign is </span><span class="s2">\&quot;</span><span class="s1">#</span><span class="s2">\&quot;\n  </span><span class="s1">readToken_numberSign(): void {</span><span class="s2">\n    </span><span class="s1">if (this.state.pos === 0 &amp;&amp; this.readToken_interpreter()) {</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">const nextPos = this.state.pos + 1;</span><span class="s2">\n    </span><span class="s1">const next = this.codePointAtPos(nextPos);</span><span class="s2">\n    </span><span class="s1">if (next &gt;= charCodes.digit0 &amp;&amp; next &lt;= charCodes.digit9) {</span><span class="s2">\n      </span><span class="s1">throw this.raise(Errors.UnexpectedDigitAfterHash, {</span><span class="s2">\n        </span><span class="s1">at: this.state.curPosition(),</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">if (</span><span class="s2">\n      </span><span class="s1">next === charCodes.leftCurlyBrace ||</span><span class="s2">\n      </span><span class="s1">(next === charCodes.leftSquareBracket &amp;&amp; this.hasPlugin(</span><span class="s2">\&quot;</span><span class="s1">recordAndTuple</span><span class="s2">\&quot;</span><span class="s1">))</span><span class="s2">\n    </span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">// When we see `#{`, it is likely to be a hash record.</span><span class="s2">\n      </span><span class="s1">// However we don't yell at `#[` since users may intend to use </span><span class="s2">\&quot;</span><span class="s1">computed private fields</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">// which is not allowed in the spec. Throwing expecting recordAndTuple is</span><span class="s2">\n      </span><span class="s1">// misleading</span><span class="s2">\n      </span><span class="s1">this.expectPlugin(</span><span class="s2">\&quot;</span><span class="s1">recordAndTuple</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">if (this.getPluginOption(</span><span class="s2">\&quot;</span><span class="s1">recordAndTuple</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">syntaxType</span><span class="s2">\&quot;</span><span class="s1">) === </span><span class="s2">\&quot;</span><span class="s1">bar</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">throw this.raise(</span><span class="s2">\n          </span><span class="s1">next === charCodes.leftCurlyBrace</span><span class="s2">\n            </span><span class="s1">? Errors.RecordExpressionHashIncorrectStartSyntaxType</span><span class="s2">\n            </span><span class="s1">: Errors.TupleExpressionHashIncorrectStartSyntaxType,</span><span class="s2">\n          </span><span class="s1">{ at: this.state.curPosition() },</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">this.state.pos += 2;</span><span class="s2">\n      </span><span class="s1">if (next === charCodes.leftCurlyBrace) {</span><span class="s2">\n        </span><span class="s1">// #{</span><span class="s2">\n        </span><span class="s1">this.finishToken(tt.braceHashL);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">// #[</span><span class="s2">\n        </span><span class="s1">this.finishToken(tt.bracketHashL);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else if (isIdentifierStart(next)) {</span><span class="s2">\n      </span><span class="s1">++this.state.pos;</span><span class="s2">\n      </span><span class="s1">this.finishToken(tt.privateName, this.readWord1(next));</span><span class="s2">\n    </span><span class="s1">} else if (next === charCodes.backslash) {</span><span class="s2">\n      </span><span class="s1">++this.state.pos;</span><span class="s2">\n      </span><span class="s1">this.finishToken(tt.privateName, this.readWord1());</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">this.finishOp(tt.hash, 1);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">readToken_dot(): void {</span><span class="s2">\n    </span><span class="s1">const next = this.input.charCodeAt(this.state.pos + 1);</span><span class="s2">\n    </span><span class="s1">if (next &gt;= charCodes.digit0 &amp;&amp; next &lt;= charCodes.digit9) {</span><span class="s2">\n      </span><span class="s1">this.readNumber(true);</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">if (</span><span class="s2">\n      </span><span class="s1">next === charCodes.dot &amp;&amp;</span><span class="s2">\n      </span><span class="s1">this.input.charCodeAt(this.state.pos + 2) === charCodes.dot</span><span class="s2">\n    </span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">this.state.pos += 3;</span><span class="s2">\n      </span><span class="s1">this.finishToken(tt.ellipsis);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">++this.state.pos;</span><span class="s2">\n      </span><span class="s1">this.finishToken(tt.dot);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">readToken_slash(): void {</span><span class="s2">\n    </span><span class="s1">const next = this.input.charCodeAt(this.state.pos + 1);</span><span class="s2">\n    </span><span class="s1">if (next === charCodes.equalsTo) {</span><span class="s2">\n      </span><span class="s1">this.finishOp(tt.slashAssign, 2);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">this.finishOp(tt.slash, 1);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">readToken_interpreter(): boolean {</span><span class="s2">\n    </span><span class="s1">if (this.state.pos !== 0 || this.length &lt; 2) return false;</span><span class="s2">\n\n    </span><span class="s1">let ch = this.input.charCodeAt(this.state.pos + 1);</span><span class="s2">\n    </span><span class="s1">if (ch !== charCodes.exclamationMark) return false;</span><span class="s2">\n\n    </span><span class="s1">const start = this.state.pos;</span><span class="s2">\n    </span><span class="s1">this.state.pos += 1;</span><span class="s2">\n\n    </span><span class="s1">while (!isNewLine(ch) &amp;&amp; ++this.state.pos &lt; this.length) {</span><span class="s2">\n      </span><span class="s1">ch = this.input.charCodeAt(this.state.pos);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">const value = this.input.slice(start + 2, this.state.pos);</span><span class="s2">\n\n    </span><span class="s1">this.finishToken(tt.interpreterDirective, value);</span><span class="s2">\n\n    </span><span class="s1">return true;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">readToken_mult_modulo(code: number): void {</span><span class="s2">\n    </span><span class="s1">// '%' or '*'</span><span class="s2">\n    </span><span class="s1">let type = code === charCodes.asterisk ? tt.star : tt.modulo;</span><span class="s2">\n    </span><span class="s1">let width = 1;</span><span class="s2">\n    </span><span class="s1">let next = this.input.charCodeAt(this.state.pos + 1);</span><span class="s2">\n\n    </span><span class="s1">// Exponentiation operator '**'</span><span class="s2">\n    </span><span class="s1">if (code === charCodes.asterisk &amp;&amp; next === charCodes.asterisk) {</span><span class="s2">\n      </span><span class="s1">width++;</span><span class="s2">\n      </span><span class="s1">next = this.input.charCodeAt(this.state.pos + 2);</span><span class="s2">\n      </span><span class="s1">type = tt.exponent;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// '%=' or '*='</span><span class="s2">\n    </span><span class="s1">if (next === charCodes.equalsTo &amp;&amp; !this.state.inType) {</span><span class="s2">\n      </span><span class="s1">width++;</span><span class="s2">\n      </span><span class="s1">// `tt.moduloAssign` is only needed to support % as a Hack-pipe topic token.</span><span class="s2">\n      </span><span class="s1">// If the proposal ends up choosing a different token,</span><span class="s2">\n      </span><span class="s1">// it can be merged with tt.assign.</span><span class="s2">\n      </span><span class="s1">type = code === charCodes.percentSign ? tt.moduloAssign : tt.assign;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">this.finishOp(type, width);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">readToken_pipe_amp(code: number): void {</span><span class="s2">\n    </span><span class="s1">// '||' '&amp;&amp;' '||=' '&amp;&amp;='</span><span class="s2">\n    </span><span class="s1">const next = this.input.charCodeAt(this.state.pos + 1);</span><span class="s2">\n\n    </span><span class="s1">if (next === code) {</span><span class="s2">\n      </span><span class="s1">if (this.input.charCodeAt(this.state.pos + 2) === charCodes.equalsTo) {</span><span class="s2">\n        </span><span class="s1">this.finishOp(tt.assign, 3);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">this.finishOp(</span><span class="s2">\n          </span><span class="s1">code === charCodes.verticalBar ? tt.logicalOR : tt.logicalAND,</span><span class="s2">\n          </span><span class="s1">2,</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">if (code === charCodes.verticalBar) {</span><span class="s2">\n      </span><span class="s1">// '|&gt;'</span><span class="s2">\n      </span><span class="s1">if (next === charCodes.greaterThan) {</span><span class="s2">\n        </span><span class="s1">this.finishOp(tt.pipeline, 2);</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">// '|}'</span><span class="s2">\n      </span><span class="s1">if (</span><span class="s2">\n        </span><span class="s1">this.hasPlugin(</span><span class="s2">\&quot;</span><span class="s1">recordAndTuple</span><span class="s2">\&quot;</span><span class="s1">) &amp;&amp;</span><span class="s2">\n        </span><span class="s1">next === charCodes.rightCurlyBrace</span><span class="s2">\n      </span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">if (this.getPluginOption(</span><span class="s2">\&quot;</span><span class="s1">recordAndTuple</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">syntaxType</span><span class="s2">\&quot;</span><span class="s1">) !== </span><span class="s2">\&quot;</span><span class="s1">bar</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">throw this.raise(Errors.RecordExpressionBarIncorrectEndSyntaxType, {</span><span class="s2">\n            </span><span class="s1">at: this.state.curPosition(),</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">this.state.pos += 2;</span><span class="s2">\n        </span><span class="s1">this.finishToken(tt.braceBarR);</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">// '|]'</span><span class="s2">\n      </span><span class="s1">if (</span><span class="s2">\n        </span><span class="s1">this.hasPlugin(</span><span class="s2">\&quot;</span><span class="s1">recordAndTuple</span><span class="s2">\&quot;</span><span class="s1">) &amp;&amp;</span><span class="s2">\n        </span><span class="s1">next === charCodes.rightSquareBracket</span><span class="s2">\n      </span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">if (this.getPluginOption(</span><span class="s2">\&quot;</span><span class="s1">recordAndTuple</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">syntaxType</span><span class="s2">\&quot;</span><span class="s1">) !== </span><span class="s2">\&quot;</span><span class="s1">bar</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">throw this.raise(Errors.TupleExpressionBarIncorrectEndSyntaxType, {</span><span class="s2">\n            </span><span class="s1">at: this.state.curPosition(),</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">this.state.pos += 2;</span><span class="s2">\n        </span><span class="s1">this.finishToken(tt.bracketBarR);</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">if (next === charCodes.equalsTo) {</span><span class="s2">\n      </span><span class="s1">this.finishOp(tt.assign, 2);</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">this.finishOp(</span><span class="s2">\n      </span><span class="s1">code === charCodes.verticalBar ? tt.bitwiseOR : tt.bitwiseAND,</span><span class="s2">\n      </span><span class="s1">1,</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">readToken_caret(): void {</span><span class="s2">\n    </span><span class="s1">const next = this.input.charCodeAt(this.state.pos + 1);</span><span class="s2">\n\n    </span><span class="s1">// '^='</span><span class="s2">\n    </span><span class="s1">if (next === charCodes.equalsTo &amp;&amp; !this.state.inType) {</span><span class="s2">\n      </span><span class="s1">// `tt.xorAssign` is only needed to support ^ as a Hack-pipe topic token.</span><span class="s2">\n      </span><span class="s1">// If the proposal ends up choosing a different token,</span><span class="s2">\n      </span><span class="s1">// it can be merged with tt.assign.</span><span class="s2">\n      </span><span class="s1">this.finishOp(tt.xorAssign, 2);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// '^^'</span><span class="s2">\n    </span><span class="s1">else if (</span><span class="s2">\n      </span><span class="s1">next === charCodes.caret &amp;&amp;</span><span class="s2">\n      </span><span class="s1">// If the ^^ token is not enabled, we don't throw but parse two single ^s</span><span class="s2">\n      </span><span class="s1">// because it could be a ^ hack token followed by a ^ binary operator.</span><span class="s2">\n      </span><span class="s1">this.hasPlugin([</span><span class="s2">\n        \&quot;</span><span class="s1">pipelineOperator</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">{ proposal: </span><span class="s2">\&quot;</span><span class="s1">hack</span><span class="s2">\&quot;</span><span class="s1">, topicToken: </span><span class="s2">\&quot;</span><span class="s1">^^</span><span class="s2">\&quot; </span><span class="s1">},</span><span class="s2">\n      </span><span class="s1">])</span><span class="s2">\n    </span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">this.finishOp(tt.doubleCaret, 2);</span><span class="s2">\n\n      </span><span class="s1">// `^^^` is forbidden and must be separated by a space.</span><span class="s2">\n      </span><span class="s1">const lookaheadCh = this.input.codePointAt(this.state.pos);</span><span class="s2">\n      </span><span class="s1">if (lookaheadCh === charCodes.caret) {</span><span class="s2">\n        </span><span class="s1">this.unexpected();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// '^'</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n      </span><span class="s1">this.finishOp(tt.bitwiseXOR, 1);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">readToken_atSign(): void {</span><span class="s2">\n    </span><span class="s1">const next = this.input.charCodeAt(this.state.pos + 1);</span><span class="s2">\n\n    </span><span class="s1">// '@@'</span><span class="s2">\n    </span><span class="s1">if (</span><span class="s2">\n      </span><span class="s1">next === charCodes.atSign &amp;&amp;</span><span class="s2">\n      </span><span class="s1">this.hasPlugin([</span><span class="s2">\n        \&quot;</span><span class="s1">pipelineOperator</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">{ proposal: </span><span class="s2">\&quot;</span><span class="s1">hack</span><span class="s2">\&quot;</span><span class="s1">, topicToken: </span><span class="s2">\&quot;</span><span class="s1">@@</span><span class="s2">\&quot; </span><span class="s1">},</span><span class="s2">\n      </span><span class="s1">])</span><span class="s2">\n    </span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">this.finishOp(tt.doubleAt, 2);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// '@'</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n      </span><span class="s1">this.finishOp(tt.at, 1);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">readToken_plus_min(code: number): void {</span><span class="s2">\n    </span><span class="s1">// '+-'</span><span class="s2">\n    </span><span class="s1">const next = this.input.charCodeAt(this.state.pos + 1);</span><span class="s2">\n\n    </span><span class="s1">if (next === code) {</span><span class="s2">\n      </span><span class="s1">this.finishOp(tt.incDec, 2);</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">if (next === charCodes.equalsTo) {</span><span class="s2">\n      </span><span class="s1">this.finishOp(tt.assign, 2);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">this.finishOp(tt.plusMin, 1);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">readToken_lt(): void {</span><span class="s2">\n    </span><span class="s1">// '&lt;'</span><span class="s2">\n    </span><span class="s1">const { pos } = this.state;</span><span class="s2">\n    </span><span class="s1">const next = this.input.charCodeAt(pos + 1);</span><span class="s2">\n\n    </span><span class="s1">if (next === charCodes.lessThan) {</span><span class="s2">\n      </span><span class="s1">if (this.input.charCodeAt(pos + 2) === charCodes.equalsTo) {</span><span class="s2">\n        </span><span class="s1">this.finishOp(tt.assign, 3);</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">this.finishOp(tt.bitShiftL, 2);</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">if (next === charCodes.equalsTo) {</span><span class="s2">\n      </span><span class="s1">// &lt;=</span><span class="s2">\n      </span><span class="s1">this.finishOp(tt.relational, 2);</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">this.finishOp(tt.lt, 1);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">readToken_gt(): void {</span><span class="s2">\n    </span><span class="s1">// '&gt;'</span><span class="s2">\n    </span><span class="s1">const { pos } = this.state;</span><span class="s2">\n    </span><span class="s1">const next = this.input.charCodeAt(pos + 1);</span><span class="s2">\n\n    </span><span class="s1">if (next === charCodes.greaterThan) {</span><span class="s2">\n      </span><span class="s1">const size =</span><span class="s2">\n        </span><span class="s1">this.input.charCodeAt(pos + 2) === charCodes.greaterThan ? 3 : 2;</span><span class="s2">\n      </span><span class="s1">if (this.input.charCodeAt(pos + size) === charCodes.equalsTo) {</span><span class="s2">\n        </span><span class="s1">this.finishOp(tt.assign, size + 1);</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">this.finishOp(tt.bitShiftR, size);</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">if (next === charCodes.equalsTo) {</span><span class="s2">\n      </span><span class="s1">// &lt;= | &gt;=</span><span class="s2">\n      </span><span class="s1">this.finishOp(tt.relational, 2);</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">this.finishOp(tt.gt, 1);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">readToken_eq_excl(code: number): void {</span><span class="s2">\n    </span><span class="s1">// '=!'</span><span class="s2">\n    </span><span class="s1">const next = this.input.charCodeAt(this.state.pos + 1);</span><span class="s2">\n    </span><span class="s1">if (next === charCodes.equalsTo) {</span><span class="s2">\n      </span><span class="s1">this.finishOp(</span><span class="s2">\n        </span><span class="s1">tt.equality,</span><span class="s2">\n        </span><span class="s1">this.input.charCodeAt(this.state.pos + 2) === charCodes.equalsTo</span><span class="s2">\n          </span><span class="s1">? 3</span><span class="s2">\n          </span><span class="s1">: 2,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (code === charCodes.equalsTo &amp;&amp; next === charCodes.greaterThan) {</span><span class="s2">\n      </span><span class="s1">// '=&gt;'</span><span class="s2">\n      </span><span class="s1">this.state.pos += 2;</span><span class="s2">\n      </span><span class="s1">this.finishToken(tt.arrow);</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">this.finishOp(code === charCodes.equalsTo ? tt.eq : tt.bang, 1);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">readToken_question(): void {</span><span class="s2">\n    </span><span class="s1">// '?'</span><span class="s2">\n    </span><span class="s1">const next = this.input.charCodeAt(this.state.pos + 1);</span><span class="s2">\n    </span><span class="s1">const next2 = this.input.charCodeAt(this.state.pos + 2);</span><span class="s2">\n    </span><span class="s1">if (next === charCodes.questionMark) {</span><span class="s2">\n      </span><span class="s1">if (next2 === charCodes.equalsTo) {</span><span class="s2">\n        </span><span class="s1">// '??='</span><span class="s2">\n        </span><span class="s1">this.finishOp(tt.assign, 3);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">// '??'</span><span class="s2">\n        </span><span class="s1">this.finishOp(tt.nullishCoalescing, 2);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else if (</span><span class="s2">\n      </span><span class="s1">next === charCodes.dot &amp;&amp;</span><span class="s2">\n      </span><span class="s1">!(next2 &gt;= charCodes.digit0 &amp;&amp; next2 &lt;= charCodes.digit9)</span><span class="s2">\n    </span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">// '.' not followed by a number</span><span class="s2">\n      </span><span class="s1">this.state.pos += 2;</span><span class="s2">\n      </span><span class="s1">this.finishToken(tt.questionDot);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">++this.state.pos;</span><span class="s2">\n      </span><span class="s1">this.finishToken(tt.question);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">getTokenFromCode(code: number): void {</span><span class="s2">\n    </span><span class="s1">switch (code) {</span><span class="s2">\n      </span><span class="s1">// The interpretation of a dot depends on whether it is followed</span><span class="s2">\n      </span><span class="s1">// by a digit or another two dots.</span><span class="s2">\n\n      </span><span class="s1">case charCodes.dot:</span><span class="s2">\n        </span><span class="s1">this.readToken_dot();</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">// Punctuation tokens.</span><span class="s2">\n      </span><span class="s1">case charCodes.leftParenthesis:</span><span class="s2">\n        </span><span class="s1">++this.state.pos;</span><span class="s2">\n        </span><span class="s1">this.finishToken(tt.parenL);</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">case charCodes.rightParenthesis:</span><span class="s2">\n        </span><span class="s1">++this.state.pos;</span><span class="s2">\n        </span><span class="s1">this.finishToken(tt.parenR);</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">case charCodes.semicolon:</span><span class="s2">\n        </span><span class="s1">++this.state.pos;</span><span class="s2">\n        </span><span class="s1">this.finishToken(tt.semi);</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">case charCodes.comma:</span><span class="s2">\n        </span><span class="s1">++this.state.pos;</span><span class="s2">\n        </span><span class="s1">this.finishToken(tt.comma);</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">case charCodes.leftSquareBracket:</span><span class="s2">\n        </span><span class="s1">if (</span><span class="s2">\n          </span><span class="s1">this.hasPlugin(</span><span class="s2">\&quot;</span><span class="s1">recordAndTuple</span><span class="s2">\&quot;</span><span class="s1">) &amp;&amp;</span><span class="s2">\n          </span><span class="s1">this.input.charCodeAt(this.state.pos + 1) === charCodes.verticalBar</span><span class="s2">\n        </span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">if (this.getPluginOption(</span><span class="s2">\&quot;</span><span class="s1">recordAndTuple</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">syntaxType</span><span class="s2">\&quot;</span><span class="s1">) !== </span><span class="s2">\&quot;</span><span class="s1">bar</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n            </span><span class="s1">throw this.raise(</span><span class="s2">\n              </span><span class="s1">Errors.TupleExpressionBarIncorrectStartSyntaxType,</span><span class="s2">\n              </span><span class="s1">{ at: this.state.curPosition() },</span><span class="s2">\n            </span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n\n          </span><span class="s1">// [|</span><span class="s2">\n          </span><span class="s1">this.state.pos += 2;</span><span class="s2">\n          </span><span class="s1">this.finishToken(tt.bracketBarL);</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">++this.state.pos;</span><span class="s2">\n          </span><span class="s1">this.finishToken(tt.bracketL);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">case charCodes.rightSquareBracket:</span><span class="s2">\n        </span><span class="s1">++this.state.pos;</span><span class="s2">\n        </span><span class="s1">this.finishToken(tt.bracketR);</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">case charCodes.leftCurlyBrace:</span><span class="s2">\n        </span><span class="s1">if (</span><span class="s2">\n          </span><span class="s1">this.hasPlugin(</span><span class="s2">\&quot;</span><span class="s1">recordAndTuple</span><span class="s2">\&quot;</span><span class="s1">) &amp;&amp;</span><span class="s2">\n          </span><span class="s1">this.input.charCodeAt(this.state.pos + 1) === charCodes.verticalBar</span><span class="s2">\n        </span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">if (this.getPluginOption(</span><span class="s2">\&quot;</span><span class="s1">recordAndTuple</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">syntaxType</span><span class="s2">\&quot;</span><span class="s1">) !== </span><span class="s2">\&quot;</span><span class="s1">bar</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n            </span><span class="s1">throw this.raise(</span><span class="s2">\n              </span><span class="s1">Errors.RecordExpressionBarIncorrectStartSyntaxType,</span><span class="s2">\n              </span><span class="s1">{ at: this.state.curPosition() },</span><span class="s2">\n            </span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n\n          </span><span class="s1">// {|</span><span class="s2">\n          </span><span class="s1">this.state.pos += 2;</span><span class="s2">\n          </span><span class="s1">this.finishToken(tt.braceBarL);</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">++this.state.pos;</span><span class="s2">\n          </span><span class="s1">this.finishToken(tt.braceL);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">case charCodes.rightCurlyBrace:</span><span class="s2">\n        </span><span class="s1">++this.state.pos;</span><span class="s2">\n        </span><span class="s1">this.finishToken(tt.braceR);</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n\n      </span><span class="s1">case charCodes.colon:</span><span class="s2">\n        </span><span class="s1">if (</span><span class="s2">\n          </span><span class="s1">this.hasPlugin(</span><span class="s2">\&quot;</span><span class="s1">functionBind</span><span class="s2">\&quot;</span><span class="s1">) &amp;&amp;</span><span class="s2">\n          </span><span class="s1">this.input.charCodeAt(this.state.pos + 1) === charCodes.colon</span><span class="s2">\n        </span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">this.finishOp(tt.doubleColon, 2);</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">++this.state.pos;</span><span class="s2">\n          </span><span class="s1">this.finishToken(tt.colon);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n\n      </span><span class="s1">case charCodes.questionMark:</span><span class="s2">\n        </span><span class="s1">this.readToken_question();</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n\n      </span><span class="s1">case charCodes.graveAccent:</span><span class="s2">\n        </span><span class="s1">this.readTemplateToken();</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n\n      </span><span class="s1">case charCodes.digit0: {</span><span class="s2">\n        </span><span class="s1">const next = this.input.charCodeAt(this.state.pos + 1);</span><span class="s2">\n        </span><span class="s1">// '0x', '0X' - hex number</span><span class="s2">\n        </span><span class="s1">if (next === charCodes.lowercaseX || next === charCodes.uppercaseX) {</span><span class="s2">\n          </span><span class="s1">this.readRadixNumber(16);</span><span class="s2">\n          </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// '0o', '0O' - octal number</span><span class="s2">\n        </span><span class="s1">if (next === charCodes.lowercaseO || next === charCodes.uppercaseO) {</span><span class="s2">\n          </span><span class="s1">this.readRadixNumber(8);</span><span class="s2">\n          </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// '0b', '0B' - binary number</span><span class="s2">\n        </span><span class="s1">if (next === charCodes.lowercaseB || next === charCodes.uppercaseB) {</span><span class="s2">\n          </span><span class="s1">this.readRadixNumber(2);</span><span class="s2">\n          </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">// Anything else beginning with a digit is an integer, octal</span><span class="s2">\n      </span><span class="s1">// number, or float. (fall through)</span><span class="s2">\n      </span><span class="s1">case charCodes.digit1:</span><span class="s2">\n      </span><span class="s1">case charCodes.digit2:</span><span class="s2">\n      </span><span class="s1">case charCodes.digit3:</span><span class="s2">\n      </span><span class="s1">case charCodes.digit4:</span><span class="s2">\n      </span><span class="s1">case charCodes.digit5:</span><span class="s2">\n      </span><span class="s1">case charCodes.digit6:</span><span class="s2">\n      </span><span class="s1">case charCodes.digit7:</span><span class="s2">\n      </span><span class="s1">case charCodes.digit8:</span><span class="s2">\n      </span><span class="s1">case charCodes.digit9:</span><span class="s2">\n        </span><span class="s1">this.readNumber(false);</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n\n      </span><span class="s1">// Quotes produce strings.</span><span class="s2">\n      </span><span class="s1">case charCodes.quotationMark:</span><span class="s2">\n      </span><span class="s1">case charCodes.apostrophe:</span><span class="s2">\n        </span><span class="s1">this.readString(code);</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n\n      </span><span class="s1">// Operators are parsed inline in tiny state machines. '=' (charCodes.equalsTo) is</span><span class="s2">\n      </span><span class="s1">// often referred to. `finishOp` simply skips the amount of</span><span class="s2">\n      </span><span class="s1">// characters it is given as second argument, and returns a token</span><span class="s2">\n      </span><span class="s1">// of the type given by its first argument.</span><span class="s2">\n\n      </span><span class="s1">case charCodes.slash:</span><span class="s2">\n        </span><span class="s1">this.readToken_slash();</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n\n      </span><span class="s1">case charCodes.percentSign:</span><span class="s2">\n      </span><span class="s1">case charCodes.asterisk:</span><span class="s2">\n        </span><span class="s1">this.readToken_mult_modulo(code);</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n\n      </span><span class="s1">case charCodes.verticalBar:</span><span class="s2">\n      </span><span class="s1">case charCodes.ampersand:</span><span class="s2">\n        </span><span class="s1">this.readToken_pipe_amp(code);</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n\n      </span><span class="s1">case charCodes.caret:</span><span class="s2">\n        </span><span class="s1">this.readToken_caret();</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n\n      </span><span class="s1">case charCodes.plusSign:</span><span class="s2">\n      </span><span class="s1">case charCodes.dash:</span><span class="s2">\n        </span><span class="s1">this.readToken_plus_min(code);</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n\n      </span><span class="s1">case charCodes.lessThan:</span><span class="s2">\n        </span><span class="s1">this.readToken_lt();</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n\n      </span><span class="s1">case charCodes.greaterThan:</span><span class="s2">\n        </span><span class="s1">this.readToken_gt();</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n\n      </span><span class="s1">case charCodes.equalsTo:</span><span class="s2">\n      </span><span class="s1">case charCodes.exclamationMark:</span><span class="s2">\n        </span><span class="s1">this.readToken_eq_excl(code);</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n\n      </span><span class="s1">case charCodes.tilde:</span><span class="s2">\n        </span><span class="s1">this.finishOp(tt.tilde, 1);</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n\n      </span><span class="s1">case charCodes.atSign:</span><span class="s2">\n        </span><span class="s1">this.readToken_atSign();</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n\n      </span><span class="s1">case charCodes.numberSign:</span><span class="s2">\n        </span><span class="s1">this.readToken_numberSign();</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n\n      </span><span class="s1">case charCodes.backslash:</span><span class="s2">\n        </span><span class="s1">this.readWord();</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n\n      </span><span class="s1">default:</span><span class="s2">\n        </span><span class="s1">if (isIdentifierStart(code)) {</span><span class="s2">\n          </span><span class="s1">this.readWord(code);</span><span class="s2">\n          </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">throw this.raise(Errors.InvalidOrUnexpectedToken, {</span><span class="s2">\n      </span><span class="s1">at: this.state.curPosition(),</span><span class="s2">\n      </span><span class="s1">unexpected: String.fromCodePoint(code),</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">finishOp(type: TokenType, size: number): void {</span><span class="s2">\n    </span><span class="s1">const str = this.input.slice(this.state.pos, this.state.pos + size);</span><span class="s2">\n    </span><span class="s1">this.state.pos += size;</span><span class="s2">\n    </span><span class="s1">this.finishToken(type, str);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">readRegexp(): void {</span><span class="s2">\n    </span><span class="s1">const startLoc = this.state.startLoc;</span><span class="s2">\n    </span><span class="s1">const start = this.state.start + 1;</span><span class="s2">\n    </span><span class="s1">let escaped, inClass;</span><span class="s2">\n    </span><span class="s1">let { pos } = this.state;</span><span class="s2">\n    </span><span class="s1">for (; ; ++pos) {</span><span class="s2">\n      </span><span class="s1">if (pos &gt;= this.length) {</span><span class="s2">\n        </span><span class="s1">// FIXME: explain</span><span class="s2">\n        </span><span class="s1">throw this.raise(Errors.UnterminatedRegExp, {</span><span class="s2">\n          </span><span class="s1">at: createPositionWithColumnOffset(startLoc, 1),</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">const ch = this.input.charCodeAt(pos);</span><span class="s2">\n      </span><span class="s1">if (isNewLine(ch)) {</span><span class="s2">\n        </span><span class="s1">throw this.raise(Errors.UnterminatedRegExp, {</span><span class="s2">\n          </span><span class="s1">at: createPositionWithColumnOffset(startLoc, 1),</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (escaped) {</span><span class="s2">\n        </span><span class="s1">escaped = false;</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">if (ch === charCodes.leftSquareBracket) {</span><span class="s2">\n          </span><span class="s1">inClass = true;</span><span class="s2">\n        </span><span class="s1">} else if (ch === charCodes.rightSquareBracket &amp;&amp; inClass) {</span><span class="s2">\n          </span><span class="s1">inClass = false;</span><span class="s2">\n        </span><span class="s1">} else if (ch === charCodes.slash &amp;&amp; !inClass) {</span><span class="s2">\n          </span><span class="s1">break;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">escaped = ch === charCodes.backslash;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">const content = this.input.slice(start, pos);</span><span class="s2">\n    </span><span class="s1">++pos;</span><span class="s2">\n\n    </span><span class="s1">let mods = </span><span class="s2">\&quot;\&quot;</span><span class="s1">;</span><span class="s2">\n\n    </span><span class="s1">const nextPos = () =&gt;</span><span class="s2">\n      </span><span class="s1">// (pos + 1) + 1 - start</span><span class="s2">\n      </span><span class="s1">createPositionWithColumnOffset(startLoc, pos + 2 - start);</span><span class="s2">\n\n    </span><span class="s1">while (pos &lt; this.length) {</span><span class="s2">\n      </span><span class="s1">const cp = this.codePointAtPos(pos);</span><span class="s2">\n      </span><span class="s1">// It doesn't matter if cp &gt; 0xffff, the loop will either throw or break because we check on cp</span><span class="s2">\n      </span><span class="s1">const char = String.fromCharCode(cp);</span><span class="s2">\n\n      </span><span class="s1">// @ts-expect-error VALID_REGEX_FLAGS.has should accept expanded type: number</span><span class="s2">\n      </span><span class="s1">if (VALID_REGEX_FLAGS.has(cp)) {</span><span class="s2">\n        </span><span class="s1">if (cp === charCodes.lowercaseV) {</span><span class="s2">\n          </span><span class="s1">this.expectPlugin(</span><span class="s2">\&quot;</span><span class="s1">regexpUnicodeSets</span><span class="s2">\&quot;</span><span class="s1">, nextPos());</span><span class="s2">\n\n          </span><span class="s1">if (mods.includes(</span><span class="s2">\&quot;</span><span class="s1">u</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n            </span><span class="s1">this.raise(Errors.IncompatibleRegExpUVFlags, { at: nextPos() });</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">} else if (cp === charCodes.lowercaseU) {</span><span class="s2">\n          </span><span class="s1">if (mods.includes(</span><span class="s2">\&quot;</span><span class="s1">v</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n            </span><span class="s1">this.raise(Errors.IncompatibleRegExpUVFlags, { at: nextPos() });</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (mods.includes(char)) {</span><span class="s2">\n          </span><span class="s1">this.raise(Errors.DuplicateRegExpFlags, { at: nextPos() });</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">} else if (isIdentifierChar(cp) || cp === charCodes.backslash) {</span><span class="s2">\n        </span><span class="s1">this.raise(Errors.MalformedRegExpFlags, { at: nextPos() });</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">break;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">++pos;</span><span class="s2">\n      </span><span class="s1">mods += char;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">this.state.pos = pos;</span><span class="s2">\n\n    </span><span class="s1">this.finishToken(tt.regexp, {</span><span class="s2">\n      </span><span class="s1">pattern: content,</span><span class="s2">\n      </span><span class="s1">flags: mods,</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Read an integer in the given radix. Return null if zero digits</span><span class="s2">\n  </span><span class="s1">// were read, the integer value otherwise. When `len` is given, this</span><span class="s2">\n  </span><span class="s1">// will return `null` unless the integer has exactly `len` digits.</span><span class="s2">\n  </span><span class="s1">// When `forceLen` is `true`, it means that we already know that in case</span><span class="s2">\n  </span><span class="s1">// of a malformed number we have to skip `len` characters anyway, instead</span><span class="s2">\n  </span><span class="s1">// of bailing out early. For example, in </span><span class="s2">\&quot;\\</span><span class="s1">u{123Z}</span><span class="s2">\&quot; </span><span class="s1">we want to read up to }</span><span class="s2">\n  </span><span class="s1">// anyway, while in </span><span class="s2">\&quot;\\</span><span class="s1">u00Z</span><span class="s2">\&quot; </span><span class="s1">we will stop at Z instead of consuming four</span><span class="s2">\n  </span><span class="s1">// characters (and thus the closing quote).</span><span class="s2">\n\n  </span><span class="s1">readInt(</span><span class="s2">\n    </span><span class="s1">radix: number,</span><span class="s2">\n    </span><span class="s1">len?: number,</span><span class="s2">\n    </span><span class="s1">forceLen: boolean = false,</span><span class="s2">\n    </span><span class="s1">allowNumSeparator: boolean | </span><span class="s2">\&quot;</span><span class="s1">bail</span><span class="s2">\&quot; </span><span class="s1">= true,</span><span class="s2">\n  </span><span class="s1">): number | null {</span><span class="s2">\n    </span><span class="s1">const { n, pos } = readInt(</span><span class="s2">\n      </span><span class="s1">this.input,</span><span class="s2">\n      </span><span class="s1">this.state.pos,</span><span class="s2">\n      </span><span class="s1">this.state.lineStart,</span><span class="s2">\n      </span><span class="s1">this.state.curLine,</span><span class="s2">\n      </span><span class="s1">radix,</span><span class="s2">\n      </span><span class="s1">len,</span><span class="s2">\n      </span><span class="s1">forceLen,</span><span class="s2">\n      </span><span class="s1">allowNumSeparator,</span><span class="s2">\n      </span><span class="s1">this.errorHandlers_readInt,</span><span class="s2">\n      </span><span class="s1">/* bailOnError */ false,</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">this.state.pos = pos;</span><span class="s2">\n    </span><span class="s1">return n;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">readRadixNumber(radix: number): void {</span><span class="s2">\n    </span><span class="s1">const startLoc = this.state.curPosition();</span><span class="s2">\n    </span><span class="s1">let isBigInt = false;</span><span class="s2">\n\n    </span><span class="s1">this.state.pos += 2; // 0x</span><span class="s2">\n    </span><span class="s1">const val = this.readInt(radix);</span><span class="s2">\n    </span><span class="s1">if (val == null) {</span><span class="s2">\n      </span><span class="s1">this.raise(Errors.InvalidDigit, {</span><span class="s2">\n        </span><span class="s1">// Numeric literals can't have newlines, so this is safe to do.</span><span class="s2">\n        </span><span class="s1">at: createPositionWithColumnOffset(startLoc, 2),</span><span class="s2">\n        </span><span class="s1">radix,</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">const next = this.input.charCodeAt(this.state.pos);</span><span class="s2">\n\n    </span><span class="s1">if (next === charCodes.lowercaseN) {</span><span class="s2">\n      </span><span class="s1">++this.state.pos;</span><span class="s2">\n      </span><span class="s1">isBigInt = true;</span><span class="s2">\n    </span><span class="s1">} else if (next === charCodes.lowercaseM) {</span><span class="s2">\n      </span><span class="s1">throw this.raise(Errors.InvalidDecimal, { at: startLoc });</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {</span><span class="s2">\n      </span><span class="s1">throw this.raise(Errors.NumberIdentifier, {</span><span class="s2">\n        </span><span class="s1">at: this.state.curPosition(),</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">if (isBigInt) {</span><span class="s2">\n      </span><span class="s1">const str = this.input</span><span class="s2">\n        </span><span class="s1">.slice(startLoc.index, this.state.pos)</span><span class="s2">\n        </span><span class="s1">.replace(/[_n]/g, </span><span class="s2">\&quot;\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">this.finishToken(tt.bigint, str);</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">this.finishToken(tt.num, val);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Read an integer, octal integer, or floating-point number.</span><span class="s2">\n\n  </span><span class="s1">readNumber(startsWithDot: boolean): void {</span><span class="s2">\n    </span><span class="s1">const start = this.state.pos;</span><span class="s2">\n    </span><span class="s1">const startLoc = this.state.curPosition();</span><span class="s2">\n    </span><span class="s1">let isFloat = false;</span><span class="s2">\n    </span><span class="s1">let isBigInt = false;</span><span class="s2">\n    </span><span class="s1">let isDecimal = false;</span><span class="s2">\n    </span><span class="s1">let hasExponent = false;</span><span class="s2">\n    </span><span class="s1">let isOctal = false;</span><span class="s2">\n\n    </span><span class="s1">if (!startsWithDot &amp;&amp; this.readInt(10) === null) {</span><span class="s2">\n      </span><span class="s1">this.raise(Errors.InvalidNumber, { at: this.state.curPosition() });</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">const hasLeadingZero =</span><span class="s2">\n      </span><span class="s1">this.state.pos - start &gt;= 2 &amp;&amp;</span><span class="s2">\n      </span><span class="s1">this.input.charCodeAt(start) === charCodes.digit0;</span><span class="s2">\n\n    </span><span class="s1">if (hasLeadingZero) {</span><span class="s2">\n      </span><span class="s1">const integer = this.input.slice(start, this.state.pos);</span><span class="s2">\n      </span><span class="s1">this.recordStrictModeErrors(Errors.StrictOctalLiteral, { at: startLoc });</span><span class="s2">\n      </span><span class="s1">if (!this.state.strict) {</span><span class="s2">\n        </span><span class="s1">// disallow numeric separators in non octal decimals and legacy octal likes</span><span class="s2">\n        </span><span class="s1">const underscorePos = integer.indexOf(</span><span class="s2">\&quot;</span><span class="s1">_</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">if (underscorePos &gt; 0) {</span><span class="s2">\n          </span><span class="s1">// Numeric literals can't have newlines, so this is safe to do.</span><span class="s2">\n          </span><span class="s1">this.raise(Errors.ZeroDigitNumericSeparator, {</span><span class="s2">\n            </span><span class="s1">at: createPositionWithColumnOffset(startLoc, underscorePos),</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">isOctal = hasLeadingZero &amp;&amp; !/[89]/.test(integer);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">let next = this.input.charCodeAt(this.state.pos);</span><span class="s2">\n    </span><span class="s1">if (next === charCodes.dot &amp;&amp; !isOctal) {</span><span class="s2">\n      </span><span class="s1">++this.state.pos;</span><span class="s2">\n      </span><span class="s1">this.readInt(10);</span><span class="s2">\n      </span><span class="s1">isFloat = true;</span><span class="s2">\n      </span><span class="s1">next = this.input.charCodeAt(this.state.pos);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">if (</span><span class="s2">\n      </span><span class="s1">(next === charCodes.uppercaseE || next === charCodes.lowercaseE) &amp;&amp;</span><span class="s2">\n      </span><span class="s1">!isOctal</span><span class="s2">\n    </span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">next = this.input.charCodeAt(++this.state.pos);</span><span class="s2">\n      </span><span class="s1">if (next === charCodes.plusSign || next === charCodes.dash) {</span><span class="s2">\n        </span><span class="s1">++this.state.pos;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (this.readInt(10) === null) {</span><span class="s2">\n        </span><span class="s1">this.raise(Errors.InvalidOrMissingExponent, { at: startLoc });</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">isFloat = true;</span><span class="s2">\n      </span><span class="s1">hasExponent = true;</span><span class="s2">\n      </span><span class="s1">next = this.input.charCodeAt(this.state.pos);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">if (next === charCodes.lowercaseN) {</span><span class="s2">\n      </span><span class="s1">// disallow floats, legacy octal syntax and non octal decimals</span><span class="s2">\n      </span><span class="s1">// new style octal (</span><span class="s2">\&quot;</span><span class="s1">0o</span><span class="s2">\&quot;</span><span class="s1">) is handled in this.readRadixNumber</span><span class="s2">\n      </span><span class="s1">if (isFloat || hasLeadingZero) {</span><span class="s2">\n        </span><span class="s1">this.raise(Errors.InvalidBigIntLiteral, { at: startLoc });</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">++this.state.pos;</span><span class="s2">\n      </span><span class="s1">isBigInt = true;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">if (next === charCodes.lowercaseM) {</span><span class="s2">\n      </span><span class="s1">this.expectPlugin(</span><span class="s2">\&quot;</span><span class="s1">decimal</span><span class="s2">\&quot;</span><span class="s1">, this.state.curPosition());</span><span class="s2">\n      </span><span class="s1">if (hasExponent || hasLeadingZero) {</span><span class="s2">\n        </span><span class="s1">this.raise(Errors.InvalidDecimal, { at: startLoc });</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">++this.state.pos;</span><span class="s2">\n      </span><span class="s1">isDecimal = true;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {</span><span class="s2">\n      </span><span class="s1">throw this.raise(Errors.NumberIdentifier, {</span><span class="s2">\n        </span><span class="s1">at: this.state.curPosition(),</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// remove </span><span class="s2">\&quot;</span><span class="s1">_</span><span class="s2">\&quot; </span><span class="s1">for numeric literal separator, and trailing `m` or `n`</span><span class="s2">\n    </span><span class="s1">const str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, </span><span class="s2">\&quot;\&quot;</span><span class="s1">);</span><span class="s2">\n\n    </span><span class="s1">if (isBigInt) {</span><span class="s2">\n      </span><span class="s1">this.finishToken(tt.bigint, str);</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">if (isDecimal) {</span><span class="s2">\n      </span><span class="s1">this.finishToken(tt.decimal, str);</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">const val = isOctal ? parseInt(str, 8) : parseFloat(str);</span><span class="s2">\n    </span><span class="s1">this.finishToken(tt.num, val);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Read a string value, interpreting backslash-escapes.</span><span class="s2">\n\n  </span><span class="s1">readCodePoint(throwOnInvalid: boolean): number | null {</span><span class="s2">\n    </span><span class="s1">const { code, pos } = readCodePoint(</span><span class="s2">\n      </span><span class="s1">this.input,</span><span class="s2">\n      </span><span class="s1">this.state.pos,</span><span class="s2">\n      </span><span class="s1">this.state.lineStart,</span><span class="s2">\n      </span><span class="s1">this.state.curLine,</span><span class="s2">\n      </span><span class="s1">throwOnInvalid,</span><span class="s2">\n      </span><span class="s1">this.errorHandlers_readCodePoint,</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">this.state.pos = pos;</span><span class="s2">\n    </span><span class="s1">return code;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">readString(quote: number): void {</span><span class="s2">\n    </span><span class="s1">const { str, pos, curLine, lineStart } = readStringContents(</span><span class="s2">\n      </span><span class="s1">quote === charCodes.quotationMark ? </span><span class="s2">\&quot;</span><span class="s1">double</span><span class="s2">\&quot; </span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">single</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">this.input,</span><span class="s2">\n      </span><span class="s1">this.state.pos + 1, // skip the quote</span><span class="s2">\n      </span><span class="s1">this.state.lineStart,</span><span class="s2">\n      </span><span class="s1">this.state.curLine,</span><span class="s2">\n      </span><span class="s1">this.errorHandlers_readStringContents_string,</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">this.state.pos = pos + 1; // skip the quote</span><span class="s2">\n    </span><span class="s1">this.state.lineStart = lineStart;</span><span class="s2">\n    </span><span class="s1">this.state.curLine = curLine;</span><span class="s2">\n    </span><span class="s1">this.finishToken(tt.string, str);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Reads template continuation `}...`</span><span class="s2">\n  </span><span class="s1">readTemplateContinuation(): void {</span><span class="s2">\n    </span><span class="s1">if (!this.match(tt.braceR)) {</span><span class="s2">\n      </span><span class="s1">this.unexpected(null, tt.braceR);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// rewind pos to `}`</span><span class="s2">\n    </span><span class="s1">this.state.pos--;</span><span class="s2">\n    </span><span class="s1">this.readTemplateToken();</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Reads template string tokens.</span><span class="s2">\n  </span><span class="s1">readTemplateToken(): void {</span><span class="s2">\n    </span><span class="s1">const opening = this.input[this.state.pos];</span><span class="s2">\n    </span><span class="s1">const { str, firstInvalidLoc, pos, curLine, lineStart } =</span><span class="s2">\n      </span><span class="s1">readStringContents(</span><span class="s2">\n        \&quot;</span><span class="s1">template</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">this.input,</span><span class="s2">\n        </span><span class="s1">this.state.pos + 1, // skip '`' or `}`</span><span class="s2">\n        </span><span class="s1">this.state.lineStart,</span><span class="s2">\n        </span><span class="s1">this.state.curLine,</span><span class="s2">\n        </span><span class="s1">this.errorHandlers_readStringContents_template,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">this.state.pos = pos + 1; // skip '`' or `$`</span><span class="s2">\n    </span><span class="s1">this.state.lineStart = lineStart;</span><span class="s2">\n    </span><span class="s1">this.state.curLine = curLine;</span><span class="s2">\n\n    </span><span class="s1">if (firstInvalidLoc) {</span><span class="s2">\n      </span><span class="s1">this.state.firstInvalidTemplateEscapePos = new Position(</span><span class="s2">\n        </span><span class="s1">firstInvalidLoc.curLine,</span><span class="s2">\n        </span><span class="s1">firstInvalidLoc.pos - firstInvalidLoc.lineStart,</span><span class="s2">\n        </span><span class="s1">firstInvalidLoc.pos,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">if (this.input.codePointAt(pos) === charCodes.graveAccent) {</span><span class="s2">\n      </span><span class="s1">this.finishToken(</span><span class="s2">\n        </span><span class="s1">tt.templateTail,</span><span class="s2">\n        </span><span class="s1">firstInvalidLoc ? null : opening + str + </span><span class="s2">\&quot;</span><span class="s1">`</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">this.state.pos++; // skip '{'</span><span class="s2">\n      </span><span class="s1">this.finishToken(</span><span class="s2">\n        </span><span class="s1">tt.templateNonTail,</span><span class="s2">\n        </span><span class="s1">firstInvalidLoc ? null : opening + str + </span><span class="s2">\&quot;</span><span class="s1">${</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">recordStrictModeErrors(</span><span class="s2">\n    </span><span class="s1">toParseError: DeferredStrictError,</span><span class="s2">\n    </span><span class="s1">{ at }: { at: Position },</span><span class="s2">\n  </span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">const index = at.index;</span><span class="s2">\n\n    </span><span class="s1">if (this.state.strict &amp;&amp; !this.state.strictErrors.has(index)) {</span><span class="s2">\n      </span><span class="s1">this.raise(toParseError, { at });</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">this.state.strictErrors.set(index, [toParseError, at]);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Read an identifier, and return it as a string. Sets `this.state.containsEsc`</span><span class="s2">\n  </span><span class="s1">// to whether the word contained a '</span><span class="s2">\\</span><span class="s1">u' escape.</span><span class="s2">\n  </span><span class="s1">//</span><span class="s2">\n  </span><span class="s1">// Incrementally adds only escaped chars, adding other chunks as-is</span><span class="s2">\n  </span><span class="s1">// as a micro-optimization.</span><span class="s2">\n  </span><span class="s1">//</span><span class="s2">\n  </span><span class="s1">// When `firstCode` is given, it assumes it is always an identifier start and</span><span class="s2">\n  </span><span class="s1">// will skip reading start position again</span><span class="s2">\n\n  </span><span class="s1">readWord1(firstCode?: number): string {</span><span class="s2">\n    </span><span class="s1">this.state.containsEsc = false;</span><span class="s2">\n    </span><span class="s1">let word = </span><span class="s2">\&quot;\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">const start = this.state.pos;</span><span class="s2">\n    </span><span class="s1">let chunkStart = this.state.pos;</span><span class="s2">\n    </span><span class="s1">if (firstCode !== undefined) {</span><span class="s2">\n      </span><span class="s1">this.state.pos += firstCode &lt;= 0xffff ? 1 : 2;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">while (this.state.pos &lt; this.length) {</span><span class="s2">\n      </span><span class="s1">const ch = this.codePointAtPos(this.state.pos);</span><span class="s2">\n      </span><span class="s1">if (isIdentifierChar(ch)) {</span><span class="s2">\n        </span><span class="s1">this.state.pos += ch &lt;= 0xffff ? 1 : 2;</span><span class="s2">\n      </span><span class="s1">} else if (ch === charCodes.backslash) {</span><span class="s2">\n        </span><span class="s1">this.state.containsEsc = true;</span><span class="s2">\n\n        </span><span class="s1">word += this.input.slice(chunkStart, this.state.pos);</span><span class="s2">\n        </span><span class="s1">const escStart = this.state.curPosition();</span><span class="s2">\n        </span><span class="s1">const identifierCheck =</span><span class="s2">\n          </span><span class="s1">this.state.pos === start ? isIdentifierStart : isIdentifierChar;</span><span class="s2">\n\n        </span><span class="s1">if (this.input.charCodeAt(++this.state.pos) !== charCodes.lowercaseU) {</span><span class="s2">\n          </span><span class="s1">this.raise(Errors.MissingUnicodeEscape, {</span><span class="s2">\n            </span><span class="s1">at: this.state.curPosition(),</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n          </span><span class="s1">chunkStart = this.state.pos - 1;</span><span class="s2">\n          </span><span class="s1">continue;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">++this.state.pos;</span><span class="s2">\n        </span><span class="s1">const esc = this.readCodePoint(true);</span><span class="s2">\n        </span><span class="s1">if (esc !== null) {</span><span class="s2">\n          </span><span class="s1">if (!identifierCheck(esc)) {</span><span class="s2">\n            </span><span class="s1">this.raise(Errors.EscapedCharNotAnIdentifier, { at: escStart });</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n\n          </span><span class="s1">word += String.fromCodePoint(esc);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">chunkStart = this.state.pos;</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">break;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return word + this.input.slice(chunkStart, this.state.pos);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Read an identifier or keyword token. Will check for reserved</span><span class="s2">\n  </span><span class="s1">// words when necessary.</span><span class="s2">\n\n  </span><span class="s1">readWord(firstCode?: number): void {</span><span class="s2">\n    </span><span class="s1">const word = this.readWord1(firstCode);</span><span class="s2">\n    </span><span class="s1">const type = keywordTypes.get(word);</span><span class="s2">\n    </span><span class="s1">if (type !== undefined) {</span><span class="s2">\n      </span><span class="s1">// We don't use word as state.value here because word is a dynamic string</span><span class="s2">\n      </span><span class="s1">// while token label is a shared constant string</span><span class="s2">\n      </span><span class="s1">this.finishToken(type, tokenLabelName(type));</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">this.finishToken(tt.name, word);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">checkKeywordEscapes(): void {</span><span class="s2">\n    </span><span class="s1">const { type } = this.state;</span><span class="s2">\n    </span><span class="s1">if (tokenIsKeyword(type) &amp;&amp; this.state.containsEsc) {</span><span class="s2">\n      </span><span class="s1">this.raise(Errors.InvalidEscapedReservedWord, {</span><span class="s2">\n        </span><span class="s1">at: this.state.startLoc,</span><span class="s2">\n        </span><span class="s1">reservedWord: tokenLabelName(type),</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* Raise a `ParseError` given the appropriate properties. If passed a</span><span class="s2">\n   </span><span class="s1">* `Position` for the `at` property, raises the `ParseError` at that location.</span><span class="s2">\n   </span><span class="s1">* Otherwise, if passed a `Node`, raises the `ParseError` at the start</span><span class="s2">\n   </span><span class="s1">* location of that `Node`.</span><span class="s2">\n   </span><span class="s1">*</span><span class="s2">\n   </span><span class="s1">* If `errorRecovery` is `true`, the error is pushed to the errors array and</span><span class="s2">\n   </span><span class="s1">* returned. If `errorRecovery` is `false`, the error is instead thrown.</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">raise&lt;ErrorDetails&gt;(</span><span class="s2">\n    </span><span class="s1">toParseError: ParseErrorConstructor&lt;ErrorDetails&gt;,</span><span class="s2">\n    </span><span class="s1">raiseProperties: RaiseProperties&lt;ErrorDetails&gt;,</span><span class="s2">\n  </span><span class="s1">): ParseError&lt;ErrorDetails&gt; {</span><span class="s2">\n    </span><span class="s1">const { at, ...details } = raiseProperties;</span><span class="s2">\n    </span><span class="s1">const loc = at instanceof Position ? at : at.loc.start;</span><span class="s2">\n    </span><span class="s1">// @ts-expect-error: refine details typing</span><span class="s2">\n    </span><span class="s1">const error = toParseError({ loc, details });</span><span class="s2">\n\n    </span><span class="s1">if (!this.options.errorRecovery) throw error;</span><span class="s2">\n    </span><span class="s1">if (!this.isLookahead) this.state.errors.push(error);</span><span class="s2">\n\n    </span><span class="s1">return error;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* If `errorRecovery` is `false`, this method behaves identically to `raise`.</span><span class="s2">\n   </span><span class="s1">* If `errorRecovery` is `true`, this method will first see if there is</span><span class="s2">\n   </span><span class="s1">* already an error stored at the same `Position`, and replaces it with the</span><span class="s2">\n   </span><span class="s1">* one generated here.</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">raiseOverwrite&lt;ErrorDetails&gt;(</span><span class="s2">\n    </span><span class="s1">toParseError: ParseErrorConstructor&lt;ErrorDetails&gt;,</span><span class="s2">\n    </span><span class="s1">raiseProperties: RaiseProperties&lt;ErrorDetails&gt;,</span><span class="s2">\n  </span><span class="s1">): ParseError&lt;ErrorDetails&gt; | never {</span><span class="s2">\n    </span><span class="s1">const { at, ...details } = raiseProperties;</span><span class="s2">\n    </span><span class="s1">const loc = at instanceof Position ? at : at.loc.start;</span><span class="s2">\n    </span><span class="s1">const pos = loc.index;</span><span class="s2">\n    </span><span class="s1">const errors = this.state.errors;</span><span class="s2">\n\n    </span><span class="s1">for (let i = errors.length - 1; i &gt;= 0; i--) {</span><span class="s2">\n      </span><span class="s1">const error = errors[i];</span><span class="s2">\n      </span><span class="s1">if (error.loc.index === pos) {</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error: refine details typing</span><span class="s2">\n        </span><span class="s1">return (errors[i] = toParseError({ loc, details }));</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (error.loc.index &lt; pos) break;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">return this.raise(toParseError, raiseProperties);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// updateContext is used by the jsx plugin</span><span class="s2">\n  </span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-unused-vars</span><span class="s2">\n  </span><span class="s1">updateContext(prevType: TokenType): void {}</span><span class="s2">\n\n  </span><span class="s1">// Raise an unexpected token error. Can take the expected token type.</span><span class="s2">\n  </span><span class="s1">unexpected(loc?: Position | null, type?: TokenType): void {</span><span class="s2">\n    </span><span class="s1">throw this.raise(Errors.UnexpectedToken, {</span><span class="s2">\n      </span><span class="s1">expected: type ? tokenLabelName(type) : null,</span><span class="s2">\n      </span><span class="s1">at: loc != null ? loc : this.state.startLoc,</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">expectPlugin(pluginName: Plugin, loc?: Position): true {</span><span class="s2">\n    </span><span class="s1">if (this.hasPlugin(pluginName)) {</span><span class="s2">\n      </span><span class="s1">return true;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">throw this.raise(Errors.MissingPlugin, {</span><span class="s2">\n      </span><span class="s1">at: loc != null ? loc : this.state.startLoc,</span><span class="s2">\n      </span><span class="s1">missingPlugin: [pluginName],</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">expectOnePlugin(pluginNames: Plugin[]): void {</span><span class="s2">\n    </span><span class="s1">if (!pluginNames.some(name =&gt; this.hasPlugin(name))) {</span><span class="s2">\n      </span><span class="s1">throw this.raise(Errors.MissingOneOfPlugins, {</span><span class="s2">\n        </span><span class="s1">at: this.state.startLoc,</span><span class="s2">\n        </span><span class="s1">missingPlugin: pluginNames,</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">errorBuilder(error: ParseErrorConstructor&lt;{}&gt;) {</span><span class="s2">\n    </span><span class="s1">return (pos: number, lineStart: number, curLine: number) =&gt; {</span><span class="s2">\n      </span><span class="s1">this.raise(error, {</span><span class="s2">\n        </span><span class="s1">at: buildPosition(pos, lineStart, curLine),</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">errorHandlers_readInt: IntErrorHandlers = {</span><span class="s2">\n    </span><span class="s1">invalidDigit: (pos, lineStart, curLine, radix) =&gt; {</span><span class="s2">\n      </span><span class="s1">if (!this.options.errorRecovery) return false;</span><span class="s2">\n\n      </span><span class="s1">this.raise(Errors.InvalidDigit, {</span><span class="s2">\n        </span><span class="s1">at: buildPosition(pos, lineStart, curLine),</span><span class="s2">\n        </span><span class="s1">radix,</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">// Continue parsing the number as if there was no invalid digit.</span><span class="s2">\n      </span><span class="s1">return true;</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">numericSeparatorInEscapeSequence: this.errorBuilder(</span><span class="s2">\n      </span><span class="s1">Errors.NumericSeparatorInEscapeSequence,</span><span class="s2">\n    </span><span class="s1">),</span><span class="s2">\n    </span><span class="s1">unexpectedNumericSeparator: this.errorBuilder(</span><span class="s2">\n      </span><span class="s1">Errors.UnexpectedNumericSeparator,</span><span class="s2">\n    </span><span class="s1">),</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n\n  </span><span class="s1">errorHandlers_readCodePoint: CodePointErrorHandlers = {</span><span class="s2">\n    </span><span class="s1">...this.errorHandlers_readInt,</span><span class="s2">\n    </span><span class="s1">invalidEscapeSequence: this.errorBuilder(Errors.InvalidEscapeSequence),</span><span class="s2">\n    </span><span class="s1">invalidCodePoint: this.errorBuilder(Errors.InvalidCodePoint),</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n\n  </span><span class="s1">errorHandlers_readStringContents_string: StringContentsErrorHandlers = {</span><span class="s2">\n    </span><span class="s1">...this.errorHandlers_readCodePoint,</span><span class="s2">\n    </span><span class="s1">strictNumericEscape: (pos, lineStart, curLine) =&gt; {</span><span class="s2">\n      </span><span class="s1">this.recordStrictModeErrors(Errors.StrictNumericEscape, {</span><span class="s2">\n        </span><span class="s1">at: buildPosition(pos, lineStart, curLine),</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">unterminated: (pos, lineStart, curLine) =&gt; {</span><span class="s2">\n      </span><span class="s1">throw this.raise(Errors.UnterminatedString, {</span><span class="s2">\n        </span><span class="s1">// Report the error at the string quote</span><span class="s2">\n        </span><span class="s1">at: buildPosition(pos - 1, lineStart, curLine),</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n\n  </span><span class="s1">errorHandlers_readStringContents_template: StringContentsErrorHandlers = {</span><span class="s2">\n    </span><span class="s1">...this.errorHandlers_readCodePoint,</span><span class="s2">\n    </span><span class="s1">strictNumericEscape: this.errorBuilder(Errors.StrictNumericEscape),</span><span class="s2">\n    </span><span class="s1">unterminated: (pos, lineStart, curLine) =&gt; {</span><span class="s2">\n      </span><span class="s1">throw this.raise(Errors.UnterminatedTemplate, {</span><span class="s2">\n        </span><span class="s1">at: buildPosition(pos, lineStart, curLine),</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">&quot;</span><span class="s2">,</span><span class="s1">&quot;import {</span><span class="s2">\n  </span><span class="s1">CLASS_ELEMENT_KIND_ACCESSOR,</span><span class="s2">\n  </span><span class="s1">CLASS_ELEMENT_FLAG_STATIC,</span><span class="s2">\n  </span><span class="s1">type ClassElementTypes,</span><span class="s2">\n</span><span class="s1">} from </span><span class="s2">\&quot;</span><span class="s1">./scopeflags</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type { Position } from </span><span class="s2">\&quot;</span><span class="s1">./location</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import { Errors } from </span><span class="s2">\&quot;</span><span class="s1">../parse-error</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type Tokenizer from </span><span class="s2">\&quot;</span><span class="s1">../tokenizer</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">export class ClassScope {</span><span class="s2">\n  </span><span class="s1">// A list of private named declared in the current class</span><span class="s2">\n  </span><span class="s1">privateNames: Set&lt;string&gt; = new Set();</span><span class="s2">\n\n  </span><span class="s1">// A list of private getters of setters without their counterpart</span><span class="s2">\n  </span><span class="s1">loneAccessors: Map&lt;string, ClassElementTypes&gt; = new Map();</span><span class="s2">\n\n  </span><span class="s1">// A list of private names used before being defined, mapping to</span><span class="s2">\n  </span><span class="s1">// their position.</span><span class="s2">\n  </span><span class="s1">undefinedPrivateNames: Map&lt;string, Position&gt; = new Map();</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">export default class ClassScopeHandler {</span><span class="s2">\n  </span><span class="s1">parser: Tokenizer;</span><span class="s2">\n  </span><span class="s1">stack: Array&lt;ClassScope&gt; = [];</span><span class="s2">\n  </span><span class="s1">undefinedPrivateNames: Map&lt;string, Position&gt; = new Map();</span><span class="s2">\n\n  </span><span class="s1">constructor(parser: Tokenizer) {</span><span class="s2">\n    </span><span class="s1">this.parser = parser;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">current(): ClassScope {</span><span class="s2">\n    </span><span class="s1">return this.stack[this.stack.length - 1];</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">enter() {</span><span class="s2">\n    </span><span class="s1">this.stack.push(new ClassScope());</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">exit() {</span><span class="s2">\n    </span><span class="s1">const oldClassScope = this.stack.pop();</span><span class="s2">\n\n    </span><span class="s1">// Migrate the usage of not yet defined private names to the outer</span><span class="s2">\n    </span><span class="s1">// class scope, or raise an error if we reached the top-level scope.</span><span class="s2">\n\n    </span><span class="s1">const current = this.current();</span><span class="s2">\n\n    </span><span class="s1">// Array.from is needed because this is compiled to an array-like for loop</span><span class="s2">\n    </span><span class="s1">for (const [name, loc] of Array.from(oldClassScope.undefinedPrivateNames)) {</span><span class="s2">\n      </span><span class="s1">if (current) {</span><span class="s2">\n        </span><span class="s1">if (!current.undefinedPrivateNames.has(name)) {</span><span class="s2">\n          </span><span class="s1">current.undefinedPrivateNames.set(name, loc);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">this.parser.raise(Errors.InvalidPrivateFieldResolution, {</span><span class="s2">\n          </span><span class="s1">at: loc,</span><span class="s2">\n          </span><span class="s1">identifierName: name,</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">declarePrivateName(</span><span class="s2">\n    </span><span class="s1">name: string,</span><span class="s2">\n    </span><span class="s1">elementType: ClassElementTypes,</span><span class="s2">\n    </span><span class="s1">loc: Position,</span><span class="s2">\n  </span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">const { privateNames, loneAccessors, undefinedPrivateNames } =</span><span class="s2">\n      </span><span class="s1">this.current();</span><span class="s2">\n    </span><span class="s1">let redefined = privateNames.has(name);</span><span class="s2">\n\n    </span><span class="s1">if (elementType &amp; CLASS_ELEMENT_KIND_ACCESSOR) {</span><span class="s2">\n      </span><span class="s1">const accessor = redefined &amp;&amp; loneAccessors.get(name);</span><span class="s2">\n      </span><span class="s1">if (accessor) {</span><span class="s2">\n        </span><span class="s1">const oldStatic = accessor &amp; CLASS_ELEMENT_FLAG_STATIC;</span><span class="s2">\n        </span><span class="s1">const newStatic = elementType &amp; CLASS_ELEMENT_FLAG_STATIC;</span><span class="s2">\n\n        </span><span class="s1">const oldKind = accessor &amp; CLASS_ELEMENT_KIND_ACCESSOR;</span><span class="s2">\n        </span><span class="s1">const newKind = elementType &amp; CLASS_ELEMENT_KIND_ACCESSOR;</span><span class="s2">\n\n        </span><span class="s1">// The private name can be duplicated only if it is used by</span><span class="s2">\n        </span><span class="s1">// two accessors with different kind (get and set), and if</span><span class="s2">\n        </span><span class="s1">// they have the same placement (static or not).</span><span class="s2">\n        </span><span class="s1">redefined = oldKind === newKind || oldStatic !== newStatic;</span><span class="s2">\n\n        </span><span class="s1">if (!redefined) loneAccessors.delete(name);</span><span class="s2">\n      </span><span class="s1">} else if (!redefined) {</span><span class="s2">\n        </span><span class="s1">loneAccessors.set(name, elementType);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">if (redefined) {</span><span class="s2">\n      </span><span class="s1">this.parser.raise(Errors.PrivateNameRedeclaration, {</span><span class="s2">\n        </span><span class="s1">at: loc,</span><span class="s2">\n        </span><span class="s1">identifierName: name,</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">privateNames.add(name);</span><span class="s2">\n    </span><span class="s1">undefinedPrivateNames.delete(name);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">usePrivateName(name: string, loc: Position) {</span><span class="s2">\n    </span><span class="s1">let classScope;</span><span class="s2">\n    </span><span class="s1">for (classScope of this.stack) {</span><span class="s2">\n      </span><span class="s1">if (classScope.privateNames.has(name)) return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">if (classScope) {</span><span class="s2">\n      </span><span class="s1">classScope.undefinedPrivateNames.set(name, loc);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">// top-level</span><span class="s2">\n      </span><span class="s1">this.parser.raise(Errors.InvalidPrivateFieldResolution, {</span><span class="s2">\n        </span><span class="s1">at: loc,</span><span class="s2">\n        </span><span class="s1">identifierName: name,</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">&quot;</span><span class="s2">,</span><span class="s1">&quot;import { Errors, type ParseErrorConstructor } from </span><span class="s2">\&quot;</span><span class="s1">../parse-error</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type { Position } from </span><span class="s2">\&quot;</span><span class="s1">./location</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type { Node } from </span><span class="s2">\&quot;</span><span class="s1">../types</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type Tokenizer from </span><span class="s2">\&quot;</span><span class="s1">../tokenizer</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* @module util/expression-scope</span><span class="s2">\n\n</span><span class="s1">ExpressionScope is used to track declaration errors in these ambiguous patterns:</span><span class="s2">\n\n</span><span class="s1">- CoverParenthesizedExpressionAndArrowParameterList</span><span class="s2">\n  </span><span class="s1">e.g. we don't know if `({ x })` is an parenthesized expression or an</span><span class="s2">\n  </span><span class="s1">arrow function parameters until we see an `=&gt;` after `)`.</span><span class="s2">\n\n</span><span class="s1">- CoverCallExpressionAndAsyncArrowHead</span><span class="s2">\n  </span><span class="s1">e.g. we don't know if `async({ x })` is a call expression or an async arrow</span><span class="s2">\n  </span><span class="s1">function parameters until we see an `=&gt;` after `)`</span><span class="s2">\n\n</span><span class="s1">The following declaration errors (@see parser-errors/standard) will be recorded in</span><span class="s2">\n</span><span class="s1">some expression scopes and thrown later when we know what the ambiguous pattern is</span><span class="s2">\n\n</span><span class="s1">- AwaitBindingIdentifier</span><span class="s2">\n</span><span class="s1">- AwaitExpressionFormalParameter</span><span class="s2">\n</span><span class="s1">- YieldInParameter</span><span class="s2">\n</span><span class="s1">- InvalidParenthesizedAssignment when parenthesized is an identifier</span><span class="s2">\n\n</span><span class="s1">There are four different expression scope</span><span class="s2">\n</span><span class="s1">- Expression</span><span class="s2">\n  </span><span class="s1">A general scope that represents program / function body / static block. No errors</span><span class="s2">\n  </span><span class="s1">will be recorded nor thrown in this scope.</span><span class="s2">\n\n</span><span class="s1">- MaybeArrowParameterDeclaration</span><span class="s2">\n  </span><span class="s1">A scope that represents ambiguous arrow head e.g. `(x)`. Errors will be recorded</span><span class="s2">\n  </span><span class="s1">alongside parent scopes and thrown when `ExpressionScopeHandler#validateAsPattern`</span><span class="s2">\n  </span><span class="s1">is called.</span><span class="s2">\n\n</span><span class="s1">- MaybeAsyncArrowParameterDeclaration</span><span class="s2">\n  </span><span class="s1">A scope that represents ambiguous async arrow head e.g. `async(x)`. Errors will</span><span class="s2">\n  </span><span class="s1">be recorded alongside parent scopes and thrown when</span><span class="s2">\n  </span><span class="s1">`ExpressionScopeHandler#validateAsPattern` is called.</span><span class="s2">\n\n</span><span class="s1">- ParameterDeclaration</span><span class="s2">\n  </span><span class="s1">A scope that represents unambiguous function parameters `function(x)`. Errors</span><span class="s2">\n  </span><span class="s1">recorded in this scope will be thrown immediately. No errors will be recorded in</span><span class="s2">\n  </span><span class="s1">this scope.</span><span class="s2">\n\n</span><span class="s1">// @see {@link https://docs.google.com/document/d/1FAvEp9EUK-G8kHfDIEo_385Hs2SUBCYbJ5H-NnLvq8M|V8 Expression Scope design docs}</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n\n</span><span class="s1">const kExpression = 0,</span><span class="s2">\n  </span><span class="s1">kMaybeArrowParameterDeclaration = 1,</span><span class="s2">\n  </span><span class="s1">kMaybeAsyncArrowParameterDeclaration = 2,</span><span class="s2">\n  </span><span class="s1">kParameterDeclaration = 3;</span><span class="s2">\n\n</span><span class="s1">type ExpressionScopeType = 0 | 1 | 2 | 3;</span><span class="s2">\n\n</span><span class="s1">class ExpressionScope {</span><span class="s2">\n  </span><span class="s1">type: ExpressionScopeType;</span><span class="s2">\n\n  </span><span class="s1">constructor(type: ExpressionScopeType = kExpression) {</span><span class="s2">\n    </span><span class="s1">this.type = type;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">canBeArrowParameterDeclaration(): this is ArrowHeadParsingScope {</span><span class="s2">\n    </span><span class="s1">return (</span><span class="s2">\n      </span><span class="s1">this.type === kMaybeAsyncArrowParameterDeclaration ||</span><span class="s2">\n      </span><span class="s1">this.type === kMaybeArrowParameterDeclaration</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">isCertainlyParameterDeclaration() {</span><span class="s2">\n    </span><span class="s1">return this.type === kParameterDeclaration;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">type ArrowHeadParsingParameterInitializerError =</span><span class="s2">\n  </span><span class="s1">| typeof Errors.AwaitExpressionFormalParameter</span><span class="s2">\n  </span><span class="s1">| typeof Errors.YieldInParameter;</span><span class="s2">\n</span><span class="s1">type ArrowHeadParsingDeclarationError =</span><span class="s2">\n  </span><span class="s1">| ArrowHeadParsingParameterInitializerError</span><span class="s2">\n  </span><span class="s1">| typeof Errors.InvalidParenthesizedAssignment</span><span class="s2">\n  </span><span class="s1">| typeof Errors.AwaitBindingIdentifier;</span><span class="s2">\n\n</span><span class="s1">class ArrowHeadParsingScope extends ExpressionScope {</span><span class="s2">\n  </span><span class="s1">declarationErrors: Map&lt;number, [ParseErrorConstructor&lt;{}&gt;, Position]&gt; =</span><span class="s2">\n    </span><span class="s1">new Map();</span><span class="s2">\n  </span><span class="s1">constructor(type: 1 | 2) {</span><span class="s2">\n    </span><span class="s1">super(type);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">recordDeclarationError(</span><span class="s2">\n    </span><span class="s1">ParsingErrorClass: ParseErrorConstructor&lt;{}&gt;,</span><span class="s2">\n    </span><span class="s1">{</span><span class="s2">\n      </span><span class="s1">at,</span><span class="s2">\n    </span><span class="s1">}: {</span><span class="s2">\n      </span><span class="s1">at: Position;</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n  </span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">const index = at.index;</span><span class="s2">\n\n    </span><span class="s1">this.declarationErrors.set(index, [ParsingErrorClass, at]);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">clearDeclarationError(index: number) {</span><span class="s2">\n    </span><span class="s1">this.declarationErrors.delete(index);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">iterateErrors(</span><span class="s2">\n    </span><span class="s1">iterator: (a: [ArrowHeadParsingDeclarationError, Position]) =&gt; void,</span><span class="s2">\n  </span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">this.declarationErrors.forEach(iterator);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">export default class ExpressionScopeHandler {</span><span class="s2">\n  </span><span class="s1">parser: Tokenizer;</span><span class="s2">\n  </span><span class="s1">stack: Array&lt;ExpressionScope&gt; = [new ExpressionScope()];</span><span class="s2">\n\n  </span><span class="s1">constructor(parser: Tokenizer) {</span><span class="s2">\n    </span><span class="s1">this.parser = parser;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">enter(scope: ExpressionScope) {</span><span class="s2">\n    </span><span class="s1">this.stack.push(scope);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">exit() {</span><span class="s2">\n    </span><span class="s1">this.stack.pop();</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* Record likely parameter initializer errors</span><span class="s2">\n   </span><span class="s1">*</span><span class="s2">\n   </span><span class="s1">* When current scope is a ParameterDeclaration, the error will be thrown immediately,</span><span class="s2">\n   </span><span class="s1">* otherwise it will be recorded to any ancestry MaybeArrowParameterDeclaration and</span><span class="s2">\n   </span><span class="s1">* MaybeAsyncArrowParameterDeclaration scope until an Expression scope is seen.</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">recordParameterInitializerError(</span><span class="s2">\n    </span><span class="s1">toParseError: ArrowHeadParsingParameterInitializerError,</span><span class="s2">\n    </span><span class="s1">{</span><span class="s2">\n      </span><span class="s1">at: node,</span><span class="s2">\n    </span><span class="s1">}: {</span><span class="s2">\n      </span><span class="s1">at: Node;</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n  </span><span class="s1">): void {</span><span class="s2">\n    </span><span class="s1">const origin = { at: node.loc.start };</span><span class="s2">\n    </span><span class="s1">const { stack } = this;</span><span class="s2">\n    </span><span class="s1">let i = stack.length - 1;</span><span class="s2">\n    </span><span class="s1">let scope: ExpressionScope = stack[i];</span><span class="s2">\n    </span><span class="s1">while (!scope.isCertainlyParameterDeclaration()) {</span><span class="s2">\n      </span><span class="s1">if (scope.canBeArrowParameterDeclaration()) {</span><span class="s2">\n        </span><span class="s1">scope.recordDeclarationError(toParseError, origin);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">/*:: invariant(scope.type == kExpression) */</span><span class="s2">\n        </span><span class="s1">// Type-Expression is the boundary where initializer error can populate to</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">scope = stack[--i];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">this.parser.raise(toParseError, origin);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* Record errors that must be thrown if the current pattern ends up being an arrow</span><span class="s2">\n   </span><span class="s1">* function parameter. This is used to record parenthesized identifiers, and to record</span><span class="s2">\n   </span><span class="s1">* </span><span class="s2">\&quot;</span><span class="s1">a as T</span><span class="s2">\&quot; </span><span class="s1">and </span><span class="s2">\&quot;</span><span class="s1">&lt;T&gt; a</span><span class="s2">\&quot; </span><span class="s1">type assertions when parsing typescript.</span><span class="s2">\n   </span><span class="s1">*</span><span class="s2">\n   </span><span class="s1">* A parenthesized identifier (or type assertion) in LHS can be ambiguous because the assignment</span><span class="s2">\n   </span><span class="s1">* can be transformed to an assignable later, but not vice versa:</span><span class="s2">\n   </span><span class="s1">* For example, in `([(a) = []] = []) =&gt; {}`, we think `(a) = []` is an LHS in `[(a) = []]`,</span><span class="s2">\n   </span><span class="s1">* an LHS within `[(a) = []] = []`. However the LHS chain is then transformed by toAssignable,</span><span class="s2">\n   </span><span class="s1">* and we should throw assignment `(a)`, which is only valid in LHS. Hence we record the</span><span class="s2">\n   </span><span class="s1">* location of parenthesized `(a)` to current scope if it is one of MaybeArrowParameterDeclaration</span><span class="s2">\n   </span><span class="s1">* and MaybeAsyncArrowParameterDeclaration</span><span class="s2">\n   </span><span class="s1">*</span><span class="s2">\n   </span><span class="s1">* Unlike `recordParameterInitializerError`, we don't record to ancestry scope because we</span><span class="s2">\n   </span><span class="s1">* validate arrow head parsing scope before exit, and then the LHS will be unambiguous:</span><span class="s2">\n   </span><span class="s1">* For example, in `( x = ( [(a) = []] = [] ) ) =&gt; {}`, we should not record `(a)` in `( x = ... ) =&gt;`</span><span class="s2">\n   </span><span class="s1">* arrow scope because when we finish parsing `( [(a) = []] = [] )`, it is an unambiguous assignment</span><span class="s2">\n   </span><span class="s1">* expression and can not be cast to pattern</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">recordArrowParameterBindingError(</span><span class="s2">\n    </span><span class="s1">error: ParseErrorConstructor&lt;{}&gt;,</span><span class="s2">\n    </span><span class="s1">{</span><span class="s2">\n      </span><span class="s1">at: node,</span><span class="s2">\n    </span><span class="s1">}: {</span><span class="s2">\n      </span><span class="s1">at: Node;</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n  </span><span class="s1">): void {</span><span class="s2">\n    </span><span class="s1">const { stack } = this;</span><span class="s2">\n    </span><span class="s1">const scope: ExpressionScope = stack[stack.length - 1];</span><span class="s2">\n    </span><span class="s1">const origin = { at: node.loc.start };</span><span class="s2">\n    </span><span class="s1">if (scope.isCertainlyParameterDeclaration()) {</span><span class="s2">\n      </span><span class="s1">this.parser.raise(error, origin);</span><span class="s2">\n    </span><span class="s1">} else if (scope.canBeArrowParameterDeclaration()) {</span><span class="s2">\n      </span><span class="s1">scope.recordDeclarationError(error, origin);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* Record likely async arrow parameter errors</span><span class="s2">\n   </span><span class="s1">*</span><span class="s2">\n   </span><span class="s1">* Errors will be recorded to any ancestry MaybeAsyncArrowParameterDeclaration</span><span class="s2">\n   </span><span class="s1">* scope until an Expression scope is seen.</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">recordAsyncArrowParametersError({ at }: { at: Position }): void {</span><span class="s2">\n    </span><span class="s1">const { stack } = this;</span><span class="s2">\n    </span><span class="s1">let i = stack.length - 1;</span><span class="s2">\n    </span><span class="s1">let scope: ExpressionScope = stack[i];</span><span class="s2">\n    </span><span class="s1">while (scope.canBeArrowParameterDeclaration()) {</span><span class="s2">\n      </span><span class="s1">if (scope.type === kMaybeAsyncArrowParameterDeclaration) {</span><span class="s2">\n        </span><span class="s1">scope.recordDeclarationError(Errors.AwaitBindingIdentifier, { at });</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">scope = stack[--i];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">validateAsPattern(): void {</span><span class="s2">\n    </span><span class="s1">const { stack } = this;</span><span class="s2">\n    </span><span class="s1">const currentScope = stack[stack.length - 1];</span><span class="s2">\n    </span><span class="s1">if (!currentScope.canBeArrowParameterDeclaration()) return;</span><span class="s2">\n    </span><span class="s1">currentScope.iterateErrors(([toParseError, loc]) =&gt; {</span><span class="s2">\n      </span><span class="s1">this.parser.raise(toParseError, { at: loc });</span><span class="s2">\n      </span><span class="s1">// iterate from parent scope</span><span class="s2">\n      </span><span class="s1">let i = stack.length - 2;</span><span class="s2">\n      </span><span class="s1">let scope = stack[i];</span><span class="s2">\n      </span><span class="s1">while (scope.canBeArrowParameterDeclaration()) {</span><span class="s2">\n        </span><span class="s1">scope.clearDeclarationError(loc.index);</span><span class="s2">\n        </span><span class="s1">scope = stack[--i];</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">export function newParameterDeclarationScope() {</span><span class="s2">\n  </span><span class="s1">return new ExpressionScope(kParameterDeclaration);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">export function newArrowHeadScope() {</span><span class="s2">\n  </span><span class="s1">return new ArrowHeadParsingScope(kMaybeArrowParameterDeclaration);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">export function newAsyncArrowScope() {</span><span class="s2">\n  </span><span class="s1">return new ArrowHeadParsingScope(kMaybeAsyncArrowParameterDeclaration);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">export function newExpressionScope() {</span><span class="s2">\n  </span><span class="s1">return new ExpressionScope();</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">&quot;</span><span class="s2">,</span><span class="s1">&quot;export const // Initial Parameter flags</span><span class="s2">\n  </span><span class="s1">PARAM = 0b0000,</span><span class="s2">\n  </span><span class="s1">// track [Yield] production parameter</span><span class="s2">\n  </span><span class="s1">PARAM_YIELD = 0b0001,</span><span class="s2">\n  </span><span class="s1">// track [Await] production parameter</span><span class="s2">\n  </span><span class="s1">PARAM_AWAIT = 0b0010,</span><span class="s2">\n  </span><span class="s1">// track [Return] production parameter</span><span class="s2">\n  </span><span class="s1">PARAM_RETURN = 0b0100,</span><span class="s2">\n  </span><span class="s1">PARAM_IN = 0b1000; // track [In] production parameter</span><span class="s2">\n\n</span><span class="s1">// ProductionParameterHandler is a stack fashioned production parameter tracker</span><span class="s2">\n</span><span class="s1">// https://tc39.es/ecma262/#sec-grammar-notation</span><span class="s2">\n</span><span class="s1">// The tracked parameters are defined above.</span><span class="s2">\n</span><span class="s1">//</span><span class="s2">\n</span><span class="s1">// Whenever [+Await]/[+Yield] appears in the right-hand sides of a production,</span><span class="s2">\n</span><span class="s1">// we must enter a new tracking stack. For example when parsing</span><span class="s2">\n</span><span class="s1">//</span><span class="s2">\n</span><span class="s1">// AsyncFunctionDeclaration [Yield, Await]:</span><span class="s2">\n</span><span class="s1">//   async [no LineTerminator here] function BindingIdentifier[?Yield, ?Await]</span><span class="s2">\n</span><span class="s1">//     ( FormalParameters[~Yield, +Await] ) { AsyncFunctionBody }</span><span class="s2">\n</span><span class="s1">//</span><span class="s2">\n</span><span class="s1">// we must follow such process:</span><span class="s2">\n</span><span class="s1">//</span><span class="s2">\n</span><span class="s1">// 1. parse async keyword</span><span class="s2">\n</span><span class="s1">// 2. parse function keyword</span><span class="s2">\n</span><span class="s1">// 3. parse bindingIdentifier &lt;= inherit current parameters: [?Await]</span><span class="s2">\n</span><span class="s1">// 4. enter new stack with (PARAM_AWAIT)</span><span class="s2">\n</span><span class="s1">// 5. parse formal parameters &lt;= must have [Await] parameter [+Await]</span><span class="s2">\n</span><span class="s1">// 6. parse function body</span><span class="s2">\n</span><span class="s1">// 7. exit current stack</span><span class="s2">\n\n</span><span class="s1">export type ParamKind = number;</span><span class="s2">\n\n</span><span class="s1">// todo(flow-&gt;ts) - check if more granular type can be used,</span><span class="s2">\n</span><span class="s1">//  type below is not good because things like PARAM_AWAIT|PARAM_YIELD are not included</span><span class="s2">\n</span><span class="s1">// export type ParamKind =</span><span class="s2">\n</span><span class="s1">//   | typeof PARAM</span><span class="s2">\n</span><span class="s1">//   | typeof PARAM_AWAIT</span><span class="s2">\n</span><span class="s1">//   | typeof PARAM_IN</span><span class="s2">\n</span><span class="s1">//   | typeof PARAM_RETURN</span><span class="s2">\n</span><span class="s1">//   | typeof PARAM_YIELD;</span><span class="s2">\n\n</span><span class="s1">export default class ProductionParameterHandler {</span><span class="s2">\n  </span><span class="s1">stacks: Array&lt;number&gt; = [];</span><span class="s2">\n  </span><span class="s1">enter(flags: number) {</span><span class="s2">\n    </span><span class="s1">this.stacks.push(flags);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">exit() {</span><span class="s2">\n    </span><span class="s1">this.stacks.pop();</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">currentFlags(): number {</span><span class="s2">\n    </span><span class="s1">return this.stacks[this.stacks.length - 1];</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">get hasAwait(): boolean {</span><span class="s2">\n    </span><span class="s1">return (this.currentFlags() &amp; PARAM_AWAIT) &gt; 0;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">get hasYield(): boolean {</span><span class="s2">\n    </span><span class="s1">return (this.currentFlags() &amp; PARAM_YIELD) &gt; 0;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">get hasReturn(): boolean {</span><span class="s2">\n    </span><span class="s1">return (this.currentFlags() &amp; PARAM_RETURN) &gt; 0;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">get hasIn(): boolean {</span><span class="s2">\n    </span><span class="s1">return (this.currentFlags() &amp; PARAM_IN) &gt; 0;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">export function functionFlags(</span><span class="s2">\n  </span><span class="s1">isAsync: boolean,</span><span class="s2">\n  </span><span class="s1">isGenerator: boolean,</span><span class="s2">\n</span><span class="s1">): ParamKind {</span><span class="s2">\n  </span><span class="s1">return (isAsync ? PARAM_AWAIT : 0) | (isGenerator ? PARAM_YIELD : 0);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">&quot;</span><span class="s2">,</span><span class="s1">&quot;import { type Position } from </span><span class="s2">\&quot;</span><span class="s1">../util/location</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import {</span><span class="s2">\n  </span><span class="s1">tokenIsLiteralPropertyName,</span><span class="s2">\n  </span><span class="s1">tt,</span><span class="s2">\n  </span><span class="s1">type TokenType,</span><span class="s2">\n</span><span class="s1">} from </span><span class="s2">\&quot;</span><span class="s1">../tokenizer/types</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import Tokenizer from </span><span class="s2">\&quot;</span><span class="s1">../tokenizer</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type State from </span><span class="s2">\&quot;</span><span class="s1">../tokenizer/state</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type { EstreePropertyDefinition, Node, ObjectProperty } from </span><span class="s2">\&quot;</span><span class="s1">../types</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import { lineBreak, skipWhiteSpaceToLineBreak } from </span><span class="s2">\&quot;</span><span class="s1">../util/whitespace</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import { isIdentifierChar } from </span><span class="s2">\&quot;</span><span class="s1">../util/identifier</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import ClassScopeHandler from </span><span class="s2">\&quot;</span><span class="s1">../util/class-scope</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import ExpressionScopeHandler from </span><span class="s2">\&quot;</span><span class="s1">../util/expression-scope</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import { SCOPE_PROGRAM } from </span><span class="s2">\&quot;</span><span class="s1">../util/scopeflags</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import ProductionParameterHandler, {</span><span class="s2">\n  </span><span class="s1">PARAM_AWAIT,</span><span class="s2">\n  </span><span class="s1">PARAM,</span><span class="s2">\n</span><span class="s1">} from </span><span class="s2">\&quot;</span><span class="s1">../util/production-parameter</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import {</span><span class="s2">\n  </span><span class="s1">Errors,</span><span class="s2">\n  </span><span class="s1">type ParseError,</span><span class="s2">\n  </span><span class="s1">type ParseErrorConstructor,</span><span class="s2">\n</span><span class="s1">} from </span><span class="s2">\&quot;</span><span class="s1">../parse-error</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type Parser from </span><span class="s2">\&quot;</span><span class="s1">.</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">import type ScopeHandler from </span><span class="s2">\&quot;</span><span class="s1">../util/scope</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">type TryParse&lt;Node, Error, Thrown, Aborted, FailState&gt; = {</span><span class="s2">\n  </span><span class="s1">node: Node;</span><span class="s2">\n  </span><span class="s1">error: Error;</span><span class="s2">\n  </span><span class="s1">thrown: Thrown;</span><span class="s2">\n  </span><span class="s1">aborted: Aborted;</span><span class="s2">\n  </span><span class="s1">failState: FailState;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">// ## Parser utilities</span><span class="s2">\n\n</span><span class="s1">export default abstract class UtilParser extends Tokenizer {</span><span class="s2">\n  </span><span class="s1">// Forward-declaration: defined in parser/index.js</span><span class="s2">\n  </span><span class="s1">abstract getScopeHandler(): { new (...args: any): ScopeHandler };</span><span class="s2">\n\n  </span><span class="s1">addExtra(</span><span class="s2">\n    </span><span class="s1">node: Partial&lt;Node&gt;,</span><span class="s2">\n    </span><span class="s1">key: string,</span><span class="s2">\n    </span><span class="s1">value: any,</span><span class="s2">\n    </span><span class="s1">enumerable: boolean = true,</span><span class="s2">\n  </span><span class="s1">): void {</span><span class="s2">\n    </span><span class="s1">if (!node) return;</span><span class="s2">\n\n    </span><span class="s1">const extra = (node.extra = node.extra || {});</span><span class="s2">\n    </span><span class="s1">if (enumerable) {</span><span class="s2">\n      </span><span class="s1">extra[key] = value;</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">Object.defineProperty(extra, key, { enumerable, value });</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Tests whether parsed token is a contextual keyword.</span><span class="s2">\n\n  </span><span class="s1">isContextual(token: TokenType): boolean {</span><span class="s2">\n    </span><span class="s1">return this.state.type === token &amp;&amp; !this.state.containsEsc;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">isUnparsedContextual(nameStart: number, name: string): boolean {</span><span class="s2">\n    </span><span class="s1">const nameEnd = nameStart + name.length;</span><span class="s2">\n    </span><span class="s1">if (this.input.slice(nameStart, nameEnd) === name) {</span><span class="s2">\n      </span><span class="s1">const nextCh = this.input.charCodeAt(nameEnd);</span><span class="s2">\n      </span><span class="s1">return !(</span><span class="s2">\n        </span><span class="s1">isIdentifierChar(nextCh) ||</span><span class="s2">\n        </span><span class="s1">// check if `nextCh is between 0xd800 - 0xdbff,</span><span class="s2">\n        </span><span class="s1">// if `nextCh` is NaN, `NaN &amp; 0xfc00` is 0, the function</span><span class="s2">\n        </span><span class="s1">// returns true</span><span class="s2">\n        </span><span class="s1">(nextCh &amp; 0xfc00) === 0xd800</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return false;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">isLookaheadContextual(name: string): boolean {</span><span class="s2">\n    </span><span class="s1">const next = this.nextTokenStart();</span><span class="s2">\n    </span><span class="s1">return this.isUnparsedContextual(next, name);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Consumes contextual keyword if possible.</span><span class="s2">\n\n  </span><span class="s1">eatContextual(token: TokenType): boolean {</span><span class="s2">\n    </span><span class="s1">if (this.isContextual(token)) {</span><span class="s2">\n      </span><span class="s1">this.next();</span><span class="s2">\n      </span><span class="s1">return true;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return false;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Asserts that following token is given contextual keyword.</span><span class="s2">\n\n  </span><span class="s1">expectContextual(</span><span class="s2">\n    </span><span class="s1">token: TokenType,</span><span class="s2">\n    </span><span class="s1">toParseError?: ParseErrorConstructor&lt;any&gt;,</span><span class="s2">\n  </span><span class="s1">): void {</span><span class="s2">\n    </span><span class="s1">if (!this.eatContextual(token)) {</span><span class="s2">\n      </span><span class="s1">if (toParseError != null) {</span><span class="s2">\n        </span><span class="s1">throw this.raise(toParseError, { at: this.state.startLoc });</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">this.unexpected(null, token);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Test whether a semicolon can be inserted at the current position.</span><span class="s2">\n\n  </span><span class="s1">canInsertSemicolon(): boolean {</span><span class="s2">\n    </span><span class="s1">return (</span><span class="s2">\n      </span><span class="s1">this.match(tt.eof) ||</span><span class="s2">\n      </span><span class="s1">this.match(tt.braceR) ||</span><span class="s2">\n      </span><span class="s1">this.hasPrecedingLineBreak()</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">hasPrecedingLineBreak(): boolean {</span><span class="s2">\n    </span><span class="s1">return lineBreak.test(</span><span class="s2">\n      </span><span class="s1">this.input.slice(this.state.lastTokEndLoc.index, this.state.start),</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">hasFollowingLineBreak(): boolean {</span><span class="s2">\n    </span><span class="s1">skipWhiteSpaceToLineBreak.lastIndex = this.state.end;</span><span class="s2">\n    </span><span class="s1">return skipWhiteSpaceToLineBreak.test(this.input);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">isLineTerminator(): boolean {</span><span class="s2">\n    </span><span class="s1">return this.eat(tt.semi) || this.canInsertSemicolon();</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Consume a semicolon, or, failing that, see if we are allowed to</span><span class="s2">\n  </span><span class="s1">// pretend that there is a semicolon at this position.</span><span class="s2">\n\n  </span><span class="s1">semicolon(allowAsi: boolean = true): void {</span><span class="s2">\n    </span><span class="s1">if (allowAsi ? this.isLineTerminator() : this.eat(tt.semi)) return;</span><span class="s2">\n    </span><span class="s1">this.raise(Errors.MissingSemicolon, { at: this.state.lastTokEndLoc });</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Expect a token of a given type. If found, consume it, otherwise,</span><span class="s2">\n  </span><span class="s1">// raise an unexpected token error at given pos.</span><span class="s2">\n\n  </span><span class="s1">expect(type: TokenType, loc?: Position | null): void {</span><span class="s2">\n    </span><span class="s1">this.eat(type) || this.unexpected(loc, type);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// tryParse will clone parser state.</span><span class="s2">\n  </span><span class="s1">// It is expensive and should be used with cautions</span><span class="s2">\n  </span><span class="s1">tryParse&lt;T extends Node | ReadonlyArray&lt;Node&gt;&gt;(</span><span class="s2">\n    </span><span class="s1">fn: (abort: (node?: T) =&gt; never) =&gt; T,</span><span class="s2">\n    </span><span class="s1">oldState: State = this.state.clone(),</span><span class="s2">\n  </span><span class="s1">):</span><span class="s2">\n    </span><span class="s1">| TryParse&lt;T, null, false, false, null&gt;</span><span class="s2">\n    </span><span class="s1">| TryParse&lt;T | null, ParseError&lt;any&gt;, boolean, false, State&gt;</span><span class="s2">\n    </span><span class="s1">| TryParse&lt;T | null, null, false, true, State&gt; {</span><span class="s2">\n    </span><span class="s1">const abortSignal: {</span><span class="s2">\n      </span><span class="s1">node: T | null;</span><span class="s2">\n    </span><span class="s1">} = { node: null };</span><span class="s2">\n    </span><span class="s1">try {</span><span class="s2">\n      </span><span class="s1">const node = fn((node = null) =&gt; {</span><span class="s2">\n        </span><span class="s1">abortSignal.node = node;</span><span class="s2">\n        </span><span class="s1">throw abortSignal;</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">if (this.state.errors.length &gt; oldState.errors.length) {</span><span class="s2">\n        </span><span class="s1">const failState = this.state;</span><span class="s2">\n        </span><span class="s1">this.state = oldState;</span><span class="s2">\n        </span><span class="s1">// tokensLength should be preserved during error recovery mode</span><span class="s2">\n        </span><span class="s1">// since the parser does not halt and will instead parse the</span><span class="s2">\n        </span><span class="s1">// remaining tokens</span><span class="s2">\n        </span><span class="s1">this.state.tokensLength = failState.tokensLength;</span><span class="s2">\n        </span><span class="s1">return {</span><span class="s2">\n          </span><span class="s1">node,</span><span class="s2">\n          </span><span class="s1">error: failState.errors[oldState.errors.length],</span><span class="s2">\n          </span><span class="s1">thrown: false,</span><span class="s2">\n          </span><span class="s1">aborted: false,</span><span class="s2">\n          </span><span class="s1">failState,</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return {</span><span class="s2">\n        </span><span class="s1">node,</span><span class="s2">\n        </span><span class="s1">error: null,</span><span class="s2">\n        </span><span class="s1">thrown: false,</span><span class="s2">\n        </span><span class="s1">aborted: false,</span><span class="s2">\n        </span><span class="s1">failState: null,</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">} catch (error) {</span><span class="s2">\n      </span><span class="s1">const failState = this.state;</span><span class="s2">\n      </span><span class="s1">this.state = oldState;</span><span class="s2">\n      </span><span class="s1">if (error instanceof SyntaxError) {</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error casting general syntax error to parse error</span><span class="s2">\n        </span><span class="s1">return { node: null, error, thrown: true, aborted: false, failState };</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (error === abortSignal) {</span><span class="s2">\n        </span><span class="s1">return {</span><span class="s2">\n          </span><span class="s1">node: abortSignal.node,</span><span class="s2">\n          </span><span class="s1">error: null,</span><span class="s2">\n          </span><span class="s1">thrown: false,</span><span class="s2">\n          </span><span class="s1">aborted: true,</span><span class="s2">\n          </span><span class="s1">failState,</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">throw error;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">checkExpressionErrors(</span><span class="s2">\n    </span><span class="s1">refExpressionErrors: ExpressionErrors | undefined | null,</span><span class="s2">\n    </span><span class="s1">andThrow: boolean,</span><span class="s2">\n  </span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">if (!refExpressionErrors) return false;</span><span class="s2">\n    </span><span class="s1">const {</span><span class="s2">\n      </span><span class="s1">shorthandAssignLoc,</span><span class="s2">\n      </span><span class="s1">doubleProtoLoc,</span><span class="s2">\n      </span><span class="s1">privateKeyLoc,</span><span class="s2">\n      </span><span class="s1">optionalParametersLoc,</span><span class="s2">\n    </span><span class="s1">} = refExpressionErrors;</span><span class="s2">\n\n    </span><span class="s1">const hasErrors =</span><span class="s2">\n      </span><span class="s1">!!shorthandAssignLoc ||</span><span class="s2">\n      </span><span class="s1">!!doubleProtoLoc ||</span><span class="s2">\n      </span><span class="s1">!!optionalParametersLoc ||</span><span class="s2">\n      </span><span class="s1">!!privateKeyLoc;</span><span class="s2">\n\n    </span><span class="s1">if (!andThrow) {</span><span class="s2">\n      </span><span class="s1">return hasErrors;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">if (shorthandAssignLoc != null) {</span><span class="s2">\n      </span><span class="s1">this.raise(Errors.InvalidCoverInitializedName, {</span><span class="s2">\n        </span><span class="s1">at: shorthandAssignLoc,</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">if (doubleProtoLoc != null) {</span><span class="s2">\n      </span><span class="s1">this.raise(Errors.DuplicateProto, { at: doubleProtoLoc });</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">if (privateKeyLoc != null) {</span><span class="s2">\n      </span><span class="s1">this.raise(Errors.UnexpectedPrivateField, { at: privateKeyLoc });</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">if (optionalParametersLoc != null) {</span><span class="s2">\n      </span><span class="s1">this.unexpected(optionalParametersLoc);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* Test if current token is a literal property name</span><span class="s2">\n   </span><span class="s1">* https://tc39.es/ecma262/#prod-LiteralPropertyName</span><span class="s2">\n   </span><span class="s1">* LiteralPropertyName:</span><span class="s2">\n   </span><span class="s1">*   IdentifierName</span><span class="s2">\n   </span><span class="s1">*   StringLiteral</span><span class="s2">\n   </span><span class="s1">*   NumericLiteral</span><span class="s2">\n   </span><span class="s1">*   BigIntLiteral</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">isLiteralPropertyName(): boolean {</span><span class="s2">\n    </span><span class="s1">return tokenIsLiteralPropertyName(this.state.type);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* Test if given node is a PrivateName</span><span class="s2">\n   </span><span class="s1">* will be overridden in ESTree plugin</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">isPrivateName(node: Node): boolean {</span><span class="s2">\n    </span><span class="s1">return node.type === </span><span class="s2">\&quot;</span><span class="s1">PrivateName</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* Return the string value of a given private name</span><span class="s2">\n   </span><span class="s1">* WITHOUT `#`</span><span class="s2">\n   </span><span class="s1">* @see {@link https://tc39.es/ecma262/#sec-static-semantics-stringvalue}</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">getPrivateNameSV(node: Node): string {</span><span class="s2">\n    </span><span class="s1">return node.id.name;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* Return whether the given node is a member/optional chain that</span><span class="s2">\n   </span><span class="s1">* contains a private name as its property</span><span class="s2">\n   </span><span class="s1">* It is overridden in ESTree plugin</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">hasPropertyAsPrivateName(node: Node): boolean {</span><span class="s2">\n    </span><span class="s1">return (</span><span class="s2">\n      </span><span class="s1">(node.type === </span><span class="s2">\&quot;</span><span class="s1">MemberExpression</span><span class="s2">\&quot; </span><span class="s1">||</span><span class="s2">\n        </span><span class="s1">node.type === </span><span class="s2">\&quot;</span><span class="s1">OptionalMemberExpression</span><span class="s2">\&quot;</span><span class="s1">) &amp;&amp;</span><span class="s2">\n      </span><span class="s1">this.isPrivateName(node.property)</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">isObjectProperty(</span><span class="s2">\n    </span><span class="s1">node: Node,</span><span class="s2">\n  </span><span class="s1">): node is ObjectProperty | EstreePropertyDefinition {</span><span class="s2">\n    </span><span class="s1">return node.type === </span><span class="s2">\&quot;</span><span class="s1">ObjectProperty</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">isObjectMethod(node: Node): boolean {</span><span class="s2">\n    </span><span class="s1">return node.type === </span><span class="s2">\&quot;</span><span class="s1">ObjectMethod</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">initializeScopes(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">inModule: boolean = this.options.sourceType === </span><span class="s2">\&quot;</span><span class="s1">module</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">): () =&gt; void {</span><span class="s2">\n    </span><span class="s1">// Initialize state</span><span class="s2">\n    </span><span class="s1">const oldLabels = this.state.labels;</span><span class="s2">\n    </span><span class="s1">this.state.labels = [];</span><span class="s2">\n\n    </span><span class="s1">const oldExportedIdentifiers = this.exportedIdentifiers;</span><span class="s2">\n    </span><span class="s1">this.exportedIdentifiers = new Set();</span><span class="s2">\n\n    </span><span class="s1">// initialize scopes</span><span class="s2">\n    </span><span class="s1">const oldInModule = this.inModule;</span><span class="s2">\n    </span><span class="s1">this.inModule = inModule;</span><span class="s2">\n\n    </span><span class="s1">const oldScope = this.scope;</span><span class="s2">\n    </span><span class="s1">const ScopeHandler = this.getScopeHandler();</span><span class="s2">\n    </span><span class="s1">this.scope = new ScopeHandler(this, inModule);</span><span class="s2">\n\n    </span><span class="s1">const oldProdParam = this.prodParam;</span><span class="s2">\n    </span><span class="s1">this.prodParam = new ProductionParameterHandler();</span><span class="s2">\n\n    </span><span class="s1">const oldClassScope = this.classScope;</span><span class="s2">\n    </span><span class="s1">this.classScope = new ClassScopeHandler(this);</span><span class="s2">\n\n    </span><span class="s1">const oldExpressionScope = this.expressionScope;</span><span class="s2">\n    </span><span class="s1">this.expressionScope = new ExpressionScopeHandler(this);</span><span class="s2">\n\n    </span><span class="s1">return () =&gt; {</span><span class="s2">\n      </span><span class="s1">// Revert state</span><span class="s2">\n      </span><span class="s1">this.state.labels = oldLabels;</span><span class="s2">\n      </span><span class="s1">this.exportedIdentifiers = oldExportedIdentifiers;</span><span class="s2">\n\n      </span><span class="s1">// Revert scopes</span><span class="s2">\n      </span><span class="s1">this.inModule = oldInModule;</span><span class="s2">\n      </span><span class="s1">this.scope = oldScope;</span><span class="s2">\n      </span><span class="s1">this.prodParam = oldProdParam;</span><span class="s2">\n      </span><span class="s1">this.classScope = oldClassScope;</span><span class="s2">\n      </span><span class="s1">this.expressionScope = oldExpressionScope;</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">enterInitialScopes() {</span><span class="s2">\n    </span><span class="s1">let paramFlags = PARAM;</span><span class="s2">\n    </span><span class="s1">if (this.inModule) {</span><span class="s2">\n      </span><span class="s1">paramFlags |= PARAM_AWAIT;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">this.scope.enter(SCOPE_PROGRAM);</span><span class="s2">\n    </span><span class="s1">this.prodParam.enter(paramFlags);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">checkDestructuringPrivate(refExpressionErrors: ExpressionErrors) {</span><span class="s2">\n    </span><span class="s1">const { privateKeyLoc } = refExpressionErrors;</span><span class="s2">\n    </span><span class="s1">if (privateKeyLoc !== null) {</span><span class="s2">\n      </span><span class="s1">this.expectPlugin(</span><span class="s2">\&quot;</span><span class="s1">destructuringPrivate</span><span class="s2">\&quot;</span><span class="s1">, privateKeyLoc);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* The ExpressionErrors is a context struct used to track ambiguous patterns</span><span class="s2">\n </span><span class="s1">* When we are sure the parsed pattern is a RHS, which means it is not a pattern,</span><span class="s2">\n </span><span class="s1">* we will throw on this position on invalid assign syntax, otherwise it will be reset to -1</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* Types of ExpressionErrors:</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* - **shorthandAssignLoc**: track initializer `=` position</span><span class="s2">\n </span><span class="s1">* - **doubleProtoLoc**: track the duplicate `__proto__` key position</span><span class="s2">\n </span><span class="s1">* - **privateKey**: track private key `#p` position</span><span class="s2">\n </span><span class="s1">* - **optionalParametersLoc**: track the optional parameter (`?`).</span><span class="s2">\n </span><span class="s1">* It's only used by typescript and flow plugins</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">export class ExpressionErrors {</span><span class="s2">\n  </span><span class="s1">shorthandAssignLoc: Position | undefined | null = null;</span><span class="s2">\n  </span><span class="s1">doubleProtoLoc: Position | undefined | null = null;</span><span class="s2">\n  </span><span class="s1">privateKeyLoc: Position | undefined | null = null;</span><span class="s2">\n  </span><span class="s1">optionalParametersLoc: Position | undefined | null = null;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">&quot;</span><span class="s2">,</span><span class="s1">&quot;import type Parser from </span><span class="s2">\&quot;</span><span class="s1">./index</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import UtilParser from </span><span class="s2">\&quot;</span><span class="s1">./util</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import { SourceLocation, type Position } from </span><span class="s2">\&quot;</span><span class="s1">../util/location</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type { Comment, Node as NodeType, NodeBase } from </span><span class="s2">\&quot;</span><span class="s1">../types</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">// Start an AST node, attaching a start offset.</span><span class="s2">\n\n</span><span class="s1">class Node implements NodeBase {</span><span class="s2">\n  </span><span class="s1">constructor(parser: Parser, pos: number, loc: Position) {</span><span class="s2">\n    </span><span class="s1">this.start = pos;</span><span class="s2">\n    </span><span class="s1">this.end = 0;</span><span class="s2">\n    </span><span class="s1">this.loc = new SourceLocation(loc);</span><span class="s2">\n    </span><span class="s1">if (parser?.options.ranges) this.range = [pos, 0];</span><span class="s2">\n    </span><span class="s1">if (parser?.filename) this.loc.filename = parser.filename;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">type: string = </span><span class="s2">\&quot;\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">declare start: number;</span><span class="s2">\n  </span><span class="s1">declare end: number;</span><span class="s2">\n  </span><span class="s1">declare loc: SourceLocation;</span><span class="s2">\n  </span><span class="s1">declare range: [number, number];</span><span class="s2">\n  </span><span class="s1">declare leadingComments: Array&lt;Comment&gt;;</span><span class="s2">\n  </span><span class="s1">declare trailingComments: Array&lt;Comment&gt;;</span><span class="s2">\n  </span><span class="s1">declare innerComments: Array&lt;Comment&gt;;</span><span class="s2">\n  </span><span class="s1">declare extra: {</span><span class="s2">\n    </span><span class="s1">[key: string]: any;</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">const NodePrototype = Node.prototype;</span><span class="s2">\n\n</span><span class="s1">if (!process.env.BABEL_8_BREAKING) {</span><span class="s2">\n  </span><span class="s1">// @ts-expect-error __clone is not defined in Node prototype</span><span class="s2">\n  </span><span class="s1">NodePrototype.__clone = function (): Node {</span><span class="s2">\n    </span><span class="s1">const newNode = new Node(undefined, this.start, this.loc.start);</span><span class="s2">\n    </span><span class="s1">const keys = Object.keys(this) as (keyof Node)[];</span><span class="s2">\n    </span><span class="s1">for (let i = 0, length = keys.length; i &lt; length; i++) {</span><span class="s2">\n      </span><span class="s1">const key = keys[i];</span><span class="s2">\n      </span><span class="s1">// Do not clone comments that are already attached to the node</span><span class="s2">\n      </span><span class="s1">if (</span><span class="s2">\n        </span><span class="s1">key !== </span><span class="s2">\&quot;</span><span class="s1">leadingComments</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n        </span><span class="s1">key !== </span><span class="s2">\&quot;</span><span class="s1">trailingComments</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n        </span><span class="s1">key !== </span><span class="s2">\&quot;</span><span class="s1">innerComments</span><span class="s2">\&quot;\n      </span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error cloning this to newNode</span><span class="s2">\n        </span><span class="s1">newNode[key] = this[key];</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">return newNode;</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function clonePlaceholder(node: any): any {</span><span class="s2">\n  </span><span class="s1">return cloneIdentifier(node);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">export function cloneIdentifier(node: any): any {</span><span class="s2">\n  </span><span class="s1">// We don't need to clone `typeAnnotations` and `optional`: because</span><span class="s2">\n  </span><span class="s1">// cloneIdentifier is only used in object shorthand and named import/export.</span><span class="s2">\n  </span><span class="s1">// Neither of them allow type annotations after the identifier or optional identifier</span><span class="s2">\n  </span><span class="s1">const { type, start, end, loc, range, extra, name } = node;</span><span class="s2">\n  </span><span class="s1">const cloned = Object.create(NodePrototype);</span><span class="s2">\n  </span><span class="s1">cloned.type = type;</span><span class="s2">\n  </span><span class="s1">cloned.start = start;</span><span class="s2">\n  </span><span class="s1">cloned.end = end;</span><span class="s2">\n  </span><span class="s1">cloned.loc = loc;</span><span class="s2">\n  </span><span class="s1">cloned.range = range;</span><span class="s2">\n  </span><span class="s1">cloned.extra = extra;</span><span class="s2">\n  </span><span class="s1">cloned.name = name;</span><span class="s2">\n  </span><span class="s1">if (type === </span><span class="s2">\&quot;</span><span class="s1">Placeholder</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">cloned.expectedNode = node.expectedNode;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return cloned;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">export function cloneStringLiteral(node: any): any {</span><span class="s2">\n  </span><span class="s1">const { type, start, end, loc, range, extra } = node;</span><span class="s2">\n  </span><span class="s1">if (type === </span><span class="s2">\&quot;</span><span class="s1">Placeholder</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">return clonePlaceholder(node);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">const cloned = Object.create(NodePrototype);</span><span class="s2">\n  </span><span class="s1">cloned.type = type;</span><span class="s2">\n  </span><span class="s1">cloned.start = start;</span><span class="s2">\n  </span><span class="s1">cloned.end = end;</span><span class="s2">\n  </span><span class="s1">cloned.loc = loc;</span><span class="s2">\n  </span><span class="s1">cloned.range = range;</span><span class="s2">\n  </span><span class="s1">if (node.raw !== undefined) {</span><span class="s2">\n    </span><span class="s1">// estree set node.raw instead of node.extra</span><span class="s2">\n    </span><span class="s1">cloned.raw = node.raw;</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">cloned.extra = extra;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">cloned.value = node.value;</span><span class="s2">\n  </span><span class="s1">return cloned;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">export type Undone&lt;T extends NodeType&gt; = Omit&lt;T, </span><span class="s2">\&quot;</span><span class="s1">type</span><span class="s2">\&quot;</span><span class="s1">&gt;;</span><span class="s2">\n\n</span><span class="s1">export abstract class NodeUtils extends UtilParser {</span><span class="s2">\n  </span><span class="s1">startNode&lt;T extends NodeType&gt;(): Undone&lt;T&gt; {</span><span class="s2">\n    </span><span class="s1">// @ts-expect-error cast Node as Undone&lt;T&gt;</span><span class="s2">\n    </span><span class="s1">return new Node(this, this.state.start, this.state.startLoc);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">startNodeAt&lt;T extends NodeType&gt;(loc: Position): Undone&lt;T&gt; {</span><span class="s2">\n    </span><span class="s1">// @ts-expect-error cast Node as Undone&lt;T&gt;</span><span class="s2">\n    </span><span class="s1">return new Node(this, loc.index, loc);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">/** Start a new node with a previous node's location. */</span><span class="s2">\n  </span><span class="s1">startNodeAtNode&lt;T extends NodeType&gt;(type: Undone&lt;NodeType&gt;): Undone&lt;T&gt; {</span><span class="s2">\n    </span><span class="s1">return this.startNodeAt(type.loc.start);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Finish an AST node, adding `type` and `end` properties.</span><span class="s2">\n\n  </span><span class="s1">finishNode&lt;T extends NodeType&gt;(node: Undone&lt;T&gt;, type: T[</span><span class="s2">\&quot;</span><span class="s1">type</span><span class="s2">\&quot;</span><span class="s1">]): T {</span><span class="s2">\n    </span><span class="s1">return this.finishNodeAt(node, type, this.state.lastTokEndLoc);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Finish node at given position</span><span class="s2">\n\n  </span><span class="s1">finishNodeAt&lt;T extends NodeType&gt;(</span><span class="s2">\n    </span><span class="s1">node: Omit&lt;T, </span><span class="s2">\&quot;</span><span class="s1">type</span><span class="s2">\&quot;</span><span class="s1">&gt;,</span><span class="s2">\n    </span><span class="s1">type: T[</span><span class="s2">\&quot;</span><span class="s1">type</span><span class="s2">\&quot;</span><span class="s1">],</span><span class="s2">\n    </span><span class="s1">endLoc: Position,</span><span class="s2">\n  </span><span class="s1">): T {</span><span class="s2">\n    </span><span class="s1">if (process.env.NODE_ENV !== </span><span class="s2">\&quot;</span><span class="s1">production</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; node.end &gt; 0) {</span><span class="s2">\n      </span><span class="s1">throw new Error(</span><span class="s2">\n        \&quot;</span><span class="s1">Do not call finishNode*() twice on the same node.</span><span class="s2">\&quot; </span><span class="s1">+</span><span class="s2">\n          \&quot; </span><span class="s1">Instead use resetEndLocation() or change type directly.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// @ts-expect-error migrate to Babel types AST typings</span><span class="s2">\n    </span><span class="s1">node.type = type;</span><span class="s2">\n    </span><span class="s1">// @ts-expect-error migrate to Babel types AST typings</span><span class="s2">\n    </span><span class="s1">node.end = endLoc.index;</span><span class="s2">\n    </span><span class="s1">node.loc.end = endLoc;</span><span class="s2">\n    </span><span class="s1">if (this.options.ranges) node.range[1] = endLoc.index;</span><span class="s2">\n    </span><span class="s1">if (this.options.attachComment) this.processComment(node as T);</span><span class="s2">\n    </span><span class="s1">return node as T;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">resetStartLocation(node: NodeBase, startLoc: Position): void {</span><span class="s2">\n    </span><span class="s1">node.start = startLoc.index;</span><span class="s2">\n    </span><span class="s1">node.loc.start = startLoc;</span><span class="s2">\n    </span><span class="s1">if (this.options.ranges) node.range[0] = startLoc.index;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">resetEndLocation(</span><span class="s2">\n    </span><span class="s1">node: NodeBase,</span><span class="s2">\n    </span><span class="s1">endLoc: Position = this.state.lastTokEndLoc,</span><span class="s2">\n  </span><span class="s1">): void {</span><span class="s2">\n    </span><span class="s1">node.end = endLoc.index;</span><span class="s2">\n    </span><span class="s1">node.loc.end = endLoc;</span><span class="s2">\n    </span><span class="s1">if (this.options.ranges) node.range[1] = endLoc.index;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* Reset the start location of node to the start location of locationNode</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">resetStartLocationFromNode(node: NodeBase, locationNode: NodeBase): void {</span><span class="s2">\n    </span><span class="s1">this.resetStartLocation(node, locationNode.loc.start);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">&quot;</span><span class="s2">,</span><span class="s1">&quot;/*:: declare var invariant; */</span><span class="s2">\n\n</span><span class="s1">import type Parser from </span><span class="s2">\&quot;</span><span class="s1">../../parser</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import {</span><span class="s2">\n  </span><span class="s1">tokenIsIdentifier,</span><span class="s2">\n  </span><span class="s1">tokenIsKeyword,</span><span class="s2">\n  </span><span class="s1">tokenIsKeywordOrIdentifier,</span><span class="s2">\n  </span><span class="s1">tokenIsLiteralPropertyName,</span><span class="s2">\n  </span><span class="s1">tokenLabelName,</span><span class="s2">\n  </span><span class="s1">tt,</span><span class="s2">\n  </span><span class="s1">type TokenType,</span><span class="s2">\n  </span><span class="s1">tokenIsFlowInterfaceOrTypeOrOpaque,</span><span class="s2">\n</span><span class="s1">} from </span><span class="s2">\&quot;</span><span class="s1">../../tokenizer/types</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type * as N from </span><span class="s2">\&quot;</span><span class="s1">../../types</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type { Position } from </span><span class="s2">\&quot;</span><span class="s1">../../util/location</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import { types as tc } from </span><span class="s2">\&quot;</span><span class="s1">../../tokenizer/context</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import * as charCodes from </span><span class="s2">\&quot;</span><span class="s1">charcodes</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import { isIteratorStart } from </span><span class="s2">\&quot;</span><span class="s1">../../util/identifier</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import FlowScopeHandler from </span><span class="s2">\&quot;</span><span class="s1">./scope</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import {</span><span class="s2">\n  </span><span class="s1">BIND_LEXICAL,</span><span class="s2">\n  </span><span class="s1">BIND_VAR,</span><span class="s2">\n  </span><span class="s1">BIND_FUNCTION,</span><span class="s2">\n  </span><span class="s1">BIND_FLOW_DECLARE_FN,</span><span class="s2">\n  </span><span class="s1">SCOPE_ARROW,</span><span class="s2">\n  </span><span class="s1">SCOPE_FUNCTION,</span><span class="s2">\n  </span><span class="s1">SCOPE_OTHER,</span><span class="s2">\n  </span><span class="s1">type BindingTypes,</span><span class="s2">\n</span><span class="s1">} from </span><span class="s2">\&quot;</span><span class="s1">../../util/scopeflags</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type { ExpressionErrors } from </span><span class="s2">\&quot;</span><span class="s1">../../parser/util</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type { ParseStatementFlag } from </span><span class="s2">\&quot;</span><span class="s1">../../parser/statement</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import { Errors, ParseErrorEnum } from </span><span class="s2">\&quot;</span><span class="s1">../../parse-error</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import { cloneIdentifier, type Undone } from </span><span class="s2">\&quot;</span><span class="s1">../../parser/node</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">const reservedTypes = new Set([</span><span class="s2">\n  \&quot;</span><span class="s1">_</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">any</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">bool</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">boolean</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">empty</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">extends</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">false</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">interface</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">mixed</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">null</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">number</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">static</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">string</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">true</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">typeof</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  \&quot;</span><span class="s1">void</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n</span><span class="s1">]);</span><span class="s2">\n\n</span><span class="s1">/* eslint sort-keys: </span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot; </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">// The Errors key follows https://github.com/facebook/flow/blob/master/src/parser/parse_error.ml unless it does not exist</span><span class="s2">\n</span><span class="s1">const FlowErrors = ParseErrorEnum`flow`({</span><span class="s2">\n  </span><span class="s1">AmbiguousConditionalArrow:</span><span class="s2">\n    \&quot;</span><span class="s1">Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">AmbiguousDeclareModuleKind:</span><span class="s2">\n    \&quot;</span><span class="s1">Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">// TODO: When we get proper string enums in typescript make this ReservedType.</span><span class="s2">\n  </span><span class="s1">// Not really worth it to do the whole $Values dance with reservedTypes set.</span><span class="s2">\n  </span><span class="s1">AssignReservedType: ({ reservedType }: { reservedType: string }) =&gt;</span><span class="s2">\n    </span><span class="s1">`Cannot overwrite reserved type ${reservedType}.`,</span><span class="s2">\n  </span><span class="s1">DeclareClassElement:</span><span class="s2">\n    \&quot;</span><span class="s1">The `declare` modifier can only appear on class fields.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">DeclareClassFieldInitializer:</span><span class="s2">\n    \&quot;</span><span class="s1">Initializers are not allowed in fields with the `declare` modifier.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">DuplicateDeclareModuleExports:</span><span class="s2">\n    \&quot;</span><span class="s1">Duplicate `declare module.exports` statement.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">EnumBooleanMemberNotInitialized: ({</span><span class="s2">\n    </span><span class="s1">memberName,</span><span class="s2">\n    </span><span class="s1">enumName,</span><span class="s2">\n  </span><span class="s1">}: {</span><span class="s2">\n    </span><span class="s1">memberName: string;</span><span class="s2">\n    </span><span class="s1">enumName: string;</span><span class="s2">\n  </span><span class="s1">}) =&gt;</span><span class="s2">\n    </span><span class="s1">`Boolean enum members need to be initialized. Use either </span><span class="s2">\\</span><span class="s1">`${memberName} = true,</span><span class="s2">\\</span><span class="s1">` or </span><span class="s2">\\</span><span class="s1">`${memberName} = false,</span><span class="s2">\\</span><span class="s1">` in enum </span><span class="s2">\\</span><span class="s1">`${enumName}</span><span class="s2">\\</span><span class="s1">`.`,</span><span class="s2">\n  </span><span class="s1">EnumDuplicateMemberName: ({</span><span class="s2">\n    </span><span class="s1">memberName,</span><span class="s2">\n    </span><span class="s1">enumName,</span><span class="s2">\n  </span><span class="s1">}: {</span><span class="s2">\n    </span><span class="s1">memberName: string;</span><span class="s2">\n    </span><span class="s1">enumName: string;</span><span class="s2">\n  </span><span class="s1">}) =&gt;</span><span class="s2">\n    </span><span class="s1">`Enum member names need to be unique, but the name </span><span class="s2">\\</span><span class="s1">`${memberName}</span><span class="s2">\\</span><span class="s1">` has already been used before in enum </span><span class="s2">\\</span><span class="s1">`${enumName}</span><span class="s2">\\</span><span class="s1">`.`,</span><span class="s2">\n  </span><span class="s1">EnumInconsistentMemberValues: ({ enumName }: { enumName: string }) =&gt;</span><span class="s2">\n    </span><span class="s1">`Enum </span><span class="s2">\\</span><span class="s1">`${enumName}</span><span class="s2">\\</span><span class="s1">` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`,</span><span class="s2">\n  </span><span class="s1">EnumInvalidExplicitType: ({</span><span class="s2">\n    </span><span class="s1">invalidEnumType,</span><span class="s2">\n    </span><span class="s1">enumName,</span><span class="s2">\n  </span><span class="s1">}: {</span><span class="s2">\n    </span><span class="s1">invalidEnumType: string;</span><span class="s2">\n    </span><span class="s1">enumName: string;</span><span class="s2">\n  </span><span class="s1">}) =&gt;</span><span class="s2">\n    </span><span class="s1">`Enum type </span><span class="s2">\\</span><span class="s1">`${invalidEnumType}</span><span class="s2">\\</span><span class="s1">` is not valid. Use one of </span><span class="s2">\\</span><span class="s1">`boolean</span><span class="s2">\\</span><span class="s1">`, </span><span class="s2">\\</span><span class="s1">`number</span><span class="s2">\\</span><span class="s1">`, </span><span class="s2">\\</span><span class="s1">`string</span><span class="s2">\\</span><span class="s1">`, or </span><span class="s2">\\</span><span class="s1">`symbol</span><span class="s2">\\</span><span class="s1">` in enum </span><span class="s2">\\</span><span class="s1">`${enumName}</span><span class="s2">\\</span><span class="s1">`.`,</span><span class="s2">\n  </span><span class="s1">EnumInvalidExplicitTypeUnknownSupplied: ({</span><span class="s2">\n    </span><span class="s1">enumName,</span><span class="s2">\n  </span><span class="s1">}: {</span><span class="s2">\n    </span><span class="s1">enumName: string;</span><span class="s2">\n  </span><span class="s1">}) =&gt;</span><span class="s2">\n    </span><span class="s1">`Supplied enum type is not valid. Use one of </span><span class="s2">\\</span><span class="s1">`boolean</span><span class="s2">\\</span><span class="s1">`, </span><span class="s2">\\</span><span class="s1">`number</span><span class="s2">\\</span><span class="s1">`, </span><span class="s2">\\</span><span class="s1">`string</span><span class="s2">\\</span><span class="s1">`, or </span><span class="s2">\\</span><span class="s1">`symbol</span><span class="s2">\\</span><span class="s1">` in enum </span><span class="s2">\\</span><span class="s1">`${enumName}</span><span class="s2">\\</span><span class="s1">`.`,</span><span class="s2">\n\n  </span><span class="s1">// TODO: When moving to typescript, we should either have each of the</span><span class="s2">\n  </span><span class="s1">// following errors only accept the specific strings they want:</span><span class="s2">\n  </span><span class="s1">//</span><span class="s2">\n  </span><span class="s1">// ...PrimaryType: explicitType: </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">number</span><span class="s2">\&quot; </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">boolean</span><span class="s2">\&quot;\n  </span><span class="s1">// ...SymbolType: explicitType: </span><span class="s2">\&quot;</span><span class="s1">symbol</span><span class="s2">\&quot;\n  </span><span class="s1">// ...UnknownType: explicitType: null</span><span class="s2">\n  </span><span class="s1">//</span><span class="s2">\n  </span><span class="s1">// Or, alternatively, merge these three errors together into one</span><span class="s2">\n  </span><span class="s1">// `EnumInvalidMemberInitializer` error that can accept `EnumExplicitType`</span><span class="s2">\n  </span><span class="s1">// without alteration, and then just have its message change based on the</span><span class="s2">\n  </span><span class="s1">// explicitType.</span><span class="s2">\n  </span><span class="s1">EnumInvalidMemberInitializerPrimaryType: ({</span><span class="s2">\n    </span><span class="s1">enumName,</span><span class="s2">\n    </span><span class="s1">memberName,</span><span class="s2">\n    </span><span class="s1">explicitType,</span><span class="s2">\n  </span><span class="s1">}: {</span><span class="s2">\n    </span><span class="s1">enumName: string;</span><span class="s2">\n    </span><span class="s1">memberName: string;</span><span class="s2">\n    </span><span class="s1">explicitType: EnumExplicitType;</span><span class="s2">\n  </span><span class="s1">}) =&gt;</span><span class="s2">\n    </span><span class="s1">`Enum </span><span class="s2">\\</span><span class="s1">`${enumName}</span><span class="s2">\\</span><span class="s1">` has type </span><span class="s2">\\</span><span class="s1">`${explicitType}</span><span class="s2">\\</span><span class="s1">`, so the initializer of </span><span class="s2">\\</span><span class="s1">`${memberName}</span><span class="s2">\\</span><span class="s1">` needs to be a ${explicitType} literal.`,</span><span class="s2">\n  </span><span class="s1">EnumInvalidMemberInitializerSymbolType: ({</span><span class="s2">\n    </span><span class="s1">enumName,</span><span class="s2">\n    </span><span class="s1">memberName,</span><span class="s2">\n  </span><span class="s1">}: {</span><span class="s2">\n    </span><span class="s1">enumName: string;</span><span class="s2">\n    </span><span class="s1">memberName: string;</span><span class="s2">\n    </span><span class="s1">explicitType: EnumExplicitType;</span><span class="s2">\n  </span><span class="s1">}) =&gt;</span><span class="s2">\n    </span><span class="s1">`Symbol enum members cannot be initialized. Use </span><span class="s2">\\</span><span class="s1">`${memberName},</span><span class="s2">\\</span><span class="s1">` in enum </span><span class="s2">\\</span><span class="s1">`${enumName}</span><span class="s2">\\</span><span class="s1">`.`,</span><span class="s2">\n  </span><span class="s1">EnumInvalidMemberInitializerUnknownType: ({</span><span class="s2">\n    </span><span class="s1">enumName,</span><span class="s2">\n    </span><span class="s1">memberName,</span><span class="s2">\n  </span><span class="s1">}: {</span><span class="s2">\n    </span><span class="s1">enumName: string;</span><span class="s2">\n    </span><span class="s1">memberName: string;</span><span class="s2">\n    </span><span class="s1">explicitType: EnumExplicitType;</span><span class="s2">\n  </span><span class="s1">}) =&gt;</span><span class="s2">\n    </span><span class="s1">`The enum member initializer for </span><span class="s2">\\</span><span class="s1">`${memberName}</span><span class="s2">\\</span><span class="s1">` needs to be a literal (either a boolean, number, or string) in enum </span><span class="s2">\\</span><span class="s1">`${enumName}</span><span class="s2">\\</span><span class="s1">`.`,</span><span class="s2">\n  </span><span class="s1">EnumInvalidMemberName: ({</span><span class="s2">\n    </span><span class="s1">enumName,</span><span class="s2">\n    </span><span class="s1">memberName,</span><span class="s2">\n    </span><span class="s1">suggestion,</span><span class="s2">\n  </span><span class="s1">}: {</span><span class="s2">\n    </span><span class="s1">enumName: string;</span><span class="s2">\n    </span><span class="s1">memberName: string;</span><span class="s2">\n    </span><span class="s1">suggestion: string;</span><span class="s2">\n  </span><span class="s1">}) =&gt;</span><span class="s2">\n    </span><span class="s1">`Enum member names cannot start with lowercase 'a' through 'z'. Instead of using </span><span class="s2">\\</span><span class="s1">`${memberName}</span><span class="s2">\\</span><span class="s1">`, consider using </span><span class="s2">\\</span><span class="s1">`${suggestion}</span><span class="s2">\\</span><span class="s1">`, in enum </span><span class="s2">\\</span><span class="s1">`${enumName}</span><span class="s2">\\</span><span class="s1">`.`,</span><span class="s2">\n  </span><span class="s1">EnumNumberMemberNotInitialized: ({</span><span class="s2">\n    </span><span class="s1">enumName,</span><span class="s2">\n    </span><span class="s1">memberName,</span><span class="s2">\n  </span><span class="s1">}: {</span><span class="s2">\n    </span><span class="s1">enumName: string;</span><span class="s2">\n    </span><span class="s1">memberName: string;</span><span class="s2">\n  </span><span class="s1">}) =&gt;</span><span class="s2">\n    </span><span class="s1">`Number enum members need to be initialized, e.g. </span><span class="s2">\\</span><span class="s1">`${memberName} = 1</span><span class="s2">\\</span><span class="s1">` in enum </span><span class="s2">\\</span><span class="s1">`${enumName}</span><span class="s2">\\</span><span class="s1">`.`,</span><span class="s2">\n  </span><span class="s1">EnumStringMemberInconsistentlyInitailized: ({</span><span class="s2">\n    </span><span class="s1">enumName,</span><span class="s2">\n  </span><span class="s1">}: {</span><span class="s2">\n    </span><span class="s1">enumName: string;</span><span class="s2">\n  </span><span class="s1">}) =&gt;</span><span class="s2">\n    </span><span class="s1">`String enum members need to consistently either all use initializers, or use no initializers, in enum </span><span class="s2">\\</span><span class="s1">`${enumName}</span><span class="s2">\\</span><span class="s1">`.`,</span><span class="s2">\n  </span><span class="s1">GetterMayNotHaveThisParam: </span><span class="s2">\&quot;</span><span class="s1">A getter cannot have a `this` parameter.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ImportReflectionHasImportType:</span><span class="s2">\n    \&quot;</span><span class="s1">An `import module` declaration can not use `type` or `typeof` keyword.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ImportTypeShorthandOnlyInPureImport:</span><span class="s2">\n    \&quot;</span><span class="s1">The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">InexactInsideExact:</span><span class="s2">\n    \&quot;</span><span class="s1">Explicit inexact syntax cannot appear inside an explicit exact object type.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">InexactInsideNonObject:</span><span class="s2">\n    \&quot;</span><span class="s1">Explicit inexact syntax cannot appear in class or interface definitions.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">InexactVariance: </span><span class="s2">\&quot;</span><span class="s1">Explicit inexact syntax cannot have variance.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">InvalidNonTypeImportInDeclareModule:</span><span class="s2">\n    \&quot;</span><span class="s1">Imports within a `declare module` body must always be `import type` or `import typeof`.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">MissingTypeParamDefault:</span><span class="s2">\n    \&quot;</span><span class="s1">Type parameter declaration needs a default, since a preceding type parameter declaration has a default.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">NestedDeclareModule:</span><span class="s2">\n    \&quot;</span><span class="s1">`declare module` cannot be used inside another `declare module`.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">NestedFlowComment: </span><span class="s2">\&quot;</span><span class="s1">Cannot have a flow comment inside another flow comment.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">PatternIsOptional: {</span><span class="s2">\n    </span><span class="s1">message:</span><span class="s2">\n      \&quot;</span><span class="s1">A binding pattern parameter cannot be optional in an implementation signature.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">// For consistency in TypeScript and Flow error codes</span><span class="s2">\n    </span><span class="s1">...(!process.env.BABEL_8_BREAKING</span><span class="s2">\n      </span><span class="s1">? { reasonCode: </span><span class="s2">\&quot;</span><span class="s1">OptionalBindingPattern</span><span class="s2">\&quot; </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">: {}),</span><span class="s2">\n  </span><span class="s1">},</span><span class="s2">\n  </span><span class="s1">SetterMayNotHaveThisParam: </span><span class="s2">\&quot;</span><span class="s1">A setter cannot have a `this` parameter.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">SpreadVariance: </span><span class="s2">\&quot;</span><span class="s1">Spread properties cannot have variance.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ThisParamAnnotationRequired:</span><span class="s2">\n    \&quot;</span><span class="s1">A type annotation is required for the `this` parameter.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ThisParamBannedInConstructor:</span><span class="s2">\n    \&quot;</span><span class="s1">Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ThisParamMayNotBeOptional: </span><span class="s2">\&quot;</span><span class="s1">The `this` parameter cannot be optional.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ThisParamMustBeFirst:</span><span class="s2">\n    \&quot;</span><span class="s1">The `this` parameter must be the first function parameter.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ThisParamNoDefault: </span><span class="s2">\&quot;</span><span class="s1">The `this` parameter may not have a default value.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">TypeBeforeInitializer:</span><span class="s2">\n    \&quot;</span><span class="s1">Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">TypeCastInPattern:</span><span class="s2">\n    \&quot;</span><span class="s1">The type cast expression is expected to be wrapped with parenthesis.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">UnexpectedExplicitInexactInObject:</span><span class="s2">\n    \&quot;</span><span class="s1">Explicit inexact syntax must appear at the end of an inexact object.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">UnexpectedReservedType: ({ reservedType }: { reservedType: string }) =&gt;</span><span class="s2">\n    </span><span class="s1">`Unexpected reserved type ${reservedType}.`,</span><span class="s2">\n  </span><span class="s1">UnexpectedReservedUnderscore:</span><span class="s2">\n    \&quot;</span><span class="s1">`_` is only allowed as a type argument to call or new.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">UnexpectedSpaceBetweenModuloChecks:</span><span class="s2">\n    \&quot;</span><span class="s1">Spaces between `%` and `checks` are not allowed here.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">UnexpectedSpreadType:</span><span class="s2">\n    \&quot;</span><span class="s1">Spread operator cannot appear in class or interface definitions.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">UnexpectedSubtractionOperand:</span><span class="s2">\n    </span><span class="s1">'Unexpected token, expected </span><span class="s2">\&quot;</span><span class="s1">number</span><span class="s2">\&quot; </span><span class="s1">or </span><span class="s2">\&quot;</span><span class="s1">bigint</span><span class="s2">\&quot;</span><span class="s1">.',</span><span class="s2">\n  </span><span class="s1">UnexpectedTokenAfterTypeParameter:</span><span class="s2">\n    \&quot;</span><span class="s1">Expected an arrow function after this type parameter declaration.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">UnexpectedTypeParameterBeforeAsyncArrowFunction:</span><span class="s2">\n    \&quot;</span><span class="s1">Type parameters must come after the async keyword, e.g. instead of `&lt;T&gt; async () =&gt; {}`, use `async &lt;T&gt;() =&gt; {}`.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">UnsupportedDeclareExportKind: ({</span><span class="s2">\n    </span><span class="s1">unsupportedExportKind,</span><span class="s2">\n    </span><span class="s1">suggestion,</span><span class="s2">\n  </span><span class="s1">}: {</span><span class="s2">\n    </span><span class="s1">unsupportedExportKind: string;</span><span class="s2">\n    </span><span class="s1">suggestion: string;</span><span class="s2">\n  </span><span class="s1">}) =&gt;</span><span class="s2">\n    </span><span class="s1">`</span><span class="s2">\\</span><span class="s1">`declare export ${unsupportedExportKind}</span><span class="s2">\\</span><span class="s1">` is not supported. Use </span><span class="s2">\\</span><span class="s1">`${suggestion}</span><span class="s2">\\</span><span class="s1">` instead.`,</span><span class="s2">\n  </span><span class="s1">UnsupportedStatementInDeclareModule:</span><span class="s2">\n    \&quot;</span><span class="s1">Only declares and type imports are allowed inside declare module.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">UnterminatedFlowComment: </span><span class="s2">\&quot;</span><span class="s1">Unterminated flow-comment.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n</span><span class="s1">});</span><span class="s2">\n</span><span class="s1">/* eslint-disable sort-keys */</span><span class="s2">\n\n</span><span class="s1">function isEsModuleType(bodyElement: N.Node): boolean {</span><span class="s2">\n  </span><span class="s1">return (</span><span class="s2">\n    </span><span class="s1">bodyElement.type === </span><span class="s2">\&quot;</span><span class="s1">DeclareExportAllDeclaration</span><span class="s2">\&quot; </span><span class="s1">||</span><span class="s2">\n    </span><span class="s1">(bodyElement.type === </span><span class="s2">\&quot;</span><span class="s1">DeclareExportDeclaration</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n      </span><span class="s1">(!bodyElement.declaration ||</span><span class="s2">\n        </span><span class="s1">(bodyElement.declaration.type !== </span><span class="s2">\&quot;</span><span class="s1">TypeAlias</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n          </span><span class="s1">bodyElement.declaration.type !== </span><span class="s2">\&quot;</span><span class="s1">InterfaceDeclaration</span><span class="s2">\&quot;</span><span class="s1">)))</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function hasTypeImportKind(node: N.Node): boolean {</span><span class="s2">\n  </span><span class="s1">return node.importKind === </span><span class="s2">\&quot;</span><span class="s1">type</span><span class="s2">\&quot; </span><span class="s1">|| node.importKind === </span><span class="s2">\&quot;</span><span class="s1">typeof</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function isMaybeDefaultImport(type: TokenType): boolean {</span><span class="s2">\n  </span><span class="s1">return tokenIsKeywordOrIdentifier(type) &amp;&amp; type !== tt._from;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">const exportSuggestions = {</span><span class="s2">\n  </span><span class="s1">const: </span><span class="s2">\&quot;</span><span class="s1">declare export var</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">let: </span><span class="s2">\&quot;</span><span class="s1">declare export var</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">export type</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">interface: </span><span class="s2">\&quot;</span><span class="s1">export interface</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">// Like Array#filter, but returns a tuple [ acceptedElements, discardedElements ]</span><span class="s2">\n</span><span class="s1">function partition&lt;T&gt;(</span><span class="s2">\n  </span><span class="s1">list: T[],</span><span class="s2">\n  </span><span class="s1">test: (c: T, b: number, a: T[]) =&gt; boolean | undefined | null,</span><span class="s2">\n</span><span class="s1">): [T[], T[]] {</span><span class="s2">\n  </span><span class="s1">const list1: T[] = [];</span><span class="s2">\n  </span><span class="s1">const list2: T[] = [];</span><span class="s2">\n  </span><span class="s1">for (let i = 0; i &lt; list.length; i++) {</span><span class="s2">\n    </span><span class="s1">(test(list[i], i, list) ? list1 : list2).push(list[i]);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return [list1, list2];</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">const FLOW_PRAGMA_REGEX = /</span><span class="s2">\\</span><span class="s1">*?</span><span class="s2">\\</span><span class="s1">s*@((?:no)?flow)</span><span class="s2">\\</span><span class="s1">b/;</span><span class="s2">\n\n</span><span class="s1">// Flow enums types</span><span class="s2">\n</span><span class="s1">type EnumExplicitType = null | </span><span class="s2">\&quot;</span><span class="s1">boolean</span><span class="s2">\&quot; </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">number</span><span class="s2">\&quot; </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">symbol</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">type EnumContext = {</span><span class="s2">\n  </span><span class="s1">enumName: string;</span><span class="s2">\n  </span><span class="s1">explicitType: EnumExplicitType;</span><span class="s2">\n  </span><span class="s1">memberName: string;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">type EnumMemberInit =</span><span class="s2">\n  </span><span class="s1">| {</span><span class="s2">\n      </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">number</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n      </span><span class="s1">loc: Position;</span><span class="s2">\n      </span><span class="s1">value: N.Node;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">| {</span><span class="s2">\n      </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n      </span><span class="s1">loc: Position;</span><span class="s2">\n      </span><span class="s1">value: N.Node;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">| {</span><span class="s2">\n      </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">boolean</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n      </span><span class="s1">loc: Position;</span><span class="s2">\n      </span><span class="s1">value: N.Node;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">| {</span><span class="s2">\n      </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">invalid</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n      </span><span class="s1">loc: Position;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">| {</span><span class="s2">\n      </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">none</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n      </span><span class="s1">loc: Position;</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">export default (superClass: typeof Parser) =&gt;</span><span class="s2">\n  </span><span class="s1">class FlowParserMixin extends superClass implements Parser {</span><span class="s2">\n    </span><span class="s1">// The value of the @flow/@noflow pragma. Initially undefined, transitions</span><span class="s2">\n    </span><span class="s1">// to </span><span class="s2">\&quot;</span><span class="s1">@flow</span><span class="s2">\&quot; </span><span class="s1">or </span><span class="s2">\&quot;</span><span class="s1">@noflow</span><span class="s2">\&quot; </span><span class="s1">if we see a pragma. Transitions to null if we are</span><span class="s2">\n    </span><span class="s1">// past the initial comment.</span><span class="s2">\n    </span><span class="s1">flowPragma: void | null | </span><span class="s2">\&quot;</span><span class="s1">flow</span><span class="s2">\&quot; </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">noflow</span><span class="s2">\&quot; </span><span class="s1">= undefined;</span><span class="s2">\n\n    </span><span class="s1">getScopeHandler(): {</span><span class="s2">\n      </span><span class="s1">new (...args: any): FlowScopeHandler;</span><span class="s2">\n    </span><span class="s1">} {</span><span class="s2">\n      </span><span class="s1">return FlowScopeHandler;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">shouldParseTypes(): boolean {</span><span class="s2">\n      </span><span class="s1">return this.getPluginOption(</span><span class="s2">\&quot;</span><span class="s1">flow</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">all</span><span class="s2">\&quot;</span><span class="s1">) || this.flowPragma === </span><span class="s2">\&quot;</span><span class="s1">flow</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">shouldParseEnums(): boolean {</span><span class="s2">\n      </span><span class="s1">return !!this.getPluginOption(</span><span class="s2">\&quot;</span><span class="s1">flow</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">enums</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">finishToken(type: TokenType, val: any): void {</span><span class="s2">\n      </span><span class="s1">if (</span><span class="s2">\n        </span><span class="s1">type !== tt.string &amp;&amp;</span><span class="s2">\n        </span><span class="s1">type !== tt.semi &amp;&amp;</span><span class="s2">\n        </span><span class="s1">type !== tt.interpreterDirective</span><span class="s2">\n      </span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">if (this.flowPragma === undefined) {</span><span class="s2">\n          </span><span class="s1">this.flowPragma = null;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">super.finishToken(type, val);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">addComment(comment: N.Comment): void {</span><span class="s2">\n      </span><span class="s1">if (this.flowPragma === undefined) {</span><span class="s2">\n        </span><span class="s1">// Try to parse a flow pragma.</span><span class="s2">\n        </span><span class="s1">const matches = FLOW_PRAGMA_REGEX.exec(comment.value);</span><span class="s2">\n        </span><span class="s1">if (!matches) {</span><span class="s2">\n          </span><span class="s1">// do nothing</span><span class="s2">\n        </span><span class="s1">} else if (matches[1] === </span><span class="s2">\&quot;</span><span class="s1">flow</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">this.flowPragma = </span><span class="s2">\&quot;</span><span class="s1">flow</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n        </span><span class="s1">} else if (matches[1] === </span><span class="s2">\&quot;</span><span class="s1">noflow</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">this.flowPragma = </span><span class="s2">\&quot;</span><span class="s1">noflow</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">throw new Error(</span><span class="s2">\&quot;</span><span class="s1">Unexpected flow pragma</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">super.addComment(comment);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">flowParseTypeInitialiser(tok?: TokenType): N.FlowType {</span><span class="s2">\n      </span><span class="s1">const oldInType = this.state.inType;</span><span class="s2">\n      </span><span class="s1">this.state.inType = true;</span><span class="s2">\n      </span><span class="s1">this.expect(tok || tt.colon);</span><span class="s2">\n\n      </span><span class="s1">const type = this.flowParseType();</span><span class="s2">\n      </span><span class="s1">this.state.inType = oldInType;</span><span class="s2">\n      </span><span class="s1">return type;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">flowParsePredicate(): N.FlowPredicate {</span><span class="s2">\n      </span><span class="s1">const node = this.startNode();</span><span class="s2">\n      </span><span class="s1">const moduloLoc = this.state.startLoc;</span><span class="s2">\n      </span><span class="s1">this.next(); // eat `%`</span><span class="s2">\n      </span><span class="s1">this.expectContextual(tt._checks);</span><span class="s2">\n      </span><span class="s1">// Force '%' and 'checks' to be adjacent</span><span class="s2">\n      </span><span class="s1">if (this.state.lastTokStart &gt; moduloLoc.index + 1) {</span><span class="s2">\n        </span><span class="s1">this.raise(FlowErrors.UnexpectedSpaceBetweenModuloChecks, {</span><span class="s2">\n          </span><span class="s1">at: moduloLoc,</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (this.eat(tt.parenL)) {</span><span class="s2">\n        </span><span class="s1">node.value = super.parseExpression();</span><span class="s2">\n        </span><span class="s1">this.expect(tt.parenR);</span><span class="s2">\n        </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">DeclaredPredicate</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">InferredPredicate</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">flowParseTypeAndPredicateInitialiser(): [</span><span class="s2">\n      </span><span class="s1">N.FlowType | undefined | null,</span><span class="s2">\n      </span><span class="s1">N.FlowPredicate | undefined | null,</span><span class="s2">\n    </span><span class="s1">] {</span><span class="s2">\n      </span><span class="s1">const oldInType = this.state.inType;</span><span class="s2">\n      </span><span class="s1">this.state.inType = true;</span><span class="s2">\n      </span><span class="s1">this.expect(tt.colon);</span><span class="s2">\n      </span><span class="s1">let type = null;</span><span class="s2">\n      </span><span class="s1">let predicate = null;</span><span class="s2">\n      </span><span class="s1">if (this.match(tt.modulo)) {</span><span class="s2">\n        </span><span class="s1">this.state.inType = oldInType;</span><span class="s2">\n        </span><span class="s1">predicate = this.flowParsePredicate();</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">type = this.flowParseType();</span><span class="s2">\n        </span><span class="s1">this.state.inType = oldInType;</span><span class="s2">\n        </span><span class="s1">if (this.match(tt.modulo)) {</span><span class="s2">\n          </span><span class="s1">predicate = this.flowParsePredicate();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return [type, predicate];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">flowParseDeclareClass(</span><span class="s2">\n      </span><span class="s1">node: Undone&lt;N.FlowDeclareClass&gt;,</span><span class="s2">\n    </span><span class="s1">): N.FlowDeclareClass {</span><span class="s2">\n      </span><span class="s1">this.next();</span><span class="s2">\n      </span><span class="s1">this.flowParseInterfaceish(node, /*isClass*/ true);</span><span class="s2">\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">DeclareClass</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">flowParseDeclareFunction(</span><span class="s2">\n      </span><span class="s1">node: Undone&lt;N.FlowDeclareFunction&gt;,</span><span class="s2">\n    </span><span class="s1">): N.FlowDeclareFunction {</span><span class="s2">\n      </span><span class="s1">this.next();</span><span class="s2">\n\n      </span><span class="s1">const id = (node.id = this.parseIdentifier());</span><span class="s2">\n\n      </span><span class="s1">const typeNode = this.startNode();</span><span class="s2">\n      </span><span class="s1">const typeContainer = this.startNode&lt;N.TypeAnnotation&gt;();</span><span class="s2">\n\n      </span><span class="s1">if (this.match(tt.lt)) {</span><span class="s2">\n        </span><span class="s1">typeNode.typeParameters = this.flowParseTypeParameterDeclaration();</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">typeNode.typeParameters = null;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">this.expect(tt.parenL);</span><span class="s2">\n      </span><span class="s1">const tmp = this.flowParseFunctionTypeParams();</span><span class="s2">\n      </span><span class="s1">typeNode.params = tmp.params;</span><span class="s2">\n      </span><span class="s1">typeNode.rest = tmp.rest;</span><span class="s2">\n      </span><span class="s1">typeNode.this = tmp._this;</span><span class="s2">\n      </span><span class="s1">this.expect(tt.parenR);</span><span class="s2">\n\n      </span><span class="s1">[typeNode.returnType, node.predicate] =</span><span class="s2">\n        </span><span class="s1">this.flowParseTypeAndPredicateInitialiser();</span><span class="s2">\n\n      </span><span class="s1">typeContainer.typeAnnotation = this.finishNode(</span><span class="s2">\n        </span><span class="s1">typeNode,</span><span class="s2">\n        \&quot;</span><span class="s1">FunctionTypeAnnotation</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n\n      </span><span class="s1">id.typeAnnotation = this.finishNode(typeContainer, </span><span class="s2">\&quot;</span><span class="s1">TypeAnnotation</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n\n      </span><span class="s1">this.resetEndLocation(id);</span><span class="s2">\n      </span><span class="s1">this.semicolon();</span><span class="s2">\n\n      </span><span class="s1">this.scope.declareName(</span><span class="s2">\n        </span><span class="s1">node.id.name,</span><span class="s2">\n        </span><span class="s1">BIND_FLOW_DECLARE_FN,</span><span class="s2">\n        </span><span class="s1">node.id.loc.start,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">DeclareFunction</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">flowParseDeclare(</span><span class="s2">\n      </span><span class="s1">node: Undone&lt;N.FlowDeclare&gt;,</span><span class="s2">\n      </span><span class="s1">insideModule?: boolean,</span><span class="s2">\n    </span><span class="s1">): N.FlowDeclare {</span><span class="s2">\n      </span><span class="s1">if (this.match(tt._class)) {</span><span class="s2">\n        </span><span class="s1">return this.flowParseDeclareClass(node);</span><span class="s2">\n      </span><span class="s1">} else if (this.match(tt._function)) {</span><span class="s2">\n        </span><span class="s1">return this.flowParseDeclareFunction(node);</span><span class="s2">\n      </span><span class="s1">} else if (this.match(tt._var)) {</span><span class="s2">\n        </span><span class="s1">return this.flowParseDeclareVariable(node);</span><span class="s2">\n      </span><span class="s1">} else if (this.eatContextual(tt._module)) {</span><span class="s2">\n        </span><span class="s1">if (this.match(tt.dot)) {</span><span class="s2">\n          </span><span class="s1">return this.flowParseDeclareModuleExports(node);</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">if (insideModule) {</span><span class="s2">\n            </span><span class="s1">this.raise(FlowErrors.NestedDeclareModule, {</span><span class="s2">\n              </span><span class="s1">at: this.state.lastTokStartLoc,</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">return this.flowParseDeclareModule(node);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">} else if (this.isContextual(tt._type)) {</span><span class="s2">\n        </span><span class="s1">return this.flowParseDeclareTypeAlias(node);</span><span class="s2">\n      </span><span class="s1">} else if (this.isContextual(tt._opaque)) {</span><span class="s2">\n        </span><span class="s1">return this.flowParseDeclareOpaqueType(node);</span><span class="s2">\n      </span><span class="s1">} else if (this.isContextual(tt._interface)) {</span><span class="s2">\n        </span><span class="s1">return this.flowParseDeclareInterface(node);</span><span class="s2">\n      </span><span class="s1">} else if (this.match(tt._export)) {</span><span class="s2">\n        </span><span class="s1">return this.flowParseDeclareExportDeclaration(node, insideModule);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">this.unexpected();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">flowParseDeclareVariable(</span><span class="s2">\n      </span><span class="s1">node: Undone&lt;N.FlowDeclareVariable&gt;,</span><span class="s2">\n    </span><span class="s1">): N.FlowDeclareVariable {</span><span class="s2">\n      </span><span class="s1">this.next();</span><span class="s2">\n      </span><span class="s1">node.id = this.flowParseTypeAnnotatableIdentifier(</span><span class="s2">\n        </span><span class="s1">/*allowPrimitiveOverride*/ true,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">this.scope.declareName(node.id.name, BIND_VAR, node.id.loc.start);</span><span class="s2">\n      </span><span class="s1">this.semicolon();</span><span class="s2">\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">DeclareVariable</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">flowParseDeclareModule(</span><span class="s2">\n      </span><span class="s1">node: Undone&lt;N.FlowDeclareModule&gt;,</span><span class="s2">\n    </span><span class="s1">): N.FlowDeclareModule {</span><span class="s2">\n      </span><span class="s1">this.scope.enter(SCOPE_OTHER);</span><span class="s2">\n\n      </span><span class="s1">if (this.match(tt.string)) {</span><span class="s2">\n        </span><span class="s1">node.id = super.parseExprAtom();</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">node.id = this.parseIdentifier();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">const bodyNode = (node.body = this.startNode());</span><span class="s2">\n      </span><span class="s1">// @ts-expect-error refine typings</span><span class="s2">\n      </span><span class="s1">const body = (bodyNode.body = []);</span><span class="s2">\n      </span><span class="s1">this.expect(tt.braceL);</span><span class="s2">\n      </span><span class="s1">while (!this.match(tt.braceR)) {</span><span class="s2">\n        </span><span class="s1">let bodyNode = this.startNode&lt;N.ImportDeclaration&gt;();</span><span class="s2">\n\n        </span><span class="s1">if (this.match(tt._import)) {</span><span class="s2">\n          </span><span class="s1">this.next();</span><span class="s2">\n          </span><span class="s1">if (!this.isContextual(tt._type) &amp;&amp; !this.match(tt._typeof)) {</span><span class="s2">\n            </span><span class="s1">this.raise(FlowErrors.InvalidNonTypeImportInDeclareModule, {</span><span class="s2">\n              </span><span class="s1">at: this.state.lastTokStartLoc,</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">super.parseImport(bodyNode);</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">this.expectContextual(</span><span class="s2">\n            </span><span class="s1">tt._declare,</span><span class="s2">\n            </span><span class="s1">FlowErrors.UnsupportedStatementInDeclareModule,</span><span class="s2">\n          </span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">// @ts-expect-error refine typings</span><span class="s2">\n          </span><span class="s1">bodyNode = this.flowParseDeclare(bodyNode, true);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">body.push(bodyNode);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">this.scope.exit();</span><span class="s2">\n\n      </span><span class="s1">this.expect(tt.braceR);</span><span class="s2">\n\n      </span><span class="s1">this.finishNode(bodyNode, </span><span class="s2">\&quot;</span><span class="s1">BlockStatement</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n\n      </span><span class="s1">let kind: </span><span class="s2">\&quot;</span><span class="s1">CommonJS</span><span class="s2">\&quot; </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">ES</span><span class="s2">\&quot; </span><span class="s1">| null = null;</span><span class="s2">\n      </span><span class="s1">let hasModuleExport = false;</span><span class="s2">\n      </span><span class="s1">body.forEach(bodyElement =&gt; {</span><span class="s2">\n        </span><span class="s1">if (isEsModuleType(bodyElement)) {</span><span class="s2">\n          </span><span class="s1">if (kind === </span><span class="s2">\&quot;</span><span class="s1">CommonJS</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n            </span><span class="s1">this.raise(FlowErrors.AmbiguousDeclareModuleKind, {</span><span class="s2">\n              </span><span class="s1">at: bodyElement,</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">kind = </span><span class="s2">\&quot;</span><span class="s1">ES</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n        </span><span class="s1">} else if (bodyElement.type === </span><span class="s2">\&quot;</span><span class="s1">DeclareModuleExports</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">if (hasModuleExport) {</span><span class="s2">\n            </span><span class="s1">this.raise(FlowErrors.DuplicateDeclareModuleExports, {</span><span class="s2">\n              </span><span class="s1">at: bodyElement,</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">if (kind === </span><span class="s2">\&quot;</span><span class="s1">ES</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n            </span><span class="s1">this.raise(FlowErrors.AmbiguousDeclareModuleKind, {</span><span class="s2">\n              </span><span class="s1">at: bodyElement,</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">kind = </span><span class="s2">\&quot;</span><span class="s1">CommonJS</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n          </span><span class="s1">hasModuleExport = true;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n\n      </span><span class="s1">node.kind = kind || </span><span class="s2">\&quot;</span><span class="s1">CommonJS</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">DeclareModule</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">flowParseDeclareExportDeclaration(</span><span class="s2">\n      </span><span class="s1">node: Undone&lt;N.FlowDeclareExportDeclaration&gt;,</span><span class="s2">\n      </span><span class="s1">insideModule?: boolean | null,</span><span class="s2">\n    </span><span class="s1">): N.FlowDeclareExportDeclaration {</span><span class="s2">\n      </span><span class="s1">this.expect(tt._export);</span><span class="s2">\n\n      </span><span class="s1">if (this.eat(tt._default)) {</span><span class="s2">\n        </span><span class="s1">if (this.match(tt._function) || this.match(tt._class)) {</span><span class="s2">\n          </span><span class="s1">// declare export default class ...</span><span class="s2">\n          </span><span class="s1">// declare export default function ...</span><span class="s2">\n          </span><span class="s1">node.declaration = this.flowParseDeclare(this.startNode());</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">// declare export default [type];</span><span class="s2">\n          </span><span class="s1">node.declaration = this.flowParseType();</span><span class="s2">\n          </span><span class="s1">this.semicolon();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">node.default = true;</span><span class="s2">\n\n        </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">DeclareExportDeclaration</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">if (</span><span class="s2">\n          </span><span class="s1">this.match(tt._const) ||</span><span class="s2">\n          </span><span class="s1">this.isLet() ||</span><span class="s2">\n          </span><span class="s1">((this.isContextual(tt._type) || this.isContextual(tt._interface)) &amp;&amp;</span><span class="s2">\n            </span><span class="s1">!insideModule)</span><span class="s2">\n        </span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">const label = this.state.value as</span><span class="s2">\n            </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">const</span><span class="s2">\&quot;\n            </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">let</span><span class="s2">\&quot;\n            </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">type</span><span class="s2">\&quot;\n            </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">interface</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n          </span><span class="s1">throw this.raise(FlowErrors.UnsupportedDeclareExportKind, {</span><span class="s2">\n            </span><span class="s1">at: this.state.startLoc,</span><span class="s2">\n            </span><span class="s1">unsupportedExportKind: label,</span><span class="s2">\n            </span><span class="s1">suggestion: exportSuggestions[label],</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">if (</span><span class="s2">\n          </span><span class="s1">this.match(tt._var) || // declare export var ...</span><span class="s2">\n          </span><span class="s1">this.match(tt._function) || // declare export function ...</span><span class="s2">\n          </span><span class="s1">this.match(tt._class) || // declare export class ...</span><span class="s2">\n          </span><span class="s1">this.isContextual(tt._opaque) // declare export opaque ..</span><span class="s2">\n        </span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">node.declaration = this.flowParseDeclare(this.startNode());</span><span class="s2">\n          </span><span class="s1">node.default = false;</span><span class="s2">\n\n          </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">DeclareExportDeclaration</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">} else if (</span><span class="s2">\n          </span><span class="s1">this.match(tt.star) || // declare export * from ''</span><span class="s2">\n          </span><span class="s1">this.match(tt.braceL) || // declare export {} ...</span><span class="s2">\n          </span><span class="s1">this.isContextual(tt._interface) || // declare export interface ...</span><span class="s2">\n          </span><span class="s1">this.isContextual(tt._type) || // declare export type ...</span><span class="s2">\n          </span><span class="s1">this.isContextual(tt._opaque) // declare export opaque type ...</span><span class="s2">\n        </span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">node = this.parseExport(</span><span class="s2">\n            </span><span class="s1">node as Undone&lt;N.ExportNamedDeclaration | N.ExportAllDeclaration&gt;,</span><span class="s2">\n            </span><span class="s1">/* decorators */ null,</span><span class="s2">\n          </span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">if (node.type === </span><span class="s2">\&quot;</span><span class="s1">ExportNamedDeclaration</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n            </span><span class="s1">node.type = </span><span class="s2">\&quot;</span><span class="s1">ExportDeclaration</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n            </span><span class="s1">node.default = false;</span><span class="s2">\n            </span><span class="s1">delete node.exportKind;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n\n          </span><span class="s1">node.type = </span><span class="s2">\&quot;</span><span class="s1">Declare</span><span class="s2">\&quot; </span><span class="s1">+ node.type;</span><span class="s2">\n\n          </span><span class="s1">return node as N.Node;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">this.unexpected();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">flowParseDeclareModuleExports(</span><span class="s2">\n      </span><span class="s1">node: Undone&lt;N.FlowDeclareModuleExports&gt;,</span><span class="s2">\n    </span><span class="s1">): N.FlowDeclareModuleExports {</span><span class="s2">\n      </span><span class="s1">this.next();</span><span class="s2">\n      </span><span class="s1">this.expectContextual(tt._exports);</span><span class="s2">\n      </span><span class="s1">node.typeAnnotation = this.flowParseTypeAnnotation();</span><span class="s2">\n      </span><span class="s1">this.semicolon();</span><span class="s2">\n\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">DeclareModuleExports</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">flowParseDeclareTypeAlias(</span><span class="s2">\n      </span><span class="s1">node: Undone&lt;N.FlowDeclareTypeAlias&gt;,</span><span class="s2">\n    </span><span class="s1">): N.FlowDeclareTypeAlias {</span><span class="s2">\n      </span><span class="s1">this.next();</span><span class="s2">\n      </span><span class="s1">const finished = this.flowParseTypeAlias(node);</span><span class="s2">\n      </span><span class="s1">// Don't do finishNode as we don't want to process comments twice</span><span class="s2">\n      </span><span class="s1">finished.type = </span><span class="s2">\&quot;</span><span class="s1">DeclareTypeAlias</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n      </span><span class="s1">return finished;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">flowParseDeclareOpaqueType(</span><span class="s2">\n      </span><span class="s1">node: Undone&lt;N.FlowDeclareOpaqueType&gt;,</span><span class="s2">\n    </span><span class="s1">): N.FlowDeclareOpaqueType {</span><span class="s2">\n      </span><span class="s1">this.next();</span><span class="s2">\n      </span><span class="s1">const finished = this.flowParseOpaqueType(node, true);</span><span class="s2">\n      </span><span class="s1">// Don't do finishNode as we don't want to process comments twice</span><span class="s2">\n      </span><span class="s1">finished.type = </span><span class="s2">\&quot;</span><span class="s1">DeclareOpaqueType</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n      </span><span class="s1">return finished;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">flowParseDeclareInterface(</span><span class="s2">\n      </span><span class="s1">node: Undone&lt;N.FlowDeclareInterface&gt;,</span><span class="s2">\n    </span><span class="s1">): N.FlowDeclareInterface {</span><span class="s2">\n      </span><span class="s1">this.next();</span><span class="s2">\n      </span><span class="s1">this.flowParseInterfaceish(node, /* isClass */ false);</span><span class="s2">\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">DeclareInterface</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// Interfaces</span><span class="s2">\n\n    </span><span class="s1">flowParseInterfaceish(node: Undone&lt;N.FlowDeclare&gt;, isClass: boolean): void {</span><span class="s2">\n      </span><span class="s1">node.id = this.flowParseRestrictedIdentifier(</span><span class="s2">\n        </span><span class="s1">/* liberal */ !isClass,</span><span class="s2">\n        </span><span class="s1">/* declaration */ true,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n\n      </span><span class="s1">this.scope.declareName(</span><span class="s2">\n        </span><span class="s1">node.id.name,</span><span class="s2">\n        </span><span class="s1">isClass ? BIND_FUNCTION : BIND_LEXICAL,</span><span class="s2">\n        </span><span class="s1">node.id.loc.start,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n\n      </span><span class="s1">if (this.match(tt.lt)) {</span><span class="s2">\n        </span><span class="s1">node.typeParameters = this.flowParseTypeParameterDeclaration();</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">node.typeParameters = null;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">node.extends = [];</span><span class="s2">\n      </span><span class="s1">node.implements = [];</span><span class="s2">\n      </span><span class="s1">node.mixins = [];</span><span class="s2">\n\n      </span><span class="s1">if (this.eat(tt._extends)) {</span><span class="s2">\n        </span><span class="s1">do {</span><span class="s2">\n          </span><span class="s1">node.extends.push(this.flowParseInterfaceExtends());</span><span class="s2">\n        </span><span class="s1">} while (!isClass &amp;&amp; this.eat(tt.comma));</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">if (isClass) {</span><span class="s2">\n        </span><span class="s1">if (this.eatContextual(tt._mixins)) {</span><span class="s2">\n          </span><span class="s1">do {</span><span class="s2">\n            </span><span class="s1">node.mixins.push(this.flowParseInterfaceExtends());</span><span class="s2">\n          </span><span class="s1">} while (this.eat(tt.comma));</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">if (this.eatContextual(tt._implements)) {</span><span class="s2">\n          </span><span class="s1">do {</span><span class="s2">\n            </span><span class="s1">node.implements.push(this.flowParseInterfaceExtends());</span><span class="s2">\n          </span><span class="s1">} while (this.eat(tt.comma));</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">node.body = this.flowParseObjectType({</span><span class="s2">\n        </span><span class="s1">allowStatic: isClass,</span><span class="s2">\n        </span><span class="s1">allowExact: false,</span><span class="s2">\n        </span><span class="s1">allowSpread: false,</span><span class="s2">\n        </span><span class="s1">allowProto: isClass,</span><span class="s2">\n        </span><span class="s1">allowInexact: false,</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">flowParseInterfaceExtends(): N.FlowInterfaceExtends {</span><span class="s2">\n      </span><span class="s1">const node = this.startNode();</span><span class="s2">\n\n      </span><span class="s1">node.id = this.flowParseQualifiedTypeIdentifier();</span><span class="s2">\n      </span><span class="s1">if (this.match(tt.lt)) {</span><span class="s2">\n        </span><span class="s1">node.typeParameters = this.flowParseTypeParameterInstantiation();</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">node.typeParameters = null;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">InterfaceExtends</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">flowParseInterface(node: Undone&lt;N.FlowInterface&gt;): N.FlowInterface {</span><span class="s2">\n      </span><span class="s1">this.flowParseInterfaceish(node, /* isClass */ false);</span><span class="s2">\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">InterfaceDeclaration</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">checkNotUnderscore(word: string) {</span><span class="s2">\n      </span><span class="s1">if (word === </span><span class="s2">\&quot;</span><span class="s1">_</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">this.raise(FlowErrors.UnexpectedReservedUnderscore, {</span><span class="s2">\n          </span><span class="s1">at: this.state.startLoc,</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">checkReservedType(word: string, startLoc: Position, declaration?: boolean) {</span><span class="s2">\n      </span><span class="s1">if (!reservedTypes.has(word)) return;</span><span class="s2">\n\n      </span><span class="s1">this.raise(</span><span class="s2">\n        </span><span class="s1">declaration</span><span class="s2">\n          </span><span class="s1">? FlowErrors.AssignReservedType</span><span class="s2">\n          </span><span class="s1">: FlowErrors.UnexpectedReservedType,</span><span class="s2">\n        </span><span class="s1">{</span><span class="s2">\n          </span><span class="s1">at: startLoc,</span><span class="s2">\n          </span><span class="s1">reservedType: word,</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">flowParseRestrictedIdentifier(</span><span class="s2">\n      </span><span class="s1">liberal?: boolean,</span><span class="s2">\n      </span><span class="s1">declaration?: boolean,</span><span class="s2">\n    </span><span class="s1">): N.Identifier {</span><span class="s2">\n      </span><span class="s1">this.checkReservedType(</span><span class="s2">\n        </span><span class="s1">this.state.value,</span><span class="s2">\n        </span><span class="s1">this.state.startLoc,</span><span class="s2">\n        </span><span class="s1">declaration,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">return this.parseIdentifier(liberal);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// Type aliases</span><span class="s2">\n\n    </span><span class="s1">flowParseTypeAlias(node: Undone&lt;N.FlowTypeAlias&gt;): N.FlowTypeAlias {</span><span class="s2">\n      </span><span class="s1">node.id = this.flowParseRestrictedIdentifier(</span><span class="s2">\n        </span><span class="s1">/* liberal */ false,</span><span class="s2">\n        </span><span class="s1">/* declaration */ true,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.loc.start);</span><span class="s2">\n\n      </span><span class="s1">if (this.match(tt.lt)) {</span><span class="s2">\n        </span><span class="s1">node.typeParameters = this.flowParseTypeParameterDeclaration();</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">node.typeParameters = null;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">node.right = this.flowParseTypeInitialiser(tt.eq);</span><span class="s2">\n      </span><span class="s1">this.semicolon();</span><span class="s2">\n\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">TypeAlias</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">flowParseOpaqueType(</span><span class="s2">\n      </span><span class="s1">node: Undone&lt;N.FlowOpaqueType&gt;,</span><span class="s2">\n      </span><span class="s1">declare: boolean,</span><span class="s2">\n    </span><span class="s1">): N.FlowOpaqueType {</span><span class="s2">\n      </span><span class="s1">this.expectContextual(tt._type);</span><span class="s2">\n      </span><span class="s1">node.id = this.flowParseRestrictedIdentifier(</span><span class="s2">\n        </span><span class="s1">/* liberal */ true,</span><span class="s2">\n        </span><span class="s1">/* declaration */ true,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.loc.start);</span><span class="s2">\n\n      </span><span class="s1">if (this.match(tt.lt)) {</span><span class="s2">\n        </span><span class="s1">node.typeParameters = this.flowParseTypeParameterDeclaration();</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">node.typeParameters = null;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">// Parse the supertype</span><span class="s2">\n      </span><span class="s1">node.supertype = null;</span><span class="s2">\n      </span><span class="s1">if (this.match(tt.colon)) {</span><span class="s2">\n        </span><span class="s1">node.supertype = this.flowParseTypeInitialiser(tt.colon);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">node.impltype = null;</span><span class="s2">\n      </span><span class="s1">if (!declare) {</span><span class="s2">\n        </span><span class="s1">node.impltype = this.flowParseTypeInitialiser(tt.eq);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">this.semicolon();</span><span class="s2">\n\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">OpaqueType</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// Type annotations</span><span class="s2">\n\n    </span><span class="s1">flowParseTypeParameter(requireDefault: boolean = false): N.TypeParameter {</span><span class="s2">\n      </span><span class="s1">const nodeStartLoc = this.state.startLoc;</span><span class="s2">\n\n      </span><span class="s1">const node = this.startNode&lt;N.TypeParameter&gt;();</span><span class="s2">\n\n      </span><span class="s1">const variance = this.flowParseVariance();</span><span class="s2">\n\n      </span><span class="s1">const ident = this.flowParseTypeAnnotatableIdentifier();</span><span class="s2">\n      </span><span class="s1">node.name = ident.name;</span><span class="s2">\n      </span><span class="s1">// @ts-expect-error migrate to Babel types</span><span class="s2">\n      </span><span class="s1">node.variance = variance;</span><span class="s2">\n      </span><span class="s1">// @ts-expect-error migrate to Babel types</span><span class="s2">\n      </span><span class="s1">node.bound = ident.typeAnnotation;</span><span class="s2">\n\n      </span><span class="s1">if (this.match(tt.eq)) {</span><span class="s2">\n        </span><span class="s1">this.eat(tt.eq);</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error migrate to Babel types</span><span class="s2">\n        </span><span class="s1">node.default = this.flowParseType();</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">if (requireDefault) {</span><span class="s2">\n          </span><span class="s1">this.raise(FlowErrors.MissingTypeParamDefault, { at: nodeStartLoc });</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">TypeParameter</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">flowParseTypeParameterDeclaration(): N.TypeParameterDeclaration {</span><span class="s2">\n      </span><span class="s1">const oldInType = this.state.inType;</span><span class="s2">\n      </span><span class="s1">const node = this.startNode&lt;N.TypeParameterDeclaration&gt;();</span><span class="s2">\n      </span><span class="s1">node.params = [];</span><span class="s2">\n\n      </span><span class="s1">this.state.inType = true;</span><span class="s2">\n\n      </span><span class="s1">// istanbul ignore else: this condition is already checked at all call sites</span><span class="s2">\n      </span><span class="s1">if (this.match(tt.lt) || this.match(tt.jsxTagStart)) {</span><span class="s2">\n        </span><span class="s1">this.next();</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">this.unexpected();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">let defaultRequired = false;</span><span class="s2">\n\n      </span><span class="s1">do {</span><span class="s2">\n        </span><span class="s1">const typeParameter = this.flowParseTypeParameter(defaultRequired);</span><span class="s2">\n\n        </span><span class="s1">node.params.push(typeParameter);</span><span class="s2">\n\n        </span><span class="s1">if (typeParameter.default) {</span><span class="s2">\n          </span><span class="s1">defaultRequired = true;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">if (!this.match(tt.gt)) {</span><span class="s2">\n          </span><span class="s1">this.expect(tt.comma);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">} while (!this.match(tt.gt));</span><span class="s2">\n      </span><span class="s1">this.expect(tt.gt);</span><span class="s2">\n\n      </span><span class="s1">this.state.inType = oldInType;</span><span class="s2">\n\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">TypeParameterDeclaration</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">flowParseTypeParameterInstantiation(): N.TypeParameterInstantiation {</span><span class="s2">\n      </span><span class="s1">const node = this.startNode&lt;N.TypeParameterInstantiation&gt;();</span><span class="s2">\n      </span><span class="s1">const oldInType = this.state.inType;</span><span class="s2">\n      </span><span class="s1">node.params = [];</span><span class="s2">\n\n      </span><span class="s1">this.state.inType = true;</span><span class="s2">\n\n      </span><span class="s1">this.expect(tt.lt);</span><span class="s2">\n      </span><span class="s1">const oldNoAnonFunctionType = this.state.noAnonFunctionType;</span><span class="s2">\n      </span><span class="s1">this.state.noAnonFunctionType = false;</span><span class="s2">\n      </span><span class="s1">while (!this.match(tt.gt)) {</span><span class="s2">\n        </span><span class="s1">node.params.push(this.flowParseType());</span><span class="s2">\n        </span><span class="s1">if (!this.match(tt.gt)) {</span><span class="s2">\n          </span><span class="s1">this.expect(tt.comma);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">this.state.noAnonFunctionType = oldNoAnonFunctionType;</span><span class="s2">\n      </span><span class="s1">this.expect(tt.gt);</span><span class="s2">\n\n      </span><span class="s1">this.state.inType = oldInType;</span><span class="s2">\n\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">TypeParameterInstantiation</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">flowParseTypeParameterInstantiationCallOrNew(): N.TypeParameterInstantiation {</span><span class="s2">\n      </span><span class="s1">const node = this.startNode&lt;N.TypeParameterInstantiation&gt;();</span><span class="s2">\n      </span><span class="s1">const oldInType = this.state.inType;</span><span class="s2">\n      </span><span class="s1">node.params = [];</span><span class="s2">\n\n      </span><span class="s1">this.state.inType = true;</span><span class="s2">\n\n      </span><span class="s1">this.expect(tt.lt);</span><span class="s2">\n      </span><span class="s1">while (!this.match(tt.gt)) {</span><span class="s2">\n        </span><span class="s1">node.params.push(this.flowParseTypeOrImplicitInstantiation());</span><span class="s2">\n        </span><span class="s1">if (!this.match(tt.gt)) {</span><span class="s2">\n          </span><span class="s1">this.expect(tt.comma);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">this.expect(tt.gt);</span><span class="s2">\n\n      </span><span class="s1">this.state.inType = oldInType;</span><span class="s2">\n\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">TypeParameterInstantiation</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">flowParseInterfaceType(): N.FlowInterfaceType {</span><span class="s2">\n      </span><span class="s1">const node = this.startNode&lt;N.FlowInterfaceType&gt;();</span><span class="s2">\n      </span><span class="s1">this.expectContextual(tt._interface);</span><span class="s2">\n\n      </span><span class="s1">node.extends = [];</span><span class="s2">\n      </span><span class="s1">if (this.eat(tt._extends)) {</span><span class="s2">\n        </span><span class="s1">do {</span><span class="s2">\n          </span><span class="s1">node.extends.push(this.flowParseInterfaceExtends());</span><span class="s2">\n        </span><span class="s1">} while (this.eat(tt.comma));</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">node.body = this.flowParseObjectType({</span><span class="s2">\n        </span><span class="s1">allowStatic: false,</span><span class="s2">\n        </span><span class="s1">allowExact: false,</span><span class="s2">\n        </span><span class="s1">allowSpread: false,</span><span class="s2">\n        </span><span class="s1">allowProto: false,</span><span class="s2">\n        </span><span class="s1">allowInexact: false,</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">InterfaceTypeAnnotation</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">flowParseObjectPropertyKey(): N.Expression {</span><span class="s2">\n      </span><span class="s1">return this.match(tt.num) || this.match(tt.string)</span><span class="s2">\n        </span><span class="s1">? super.parseExprAtom()</span><span class="s2">\n        </span><span class="s1">: this.parseIdentifier(true);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">flowParseObjectTypeIndexer(</span><span class="s2">\n      </span><span class="s1">node: Undone&lt;N.FlowObjectTypeIndexer&gt;,</span><span class="s2">\n      </span><span class="s1">isStatic: boolean,</span><span class="s2">\n      </span><span class="s1">variance?: N.FlowVariance | null,</span><span class="s2">\n    </span><span class="s1">): N.FlowObjectTypeIndexer {</span><span class="s2">\n      </span><span class="s1">node.static = isStatic;</span><span class="s2">\n\n      </span><span class="s1">// Note: bracketL has already been consumed</span><span class="s2">\n      </span><span class="s1">if (this.lookahead().type === tt.colon) {</span><span class="s2">\n        </span><span class="s1">node.id = this.flowParseObjectPropertyKey();</span><span class="s2">\n        </span><span class="s1">node.key = this.flowParseTypeInitialiser();</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">node.id = null;</span><span class="s2">\n        </span><span class="s1">node.key = this.flowParseType();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">this.expect(tt.bracketR);</span><span class="s2">\n      </span><span class="s1">node.value = this.flowParseTypeInitialiser();</span><span class="s2">\n      </span><span class="s1">node.variance = variance;</span><span class="s2">\n\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">ObjectTypeIndexer</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">flowParseObjectTypeInternalSlot(</span><span class="s2">\n      </span><span class="s1">node: Undone&lt;N.FlowObjectTypeInternalSlot&gt;,</span><span class="s2">\n      </span><span class="s1">isStatic: boolean,</span><span class="s2">\n    </span><span class="s1">): N.FlowObjectTypeInternalSlot {</span><span class="s2">\n      </span><span class="s1">node.static = isStatic;</span><span class="s2">\n      </span><span class="s1">// Note: both bracketL have already been consumed</span><span class="s2">\n      </span><span class="s1">node.id = this.flowParseObjectPropertyKey();</span><span class="s2">\n      </span><span class="s1">this.expect(tt.bracketR);</span><span class="s2">\n      </span><span class="s1">this.expect(tt.bracketR);</span><span class="s2">\n      </span><span class="s1">if (this.match(tt.lt) || this.match(tt.parenL)) {</span><span class="s2">\n        </span><span class="s1">node.method = true;</span><span class="s2">\n        </span><span class="s1">node.optional = false;</span><span class="s2">\n        </span><span class="s1">node.value = this.flowParseObjectTypeMethodish(</span><span class="s2">\n          </span><span class="s1">this.startNodeAt(node.loc.start),</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">node.method = false;</span><span class="s2">\n        </span><span class="s1">if (this.eat(tt.question)) {</span><span class="s2">\n          </span><span class="s1">node.optional = true;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">node.value = this.flowParseTypeInitialiser();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">ObjectTypeInternalSlot</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">flowParseObjectTypeMethodish(</span><span class="s2">\n      </span><span class="s1">node: Undone&lt;N.FlowFunctionTypeAnnotation&gt;,</span><span class="s2">\n    </span><span class="s1">): N.FlowFunctionTypeAnnotation {</span><span class="s2">\n      </span><span class="s1">node.params = [];</span><span class="s2">\n      </span><span class="s1">node.rest = null;</span><span class="s2">\n      </span><span class="s1">node.typeParameters = null;</span><span class="s2">\n      </span><span class="s1">node.this = null;</span><span class="s2">\n\n      </span><span class="s1">if (this.match(tt.lt)) {</span><span class="s2">\n        </span><span class="s1">node.typeParameters = this.flowParseTypeParameterDeclaration();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">this.expect(tt.parenL);</span><span class="s2">\n      </span><span class="s1">if (this.match(tt._this)) {</span><span class="s2">\n        </span><span class="s1">node.this = this.flowParseFunctionTypeParam(/* first */ true);</span><span class="s2">\n        </span><span class="s1">// match Flow parser behavior</span><span class="s2">\n        </span><span class="s1">node.this.name = null;</span><span class="s2">\n        </span><span class="s1">if (!this.match(tt.parenR)) {</span><span class="s2">\n          </span><span class="s1">this.expect(tt.comma);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">while (!this.match(tt.parenR) &amp;&amp; !this.match(tt.ellipsis)) {</span><span class="s2">\n        </span><span class="s1">node.params.push(this.flowParseFunctionTypeParam(false));</span><span class="s2">\n        </span><span class="s1">if (!this.match(tt.parenR)) {</span><span class="s2">\n          </span><span class="s1">this.expect(tt.comma);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">if (this.eat(tt.ellipsis)) {</span><span class="s2">\n        </span><span class="s1">node.rest = this.flowParseFunctionTypeParam(false);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">this.expect(tt.parenR);</span><span class="s2">\n      </span><span class="s1">node.returnType = this.flowParseTypeInitialiser();</span><span class="s2">\n\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">FunctionTypeAnnotation</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">flowParseObjectTypeCallProperty(</span><span class="s2">\n      </span><span class="s1">node: Undone&lt;N.FlowObjectTypeCallProperty&gt;,</span><span class="s2">\n      </span><span class="s1">isStatic: boolean,</span><span class="s2">\n    </span><span class="s1">): N.FlowObjectTypeCallProperty {</span><span class="s2">\n      </span><span class="s1">const valueNode = this.startNode();</span><span class="s2">\n      </span><span class="s1">node.static = isStatic;</span><span class="s2">\n      </span><span class="s1">node.value = this.flowParseObjectTypeMethodish(valueNode);</span><span class="s2">\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">ObjectTypeCallProperty</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">flowParseObjectType({</span><span class="s2">\n      </span><span class="s1">allowStatic,</span><span class="s2">\n      </span><span class="s1">allowExact,</span><span class="s2">\n      </span><span class="s1">allowSpread,</span><span class="s2">\n      </span><span class="s1">allowProto,</span><span class="s2">\n      </span><span class="s1">allowInexact,</span><span class="s2">\n    </span><span class="s1">}: {</span><span class="s2">\n      </span><span class="s1">allowStatic: boolean;</span><span class="s2">\n      </span><span class="s1">allowExact: boolean;</span><span class="s2">\n      </span><span class="s1">allowSpread: boolean;</span><span class="s2">\n      </span><span class="s1">allowProto: boolean;</span><span class="s2">\n      </span><span class="s1">allowInexact: boolean;</span><span class="s2">\n    </span><span class="s1">}): N.FlowObjectTypeAnnotation {</span><span class="s2">\n      </span><span class="s1">const oldInType = this.state.inType;</span><span class="s2">\n      </span><span class="s1">this.state.inType = true;</span><span class="s2">\n\n      </span><span class="s1">const nodeStart = this.startNode();</span><span class="s2">\n\n      </span><span class="s1">nodeStart.callProperties = [];</span><span class="s2">\n      </span><span class="s1">nodeStart.properties = [];</span><span class="s2">\n      </span><span class="s1">nodeStart.indexers = [];</span><span class="s2">\n      </span><span class="s1">nodeStart.internalSlots = [];</span><span class="s2">\n\n      </span><span class="s1">let endDelim;</span><span class="s2">\n      </span><span class="s1">let exact;</span><span class="s2">\n      </span><span class="s1">let inexact = false;</span><span class="s2">\n      </span><span class="s1">if (allowExact &amp;&amp; this.match(tt.braceBarL)) {</span><span class="s2">\n        </span><span class="s1">this.expect(tt.braceBarL);</span><span class="s2">\n        </span><span class="s1">endDelim = tt.braceBarR;</span><span class="s2">\n        </span><span class="s1">exact = true;</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">this.expect(tt.braceL);</span><span class="s2">\n        </span><span class="s1">endDelim = tt.braceR;</span><span class="s2">\n        </span><span class="s1">exact = false;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">nodeStart.exact = exact;</span><span class="s2">\n\n      </span><span class="s1">while (!this.match(endDelim)) {</span><span class="s2">\n        </span><span class="s1">let isStatic = false;</span><span class="s2">\n        </span><span class="s1">let protoStartLoc: Position | undefined | null = null;</span><span class="s2">\n        </span><span class="s1">let inexactStartLoc: Position | undefined | null = null;</span><span class="s2">\n        </span><span class="s1">const node = this.startNode();</span><span class="s2">\n\n        </span><span class="s1">if (allowProto &amp;&amp; this.isContextual(tt._proto)) {</span><span class="s2">\n          </span><span class="s1">const lookahead = this.lookahead();</span><span class="s2">\n\n          </span><span class="s1">if (lookahead.type !== tt.colon &amp;&amp; lookahead.type !== tt.question) {</span><span class="s2">\n            </span><span class="s1">this.next();</span><span class="s2">\n            </span><span class="s1">protoStartLoc = this.state.startLoc;</span><span class="s2">\n            </span><span class="s1">allowStatic = false;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">if (allowStatic &amp;&amp; this.isContextual(tt._static)) {</span><span class="s2">\n          </span><span class="s1">const lookahead = this.lookahead();</span><span class="s2">\n\n          </span><span class="s1">// static is a valid identifier name</span><span class="s2">\n          </span><span class="s1">if (lookahead.type !== tt.colon &amp;&amp; lookahead.type !== tt.question) {</span><span class="s2">\n            </span><span class="s1">this.next();</span><span class="s2">\n            </span><span class="s1">isStatic = true;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">const variance = this.flowParseVariance();</span><span class="s2">\n\n        </span><span class="s1">if (this.eat(tt.bracketL)) {</span><span class="s2">\n          </span><span class="s1">if (protoStartLoc != null) {</span><span class="s2">\n            </span><span class="s1">this.unexpected(protoStartLoc);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">if (this.eat(tt.bracketL)) {</span><span class="s2">\n            </span><span class="s1">if (variance) {</span><span class="s2">\n              </span><span class="s1">this.unexpected(variance.loc.start);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">nodeStart.internalSlots.push(</span><span class="s2">\n              </span><span class="s1">this.flowParseObjectTypeInternalSlot(node, isStatic),</span><span class="s2">\n            </span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">} else {</span><span class="s2">\n            </span><span class="s1">nodeStart.indexers.push(</span><span class="s2">\n              </span><span class="s1">this.flowParseObjectTypeIndexer(node, isStatic, variance),</span><span class="s2">\n            </span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">} else if (this.match(tt.parenL) || this.match(tt.lt)) {</span><span class="s2">\n          </span><span class="s1">if (protoStartLoc != null) {</span><span class="s2">\n            </span><span class="s1">this.unexpected(protoStartLoc);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">if (variance) {</span><span class="s2">\n            </span><span class="s1">this.unexpected(variance.loc.start);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">nodeStart.callProperties.push(</span><span class="s2">\n            </span><span class="s1">this.flowParseObjectTypeCallProperty(node, isStatic),</span><span class="s2">\n          </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">let kind = </span><span class="s2">\&quot;</span><span class="s1">init</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n          </span><span class="s1">if (this.isContextual(tt._get) || this.isContextual(tt._set)) {</span><span class="s2">\n            </span><span class="s1">const lookahead = this.lookahead();</span><span class="s2">\n            </span><span class="s1">if (tokenIsLiteralPropertyName(lookahead.type)) {</span><span class="s2">\n              </span><span class="s1">kind = this.state.value;</span><span class="s2">\n              </span><span class="s1">this.next();</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n\n          </span><span class="s1">const propOrInexact = this.flowParseObjectTypeProperty(</span><span class="s2">\n            </span><span class="s1">node,</span><span class="s2">\n            </span><span class="s1">isStatic,</span><span class="s2">\n            </span><span class="s1">protoStartLoc,</span><span class="s2">\n            </span><span class="s1">variance,</span><span class="s2">\n            </span><span class="s1">kind,</span><span class="s2">\n            </span><span class="s1">allowSpread,</span><span class="s2">\n            </span><span class="s1">allowInexact ?? !exact,</span><span class="s2">\n          </span><span class="s1">);</span><span class="s2">\n\n          </span><span class="s1">if (propOrInexact === null) {</span><span class="s2">\n            </span><span class="s1">inexact = true;</span><span class="s2">\n            </span><span class="s1">inexactStartLoc = this.state.lastTokStartLoc;</span><span class="s2">\n          </span><span class="s1">} else {</span><span class="s2">\n            </span><span class="s1">nodeStart.properties.push(propOrInexact);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">this.flowObjectTypeSemicolon();</span><span class="s2">\n\n        </span><span class="s1">if (</span><span class="s2">\n          </span><span class="s1">inexactStartLoc &amp;&amp;</span><span class="s2">\n          </span><span class="s1">!this.match(tt.braceR) &amp;&amp;</span><span class="s2">\n          </span><span class="s1">!this.match(tt.braceBarR)</span><span class="s2">\n        </span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">this.raise(FlowErrors.UnexpectedExplicitInexactInObject, {</span><span class="s2">\n            </span><span class="s1">at: inexactStartLoc,</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">this.expect(endDelim);</span><span class="s2">\n\n      </span><span class="s1">/* The inexact flag should only be added on ObjectTypeAnnotations that</span><span class="s2">\n       </span><span class="s1">* are not the body of an interface, declare interface, or declare class.</span><span class="s2">\n       </span><span class="s1">* Since spreads are only allowed in object types, checking that is</span><span class="s2">\n       </span><span class="s1">* sufficient here.</span><span class="s2">\n       </span><span class="s1">*/</span><span class="s2">\n      </span><span class="s1">if (allowSpread) {</span><span class="s2">\n        </span><span class="s1">nodeStart.inexact = inexact;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">const out = this.finishNode(nodeStart, </span><span class="s2">\&quot;</span><span class="s1">ObjectTypeAnnotation</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n\n      </span><span class="s1">this.state.inType = oldInType;</span><span class="s2">\n\n      </span><span class="s1">return out;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">flowParseObjectTypeProperty(</span><span class="s2">\n      </span><span class="s1">node: Undone&lt;N.FlowObjectTypeProperty | N.FlowObjectTypeSpreadProperty&gt;,</span><span class="s2">\n      </span><span class="s1">isStatic: boolean,</span><span class="s2">\n      </span><span class="s1">protoStartLoc: Position | undefined | null,</span><span class="s2">\n      </span><span class="s1">variance: N.FlowVariance | undefined | null,</span><span class="s2">\n      </span><span class="s1">kind: string,</span><span class="s2">\n      </span><span class="s1">allowSpread: boolean,</span><span class="s2">\n      </span><span class="s1">allowInexact: boolean,</span><span class="s2">\n    </span><span class="s1">): N.FlowObjectTypeProperty | N.FlowObjectTypeSpreadProperty | null {</span><span class="s2">\n      </span><span class="s1">if (this.eat(tt.ellipsis)) {</span><span class="s2">\n        </span><span class="s1">const isInexactToken =</span><span class="s2">\n          </span><span class="s1">this.match(tt.comma) ||</span><span class="s2">\n          </span><span class="s1">this.match(tt.semi) ||</span><span class="s2">\n          </span><span class="s1">this.match(tt.braceR) ||</span><span class="s2">\n          </span><span class="s1">this.match(tt.braceBarR);</span><span class="s2">\n\n        </span><span class="s1">if (isInexactToken) {</span><span class="s2">\n          </span><span class="s1">if (!allowSpread) {</span><span class="s2">\n            </span><span class="s1">this.raise(FlowErrors.InexactInsideNonObject, {</span><span class="s2">\n              </span><span class="s1">at: this.state.lastTokStartLoc,</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n          </span><span class="s1">} else if (!allowInexact) {</span><span class="s2">\n            </span><span class="s1">this.raise(FlowErrors.InexactInsideExact, {</span><span class="s2">\n              </span><span class="s1">at: this.state.lastTokStartLoc,</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">if (variance) {</span><span class="s2">\n            </span><span class="s1">this.raise(FlowErrors.InexactVariance, { at: variance });</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n\n          </span><span class="s1">return null;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">if (!allowSpread) {</span><span class="s2">\n          </span><span class="s1">this.raise(FlowErrors.UnexpectedSpreadType, {</span><span class="s2">\n            </span><span class="s1">at: this.state.lastTokStartLoc,</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (protoStartLoc != null) {</span><span class="s2">\n          </span><span class="s1">this.unexpected(protoStartLoc);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (variance) {</span><span class="s2">\n          </span><span class="s1">this.raise(FlowErrors.SpreadVariance, { at: variance });</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">node.argument = this.flowParseType();</span><span class="s2">\n        </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">ObjectTypeSpreadProperty</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">node.key = this.flowParseObjectPropertyKey();</span><span class="s2">\n        </span><span class="s1">node.static = isStatic;</span><span class="s2">\n        </span><span class="s1">node.proto = protoStartLoc != null;</span><span class="s2">\n        </span><span class="s1">node.kind = kind;</span><span class="s2">\n\n        </span><span class="s1">let optional = false;</span><span class="s2">\n        </span><span class="s1">if (this.match(tt.lt) || this.match(tt.parenL)) {</span><span class="s2">\n          </span><span class="s1">// This is a method property</span><span class="s2">\n          </span><span class="s1">node.method = true;</span><span class="s2">\n\n          </span><span class="s1">if (protoStartLoc != null) {</span><span class="s2">\n            </span><span class="s1">this.unexpected(protoStartLoc);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">if (variance) {</span><span class="s2">\n            </span><span class="s1">this.unexpected(variance.loc.start);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n\n          </span><span class="s1">node.value = this.flowParseObjectTypeMethodish(</span><span class="s2">\n            </span><span class="s1">this.startNodeAt(node.loc.start),</span><span class="s2">\n          </span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">if (kind === </span><span class="s2">\&quot;</span><span class="s1">get</span><span class="s2">\&quot; </span><span class="s1">|| kind === </span><span class="s2">\&quot;</span><span class="s1">set</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n            </span><span class="s1">this.flowCheckGetterSetterParams(node);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">/** Declared classes/interfaces do not allow spread */</span><span class="s2">\n          </span><span class="s1">if (</span><span class="s2">\n            </span><span class="s1">!allowSpread &amp;&amp;</span><span class="s2">\n            </span><span class="s1">node.key.name === </span><span class="s2">\&quot;</span><span class="s1">constructor</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n            </span><span class="s1">node.value.this</span><span class="s2">\n          </span><span class="s1">) {</span><span class="s2">\n            </span><span class="s1">this.raise(FlowErrors.ThisParamBannedInConstructor, {</span><span class="s2">\n              </span><span class="s1">at: node.value.this,</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">if (kind !== </span><span class="s2">\&quot;</span><span class="s1">init</span><span class="s2">\&quot;</span><span class="s1">) this.unexpected();</span><span class="s2">\n\n          </span><span class="s1">node.method = false;</span><span class="s2">\n\n          </span><span class="s1">if (this.eat(tt.question)) {</span><span class="s2">\n            </span><span class="s1">optional = true;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">node.value = this.flowParseTypeInitialiser();</span><span class="s2">\n          </span><span class="s1">node.variance = variance;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">node.optional = optional;</span><span class="s2">\n\n        </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">ObjectTypeProperty</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// This is similar to checkGetterSetterParams, but as</span><span class="s2">\n    </span><span class="s1">// @babel/parser uses non estree properties we cannot reuse it here</span><span class="s2">\n    </span><span class="s1">flowCheckGetterSetterParams(</span><span class="s2">\n      </span><span class="s1">property: Undone&lt;</span><span class="s2">\n        </span><span class="s1">N.FlowObjectTypeProperty | N.FlowObjectTypeSpreadProperty</span><span class="s2">\n      </span><span class="s1">&gt;,</span><span class="s2">\n    </span><span class="s1">): void {</span><span class="s2">\n      </span><span class="s1">const paramCount = property.kind === </span><span class="s2">\&quot;</span><span class="s1">get</span><span class="s2">\&quot; </span><span class="s1">? 0 : 1;</span><span class="s2">\n      </span><span class="s1">const length =</span><span class="s2">\n        </span><span class="s1">property.value.params.length + (property.value.rest ? 1 : 0);</span><span class="s2">\n\n      </span><span class="s1">if (property.value.this) {</span><span class="s2">\n        </span><span class="s1">this.raise(</span><span class="s2">\n          </span><span class="s1">property.kind === </span><span class="s2">\&quot;</span><span class="s1">get</span><span class="s2">\&quot;\n            </span><span class="s1">? FlowErrors.GetterMayNotHaveThisParam</span><span class="s2">\n            </span><span class="s1">: FlowErrors.SetterMayNotHaveThisParam,</span><span class="s2">\n          </span><span class="s1">{ at: property.value.this },</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">if (length !== paramCount) {</span><span class="s2">\n        </span><span class="s1">this.raise(</span><span class="s2">\n          </span><span class="s1">property.kind === </span><span class="s2">\&quot;</span><span class="s1">get</span><span class="s2">\&quot;\n            </span><span class="s1">? Errors.BadGetterArity</span><span class="s2">\n            </span><span class="s1">: Errors.BadSetterArity,</span><span class="s2">\n          </span><span class="s1">{ at: property },</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">if (property.kind === </span><span class="s2">\&quot;</span><span class="s1">set</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; property.value.rest) {</span><span class="s2">\n        </span><span class="s1">this.raise(Errors.BadSetterRestParameter, { at: property });</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">flowObjectTypeSemicolon(): void {</span><span class="s2">\n      </span><span class="s1">if (</span><span class="s2">\n        </span><span class="s1">!this.eat(tt.semi) &amp;&amp;</span><span class="s2">\n        </span><span class="s1">!this.eat(tt.comma) &amp;&amp;</span><span class="s2">\n        </span><span class="s1">!this.match(tt.braceR) &amp;&amp;</span><span class="s2">\n        </span><span class="s1">!this.match(tt.braceBarR)</span><span class="s2">\n      </span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">this.unexpected();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">flowParseQualifiedTypeIdentifier(</span><span class="s2">\n      </span><span class="s1">startLoc?: Position,</span><span class="s2">\n      </span><span class="s1">id?: N.Identifier,</span><span class="s2">\n    </span><span class="s1">): N.FlowQualifiedTypeIdentifier {</span><span class="s2">\n      </span><span class="s1">startLoc ??= this.state.startLoc;</span><span class="s2">\n      </span><span class="s1">let node: N.Identifier | N.FlowQualifiedTypeIdentifier =</span><span class="s2">\n        </span><span class="s1">id || this.flowParseRestrictedIdentifier(true);</span><span class="s2">\n\n      </span><span class="s1">while (this.eat(tt.dot)) {</span><span class="s2">\n        </span><span class="s1">const node2 = this.startNodeAt&lt;N.FlowQualifiedTypeIdentifier&gt;(startLoc);</span><span class="s2">\n        </span><span class="s1">node2.qualification = node;</span><span class="s2">\n        </span><span class="s1">node2.id = this.flowParseRestrictedIdentifier(true);</span><span class="s2">\n        </span><span class="s1">node = this.finishNode(node2, </span><span class="s2">\&quot;</span><span class="s1">QualifiedTypeIdentifier</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return node;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">flowParseGenericType(</span><span class="s2">\n      </span><span class="s1">startLoc: Position,</span><span class="s2">\n      </span><span class="s1">id: N.Identifier,</span><span class="s2">\n    </span><span class="s1">): N.FlowGenericTypeAnnotation {</span><span class="s2">\n      </span><span class="s1">const node = this.startNodeAt(startLoc);</span><span class="s2">\n\n      </span><span class="s1">node.typeParameters = null;</span><span class="s2">\n      </span><span class="s1">node.id = this.flowParseQualifiedTypeIdentifier(startLoc, id);</span><span class="s2">\n\n      </span><span class="s1">if (this.match(tt.lt)) {</span><span class="s2">\n        </span><span class="s1">node.typeParameters = this.flowParseTypeParameterInstantiation();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">GenericTypeAnnotation</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">flowParseTypeofType(): N.FlowTypeofTypeAnnotation {</span><span class="s2">\n      </span><span class="s1">const node = this.startNode();</span><span class="s2">\n      </span><span class="s1">this.expect(tt._typeof);</span><span class="s2">\n      </span><span class="s1">node.argument = this.flowParsePrimaryType();</span><span class="s2">\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">TypeofTypeAnnotation</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">flowParseTupleType(): N.FlowTupleTypeAnnotation {</span><span class="s2">\n      </span><span class="s1">const node = this.startNode();</span><span class="s2">\n      </span><span class="s1">node.types = [];</span><span class="s2">\n      </span><span class="s1">this.expect(tt.bracketL);</span><span class="s2">\n      </span><span class="s1">// We allow trailing commas</span><span class="s2">\n      </span><span class="s1">while (this.state.pos &lt; this.length &amp;&amp; !this.match(tt.bracketR)) {</span><span class="s2">\n        </span><span class="s1">node.types.push(this.flowParseType());</span><span class="s2">\n        </span><span class="s1">if (this.match(tt.bracketR)) break;</span><span class="s2">\n        </span><span class="s1">this.expect(tt.comma);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">this.expect(tt.bracketR);</span><span class="s2">\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">TupleTypeAnnotation</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">flowParseFunctionTypeParam(first: boolean): N.FlowFunctionTypeParam {</span><span class="s2">\n      </span><span class="s1">let name = null;</span><span class="s2">\n      </span><span class="s1">let optional = false;</span><span class="s2">\n      </span><span class="s1">let typeAnnotation = null;</span><span class="s2">\n      </span><span class="s1">const node = this.startNode&lt;N.FlowFunctionTypeParam&gt;();</span><span class="s2">\n      </span><span class="s1">const lh = this.lookahead();</span><span class="s2">\n      </span><span class="s1">const isThis = this.state.type === tt._this;</span><span class="s2">\n\n      </span><span class="s1">if (lh.type === tt.colon || lh.type === tt.question) {</span><span class="s2">\n        </span><span class="s1">if (isThis &amp;&amp; !first) {</span><span class="s2">\n          </span><span class="s1">this.raise(FlowErrors.ThisParamMustBeFirst, { at: node });</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">name = this.parseIdentifier(isThis);</span><span class="s2">\n        </span><span class="s1">if (this.eat(tt.question)) {</span><span class="s2">\n          </span><span class="s1">optional = true;</span><span class="s2">\n          </span><span class="s1">if (isThis) {</span><span class="s2">\n            </span><span class="s1">this.raise(FlowErrors.ThisParamMayNotBeOptional, { at: node });</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">typeAnnotation = this.flowParseTypeInitialiser();</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">typeAnnotation = this.flowParseType();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">node.name = name;</span><span class="s2">\n      </span><span class="s1">node.optional = optional;</span><span class="s2">\n      </span><span class="s1">node.typeAnnotation = typeAnnotation;</span><span class="s2">\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">FunctionTypeParam</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">reinterpretTypeAsFunctionTypeParam(</span><span class="s2">\n      </span><span class="s1">type: N.FlowType,</span><span class="s2">\n    </span><span class="s1">): N.FlowFunctionTypeParam {</span><span class="s2">\n      </span><span class="s1">const node = this.startNodeAt(type.loc.start);</span><span class="s2">\n      </span><span class="s1">node.name = null;</span><span class="s2">\n      </span><span class="s1">node.optional = false;</span><span class="s2">\n      </span><span class="s1">node.typeAnnotation = type;</span><span class="s2">\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">FunctionTypeParam</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">flowParseFunctionTypeParams(params: N.FlowFunctionTypeParam[] = []): {</span><span class="s2">\n      </span><span class="s1">params: N.FlowFunctionTypeParam[];</span><span class="s2">\n      </span><span class="s1">rest: N.FlowFunctionTypeParam | undefined | null;</span><span class="s2">\n      </span><span class="s1">_this: N.FlowFunctionTypeParam | undefined | null;</span><span class="s2">\n    </span><span class="s1">} {</span><span class="s2">\n      </span><span class="s1">let rest: N.FlowFunctionTypeParam | undefined | null = null;</span><span class="s2">\n      </span><span class="s1">let _this: N.FlowFunctionTypeParam | undefined | null = null;</span><span class="s2">\n      </span><span class="s1">if (this.match(tt._this)) {</span><span class="s2">\n        </span><span class="s1">_this = this.flowParseFunctionTypeParam(/* first */ true);</span><span class="s2">\n        </span><span class="s1">// match Flow parser behavior</span><span class="s2">\n        </span><span class="s1">_this.name = null;</span><span class="s2">\n        </span><span class="s1">if (!this.match(tt.parenR)) {</span><span class="s2">\n          </span><span class="s1">this.expect(tt.comma);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">while (!this.match(tt.parenR) &amp;&amp; !this.match(tt.ellipsis)) {</span><span class="s2">\n        </span><span class="s1">params.push(this.flowParseFunctionTypeParam(false));</span><span class="s2">\n        </span><span class="s1">if (!this.match(tt.parenR)) {</span><span class="s2">\n          </span><span class="s1">this.expect(tt.comma);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (this.eat(tt.ellipsis)) {</span><span class="s2">\n        </span><span class="s1">rest = this.flowParseFunctionTypeParam(false);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return { params, rest, _this };</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">flowIdentToTypeAnnotation(</span><span class="s2">\n      </span><span class="s1">startLoc: Position,</span><span class="s2">\n      </span><span class="s1">node: Undone&lt;N.FlowTypeAnnotation&gt;,</span><span class="s2">\n      </span><span class="s1">id: N.Identifier,</span><span class="s2">\n    </span><span class="s1">): N.FlowTypeAnnotation {</span><span class="s2">\n      </span><span class="s1">switch (id.name) {</span><span class="s2">\n        </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">any</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n          </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">AnyTypeAnnotation</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n\n        </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">bool</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n        </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">boolean</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n          </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">BooleanTypeAnnotation</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n\n        </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">mixed</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n          </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">MixedTypeAnnotation</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n\n        </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">empty</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n          </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">EmptyTypeAnnotation</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n\n        </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">number</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n          </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">NumberTypeAnnotation</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n\n        </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n          </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">StringTypeAnnotation</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n\n        </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">symbol</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n          </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">SymbolTypeAnnotation</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n\n        </span><span class="s1">default:</span><span class="s2">\n          </span><span class="s1">this.checkNotUnderscore(id.name);</span><span class="s2">\n          </span><span class="s1">return this.flowParseGenericType(startLoc, id);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// The parsing of types roughly parallels the parsing of expressions, and</span><span class="s2">\n    </span><span class="s1">// primary types are kind of like primary expressions...they're the</span><span class="s2">\n    </span><span class="s1">// primitives with which other types are constructed.</span><span class="s2">\n    </span><span class="s1">flowParsePrimaryType(): N.FlowTypeAnnotation {</span><span class="s2">\n      </span><span class="s1">const startLoc = this.state.startLoc;</span><span class="s2">\n      </span><span class="s1">const node = this.startNode();</span><span class="s2">\n      </span><span class="s1">let tmp;</span><span class="s2">\n      </span><span class="s1">let type;</span><span class="s2">\n      </span><span class="s1">let isGroupedType = false;</span><span class="s2">\n      </span><span class="s1">const oldNoAnonFunctionType = this.state.noAnonFunctionType;</span><span class="s2">\n\n      </span><span class="s1">switch (this.state.type) {</span><span class="s2">\n        </span><span class="s1">case tt.braceL:</span><span class="s2">\n          </span><span class="s1">return this.flowParseObjectType({</span><span class="s2">\n            </span><span class="s1">allowStatic: false,</span><span class="s2">\n            </span><span class="s1">allowExact: false,</span><span class="s2">\n            </span><span class="s1">allowSpread: true,</span><span class="s2">\n            </span><span class="s1">allowProto: false,</span><span class="s2">\n            </span><span class="s1">allowInexact: true,</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n\n        </span><span class="s1">case tt.braceBarL:</span><span class="s2">\n          </span><span class="s1">return this.flowParseObjectType({</span><span class="s2">\n            </span><span class="s1">allowStatic: false,</span><span class="s2">\n            </span><span class="s1">allowExact: true,</span><span class="s2">\n            </span><span class="s1">allowSpread: true,</span><span class="s2">\n            </span><span class="s1">allowProto: false,</span><span class="s2">\n            </span><span class="s1">allowInexact: false,</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n\n        </span><span class="s1">case tt.bracketL:</span><span class="s2">\n          </span><span class="s1">this.state.noAnonFunctionType = false;</span><span class="s2">\n          </span><span class="s1">type = this.flowParseTupleType();</span><span class="s2">\n          </span><span class="s1">this.state.noAnonFunctionType = oldNoAnonFunctionType;</span><span class="s2">\n          </span><span class="s1">return type;</span><span class="s2">\n\n        </span><span class="s1">case tt.lt:</span><span class="s2">\n          </span><span class="s1">node.typeParameters = this.flowParseTypeParameterDeclaration();</span><span class="s2">\n          </span><span class="s1">this.expect(tt.parenL);</span><span class="s2">\n          </span><span class="s1">tmp = this.flowParseFunctionTypeParams();</span><span class="s2">\n          </span><span class="s1">node.params = tmp.params;</span><span class="s2">\n          </span><span class="s1">node.rest = tmp.rest;</span><span class="s2">\n          </span><span class="s1">node.this = tmp._this;</span><span class="s2">\n          </span><span class="s1">this.expect(tt.parenR);</span><span class="s2">\n\n          </span><span class="s1">this.expect(tt.arrow);</span><span class="s2">\n\n          </span><span class="s1">node.returnType = this.flowParseType();</span><span class="s2">\n\n          </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">FunctionTypeAnnotation</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n\n        </span><span class="s1">case tt.parenL:</span><span class="s2">\n          </span><span class="s1">this.next();</span><span class="s2">\n\n          </span><span class="s1">// Check to see if this is actually a grouped type</span><span class="s2">\n          </span><span class="s1">if (!this.match(tt.parenR) &amp;&amp; !this.match(tt.ellipsis)) {</span><span class="s2">\n            </span><span class="s1">if (tokenIsIdentifier(this.state.type) || this.match(tt._this)) {</span><span class="s2">\n              </span><span class="s1">const token = this.lookahead().type;</span><span class="s2">\n              </span><span class="s1">isGroupedType = token !== tt.question &amp;&amp; token !== tt.colon;</span><span class="s2">\n            </span><span class="s1">} else {</span><span class="s2">\n              </span><span class="s1">isGroupedType = true;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n\n          </span><span class="s1">if (isGroupedType) {</span><span class="s2">\n            </span><span class="s1">this.state.noAnonFunctionType = false;</span><span class="s2">\n            </span><span class="s1">type = this.flowParseType();</span><span class="s2">\n            </span><span class="s1">this.state.noAnonFunctionType = oldNoAnonFunctionType;</span><span class="s2">\n\n            </span><span class="s1">// A `,` or a `) =&gt;` means this is an anonymous function type</span><span class="s2">\n            </span><span class="s1">if (</span><span class="s2">\n              </span><span class="s1">this.state.noAnonFunctionType ||</span><span class="s2">\n              </span><span class="s1">!(</span><span class="s2">\n                </span><span class="s1">this.match(tt.comma) ||</span><span class="s2">\n                </span><span class="s1">(this.match(tt.parenR) &amp;&amp; this.lookahead().type === tt.arrow)</span><span class="s2">\n              </span><span class="s1">)</span><span class="s2">\n            </span><span class="s1">) {</span><span class="s2">\n              </span><span class="s1">this.expect(tt.parenR);</span><span class="s2">\n              </span><span class="s1">return type;</span><span class="s2">\n            </span><span class="s1">} else {</span><span class="s2">\n              </span><span class="s1">// Eat a comma if there is one</span><span class="s2">\n              </span><span class="s1">this.eat(tt.comma);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n\n          </span><span class="s1">if (type) {</span><span class="s2">\n            </span><span class="s1">tmp = this.flowParseFunctionTypeParams([</span><span class="s2">\n              </span><span class="s1">this.reinterpretTypeAsFunctionTypeParam(type),</span><span class="s2">\n            </span><span class="s1">]);</span><span class="s2">\n          </span><span class="s1">} else {</span><span class="s2">\n            </span><span class="s1">tmp = this.flowParseFunctionTypeParams();</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n\n          </span><span class="s1">node.params = tmp.params;</span><span class="s2">\n          </span><span class="s1">node.rest = tmp.rest;</span><span class="s2">\n          </span><span class="s1">node.this = tmp._this;</span><span class="s2">\n\n          </span><span class="s1">this.expect(tt.parenR);</span><span class="s2">\n\n          </span><span class="s1">this.expect(tt.arrow);</span><span class="s2">\n\n          </span><span class="s1">node.returnType = this.flowParseType();</span><span class="s2">\n\n          </span><span class="s1">node.typeParameters = null;</span><span class="s2">\n\n          </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">FunctionTypeAnnotation</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n\n        </span><span class="s1">case tt.string:</span><span class="s2">\n          </span><span class="s1">return this.parseLiteral&lt;N.StringLiteralTypeAnnotation&gt;(</span><span class="s2">\n            </span><span class="s1">this.state.value,</span><span class="s2">\n            \&quot;</span><span class="s1">StringLiteralTypeAnnotation</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n          </span><span class="s1">);</span><span class="s2">\n\n        </span><span class="s1">case tt._true:</span><span class="s2">\n        </span><span class="s1">case tt._false:</span><span class="s2">\n          </span><span class="s1">node.value = this.match(tt._true);</span><span class="s2">\n          </span><span class="s1">this.next();</span><span class="s2">\n          </span><span class="s1">return this.finishNode(</span><span class="s2">\n            </span><span class="s1">node as Undone&lt;N.BooleanLiteralTypeAnnotation&gt;,</span><span class="s2">\n            \&quot;</span><span class="s1">BooleanLiteralTypeAnnotation</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n          </span><span class="s1">);</span><span class="s2">\n\n        </span><span class="s1">case tt.plusMin:</span><span class="s2">\n          </span><span class="s1">if (this.state.value === </span><span class="s2">\&quot;</span><span class="s1">-</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n            </span><span class="s1">this.next();</span><span class="s2">\n            </span><span class="s1">if (this.match(tt.num)) {</span><span class="s2">\n              </span><span class="s1">return this.parseLiteralAtNode&lt;N.NumberLiteralTypeAnnotation&gt;(</span><span class="s2">\n                </span><span class="s1">-this.state.value,</span><span class="s2">\n                \&quot;</span><span class="s1">NumberLiteralTypeAnnotation</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n                </span><span class="s1">node,</span><span class="s2">\n              </span><span class="s1">);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n\n            </span><span class="s1">if (this.match(tt.bigint)) {</span><span class="s2">\n              </span><span class="s1">return this.parseLiteralAtNode&lt;N.BigIntLiteralTypeAnnotation&gt;(</span><span class="s2">\n                </span><span class="s1">-this.state.value,</span><span class="s2">\n                \&quot;</span><span class="s1">BigIntLiteralTypeAnnotation</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n                </span><span class="s1">node,</span><span class="s2">\n              </span><span class="s1">);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n\n            </span><span class="s1">throw this.raise(FlowErrors.UnexpectedSubtractionOperand, {</span><span class="s2">\n              </span><span class="s1">at: this.state.startLoc,</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">this.unexpected();</span><span class="s2">\n          </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">case tt.num:</span><span class="s2">\n          </span><span class="s1">return this.parseLiteral(</span><span class="s2">\n            </span><span class="s1">this.state.value,</span><span class="s2">\n            \&quot;</span><span class="s1">NumberLiteralTypeAnnotation</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n          </span><span class="s1">);</span><span class="s2">\n\n        </span><span class="s1">case tt.bigint:</span><span class="s2">\n          </span><span class="s1">return this.parseLiteral(</span><span class="s2">\n            </span><span class="s1">this.state.value,</span><span class="s2">\n            \&quot;</span><span class="s1">BigIntLiteralTypeAnnotation</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n          </span><span class="s1">);</span><span class="s2">\n\n        </span><span class="s1">case tt._void:</span><span class="s2">\n          </span><span class="s1">this.next();</span><span class="s2">\n          </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">VoidTypeAnnotation</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n\n        </span><span class="s1">case tt._null:</span><span class="s2">\n          </span><span class="s1">this.next();</span><span class="s2">\n          </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">NullLiteralTypeAnnotation</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n\n        </span><span class="s1">case tt._this:</span><span class="s2">\n          </span><span class="s1">this.next();</span><span class="s2">\n          </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">ThisTypeAnnotation</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n\n        </span><span class="s1">case tt.star:</span><span class="s2">\n          </span><span class="s1">this.next();</span><span class="s2">\n          </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">ExistsTypeAnnotation</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n\n        </span><span class="s1">case tt._typeof:</span><span class="s2">\n          </span><span class="s1">return this.flowParseTypeofType();</span><span class="s2">\n\n        </span><span class="s1">default:</span><span class="s2">\n          </span><span class="s1">if (tokenIsKeyword(this.state.type)) {</span><span class="s2">\n            </span><span class="s1">const label = tokenLabelName(this.state.type);</span><span class="s2">\n            </span><span class="s1">this.next();</span><span class="s2">\n            </span><span class="s1">return super.createIdentifier(node as Undone&lt;N.Identifier&gt;, label);</span><span class="s2">\n          </span><span class="s1">} else if (tokenIsIdentifier(this.state.type)) {</span><span class="s2">\n            </span><span class="s1">if (this.isContextual(tt._interface)) {</span><span class="s2">\n              </span><span class="s1">return this.flowParseInterfaceType();</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n\n            </span><span class="s1">return this.flowIdentToTypeAnnotation(</span><span class="s2">\n              </span><span class="s1">startLoc,</span><span class="s2">\n              </span><span class="s1">node,</span><span class="s2">\n              </span><span class="s1">this.parseIdentifier(),</span><span class="s2">\n            </span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">this.unexpected();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">flowParsePostfixType(): N.FlowTypeAnnotation {</span><span class="s2">\n      </span><span class="s1">const startLoc = this.state.startLoc;</span><span class="s2">\n      </span><span class="s1">let type = this.flowParsePrimaryType();</span><span class="s2">\n      </span><span class="s1">let seenOptionalIndexedAccess = false;</span><span class="s2">\n      </span><span class="s1">while (</span><span class="s2">\n        </span><span class="s1">(this.match(tt.bracketL) || this.match(tt.questionDot)) &amp;&amp;</span><span class="s2">\n        </span><span class="s1">!this.canInsertSemicolon()</span><span class="s2">\n      </span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">const node = this.startNodeAt(startLoc);</span><span class="s2">\n        </span><span class="s1">const optional = this.eat(tt.questionDot);</span><span class="s2">\n        </span><span class="s1">seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional;</span><span class="s2">\n        </span><span class="s1">this.expect(tt.bracketL);</span><span class="s2">\n        </span><span class="s1">if (!optional &amp;&amp; this.match(tt.bracketR)) {</span><span class="s2">\n          </span><span class="s1">node.elementType = type;</span><span class="s2">\n          </span><span class="s1">this.next(); // eat `]`</span><span class="s2">\n          </span><span class="s1">type = this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">ArrayTypeAnnotation</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">node.objectType = type;</span><span class="s2">\n          </span><span class="s1">node.indexType = this.flowParseType();</span><span class="s2">\n          </span><span class="s1">this.expect(tt.bracketR);</span><span class="s2">\n          </span><span class="s1">if (seenOptionalIndexedAccess) {</span><span class="s2">\n            </span><span class="s1">node.optional = optional;</span><span class="s2">\n            </span><span class="s1">type = this.finishNode&lt;N.FlowOptionalIndexedAccessType&gt;(</span><span class="s2">\n              </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts)</span><span class="s2">\n              </span><span class="s1">node,</span><span class="s2">\n              \&quot;</span><span class="s1">OptionalIndexedAccessType</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n            </span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">} else {</span><span class="s2">\n            </span><span class="s1">type = this.finishNode&lt;N.FlowIndexedAccessType&gt;(</span><span class="s2">\n              </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts)</span><span class="s2">\n              </span><span class="s1">node,</span><span class="s2">\n              \&quot;</span><span class="s1">IndexedAccessType</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n            </span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return type;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">flowParsePrefixType(): N.FlowTypeAnnotation {</span><span class="s2">\n      </span><span class="s1">const node = this.startNode();</span><span class="s2">\n      </span><span class="s1">if (this.eat(tt.question)) {</span><span class="s2">\n        </span><span class="s1">node.typeAnnotation = this.flowParsePrefixType();</span><span class="s2">\n        </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">NullableTypeAnnotation</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">return this.flowParsePostfixType();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">flowParseAnonFunctionWithoutParens(): N.FlowTypeAnnotation {</span><span class="s2">\n      </span><span class="s1">const param = this.flowParsePrefixType();</span><span class="s2">\n      </span><span class="s1">if (!this.state.noAnonFunctionType &amp;&amp; this.eat(tt.arrow)) {</span><span class="s2">\n        </span><span class="s1">// TODO: This should be a type error. Passing in a SourceLocation, and it expects a Position.</span><span class="s2">\n        </span><span class="s1">const node = this.startNodeAt(param.loc.start);</span><span class="s2">\n        </span><span class="s1">node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];</span><span class="s2">\n        </span><span class="s1">node.rest = null;</span><span class="s2">\n        </span><span class="s1">node.this = null;</span><span class="s2">\n        </span><span class="s1">node.returnType = this.flowParseType();</span><span class="s2">\n        </span><span class="s1">node.typeParameters = null;</span><span class="s2">\n        </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">FunctionTypeAnnotation</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return param;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">flowParseIntersectionType(): N.FlowTypeAnnotation {</span><span class="s2">\n      </span><span class="s1">const node = this.startNode();</span><span class="s2">\n      </span><span class="s1">this.eat(tt.bitwiseAND);</span><span class="s2">\n      </span><span class="s1">const type = this.flowParseAnonFunctionWithoutParens();</span><span class="s2">\n      </span><span class="s1">node.types = [type];</span><span class="s2">\n      </span><span class="s1">while (this.eat(tt.bitwiseAND)) {</span><span class="s2">\n        </span><span class="s1">node.types.push(this.flowParseAnonFunctionWithoutParens());</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return node.types.length === 1</span><span class="s2">\n        </span><span class="s1">? type</span><span class="s2">\n        </span><span class="s1">: this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">IntersectionTypeAnnotation</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">flowParseUnionType(): N.FlowTypeAnnotation {</span><span class="s2">\n      </span><span class="s1">const node = this.startNode();</span><span class="s2">\n      </span><span class="s1">this.eat(tt.bitwiseOR);</span><span class="s2">\n      </span><span class="s1">const type = this.flowParseIntersectionType();</span><span class="s2">\n      </span><span class="s1">node.types = [type];</span><span class="s2">\n      </span><span class="s1">while (this.eat(tt.bitwiseOR)) {</span><span class="s2">\n        </span><span class="s1">node.types.push(this.flowParseIntersectionType());</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return node.types.length === 1</span><span class="s2">\n        </span><span class="s1">? type</span><span class="s2">\n        </span><span class="s1">: this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">UnionTypeAnnotation</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">flowParseType(): N.FlowTypeAnnotation {</span><span class="s2">\n      </span><span class="s1">const oldInType = this.state.inType;</span><span class="s2">\n      </span><span class="s1">this.state.inType = true;</span><span class="s2">\n      </span><span class="s1">const type = this.flowParseUnionType();</span><span class="s2">\n      </span><span class="s1">this.state.inType = oldInType;</span><span class="s2">\n      </span><span class="s1">return type;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">flowParseTypeOrImplicitInstantiation(): N.FlowTypeAnnotation {</span><span class="s2">\n      </span><span class="s1">if (this.state.type === tt.name &amp;&amp; this.state.value === </span><span class="s2">\&quot;</span><span class="s1">_</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">const startLoc = this.state.startLoc;</span><span class="s2">\n        </span><span class="s1">const node = this.parseIdentifier();</span><span class="s2">\n        </span><span class="s1">return this.flowParseGenericType(startLoc, node);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">return this.flowParseType();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">flowParseTypeAnnotation(): N.FlowTypeAnnotation {</span><span class="s2">\n      </span><span class="s1">const node = this.startNode&lt;N.FlowTypeAnnotation&gt;();</span><span class="s2">\n      </span><span class="s1">node.typeAnnotation = this.flowParseTypeInitialiser();</span><span class="s2">\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">TypeAnnotation</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">flowParseTypeAnnotatableIdentifier(</span><span class="s2">\n      </span><span class="s1">allowPrimitiveOverride?: boolean,</span><span class="s2">\n    </span><span class="s1">): N.Identifier {</span><span class="s2">\n      </span><span class="s1">const ident = allowPrimitiveOverride</span><span class="s2">\n        </span><span class="s1">? this.parseIdentifier()</span><span class="s2">\n        </span><span class="s1">: this.flowParseRestrictedIdentifier();</span><span class="s2">\n      </span><span class="s1">if (this.match(tt.colon)) {</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error: refine typings</span><span class="s2">\n        </span><span class="s1">ident.typeAnnotation = this.flowParseTypeAnnotation();</span><span class="s2">\n        </span><span class="s1">this.resetEndLocation(ident);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return ident;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">typeCastToParameter(node: N.Node): N.Node {</span><span class="s2">\n      </span><span class="s1">node.expression.typeAnnotation = node.typeAnnotation;</span><span class="s2">\n\n      </span><span class="s1">this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);</span><span class="s2">\n\n      </span><span class="s1">return node.expression;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">flowParseVariance(): N.FlowVariance | undefined | null {</span><span class="s2">\n      </span><span class="s1">let variance = null;</span><span class="s2">\n      </span><span class="s1">if (this.match(tt.plusMin)) {</span><span class="s2">\n        </span><span class="s1">variance = this.startNode&lt;N.FlowVariance&gt;();</span><span class="s2">\n        </span><span class="s1">if (this.state.value === </span><span class="s2">\&quot;</span><span class="s1">+</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">variance.kind = </span><span class="s2">\&quot;</span><span class="s1">plus</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">variance.kind = </span><span class="s2">\&quot;</span><span class="s1">minus</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">this.next();</span><span class="s2">\n        </span><span class="s1">return this.finishNode(variance, </span><span class="s2">\&quot;</span><span class="s1">Variance</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return variance;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// ==================================</span><span class="s2">\n    </span><span class="s1">// Overrides</span><span class="s2">\n    </span><span class="s1">// ==================================</span><span class="s2">\n\n    </span><span class="s1">parseFunctionBody(</span><span class="s2">\n      </span><span class="s1">node: N.Function,</span><span class="s2">\n      </span><span class="s1">allowExpressionBody?: boolean | null,</span><span class="s2">\n      </span><span class="s1">isMethod: boolean = false,</span><span class="s2">\n    </span><span class="s1">): void {</span><span class="s2">\n      </span><span class="s1">if (allowExpressionBody) {</span><span class="s2">\n        </span><span class="s1">this.forwardNoArrowParamsConversionAt(node, () =&gt;</span><span class="s2">\n          </span><span class="s1">super.parseFunctionBody(node, true, isMethod),</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">super.parseFunctionBody(node, false, isMethod);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseFunctionBodyAndFinish&lt;</span><span class="s2">\n      </span><span class="s1">T extends</span><span class="s2">\n        </span><span class="s1">| N.Function</span><span class="s2">\n        </span><span class="s1">| N.TSDeclareMethod</span><span class="s2">\n        </span><span class="s1">| N.TSDeclareFunction</span><span class="s2">\n        </span><span class="s1">| N.ClassPrivateMethod,</span><span class="s2">\n    </span><span class="s1">&gt;(node: Undone&lt;T&gt;, type: T[</span><span class="s2">\&quot;</span><span class="s1">type</span><span class="s2">\&quot;</span><span class="s1">], isMethod: boolean = false): T {</span><span class="s2">\n      </span><span class="s1">if (this.match(tt.colon)) {</span><span class="s2">\n        </span><span class="s1">const typeNode = this.startNode&lt;N.TypeAnnotation&gt;();</span><span class="s2">\n\n        </span><span class="s1">[</span><span class="s2">\n          </span><span class="s1">typeNode.typeAnnotation,</span><span class="s2">\n          </span><span class="s1">// @ts-expect-error predicate may not exist</span><span class="s2">\n          </span><span class="s1">node.predicate,</span><span class="s2">\n        </span><span class="s1">] = this.flowParseTypeAndPredicateInitialiser();</span><span class="s2">\n\n        </span><span class="s1">node.returnType = typeNode.typeAnnotation</span><span class="s2">\n          </span><span class="s1">? this.finishNode(typeNode, </span><span class="s2">\&quot;</span><span class="s1">TypeAnnotation</span><span class="s2">\&quot;</span><span class="s1">)</span><span class="s2">\n          </span><span class="s1">: null;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return super.parseFunctionBodyAndFinish(node, type, isMethod);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// interfaces and enums</span><span class="s2">\n    </span><span class="s1">parseStatementLike(flags: ParseStatementFlag): N.Statement {</span><span class="s2">\n      </span><span class="s1">// strict mode handling of `interface` since it's a reserved word</span><span class="s2">\n      </span><span class="s1">if (this.state.strict &amp;&amp; this.isContextual(tt._interface)) {</span><span class="s2">\n        </span><span class="s1">const lookahead = this.lookahead();</span><span class="s2">\n        </span><span class="s1">if (tokenIsKeywordOrIdentifier(lookahead.type)) {</span><span class="s2">\n          </span><span class="s1">const node = this.startNode&lt;N.FlowInterface&gt;();</span><span class="s2">\n          </span><span class="s1">this.next();</span><span class="s2">\n          </span><span class="s1">return this.flowParseInterface(node);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">} else if (this.shouldParseEnums() &amp;&amp; this.isContextual(tt._enum)) {</span><span class="s2">\n        </span><span class="s1">const node = this.startNode();</span><span class="s2">\n        </span><span class="s1">this.next();</span><span class="s2">\n        </span><span class="s1">return this.flowParseEnumDeclaration(node);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">const stmt = super.parseStatementLike(flags);</span><span class="s2">\n      </span><span class="s1">// We will parse a flow pragma in any comment before the first statement.</span><span class="s2">\n      </span><span class="s1">if (this.flowPragma === undefined &amp;&amp; !this.isValidDirective(stmt)) {</span><span class="s2">\n        </span><span class="s1">this.flowPragma = null;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return stmt;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// declares, interfaces and type aliases</span><span class="s2">\n    </span><span class="s1">parseExpressionStatement(</span><span class="s2">\n      </span><span class="s1">node: N.ExpressionStatement,</span><span class="s2">\n      </span><span class="s1">expr: N.Expression,</span><span class="s2">\n      </span><span class="s1">decorators: N.Decorator[] | null,</span><span class="s2">\n    </span><span class="s1">): N.ExpressionStatement {</span><span class="s2">\n      </span><span class="s1">if (expr.type === </span><span class="s2">\&quot;</span><span class="s1">Identifier</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">if (expr.name === </span><span class="s2">\&quot;</span><span class="s1">declare</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">if (</span><span class="s2">\n            </span><span class="s1">this.match(tt._class) ||</span><span class="s2">\n            </span><span class="s1">tokenIsIdentifier(this.state.type) ||</span><span class="s2">\n            </span><span class="s1">this.match(tt._function) ||</span><span class="s2">\n            </span><span class="s1">this.match(tt._var) ||</span><span class="s2">\n            </span><span class="s1">this.match(tt._export)</span><span class="s2">\n          </span><span class="s1">) {</span><span class="s2">\n            </span><span class="s1">// @ts-expect-error: refine typings</span><span class="s2">\n            </span><span class="s1">return this.flowParseDeclare(node);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">} else if (tokenIsIdentifier(this.state.type)) {</span><span class="s2">\n          </span><span class="s1">if (expr.name === </span><span class="s2">\&quot;</span><span class="s1">interface</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n            </span><span class="s1">// @ts-expect-error: refine typings</span><span class="s2">\n            </span><span class="s1">return this.flowParseInterface(node);</span><span class="s2">\n          </span><span class="s1">} else if (expr.name === </span><span class="s2">\&quot;</span><span class="s1">type</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n            </span><span class="s1">// @ts-expect-error: refine typings</span><span class="s2">\n            </span><span class="s1">return this.flowParseTypeAlias(node);</span><span class="s2">\n          </span><span class="s1">} else if (expr.name === </span><span class="s2">\&quot;</span><span class="s1">opaque</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n            </span><span class="s1">// @ts-expect-error: refine typings</span><span class="s2">\n            </span><span class="s1">return this.flowParseOpaqueType(node, false);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return super.parseExpressionStatement(node, expr, decorators);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// export type</span><span class="s2">\n    </span><span class="s1">shouldParseExportDeclaration(): boolean {</span><span class="s2">\n      </span><span class="s1">const { type } = this.state;</span><span class="s2">\n      </span><span class="s1">if (</span><span class="s2">\n        </span><span class="s1">tokenIsFlowInterfaceOrTypeOrOpaque(type) ||</span><span class="s2">\n        </span><span class="s1">(this.shouldParseEnums() &amp;&amp; type === tt._enum)</span><span class="s2">\n      </span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">return !this.state.containsEsc;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return super.shouldParseExportDeclaration();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">isExportDefaultSpecifier(): boolean {</span><span class="s2">\n      </span><span class="s1">const { type } = this.state;</span><span class="s2">\n      </span><span class="s1">if (</span><span class="s2">\n        </span><span class="s1">tokenIsFlowInterfaceOrTypeOrOpaque(type) ||</span><span class="s2">\n        </span><span class="s1">(this.shouldParseEnums() &amp;&amp; type === tt._enum)</span><span class="s2">\n      </span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">return this.state.containsEsc;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return super.isExportDefaultSpecifier();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseExportDefaultExpression(): N.Expression | N.Declaration {</span><span class="s2">\n      </span><span class="s1">if (this.shouldParseEnums() &amp;&amp; this.isContextual(tt._enum)) {</span><span class="s2">\n        </span><span class="s1">const node = this.startNode();</span><span class="s2">\n        </span><span class="s1">this.next();</span><span class="s2">\n        </span><span class="s1">return this.flowParseEnumDeclaration(node);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return super.parseExportDefaultExpression();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseConditional(</span><span class="s2">\n      </span><span class="s1">expr: N.Expression,</span><span class="s2">\n\n      </span><span class="s1">startLoc: Position,</span><span class="s2">\n      </span><span class="s1">refExpressionErrors?: ExpressionErrors | null,</span><span class="s2">\n    </span><span class="s1">): N.Expression {</span><span class="s2">\n      </span><span class="s1">if (!this.match(tt.question)) return expr;</span><span class="s2">\n\n      </span><span class="s1">if (this.state.maybeInArrowParameters) {</span><span class="s2">\n        </span><span class="s1">const nextCh = this.lookaheadCharCode();</span><span class="s2">\n        </span><span class="s1">// These tokens cannot start an expression, so if one of them follows</span><span class="s2">\n        </span><span class="s1">// ? then we are probably in an arrow function parameters list and we</span><span class="s2">\n        </span><span class="s1">// don't parse the conditional expression.</span><span class="s2">\n        </span><span class="s1">if (</span><span class="s2">\n          </span><span class="s1">nextCh === charCodes.comma || // (a?, b) =&gt; c</span><span class="s2">\n          </span><span class="s1">nextCh === charCodes.equalsTo || // (a? = b) =&gt; c</span><span class="s2">\n          </span><span class="s1">nextCh === charCodes.colon || // (a?: b) =&gt; c</span><span class="s2">\n          </span><span class="s1">nextCh === charCodes.rightParenthesis // (a?) =&gt; c</span><span class="s2">\n        </span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">/*:: invariant(refExpressionErrors != null) */</span><span class="s2">\n          </span><span class="s1">this.setOptionalParametersError(refExpressionErrors);</span><span class="s2">\n          </span><span class="s1">return expr;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">this.expect(tt.question);</span><span class="s2">\n      </span><span class="s1">const state = this.state.clone();</span><span class="s2">\n      </span><span class="s1">const originalNoArrowAt = this.state.noArrowAt;</span><span class="s2">\n      </span><span class="s1">const node = this.startNodeAt(startLoc);</span><span class="s2">\n      </span><span class="s1">let { consequent, failed } = this.tryParseConditionalConsequent();</span><span class="s2">\n      </span><span class="s1">let [valid, invalid] = this.getArrowLikeExpressions(consequent);</span><span class="s2">\n\n      </span><span class="s1">if (failed || invalid.length &gt; 0) {</span><span class="s2">\n        </span><span class="s1">const noArrowAt = [...originalNoArrowAt];</span><span class="s2">\n\n        </span><span class="s1">if (invalid.length &gt; 0) {</span><span class="s2">\n          </span><span class="s1">this.state = state;</span><span class="s2">\n          </span><span class="s1">this.state.noArrowAt = noArrowAt;</span><span class="s2">\n\n          </span><span class="s1">for (let i = 0; i &lt; invalid.length; i++) {</span><span class="s2">\n            </span><span class="s1">noArrowAt.push(invalid[i].start);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n\n          </span><span class="s1">({ consequent, failed } = this.tryParseConditionalConsequent());</span><span class="s2">\n          </span><span class="s1">[valid, invalid] = this.getArrowLikeExpressions(consequent);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">if (failed &amp;&amp; valid.length &gt; 1) {</span><span class="s2">\n          </span><span class="s1">// if there are two or more possible correct ways of parsing, throw an</span><span class="s2">\n          </span><span class="s1">// error.</span><span class="s2">\n          </span><span class="s1">// e.g.   Source: a ? (b): c =&gt; (d): e =&gt; f</span><span class="s2">\n          </span><span class="s1">//      Result 1: a ? b : (c =&gt; ((d): e =&gt; f))</span><span class="s2">\n          </span><span class="s1">//      Result 2: a ? ((b): c =&gt; d) : (e =&gt; f)</span><span class="s2">\n          </span><span class="s1">this.raise(FlowErrors.AmbiguousConditionalArrow, {</span><span class="s2">\n            </span><span class="s1">at: state.startLoc,</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">if (failed &amp;&amp; valid.length === 1) {</span><span class="s2">\n          </span><span class="s1">this.state = state;</span><span class="s2">\n          </span><span class="s1">noArrowAt.push(valid[0].start);</span><span class="s2">\n          </span><span class="s1">this.state.noArrowAt = noArrowAt;</span><span class="s2">\n          </span><span class="s1">({ consequent, failed } = this.tryParseConditionalConsequent());</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">this.getArrowLikeExpressions(consequent, true);</span><span class="s2">\n\n      </span><span class="s1">this.state.noArrowAt = originalNoArrowAt;</span><span class="s2">\n      </span><span class="s1">this.expect(tt.colon);</span><span class="s2">\n\n      </span><span class="s1">node.test = expr;</span><span class="s2">\n      </span><span class="s1">node.consequent = consequent;</span><span class="s2">\n      </span><span class="s1">node.alternate = this.forwardNoArrowParamsConversionAt(node, () =&gt;</span><span class="s2">\n        </span><span class="s1">this.parseMaybeAssign(undefined, undefined),</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">ConditionalExpression</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tryParseConditionalConsequent(): {</span><span class="s2">\n      </span><span class="s1">consequent: N.Expression;</span><span class="s2">\n      </span><span class="s1">failed: boolean;</span><span class="s2">\n    </span><span class="s1">} {</span><span class="s2">\n      </span><span class="s1">this.state.noArrowParamsConversionAt.push(this.state.start);</span><span class="s2">\n\n      </span><span class="s1">const consequent = this.parseMaybeAssignAllowIn();</span><span class="s2">\n      </span><span class="s1">const failed = !this.match(tt.colon);</span><span class="s2">\n\n      </span><span class="s1">this.state.noArrowParamsConversionAt.pop();</span><span class="s2">\n\n      </span><span class="s1">return { consequent, failed };</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// Given an expression, walks through out its arrow functions whose body is</span><span class="s2">\n    </span><span class="s1">// an expression and through out conditional expressions. It returns every</span><span class="s2">\n    </span><span class="s1">// function which has been parsed with a return type but could have been</span><span class="s2">\n    </span><span class="s1">// parenthesized expressions.</span><span class="s2">\n    </span><span class="s1">// These functions are separated into two arrays: one containing the ones</span><span class="s2">\n    </span><span class="s1">// whose parameters can be converted to assignable lists, one containing the</span><span class="s2">\n    </span><span class="s1">// others.</span><span class="s2">\n    </span><span class="s1">getArrowLikeExpressions(</span><span class="s2">\n      </span><span class="s1">node: N.Expression,</span><span class="s2">\n      </span><span class="s1">disallowInvalid?: boolean,</span><span class="s2">\n    </span><span class="s1">): [N.ArrowFunctionExpression[], N.ArrowFunctionExpression[]] {</span><span class="s2">\n      </span><span class="s1">const stack = [node];</span><span class="s2">\n      </span><span class="s1">const arrows: N.ArrowFunctionExpression[] = [];</span><span class="s2">\n\n      </span><span class="s1">while (stack.length !== 0) {</span><span class="s2">\n        </span><span class="s1">const node = stack.pop();</span><span class="s2">\n        </span><span class="s1">if (node.type === </span><span class="s2">\&quot;</span><span class="s1">ArrowFunctionExpression</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">if (node.typeParameters || !node.returnType) {</span><span class="s2">\n            </span><span class="s1">// This is an arrow expression without ambiguity, so check its parameters</span><span class="s2">\n            </span><span class="s1">// @ts-expect-error: refine typings</span><span class="s2">\n            </span><span class="s1">this.finishArrowValidation(node);</span><span class="s2">\n          </span><span class="s1">} else {</span><span class="s2">\n            </span><span class="s1">// @ts-expect-error: refine typings</span><span class="s2">\n            </span><span class="s1">arrows.push(node);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">stack.push(node.body);</span><span class="s2">\n        </span><span class="s1">} else if (node.type === </span><span class="s2">\&quot;</span><span class="s1">ConditionalExpression</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">stack.push(node.consequent);</span><span class="s2">\n          </span><span class="s1">stack.push(node.alternate);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">if (disallowInvalid) {</span><span class="s2">\n        </span><span class="s1">arrows.forEach(node =&gt; this.finishArrowValidation(node));</span><span class="s2">\n        </span><span class="s1">return [arrows, []];</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return partition(arrows, node =&gt;</span><span class="s2">\n        </span><span class="s1">node.params.every(param =&gt; this.isAssignable(param, true)),</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">finishArrowValidation(node: N.ArrowFunctionExpression) {</span><span class="s2">\n      </span><span class="s1">this.toAssignableList(</span><span class="s2">\n        </span><span class="s1">// node.params is Expression[] instead of $ReadOnlyArray&lt;Pattern&gt; because it</span><span class="s2">\n        </span><span class="s1">// has not been converted yet.</span><span class="s2">\n        </span><span class="s1">node.params as any as N.Expression[],</span><span class="s2">\n        </span><span class="s1">node.extra?.trailingCommaLoc,</span><span class="s2">\n        </span><span class="s1">/* isLHS */ false,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">// Enter scope, as checkParams defines bindings</span><span class="s2">\n      </span><span class="s1">this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);</span><span class="s2">\n      </span><span class="s1">// Use super's method to force the parameters to be checked</span><span class="s2">\n      </span><span class="s1">super.checkParams(node, false, true);</span><span class="s2">\n      </span><span class="s1">this.scope.exit();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">forwardNoArrowParamsConversionAt&lt;T&gt;(</span><span class="s2">\n      </span><span class="s1">node: Undone&lt;N.Node&gt;,</span><span class="s2">\n      </span><span class="s1">parse: () =&gt; T,</span><span class="s2">\n    </span><span class="s1">): T {</span><span class="s2">\n      </span><span class="s1">let result: T;</span><span class="s2">\n      </span><span class="s1">if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {</span><span class="s2">\n        </span><span class="s1">this.state.noArrowParamsConversionAt.push(this.state.start);</span><span class="s2">\n        </span><span class="s1">result = parse();</span><span class="s2">\n        </span><span class="s1">this.state.noArrowParamsConversionAt.pop();</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">result = parse();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return result;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseParenItem(</span><span class="s2">\n      </span><span class="s1">node: N.Expression,</span><span class="s2">\n\n      </span><span class="s1">startLoc: Position,</span><span class="s2">\n    </span><span class="s1">): N.Expression {</span><span class="s2">\n      </span><span class="s1">node = super.parseParenItem(node, startLoc);</span><span class="s2">\n      </span><span class="s1">if (this.eat(tt.question)) {</span><span class="s2">\n        </span><span class="s1">node.optional = true;</span><span class="s2">\n        </span><span class="s1">// Include questionmark in location of node</span><span class="s2">\n        </span><span class="s1">// Don't use this.finishNode() as otherwise we might process comments twice and</span><span class="s2">\n        </span><span class="s1">// include already consumed parens</span><span class="s2">\n        </span><span class="s1">this.resetEndLocation(node);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">if (this.match(tt.colon)) {</span><span class="s2">\n        </span><span class="s1">const typeCastNode = this.startNodeAt(startLoc);</span><span class="s2">\n        </span><span class="s1">typeCastNode.expression = node;</span><span class="s2">\n        </span><span class="s1">typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();</span><span class="s2">\n\n        </span><span class="s1">return this.finishNode(typeCastNode, </span><span class="s2">\&quot;</span><span class="s1">TypeCastExpression</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return node;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">assertModuleNodeAllowed(node: N.Node) {</span><span class="s2">\n      </span><span class="s1">if (</span><span class="s2">\n        </span><span class="s1">(node.type === </span><span class="s2">\&quot;</span><span class="s1">ImportDeclaration</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n          </span><span class="s1">(node.importKind === </span><span class="s2">\&quot;</span><span class="s1">type</span><span class="s2">\&quot; </span><span class="s1">|| node.importKind === </span><span class="s2">\&quot;</span><span class="s1">typeof</span><span class="s2">\&quot;</span><span class="s1">)) ||</span><span class="s2">\n        </span><span class="s1">(node.type === </span><span class="s2">\&quot;</span><span class="s1">ExportNamedDeclaration</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n          </span><span class="s1">node.exportKind === </span><span class="s2">\&quot;</span><span class="s1">type</span><span class="s2">\&quot;</span><span class="s1">) ||</span><span class="s2">\n        </span><span class="s1">(node.type === </span><span class="s2">\&quot;</span><span class="s1">ExportAllDeclaration</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; node.exportKind === </span><span class="s2">\&quot;</span><span class="s1">type</span><span class="s2">\&quot;</span><span class="s1">)</span><span class="s2">\n      </span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">// Allow Flowtype imports and exports in all conditions because</span><span class="s2">\n        </span><span class="s1">// Flow itself does not care about 'sourceType'.</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">super.assertModuleNodeAllowed(node);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseExport(</span><span class="s2">\n      </span><span class="s1">node: Undone&lt;N.ExportNamedDeclaration | N.ExportAllDeclaration&gt;,</span><span class="s2">\n      </span><span class="s1">decorators: N.Decorator[] | null,</span><span class="s2">\n    </span><span class="s1">): N.AnyExport {</span><span class="s2">\n      </span><span class="s1">const decl = super.parseExport(node, decorators);</span><span class="s2">\n      </span><span class="s1">if (</span><span class="s2">\n        </span><span class="s1">decl.type === </span><span class="s2">\&quot;</span><span class="s1">ExportNamedDeclaration</span><span class="s2">\&quot; </span><span class="s1">||</span><span class="s2">\n        </span><span class="s1">decl.type === </span><span class="s2">\&quot;</span><span class="s1">ExportAllDeclaration</span><span class="s2">\&quot;\n      </span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">decl.exportKind = decl.exportKind || </span><span class="s2">\&quot;</span><span class="s1">value</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return decl;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseExportDeclaration(</span><span class="s2">\n      </span><span class="s1">node: N.ExportNamedDeclaration,</span><span class="s2">\n    </span><span class="s1">): N.Declaration | undefined | null {</span><span class="s2">\n      </span><span class="s1">if (this.isContextual(tt._type)) {</span><span class="s2">\n        </span><span class="s1">node.exportKind = </span><span class="s2">\&quot;</span><span class="s1">type</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n        </span><span class="s1">const declarationNode = this.startNode();</span><span class="s2">\n        </span><span class="s1">this.next();</span><span class="s2">\n\n        </span><span class="s1">if (this.match(tt.braceL)) {</span><span class="s2">\n          </span><span class="s1">// export type { foo, bar };</span><span class="s2">\n          </span><span class="s1">node.specifiers = this.parseExportSpecifiers(</span><span class="s2">\n            </span><span class="s1">/* isInTypeExport */ true,</span><span class="s2">\n          </span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">super.parseExportFrom(node);</span><span class="s2">\n          </span><span class="s1">return null;</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">// export type Foo = Bar;</span><span class="s2">\n          </span><span class="s1">// @ts-expect-error: refine typings</span><span class="s2">\n          </span><span class="s1">return this.flowParseTypeAlias(declarationNode);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">} else if (this.isContextual(tt._opaque)) {</span><span class="s2">\n        </span><span class="s1">node.exportKind = </span><span class="s2">\&quot;</span><span class="s1">type</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n        </span><span class="s1">const declarationNode = this.startNode();</span><span class="s2">\n        </span><span class="s1">this.next();</span><span class="s2">\n        </span><span class="s1">// export opaque type Foo = Bar;</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error: refine typings</span><span class="s2">\n        </span><span class="s1">return this.flowParseOpaqueType(declarationNode, false);</span><span class="s2">\n      </span><span class="s1">} else if (this.isContextual(tt._interface)) {</span><span class="s2">\n        </span><span class="s1">node.exportKind = </span><span class="s2">\&quot;</span><span class="s1">type</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n        </span><span class="s1">const declarationNode = this.startNode();</span><span class="s2">\n        </span><span class="s1">this.next();</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error: refine typings</span><span class="s2">\n        </span><span class="s1">return this.flowParseInterface(declarationNode);</span><span class="s2">\n      </span><span class="s1">} else if (this.shouldParseEnums() &amp;&amp; this.isContextual(tt._enum)) {</span><span class="s2">\n        </span><span class="s1">node.exportKind = </span><span class="s2">\&quot;</span><span class="s1">value</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n        </span><span class="s1">const declarationNode = this.startNode();</span><span class="s2">\n        </span><span class="s1">this.next();</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error: refine typings</span><span class="s2">\n        </span><span class="s1">return this.flowParseEnumDeclaration(declarationNode);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">return super.parseExportDeclaration(node);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">eatExportStar(node: N.Node): boolean {</span><span class="s2">\n      </span><span class="s1">if (super.eatExportStar(node)) return true;</span><span class="s2">\n\n      </span><span class="s1">if (this.isContextual(tt._type) &amp;&amp; this.lookahead().type === tt.star) {</span><span class="s2">\n        </span><span class="s1">node.exportKind = </span><span class="s2">\&quot;</span><span class="s1">type</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n        </span><span class="s1">this.next();</span><span class="s2">\n        </span><span class="s1">this.next();</span><span class="s2">\n        </span><span class="s1">return true;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return false;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">maybeParseExportNamespaceSpecifier(node: N.Node): boolean {</span><span class="s2">\n      </span><span class="s1">const { startLoc } = this.state;</span><span class="s2">\n      </span><span class="s1">const hasNamespace = super.maybeParseExportNamespaceSpecifier(node);</span><span class="s2">\n      </span><span class="s1">if (hasNamespace &amp;&amp; node.exportKind === </span><span class="s2">\&quot;</span><span class="s1">type</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">this.unexpected(startLoc);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return hasNamespace;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseClassId(</span><span class="s2">\n      </span><span class="s1">node: N.Class,</span><span class="s2">\n      </span><span class="s1">isStatement: boolean,</span><span class="s2">\n      </span><span class="s1">optionalId?: boolean | null,</span><span class="s2">\n    </span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">super.parseClassId(node, isStatement, optionalId);</span><span class="s2">\n      </span><span class="s1">if (this.match(tt.lt)) {</span><span class="s2">\n        </span><span class="s1">node.typeParameters = this.flowParseTypeParameterDeclaration();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseClassMember(</span><span class="s2">\n      </span><span class="s1">classBody: N.ClassBody,</span><span class="s2">\n      </span><span class="s1">member: any,</span><span class="s2">\n      </span><span class="s1">state: N.ParseClassMemberState,</span><span class="s2">\n    </span><span class="s1">): void {</span><span class="s2">\n      </span><span class="s1">const { startLoc } = this.state;</span><span class="s2">\n      </span><span class="s1">if (this.isContextual(tt._declare)) {</span><span class="s2">\n        </span><span class="s1">if (super.parseClassMemberFromModifier(classBody, member)) {</span><span class="s2">\n          </span><span class="s1">// 'declare' is a class element name</span><span class="s2">\n          </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">member.declare = true;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">super.parseClassMember(classBody, member, state);</span><span class="s2">\n\n      </span><span class="s1">if (member.declare) {</span><span class="s2">\n        </span><span class="s1">if (</span><span class="s2">\n          </span><span class="s1">member.type !== </span><span class="s2">\&quot;</span><span class="s1">ClassProperty</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n          </span><span class="s1">member.type !== </span><span class="s2">\&quot;</span><span class="s1">ClassPrivateProperty</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n          </span><span class="s1">member.type !== </span><span class="s2">\&quot;</span><span class="s1">PropertyDefinition</span><span class="s2">\&quot; </span><span class="s1">// Used by estree plugin</span><span class="s2">\n        </span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">this.raise(FlowErrors.DeclareClassElement, { at: startLoc });</span><span class="s2">\n        </span><span class="s1">} else if (member.value) {</span><span class="s2">\n          </span><span class="s1">this.raise(FlowErrors.DeclareClassFieldInitializer, {</span><span class="s2">\n            </span><span class="s1">at: member.value,</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">isIterator(word: string): boolean {</span><span class="s2">\n      </span><span class="s1">return word === </span><span class="s2">\&quot;</span><span class="s1">iterator</span><span class="s2">\&quot; </span><span class="s1">|| word === </span><span class="s2">\&quot;</span><span class="s1">asyncIterator</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">readIterator(): void {</span><span class="s2">\n      </span><span class="s1">const word = super.readWord1();</span><span class="s2">\n      </span><span class="s1">const fullWord = </span><span class="s2">\&quot;</span><span class="s1">@@</span><span class="s2">\&quot; </span><span class="s1">+ word;</span><span class="s2">\n\n      </span><span class="s1">// Allow @@iterator and @@asyncIterator as a identifier only inside type</span><span class="s2">\n      </span><span class="s1">if (!this.isIterator(word) || !this.state.inType) {</span><span class="s2">\n        </span><span class="s1">this.raise(Errors.InvalidIdentifier, {</span><span class="s2">\n          </span><span class="s1">at: this.state.curPosition(),</span><span class="s2">\n          </span><span class="s1">identifierName: fullWord,</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">this.finishToken(tt.name, fullWord);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// ensure that inside flow types, we bypass the jsx parser plugin</span><span class="s2">\n    </span><span class="s1">getTokenFromCode(code: number): void {</span><span class="s2">\n      </span><span class="s1">const next = this.input.charCodeAt(this.state.pos + 1);</span><span class="s2">\n      </span><span class="s1">if (code === charCodes.leftCurlyBrace &amp;&amp; next === charCodes.verticalBar) {</span><span class="s2">\n        </span><span class="s1">this.finishOp(tt.braceBarL, 2);</span><span class="s2">\n      </span><span class="s1">} else if (</span><span class="s2">\n        </span><span class="s1">this.state.inType &amp;&amp;</span><span class="s2">\n        </span><span class="s1">(code === charCodes.greaterThan || code === charCodes.lessThan)</span><span class="s2">\n      </span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">this.finishOp(code === charCodes.greaterThan ? tt.gt : tt.lt, 1);</span><span class="s2">\n      </span><span class="s1">} else if (this.state.inType &amp;&amp; code === charCodes.questionMark) {</span><span class="s2">\n        </span><span class="s1">if (next === charCodes.dot) {</span><span class="s2">\n          </span><span class="s1">this.finishOp(tt.questionDot, 2);</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">// allow double nullable types in Flow: ??string</span><span class="s2">\n          </span><span class="s1">this.finishOp(tt.question, 1);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">} else if (</span><span class="s2">\n        </span><span class="s1">isIteratorStart(code, next, this.input.charCodeAt(this.state.pos + 2))</span><span class="s2">\n      </span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">this.state.pos += 2; // eat </span><span class="s2">\&quot;</span><span class="s1">@@</span><span class="s2">\&quot;\n        </span><span class="s1">this.readIterator();</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">super.getTokenFromCode(code);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">isAssignable(node: N.Node, isBinding?: boolean): boolean {</span><span class="s2">\n      </span><span class="s1">if (node.type === </span><span class="s2">\&quot;</span><span class="s1">TypeCastExpression</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">return this.isAssignable(node.expression, isBinding);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">return super.isAssignable(node, isBinding);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">toAssignable(node: N.Node, isLHS: boolean = false): void {</span><span class="s2">\n      </span><span class="s1">if (</span><span class="s2">\n        </span><span class="s1">!isLHS &amp;&amp;</span><span class="s2">\n        </span><span class="s1">node.type === </span><span class="s2">\&quot;</span><span class="s1">AssignmentExpression</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n        </span><span class="s1">node.left.type === </span><span class="s2">\&quot;</span><span class="s1">TypeCastExpression</span><span class="s2">\&quot;\n      </span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">node.left = this.typeCastToParameter(node.left);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">super.toAssignable(node, isLHS);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// turn type casts that we found in function parameter head into type annotated params</span><span class="s2">\n    </span><span class="s1">toAssignableList(</span><span class="s2">\n      </span><span class="s1">exprList: N.Expression[],</span><span class="s2">\n      </span><span class="s1">trailingCommaLoc: Position | undefined | null,</span><span class="s2">\n      </span><span class="s1">isLHS: boolean,</span><span class="s2">\n    </span><span class="s1">): void {</span><span class="s2">\n      </span><span class="s1">for (let i = 0; i &lt; exprList.length; i++) {</span><span class="s2">\n        </span><span class="s1">const expr = exprList[i];</span><span class="s2">\n        </span><span class="s1">if (expr?.type === </span><span class="s2">\&quot;</span><span class="s1">TypeCastExpression</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">exprList[i] = this.typeCastToParameter(expr);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">super.toAssignableList(exprList, trailingCommaLoc, isLHS);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// this is a list of nodes, from something like a call expression, we need to filter the</span><span class="s2">\n    </span><span class="s1">// type casts that we've found that are illegal in this context</span><span class="s2">\n    </span><span class="s1">toReferencedList(</span><span class="s2">\n      </span><span class="s1">exprList: ReadonlyArray&lt;N.Expression | undefined | null&gt;,</span><span class="s2">\n      </span><span class="s1">isParenthesizedExpr?: boolean,</span><span class="s2">\n    </span><span class="s1">): ReadonlyArray&lt;N.Expression | undefined | null&gt; {</span><span class="s2">\n      </span><span class="s1">for (let i = 0; i &lt; exprList.length; i++) {</span><span class="s2">\n        </span><span class="s1">const expr = exprList[i];</span><span class="s2">\n        </span><span class="s1">if (</span><span class="s2">\n          </span><span class="s1">expr &amp;&amp;</span><span class="s2">\n          </span><span class="s1">expr.type === </span><span class="s2">\&quot;</span><span class="s1">TypeCastExpression</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n          </span><span class="s1">!expr.extra?.parenthesized &amp;&amp;</span><span class="s2">\n          </span><span class="s1">(exprList.length &gt; 1 || !isParenthesizedExpr)</span><span class="s2">\n        </span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">this.raise(FlowErrors.TypeCastInPattern, {</span><span class="s2">\n            </span><span class="s1">at: expr.typeAnnotation,</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return exprList;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseArrayLike(</span><span class="s2">\n      </span><span class="s1">close: TokenType,</span><span class="s2">\n      </span><span class="s1">canBePattern: boolean,</span><span class="s2">\n      </span><span class="s1">isTuple: boolean,</span><span class="s2">\n      </span><span class="s1">refExpressionErrors?: ExpressionErrors | null,</span><span class="s2">\n    </span><span class="s1">): N.ArrayExpression | N.TupleExpression {</span><span class="s2">\n      </span><span class="s1">const node = super.parseArrayLike(</span><span class="s2">\n        </span><span class="s1">close,</span><span class="s2">\n        </span><span class="s1">canBePattern,</span><span class="s2">\n        </span><span class="s1">isTuple,</span><span class="s2">\n        </span><span class="s1">refExpressionErrors,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n\n      </span><span class="s1">// This could be an array pattern:</span><span class="s2">\n      </span><span class="s1">//   ([a: string, b: string]) =&gt; {}</span><span class="s2">\n      </span><span class="s1">// In this case, we don't have to call toReferencedList. We will</span><span class="s2">\n      </span><span class="s1">// call it, if needed, when we are sure that it is a parenthesized</span><span class="s2">\n      </span><span class="s1">// expression by calling toReferencedListDeep.</span><span class="s2">\n      </span><span class="s1">if (canBePattern &amp;&amp; !this.state.maybeInArrowParameters) {</span><span class="s2">\n        </span><span class="s1">this.toReferencedList(node.elements);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return node;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">isValidLVal(type: string, isParenthesized: boolean, binding: BindingTypes) {</span><span class="s2">\n      </span><span class="s1">return (</span><span class="s2">\n        </span><span class="s1">type === </span><span class="s2">\&quot;</span><span class="s1">TypeCastExpression</span><span class="s2">\&quot; </span><span class="s1">||</span><span class="s2">\n        </span><span class="s1">super.isValidLVal(type, isParenthesized, binding)</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// parse class property type annotations</span><span class="s2">\n    </span><span class="s1">parseClassProperty(node: N.ClassProperty): N.ClassProperty {</span><span class="s2">\n      </span><span class="s1">if (this.match(tt.colon)) {</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error refine typings</span><span class="s2">\n        </span><span class="s1">node.typeAnnotation = this.flowParseTypeAnnotation();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return super.parseClassProperty(node);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseClassPrivateProperty(</span><span class="s2">\n      </span><span class="s1">node: N.ClassPrivateProperty,</span><span class="s2">\n    </span><span class="s1">): N.ClassPrivateProperty {</span><span class="s2">\n      </span><span class="s1">if (this.match(tt.colon)) {</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error refine typings</span><span class="s2">\n        </span><span class="s1">node.typeAnnotation = this.flowParseTypeAnnotation();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return super.parseClassPrivateProperty(node);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// determine whether or not we're currently in the position where a class method would appear</span><span class="s2">\n    </span><span class="s1">isClassMethod(): boolean {</span><span class="s2">\n      </span><span class="s1">return this.match(tt.lt) || super.isClassMethod();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// determine whether or not we're currently in the position where a class property would appear</span><span class="s2">\n    </span><span class="s1">isClassProperty(): boolean {</span><span class="s2">\n      </span><span class="s1">return this.match(tt.colon) || super.isClassProperty();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">isNonstaticConstructor(method: N.ClassMethod | N.ClassProperty): boolean {</span><span class="s2">\n      </span><span class="s1">return !this.match(tt.colon) &amp;&amp; super.isNonstaticConstructor(method);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// parse type parameters for class methods</span><span class="s2">\n    </span><span class="s1">pushClassMethod(</span><span class="s2">\n      </span><span class="s1">classBody: N.ClassBody,</span><span class="s2">\n      </span><span class="s1">method: N.ClassMethod,</span><span class="s2">\n      </span><span class="s1">isGenerator: boolean,</span><span class="s2">\n      </span><span class="s1">isAsync: boolean,</span><span class="s2">\n      </span><span class="s1">isConstructor: boolean,</span><span class="s2">\n      </span><span class="s1">allowsDirectSuper: boolean,</span><span class="s2">\n    </span><span class="s1">): void {</span><span class="s2">\n      </span><span class="s1">if ((method as any).variance) {</span><span class="s2">\n        </span><span class="s1">this.unexpected((method as any).variance.loc.start);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">delete (method as any).variance;</span><span class="s2">\n      </span><span class="s1">if (this.match(tt.lt)) {</span><span class="s2">\n        </span><span class="s1">method.typeParameters = this.flowParseTypeParameterDeclaration();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">super.pushClassMethod(</span><span class="s2">\n        </span><span class="s1">classBody,</span><span class="s2">\n        </span><span class="s1">method,</span><span class="s2">\n        </span><span class="s1">isGenerator,</span><span class="s2">\n        </span><span class="s1">isAsync,</span><span class="s2">\n        </span><span class="s1">isConstructor,</span><span class="s2">\n        </span><span class="s1">allowsDirectSuper,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n\n      </span><span class="s1">if (method.params &amp;&amp; isConstructor) {</span><span class="s2">\n        </span><span class="s1">const params = method.params;</span><span class="s2">\n        </span><span class="s1">if (params.length &gt; 0 &amp;&amp; this.isThisParam(params[0])) {</span><span class="s2">\n          </span><span class="s1">this.raise(FlowErrors.ThisParamBannedInConstructor, { at: method });</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// estree support</span><span class="s2">\n      </span><span class="s1">} else if (</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error TS does not know about the face that estree can replace ClassMethod with MethodDefinition</span><span class="s2">\n        </span><span class="s1">method.type === </span><span class="s2">\&quot;</span><span class="s1">MethodDefinition</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n        </span><span class="s1">isConstructor &amp;&amp;</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error estree</span><span class="s2">\n        </span><span class="s1">method.value.params</span><span class="s2">\n      </span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error estree</span><span class="s2">\n        </span><span class="s1">const params = method.value.params;</span><span class="s2">\n        </span><span class="s1">if (params.length &gt; 0 &amp;&amp; this.isThisParam(params[0])) {</span><span class="s2">\n          </span><span class="s1">this.raise(FlowErrors.ThisParamBannedInConstructor, { at: method });</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">pushClassPrivateMethod(</span><span class="s2">\n      </span><span class="s1">classBody: N.ClassBody,</span><span class="s2">\n      </span><span class="s1">method: N.ClassPrivateMethod,</span><span class="s2">\n      </span><span class="s1">isGenerator: boolean,</span><span class="s2">\n      </span><span class="s1">isAsync: boolean,</span><span class="s2">\n    </span><span class="s1">): void {</span><span class="s2">\n      </span><span class="s1">if ((method as any).variance) {</span><span class="s2">\n        </span><span class="s1">this.unexpected((method as any).variance.loc.start);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">delete (method as any).variance;</span><span class="s2">\n      </span><span class="s1">if (this.match(tt.lt)) {</span><span class="s2">\n        </span><span class="s1">method.typeParameters = this.flowParseTypeParameterDeclaration();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// parse a the super class type parameters and implements</span><span class="s2">\n    </span><span class="s1">parseClassSuper(node: N.Class): void {</span><span class="s2">\n      </span><span class="s1">super.parseClassSuper(node);</span><span class="s2">\n      </span><span class="s1">if (node.superClass &amp;&amp; this.match(tt.lt)) {</span><span class="s2">\n        </span><span class="s1">node.superTypeParameters = this.flowParseTypeParameterInstantiation();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (this.isContextual(tt._implements)) {</span><span class="s2">\n        </span><span class="s1">this.next();</span><span class="s2">\n        </span><span class="s1">const implemented: N.FlowClassImplements[] = (node.implements = []);</span><span class="s2">\n        </span><span class="s1">do {</span><span class="s2">\n          </span><span class="s1">const node = this.startNode();</span><span class="s2">\n          </span><span class="s1">node.id = this.flowParseRestrictedIdentifier(/*liberal*/ true);</span><span class="s2">\n          </span><span class="s1">if (this.match(tt.lt)) {</span><span class="s2">\n            </span><span class="s1">node.typeParameters = this.flowParseTypeParameterInstantiation();</span><span class="s2">\n          </span><span class="s1">} else {</span><span class="s2">\n            </span><span class="s1">node.typeParameters = null;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">implemented.push(this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">ClassImplements</span><span class="s2">\&quot;</span><span class="s1">));</span><span class="s2">\n        </span><span class="s1">} while (this.eat(tt.comma));</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">checkGetterSetterParams(method: N.ObjectMethod | N.ClassMethod): void {</span><span class="s2">\n      </span><span class="s1">super.checkGetterSetterParams(method);</span><span class="s2">\n      </span><span class="s1">const params = this.getObjectOrClassMethodParams(method);</span><span class="s2">\n      </span><span class="s1">if (params.length &gt; 0) {</span><span class="s2">\n        </span><span class="s1">const param = params[0];</span><span class="s2">\n        </span><span class="s1">if (this.isThisParam(param) &amp;&amp; method.kind === </span><span class="s2">\&quot;</span><span class="s1">get</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">this.raise(FlowErrors.GetterMayNotHaveThisParam, { at: param });</span><span class="s2">\n        </span><span class="s1">} else if (this.isThisParam(param)) {</span><span class="s2">\n          </span><span class="s1">this.raise(FlowErrors.SetterMayNotHaveThisParam, { at: param });</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parsePropertyNamePrefixOperator(</span><span class="s2">\n      </span><span class="s1">node: N.ObjectOrClassMember | N.ClassMember,</span><span class="s2">\n    </span><span class="s1">): void {</span><span class="s2">\n      </span><span class="s1">node.variance = this.flowParseVariance();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// parse type parameters for object method shorthand</span><span class="s2">\n    </span><span class="s1">parseObjPropValue(</span><span class="s2">\n      </span><span class="s1">prop: Undone&lt;N.ObjectMethod | N.ObjectProperty&gt;,</span><span class="s2">\n      </span><span class="s1">startLoc: Position | undefined | null,</span><span class="s2">\n      </span><span class="s1">isGenerator: boolean,</span><span class="s2">\n      </span><span class="s1">isAsync: boolean,</span><span class="s2">\n      </span><span class="s1">isPattern: boolean,</span><span class="s2">\n      </span><span class="s1">isAccessor: boolean,</span><span class="s2">\n      </span><span class="s1">refExpressionErrors?: ExpressionErrors | null,</span><span class="s2">\n    </span><span class="s1">): N.ObjectMethod | N.ObjectProperty {</span><span class="s2">\n      </span><span class="s1">if ((prop as any).variance) {</span><span class="s2">\n        </span><span class="s1">this.unexpected((prop as any).variance.loc.start);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">delete (prop as any).variance;</span><span class="s2">\n\n      </span><span class="s1">let typeParameters;</span><span class="s2">\n\n      </span><span class="s1">// method shorthand</span><span class="s2">\n      </span><span class="s1">if (this.match(tt.lt) &amp;&amp; !isAccessor) {</span><span class="s2">\n        </span><span class="s1">typeParameters = this.flowParseTypeParameterDeclaration();</span><span class="s2">\n        </span><span class="s1">if (!this.match(tt.parenL)) this.unexpected();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">const result = super.parseObjPropValue(</span><span class="s2">\n        </span><span class="s1">prop,</span><span class="s2">\n        </span><span class="s1">startLoc,</span><span class="s2">\n        </span><span class="s1">isGenerator,</span><span class="s2">\n        </span><span class="s1">isAsync,</span><span class="s2">\n        </span><span class="s1">isPattern,</span><span class="s2">\n        </span><span class="s1">isAccessor,</span><span class="s2">\n        </span><span class="s1">refExpressionErrors,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n\n      </span><span class="s1">// add typeParameters if we found them</span><span class="s2">\n      </span><span class="s1">if (typeParameters) {</span><span class="s2">\n        </span><span class="s1">(result.value || result).typeParameters = typeParameters;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return result;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseAssignableListItemTypes(param: N.Pattern): N.Pattern {</span><span class="s2">\n      </span><span class="s1">if (this.eat(tt.question)) {</span><span class="s2">\n        </span><span class="s1">if (param.type !== </span><span class="s2">\&quot;</span><span class="s1">Identifier</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">this.raise(FlowErrors.PatternIsOptional, { at: param });</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (this.isThisParam(param)) {</span><span class="s2">\n          </span><span class="s1">this.raise(FlowErrors.ThisParamMayNotBeOptional, { at: param });</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">(param as any as N.Identifier).optional = true;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (this.match(tt.colon)) {</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error: refine typings</span><span class="s2">\n        </span><span class="s1">param.typeAnnotation = this.flowParseTypeAnnotation();</span><span class="s2">\n      </span><span class="s1">} else if (this.isThisParam(param)) {</span><span class="s2">\n        </span><span class="s1">this.raise(FlowErrors.ThisParamAnnotationRequired, { at: param });</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">if (this.match(tt.eq) &amp;&amp; this.isThisParam(param)) {</span><span class="s2">\n        </span><span class="s1">this.raise(FlowErrors.ThisParamNoDefault, { at: param });</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">this.resetEndLocation(param);</span><span class="s2">\n      </span><span class="s1">return param;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseMaybeDefault(</span><span class="s2">\n      </span><span class="s1">startLoc?: Position | null,</span><span class="s2">\n      </span><span class="s1">left?: N.Pattern | null,</span><span class="s2">\n    </span><span class="s1">): N.Pattern {</span><span class="s2">\n      </span><span class="s1">const node = super.parseMaybeDefault(startLoc, left);</span><span class="s2">\n\n      </span><span class="s1">if (</span><span class="s2">\n        </span><span class="s1">node.type === </span><span class="s2">\&quot;</span><span class="s1">AssignmentPattern</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n        </span><span class="s1">node.typeAnnotation &amp;&amp;</span><span class="s2">\n        </span><span class="s1">node.right.start &lt; node.typeAnnotation.start</span><span class="s2">\n      </span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">this.raise(FlowErrors.TypeBeforeInitializer, {</span><span class="s2">\n          </span><span class="s1">at: node.typeAnnotation,</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return node;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">shouldParseDefaultImport(node: N.ImportDeclaration): boolean {</span><span class="s2">\n      </span><span class="s1">if (!hasTypeImportKind(node)) {</span><span class="s2">\n        </span><span class="s1">return super.shouldParseDefaultImport(node);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return isMaybeDefaultImport(this.state.type);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">checkImportReflection(node: Undone&lt;N.ImportDeclaration&gt;) {</span><span class="s2">\n      </span><span class="s1">super.checkImportReflection(node);</span><span class="s2">\n      </span><span class="s1">if (node.module &amp;&amp; node.importKind !== </span><span class="s2">\&quot;</span><span class="s1">value</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">this.raise(FlowErrors.ImportReflectionHasImportType, {</span><span class="s2">\n          </span><span class="s1">at: node.specifiers[0].loc.start,</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseImportSpecifierLocal&lt;</span><span class="s2">\n      </span><span class="s1">T extends</span><span class="s2">\n        </span><span class="s1">| N.ImportSpecifier</span><span class="s2">\n        </span><span class="s1">| N.ImportDefaultSpecifier</span><span class="s2">\n        </span><span class="s1">| N.ImportNamespaceSpecifier,</span><span class="s2">\n    </span><span class="s1">&gt;(node: N.ImportDeclaration, specifier: Undone&lt;T&gt;, type: T[</span><span class="s2">\&quot;</span><span class="s1">type</span><span class="s2">\&quot;</span><span class="s1">]): void {</span><span class="s2">\n      </span><span class="s1">specifier.local = hasTypeImportKind(node)</span><span class="s2">\n        </span><span class="s1">? this.flowParseRestrictedIdentifier(</span><span class="s2">\n            </span><span class="s1">/* liberal */ true,</span><span class="s2">\n            </span><span class="s1">/* declaration */ true,</span><span class="s2">\n          </span><span class="s1">)</span><span class="s2">\n        </span><span class="s1">: this.parseIdentifier();</span><span class="s2">\n\n      </span><span class="s1">node.specifiers.push(this.finishImportSpecifier(specifier, type));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// parse typeof and type imports</span><span class="s2">\n    </span><span class="s1">maybeParseDefaultImportSpecifier(node: N.ImportDeclaration): boolean {</span><span class="s2">\n      </span><span class="s1">node.importKind = </span><span class="s2">\&quot;</span><span class="s1">value</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n      </span><span class="s1">let kind = null;</span><span class="s2">\n      </span><span class="s1">if (this.match(tt._typeof)) {</span><span class="s2">\n        </span><span class="s1">kind = </span><span class="s2">\&quot;</span><span class="s1">typeof</span><span class="s2">\&quot; </span><span class="s1">as const;</span><span class="s2">\n      </span><span class="s1">} else if (this.isContextual(tt._type)) {</span><span class="s2">\n        </span><span class="s1">kind = </span><span class="s2">\&quot;</span><span class="s1">type</span><span class="s2">\&quot; </span><span class="s1">as const;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (kind) {</span><span class="s2">\n        </span><span class="s1">const lh = this.lookahead();</span><span class="s2">\n        </span><span class="s1">const { type } = lh;</span><span class="s2">\n\n        </span><span class="s1">// import type * is not allowed</span><span class="s2">\n        </span><span class="s1">if (kind === </span><span class="s2">\&quot;</span><span class="s1">type</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; type === tt.star) {</span><span class="s2">\n          </span><span class="s1">// FIXME: lh.start?</span><span class="s2">\n          </span><span class="s1">this.unexpected(null, lh.type);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">if (</span><span class="s2">\n          </span><span class="s1">isMaybeDefaultImport(type) ||</span><span class="s2">\n          </span><span class="s1">type === tt.braceL ||</span><span class="s2">\n          </span><span class="s1">type === tt.star</span><span class="s2">\n        </span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">this.next();</span><span class="s2">\n          </span><span class="s1">node.importKind = kind;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return super.maybeParseDefaultImportSpecifier(node);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// parse import-type/typeof shorthand</span><span class="s2">\n    </span><span class="s1">parseImportSpecifier(</span><span class="s2">\n      </span><span class="s1">specifier: any,</span><span class="s2">\n      </span><span class="s1">importedIsString: boolean,</span><span class="s2">\n      </span><span class="s1">isInTypeOnlyImport: boolean,</span><span class="s2">\n      </span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-unused-vars</span><span class="s2">\n      </span><span class="s1">isMaybeTypeOnly: boolean,</span><span class="s2">\n      </span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-unused-vars</span><span class="s2">\n      </span><span class="s1">bindingType: BindingTypes | undefined,</span><span class="s2">\n    </span><span class="s1">): N.ImportSpecifier {</span><span class="s2">\n      </span><span class="s1">const firstIdent = specifier.imported;</span><span class="s2">\n\n      </span><span class="s1">let specifierTypeKind = null;</span><span class="s2">\n      </span><span class="s1">if (firstIdent.type === </span><span class="s2">\&quot;</span><span class="s1">Identifier</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">if (firstIdent.name === </span><span class="s2">\&quot;</span><span class="s1">type</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">specifierTypeKind = </span><span class="s2">\&quot;</span><span class="s1">type</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n        </span><span class="s1">} else if (firstIdent.name === </span><span class="s2">\&quot;</span><span class="s1">typeof</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">specifierTypeKind = </span><span class="s2">\&quot;</span><span class="s1">typeof</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">let isBinding = false;</span><span class="s2">\n      </span><span class="s1">if (this.isContextual(tt._as) &amp;&amp; !this.isLookaheadContextual(</span><span class="s2">\&quot;</span><span class="s1">as</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n        </span><span class="s1">const as_ident = this.parseIdentifier(true);</span><span class="s2">\n        </span><span class="s1">if (</span><span class="s2">\n          </span><span class="s1">specifierTypeKind !== null &amp;&amp;</span><span class="s2">\n          </span><span class="s1">!tokenIsKeywordOrIdentifier(this.state.type)</span><span class="s2">\n        </span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">// `import {type as ,` or `import {type as }`</span><span class="s2">\n          </span><span class="s1">specifier.imported = as_ident;</span><span class="s2">\n          </span><span class="s1">specifier.importKind = specifierTypeKind;</span><span class="s2">\n          </span><span class="s1">specifier.local = cloneIdentifier(as_ident);</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">// `import {type as foo`</span><span class="s2">\n          </span><span class="s1">specifier.imported = firstIdent;</span><span class="s2">\n          </span><span class="s1">specifier.importKind = null;</span><span class="s2">\n          </span><span class="s1">specifier.local = this.parseIdentifier();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">if (</span><span class="s2">\n          </span><span class="s1">specifierTypeKind !== null &amp;&amp;</span><span class="s2">\n          </span><span class="s1">tokenIsKeywordOrIdentifier(this.state.type)</span><span class="s2">\n        </span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">// `import {type foo`</span><span class="s2">\n          </span><span class="s1">specifier.imported = this.parseIdentifier(true);</span><span class="s2">\n          </span><span class="s1">specifier.importKind = specifierTypeKind;</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">if (importedIsString) {</span><span class="s2">\n            </span><span class="s1">/*:: invariant(firstIdent instanceof N.StringLiteral) */</span><span class="s2">\n            </span><span class="s1">throw this.raise(Errors.ImportBindingIsString, {</span><span class="s2">\n              </span><span class="s1">at: specifier,</span><span class="s2">\n              </span><span class="s1">importName: firstIdent.value,</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">/*:: invariant(firstIdent instanceof N.Node) */</span><span class="s2">\n          </span><span class="s1">specifier.imported = firstIdent;</span><span class="s2">\n          </span><span class="s1">specifier.importKind = null;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">if (this.eatContextual(tt._as)) {</span><span class="s2">\n          </span><span class="s1">specifier.local = this.parseIdentifier();</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">isBinding = true;</span><span class="s2">\n          </span><span class="s1">specifier.local = cloneIdentifier(specifier.imported);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">const specifierIsTypeImport = hasTypeImportKind(specifier);</span><span class="s2">\n\n      </span><span class="s1">if (isInTypeOnlyImport &amp;&amp; specifierIsTypeImport) {</span><span class="s2">\n        </span><span class="s1">this.raise(FlowErrors.ImportTypeShorthandOnlyInPureImport, {</span><span class="s2">\n          </span><span class="s1">at: specifier,</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">if (isInTypeOnlyImport || specifierIsTypeImport) {</span><span class="s2">\n        </span><span class="s1">this.checkReservedType(</span><span class="s2">\n          </span><span class="s1">specifier.local.name,</span><span class="s2">\n          </span><span class="s1">specifier.local.loc.start,</span><span class="s2">\n          </span><span class="s1">/* declaration */ true,</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">if (isBinding &amp;&amp; !isInTypeOnlyImport &amp;&amp; !specifierIsTypeImport) {</span><span class="s2">\n        </span><span class="s1">this.checkReservedWord(</span><span class="s2">\n          </span><span class="s1">specifier.local.name,</span><span class="s2">\n          </span><span class="s1">specifier.loc.start,</span><span class="s2">\n          </span><span class="s1">true,</span><span class="s2">\n          </span><span class="s1">true,</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return this.finishImportSpecifier(specifier, </span><span class="s2">\&quot;</span><span class="s1">ImportSpecifier</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseBindingAtom(): N.Pattern {</span><span class="s2">\n      </span><span class="s1">switch (this.state.type) {</span><span class="s2">\n        </span><span class="s1">case tt._this:</span><span class="s2">\n          </span><span class="s1">// </span><span class="s2">\&quot;</span><span class="s1">this</span><span class="s2">\&quot; </span><span class="s1">may be the name of a parameter, so allow it.</span><span class="s2">\n          </span><span class="s1">return this.parseIdentifier(/* liberal */ true);</span><span class="s2">\n        </span><span class="s1">default:</span><span class="s2">\n          </span><span class="s1">return super.parseBindingAtom();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// parse function type parameters - function foo&lt;T&gt;() {}</span><span class="s2">\n    </span><span class="s1">parseFunctionParams(</span><span class="s2">\n      </span><span class="s1">node: Undone&lt;N.Function&gt;,</span><span class="s2">\n      </span><span class="s1">isConstructor: boolean,</span><span class="s2">\n    </span><span class="s1">): void {</span><span class="s2">\n      </span><span class="s1">// @ts-expect-error kind may not index node</span><span class="s2">\n      </span><span class="s1">const kind = node.kind;</span><span class="s2">\n      </span><span class="s1">if (kind !== </span><span class="s2">\&quot;</span><span class="s1">get</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; kind !== </span><span class="s2">\&quot;</span><span class="s1">set</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; this.match(tt.lt)) {</span><span class="s2">\n        </span><span class="s1">node.typeParameters = this.flowParseTypeParameterDeclaration();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">super.parseFunctionParams(node, isConstructor);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// parse flow type annotations on variable declarator heads - let foo: string = bar</span><span class="s2">\n    </span><span class="s1">parseVarId(</span><span class="s2">\n      </span><span class="s1">decl: N.VariableDeclarator,</span><span class="s2">\n      </span><span class="s1">kind: </span><span class="s2">\&quot;</span><span class="s1">var</span><span class="s2">\&quot; </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">let</span><span class="s2">\&quot; </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">const</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">): void {</span><span class="s2">\n      </span><span class="s1">super.parseVarId(decl, kind);</span><span class="s2">\n      </span><span class="s1">if (this.match(tt.colon)) {</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error: refine typings</span><span class="s2">\n        </span><span class="s1">decl.id.typeAnnotation = this.flowParseTypeAnnotation();</span><span class="s2">\n        </span><span class="s1">this.resetEndLocation(decl.id); // set end position to end of type</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// parse the return type of an async arrow function - let foo = (async (): number =&gt; {});</span><span class="s2">\n    </span><span class="s1">parseAsyncArrowFromCallExpression(</span><span class="s2">\n      </span><span class="s1">node: N.ArrowFunctionExpression,</span><span class="s2">\n      </span><span class="s1">call: N.CallExpression,</span><span class="s2">\n    </span><span class="s1">): N.ArrowFunctionExpression {</span><span class="s2">\n      </span><span class="s1">if (this.match(tt.colon)) {</span><span class="s2">\n        </span><span class="s1">const oldNoAnonFunctionType = this.state.noAnonFunctionType;</span><span class="s2">\n        </span><span class="s1">this.state.noAnonFunctionType = true;</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error refine typings</span><span class="s2">\n        </span><span class="s1">node.returnType = this.flowParseTypeAnnotation();</span><span class="s2">\n        </span><span class="s1">this.state.noAnonFunctionType = oldNoAnonFunctionType;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return super.parseAsyncArrowFromCallExpression(node, call);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// todo description</span><span class="s2">\n    </span><span class="s1">shouldParseAsyncArrow(): boolean {</span><span class="s2">\n      </span><span class="s1">return this.match(tt.colon) || super.shouldParseAsyncArrow();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// We need to support type parameter declarations for arrow functions. This</span><span class="s2">\n    </span><span class="s1">// is tricky. There are three situations we need to handle</span><span class="s2">\n    </span><span class="s1">//</span><span class="s2">\n    </span><span class="s1">// 1. This is either JSX or an arrow function. We'll try JSX first. If that</span><span class="s2">\n    </span><span class="s1">//    fails, we'll try an arrow function. If that fails, we'll throw the JSX</span><span class="s2">\n    </span><span class="s1">//    error.</span><span class="s2">\n    </span><span class="s1">// 2. This is an arrow function. We'll parse the type parameter declaration,</span><span class="s2">\n    </span><span class="s1">//    parse the rest, make sure the rest is an arrow function, and go from</span><span class="s2">\n    </span><span class="s1">//    there</span><span class="s2">\n    </span><span class="s1">// 3. This is neither. Just call the super method</span><span class="s2">\n    </span><span class="s1">parseMaybeAssign(</span><span class="s2">\n      </span><span class="s1">refExpressionErrors?: ExpressionErrors | null,</span><span class="s2">\n      </span><span class="s1">afterLeftParse?: Function,</span><span class="s2">\n    </span><span class="s1">): N.Expression {</span><span class="s2">\n      </span><span class="s1">let state = null;</span><span class="s2">\n\n      </span><span class="s1">let jsx;</span><span class="s2">\n\n      </span><span class="s1">if (</span><span class="s2">\n        </span><span class="s1">this.hasPlugin(</span><span class="s2">\&quot;</span><span class="s1">jsx</span><span class="s2">\&quot;</span><span class="s1">) &amp;&amp;</span><span class="s2">\n        </span><span class="s1">(this.match(tt.jsxTagStart) || this.match(tt.lt))</span><span class="s2">\n      </span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">state = this.state.clone();</span><span class="s2">\n\n        </span><span class="s1">jsx = this.tryParse(</span><span class="s2">\n          </span><span class="s1">() =&gt; super.parseMaybeAssign(refExpressionErrors, afterLeftParse),</span><span class="s2">\n          </span><span class="s1">state,</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n\n        </span><span class="s1">/*:: invariant(!jsx.aborted) */</span><span class="s2">\n        </span><span class="s1">/*:: invariant(jsx.node != null) */</span><span class="s2">\n        </span><span class="s1">if (!jsx.error) return jsx.node;</span><span class="s2">\n\n        </span><span class="s1">// Remove `tc.j_expr` and `tc.j_oTag` from context added</span><span class="s2">\n        </span><span class="s1">// by parsing `jsxTagStart` to stop the JSX plugin from</span><span class="s2">\n        </span><span class="s1">// messing with the tokens</span><span class="s2">\n        </span><span class="s1">const { context } = this.state;</span><span class="s2">\n        </span><span class="s1">const currentContext = context[context.length - 1];</span><span class="s2">\n        </span><span class="s1">if (currentContext === tc.j_oTag || currentContext === tc.j_expr) {</span><span class="s2">\n          </span><span class="s1">context.pop();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">if (jsx?.error || this.match(tt.lt)) {</span><span class="s2">\n        </span><span class="s1">state = state || this.state.clone();</span><span class="s2">\n\n        </span><span class="s1">let typeParameters: N.TypeParameterDeclaration;</span><span class="s2">\n\n        </span><span class="s1">const arrow = this.tryParse(abort =&gt; {</span><span class="s2">\n          </span><span class="s1">typeParameters = this.flowParseTypeParameterDeclaration();</span><span class="s2">\n\n          </span><span class="s1">const arrowExpression = this.forwardNoArrowParamsConversionAt(</span><span class="s2">\n            </span><span class="s1">typeParameters,</span><span class="s2">\n            </span><span class="s1">() =&gt; {</span><span class="s2">\n              </span><span class="s1">const result = super.parseMaybeAssign(</span><span class="s2">\n                </span><span class="s1">refExpressionErrors,</span><span class="s2">\n                </span><span class="s1">afterLeftParse,</span><span class="s2">\n              </span><span class="s1">);</span><span class="s2">\n\n              </span><span class="s1">this.resetStartLocationFromNode(result, typeParameters);</span><span class="s2">\n\n              </span><span class="s1">return result;</span><span class="s2">\n            </span><span class="s1">},</span><span class="s2">\n          </span><span class="s1">);</span><span class="s2">\n\n          </span><span class="s1">// &lt;T&gt;(() =&gt; {});</span><span class="s2">\n          </span><span class="s1">// &lt;T&gt;(() =&gt; {}: any);</span><span class="s2">\n          </span><span class="s1">if (arrowExpression.extra?.parenthesized) abort();</span><span class="s2">\n\n          </span><span class="s1">// The above can return a TypeCastExpression when the arrow</span><span class="s2">\n          </span><span class="s1">// expression is not wrapped in parens. See also `this.parseParenItem`.</span><span class="s2">\n          </span><span class="s1">// (&lt;T&gt;() =&gt; {}: any);</span><span class="s2">\n          </span><span class="s1">const expr = this.maybeUnwrapTypeCastExpression(arrowExpression);</span><span class="s2">\n\n          </span><span class="s1">if (expr.type !== </span><span class="s2">\&quot;</span><span class="s1">ArrowFunctionExpression</span><span class="s2">\&quot;</span><span class="s1">) abort();</span><span class="s2">\n\n          </span><span class="s1">expr.typeParameters = typeParameters;</span><span class="s2">\n          </span><span class="s1">this.resetStartLocationFromNode(expr, typeParameters);</span><span class="s2">\n\n          </span><span class="s1">return arrowExpression;</span><span class="s2">\n        </span><span class="s1">}, state);</span><span class="s2">\n\n        </span><span class="s1">let arrowExpression:</span><span class="s2">\n          </span><span class="s1">| N.ArrowFunctionExpression</span><span class="s2">\n          </span><span class="s1">| N.TypeCastExpression</span><span class="s2">\n          </span><span class="s1">| undefined</span><span class="s2">\n          </span><span class="s1">| null = null;</span><span class="s2">\n\n        </span><span class="s1">if (</span><span class="s2">\n          </span><span class="s1">arrow.node &amp;&amp;</span><span class="s2">\n          </span><span class="s1">// @ts-expect-error: refine tryParse typings</span><span class="s2">\n          </span><span class="s1">this.maybeUnwrapTypeCastExpression(arrow.node).type ===</span><span class="s2">\n            \&quot;</span><span class="s1">ArrowFunctionExpression</span><span class="s2">\&quot;\n        </span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">if (!arrow.error &amp;&amp; !arrow.aborted) {</span><span class="s2">\n            </span><span class="s1">// &lt;T&gt; async () =&gt; {}</span><span class="s2">\n            </span><span class="s1">// @ts-expect-error: refine tryParse typings</span><span class="s2">\n            </span><span class="s1">if (arrow.node.async) {</span><span class="s2">\n              </span><span class="s1">/*:: invariant(typeParameters) */</span><span class="s2">\n              </span><span class="s1">this.raise(</span><span class="s2">\n                </span><span class="s1">FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction,</span><span class="s2">\n                </span><span class="s1">{ at: typeParameters },</span><span class="s2">\n              </span><span class="s1">);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">// @ts-expect-error: refine tryParse typings</span><span class="s2">\n            </span><span class="s1">return arrow.node;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n\n          </span><span class="s1">// @ts-expect-error: refine typings</span><span class="s2">\n          </span><span class="s1">arrowExpression = arrow.node;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">// If we are here, both JSX and Flow parsing attempts failed.</span><span class="s2">\n        </span><span class="s1">// Give the precedence to the JSX error, except if JSX had an</span><span class="s2">\n        </span><span class="s1">// unrecoverable error while Flow didn't.</span><span class="s2">\n        </span><span class="s1">// If the error is recoverable, we can only re-report it if there is</span><span class="s2">\n        </span><span class="s1">// a node we can return.</span><span class="s2">\n\n        </span><span class="s1">if (jsx?.node) {</span><span class="s2">\n          </span><span class="s1">/*:: invariant(jsx.failState) */</span><span class="s2">\n          </span><span class="s1">this.state = jsx.failState;</span><span class="s2">\n          </span><span class="s1">return jsx.node;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">if (arrowExpression) {</span><span class="s2">\n          </span><span class="s1">/*:: invariant(arrow.failState) */</span><span class="s2">\n          </span><span class="s1">this.state = arrow.failState;</span><span class="s2">\n          </span><span class="s1">return arrowExpression;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">if (jsx?.thrown) throw jsx.error;</span><span class="s2">\n        </span><span class="s1">if (arrow.thrown) throw arrow.error;</span><span class="s2">\n\n        </span><span class="s1">/*:: invariant(typeParameters) */</span><span class="s2">\n        </span><span class="s1">throw this.raise(FlowErrors.UnexpectedTokenAfterTypeParameter, {</span><span class="s2">\n          </span><span class="s1">at: typeParameters,</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// handle return types for arrow functions</span><span class="s2">\n    </span><span class="s1">parseArrow(</span><span class="s2">\n      </span><span class="s1">node: Undone&lt;N.ArrowFunctionExpression&gt;,</span><span class="s2">\n    </span><span class="s1">): Undone&lt;N.ArrowFunctionExpression&gt; | undefined | null {</span><span class="s2">\n      </span><span class="s1">if (this.match(tt.colon)) {</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts)</span><span class="s2">\n        </span><span class="s1">const result = this.tryParse(() =&gt; {</span><span class="s2">\n          </span><span class="s1">const oldNoAnonFunctionType = this.state.noAnonFunctionType;</span><span class="s2">\n          </span><span class="s1">this.state.noAnonFunctionType = true;</span><span class="s2">\n\n          </span><span class="s1">const typeNode = this.startNode&lt;N.TypeAnnotation&gt;();</span><span class="s2">\n\n          </span><span class="s1">[</span><span class="s2">\n            </span><span class="s1">typeNode.typeAnnotation,</span><span class="s2">\n            </span><span class="s1">// @ts-expect-error (destructuring not supported yet)</span><span class="s2">\n            </span><span class="s1">node.predicate,</span><span class="s2">\n          </span><span class="s1">] = this.flowParseTypeAndPredicateInitialiser();</span><span class="s2">\n\n          </span><span class="s1">this.state.noAnonFunctionType = oldNoAnonFunctionType;</span><span class="s2">\n\n          </span><span class="s1">if (this.canInsertSemicolon()) this.unexpected();</span><span class="s2">\n          </span><span class="s1">if (!this.match(tt.arrow)) this.unexpected();</span><span class="s2">\n\n          </span><span class="s1">return typeNode;</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n\n        </span><span class="s1">if (result.thrown) return null;</span><span class="s2">\n        </span><span class="s1">/*:: invariant(result.node) */</span><span class="s2">\n\n        </span><span class="s1">if (result.error) this.state = result.failState;</span><span class="s2">\n\n        </span><span class="s1">// assign after it is clear it is an arrow</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts)</span><span class="s2">\n        </span><span class="s1">node.returnType = result.node.typeAnnotation</span><span class="s2">\n          </span><span class="s1">? this.finishNode(result.node, </span><span class="s2">\&quot;</span><span class="s1">TypeAnnotation</span><span class="s2">\&quot;</span><span class="s1">)</span><span class="s2">\n          </span><span class="s1">: null;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return super.parseArrow(node);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">shouldParseArrow(params: Array&lt;N.Node&gt;): boolean {</span><span class="s2">\n      </span><span class="s1">return this.match(tt.colon) || super.shouldParseArrow(params);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">setArrowFunctionParameters(</span><span class="s2">\n      </span><span class="s1">node: N.ArrowFunctionExpression,</span><span class="s2">\n      </span><span class="s1">params: N.Pattern[],</span><span class="s2">\n    </span><span class="s1">): void {</span><span class="s2">\n      </span><span class="s1">if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {</span><span class="s2">\n        </span><span class="s1">node.params = params;</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">super.setArrowFunctionParameters(node, params);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">checkParams(</span><span class="s2">\n      </span><span class="s1">node: N.Function,</span><span class="s2">\n      </span><span class="s1">allowDuplicates: boolean,</span><span class="s2">\n      </span><span class="s1">isArrowFunction?: boolean | null,</span><span class="s2">\n      </span><span class="s1">strictModeChanged: boolean = true,</span><span class="s2">\n    </span><span class="s1">): void {</span><span class="s2">\n      </span><span class="s1">if (</span><span class="s2">\n        </span><span class="s1">isArrowFunction &amp;&amp;</span><span class="s2">\n        </span><span class="s1">this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1</span><span class="s2">\n      </span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">// ensure the `this` param is first, if it exists</span><span class="s2">\n      </span><span class="s1">for (let i = 0; i &lt; node.params.length; i++) {</span><span class="s2">\n        </span><span class="s1">if (this.isThisParam(node.params[i]) &amp;&amp; i &gt; 0) {</span><span class="s2">\n          </span><span class="s1">this.raise(FlowErrors.ThisParamMustBeFirst, { at: node.params[i] });</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">super.checkParams(</span><span class="s2">\n        </span><span class="s1">node,</span><span class="s2">\n        </span><span class="s1">allowDuplicates,</span><span class="s2">\n        </span><span class="s1">isArrowFunction,</span><span class="s2">\n        </span><span class="s1">strictModeChanged,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseParenAndDistinguishExpression(canBeArrow: boolean): N.Expression {</span><span class="s2">\n      </span><span class="s1">return super.parseParenAndDistinguishExpression(</span><span class="s2">\n        </span><span class="s1">canBeArrow &amp;&amp; this.state.noArrowAt.indexOf(this.state.start) === -1,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseSubscripts(</span><span class="s2">\n      </span><span class="s1">base: N.Expression,</span><span class="s2">\n\n      </span><span class="s1">startLoc: Position,</span><span class="s2">\n      </span><span class="s1">noCalls?: boolean | null,</span><span class="s2">\n    </span><span class="s1">): N.Expression {</span><span class="s2">\n      </span><span class="s1">if (</span><span class="s2">\n        </span><span class="s1">base.type === </span><span class="s2">\&quot;</span><span class="s1">Identifier</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n        </span><span class="s1">base.name === </span><span class="s2">\&quot;</span><span class="s1">async</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n        </span><span class="s1">this.state.noArrowAt.indexOf(startLoc.index) !== -1</span><span class="s2">\n      </span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">this.next();</span><span class="s2">\n\n        </span><span class="s1">const node = this.startNodeAt(startLoc);</span><span class="s2">\n        </span><span class="s1">node.callee = base;</span><span class="s2">\n        </span><span class="s1">node.arguments = super.parseCallExpressionArguments(tt.parenR, false);</span><span class="s2">\n        </span><span class="s1">base = this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">CallExpression</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">} else if (</span><span class="s2">\n        </span><span class="s1">base.type === </span><span class="s2">\&quot;</span><span class="s1">Identifier</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n        </span><span class="s1">base.name === </span><span class="s2">\&quot;</span><span class="s1">async</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n        </span><span class="s1">this.match(tt.lt)</span><span class="s2">\n      </span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">const state = this.state.clone();</span><span class="s2">\n        </span><span class="s1">const arrow = this.tryParse(</span><span class="s2">\n          </span><span class="s1">abort =&gt; this.parseAsyncArrowWithTypeParameters(startLoc) || abort(),</span><span class="s2">\n          </span><span class="s1">state,</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n\n        </span><span class="s1">/*:: invariant(arrow.node != null) */</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error: refine tryParse typings</span><span class="s2">\n        </span><span class="s1">if (!arrow.error &amp;&amp; !arrow.aborted) return arrow.node;</span><span class="s2">\n\n        </span><span class="s1">const result = this.tryParse(</span><span class="s2">\n          </span><span class="s1">() =&gt; super.parseSubscripts(base, startLoc, noCalls),</span><span class="s2">\n          </span><span class="s1">state,</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n\n        </span><span class="s1">if (result.node &amp;&amp; !result.error) return result.node;</span><span class="s2">\n\n        </span><span class="s1">if (arrow.node) {</span><span class="s2">\n          </span><span class="s1">this.state = arrow.failState;</span><span class="s2">\n          </span><span class="s1">// @ts-expect-error: refine tryParse typings</span><span class="s2">\n          </span><span class="s1">return arrow.node;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">if (result.node) {</span><span class="s2">\n          </span><span class="s1">this.state = result.failState;</span><span class="s2">\n          </span><span class="s1">return result.node;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">throw arrow.error || result.error;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return super.parseSubscripts(base, startLoc, noCalls);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseSubscript(</span><span class="s2">\n      </span><span class="s1">base: N.Expression,</span><span class="s2">\n\n      </span><span class="s1">startLoc: Position,</span><span class="s2">\n      </span><span class="s1">noCalls: boolean | undefined | null,</span><span class="s2">\n      </span><span class="s1">subscriptState: N.ParseSubscriptState,</span><span class="s2">\n    </span><span class="s1">): N.Expression {</span><span class="s2">\n      </span><span class="s1">if (this.match(tt.questionDot) &amp;&amp; this.isLookaheadToken_lt()) {</span><span class="s2">\n        </span><span class="s1">subscriptState.optionalChainMember = true;</span><span class="s2">\n        </span><span class="s1">if (noCalls) {</span><span class="s2">\n          </span><span class="s1">subscriptState.stop = true;</span><span class="s2">\n          </span><span class="s1">return base;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">this.next();</span><span class="s2">\n        </span><span class="s1">const node = this.startNodeAt&lt;N.OptionalCallExpression&gt;(startLoc);</span><span class="s2">\n        </span><span class="s1">node.callee = base;</span><span class="s2">\n        </span><span class="s1">node.typeArguments = this.flowParseTypeParameterInstantiation();</span><span class="s2">\n        </span><span class="s1">this.expect(tt.parenL);</span><span class="s2">\n        </span><span class="s1">node.arguments = this.parseCallExpressionArguments(tt.parenR, false);</span><span class="s2">\n        </span><span class="s1">node.optional = true;</span><span class="s2">\n        </span><span class="s1">return this.finishCallExpression(node, /* optional */ true);</span><span class="s2">\n      </span><span class="s1">} else if (!noCalls &amp;&amp; this.shouldParseTypes() &amp;&amp; this.match(tt.lt)) {</span><span class="s2">\n        </span><span class="s1">const node = this.startNodeAt&lt;</span><span class="s2">\n          </span><span class="s1">N.OptionalCallExpression | N.CallExpression</span><span class="s2">\n        </span><span class="s1">&gt;(startLoc);</span><span class="s2">\n        </span><span class="s1">node.callee = base;</span><span class="s2">\n\n        </span><span class="s1">const result = this.tryParse(() =&gt; {</span><span class="s2">\n          </span><span class="s1">node.typeArguments =</span><span class="s2">\n            </span><span class="s1">this.flowParseTypeParameterInstantiationCallOrNew();</span><span class="s2">\n          </span><span class="s1">this.expect(tt.parenL);</span><span class="s2">\n          </span><span class="s1">node.arguments = super.parseCallExpressionArguments(tt.parenR, false);</span><span class="s2">\n          </span><span class="s1">if (subscriptState.optionalChainMember) {</span><span class="s2">\n            </span><span class="s1">(node as Undone&lt;N.OptionalCallExpression&gt;).optional = false;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">return this.finishCallExpression(</span><span class="s2">\n            </span><span class="s1">node,</span><span class="s2">\n            </span><span class="s1">subscriptState.optionalChainMember,</span><span class="s2">\n          </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n\n        </span><span class="s1">if (result.node) {</span><span class="s2">\n          </span><span class="s1">if (result.error) this.state = result.failState;</span><span class="s2">\n          </span><span class="s1">return result.node;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return super.parseSubscript(</span><span class="s2">\n        </span><span class="s1">base,</span><span class="s2">\n\n        </span><span class="s1">startLoc,</span><span class="s2">\n        </span><span class="s1">noCalls,</span><span class="s2">\n        </span><span class="s1">subscriptState,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseNewCallee(node: N.NewExpression): void {</span><span class="s2">\n      </span><span class="s1">super.parseNewCallee(node);</span><span class="s2">\n\n      </span><span class="s1">let targs = null;</span><span class="s2">\n      </span><span class="s1">if (this.shouldParseTypes() &amp;&amp; this.match(tt.lt)) {</span><span class="s2">\n        </span><span class="s1">targs = this.tryParse(() =&gt;</span><span class="s2">\n          </span><span class="s1">this.flowParseTypeParameterInstantiationCallOrNew(),</span><span class="s2">\n        </span><span class="s1">).node;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">node.typeArguments = targs;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseAsyncArrowWithTypeParameters(</span><span class="s2">\n      </span><span class="s1">startLoc: Position,</span><span class="s2">\n    </span><span class="s1">): N.ArrowFunctionExpression | undefined | null {</span><span class="s2">\n      </span><span class="s1">const node = this.startNodeAt&lt;N.ArrowFunctionExpression&gt;(startLoc);</span><span class="s2">\n      </span><span class="s1">this.parseFunctionParams(node, false);</span><span class="s2">\n      </span><span class="s1">if (!this.parseArrow(node)) return;</span><span class="s2">\n      </span><span class="s1">return super.parseArrowExpression(</span><span class="s2">\n        </span><span class="s1">node,</span><span class="s2">\n        </span><span class="s1">/* params */ undefined,</span><span class="s2">\n        </span><span class="s1">/* isAsync */ true,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">readToken_mult_modulo(code: number): void {</span><span class="s2">\n      </span><span class="s1">const next = this.input.charCodeAt(this.state.pos + 1);</span><span class="s2">\n      </span><span class="s1">if (</span><span class="s2">\n        </span><span class="s1">code === charCodes.asterisk &amp;&amp;</span><span class="s2">\n        </span><span class="s1">next === charCodes.slash &amp;&amp;</span><span class="s2">\n        </span><span class="s1">this.state.hasFlowComment</span><span class="s2">\n      </span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">this.state.hasFlowComment = false;</span><span class="s2">\n        </span><span class="s1">this.state.pos += 2;</span><span class="s2">\n        </span><span class="s1">this.nextToken();</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">super.readToken_mult_modulo(code);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">readToken_pipe_amp(code: number): void {</span><span class="s2">\n      </span><span class="s1">const next = this.input.charCodeAt(this.state.pos + 1);</span><span class="s2">\n      </span><span class="s1">if (</span><span class="s2">\n        </span><span class="s1">code === charCodes.verticalBar &amp;&amp;</span><span class="s2">\n        </span><span class="s1">next === charCodes.rightCurlyBrace</span><span class="s2">\n      </span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">// '|}'</span><span class="s2">\n        </span><span class="s1">this.finishOp(tt.braceBarR, 2);</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">super.readToken_pipe_amp(code);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseTopLevel(file: N.File, program: N.Program): N.File {</span><span class="s2">\n      </span><span class="s1">const fileNode = super.parseTopLevel(file, program);</span><span class="s2">\n      </span><span class="s1">if (this.state.hasFlowComment) {</span><span class="s2">\n        </span><span class="s1">this.raise(FlowErrors.UnterminatedFlowComment, {</span><span class="s2">\n          </span><span class="s1">at: this.state.curPosition(),</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return fileNode;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">skipBlockComment(): N.CommentBlock | undefined {</span><span class="s2">\n      </span><span class="s1">if (this.hasPlugin(</span><span class="s2">\&quot;</span><span class="s1">flowComments</span><span class="s2">\&quot;</span><span class="s1">) &amp;&amp; this.skipFlowComment()) {</span><span class="s2">\n        </span><span class="s1">if (this.state.hasFlowComment) {</span><span class="s2">\n          </span><span class="s1">throw this.raise(FlowErrors.NestedFlowComment, {</span><span class="s2">\n            </span><span class="s1">at: this.state.startLoc,</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">this.hasFlowCommentCompletion();</span><span class="s2">\n        </span><span class="s1">const commentSkip = this.skipFlowComment();</span><span class="s2">\n        </span><span class="s1">if (commentSkip) {</span><span class="s2">\n          </span><span class="s1">this.state.pos += commentSkip;</span><span class="s2">\n          </span><span class="s1">this.state.hasFlowComment = true;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return super.skipBlockComment(this.state.hasFlowComment ? </span><span class="s2">\&quot;</span><span class="s1">*-/</span><span class="s2">\&quot; </span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">*/</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">skipFlowComment(): number | false {</span><span class="s2">\n      </span><span class="s1">const { pos } = this.state;</span><span class="s2">\n      </span><span class="s1">let shiftToFirstNonWhiteSpace = 2;</span><span class="s2">\n      </span><span class="s1">while (</span><span class="s2">\n        </span><span class="s1">[charCodes.space, charCodes.tab].includes(</span><span class="s2">\n          </span><span class="s1">// @ts-expect-error testing whether a number is included</span><span class="s2">\n          </span><span class="s1">this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace),</span><span class="s2">\n        </span><span class="s1">)</span><span class="s2">\n      </span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">shiftToFirstNonWhiteSpace++;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);</span><span class="s2">\n      </span><span class="s1">const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);</span><span class="s2">\n\n      </span><span class="s1">if (ch2 === charCodes.colon &amp;&amp; ch3 === charCodes.colon) {</span><span class="s2">\n        </span><span class="s1">return shiftToFirstNonWhiteSpace + 2; // check for /*::</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (</span><span class="s2">\n        </span><span class="s1">this.input.slice(</span><span class="s2">\n          </span><span class="s1">shiftToFirstNonWhiteSpace + pos,</span><span class="s2">\n          </span><span class="s1">shiftToFirstNonWhiteSpace + pos + 12,</span><span class="s2">\n        </span><span class="s1">) === </span><span class="s2">\&quot;</span><span class="s1">flow-include</span><span class="s2">\&quot;\n      </span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">return shiftToFirstNonWhiteSpace + 12; // check for /*flow-include</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (ch2 === charCodes.colon &amp;&amp; ch3 !== charCodes.colon) {</span><span class="s2">\n        </span><span class="s1">return shiftToFirstNonWhiteSpace; // check for /*:, advance up to :</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return false;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">hasFlowCommentCompletion(): void {</span><span class="s2">\n      </span><span class="s1">const end = this.input.indexOf(</span><span class="s2">\&quot;</span><span class="s1">*/</span><span class="s2">\&quot;</span><span class="s1">, this.state.pos);</span><span class="s2">\n      </span><span class="s1">if (end === -1) {</span><span class="s2">\n        </span><span class="s1">throw this.raise(Errors.UnterminatedComment, {</span><span class="s2">\n          </span><span class="s1">at: this.state.curPosition(),</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// Flow enum parsing</span><span class="s2">\n\n    </span><span class="s1">flowEnumErrorBooleanMemberNotInitialized(</span><span class="s2">\n      </span><span class="s1">loc: Position,</span><span class="s2">\n      </span><span class="s1">{</span><span class="s2">\n        </span><span class="s1">enumName,</span><span class="s2">\n        </span><span class="s1">memberName,</span><span class="s2">\n      </span><span class="s1">}: {</span><span class="s2">\n        </span><span class="s1">enumName: string;</span><span class="s2">\n        </span><span class="s1">memberName: string;</span><span class="s2">\n      </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">): void {</span><span class="s2">\n      </span><span class="s1">this.raise(FlowErrors.EnumBooleanMemberNotInitialized, {</span><span class="s2">\n        </span><span class="s1">at: loc,</span><span class="s2">\n        </span><span class="s1">memberName,</span><span class="s2">\n        </span><span class="s1">enumName,</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">flowEnumErrorInvalidMemberInitializer(</span><span class="s2">\n      </span><span class="s1">loc: Position,</span><span class="s2">\n      </span><span class="s1">enumContext: EnumContext,</span><span class="s2">\n    </span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">return this.raise(</span><span class="s2">\n        </span><span class="s1">!enumContext.explicitType</span><span class="s2">\n          </span><span class="s1">? FlowErrors.EnumInvalidMemberInitializerUnknownType</span><span class="s2">\n          </span><span class="s1">: enumContext.explicitType === </span><span class="s2">\&quot;</span><span class="s1">symbol</span><span class="s2">\&quot;\n          </span><span class="s1">? FlowErrors.EnumInvalidMemberInitializerSymbolType</span><span class="s2">\n          </span><span class="s1">: FlowErrors.EnumInvalidMemberInitializerPrimaryType,</span><span class="s2">\n        </span><span class="s1">{</span><span class="s2">\n          </span><span class="s1">at: loc,</span><span class="s2">\n          </span><span class="s1">...enumContext,</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">flowEnumErrorNumberMemberNotInitialized(</span><span class="s2">\n      </span><span class="s1">loc: Position,</span><span class="s2">\n      </span><span class="s1">{</span><span class="s2">\n        </span><span class="s1">enumName,</span><span class="s2">\n        </span><span class="s1">memberName,</span><span class="s2">\n      </span><span class="s1">}: {</span><span class="s2">\n        </span><span class="s1">enumName: string;</span><span class="s2">\n        </span><span class="s1">memberName: string;</span><span class="s2">\n      </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">): void {</span><span class="s2">\n      </span><span class="s1">this.raise(FlowErrors.EnumNumberMemberNotInitialized, {</span><span class="s2">\n        </span><span class="s1">at: loc,</span><span class="s2">\n        </span><span class="s1">enumName,</span><span class="s2">\n        </span><span class="s1">memberName,</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">flowEnumErrorStringMemberInconsistentlyInitailized(</span><span class="s2">\n      </span><span class="s1">node: N.Node,</span><span class="s2">\n      </span><span class="s1">{</span><span class="s2">\n        </span><span class="s1">enumName,</span><span class="s2">\n      </span><span class="s1">}: {</span><span class="s2">\n        </span><span class="s1">enumName: string;</span><span class="s2">\n      </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">): void {</span><span class="s2">\n      </span><span class="s1">this.raise(FlowErrors.EnumStringMemberInconsistentlyInitailized, {</span><span class="s2">\n        </span><span class="s1">at: node,</span><span class="s2">\n        </span><span class="s1">enumName,</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">flowEnumMemberInit(): EnumMemberInit {</span><span class="s2">\n      </span><span class="s1">const startLoc = this.state.startLoc;</span><span class="s2">\n      </span><span class="s1">const endOfInit = () =&gt; this.match(tt.comma) || this.match(tt.braceR);</span><span class="s2">\n      </span><span class="s1">switch (this.state.type) {</span><span class="s2">\n        </span><span class="s1">case tt.num: {</span><span class="s2">\n          </span><span class="s1">const literal = this.parseNumericLiteral(this.state.value);</span><span class="s2">\n          </span><span class="s1">if (endOfInit()) {</span><span class="s2">\n            </span><span class="s1">return { type: </span><span class="s2">\&quot;</span><span class="s1">number</span><span class="s2">\&quot;</span><span class="s1">, loc: literal.loc.start, value: literal };</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">return { type: </span><span class="s2">\&quot;</span><span class="s1">invalid</span><span class="s2">\&quot;</span><span class="s1">, loc: startLoc };</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">case tt.string: {</span><span class="s2">\n          </span><span class="s1">const literal = this.parseStringLiteral(this.state.value);</span><span class="s2">\n          </span><span class="s1">if (endOfInit()) {</span><span class="s2">\n            </span><span class="s1">return { type: </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot;</span><span class="s1">, loc: literal.loc.start, value: literal };</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">return { type: </span><span class="s2">\&quot;</span><span class="s1">invalid</span><span class="s2">\&quot;</span><span class="s1">, loc: startLoc };</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">case tt._true:</span><span class="s2">\n        </span><span class="s1">case tt._false: {</span><span class="s2">\n          </span><span class="s1">const literal = this.parseBooleanLiteral(this.match(tt._true));</span><span class="s2">\n          </span><span class="s1">if (endOfInit()) {</span><span class="s2">\n            </span><span class="s1">return {</span><span class="s2">\n              </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">boolean</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n              </span><span class="s1">loc: literal.loc.start,</span><span class="s2">\n              </span><span class="s1">value: literal,</span><span class="s2">\n            </span><span class="s1">};</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">return { type: </span><span class="s2">\&quot;</span><span class="s1">invalid</span><span class="s2">\&quot;</span><span class="s1">, loc: startLoc };</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">default:</span><span class="s2">\n          </span><span class="s1">return { type: </span><span class="s2">\&quot;</span><span class="s1">invalid</span><span class="s2">\&quot;</span><span class="s1">, loc: startLoc };</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">flowEnumMemberRaw(): {</span><span class="s2">\n      </span><span class="s1">id: N.Node;</span><span class="s2">\n      </span><span class="s1">init: EnumMemberInit;</span><span class="s2">\n    </span><span class="s1">} {</span><span class="s2">\n      </span><span class="s1">const loc = this.state.startLoc;</span><span class="s2">\n      </span><span class="s1">const id = this.parseIdentifier(true);</span><span class="s2">\n      </span><span class="s1">const init = this.eat(tt.eq)</span><span class="s2">\n        </span><span class="s1">? this.flowEnumMemberInit()</span><span class="s2">\n        </span><span class="s1">: { type: </span><span class="s2">\&quot;</span><span class="s1">none</span><span class="s2">\&quot; </span><span class="s1">as const, loc };</span><span class="s2">\n      </span><span class="s1">return { id, init };</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">flowEnumCheckExplicitTypeMismatch(</span><span class="s2">\n      </span><span class="s1">loc: Position,</span><span class="s2">\n      </span><span class="s1">context: EnumContext,</span><span class="s2">\n      </span><span class="s1">expectedType: EnumExplicitType,</span><span class="s2">\n    </span><span class="s1">): void {</span><span class="s2">\n      </span><span class="s1">const { explicitType } = context;</span><span class="s2">\n      </span><span class="s1">if (explicitType === null) {</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (explicitType !== expectedType) {</span><span class="s2">\n        </span><span class="s1">this.flowEnumErrorInvalidMemberInitializer(loc, context);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">flowEnumMembers({</span><span class="s2">\n      </span><span class="s1">enumName,</span><span class="s2">\n      </span><span class="s1">explicitType,</span><span class="s2">\n    </span><span class="s1">}: {</span><span class="s2">\n      </span><span class="s1">enumName: string;</span><span class="s2">\n      </span><span class="s1">explicitType: EnumExplicitType;</span><span class="s2">\n    </span><span class="s1">}): {</span><span class="s2">\n      </span><span class="s1">members: {</span><span class="s2">\n        </span><span class="s1">booleanMembers: Array&lt;N.Node&gt;;</span><span class="s2">\n        </span><span class="s1">numberMembers: Array&lt;N.Node&gt;;</span><span class="s2">\n        </span><span class="s1">stringMembers: Array&lt;N.Node&gt;;</span><span class="s2">\n        </span><span class="s1">defaultedMembers: Array&lt;N.Node&gt;;</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">hasUnknownMembers: boolean;</span><span class="s2">\n    </span><span class="s1">} {</span><span class="s2">\n      </span><span class="s1">const seenNames = new Set();</span><span class="s2">\n      </span><span class="s1">const members = {</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error: migrate to Babel types</span><span class="s2">\n        </span><span class="s1">booleanMembers: [],</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error: migrate to Babel types</span><span class="s2">\n        </span><span class="s1">numberMembers: [],</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error: migrate to Babel types</span><span class="s2">\n        </span><span class="s1">stringMembers: [],</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error: migrate to Babel types</span><span class="s2">\n        </span><span class="s1">defaultedMembers: [],</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">let hasUnknownMembers = false;</span><span class="s2">\n      </span><span class="s1">while (!this.match(tt.braceR)) {</span><span class="s2">\n        </span><span class="s1">if (this.eat(tt.ellipsis)) {</span><span class="s2">\n          </span><span class="s1">hasUnknownMembers = true;</span><span class="s2">\n          </span><span class="s1">break;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">const memberNode = this.startNode();</span><span class="s2">\n        </span><span class="s1">const { id, init } = this.flowEnumMemberRaw();</span><span class="s2">\n        </span><span class="s1">const memberName = id.name;</span><span class="s2">\n        </span><span class="s1">if (memberName === </span><span class="s2">\&quot;\&quot;</span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">continue;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (/^[a-z]/.test(memberName)) {</span><span class="s2">\n          </span><span class="s1">this.raise(FlowErrors.EnumInvalidMemberName, {</span><span class="s2">\n            </span><span class="s1">at: id,</span><span class="s2">\n            </span><span class="s1">memberName,</span><span class="s2">\n            </span><span class="s1">suggestion: memberName[0].toUpperCase() + memberName.slice(1),</span><span class="s2">\n            </span><span class="s1">enumName,</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (seenNames.has(memberName)) {</span><span class="s2">\n          </span><span class="s1">this.raise(FlowErrors.EnumDuplicateMemberName, {</span><span class="s2">\n            </span><span class="s1">at: id,</span><span class="s2">\n            </span><span class="s1">memberName,</span><span class="s2">\n            </span><span class="s1">enumName,</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">seenNames.add(memberName);</span><span class="s2">\n        </span><span class="s1">const context = { enumName, explicitType, memberName };</span><span class="s2">\n        </span><span class="s1">memberNode.id = id;</span><span class="s2">\n        </span><span class="s1">switch (init.type) {</span><span class="s2">\n          </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">boolean</span><span class="s2">\&quot;</span><span class="s1">: {</span><span class="s2">\n            </span><span class="s1">this.flowEnumCheckExplicitTypeMismatch(</span><span class="s2">\n              </span><span class="s1">init.loc,</span><span class="s2">\n              </span><span class="s1">context,</span><span class="s2">\n              \&quot;</span><span class="s1">boolean</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n            </span><span class="s1">);</span><span class="s2">\n            </span><span class="s1">memberNode.init = init.value;</span><span class="s2">\n            </span><span class="s1">members.booleanMembers.push(</span><span class="s2">\n              </span><span class="s1">this.finishNode(memberNode, </span><span class="s2">\&quot;</span><span class="s1">EnumBooleanMember</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n            </span><span class="s1">);</span><span class="s2">\n            </span><span class="s1">break;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">number</span><span class="s2">\&quot;</span><span class="s1">: {</span><span class="s2">\n            </span><span class="s1">this.flowEnumCheckExplicitTypeMismatch(init.loc, context, </span><span class="s2">\&quot;</span><span class="s1">number</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n            </span><span class="s1">memberNode.init = init.value;</span><span class="s2">\n            </span><span class="s1">members.numberMembers.push(</span><span class="s2">\n              </span><span class="s1">this.finishNode(memberNode, </span><span class="s2">\&quot;</span><span class="s1">EnumNumberMember</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n            </span><span class="s1">);</span><span class="s2">\n            </span><span class="s1">break;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot;</span><span class="s1">: {</span><span class="s2">\n            </span><span class="s1">this.flowEnumCheckExplicitTypeMismatch(init.loc, context, </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n            </span><span class="s1">memberNode.init = init.value;</span><span class="s2">\n            </span><span class="s1">members.stringMembers.push(</span><span class="s2">\n              </span><span class="s1">this.finishNode(memberNode, </span><span class="s2">\&quot;</span><span class="s1">EnumStringMember</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n            </span><span class="s1">);</span><span class="s2">\n            </span><span class="s1">break;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">invalid</span><span class="s2">\&quot;</span><span class="s1">: {</span><span class="s2">\n            </span><span class="s1">throw this.flowEnumErrorInvalidMemberInitializer(init.loc, context);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">none</span><span class="s2">\&quot;</span><span class="s1">: {</span><span class="s2">\n            </span><span class="s1">switch (explicitType) {</span><span class="s2">\n              </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">boolean</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n                </span><span class="s1">this.flowEnumErrorBooleanMemberNotInitialized(</span><span class="s2">\n                  </span><span class="s1">init.loc,</span><span class="s2">\n                  </span><span class="s1">context,</span><span class="s2">\n                </span><span class="s1">);</span><span class="s2">\n                </span><span class="s1">break;</span><span class="s2">\n              </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">number</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n                </span><span class="s1">this.flowEnumErrorNumberMemberNotInitialized(init.loc, context);</span><span class="s2">\n                </span><span class="s1">break;</span><span class="s2">\n              </span><span class="s1">default:</span><span class="s2">\n                </span><span class="s1">members.defaultedMembers.push(</span><span class="s2">\n                  </span><span class="s1">this.finishNode(memberNode, </span><span class="s2">\&quot;</span><span class="s1">EnumDefaultedMember</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n                </span><span class="s1">);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">if (!this.match(tt.braceR)) {</span><span class="s2">\n          </span><span class="s1">this.expect(tt.comma);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return { members, hasUnknownMembers };</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">flowEnumStringMembers(</span><span class="s2">\n      </span><span class="s1">initializedMembers: Array&lt;N.Node&gt;,</span><span class="s2">\n      </span><span class="s1">defaultedMembers: Array&lt;N.Node&gt;,</span><span class="s2">\n      </span><span class="s1">{</span><span class="s2">\n        </span><span class="s1">enumName,</span><span class="s2">\n      </span><span class="s1">}: {</span><span class="s2">\n        </span><span class="s1">enumName: string;</span><span class="s2">\n      </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">): Array&lt;N.Node&gt; {</span><span class="s2">\n      </span><span class="s1">if (initializedMembers.length === 0) {</span><span class="s2">\n        </span><span class="s1">return defaultedMembers;</span><span class="s2">\n      </span><span class="s1">} else if (defaultedMembers.length === 0) {</span><span class="s2">\n        </span><span class="s1">return initializedMembers;</span><span class="s2">\n      </span><span class="s1">} else if (defaultedMembers.length &gt; initializedMembers.length) {</span><span class="s2">\n        </span><span class="s1">for (const member of initializedMembers) {</span><span class="s2">\n          </span><span class="s1">this.flowEnumErrorStringMemberInconsistentlyInitailized(member, {</span><span class="s2">\n            </span><span class="s1">enumName,</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return defaultedMembers;</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">for (const member of defaultedMembers) {</span><span class="s2">\n          </span><span class="s1">this.flowEnumErrorStringMemberInconsistentlyInitailized(member, {</span><span class="s2">\n            </span><span class="s1">enumName,</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return initializedMembers;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">flowEnumParseExplicitType({</span><span class="s2">\n      </span><span class="s1">enumName,</span><span class="s2">\n    </span><span class="s1">}: {</span><span class="s2">\n      </span><span class="s1">enumName: string;</span><span class="s2">\n    </span><span class="s1">}): EnumExplicitType {</span><span class="s2">\n      </span><span class="s1">if (!this.eatContextual(tt._of)) return null;</span><span class="s2">\n\n      </span><span class="s1">if (!tokenIsIdentifier(this.state.type)) {</span><span class="s2">\n        </span><span class="s1">throw this.raise(FlowErrors.EnumInvalidExplicitTypeUnknownSupplied, {</span><span class="s2">\n          </span><span class="s1">at: this.state.startLoc,</span><span class="s2">\n          </span><span class="s1">enumName,</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">const { value } = this.state;</span><span class="s2">\n      </span><span class="s1">this.next();</span><span class="s2">\n\n      </span><span class="s1">if (</span><span class="s2">\n        </span><span class="s1">value !== </span><span class="s2">\&quot;</span><span class="s1">boolean</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n        </span><span class="s1">value !== </span><span class="s2">\&quot;</span><span class="s1">number</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n        </span><span class="s1">value !== </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n        </span><span class="s1">value !== </span><span class="s2">\&quot;</span><span class="s1">symbol</span><span class="s2">\&quot;\n      </span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">this.raise(FlowErrors.EnumInvalidExplicitType, {</span><span class="s2">\n          </span><span class="s1">at: this.state.startLoc,</span><span class="s2">\n          </span><span class="s1">enumName,</span><span class="s2">\n          </span><span class="s1">invalidEnumType: value,</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return value;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">flowEnumBody(node: Undone&lt;N.Node&gt;, id: N.Node): N.Node {</span><span class="s2">\n      </span><span class="s1">const enumName = id.name;</span><span class="s2">\n      </span><span class="s1">const nameLoc = id.loc.start;</span><span class="s2">\n      </span><span class="s1">const explicitType = this.flowEnumParseExplicitType({ enumName });</span><span class="s2">\n      </span><span class="s1">this.expect(tt.braceL);</span><span class="s2">\n      </span><span class="s1">const { members, hasUnknownMembers } = this.flowEnumMembers({</span><span class="s2">\n        </span><span class="s1">enumName,</span><span class="s2">\n        </span><span class="s1">explicitType,</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">node.hasUnknownMembers = hasUnknownMembers;</span><span class="s2">\n\n      </span><span class="s1">switch (explicitType) {</span><span class="s2">\n        </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">boolean</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n          </span><span class="s1">node.explicitType = true;</span><span class="s2">\n          </span><span class="s1">node.members = members.booleanMembers;</span><span class="s2">\n          </span><span class="s1">this.expect(tt.braceR);</span><span class="s2">\n          </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">EnumBooleanBody</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">number</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n          </span><span class="s1">node.explicitType = true;</span><span class="s2">\n          </span><span class="s1">node.members = members.numberMembers;</span><span class="s2">\n          </span><span class="s1">this.expect(tt.braceR);</span><span class="s2">\n          </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">EnumNumberBody</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n          </span><span class="s1">node.explicitType = true;</span><span class="s2">\n          </span><span class="s1">node.members = this.flowEnumStringMembers(</span><span class="s2">\n            </span><span class="s1">members.stringMembers,</span><span class="s2">\n            </span><span class="s1">members.defaultedMembers,</span><span class="s2">\n            </span><span class="s1">{ enumName },</span><span class="s2">\n          </span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">this.expect(tt.braceR);</span><span class="s2">\n          </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">EnumStringBody</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">symbol</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n          </span><span class="s1">node.members = members.defaultedMembers;</span><span class="s2">\n          </span><span class="s1">this.expect(tt.braceR);</span><span class="s2">\n          </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">EnumSymbolBody</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">default: {</span><span class="s2">\n          </span><span class="s1">// `explicitType` is `null`</span><span class="s2">\n          </span><span class="s1">const empty = () =&gt; {</span><span class="s2">\n            </span><span class="s1">node.members = [];</span><span class="s2">\n            </span><span class="s1">this.expect(tt.braceR);</span><span class="s2">\n            </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">EnumStringBody</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">};</span><span class="s2">\n          </span><span class="s1">node.explicitType = false;</span><span class="s2">\n\n          </span><span class="s1">const boolsLen = members.booleanMembers.length;</span><span class="s2">\n          </span><span class="s1">const numsLen = members.numberMembers.length;</span><span class="s2">\n          </span><span class="s1">const strsLen = members.stringMembers.length;</span><span class="s2">\n          </span><span class="s1">const defaultedLen = members.defaultedMembers.length;</span><span class="s2">\n\n          </span><span class="s1">if (!boolsLen &amp;&amp; !numsLen &amp;&amp; !strsLen &amp;&amp; !defaultedLen) {</span><span class="s2">\n            </span><span class="s1">return empty();</span><span class="s2">\n          </span><span class="s1">} else if (!boolsLen &amp;&amp; !numsLen) {</span><span class="s2">\n            </span><span class="s1">node.members = this.flowEnumStringMembers(</span><span class="s2">\n              </span><span class="s1">members.stringMembers,</span><span class="s2">\n              </span><span class="s1">members.defaultedMembers,</span><span class="s2">\n              </span><span class="s1">{ enumName },</span><span class="s2">\n            </span><span class="s1">);</span><span class="s2">\n            </span><span class="s1">this.expect(tt.braceR);</span><span class="s2">\n            </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">EnumStringBody</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">} else if (!numsLen &amp;&amp; !strsLen &amp;&amp; boolsLen &gt;= defaultedLen) {</span><span class="s2">\n            </span><span class="s1">for (const member of members.defaultedMembers) {</span><span class="s2">\n              </span><span class="s1">this.flowEnumErrorBooleanMemberNotInitialized(member.loc.start, {</span><span class="s2">\n                </span><span class="s1">enumName,</span><span class="s2">\n                </span><span class="s1">memberName: member.id.name,</span><span class="s2">\n              </span><span class="s1">});</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">node.members = members.booleanMembers;</span><span class="s2">\n            </span><span class="s1">this.expect(tt.braceR);</span><span class="s2">\n            </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">EnumBooleanBody</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">} else if (!boolsLen &amp;&amp; !strsLen &amp;&amp; numsLen &gt;= defaultedLen) {</span><span class="s2">\n            </span><span class="s1">for (const member of members.defaultedMembers) {</span><span class="s2">\n              </span><span class="s1">this.flowEnumErrorNumberMemberNotInitialized(member.loc.start, {</span><span class="s2">\n                </span><span class="s1">enumName,</span><span class="s2">\n                </span><span class="s1">memberName: member.id.name,</span><span class="s2">\n              </span><span class="s1">});</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">node.members = members.numberMembers;</span><span class="s2">\n            </span><span class="s1">this.expect(tt.braceR);</span><span class="s2">\n            </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">EnumNumberBody</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">} else {</span><span class="s2">\n            </span><span class="s1">this.raise(FlowErrors.EnumInconsistentMemberValues, {</span><span class="s2">\n              </span><span class="s1">at: nameLoc,</span><span class="s2">\n              </span><span class="s1">enumName,</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n            </span><span class="s1">return empty();</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">flowParseEnumDeclaration(node: Undone&lt;N.Node&gt;): N.Node {</span><span class="s2">\n      </span><span class="s1">const id = this.parseIdentifier();</span><span class="s2">\n      </span><span class="s1">node.id = id;</span><span class="s2">\n      </span><span class="s1">node.body = this.flowEnumBody(this.startNode(), id);</span><span class="s2">\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">EnumDeclaration</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// check if the next token is a tt.lt</span><span class="s2">\n    </span><span class="s1">isLookaheadToken_lt(): boolean {</span><span class="s2">\n      </span><span class="s1">const next = this.nextTokenStart();</span><span class="s2">\n      </span><span class="s1">if (this.input.charCodeAt(next) === charCodes.lessThan) {</span><span class="s2">\n        </span><span class="s1">const afterNext = this.input.charCodeAt(next + 1);</span><span class="s2">\n        </span><span class="s1">return (</span><span class="s2">\n          </span><span class="s1">afterNext !== charCodes.lessThan &amp;&amp; afterNext !== charCodes.equalsTo</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return false;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">maybeUnwrapTypeCastExpression(node: N.Node) {</span><span class="s2">\n      </span><span class="s1">return node.type === </span><span class="s2">\&quot;</span><span class="s1">TypeCastExpression</span><span class="s2">\&quot; </span><span class="s1">? node.expression : node;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">&quot;</span><span class="s2">,</span><span class="s1">&quot;const entities: {</span><span class="s2">\n  </span><span class="s1">__proto__: null;</span><span class="s2">\n  </span><span class="s1">[name: string]: string;</span><span class="s2">\n</span><span class="s1">} = {</span><span class="s2">\n  </span><span class="s1">__proto__: null,</span><span class="s2">\n  </span><span class="s1">quot: </span><span class="s2">\&quot;\\</span><span class="s1">u0022</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">amp: </span><span class="s2">\&quot;</span><span class="s1">&amp;</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">apos: </span><span class="s2">\&quot;\\</span><span class="s1">u0027</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">lt: </span><span class="s2">\&quot;</span><span class="s1">&lt;</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">gt: </span><span class="s2">\&quot;</span><span class="s1">&gt;</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">nbsp: </span><span class="s2">\&quot;\\</span><span class="s1">u00A0</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">iexcl: </span><span class="s2">\&quot;\\</span><span class="s1">u00A1</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">cent: </span><span class="s2">\&quot;\\</span><span class="s1">u00A2</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">pound: </span><span class="s2">\&quot;\\</span><span class="s1">u00A3</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">curren: </span><span class="s2">\&quot;\\</span><span class="s1">u00A4</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">yen: </span><span class="s2">\&quot;\\</span><span class="s1">u00A5</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">brvbar: </span><span class="s2">\&quot;\\</span><span class="s1">u00A6</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">sect: </span><span class="s2">\&quot;\\</span><span class="s1">u00A7</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">uml: </span><span class="s2">\&quot;\\</span><span class="s1">u00A8</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">copy: </span><span class="s2">\&quot;\\</span><span class="s1">u00A9</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ordf: </span><span class="s2">\&quot;\\</span><span class="s1">u00AA</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">laquo: </span><span class="s2">\&quot;\\</span><span class="s1">u00AB</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">not: </span><span class="s2">\&quot;\\</span><span class="s1">u00AC</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">shy: </span><span class="s2">\&quot;\\</span><span class="s1">u00AD</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">reg: </span><span class="s2">\&quot;\\</span><span class="s1">u00AE</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">macr: </span><span class="s2">\&quot;\\</span><span class="s1">u00AF</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">deg: </span><span class="s2">\&quot;\\</span><span class="s1">u00B0</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">plusmn: </span><span class="s2">\&quot;\\</span><span class="s1">u00B1</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">sup2: </span><span class="s2">\&quot;\\</span><span class="s1">u00B2</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">sup3: </span><span class="s2">\&quot;\\</span><span class="s1">u00B3</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">acute: </span><span class="s2">\&quot;\\</span><span class="s1">u00B4</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">micro: </span><span class="s2">\&quot;\\</span><span class="s1">u00B5</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">para: </span><span class="s2">\&quot;\\</span><span class="s1">u00B6</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">middot: </span><span class="s2">\&quot;\\</span><span class="s1">u00B7</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">cedil: </span><span class="s2">\&quot;\\</span><span class="s1">u00B8</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">sup1: </span><span class="s2">\&quot;\\</span><span class="s1">u00B9</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ordm: </span><span class="s2">\&quot;\\</span><span class="s1">u00BA</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">raquo: </span><span class="s2">\&quot;\\</span><span class="s1">u00BB</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">frac14: </span><span class="s2">\&quot;\\</span><span class="s1">u00BC</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">frac12: </span><span class="s2">\&quot;\\</span><span class="s1">u00BD</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">frac34: </span><span class="s2">\&quot;\\</span><span class="s1">u00BE</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">iquest: </span><span class="s2">\&quot;\\</span><span class="s1">u00BF</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">Agrave: </span><span class="s2">\&quot;\\</span><span class="s1">u00C0</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">Aacute: </span><span class="s2">\&quot;\\</span><span class="s1">u00C1</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">Acirc: </span><span class="s2">\&quot;\\</span><span class="s1">u00C2</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">Atilde: </span><span class="s2">\&quot;\\</span><span class="s1">u00C3</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">Auml: </span><span class="s2">\&quot;\\</span><span class="s1">u00C4</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">Aring: </span><span class="s2">\&quot;\\</span><span class="s1">u00C5</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">AElig: </span><span class="s2">\&quot;\\</span><span class="s1">u00C6</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">Ccedil: </span><span class="s2">\&quot;\\</span><span class="s1">u00C7</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">Egrave: </span><span class="s2">\&quot;\\</span><span class="s1">u00C8</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">Eacute: </span><span class="s2">\&quot;\\</span><span class="s1">u00C9</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">Ecirc: </span><span class="s2">\&quot;\\</span><span class="s1">u00CA</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">Euml: </span><span class="s2">\&quot;\\</span><span class="s1">u00CB</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">Igrave: </span><span class="s2">\&quot;\\</span><span class="s1">u00CC</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">Iacute: </span><span class="s2">\&quot;\\</span><span class="s1">u00CD</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">Icirc: </span><span class="s2">\&quot;\\</span><span class="s1">u00CE</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">Iuml: </span><span class="s2">\&quot;\\</span><span class="s1">u00CF</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ETH: </span><span class="s2">\&quot;\\</span><span class="s1">u00D0</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">Ntilde: </span><span class="s2">\&quot;\\</span><span class="s1">u00D1</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">Ograve: </span><span class="s2">\&quot;\\</span><span class="s1">u00D2</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">Oacute: </span><span class="s2">\&quot;\\</span><span class="s1">u00D3</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">Ocirc: </span><span class="s2">\&quot;\\</span><span class="s1">u00D4</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">Otilde: </span><span class="s2">\&quot;\\</span><span class="s1">u00D5</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">Ouml: </span><span class="s2">\&quot;\\</span><span class="s1">u00D6</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">times: </span><span class="s2">\&quot;\\</span><span class="s1">u00D7</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">Oslash: </span><span class="s2">\&quot;\\</span><span class="s1">u00D8</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">Ugrave: </span><span class="s2">\&quot;\\</span><span class="s1">u00D9</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">Uacute: </span><span class="s2">\&quot;\\</span><span class="s1">u00DA</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">Ucirc: </span><span class="s2">\&quot;\\</span><span class="s1">u00DB</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">Uuml: </span><span class="s2">\&quot;\\</span><span class="s1">u00DC</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">Yacute: </span><span class="s2">\&quot;\\</span><span class="s1">u00DD</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">THORN: </span><span class="s2">\&quot;\\</span><span class="s1">u00DE</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">szlig: </span><span class="s2">\&quot;\\</span><span class="s1">u00DF</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">agrave: </span><span class="s2">\&quot;\\</span><span class="s1">u00E0</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">aacute: </span><span class="s2">\&quot;\\</span><span class="s1">u00E1</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">acirc: </span><span class="s2">\&quot;\\</span><span class="s1">u00E2</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">atilde: </span><span class="s2">\&quot;\\</span><span class="s1">u00E3</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">auml: </span><span class="s2">\&quot;\\</span><span class="s1">u00E4</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">aring: </span><span class="s2">\&quot;\\</span><span class="s1">u00E5</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">aelig: </span><span class="s2">\&quot;\\</span><span class="s1">u00E6</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ccedil: </span><span class="s2">\&quot;\\</span><span class="s1">u00E7</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">egrave: </span><span class="s2">\&quot;\\</span><span class="s1">u00E8</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">eacute: </span><span class="s2">\&quot;\\</span><span class="s1">u00E9</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ecirc: </span><span class="s2">\&quot;\\</span><span class="s1">u00EA</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">euml: </span><span class="s2">\&quot;\\</span><span class="s1">u00EB</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">igrave: </span><span class="s2">\&quot;\\</span><span class="s1">u00EC</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">iacute: </span><span class="s2">\&quot;\\</span><span class="s1">u00ED</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">icirc: </span><span class="s2">\&quot;\\</span><span class="s1">u00EE</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">iuml: </span><span class="s2">\&quot;\\</span><span class="s1">u00EF</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">eth: </span><span class="s2">\&quot;\\</span><span class="s1">u00F0</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ntilde: </span><span class="s2">\&quot;\\</span><span class="s1">u00F1</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ograve: </span><span class="s2">\&quot;\\</span><span class="s1">u00F2</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">oacute: </span><span class="s2">\&quot;\\</span><span class="s1">u00F3</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ocirc: </span><span class="s2">\&quot;\\</span><span class="s1">u00F4</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">otilde: </span><span class="s2">\&quot;\\</span><span class="s1">u00F5</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ouml: </span><span class="s2">\&quot;\\</span><span class="s1">u00F6</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">divide: </span><span class="s2">\&quot;\\</span><span class="s1">u00F7</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">oslash: </span><span class="s2">\&quot;\\</span><span class="s1">u00F8</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ugrave: </span><span class="s2">\&quot;\\</span><span class="s1">u00F9</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">uacute: </span><span class="s2">\&quot;\\</span><span class="s1">u00FA</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ucirc: </span><span class="s2">\&quot;\\</span><span class="s1">u00FB</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">uuml: </span><span class="s2">\&quot;\\</span><span class="s1">u00FC</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">yacute: </span><span class="s2">\&quot;\\</span><span class="s1">u00FD</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">thorn: </span><span class="s2">\&quot;\\</span><span class="s1">u00FE</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">yuml: </span><span class="s2">\&quot;\\</span><span class="s1">u00FF</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">OElig: </span><span class="s2">\&quot;\\</span><span class="s1">u0152</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">oelig: </span><span class="s2">\&quot;\\</span><span class="s1">u0153</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">Scaron: </span><span class="s2">\&quot;\\</span><span class="s1">u0160</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">scaron: </span><span class="s2">\&quot;\\</span><span class="s1">u0161</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">Yuml: </span><span class="s2">\&quot;\\</span><span class="s1">u0178</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">fnof: </span><span class="s2">\&quot;\\</span><span class="s1">u0192</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">circ: </span><span class="s2">\&quot;\\</span><span class="s1">u02C6</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">tilde: </span><span class="s2">\&quot;\\</span><span class="s1">u02DC</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">Alpha: </span><span class="s2">\&quot;\\</span><span class="s1">u0391</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">Beta: </span><span class="s2">\&quot;\\</span><span class="s1">u0392</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">Gamma: </span><span class="s2">\&quot;\\</span><span class="s1">u0393</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">Delta: </span><span class="s2">\&quot;\\</span><span class="s1">u0394</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">Epsilon: </span><span class="s2">\&quot;\\</span><span class="s1">u0395</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">Zeta: </span><span class="s2">\&quot;\\</span><span class="s1">u0396</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">Eta: </span><span class="s2">\&quot;\\</span><span class="s1">u0397</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">Theta: </span><span class="s2">\&quot;\\</span><span class="s1">u0398</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">Iota: </span><span class="s2">\&quot;\\</span><span class="s1">u0399</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">Kappa: </span><span class="s2">\&quot;\\</span><span class="s1">u039A</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">Lambda: </span><span class="s2">\&quot;\\</span><span class="s1">u039B</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">Mu: </span><span class="s2">\&quot;\\</span><span class="s1">u039C</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">Nu: </span><span class="s2">\&quot;\\</span><span class="s1">u039D</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">Xi: </span><span class="s2">\&quot;\\</span><span class="s1">u039E</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">Omicron: </span><span class="s2">\&quot;\\</span><span class="s1">u039F</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">Pi: </span><span class="s2">\&quot;\\</span><span class="s1">u03A0</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">Rho: </span><span class="s2">\&quot;\\</span><span class="s1">u03A1</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">Sigma: </span><span class="s2">\&quot;\\</span><span class="s1">u03A3</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">Tau: </span><span class="s2">\&quot;\\</span><span class="s1">u03A4</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">Upsilon: </span><span class="s2">\&quot;\\</span><span class="s1">u03A5</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">Phi: </span><span class="s2">\&quot;\\</span><span class="s1">u03A6</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">Chi: </span><span class="s2">\&quot;\\</span><span class="s1">u03A7</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">Psi: </span><span class="s2">\&quot;\\</span><span class="s1">u03A8</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">Omega: </span><span class="s2">\&quot;\\</span><span class="s1">u03A9</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">alpha: </span><span class="s2">\&quot;\\</span><span class="s1">u03B1</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">beta: </span><span class="s2">\&quot;\\</span><span class="s1">u03B2</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">gamma: </span><span class="s2">\&quot;\\</span><span class="s1">u03B3</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">delta: </span><span class="s2">\&quot;\\</span><span class="s1">u03B4</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">epsilon: </span><span class="s2">\&quot;\\</span><span class="s1">u03B5</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">zeta: </span><span class="s2">\&quot;\\</span><span class="s1">u03B6</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">eta: </span><span class="s2">\&quot;\\</span><span class="s1">u03B7</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">theta: </span><span class="s2">\&quot;\\</span><span class="s1">u03B8</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">iota: </span><span class="s2">\&quot;\\</span><span class="s1">u03B9</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">kappa: </span><span class="s2">\&quot;\\</span><span class="s1">u03BA</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">lambda: </span><span class="s2">\&quot;\\</span><span class="s1">u03BB</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">mu: </span><span class="s2">\&quot;\\</span><span class="s1">u03BC</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">nu: </span><span class="s2">\&quot;\\</span><span class="s1">u03BD</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">xi: </span><span class="s2">\&quot;\\</span><span class="s1">u03BE</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">omicron: </span><span class="s2">\&quot;\\</span><span class="s1">u03BF</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">pi: </span><span class="s2">\&quot;\\</span><span class="s1">u03C0</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">rho: </span><span class="s2">\&quot;\\</span><span class="s1">u03C1</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">sigmaf: </span><span class="s2">\&quot;\\</span><span class="s1">u03C2</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">sigma: </span><span class="s2">\&quot;\\</span><span class="s1">u03C3</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">tau: </span><span class="s2">\&quot;\\</span><span class="s1">u03C4</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">upsilon: </span><span class="s2">\&quot;\\</span><span class="s1">u03C5</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">phi: </span><span class="s2">\&quot;\\</span><span class="s1">u03C6</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">chi: </span><span class="s2">\&quot;\\</span><span class="s1">u03C7</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">psi: </span><span class="s2">\&quot;\\</span><span class="s1">u03C8</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">omega: </span><span class="s2">\&quot;\\</span><span class="s1">u03C9</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">thetasym: </span><span class="s2">\&quot;\\</span><span class="s1">u03D1</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">upsih: </span><span class="s2">\&quot;\\</span><span class="s1">u03D2</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">piv: </span><span class="s2">\&quot;\\</span><span class="s1">u03D6</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ensp: </span><span class="s2">\&quot;\\</span><span class="s1">u2002</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">emsp: </span><span class="s2">\&quot;\\</span><span class="s1">u2003</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">thinsp: </span><span class="s2">\&quot;\\</span><span class="s1">u2009</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">zwnj: </span><span class="s2">\&quot;\\</span><span class="s1">u200C</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">zwj: </span><span class="s2">\&quot;\\</span><span class="s1">u200D</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">lrm: </span><span class="s2">\&quot;\\</span><span class="s1">u200E</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">rlm: </span><span class="s2">\&quot;\\</span><span class="s1">u200F</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ndash: </span><span class="s2">\&quot;\\</span><span class="s1">u2013</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">mdash: </span><span class="s2">\&quot;\\</span><span class="s1">u2014</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">lsquo: </span><span class="s2">\&quot;\\</span><span class="s1">u2018</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">rsquo: </span><span class="s2">\&quot;\\</span><span class="s1">u2019</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">sbquo: </span><span class="s2">\&quot;\\</span><span class="s1">u201A</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ldquo: </span><span class="s2">\&quot;\\</span><span class="s1">u201C</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">rdquo: </span><span class="s2">\&quot;\\</span><span class="s1">u201D</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">bdquo: </span><span class="s2">\&quot;\\</span><span class="s1">u201E</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">dagger: </span><span class="s2">\&quot;\\</span><span class="s1">u2020</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">Dagger: </span><span class="s2">\&quot;\\</span><span class="s1">u2021</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">bull: </span><span class="s2">\&quot;\\</span><span class="s1">u2022</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">hellip: </span><span class="s2">\&quot;\\</span><span class="s1">u2026</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">permil: </span><span class="s2">\&quot;\\</span><span class="s1">u2030</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">prime: </span><span class="s2">\&quot;\\</span><span class="s1">u2032</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">Prime: </span><span class="s2">\&quot;\\</span><span class="s1">u2033</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">lsaquo: </span><span class="s2">\&quot;\\</span><span class="s1">u2039</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">rsaquo: </span><span class="s2">\&quot;\\</span><span class="s1">u203A</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">oline: </span><span class="s2">\&quot;\\</span><span class="s1">u203E</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">frasl: </span><span class="s2">\&quot;\\</span><span class="s1">u2044</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">euro: </span><span class="s2">\&quot;\\</span><span class="s1">u20AC</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">image: </span><span class="s2">\&quot;\\</span><span class="s1">u2111</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">weierp: </span><span class="s2">\&quot;\\</span><span class="s1">u2118</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">real: </span><span class="s2">\&quot;\\</span><span class="s1">u211C</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">trade: </span><span class="s2">\&quot;\\</span><span class="s1">u2122</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">alefsym: </span><span class="s2">\&quot;\\</span><span class="s1">u2135</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">larr: </span><span class="s2">\&quot;\\</span><span class="s1">u2190</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">uarr: </span><span class="s2">\&quot;\\</span><span class="s1">u2191</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">rarr: </span><span class="s2">\&quot;\\</span><span class="s1">u2192</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">darr: </span><span class="s2">\&quot;\\</span><span class="s1">u2193</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">harr: </span><span class="s2">\&quot;\\</span><span class="s1">u2194</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">crarr: </span><span class="s2">\&quot;\\</span><span class="s1">u21B5</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">lArr: </span><span class="s2">\&quot;\\</span><span class="s1">u21D0</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">uArr: </span><span class="s2">\&quot;\\</span><span class="s1">u21D1</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">rArr: </span><span class="s2">\&quot;\\</span><span class="s1">u21D2</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">dArr: </span><span class="s2">\&quot;\\</span><span class="s1">u21D3</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">hArr: </span><span class="s2">\&quot;\\</span><span class="s1">u21D4</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">forall: </span><span class="s2">\&quot;\\</span><span class="s1">u2200</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">part: </span><span class="s2">\&quot;\\</span><span class="s1">u2202</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">exist: </span><span class="s2">\&quot;\\</span><span class="s1">u2203</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">empty: </span><span class="s2">\&quot;\\</span><span class="s1">u2205</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">nabla: </span><span class="s2">\&quot;\\</span><span class="s1">u2207</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">isin: </span><span class="s2">\&quot;\\</span><span class="s1">u2208</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">notin: </span><span class="s2">\&quot;\\</span><span class="s1">u2209</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ni: </span><span class="s2">\&quot;\\</span><span class="s1">u220B</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">prod: </span><span class="s2">\&quot;\\</span><span class="s1">u220F</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">sum: </span><span class="s2">\&quot;\\</span><span class="s1">u2211</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">minus: </span><span class="s2">\&quot;\\</span><span class="s1">u2212</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">lowast: </span><span class="s2">\&quot;\\</span><span class="s1">u2217</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">radic: </span><span class="s2">\&quot;\\</span><span class="s1">u221A</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">prop: </span><span class="s2">\&quot;\\</span><span class="s1">u221D</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">infin: </span><span class="s2">\&quot;\\</span><span class="s1">u221E</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ang: </span><span class="s2">\&quot;\\</span><span class="s1">u2220</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">and: </span><span class="s2">\&quot;\\</span><span class="s1">u2227</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">or: </span><span class="s2">\&quot;\\</span><span class="s1">u2228</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">cap: </span><span class="s2">\&quot;\\</span><span class="s1">u2229</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">cup: </span><span class="s2">\&quot;\\</span><span class="s1">u222A</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">int: </span><span class="s2">\&quot;\\</span><span class="s1">u222B</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">there4: </span><span class="s2">\&quot;\\</span><span class="s1">u2234</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">sim: </span><span class="s2">\&quot;\\</span><span class="s1">u223C</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">cong: </span><span class="s2">\&quot;\\</span><span class="s1">u2245</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">asymp: </span><span class="s2">\&quot;\\</span><span class="s1">u2248</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ne: </span><span class="s2">\&quot;\\</span><span class="s1">u2260</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">equiv: </span><span class="s2">\&quot;\\</span><span class="s1">u2261</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">le: </span><span class="s2">\&quot;\\</span><span class="s1">u2264</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ge: </span><span class="s2">\&quot;\\</span><span class="s1">u2265</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">sub: </span><span class="s2">\&quot;\\</span><span class="s1">u2282</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">sup: </span><span class="s2">\&quot;\\</span><span class="s1">u2283</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">nsub: </span><span class="s2">\&quot;\\</span><span class="s1">u2284</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">sube: </span><span class="s2">\&quot;\\</span><span class="s1">u2286</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">supe: </span><span class="s2">\&quot;\\</span><span class="s1">u2287</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">oplus: </span><span class="s2">\&quot;\\</span><span class="s1">u2295</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">otimes: </span><span class="s2">\&quot;\\</span><span class="s1">u2297</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">perp: </span><span class="s2">\&quot;\\</span><span class="s1">u22A5</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">sdot: </span><span class="s2">\&quot;\\</span><span class="s1">u22C5</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">lceil: </span><span class="s2">\&quot;\\</span><span class="s1">u2308</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">rceil: </span><span class="s2">\&quot;\\</span><span class="s1">u2309</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">lfloor: </span><span class="s2">\&quot;\\</span><span class="s1">u230A</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">rfloor: </span><span class="s2">\&quot;\\</span><span class="s1">u230B</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">lang: </span><span class="s2">\&quot;\\</span><span class="s1">u2329</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">rang: </span><span class="s2">\&quot;\\</span><span class="s1">u232A</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">loz: </span><span class="s2">\&quot;\\</span><span class="s1">u25CA</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">spades: </span><span class="s2">\&quot;\\</span><span class="s1">u2660</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">clubs: </span><span class="s2">\&quot;\\</span><span class="s1">u2663</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">hearts: </span><span class="s2">\&quot;\\</span><span class="s1">u2665</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">diams: </span><span class="s2">\&quot;\\</span><span class="s1">u2666</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n</span><span class="s1">} as const;</span><span class="s2">\n</span><span class="s1">export default entities;</span><span class="s2">\n</span><span class="s1">&quot;</span><span class="s2">,</span><span class="s1">&quot;import * as charCodes from </span><span class="s2">\&quot;</span><span class="s1">charcodes</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">import XHTMLEntities from </span><span class="s2">\&quot;</span><span class="s1">./xhtml</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type Parser from </span><span class="s2">\&quot;</span><span class="s1">../../parser</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type { ExpressionErrors } from </span><span class="s2">\&quot;</span><span class="s1">../../parser/util</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import {</span><span class="s2">\n  </span><span class="s1">tokenComesBeforeExpression,</span><span class="s2">\n  </span><span class="s1">tokenIsKeyword,</span><span class="s2">\n  </span><span class="s1">tokenLabelName,</span><span class="s2">\n  </span><span class="s1">type TokenType,</span><span class="s2">\n  </span><span class="s1">tt,</span><span class="s2">\n</span><span class="s1">} from </span><span class="s2">\&quot;</span><span class="s1">../../tokenizer/types</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type { TokContext } from </span><span class="s2">\&quot;</span><span class="s1">../../tokenizer/context</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import { types as tc } from </span><span class="s2">\&quot;</span><span class="s1">../../tokenizer/context</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type * as N from </span><span class="s2">\&quot;</span><span class="s1">../../types</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import { isIdentifierChar, isIdentifierStart } from </span><span class="s2">\&quot;</span><span class="s1">../../util/identifier</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type { Position } from </span><span class="s2">\&quot;</span><span class="s1">../../util/location</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import { isNewLine } from </span><span class="s2">\&quot;</span><span class="s1">../../util/whitespace</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import { Errors, ParseErrorEnum } from </span><span class="s2">\&quot;</span><span class="s1">../../parse-error</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import { type Undone } from </span><span class="s2">\&quot;</span><span class="s1">../../parser/node</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">/* eslint sort-keys: </span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot; </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const JsxErrors = ParseErrorEnum`jsx`({</span><span class="s2">\n  </span><span class="s1">AttributeIsEmpty:</span><span class="s2">\n    \&quot;</span><span class="s1">JSX attributes must only be assigned a non-empty expression.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">MissingClosingTagElement: ({ openingTagName }: { openingTagName: string }) =&gt;</span><span class="s2">\n    </span><span class="s1">`Expected corresponding JSX closing tag for &lt;${openingTagName}&gt;.`,</span><span class="s2">\n  </span><span class="s1">MissingClosingTagFragment: </span><span class="s2">\&quot;</span><span class="s1">Expected corresponding JSX closing tag for &lt;&gt;.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">UnexpectedSequenceExpression:</span><span class="s2">\n    \&quot;</span><span class="s1">Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">// FIXME: Unify with Errors.UnexpectedToken</span><span class="s2">\n  </span><span class="s1">UnexpectedToken: ({</span><span class="s2">\n    </span><span class="s1">unexpected,</span><span class="s2">\n    </span><span class="s1">HTMLEntity,</span><span class="s2">\n  </span><span class="s1">}: {</span><span class="s2">\n    </span><span class="s1">unexpected: string;</span><span class="s2">\n    </span><span class="s1">HTMLEntity: string;</span><span class="s2">\n  </span><span class="s1">}) =&gt;</span><span class="s2">\n    </span><span class="s1">`Unexpected token </span><span class="s2">\\</span><span class="s1">`${unexpected}</span><span class="s2">\\</span><span class="s1">`. Did you mean </span><span class="s2">\\</span><span class="s1">`${HTMLEntity}</span><span class="s2">\\</span><span class="s1">` or </span><span class="s2">\\</span><span class="s1">`{'${unexpected}'}</span><span class="s2">\\</span><span class="s1">`?`,</span><span class="s2">\n  </span><span class="s1">UnsupportedJsxValue:</span><span class="s2">\n    \&quot;</span><span class="s1">JSX value should be either an expression or a quoted JSX text.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">UnterminatedJsxContent: </span><span class="s2">\&quot;</span><span class="s1">Unterminated JSX contents.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">UnwrappedAdjacentJSXElements:</span><span class="s2">\n    \&quot;</span><span class="s1">Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment &lt;&gt;...&lt;/&gt;?</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n</span><span class="s1">});</span><span class="s2">\n\n</span><span class="s1">/* eslint-disable sort-keys */</span><span class="s2">\n\n</span><span class="s1">function isFragment(object?: N.JSXElement | null): boolean {</span><span class="s2">\n  </span><span class="s1">return object</span><span class="s2">\n    </span><span class="s1">? object.type === </span><span class="s2">\&quot;</span><span class="s1">JSXOpeningFragment</span><span class="s2">\&quot; </span><span class="s1">||</span><span class="s2">\n        </span><span class="s1">object.type === </span><span class="s2">\&quot;</span><span class="s1">JSXClosingFragment</span><span class="s2">\&quot;\n    </span><span class="s1">: false;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// Transforms JSX element name to string.</span><span class="s2">\n\n</span><span class="s1">function getQualifiedJSXName(</span><span class="s2">\n  </span><span class="s1">object: N.JSXIdentifier | N.JSXNamespacedName | N.JSXMemberExpression,</span><span class="s2">\n</span><span class="s1">): string {</span><span class="s2">\n  </span><span class="s1">if (object.type === </span><span class="s2">\&quot;</span><span class="s1">JSXIdentifier</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">return object.name;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">if (object.type === </span><span class="s2">\&quot;</span><span class="s1">JSXNamespacedName</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">return object.namespace.name + </span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\&quot; </span><span class="s1">+ object.name.name;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">if (object.type === </span><span class="s2">\&quot;</span><span class="s1">JSXMemberExpression</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">return (</span><span class="s2">\n      </span><span class="s1">getQualifiedJSXName(object.object) +</span><span class="s2">\n      \&quot;</span><span class="s1">.</span><span class="s2">\&quot; </span><span class="s1">+</span><span class="s2">\n      </span><span class="s1">getQualifiedJSXName(object.property)</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// istanbul ignore next</span><span class="s2">\n  </span><span class="s1">throw new Error(</span><span class="s2">\&quot;</span><span class="s1">Node had unexpected type: </span><span class="s2">\&quot; </span><span class="s1">+ object.type);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">export interface IJSXParserMixin {</span><span class="s2">\n  </span><span class="s1">jsxParseOpeningElementAfterName(</span><span class="s2">\n    </span><span class="s1">node: N.JSXOpeningElement,</span><span class="s2">\n  </span><span class="s1">): N.JSXOpeningElement;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">export default (superClass: typeof Parser) =&gt;</span><span class="s2">\n  </span><span class="s1">class JSXParserMixin extends superClass implements Parser, IJSXParserMixin {</span><span class="s2">\n    </span><span class="s1">// Reads inline JSX contents token.</span><span class="s2">\n\n    </span><span class="s1">jsxReadToken(): void {</span><span class="s2">\n      </span><span class="s1">let out = </span><span class="s2">\&quot;\&quot;</span><span class="s1">;</span><span class="s2">\n      </span><span class="s1">let chunkStart = this.state.pos;</span><span class="s2">\n      </span><span class="s1">for (;;) {</span><span class="s2">\n        </span><span class="s1">if (this.state.pos &gt;= this.length) {</span><span class="s2">\n          </span><span class="s1">throw this.raise(JsxErrors.UnterminatedJsxContent, {</span><span class="s2">\n            </span><span class="s1">at: this.state.startLoc,</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">const ch = this.input.charCodeAt(this.state.pos);</span><span class="s2">\n\n        </span><span class="s1">switch (ch) {</span><span class="s2">\n          </span><span class="s1">case charCodes.lessThan:</span><span class="s2">\n          </span><span class="s1">case charCodes.leftCurlyBrace:</span><span class="s2">\n            </span><span class="s1">if (this.state.pos === this.state.start) {</span><span class="s2">\n              </span><span class="s1">if (ch === charCodes.lessThan &amp;&amp; this.state.canStartJSXElement) {</span><span class="s2">\n                </span><span class="s1">++this.state.pos;</span><span class="s2">\n                </span><span class="s1">this.finishToken(tt.jsxTagStart);</span><span class="s2">\n              </span><span class="s1">} else {</span><span class="s2">\n                </span><span class="s1">super.getTokenFromCode(ch);</span><span class="s2">\n              </span><span class="s1">}</span><span class="s2">\n              </span><span class="s1">return;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">out += this.input.slice(chunkStart, this.state.pos);</span><span class="s2">\n            </span><span class="s1">this.finishToken(tt.jsxText, out);</span><span class="s2">\n            </span><span class="s1">return;</span><span class="s2">\n\n          </span><span class="s1">case charCodes.ampersand:</span><span class="s2">\n            </span><span class="s1">out += this.input.slice(chunkStart, this.state.pos);</span><span class="s2">\n            </span><span class="s1">out += this.jsxReadEntity();</span><span class="s2">\n            </span><span class="s1">chunkStart = this.state.pos;</span><span class="s2">\n            </span><span class="s1">break;</span><span class="s2">\n\n          </span><span class="s1">case charCodes.greaterThan:</span><span class="s2">\n          </span><span class="s1">case charCodes.rightCurlyBrace:</span><span class="s2">\n            </span><span class="s1">if (process.env.BABEL_8_BREAKING) {</span><span class="s2">\n              </span><span class="s1">this.raise(JsxErrors.UnexpectedToken, {</span><span class="s2">\n                </span><span class="s1">at: this.state.curPosition(),</span><span class="s2">\n                </span><span class="s1">unexpected: this.input[this.state.pos],</span><span class="s2">\n                </span><span class="s1">HTMLEntity:</span><span class="s2">\n                  </span><span class="s1">ch === charCodes.rightCurlyBrace ? </span><span class="s2">\&quot;</span><span class="s1">&amp;rbrace;</span><span class="s2">\&quot; </span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">&amp;gt;</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n              </span><span class="s1">});</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">/* falls through */</span><span class="s2">\n\n          </span><span class="s1">default:</span><span class="s2">\n            </span><span class="s1">if (isNewLine(ch)) {</span><span class="s2">\n              </span><span class="s1">out += this.input.slice(chunkStart, this.state.pos);</span><span class="s2">\n              </span><span class="s1">out += this.jsxReadNewLine(true);</span><span class="s2">\n              </span><span class="s1">chunkStart = this.state.pos;</span><span class="s2">\n            </span><span class="s1">} else {</span><span class="s2">\n              </span><span class="s1">++this.state.pos;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">jsxReadNewLine(normalizeCRLF: boolean): string {</span><span class="s2">\n      </span><span class="s1">const ch = this.input.charCodeAt(this.state.pos);</span><span class="s2">\n      </span><span class="s1">let out;</span><span class="s2">\n      </span><span class="s1">++this.state.pos;</span><span class="s2">\n      </span><span class="s1">if (</span><span class="s2">\n        </span><span class="s1">ch === charCodes.carriageReturn &amp;&amp;</span><span class="s2">\n        </span><span class="s1">this.input.charCodeAt(this.state.pos) === charCodes.lineFeed</span><span class="s2">\n      </span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">++this.state.pos;</span><span class="s2">\n        </span><span class="s1">out = normalizeCRLF ? </span><span class="s2">\&quot;\\</span><span class="s1">n</span><span class="s2">\&quot; </span><span class="s1">: </span><span class="s2">\&quot;\\</span><span class="s1">r</span><span class="s2">\\</span><span class="s1">n</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">out = String.fromCharCode(ch);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">++this.state.curLine;</span><span class="s2">\n      </span><span class="s1">this.state.lineStart = this.state.pos;</span><span class="s2">\n\n      </span><span class="s1">return out;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">jsxReadString(quote: number): void {</span><span class="s2">\n      </span><span class="s1">let out = </span><span class="s2">\&quot;\&quot;</span><span class="s1">;</span><span class="s2">\n      </span><span class="s1">let chunkStart = ++this.state.pos;</span><span class="s2">\n      </span><span class="s1">for (;;) {</span><span class="s2">\n        </span><span class="s1">if (this.state.pos &gt;= this.length) {</span><span class="s2">\n          </span><span class="s1">throw this.raise(Errors.UnterminatedString, {</span><span class="s2">\n            </span><span class="s1">at: this.state.startLoc,</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">const ch = this.input.charCodeAt(this.state.pos);</span><span class="s2">\n        </span><span class="s1">if (ch === quote) break;</span><span class="s2">\n        </span><span class="s1">if (ch === charCodes.ampersand) {</span><span class="s2">\n          </span><span class="s1">out += this.input.slice(chunkStart, this.state.pos);</span><span class="s2">\n          </span><span class="s1">out += this.jsxReadEntity();</span><span class="s2">\n          </span><span class="s1">chunkStart = this.state.pos;</span><span class="s2">\n        </span><span class="s1">} else if (isNewLine(ch)) {</span><span class="s2">\n          </span><span class="s1">out += this.input.slice(chunkStart, this.state.pos);</span><span class="s2">\n          </span><span class="s1">out += this.jsxReadNewLine(false);</span><span class="s2">\n          </span><span class="s1">chunkStart = this.state.pos;</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">++this.state.pos;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">out += this.input.slice(chunkStart, this.state.pos++);</span><span class="s2">\n      </span><span class="s1">this.finishToken(tt.string, out);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">jsxReadEntity(): string {</span><span class="s2">\n      </span><span class="s1">const startPos = ++this.state.pos;</span><span class="s2">\n      </span><span class="s1">if (this.codePointAtPos(this.state.pos) === charCodes.numberSign) {</span><span class="s2">\n        </span><span class="s1">++this.state.pos;</span><span class="s2">\n\n        </span><span class="s1">let radix = 10;</span><span class="s2">\n        </span><span class="s1">if (this.codePointAtPos(this.state.pos) === charCodes.lowercaseX) {</span><span class="s2">\n          </span><span class="s1">radix = 16;</span><span class="s2">\n          </span><span class="s1">++this.state.pos;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">const codePoint = this.readInt(</span><span class="s2">\n          </span><span class="s1">radix,</span><span class="s2">\n          </span><span class="s1">/* len */ undefined,</span><span class="s2">\n          </span><span class="s1">/* forceLen */ false,</span><span class="s2">\n          </span><span class="s1">/* allowNumSeparator */ </span><span class="s2">\&quot;</span><span class="s1">bail</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">if (</span><span class="s2">\n          </span><span class="s1">codePoint !== null &amp;&amp;</span><span class="s2">\n          </span><span class="s1">this.codePointAtPos(this.state.pos) === charCodes.semicolon</span><span class="s2">\n        </span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">++this.state.pos;</span><span class="s2">\n          </span><span class="s1">return String.fromCodePoint(codePoint);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">let count = 0;</span><span class="s2">\n        </span><span class="s1">let semi = false;</span><span class="s2">\n        </span><span class="s1">while (</span><span class="s2">\n          </span><span class="s1">count++ &lt; 10 &amp;&amp;</span><span class="s2">\n          </span><span class="s1">this.state.pos &lt; this.length &amp;&amp;</span><span class="s2">\n          </span><span class="s1">!(semi = this.codePointAtPos(this.state.pos) == charCodes.semicolon)</span><span class="s2">\n        </span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">++this.state.pos;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">if (semi) {</span><span class="s2">\n          </span><span class="s1">const desc = this.input.slice(startPos, this.state.pos);</span><span class="s2">\n          </span><span class="s1">const entity = XHTMLEntities[desc];</span><span class="s2">\n          </span><span class="s1">++this.state.pos;</span><span class="s2">\n\n          </span><span class="s1">if (entity) {</span><span class="s2">\n            </span><span class="s1">return entity;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">// Not a valid entity</span><span class="s2">\n      </span><span class="s1">this.state.pos = startPos;</span><span class="s2">\n      </span><span class="s1">return </span><span class="s2">\&quot;</span><span class="s1">&amp;</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// Read a JSX identifier (valid tag or attribute name).</span><span class="s2">\n    </span><span class="s1">//</span><span class="s2">\n    </span><span class="s1">// Optimized version since JSX identifiers can</span><span class="s2">\&quot;</span><span class="s1">t contain</span><span class="s2">\n    </span><span class="s1">// escape characters and so can be read as single slice.</span><span class="s2">\n    </span><span class="s1">// Also assumes that first character was already checked</span><span class="s2">\n    </span><span class="s1">// by isIdentifierStart in readToken.</span><span class="s2">\n\n    </span><span class="s1">jsxReadWord(): void {</span><span class="s2">\n      </span><span class="s1">let ch;</span><span class="s2">\n      </span><span class="s1">const start = this.state.pos;</span><span class="s2">\n      </span><span class="s1">do {</span><span class="s2">\n        </span><span class="s1">ch = this.input.charCodeAt(++this.state.pos);</span><span class="s2">\n      </span><span class="s1">} while (isIdentifierChar(ch) || ch === charCodes.dash);</span><span class="s2">\n      </span><span class="s1">this.finishToken(tt.jsxName, this.input.slice(start, this.state.pos));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// Parse next token as JSX identifier</span><span class="s2">\n\n    </span><span class="s1">jsxParseIdentifier(): N.JSXIdentifier {</span><span class="s2">\n      </span><span class="s1">const node = this.startNode();</span><span class="s2">\n      </span><span class="s1">if (this.match(tt.jsxName)) {</span><span class="s2">\n        </span><span class="s1">node.name = this.state.value;</span><span class="s2">\n      </span><span class="s1">} else if (tokenIsKeyword(this.state.type)) {</span><span class="s2">\n        </span><span class="s1">node.name = tokenLabelName(this.state.type);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">this.unexpected();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">this.next();</span><span class="s2">\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">JSXIdentifier</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// Parse namespaced identifier.</span><span class="s2">\n\n    </span><span class="s1">jsxParseNamespacedName(): N.JSXNamespacedName {</span><span class="s2">\n      </span><span class="s1">const startLoc = this.state.startLoc;</span><span class="s2">\n      </span><span class="s1">const name = this.jsxParseIdentifier();</span><span class="s2">\n      </span><span class="s1">if (!this.eat(tt.colon)) return name;</span><span class="s2">\n\n      </span><span class="s1">const node = this.startNodeAt(startLoc);</span><span class="s2">\n      </span><span class="s1">node.namespace = name;</span><span class="s2">\n      </span><span class="s1">node.name = this.jsxParseIdentifier();</span><span class="s2">\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">JSXNamespacedName</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// Parses element name in any form - namespaced, member</span><span class="s2">\n    </span><span class="s1">// or single identifier.</span><span class="s2">\n\n    </span><span class="s1">jsxParseElementName():</span><span class="s2">\n      </span><span class="s1">| N.JSXIdentifier</span><span class="s2">\n      </span><span class="s1">| N.JSXNamespacedName</span><span class="s2">\n      </span><span class="s1">| N.JSXMemberExpression {</span><span class="s2">\n      </span><span class="s1">const startLoc = this.state.startLoc;</span><span class="s2">\n      </span><span class="s1">let node = this.jsxParseNamespacedName();</span><span class="s2">\n      </span><span class="s1">if (node.type === </span><span class="s2">\&quot;</span><span class="s1">JSXNamespacedName</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">return node;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">while (this.eat(tt.dot)) {</span><span class="s2">\n        </span><span class="s1">const newNode = this.startNodeAt(startLoc);</span><span class="s2">\n        </span><span class="s1">newNode.object = node;</span><span class="s2">\n        </span><span class="s1">newNode.property = this.jsxParseIdentifier();</span><span class="s2">\n        </span><span class="s1">node = this.finishNode(newNode, </span><span class="s2">\&quot;</span><span class="s1">JSXMemberExpression</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return node;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// Parses any type of JSX attribute value.</span><span class="s2">\n\n    </span><span class="s1">jsxParseAttributeValue(): N.Expression {</span><span class="s2">\n      </span><span class="s1">let node;</span><span class="s2">\n      </span><span class="s1">switch (this.state.type) {</span><span class="s2">\n        </span><span class="s1">case tt.braceL:</span><span class="s2">\n          </span><span class="s1">node = this.startNode();</span><span class="s2">\n          </span><span class="s1">this.setContext(tc.brace);</span><span class="s2">\n          </span><span class="s1">this.next();</span><span class="s2">\n          </span><span class="s1">node = this.jsxParseExpressionContainer(node, tc.j_oTag);</span><span class="s2">\n          </span><span class="s1">if (node.expression.type === </span><span class="s2">\&quot;</span><span class="s1">JSXEmptyExpression</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n            </span><span class="s1">this.raise(JsxErrors.AttributeIsEmpty, { at: node });</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">return node;</span><span class="s2">\n\n        </span><span class="s1">case tt.jsxTagStart:</span><span class="s2">\n        </span><span class="s1">case tt.string:</span><span class="s2">\n          </span><span class="s1">return this.parseExprAtom();</span><span class="s2">\n\n        </span><span class="s1">default:</span><span class="s2">\n          </span><span class="s1">throw this.raise(JsxErrors.UnsupportedJsxValue, {</span><span class="s2">\n            </span><span class="s1">at: this.state.startLoc,</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// JSXEmptyExpression is unique type since it doesn't actually parse anything,</span><span class="s2">\n    </span><span class="s1">// and so it should start at the end of last read token (left brace) and finish</span><span class="s2">\n    </span><span class="s1">// at the beginning of the next one (right brace).</span><span class="s2">\n\n    </span><span class="s1">jsxParseEmptyExpression(): N.JSXEmptyExpression {</span><span class="s2">\n      </span><span class="s1">const node = this.startNodeAt(this.state.lastTokEndLoc);</span><span class="s2">\n      </span><span class="s1">return this.finishNodeAt(node, </span><span class="s2">\&quot;</span><span class="s1">JSXEmptyExpression</span><span class="s2">\&quot;</span><span class="s1">, this.state.startLoc);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// Parse JSX spread child</span><span class="s2">\n\n    </span><span class="s1">jsxParseSpreadChild(node: Undone&lt;N.JSXSpreadChild&gt;): N.JSXSpreadChild {</span><span class="s2">\n      </span><span class="s1">this.next(); // ellipsis</span><span class="s2">\n      </span><span class="s1">node.expression = this.parseExpression();</span><span class="s2">\n      </span><span class="s1">this.setContext(tc.j_expr);</span><span class="s2">\n      </span><span class="s1">this.state.canStartJSXElement = true;</span><span class="s2">\n      </span><span class="s1">this.expect(tt.braceR);</span><span class="s2">\n\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">JSXSpreadChild</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// Parses JSX expression enclosed into curly brackets.</span><span class="s2">\n\n    </span><span class="s1">jsxParseExpressionContainer(</span><span class="s2">\n      </span><span class="s1">node: Undone&lt;N.JSXExpressionContainer&gt;,</span><span class="s2">\n      </span><span class="s1">previousContext: TokContext,</span><span class="s2">\n    </span><span class="s1">): N.JSXExpressionContainer {</span><span class="s2">\n      </span><span class="s1">if (this.match(tt.braceR)) {</span><span class="s2">\n        </span><span class="s1">node.expression = this.jsxParseEmptyExpression();</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">const expression = this.parseExpression();</span><span class="s2">\n\n        </span><span class="s1">if (process.env.BABEL_8_BREAKING) {</span><span class="s2">\n          </span><span class="s1">if (</span><span class="s2">\n            </span><span class="s1">expression.type === </span><span class="s2">\&quot;</span><span class="s1">SequenceExpression</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n            </span><span class="s1">!expression.extra?.parenthesized</span><span class="s2">\n          </span><span class="s1">) {</span><span class="s2">\n            </span><span class="s1">this.raise(JsxErrors.UnexpectedSequenceExpression, {</span><span class="s2">\n              </span><span class="s1">at: expression.expressions[1],</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">node.expression = expression;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">this.setContext(previousContext);</span><span class="s2">\n      </span><span class="s1">this.state.canStartJSXElement = true;</span><span class="s2">\n      </span><span class="s1">this.expect(tt.braceR);</span><span class="s2">\n\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">JSXExpressionContainer</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// Parses following JSX attribute name-value pair.</span><span class="s2">\n\n    </span><span class="s1">jsxParseAttribute(): N.JSXAttribute {</span><span class="s2">\n      </span><span class="s1">const node = this.startNode();</span><span class="s2">\n      </span><span class="s1">if (this.match(tt.braceL)) {</span><span class="s2">\n        </span><span class="s1">this.setContext(tc.brace);</span><span class="s2">\n        </span><span class="s1">this.next();</span><span class="s2">\n        </span><span class="s1">this.expect(tt.ellipsis);</span><span class="s2">\n        </span><span class="s1">node.argument = this.parseMaybeAssignAllowIn();</span><span class="s2">\n        </span><span class="s1">this.setContext(tc.j_oTag);</span><span class="s2">\n        </span><span class="s1">this.state.canStartJSXElement = true;</span><span class="s2">\n        </span><span class="s1">this.expect(tt.braceR);</span><span class="s2">\n        </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">JSXSpreadAttribute</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">node.name = this.jsxParseNamespacedName();</span><span class="s2">\n      </span><span class="s1">node.value = this.eat(tt.eq) ? this.jsxParseAttributeValue() : null;</span><span class="s2">\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">JSXAttribute</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// Parses JSX opening tag starting after </span><span class="s2">\&quot;</span><span class="s1">&lt;</span><span class="s2">\&quot;</span><span class="s1">.</span><span class="s2">\n\n    </span><span class="s1">jsxParseOpeningElementAt(startLoc: Position): N.JSXOpeningElement {</span><span class="s2">\n      </span><span class="s1">const node = this.startNodeAt&lt;N.JSXOpeningElement | N.JSXOpeningFragment&gt;(</span><span class="s2">\n        </span><span class="s1">startLoc,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">if (this.eat(tt.jsxTagEnd)) {</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error migrate to Babel types</span><span class="s2">\n        </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">JSXOpeningFragment</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">node.name = this.jsxParseElementName();</span><span class="s2">\n      </span><span class="s1">return this.jsxParseOpeningElementAfterName(</span><span class="s2">\n        </span><span class="s1">node as Undone&lt;N.JSXOpeningElement&gt;,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">jsxParseOpeningElementAfterName(</span><span class="s2">\n      </span><span class="s1">node: Undone&lt;N.JSXOpeningElement&gt;,</span><span class="s2">\n    </span><span class="s1">): N.JSXOpeningElement {</span><span class="s2">\n      </span><span class="s1">const attributes: N.JSXAttribute[] = [];</span><span class="s2">\n      </span><span class="s1">while (!this.match(tt.slash) &amp;&amp; !this.match(tt.jsxTagEnd)) {</span><span class="s2">\n        </span><span class="s1">attributes.push(this.jsxParseAttribute());</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">node.attributes = attributes;</span><span class="s2">\n      </span><span class="s1">node.selfClosing = this.eat(tt.slash);</span><span class="s2">\n      </span><span class="s1">this.expect(tt.jsxTagEnd);</span><span class="s2">\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">JSXOpeningElement</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// Parses JSX closing tag starting after </span><span class="s2">\&quot;</span><span class="s1">&lt;/</span><span class="s2">\&quot;</span><span class="s1">.</span><span class="s2">\n\n    </span><span class="s1">jsxParseClosingElementAt(startLoc: Position): N.JSXClosingElement {</span><span class="s2">\n      </span><span class="s1">const node = this.startNodeAt(startLoc);</span><span class="s2">\n      </span><span class="s1">if (this.eat(tt.jsxTagEnd)) {</span><span class="s2">\n        </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">JSXClosingFragment</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">node.name = this.jsxParseElementName();</span><span class="s2">\n      </span><span class="s1">this.expect(tt.jsxTagEnd);</span><span class="s2">\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">JSXClosingElement</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// Parses entire JSX element, including it</span><span class="s2">\&quot;</span><span class="s1">s opening tag</span><span class="s2">\n    </span><span class="s1">// (starting after </span><span class="s2">\&quot;</span><span class="s1">&lt;</span><span class="s2">\&quot;</span><span class="s1">), attributes, contents and closing tag.</span><span class="s2">\n\n    </span><span class="s1">jsxParseElementAt(startLoc: Position): N.JSXElement {</span><span class="s2">\n      </span><span class="s1">const node = this.startNodeAt(startLoc);</span><span class="s2">\n      </span><span class="s1">const children = [];</span><span class="s2">\n      </span><span class="s1">const openingElement = this.jsxParseOpeningElementAt(startLoc);</span><span class="s2">\n      </span><span class="s1">let closingElement = null;</span><span class="s2">\n\n      </span><span class="s1">if (!openingElement.selfClosing) {</span><span class="s2">\n        </span><span class="s1">contents: for (;;) {</span><span class="s2">\n          </span><span class="s1">switch (this.state.type) {</span><span class="s2">\n            </span><span class="s1">case tt.jsxTagStart:</span><span class="s2">\n              </span><span class="s1">startLoc = this.state.startLoc;</span><span class="s2">\n              </span><span class="s1">this.next();</span><span class="s2">\n              </span><span class="s1">if (this.eat(tt.slash)) {</span><span class="s2">\n                </span><span class="s1">closingElement = this.jsxParseClosingElementAt(startLoc);</span><span class="s2">\n                </span><span class="s1">break contents;</span><span class="s2">\n              </span><span class="s1">}</span><span class="s2">\n              </span><span class="s1">children.push(this.jsxParseElementAt(startLoc));</span><span class="s2">\n              </span><span class="s1">break;</span><span class="s2">\n\n            </span><span class="s1">case tt.jsxText:</span><span class="s2">\n              </span><span class="s1">children.push(this.parseExprAtom());</span><span class="s2">\n              </span><span class="s1">break;</span><span class="s2">\n\n            </span><span class="s1">case tt.braceL: {</span><span class="s2">\n              </span><span class="s1">const node = this.startNode&lt;</span><span class="s2">\n                </span><span class="s1">N.JSXSpreadChild | N.JSXExpressionContainer</span><span class="s2">\n              </span><span class="s1">&gt;();</span><span class="s2">\n              </span><span class="s1">this.setContext(tc.brace);</span><span class="s2">\n              </span><span class="s1">this.next();</span><span class="s2">\n              </span><span class="s1">if (this.match(tt.ellipsis)) {</span><span class="s2">\n                </span><span class="s1">children.push(this.jsxParseSpreadChild(node));</span><span class="s2">\n              </span><span class="s1">} else {</span><span class="s2">\n                </span><span class="s1">children.push(</span><span class="s2">\n                  </span><span class="s1">this.jsxParseExpressionContainer(node, tc.j_expr),</span><span class="s2">\n                </span><span class="s1">);</span><span class="s2">\n              </span><span class="s1">}</span><span class="s2">\n\n              </span><span class="s1">break;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">// istanbul ignore next - should never happen</span><span class="s2">\n            </span><span class="s1">default:</span><span class="s2">\n              </span><span class="s1">this.unexpected();</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">if (</span><span class="s2">\n          </span><span class="s1">isFragment(openingElement) &amp;&amp;</span><span class="s2">\n          </span><span class="s1">!isFragment(closingElement) &amp;&amp;</span><span class="s2">\n          </span><span class="s1">closingElement !== null</span><span class="s2">\n        </span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">this.raise(JsxErrors.MissingClosingTagFragment, {</span><span class="s2">\n            </span><span class="s1">at: closingElement,</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">} else if (!isFragment(openingElement) &amp;&amp; isFragment(closingElement)) {</span><span class="s2">\n          </span><span class="s1">this.raise(JsxErrors.MissingClosingTagElement, {</span><span class="s2">\n            </span><span class="s1">at: closingElement,</span><span class="s2">\n            </span><span class="s1">openingTagName: getQualifiedJSXName(openingElement.name),</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">} else if (!isFragment(openingElement) &amp;&amp; !isFragment(closingElement)) {</span><span class="s2">\n          </span><span class="s1">if (</span><span class="s2">\n            </span><span class="s1">getQualifiedJSXName(closingElement.name) !==</span><span class="s2">\n            </span><span class="s1">getQualifiedJSXName(openingElement.name)</span><span class="s2">\n          </span><span class="s1">) {</span><span class="s2">\n            </span><span class="s1">this.raise(JsxErrors.MissingClosingTagElement, {</span><span class="s2">\n              </span><span class="s1">at: closingElement,</span><span class="s2">\n              </span><span class="s1">openingTagName: getQualifiedJSXName(openingElement.name),</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">if (isFragment(openingElement)) {</span><span class="s2">\n        </span><span class="s1">node.openingFragment = openingElement;</span><span class="s2">\n        </span><span class="s1">node.closingFragment = closingElement;</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">node.openingElement = openingElement;</span><span class="s2">\n        </span><span class="s1">node.closingElement = closingElement;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">node.children = children;</span><span class="s2">\n      </span><span class="s1">if (this.match(tt.lt)) {</span><span class="s2">\n        </span><span class="s1">throw this.raise(JsxErrors.UnwrappedAdjacentJSXElements, {</span><span class="s2">\n          </span><span class="s1">at: this.state.startLoc,</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return isFragment(openingElement)</span><span class="s2">\n        </span><span class="s1">? this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">JSXFragment</span><span class="s2">\&quot;</span><span class="s1">)</span><span class="s2">\n        </span><span class="s1">: this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">JSXElement</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// Parses entire JSX element from current position.</span><span class="s2">\n\n    </span><span class="s1">jsxParseElement(): N.JSXElement {</span><span class="s2">\n      </span><span class="s1">const startLoc = this.state.startLoc;</span><span class="s2">\n      </span><span class="s1">this.next();</span><span class="s2">\n      </span><span class="s1">return this.jsxParseElementAt(startLoc);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">setContext(newContext: TokContext) {</span><span class="s2">\n      </span><span class="s1">const { context } = this.state;</span><span class="s2">\n      </span><span class="s1">context[context.length - 1] = newContext;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// ==================================</span><span class="s2">\n    </span><span class="s1">// Overrides</span><span class="s2">\n    </span><span class="s1">// ==================================</span><span class="s2">\n\n    </span><span class="s1">parseExprAtom(refExpressionErrors?: ExpressionErrors | null): N.Expression {</span><span class="s2">\n      </span><span class="s1">if (this.match(tt.jsxText)) {</span><span class="s2">\n        </span><span class="s1">return this.parseLiteral(this.state.value, </span><span class="s2">\&quot;</span><span class="s1">JSXText</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">} else if (this.match(tt.jsxTagStart)) {</span><span class="s2">\n        </span><span class="s1">return this.jsxParseElement();</span><span class="s2">\n      </span><span class="s1">} else if (</span><span class="s2">\n        </span><span class="s1">this.match(tt.lt) &amp;&amp;</span><span class="s2">\n        </span><span class="s1">this.input.charCodeAt(this.state.pos) !== charCodes.exclamationMark</span><span class="s2">\n      </span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">// In case we encounter an lt token here it will always be the start of</span><span class="s2">\n        </span><span class="s1">// jsx as the lt sign is not allowed in places that expect an expression</span><span class="s2">\n        </span><span class="s1">this.replaceToken(tt.jsxTagStart);</span><span class="s2">\n        </span><span class="s1">return this.jsxParseElement();</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">return super.parseExprAtom(refExpressionErrors);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">skipSpace() {</span><span class="s2">\n      </span><span class="s1">const curContext = this.curContext();</span><span class="s2">\n      </span><span class="s1">if (!curContext.preserveSpace) super.skipSpace();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">getTokenFromCode(code: number): void {</span><span class="s2">\n      </span><span class="s1">const context = this.curContext();</span><span class="s2">\n\n      </span><span class="s1">if (context === tc.j_expr) {</span><span class="s2">\n        </span><span class="s1">this.jsxReadToken();</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">if (context === tc.j_oTag || context === tc.j_cTag) {</span><span class="s2">\n        </span><span class="s1">if (isIdentifierStart(code)) {</span><span class="s2">\n          </span><span class="s1">this.jsxReadWord();</span><span class="s2">\n          </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">if (code === charCodes.greaterThan) {</span><span class="s2">\n          </span><span class="s1">++this.state.pos;</span><span class="s2">\n          </span><span class="s1">this.finishToken(tt.jsxTagEnd);</span><span class="s2">\n          </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">if (</span><span class="s2">\n          </span><span class="s1">(code === charCodes.quotationMark || code === charCodes.apostrophe) &amp;&amp;</span><span class="s2">\n          </span><span class="s1">context === tc.j_oTag</span><span class="s2">\n        </span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">this.jsxReadString(code);</span><span class="s2">\n          </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">if (</span><span class="s2">\n        </span><span class="s1">code === charCodes.lessThan &amp;&amp;</span><span class="s2">\n        </span><span class="s1">this.state.canStartJSXElement &amp;&amp;</span><span class="s2">\n        </span><span class="s1">this.input.charCodeAt(this.state.pos + 1) !== charCodes.exclamationMark</span><span class="s2">\n      </span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">++this.state.pos;</span><span class="s2">\n        </span><span class="s1">this.finishToken(tt.jsxTagStart);</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">super.getTokenFromCode(code);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">updateContext(prevType: TokenType): void {</span><span class="s2">\n      </span><span class="s1">const { context, type } = this.state;</span><span class="s2">\n      </span><span class="s1">if (type === tt.slash &amp;&amp; prevType === tt.jsxTagStart) {</span><span class="s2">\n        </span><span class="s1">// do not consider JSX expr -&gt; JSX open tag -&gt; ... anymore</span><span class="s2">\n        </span><span class="s1">// reconsider as closing tag context</span><span class="s2">\n        </span><span class="s1">context.splice(-2, 2, tc.j_cTag);</span><span class="s2">\n        </span><span class="s1">this.state.canStartJSXElement = false;</span><span class="s2">\n      </span><span class="s1">} else if (type === tt.jsxTagStart) {</span><span class="s2">\n        </span><span class="s1">// start opening tag context</span><span class="s2">\n        </span><span class="s1">context.push(tc.j_oTag);</span><span class="s2">\n      </span><span class="s1">} else if (type === tt.jsxTagEnd) {</span><span class="s2">\n        </span><span class="s1">const out = context[context.length - 1];</span><span class="s2">\n        </span><span class="s1">if ((out === tc.j_oTag &amp;&amp; prevType === tt.slash) || out === tc.j_cTag) {</span><span class="s2">\n          </span><span class="s1">context.pop();</span><span class="s2">\n          </span><span class="s1">this.state.canStartJSXElement =</span><span class="s2">\n            </span><span class="s1">context[context.length - 1] === tc.j_expr;</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">this.setContext(tc.j_expr);</span><span class="s2">\n          </span><span class="s1">this.state.canStartJSXElement = true;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">this.state.canStartJSXElement = tokenComesBeforeExpression(type);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">&quot;</span><span class="s2">,</span><span class="s1">&quot;import type { Position } from </span><span class="s2">\&quot;</span><span class="s1">../../util/location</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import ScopeHandler, { Scope } from </span><span class="s2">\&quot;</span><span class="s1">../../util/scope</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import {</span><span class="s2">\n  </span><span class="s1">BIND_KIND_TYPE,</span><span class="s2">\n  </span><span class="s1">BIND_FLAGS_TS_ENUM,</span><span class="s2">\n  </span><span class="s1">BIND_FLAGS_TS_CONST_ENUM,</span><span class="s2">\n  </span><span class="s1">BIND_FLAGS_TS_EXPORT_ONLY,</span><span class="s2">\n  </span><span class="s1">BIND_KIND_VALUE,</span><span class="s2">\n  </span><span class="s1">BIND_FLAGS_CLASS,</span><span class="s2">\n  </span><span class="s1">type ScopeFlags,</span><span class="s2">\n  </span><span class="s1">type BindingTypes,</span><span class="s2">\n  </span><span class="s1">BIND_FLAGS_TS_IMPORT,</span><span class="s2">\n  </span><span class="s1">SCOPE_TS_MODULE,</span><span class="s2">\n</span><span class="s1">} from </span><span class="s2">\&quot;</span><span class="s1">../../util/scopeflags</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type * as N from </span><span class="s2">\&quot;</span><span class="s1">../../types</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import { Errors } from </span><span class="s2">\&quot;</span><span class="s1">../../parse-error</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">class TypeScriptScope extends Scope {</span><span class="s2">\n  </span><span class="s1">types: Set&lt;string&gt; = new Set();</span><span class="s2">\n\n  </span><span class="s1">// enums (which are also in .types)</span><span class="s2">\n  </span><span class="s1">enums: Set&lt;string&gt; = new Set();</span><span class="s2">\n\n  </span><span class="s1">// const enums (which are also in .enums and .types)</span><span class="s2">\n  </span><span class="s1">constEnums: Set&lt;string&gt; = new Set();</span><span class="s2">\n\n  </span><span class="s1">// classes (which are also in .lexical) and interface (which are also in .types)</span><span class="s2">\n  </span><span class="s1">classes: Set&lt;string&gt; = new Set();</span><span class="s2">\n\n  </span><span class="s1">// namespaces and ambient functions (or classes) are too difficult to track,</span><span class="s2">\n  </span><span class="s1">// especially without type analysis.</span><span class="s2">\n  </span><span class="s1">// We need to track them anyway, to avoid </span><span class="s2">\&quot;</span><span class="s1">X is not defined</span><span class="s2">\&quot; </span><span class="s1">errors</span><span class="s2">\n  </span><span class="s1">// when exporting them.</span><span class="s2">\n  </span><span class="s1">exportOnlyBindings: Set&lt;string&gt; = new Set();</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// See https://github.com/babel/babel/pull/9766#discussion_r268920730 for an</span><span class="s2">\n</span><span class="s1">// explanation of how typescript handles scope.</span><span class="s2">\n\n</span><span class="s1">export default class TypeScriptScopeHandler extends ScopeHandler&lt;TypeScriptScope&gt; {</span><span class="s2">\n  </span><span class="s1">importsStack: Set&lt;string&gt;[] = [];</span><span class="s2">\n\n  </span><span class="s1">createScope(flags: ScopeFlags): TypeScriptScope {</span><span class="s2">\n    </span><span class="s1">this.importsStack.push(new Set()); // Always keep the top-level scope for export checks.</span><span class="s2">\n\n    </span><span class="s1">return new TypeScriptScope(flags);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">enter(flags: number): void {</span><span class="s2">\n    </span><span class="s1">if (flags == SCOPE_TS_MODULE) {</span><span class="s2">\n      </span><span class="s1">this.importsStack.push(new Set());</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">super.enter(flags);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">exit() {</span><span class="s2">\n    </span><span class="s1">const flags = super.exit();</span><span class="s2">\n\n    </span><span class="s1">if (flags == SCOPE_TS_MODULE) {</span><span class="s2">\n      </span><span class="s1">this.importsStack.pop();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">return flags;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">hasImport(name: string, allowShadow?: boolean) {</span><span class="s2">\n    </span><span class="s1">const len = this.importsStack.length;</span><span class="s2">\n    </span><span class="s1">if (this.importsStack[len - 1].has(name)) {</span><span class="s2">\n      </span><span class="s1">return true;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (!allowShadow &amp;&amp; len &gt; 1) {</span><span class="s2">\n      </span><span class="s1">for (let i = 0; i &lt; len - 1; i++) {</span><span class="s2">\n        </span><span class="s1">if (this.importsStack[i].has(name)) return true;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return false;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">declareName(name: string, bindingType: BindingTypes, loc: Position) {</span><span class="s2">\n    </span><span class="s1">if (bindingType &amp; BIND_FLAGS_TS_IMPORT) {</span><span class="s2">\n      </span><span class="s1">if (this.hasImport(name, true)) {</span><span class="s2">\n        </span><span class="s1">this.parser.raise(Errors.VarRedeclaration, {</span><span class="s2">\n          </span><span class="s1">at: loc,</span><span class="s2">\n          </span><span class="s1">identifierName: name,</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">this.importsStack[this.importsStack.length - 1].add(name);</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">const scope = this.currentScope();</span><span class="s2">\n    </span><span class="s1">if (bindingType &amp; BIND_FLAGS_TS_EXPORT_ONLY) {</span><span class="s2">\n      </span><span class="s1">this.maybeExportDefined(scope, name);</span><span class="s2">\n      </span><span class="s1">scope.exportOnlyBindings.add(name);</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">super.declareName(name, bindingType, loc);</span><span class="s2">\n\n    </span><span class="s1">if (bindingType &amp; BIND_KIND_TYPE) {</span><span class="s2">\n      </span><span class="s1">if (!(bindingType &amp; BIND_KIND_VALUE)) {</span><span class="s2">\n        </span><span class="s1">// </span><span class="s2">\&quot;</span><span class="s1">Value</span><span class="s2">\&quot; </span><span class="s1">bindings have already been registered by the superclass.</span><span class="s2">\n        </span><span class="s1">this.checkRedeclarationInScope(scope, name, bindingType, loc);</span><span class="s2">\n        </span><span class="s1">this.maybeExportDefined(scope, name);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">scope.types.add(name);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (bindingType &amp; BIND_FLAGS_TS_ENUM) scope.enums.add(name);</span><span class="s2">\n    </span><span class="s1">if (bindingType &amp; BIND_FLAGS_TS_CONST_ENUM) scope.constEnums.add(name);</span><span class="s2">\n    </span><span class="s1">if (bindingType &amp; BIND_FLAGS_CLASS) scope.classes.add(name);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">isRedeclaredInScope(</span><span class="s2">\n    </span><span class="s1">scope: TypeScriptScope,</span><span class="s2">\n    </span><span class="s1">name: string,</span><span class="s2">\n    </span><span class="s1">bindingType: BindingTypes,</span><span class="s2">\n  </span><span class="s1">): boolean {</span><span class="s2">\n    </span><span class="s1">if (scope.enums.has(name)) {</span><span class="s2">\n      </span><span class="s1">if (bindingType &amp; BIND_FLAGS_TS_ENUM) {</span><span class="s2">\n        </span><span class="s1">// Enums can be merged with other enums if they are both</span><span class="s2">\n        </span><span class="s1">//  const or both non-const.</span><span class="s2">\n        </span><span class="s1">const isConst = !!(bindingType &amp; BIND_FLAGS_TS_CONST_ENUM);</span><span class="s2">\n        </span><span class="s1">const wasConst = scope.constEnums.has(name);</span><span class="s2">\n        </span><span class="s1">return isConst !== wasConst;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return true;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (bindingType &amp; BIND_FLAGS_CLASS &amp;&amp; scope.classes.has(name)) {</span><span class="s2">\n      </span><span class="s1">if (scope.lexical.has(name)) {</span><span class="s2">\n        </span><span class="s1">// Classes can be merged with interfaces</span><span class="s2">\n        </span><span class="s1">return !!(bindingType &amp; BIND_KIND_VALUE);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">// Interface can be merged with other classes or interfaces</span><span class="s2">\n        </span><span class="s1">return false;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (bindingType &amp; BIND_KIND_TYPE &amp;&amp; scope.types.has(name)) {</span><span class="s2">\n      </span><span class="s1">return true;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">return super.isRedeclaredInScope(scope, name, bindingType);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">checkLocalExport(id: N.Identifier) {</span><span class="s2">\n    </span><span class="s1">const { name } = id;</span><span class="s2">\n\n    </span><span class="s1">if (this.hasImport(name)) return;</span><span class="s2">\n\n    </span><span class="s1">const len = this.scopeStack.length;</span><span class="s2">\n    </span><span class="s1">for (let i = len - 1; i &gt;= 0; i--) {</span><span class="s2">\n      </span><span class="s1">const scope = this.scopeStack[i];</span><span class="s2">\n      </span><span class="s1">if (scope.types.has(name) || scope.exportOnlyBindings.has(name)) return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">super.checkLocalExport(id);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">&quot;</span><span class="s2">,</span><span class="s1">&quot;import * as charCodes from </span><span class="s2">\&quot;</span><span class="s1">charcodes</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import { tt, type TokenType } from </span><span class="s2">\&quot;</span><span class="s1">../tokenizer/types</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type {</span><span class="s2">\n  </span><span class="s1">AssignmentPattern,</span><span class="s2">\n  </span><span class="s1">TSParameterProperty,</span><span class="s2">\n  </span><span class="s1">Decorator,</span><span class="s2">\n  </span><span class="s1">Expression,</span><span class="s2">\n  </span><span class="s1">Identifier,</span><span class="s2">\n  </span><span class="s1">Node,</span><span class="s2">\n  </span><span class="s1">Pattern,</span><span class="s2">\n  </span><span class="s1">RestElement,</span><span class="s2">\n  </span><span class="s1">SpreadElement,</span><span class="s2">\n  </span><span class="s1">ObjectOrClassMember,</span><span class="s2">\n  </span><span class="s1">ClassMember,</span><span class="s2">\n  </span><span class="s1">ObjectMember,</span><span class="s2">\n  </span><span class="s1">TsNamedTypeElementBase,</span><span class="s2">\n  </span><span class="s1">PrivateName,</span><span class="s2">\n  </span><span class="s1">ObjectExpression,</span><span class="s2">\n  </span><span class="s1">ObjectPattern,</span><span class="s2">\n  </span><span class="s1">ArrayExpression,</span><span class="s2">\n  </span><span class="s1">ArrayPattern,</span><span class="s2">\n</span><span class="s1">} from </span><span class="s2">\&quot;</span><span class="s1">../types</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type { Pos, Position } from </span><span class="s2">\&quot;</span><span class="s1">../util/location</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import {</span><span class="s2">\n  </span><span class="s1">isStrictBindOnlyReservedWord,</span><span class="s2">\n  </span><span class="s1">isStrictBindReservedWord,</span><span class="s2">\n</span><span class="s1">} from </span><span class="s2">\&quot;</span><span class="s1">../util/identifier</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import { NodeUtils, type Undone } from </span><span class="s2">\&quot;</span><span class="s1">./node</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import {</span><span class="s2">\n  </span><span class="s1">type BindingTypes,</span><span class="s2">\n  </span><span class="s1">BIND_NONE,</span><span class="s2">\n  </span><span class="s1">BIND_FLAGS_NO_LET_IN_LEXICAL,</span><span class="s2">\n</span><span class="s1">} from </span><span class="s2">\&quot;</span><span class="s1">../util/scopeflags</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type { ExpressionErrors } from </span><span class="s2">\&quot;</span><span class="s1">./util</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import { Errors, type LValAncestor } from </span><span class="s2">\&quot;</span><span class="s1">../parse-error</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type Parser from </span><span class="s2">\&quot;</span><span class="s1">./index</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">const getOwn = &lt;T extends {}&gt;(object: T, key: keyof T) =&gt;</span><span class="s2">\n  </span><span class="s1">Object.hasOwnProperty.call(object, key) &amp;&amp; object[key];</span><span class="s2">\n\n</span><span class="s1">const unwrapParenthesizedExpression = (node: Node): Node =&gt; {</span><span class="s2">\n  </span><span class="s1">return node.type === </span><span class="s2">\&quot;</span><span class="s1">ParenthesizedExpression</span><span class="s2">\&quot;\n    </span><span class="s1">? unwrapParenthesizedExpression(node.expression)</span><span class="s2">\n    </span><span class="s1">: node;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">export const enum ParseBindingListFlags {</span><span class="s2">\n  </span><span class="s1">ALLOW_EMPTY = 1 &lt;&lt; 0,</span><span class="s2">\n  </span><span class="s1">IS_FUNCTION_PARAMS = 1 &lt;&lt; 1,</span><span class="s2">\n  </span><span class="s1">IS_CONSTRUCTOR_PARAMS = 1 &lt;&lt; 2,</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">export default abstract class LValParser extends NodeUtils {</span><span class="s2">\n  </span><span class="s1">// Forward-declaration: defined in expression.js</span><span class="s2">\n  </span><span class="s1">abstract parseIdentifier(liberal?: boolean): Identifier;</span><span class="s2">\n  </span><span class="s1">abstract parseMaybeAssign(</span><span class="s2">\n    </span><span class="s1">refExpressionErrors?: ExpressionErrors | null,</span><span class="s2">\n    </span><span class="s1">afterLeftParse?: Function,</span><span class="s2">\n    </span><span class="s1">refNeedsArrowPos?: Pos | null,</span><span class="s2">\n  </span><span class="s1">): Expression;</span><span class="s2">\n\n  </span><span class="s1">abstract parseMaybeAssignAllowIn(</span><span class="s2">\n    </span><span class="s1">refExpressionErrors?: ExpressionErrors | null,</span><span class="s2">\n    </span><span class="s1">afterLeftParse?: Function,</span><span class="s2">\n    </span><span class="s1">refNeedsArrowPos?: Pos | null,</span><span class="s2">\n  </span><span class="s1">): Expression;</span><span class="s2">\n\n  </span><span class="s1">abstract parseObjectLike&lt;T extends ObjectPattern | ObjectExpression&gt;(</span><span class="s2">\n    </span><span class="s1">close: TokenType,</span><span class="s2">\n    </span><span class="s1">isPattern: boolean,</span><span class="s2">\n    </span><span class="s1">isRecord?: boolean,</span><span class="s2">\n    </span><span class="s1">refExpressionErrors?: ExpressionErrors,</span><span class="s2">\n  </span><span class="s1">): T;</span><span class="s2">\n  </span><span class="s1">abstract parseObjPropValue(</span><span class="s2">\n    </span><span class="s1">prop: any,</span><span class="s2">\n    </span><span class="s1">startLoc: Position | null,</span><span class="s2">\n    </span><span class="s1">isGenerator: boolean,</span><span class="s2">\n    </span><span class="s1">isAsync: boolean,</span><span class="s2">\n    </span><span class="s1">isPattern: boolean,</span><span class="s2">\n    </span><span class="s1">isAccessor: boolean,</span><span class="s2">\n    </span><span class="s1">refExpressionErrors?: ExpressionErrors | null,</span><span class="s2">\n  </span><span class="s1">): void;</span><span class="s2">\n  </span><span class="s1">abstract parsePropertyName(</span><span class="s2">\n    </span><span class="s1">prop: ObjectOrClassMember | ClassMember | TsNamedTypeElementBase,</span><span class="s2">\n  </span><span class="s1">): Expression | Identifier;</span><span class="s2">\n  </span><span class="s1">abstract parsePrivateName(): PrivateName;</span><span class="s2">\n  </span><span class="s1">// Forward-declaration: defined in statement.js</span><span class="s2">\n  </span><span class="s1">abstract parseDecorator(): Decorator;</span><span class="s2">\n\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* Convert existing expression atom to assignable pattern</span><span class="s2">\n   </span><span class="s1">* if possible. Also checks invalid destructuring targets:</span><span class="s2">\n   </span><span class="s1">*</span><span class="s2">\n   </span><span class="s1">* - Parenthesized Destructuring patterns</span><span class="s2">\n   </span><span class="s1">* - RestElement is not the last element</span><span class="s2">\n   </span><span class="s1">* - Missing `=` in assignment pattern</span><span class="s2">\n   </span><span class="s1">*</span><span class="s2">\n   </span><span class="s1">* NOTE: There is a corresponding </span><span class="s2">\&quot;</span><span class="s1">isAssignable</span><span class="s2">\&quot; </span><span class="s1">method.</span><span class="s2">\n   </span><span class="s1">* When this one is updated, please check if also that one needs to be updated.</span><span class="s2">\n   </span><span class="s1">*</span><span class="s2">\n   </span><span class="s1">* @param node The expression atom</span><span class="s2">\n   </span><span class="s1">* @param isLHS Whether we are parsing a LeftHandSideExpression.</span><span class="s2">\n   </span><span class="s1">*              If isLHS is `true`, the following cases are allowed: `[(a)] = [0]`, `[(a.b)] = [0]`</span><span class="s2">\n   </span><span class="s1">*              If isLHS is `false`, we are in an arrow function parameters list.</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">toAssignable(node: Node, isLHS: boolean = false): void {</span><span class="s2">\n    </span><span class="s1">let parenthesized = undefined;</span><span class="s2">\n    </span><span class="s1">if (node.type === </span><span class="s2">\&quot;</span><span class="s1">ParenthesizedExpression</span><span class="s2">\&quot; </span><span class="s1">|| node.extra?.parenthesized) {</span><span class="s2">\n      </span><span class="s1">parenthesized = unwrapParenthesizedExpression(node);</span><span class="s2">\n      </span><span class="s1">if (isLHS) {</span><span class="s2">\n        </span><span class="s1">// an LHS can be reinterpreted to a binding pattern but not vice versa.</span><span class="s2">\n        </span><span class="s1">// therefore a parenthesized identifier is ambiguous until we are sure it is an assignment expression</span><span class="s2">\n        </span><span class="s1">// i.e. `([(a) = []] = []) =&gt; {}`</span><span class="s2">\n        </span><span class="s1">// see also `recordArrowParameterBindingError` signature in packages/babel-parser/src/util/expression-scope.js</span><span class="s2">\n        </span><span class="s1">if (parenthesized.type === </span><span class="s2">\&quot;</span><span class="s1">Identifier</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">this.expressionScope.recordArrowParameterBindingError(</span><span class="s2">\n            </span><span class="s1">Errors.InvalidParenthesizedAssignment,</span><span class="s2">\n            </span><span class="s1">{ at: node },</span><span class="s2">\n          </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">} else if (parenthesized.type !== </span><span class="s2">\&quot;</span><span class="s1">MemberExpression</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">// A parenthesized member expression can be in LHS but not in pattern.</span><span class="s2">\n          </span><span class="s1">// If the LHS is later interpreted as a pattern, `checkLVal` will throw for member expression binding</span><span class="s2">\n          </span><span class="s1">// i.e. `([(a.b) = []] = []) =&gt; {}`</span><span class="s2">\n          </span><span class="s1">this.raise(Errors.InvalidParenthesizedAssignment, { at: node });</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">this.raise(Errors.InvalidParenthesizedAssignment, { at: node });</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">switch (node.type) {</span><span class="s2">\n      </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">Identifier</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n      </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">ObjectPattern</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n      </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">ArrayPattern</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n      </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">AssignmentPattern</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n      </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">RestElement</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n        </span><span class="s1">break;</span><span class="s2">\n\n      </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">ObjectExpression</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n        </span><span class="s1">node.type = </span><span class="s2">\&quot;</span><span class="s1">ObjectPattern</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n        </span><span class="s1">for (</span><span class="s2">\n          </span><span class="s1">let i = 0, length = node.properties.length, last = length - 1;</span><span class="s2">\n          </span><span class="s1">i &lt; length;</span><span class="s2">\n          </span><span class="s1">i++</span><span class="s2">\n        </span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">const prop = node.properties[i];</span><span class="s2">\n          </span><span class="s1">const isLast = i === last;</span><span class="s2">\n          </span><span class="s1">this.toAssignableObjectExpressionProp(prop, isLast, isLHS);</span><span class="s2">\n\n          </span><span class="s1">if (</span><span class="s2">\n            </span><span class="s1">isLast &amp;&amp;</span><span class="s2">\n            </span><span class="s1">prop.type === </span><span class="s2">\&quot;</span><span class="s1">RestElement</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n            </span><span class="s1">node.extra?.trailingCommaLoc</span><span class="s2">\n          </span><span class="s1">) {</span><span class="s2">\n            </span><span class="s1">this.raise(Errors.RestTrailingComma, {</span><span class="s2">\n              </span><span class="s1">at: node.extra.trailingCommaLoc,</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">break;</span><span class="s2">\n\n      </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">ObjectProperty</span><span class="s2">\&quot;</span><span class="s1">: {</span><span class="s2">\n        </span><span class="s1">const { key, value } = node;</span><span class="s2">\n        </span><span class="s1">if (this.isPrivateName(key)) {</span><span class="s2">\n          </span><span class="s1">this.classScope.usePrivateName(</span><span class="s2">\n            </span><span class="s1">this.getPrivateNameSV(key),</span><span class="s2">\n            </span><span class="s1">key.loc.start,</span><span class="s2">\n          </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">this.toAssignable(value, isLHS);</span><span class="s2">\n        </span><span class="s1">break;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">SpreadElement</span><span class="s2">\&quot;</span><span class="s1">: {</span><span class="s2">\n        </span><span class="s1">throw new Error(</span><span class="s2">\n          \&quot;</span><span class="s1">Internal @babel/parser error (this is a bug, please report it).</span><span class="s2">\&quot; </span><span class="s1">+</span><span class="s2">\n            \&quot; </span><span class="s1">SpreadElement should be converted by .toAssignable's caller.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">ArrayExpression</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n        </span><span class="s1">node.type = </span><span class="s2">\&quot;</span><span class="s1">ArrayPattern</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n        </span><span class="s1">this.toAssignableList(</span><span class="s2">\n          </span><span class="s1">node.elements,</span><span class="s2">\n          </span><span class="s1">node.extra?.trailingCommaLoc,</span><span class="s2">\n          </span><span class="s1">isLHS,</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">break;</span><span class="s2">\n\n      </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">AssignmentExpression</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n        </span><span class="s1">if (node.operator !== </span><span class="s2">\&quot;</span><span class="s1">=</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">this.raise(Errors.MissingEqInAssignment, { at: node.left.loc.end });</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">node.type = </span><span class="s2">\&quot;</span><span class="s1">AssignmentPattern</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n        </span><span class="s1">delete node.operator;</span><span class="s2">\n        </span><span class="s1">this.toAssignable(node.left, isLHS);</span><span class="s2">\n        </span><span class="s1">break;</span><span class="s2">\n\n      </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">ParenthesizedExpression</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n        </span><span class="s1">/*::invariant (parenthesized !== undefined) */</span><span class="s2">\n        </span><span class="s1">this.toAssignable(parenthesized, isLHS);</span><span class="s2">\n        </span><span class="s1">break;</span><span class="s2">\n\n      </span><span class="s1">default:</span><span class="s2">\n      </span><span class="s1">// We don't know how to deal with this node. It will</span><span class="s2">\n      </span><span class="s1">// be reported by a later call to checkLVal</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">toAssignableObjectExpressionProp(</span><span class="s2">\n    </span><span class="s1">prop: Node,</span><span class="s2">\n    </span><span class="s1">isLast: boolean,</span><span class="s2">\n    </span><span class="s1">isLHS: boolean,</span><span class="s2">\n  </span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">if (prop.type === </span><span class="s2">\&quot;</span><span class="s1">ObjectMethod</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">this.raise(</span><span class="s2">\n        </span><span class="s1">prop.kind === </span><span class="s2">\&quot;</span><span class="s1">get</span><span class="s2">\&quot; </span><span class="s1">|| prop.kind === </span><span class="s2">\&quot;</span><span class="s1">set</span><span class="s2">\&quot;\n          </span><span class="s1">? Errors.PatternHasAccessor</span><span class="s2">\n          </span><span class="s1">: Errors.PatternHasMethod,</span><span class="s2">\n        </span><span class="s1">{ at: prop.key },</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">} else if (prop.type === </span><span class="s2">\&quot;</span><span class="s1">SpreadElement</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">prop.type = </span><span class="s2">\&quot;</span><span class="s1">RestElement</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n      </span><span class="s1">const arg = prop.argument;</span><span class="s2">\n      </span><span class="s1">this.checkToRestConversion(arg, /* allowPattern */ false);</span><span class="s2">\n      </span><span class="s1">this.toAssignable(arg, isLHS);</span><span class="s2">\n\n      </span><span class="s1">if (!isLast) {</span><span class="s2">\n        </span><span class="s1">this.raise(Errors.RestTrailingComma, { at: prop });</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">this.toAssignable(prop, isLHS);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Convert list of expression atoms to binding list.</span><span class="s2">\n\n  </span><span class="s1">toAssignableList(</span><span class="s2">\n    </span><span class="s1">exprList: Expression[],</span><span class="s2">\n    </span><span class="s1">trailingCommaLoc: Position | undefined | null,</span><span class="s2">\n    </span><span class="s1">isLHS: boolean,</span><span class="s2">\n  </span><span class="s1">): void {</span><span class="s2">\n    </span><span class="s1">const end = exprList.length - 1;</span><span class="s2">\n\n    </span><span class="s1">for (let i = 0; i &lt;= end; i++) {</span><span class="s2">\n      </span><span class="s1">const elt = exprList[i];</span><span class="s2">\n      </span><span class="s1">if (!elt) continue;</span><span class="s2">\n\n      </span><span class="s1">if (elt.type === </span><span class="s2">\&quot;</span><span class="s1">SpreadElement</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">elt.type = </span><span class="s2">\&quot;</span><span class="s1">RestElement</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n        </span><span class="s1">const arg = elt.argument;</span><span class="s2">\n        </span><span class="s1">this.checkToRestConversion(arg, /* allowPattern */ true);</span><span class="s2">\n        </span><span class="s1">this.toAssignable(arg, isLHS);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">this.toAssignable(elt, isLHS);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">if (elt.type === </span><span class="s2">\&quot;</span><span class="s1">RestElement</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">if (i &lt; end) {</span><span class="s2">\n          </span><span class="s1">this.raise(Errors.RestTrailingComma, { at: elt });</span><span class="s2">\n        </span><span class="s1">} else if (trailingCommaLoc) {</span><span class="s2">\n          </span><span class="s1">this.raise(Errors.RestTrailingComma, { at: trailingCommaLoc });</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">isAssignable(node: Node, isBinding?: boolean): boolean {</span><span class="s2">\n    </span><span class="s1">switch (node.type) {</span><span class="s2">\n      </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">Identifier</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n      </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">ObjectPattern</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n      </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">ArrayPattern</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n      </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">AssignmentPattern</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n      </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">RestElement</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n        </span><span class="s1">return true;</span><span class="s2">\n\n      </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">ObjectExpression</span><span class="s2">\&quot;</span><span class="s1">: {</span><span class="s2">\n        </span><span class="s1">const last = node.properties.length - 1;</span><span class="s2">\n        </span><span class="s1">return (node.properties as ObjectExpression[</span><span class="s2">\&quot;</span><span class="s1">properties</span><span class="s2">\&quot;</span><span class="s1">]).every(</span><span class="s2">\n          </span><span class="s1">(prop, i) =&gt; {</span><span class="s2">\n            </span><span class="s1">return (</span><span class="s2">\n              </span><span class="s1">prop.type !== </span><span class="s2">\&quot;</span><span class="s1">ObjectMethod</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n              </span><span class="s1">(i === last || prop.type !== </span><span class="s2">\&quot;</span><span class="s1">SpreadElement</span><span class="s2">\&quot;</span><span class="s1">) &amp;&amp;</span><span class="s2">\n              </span><span class="s1">this.isAssignable(prop)</span><span class="s2">\n            </span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">ObjectProperty</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n        </span><span class="s1">return this.isAssignable(node.value);</span><span class="s2">\n\n      </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">SpreadElement</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n        </span><span class="s1">return this.isAssignable(node.argument);</span><span class="s2">\n\n      </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">ArrayExpression</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n        </span><span class="s1">return (node as ArrayExpression).elements.every(</span><span class="s2">\n          </span><span class="s1">element =&gt; element === null || this.isAssignable(element),</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n\n      </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">AssignmentExpression</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n        </span><span class="s1">return node.operator === </span><span class="s2">\&quot;</span><span class="s1">=</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n      </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">ParenthesizedExpression</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n        </span><span class="s1">return this.isAssignable(node.expression);</span><span class="s2">\n\n      </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">MemberExpression</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n      </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">OptionalMemberExpression</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n        </span><span class="s1">return !isBinding;</span><span class="s2">\n\n      </span><span class="s1">default:</span><span class="s2">\n        </span><span class="s1">return false;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Convert list of expression atoms to a list of</span><span class="s2">\n\n  </span><span class="s1">toReferencedList(</span><span class="s2">\n    </span><span class="s1">exprList: ReadonlyArray&lt;Expression | undefined | null&gt;,</span><span class="s2">\n    </span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-unused-vars</span><span class="s2">\n    </span><span class="s1">isParenthesizedExpr?: boolean,</span><span class="s2">\n  </span><span class="s1">): ReadonlyArray&lt;Expression | undefined | null&gt; {</span><span class="s2">\n    </span><span class="s1">return exprList;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">toReferencedListDeep(</span><span class="s2">\n    </span><span class="s1">exprList: ReadonlyArray&lt;Expression | undefined | null&gt;,</span><span class="s2">\n    </span><span class="s1">isParenthesizedExpr?: boolean,</span><span class="s2">\n  </span><span class="s1">): void {</span><span class="s2">\n    </span><span class="s1">this.toReferencedList(exprList, isParenthesizedExpr);</span><span class="s2">\n\n    </span><span class="s1">for (const expr of exprList) {</span><span class="s2">\n      </span><span class="s1">if (expr?.type === </span><span class="s2">\&quot;</span><span class="s1">ArrayExpression</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">this.toReferencedListDeep(expr.elements);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Parses spread element.</span><span class="s2">\n\n  </span><span class="s1">parseSpread(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">refExpressionErrors?: ExpressionErrors | null,</span><span class="s2">\n  </span><span class="s1">): SpreadElement {</span><span class="s2">\n    </span><span class="s1">const node = this.startNode&lt;SpreadElement&gt;();</span><span class="s2">\n    </span><span class="s1">this.next();</span><span class="s2">\n    </span><span class="s1">node.argument = this.parseMaybeAssignAllowIn(</span><span class="s2">\n      </span><span class="s1">refExpressionErrors,</span><span class="s2">\n      </span><span class="s1">undefined,</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">SpreadElement</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// https://tc39.es/ecma262/#prod-BindingRestProperty</span><span class="s2">\n  </span><span class="s1">// https://tc39.es/ecma262/#prod-BindingRestElement</span><span class="s2">\n  </span><span class="s1">parseRestBinding(this: Parser): RestElement {</span><span class="s2">\n    </span><span class="s1">const node = this.startNode&lt;RestElement&gt;();</span><span class="s2">\n    </span><span class="s1">this.next(); // eat `...`</span><span class="s2">\n    </span><span class="s1">node.argument = this.parseBindingAtom();</span><span class="s2">\n    </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">RestElement</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Parses lvalue (assignable) atom.</span><span class="s2">\n  </span><span class="s1">parseBindingAtom(this: Parser): Pattern {</span><span class="s2">\n    </span><span class="s1">// https://tc39.es/ecma262/#prod-BindingPattern</span><span class="s2">\n    </span><span class="s1">switch (this.state.type) {</span><span class="s2">\n      </span><span class="s1">case tt.bracketL: {</span><span class="s2">\n        </span><span class="s1">const node = this.startNode&lt;ArrayPattern&gt;();</span><span class="s2">\n        </span><span class="s1">this.next();</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error: Fixme: TSParameterProperty can not be assigned to node.elements</span><span class="s2">\n        </span><span class="s1">node.elements = this.parseBindingList(</span><span class="s2">\n          </span><span class="s1">tt.bracketR,</span><span class="s2">\n          </span><span class="s1">charCodes.rightSquareBracket,</span><span class="s2">\n          </span><span class="s1">ParseBindingListFlags.ALLOW_EMPTY,</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">ArrayPattern</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">case tt.braceL:</span><span class="s2">\n        </span><span class="s1">return this.parseObjectLike(tt.braceR, true);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// https://tc39.es/ecma262/#prod-BindingIdentifier</span><span class="s2">\n    </span><span class="s1">return this.parseIdentifier();</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// https://tc39.es/ecma262/#prod-BindingElementList</span><span class="s2">\n  </span><span class="s1">parseBindingList(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">close: TokenType,</span><span class="s2">\n    </span><span class="s1">closeCharCode: (typeof charCodes)[keyof typeof charCodes],</span><span class="s2">\n    </span><span class="s1">flags: ParseBindingListFlags,</span><span class="s2">\n  </span><span class="s1">): Array&lt;Pattern | TSParameterProperty&gt; {</span><span class="s2">\n    </span><span class="s1">const allowEmpty = flags &amp; ParseBindingListFlags.ALLOW_EMPTY;</span><span class="s2">\n\n    </span><span class="s1">const elts: Array&lt;Pattern | TSParameterProperty&gt; = [];</span><span class="s2">\n    </span><span class="s1">let first = true;</span><span class="s2">\n    </span><span class="s1">while (!this.eat(close)) {</span><span class="s2">\n      </span><span class="s1">if (first) {</span><span class="s2">\n        </span><span class="s1">first = false;</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">this.expect(tt.comma);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (allowEmpty &amp;&amp; this.match(tt.comma)) {</span><span class="s2">\n        </span><span class="s1">elts.push(null);</span><span class="s2">\n      </span><span class="s1">} else if (this.eat(close)) {</span><span class="s2">\n        </span><span class="s1">break;</span><span class="s2">\n      </span><span class="s1">} else if (this.match(tt.ellipsis)) {</span><span class="s2">\n        </span><span class="s1">elts.push(</span><span class="s2">\n          </span><span class="s1">this.parseAssignableListItemTypes(this.parseRestBinding(), flags),</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">if (!this.checkCommaAfterRest(closeCharCode)) {</span><span class="s2">\n          </span><span class="s1">this.expect(close);</span><span class="s2">\n          </span><span class="s1">break;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">const decorators = [];</span><span class="s2">\n        </span><span class="s1">if (this.match(tt.at) &amp;&amp; this.hasPlugin(</span><span class="s2">\&quot;</span><span class="s1">decorators</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n          </span><span class="s1">this.raise(Errors.UnsupportedParameterDecorator, {</span><span class="s2">\n            </span><span class="s1">at: this.state.startLoc,</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// invariant: hasPlugin(</span><span class="s2">\&quot;</span><span class="s1">decorators-legacy</span><span class="s2">\&quot;</span><span class="s1">)</span><span class="s2">\n        </span><span class="s1">while (this.match(tt.at)) {</span><span class="s2">\n          </span><span class="s1">decorators.push(this.parseDecorator());</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">elts.push(this.parseAssignableListItem(flags, decorators));</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return elts;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// https://tc39.es/ecma262/#prod-BindingRestProperty</span><span class="s2">\n  </span><span class="s1">parseBindingRestProperty(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">prop: Undone&lt;RestElement&gt;,</span><span class="s2">\n  </span><span class="s1">): RestElement {</span><span class="s2">\n    </span><span class="s1">this.next(); // eat '...'</span><span class="s2">\n    </span><span class="s1">// Don't use parseRestBinding() as we only allow Identifier here.</span><span class="s2">\n    </span><span class="s1">prop.argument = this.parseIdentifier();</span><span class="s2">\n    </span><span class="s1">this.checkCommaAfterRest(charCodes.rightCurlyBrace);</span><span class="s2">\n    </span><span class="s1">return this.finishNode(prop, </span><span class="s2">\&quot;</span><span class="s1">RestElement</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// https://tc39.es/ecma262/#prod-BindingProperty</span><span class="s2">\n  </span><span class="s1">parseBindingProperty(this: Parser): ObjectMember | RestElement {</span><span class="s2">\n    </span><span class="s1">const prop = this.startNode&lt;ObjectMember | RestElement&gt;();</span><span class="s2">\n    </span><span class="s1">const { type, startLoc } = this.state;</span><span class="s2">\n    </span><span class="s1">if (type === tt.ellipsis) {</span><span class="s2">\n      </span><span class="s1">return this.parseBindingRestProperty(prop as Undone&lt;RestElement&gt;);</span><span class="s2">\n    </span><span class="s1">} else if (type === tt.privateName) {</span><span class="s2">\n      </span><span class="s1">this.expectPlugin(</span><span class="s2">\&quot;</span><span class="s1">destructuringPrivate</span><span class="s2">\&quot;</span><span class="s1">, startLoc);</span><span class="s2">\n      </span><span class="s1">this.classScope.usePrivateName(this.state.value, startLoc);</span><span class="s2">\n      </span><span class="s1">(prop as Undone&lt;ObjectMember&gt;).key = this.parsePrivateName();</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">this.parsePropertyName(prop as Undone&lt;ObjectMember&gt;);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">(prop as Undone&lt;ObjectMember&gt;).method = false;</span><span class="s2">\n    </span><span class="s1">return this.parseObjPropValue(</span><span class="s2">\n      </span><span class="s1">prop as Undone&lt;ObjectMember&gt;,</span><span class="s2">\n      </span><span class="s1">startLoc,</span><span class="s2">\n      </span><span class="s1">false /* isGenerator */,</span><span class="s2">\n      </span><span class="s1">false /* isAsync */,</span><span class="s2">\n      </span><span class="s1">true /* isPattern */,</span><span class="s2">\n      </span><span class="s1">false /* isAccessor */,</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">parseAssignableListItem(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">flags: ParseBindingListFlags,</span><span class="s2">\n    </span><span class="s1">decorators: Decorator[],</span><span class="s2">\n  </span><span class="s1">): Pattern | TSParameterProperty {</span><span class="s2">\n    </span><span class="s1">const left = this.parseMaybeDefault();</span><span class="s2">\n    </span><span class="s1">this.parseAssignableListItemTypes(left, flags);</span><span class="s2">\n    </span><span class="s1">const elt = this.parseMaybeDefault(left.loc.start, left);</span><span class="s2">\n    </span><span class="s1">if (decorators.length) {</span><span class="s2">\n      </span><span class="s1">left.decorators = decorators;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return elt;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Used by flow/typescript plugin to add type annotations to binding elements</span><span class="s2">\n  </span><span class="s1">parseAssignableListItemTypes(</span><span class="s2">\n    </span><span class="s1">param: Pattern,</span><span class="s2">\n    </span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-unused-vars</span><span class="s2">\n    </span><span class="s1">flags: ParseBindingListFlags,</span><span class="s2">\n  </span><span class="s1">): Pattern {</span><span class="s2">\n    </span><span class="s1">return param;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Parses assignment pattern around given atom if possible.</span><span class="s2">\n  </span><span class="s1">// https://tc39.es/ecma262/#prod-BindingElement</span><span class="s2">\n  </span><span class="s1">parseMaybeDefault(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">startLoc?: Position | null,</span><span class="s2">\n    </span><span class="s1">left?: Pattern | null,</span><span class="s2">\n  </span><span class="s1">): Pattern {</span><span class="s2">\n    </span><span class="s1">startLoc ??= this.state.startLoc;</span><span class="s2">\n    </span><span class="s1">left = left ?? this.parseBindingAtom();</span><span class="s2">\n    </span><span class="s1">if (!this.eat(tt.eq)) return left;</span><span class="s2">\n\n    </span><span class="s1">const node = this.startNodeAt&lt;AssignmentPattern&gt;(startLoc);</span><span class="s2">\n    </span><span class="s1">node.left = left;</span><span class="s2">\n    </span><span class="s1">node.right = this.parseMaybeAssignAllowIn();</span><span class="s2">\n    </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">AssignmentPattern</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* Return information use in determining whether a Node of a given type is an LVal,</span><span class="s2">\n   </span><span class="s1">* possibly given certain additional context information.</span><span class="s2">\n   </span><span class="s1">*</span><span class="s2">\n   </span><span class="s1">* Subclasser notes: This method has kind of a lot of mixed, but related,</span><span class="s2">\n   </span><span class="s1">* responsibilities. If we can definitively determine with the information</span><span class="s2">\n   </span><span class="s1">* provided that this either *is* or *isn't* a valid `LVal`, then the return</span><span class="s2">\n   </span><span class="s1">* value is easy: just return `true` or `false`. However, if it is a valid</span><span class="s2">\n   </span><span class="s1">* LVal *ancestor*, and thus its descendants must be subsequently visited to</span><span class="s2">\n   </span><span class="s1">* continue the </span><span class="s2">\&quot;</span><span class="s1">investigation</span><span class="s2">\&quot;</span><span class="s1">, then this method should return the relevant</span><span class="s2">\n   </span><span class="s1">* child key as a `string`. In some special cases, you additionally want to</span><span class="s2">\n   </span><span class="s1">* convey that this node should be treated as if it were parenthesized. In</span><span class="s2">\n   </span><span class="s1">* that case, a tuple of [key: string, parenthesized: boolean] is returned.</span><span class="s2">\n   </span><span class="s1">* The `string`-only return option is actually just a shorthand for:</span><span class="s2">\n   </span><span class="s1">* `[key: string, parenthesized: false]`.</span><span class="s2">\n   </span><span class="s1">*</span><span class="s2">\n   </span><span class="s1">* @param type A Node `type` string</span><span class="s2">\n   </span><span class="s1">* @param isUnparenthesizedInAssign</span><span class="s2">\n   </span><span class="s1">*        Whether the node in question is unparenthesized and its parent</span><span class="s2">\n   </span><span class="s1">*        is either an assignment pattern or an assignment expression.</span><span class="s2">\n   </span><span class="s1">* @param binding</span><span class="s2">\n   </span><span class="s1">*        The binding operation that is being considered for this potential</span><span class="s2">\n   </span><span class="s1">*        LVal.</span><span class="s2">\n   </span><span class="s1">* @returns `true` or `false` if we can immediately determine whether the node</span><span class="s2">\n   </span><span class="s1">*          type in question can be treated as an `LVal`.</span><span class="s2">\n   </span><span class="s1">*          A `string` key to traverse if we must check this child.</span><span class="s2">\n   </span><span class="s1">*          A `[string, boolean]` tuple if we need to check this child and</span><span class="s2">\n   </span><span class="s1">*          treat is as parenthesized.</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">isValidLVal(</span><span class="s2">\n    </span><span class="s1">type: string,</span><span class="s2">\n    </span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-unused-vars</span><span class="s2">\n    </span><span class="s1">isUnparenthesizedInAssign: boolean,</span><span class="s2">\n    </span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-unused-vars</span><span class="s2">\n    </span><span class="s1">binding: BindingTypes,</span><span class="s2">\n  </span><span class="s1">): string | boolean {</span><span class="s2">\n    </span><span class="s1">return getOwn(</span><span class="s2">\n      </span><span class="s1">{</span><span class="s2">\n        </span><span class="s1">AssignmentPattern: </span><span class="s2">\&quot;</span><span class="s1">left</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">RestElement: </span><span class="s2">\&quot;</span><span class="s1">argument</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">ObjectProperty: </span><span class="s2">\&quot;</span><span class="s1">value</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">ParenthesizedExpression: </span><span class="s2">\&quot;</span><span class="s1">expression</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">ArrayPattern: </span><span class="s2">\&quot;</span><span class="s1">elements</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">ObjectPattern: </span><span class="s2">\&quot;</span><span class="s1">properties</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">},</span><span class="s2">\n      </span><span class="s1">// @ts-expect-error refine string to enum</span><span class="s2">\n      </span><span class="s1">type,</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* Verify that a target expression is an lval (something that can be assigned to).</span><span class="s2">\n   </span><span class="s1">*</span><span class="s2">\n   </span><span class="s1">* @param expression The expression in question to check.</span><span class="s2">\n   </span><span class="s1">* @param options A set of options described below.</span><span class="s2">\n   </span><span class="s1">* @param options.in</span><span class="s2">\n   </span><span class="s1">*        The relevant ancestor to provide context information for the error</span><span class="s2">\n   </span><span class="s1">*        if the check fails.</span><span class="s2">\n   </span><span class="s1">* @param options.binding</span><span class="s2">\n   </span><span class="s1">*        The desired binding type. If the given expression is an identifier</span><span class="s2">\n   </span><span class="s1">*        and `binding` is not `BIND_NONE`, `checkLVal` will register binding</span><span class="s2">\n   </span><span class="s1">*        to the parser scope See also `src/util/scopeflags.js`</span><span class="s2">\n   </span><span class="s1">* @param options.checkClashes</span><span class="s2">\n   </span><span class="s1">*        An optional string set to check if an identifier name is included.</span><span class="s2">\n   </span><span class="s1">*        `checkLVal` will add checked identifier name to `checkClashes` It is</span><span class="s2">\n   </span><span class="s1">*        used in tracking duplicates in function parameter lists. If it is</span><span class="s2">\n   </span><span class="s1">*        false, `checkLVal` will skip duplicate checks</span><span class="s2">\n   </span><span class="s1">* @param options.strictModeChanged</span><span class="s2">\n   </span><span class="s1">*        Whether an identifier has been parsed in a sloppy context but should</span><span class="s2">\n   </span><span class="s1">*        be reinterpreted as strict-mode. e.g. `(arguments) =&gt; { </span><span class="s2">\&quot;</span><span class="s1">use strict </span><span class="s2">\&quot;</span><span class="s1">}`</span><span class="s2">\n   </span><span class="s1">* @param options.hasParenthesizedAncestor</span><span class="s2">\n   </span><span class="s1">*        This is only used internally during recursive calls, and you should</span><span class="s2">\n   </span><span class="s1">*        not have to set it yourself.</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n\n  </span><span class="s1">checkLVal(</span><span class="s2">\n    </span><span class="s1">expression: Expression | ObjectMember | RestElement,</span><span class="s2">\n    </span><span class="s1">{</span><span class="s2">\n      </span><span class="s1">in: ancestor,</span><span class="s2">\n      </span><span class="s1">binding = BIND_NONE,</span><span class="s2">\n      </span><span class="s1">checkClashes = false,</span><span class="s2">\n      </span><span class="s1">strictModeChanged = false,</span><span class="s2">\n      </span><span class="s1">hasParenthesizedAncestor = false,</span><span class="s2">\n    </span><span class="s1">}: {</span><span class="s2">\n      </span><span class="s1">in: LValAncestor;</span><span class="s2">\n      </span><span class="s1">binding?: BindingTypes;</span><span class="s2">\n      </span><span class="s1">checkClashes?: Set&lt;string&gt; | false;</span><span class="s2">\n      </span><span class="s1">strictModeChanged?: boolean;</span><span class="s2">\n      </span><span class="s1">hasParenthesizedAncestor?: boolean;</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n  </span><span class="s1">): void {</span><span class="s2">\n    </span><span class="s1">const type = expression.type;</span><span class="s2">\n\n    </span><span class="s1">// If we find here an ObjectMethod, it's because this was originally</span><span class="s2">\n    </span><span class="s1">// an ObjectExpression which has then been converted.</span><span class="s2">\n    </span><span class="s1">// toAssignable already reported this error with a nicer message.</span><span class="s2">\n    </span><span class="s1">if (this.isObjectMethod(expression)) return;</span><span class="s2">\n\n    </span><span class="s1">if (type === </span><span class="s2">\&quot;</span><span class="s1">MemberExpression</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">if (binding !== BIND_NONE) {</span><span class="s2">\n        </span><span class="s1">this.raise(Errors.InvalidPropertyBindingPattern, { at: expression });</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">if (type === </span><span class="s2">\&quot;</span><span class="s1">Identifier</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">this.checkIdentifier(</span><span class="s2">\n        </span><span class="s1">expression as Identifier,</span><span class="s2">\n        </span><span class="s1">binding,</span><span class="s2">\n        </span><span class="s1">strictModeChanged,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n\n      </span><span class="s1">const { name } = expression as Identifier;</span><span class="s2">\n\n      </span><span class="s1">if (checkClashes) {</span><span class="s2">\n        </span><span class="s1">if (checkClashes.has(name)) {</span><span class="s2">\n          </span><span class="s1">this.raise(Errors.ParamDupe, { at: expression });</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">checkClashes.add(name);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">const validity = this.isValidLVal(</span><span class="s2">\n      </span><span class="s1">type,</span><span class="s2">\n      </span><span class="s1">!(hasParenthesizedAncestor || expression.extra?.parenthesized) &amp;&amp;</span><span class="s2">\n        </span><span class="s1">ancestor.type === </span><span class="s2">\&quot;</span><span class="s1">AssignmentExpression</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">binding,</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n\n    </span><span class="s1">if (validity === true) return;</span><span class="s2">\n    </span><span class="s1">if (validity === false) {</span><span class="s2">\n      </span><span class="s1">const ParseErrorClass =</span><span class="s2">\n        </span><span class="s1">binding === BIND_NONE ? Errors.InvalidLhs : Errors.InvalidLhsBinding;</span><span class="s2">\n\n      </span><span class="s1">this.raise(ParseErrorClass, { at: expression, ancestor });</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">const [key, isParenthesizedExpression] = Array.isArray(validity)</span><span class="s2">\n      </span><span class="s1">? validity</span><span class="s2">\n      </span><span class="s1">: [validity, type === </span><span class="s2">\&quot;</span><span class="s1">ParenthesizedExpression</span><span class="s2">\&quot;</span><span class="s1">];</span><span class="s2">\n    </span><span class="s1">const nextAncestor =</span><span class="s2">\n      </span><span class="s1">type === </span><span class="s2">\&quot;</span><span class="s1">ArrayPattern</span><span class="s2">\&quot; </span><span class="s1">||</span><span class="s2">\n      </span><span class="s1">type === </span><span class="s2">\&quot;</span><span class="s1">ObjectPattern</span><span class="s2">\&quot; </span><span class="s1">||</span><span class="s2">\n      </span><span class="s1">type === </span><span class="s2">\&quot;</span><span class="s1">ParenthesizedExpression</span><span class="s2">\&quot;\n        </span><span class="s1">? ({ type } as const)</span><span class="s2">\n        </span><span class="s1">: ancestor;</span><span class="s2">\n\n    </span><span class="s1">// @ts-expect-error key may not index expression.</span><span class="s2">\n    </span><span class="s1">for (const child of [].concat(expression[key])) {</span><span class="s2">\n      </span><span class="s1">if (child) {</span><span class="s2">\n        </span><span class="s1">this.checkLVal(child, {</span><span class="s2">\n          </span><span class="s1">in: nextAncestor,</span><span class="s2">\n          </span><span class="s1">binding,</span><span class="s2">\n          </span><span class="s1">checkClashes,</span><span class="s2">\n          </span><span class="s1">strictModeChanged,</span><span class="s2">\n          </span><span class="s1">hasParenthesizedAncestor: isParenthesizedExpression,</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">checkIdentifier(</span><span class="s2">\n    </span><span class="s1">at: Identifier,</span><span class="s2">\n    </span><span class="s1">bindingType: BindingTypes,</span><span class="s2">\n    </span><span class="s1">strictModeChanged: boolean = false,</span><span class="s2">\n  </span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">if (</span><span class="s2">\n      </span><span class="s1">this.state.strict &amp;&amp;</span><span class="s2">\n      </span><span class="s1">(strictModeChanged</span><span class="s2">\n        </span><span class="s1">? isStrictBindReservedWord(at.name, this.inModule)</span><span class="s2">\n        </span><span class="s1">: isStrictBindOnlyReservedWord(at.name))</span><span class="s2">\n    </span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">if (bindingType === BIND_NONE) {</span><span class="s2">\n        </span><span class="s1">this.raise(Errors.StrictEvalArguments, { at, referenceName: at.name });</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">this.raise(Errors.StrictEvalArgumentsBinding, {</span><span class="s2">\n          </span><span class="s1">at,</span><span class="s2">\n          </span><span class="s1">bindingName: at.name,</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">if (bindingType &amp; BIND_FLAGS_NO_LET_IN_LEXICAL &amp;&amp; at.name === </span><span class="s2">\&quot;</span><span class="s1">let</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">this.raise(Errors.LetInLexicalBinding, { at });</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">if (!(bindingType &amp; BIND_NONE)) {</span><span class="s2">\n      </span><span class="s1">this.declareNameFromIdentifier(at, bindingType);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">declareNameFromIdentifier(identifier: Identifier, binding: BindingTypes) {</span><span class="s2">\n    </span><span class="s1">this.scope.declareName(identifier.name, binding, identifier.loc.start);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">checkToRestConversion(node: Node, allowPattern: boolean): void {</span><span class="s2">\n    </span><span class="s1">switch (node.type) {</span><span class="s2">\n      </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">ParenthesizedExpression</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n        </span><span class="s1">this.checkToRestConversion(node.expression, allowPattern);</span><span class="s2">\n        </span><span class="s1">break;</span><span class="s2">\n      </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">Identifier</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n      </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">MemberExpression</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n        </span><span class="s1">break;</span><span class="s2">\n      </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">ArrayExpression</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n      </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">ObjectExpression</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n        </span><span class="s1">if (allowPattern) break;</span><span class="s2">\n      </span><span class="s1">/* falls through */</span><span class="s2">\n      </span><span class="s1">default:</span><span class="s2">\n        </span><span class="s1">this.raise(Errors.InvalidRestAssignmentPattern, { at: node });</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">checkCommaAfterRest(</span><span class="s2">\n    </span><span class="s1">close: (typeof charCodes)[keyof typeof charCodes],</span><span class="s2">\n  </span><span class="s1">): boolean {</span><span class="s2">\n    </span><span class="s1">if (!this.match(tt.comma)) {</span><span class="s2">\n      </span><span class="s1">return false;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">this.raise(</span><span class="s2">\n      </span><span class="s1">this.lookaheadCharCode() === close</span><span class="s2">\n        </span><span class="s1">? Errors.RestTrailingComma</span><span class="s2">\n        </span><span class="s1">: Errors.ElementAfterRest,</span><span class="s2">\n      </span><span class="s1">{ at: this.state.startLoc },</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n\n    </span><span class="s1">return true;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">&quot;</span><span class="s2">,</span><span class="s1">&quot;/*:: declare var invariant; */</span><span class="s2">\n\n</span><span class="s1">import type State from </span><span class="s2">\&quot;</span><span class="s1">../../tokenizer/state</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import {</span><span class="s2">\n  </span><span class="s1">tokenIsIdentifier,</span><span class="s2">\n  </span><span class="s1">tokenIsTSDeclarationStart,</span><span class="s2">\n  </span><span class="s1">tokenIsTSTypeOperator,</span><span class="s2">\n  </span><span class="s1">tokenOperatorPrecedence,</span><span class="s2">\n  </span><span class="s1">tokenIsKeywordOrIdentifier,</span><span class="s2">\n  </span><span class="s1">tt,</span><span class="s2">\n  </span><span class="s1">type TokenType,</span><span class="s2">\n  </span><span class="s1">tokenIsTemplate,</span><span class="s2">\n  </span><span class="s1">tokenCanStartExpression,</span><span class="s2">\n</span><span class="s1">} from </span><span class="s2">\&quot;</span><span class="s1">../../tokenizer/types</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import { types as tc } from </span><span class="s2">\&quot;</span><span class="s1">../../tokenizer/context</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type * as N from </span><span class="s2">\&quot;</span><span class="s1">../../types</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type { Position } from </span><span class="s2">\&quot;</span><span class="s1">../../util/location</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import { createPositionWithColumnOffset } from </span><span class="s2">\&quot;</span><span class="s1">../../util/location</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type Parser from </span><span class="s2">\&quot;</span><span class="s1">../../parser</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import {</span><span class="s2">\n  </span><span class="s1">type BindingTypes,</span><span class="s2">\n  </span><span class="s1">SCOPE_TS_MODULE,</span><span class="s2">\n  </span><span class="s1">SCOPE_OTHER,</span><span class="s2">\n  </span><span class="s1">BIND_TS_ENUM,</span><span class="s2">\n  </span><span class="s1">BIND_TS_CONST_ENUM,</span><span class="s2">\n  </span><span class="s1">BIND_TS_TYPE,</span><span class="s2">\n  </span><span class="s1">BIND_TS_INTERFACE,</span><span class="s2">\n  </span><span class="s1">BIND_TS_AMBIENT,</span><span class="s2">\n  </span><span class="s1">BIND_TS_NAMESPACE,</span><span class="s2">\n  </span><span class="s1">BIND_TS_TYPE_IMPORT,</span><span class="s2">\n  </span><span class="s1">BIND_CLASS,</span><span class="s2">\n  </span><span class="s1">BIND_NONE,</span><span class="s2">\n  </span><span class="s1">BIND_FLAGS_TS_IMPORT,</span><span class="s2">\n</span><span class="s1">} from </span><span class="s2">\&quot;</span><span class="s1">../../util/scopeflags</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import TypeScriptScopeHandler from </span><span class="s2">\&quot;</span><span class="s1">./scope</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import * as charCodes from </span><span class="s2">\&quot;</span><span class="s1">charcodes</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type { ExpressionErrors } from </span><span class="s2">\&quot;</span><span class="s1">../../parser/util</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type { ParseStatementFlag } from </span><span class="s2">\&quot;</span><span class="s1">../../parser/statement</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import { PARAM } from </span><span class="s2">\&quot;</span><span class="s1">../../util/production-parameter</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import { Errors, ParseErrorEnum } from </span><span class="s2">\&quot;</span><span class="s1">../../parse-error</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import { cloneIdentifier, type Undone } from </span><span class="s2">\&quot;</span><span class="s1">../../parser/node</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type { Pattern } from </span><span class="s2">\&quot;</span><span class="s1">../../types</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type { Expression } from </span><span class="s2">\&quot;</span><span class="s1">../../types</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type { IJSXParserMixin } from </span><span class="s2">\&quot;</span><span class="s1">../jsx</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import { ParseBindingListFlags } from </span><span class="s2">\&quot;</span><span class="s1">../../parser/lval</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">const getOwn = &lt;T extends {}&gt;(object: T, key: keyof T) =&gt;</span><span class="s2">\n  </span><span class="s1">Object.hasOwnProperty.call(object, key) &amp;&amp; object[key];</span><span class="s2">\n\n</span><span class="s1">type TsModifier =</span><span class="s2">\n  </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">readonly</span><span class="s2">\&quot;\n  </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">abstract</span><span class="s2">\&quot;\n  </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">declare</span><span class="s2">\&quot;\n  </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">static</span><span class="s2">\&quot;\n  </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">override</span><span class="s2">\&quot;\n  </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">const</span><span class="s2">\&quot;\n  </span><span class="s1">| N.Accessibility</span><span class="s2">\n  </span><span class="s1">| N.VarianceAnnotations;</span><span class="s2">\n\n</span><span class="s1">function nonNull&lt;T&gt;(x?: T | null): T {</span><span class="s2">\n  </span><span class="s1">if (x == null) {</span><span class="s2">\n    </span><span class="s1">throw new Error(`Unexpected ${x} value.`);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return x;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function assert(x: boolean): void {</span><span class="s2">\n  </span><span class="s1">if (!x) {</span><span class="s2">\n    </span><span class="s1">throw new Error(</span><span class="s2">\&quot;</span><span class="s1">Assert fail</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">type ParsingContext =</span><span class="s2">\n  </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">EnumMembers</span><span class="s2">\&quot;\n  </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">HeritageClauseElement</span><span class="s2">\&quot;\n  </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">TupleElementTypes</span><span class="s2">\&quot;\n  </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">TypeMembers</span><span class="s2">\&quot;\n  </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">TypeParametersOrArguments</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">type ModifierBase = {</span><span class="s2">\n  </span><span class="s1">accessibility?: N.Accessibility;</span><span class="s2">\n</span><span class="s1">} &amp; {</span><span class="s2">\n  </span><span class="s1">[key in TsModifier]?: boolean | undefined | null;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">/* eslint sort-keys: </span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot; </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const TSErrors = ParseErrorEnum`typescript`({</span><span class="s2">\n  </span><span class="s1">AbstractMethodHasImplementation: ({ methodName }: { methodName: string }) =&gt;</span><span class="s2">\n    </span><span class="s1">`Method '${methodName}' cannot have an implementation because it is marked abstract.`,</span><span class="s2">\n  </span><span class="s1">AbstractPropertyHasInitializer: ({</span><span class="s2">\n    </span><span class="s1">propertyName,</span><span class="s2">\n  </span><span class="s1">}: {</span><span class="s2">\n    </span><span class="s1">propertyName: string;</span><span class="s2">\n  </span><span class="s1">}) =&gt;</span><span class="s2">\n    </span><span class="s1">`Property '${propertyName}' cannot have an initializer because it is marked abstract.`,</span><span class="s2">\n  </span><span class="s1">AccesorCannotDeclareThisParameter:</span><span class="s2">\n    \&quot;</span><span class="s1">'get' and 'set' accessors cannot declare 'this' parameters.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">AccesorCannotHaveTypeParameters: </span><span class="s2">\&quot;</span><span class="s1">An accessor cannot have type parameters.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">AccessorCannotBeOptional:</span><span class="s2">\n    \&quot;</span><span class="s1">An 'accessor' property cannot be declared optional.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ClassMethodHasDeclare: </span><span class="s2">\&quot;</span><span class="s1">Class methods cannot have the 'declare' modifier.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ClassMethodHasReadonly: </span><span class="s2">\&quot;</span><span class="s1">Class methods cannot have the 'readonly' modifier.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference:</span><span class="s2">\n    \&quot;</span><span class="s1">A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ConstructorHasTypeParameters:</span><span class="s2">\n    \&quot;</span><span class="s1">Type parameters cannot appear on a constructor declaration.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">DeclareAccessor: ({ kind }: { kind: </span><span class="s2">\&quot;</span><span class="s1">get</span><span class="s2">\&quot; </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">set</span><span class="s2">\&quot; </span><span class="s1">}) =&gt;</span><span class="s2">\n    </span><span class="s1">`'declare' is not allowed in ${kind}ters.`,</span><span class="s2">\n  </span><span class="s1">DeclareClassFieldHasInitializer:</span><span class="s2">\n    \&quot;</span><span class="s1">Initializers are not allowed in ambient contexts.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">DeclareFunctionHasImplementation:</span><span class="s2">\n    \&quot;</span><span class="s1">An implementation cannot be declared in ambient contexts.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">DuplicateAccessibilityModifier:</span><span class="s2">\n    </span><span class="s1">// `Accessibility modifier already seen: ${modifier}` would be more helpful.</span><span class="s2">\n    </span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-unused-vars</span><span class="s2">\n    </span><span class="s1">({ modifier }: { modifier: N.Accessibility }) =&gt;</span><span class="s2">\n      </span><span class="s1">`Accessibility modifier already seen.`,</span><span class="s2">\n  </span><span class="s1">DuplicateModifier: ({ modifier }: { modifier: TsModifier }) =&gt;</span><span class="s2">\n    </span><span class="s1">`Duplicate modifier: '${modifier}'.`,</span><span class="s2">\n  </span><span class="s1">// `token` matches the terminology used by typescript:</span><span class="s2">\n  </span><span class="s1">// https://github.com/microsoft/TypeScript/blob/main/src/compiler/types.ts#L2915</span><span class="s2">\n  </span><span class="s1">EmptyHeritageClauseType: ({ token }: { token: </span><span class="s2">\&quot;</span><span class="s1">extends</span><span class="s2">\&quot; </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">implements</span><span class="s2">\&quot; </span><span class="s1">}) =&gt;</span><span class="s2">\n    </span><span class="s1">`'${token}' list cannot be empty.`,</span><span class="s2">\n  </span><span class="s1">EmptyTypeArguments: </span><span class="s2">\&quot;</span><span class="s1">Type argument list cannot be empty.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">EmptyTypeParameters: </span><span class="s2">\&quot;</span><span class="s1">Type parameter list cannot be empty.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ExpectedAmbientAfterExportDeclare:</span><span class="s2">\n    \&quot;</span><span class="s1">'export declare' must be followed by an ambient declaration.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ImportAliasHasImportType: </span><span class="s2">\&quot;</span><span class="s1">An import alias can not use 'import type'.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ImportReflectionHasImportType:</span><span class="s2">\n    \&quot;</span><span class="s1">An `import module` declaration can not use `type` modifier</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">IncompatibleModifiers: ({</span><span class="s2">\n    </span><span class="s1">modifiers,</span><span class="s2">\n  </span><span class="s1">}: {</span><span class="s2">\n    </span><span class="s1">modifiers: [TsModifier, TsModifier];</span><span class="s2">\n  </span><span class="s1">}) =&gt;</span><span class="s2">\n    </span><span class="s1">`'${modifiers[0]}' modifier cannot be used with '${modifiers[1]}' modifier.`,</span><span class="s2">\n  </span><span class="s1">IndexSignatureHasAbstract:</span><span class="s2">\n    \&quot;</span><span class="s1">Index signatures cannot have the 'abstract' modifier.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">IndexSignatureHasAccessibility: ({</span><span class="s2">\n    </span><span class="s1">modifier,</span><span class="s2">\n  </span><span class="s1">}: {</span><span class="s2">\n    </span><span class="s1">modifier: N.Accessibility;</span><span class="s2">\n  </span><span class="s1">}) =&gt;</span><span class="s2">\n    </span><span class="s1">`Index signatures cannot have an accessibility modifier ('${modifier}').`,</span><span class="s2">\n  </span><span class="s1">IndexSignatureHasDeclare:</span><span class="s2">\n    \&quot;</span><span class="s1">Index signatures cannot have the 'declare' modifier.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">IndexSignatureHasOverride:</span><span class="s2">\n    \&quot;</span><span class="s1">'override' modifier cannot appear on an index signature.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">IndexSignatureHasStatic:</span><span class="s2">\n    \&quot;</span><span class="s1">Index signatures cannot have the 'static' modifier.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">InitializerNotAllowedInAmbientContext:</span><span class="s2">\n    \&quot;</span><span class="s1">Initializers are not allowed in ambient contexts.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">InvalidModifierOnTypeMember: ({ modifier }: { modifier: TsModifier }) =&gt;</span><span class="s2">\n    </span><span class="s1">`'${modifier}' modifier cannot appear on a type member.`,</span><span class="s2">\n  </span><span class="s1">InvalidModifierOnTypeParameter: ({ modifier }: { modifier: TsModifier }) =&gt;</span><span class="s2">\n    </span><span class="s1">`'${modifier}' modifier cannot appear on a type parameter.`,</span><span class="s2">\n  </span><span class="s1">InvalidModifierOnTypeParameterPositions: ({</span><span class="s2">\n    </span><span class="s1">modifier,</span><span class="s2">\n  </span><span class="s1">}: {</span><span class="s2">\n    </span><span class="s1">modifier: TsModifier;</span><span class="s2">\n  </span><span class="s1">}) =&gt;</span><span class="s2">\n    </span><span class="s1">`'${modifier}' modifier can only appear on a type parameter of a class, interface or type alias.`,</span><span class="s2">\n  </span><span class="s1">InvalidModifiersOrder: ({</span><span class="s2">\n    </span><span class="s1">orderedModifiers,</span><span class="s2">\n  </span><span class="s1">}: {</span><span class="s2">\n    </span><span class="s1">orderedModifiers: [TsModifier, TsModifier];</span><span class="s2">\n  </span><span class="s1">}) =&gt;</span><span class="s2">\n    </span><span class="s1">`'${orderedModifiers[0]}' modifier must precede '${orderedModifiers[1]}' modifier.`,</span><span class="s2">\n  </span><span class="s1">InvalidPropertyAccessAfterInstantiationExpression:</span><span class="s2">\n    \&quot;</span><span class="s1">Invalid property access after an instantiation expression. </span><span class="s2">\&quot; </span><span class="s1">+</span><span class="s2">\n    \&quot;</span><span class="s1">You can either wrap the instantiation expression in parentheses, or delete the type arguments.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">InvalidTupleMemberLabel:</span><span class="s2">\n    \&quot;</span><span class="s1">Tuple members must be labeled with a simple identifier.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">MissingInterfaceName:</span><span class="s2">\n    \&quot;</span><span class="s1">'interface' declarations must be followed by an identifier.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">MixedLabeledAndUnlabeledElements:</span><span class="s2">\n    \&quot;</span><span class="s1">Tuple members must all have names or all not have names.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">NonAbstractClassHasAbstractMethod:</span><span class="s2">\n    \&quot;</span><span class="s1">Abstract methods can only appear within an abstract class.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">NonClassMethodPropertyHasAbstractModifer:</span><span class="s2">\n    \&quot;</span><span class="s1">'abstract' modifier can only appear on a class, method, or property declaration.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">OptionalTypeBeforeRequired:</span><span class="s2">\n    \&quot;</span><span class="s1">A required element cannot follow an optional element.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">OverrideNotInSubClass:</span><span class="s2">\n    \&quot;</span><span class="s1">This member cannot have an 'override' modifier because its containing class does not extend another class.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">PatternIsOptional:</span><span class="s2">\n    \&quot;</span><span class="s1">A binding pattern parameter cannot be optional in an implementation signature.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">PrivateElementHasAbstract:</span><span class="s2">\n    \&quot;</span><span class="s1">Private elements cannot have the 'abstract' modifier.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">PrivateElementHasAccessibility: ({</span><span class="s2">\n    </span><span class="s1">modifier,</span><span class="s2">\n  </span><span class="s1">}: {</span><span class="s2">\n    </span><span class="s1">modifier: N.Accessibility;</span><span class="s2">\n  </span><span class="s1">}) =&gt;</span><span class="s2">\n    </span><span class="s1">`Private elements cannot have an accessibility modifier ('${modifier}').`,</span><span class="s2">\n  </span><span class="s1">ReadonlyForMethodSignature:</span><span class="s2">\n    \&quot;</span><span class="s1">'readonly' modifier can only appear on a property declaration or index signature.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ReservedArrowTypeParam:</span><span class="s2">\n    \&quot;</span><span class="s1">This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `&lt;T,&gt;() =&gt; ...`.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">ReservedTypeAssertion:</span><span class="s2">\n    \&quot;</span><span class="s1">This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">// TODO: Accesor -&gt; Accessor</span><span class="s2">\n  </span><span class="s1">SetAccesorCannotHaveOptionalParameter:</span><span class="s2">\n    \&quot;</span><span class="s1">A 'set' accessor cannot have an optional parameter.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">SetAccesorCannotHaveRestParameter:</span><span class="s2">\n    \&quot;</span><span class="s1">A 'set' accessor cannot have rest parameter.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">SetAccesorCannotHaveReturnType:</span><span class="s2">\n    \&quot;</span><span class="s1">A 'set' accessor cannot have a return type annotation.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">SingleTypeParameterWithoutTrailingComma: ({</span><span class="s2">\n    </span><span class="s1">typeParameterName,</span><span class="s2">\n  </span><span class="s1">}: {</span><span class="s2">\n    </span><span class="s1">typeParameterName: string;</span><span class="s2">\n  </span><span class="s1">}) =&gt;</span><span class="s2">\n    </span><span class="s1">`Single type parameter ${typeParameterName} should have a trailing comma. Example usage: &lt;${typeParameterName},&gt;.`,</span><span class="s2">\n  </span><span class="s1">StaticBlockCannotHaveModifier:</span><span class="s2">\n    \&quot;</span><span class="s1">Static class blocks cannot have any modifier.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">TupleOptionalAfterType:</span><span class="s2">\n    \&quot;</span><span class="s1">A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">TypeAnnotationAfterAssign:</span><span class="s2">\n    \&quot;</span><span class="s1">Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">TypeImportCannotSpecifyDefaultAndNamed:</span><span class="s2">\n    \&quot;</span><span class="s1">A type-only import can specify a default import or named bindings, but not both.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">TypeModifierIsUsedInTypeExports:</span><span class="s2">\n    \&quot;</span><span class="s1">The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">TypeModifierIsUsedInTypeImports:</span><span class="s2">\n    \&quot;</span><span class="s1">The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">UnexpectedParameterModifier:</span><span class="s2">\n    \&quot;</span><span class="s1">A parameter property is only allowed in a constructor implementation.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">UnexpectedReadonly:</span><span class="s2">\n    \&quot;</span><span class="s1">'readonly' type modifier is only permitted on array and tuple literal types.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">UnexpectedTypeAnnotation: </span><span class="s2">\&quot;</span><span class="s1">Did not expect a type annotation here.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">UnexpectedTypeCastInParameter: </span><span class="s2">\&quot;</span><span class="s1">Unexpected type cast in parameter position.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">UnsupportedImportTypeArgument:</span><span class="s2">\n    \&quot;</span><span class="s1">Argument in a type import must be a string literal.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">UnsupportedParameterPropertyKind:</span><span class="s2">\n    \&quot;</span><span class="s1">A parameter property may not be declared using a binding pattern.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">UnsupportedSignatureParameterKind: ({ type }: { type: string }) =&gt;</span><span class="s2">\n    </span><span class="s1">`Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${type}.`,</span><span class="s2">\n</span><span class="s1">});</span><span class="s2">\n\n</span><span class="s1">/* eslint-disable sort-keys */</span><span class="s2">\n\n</span><span class="s1">// Doesn't handle </span><span class="s2">\&quot;</span><span class="s1">void</span><span class="s2">\&quot; </span><span class="s1">or </span><span class="s2">\&quot;</span><span class="s1">null</span><span class="s2">\&quot; </span><span class="s1">because those are keywords, not identifiers.</span><span class="s2">\n</span><span class="s1">// It also doesn't handle </span><span class="s2">\&quot;</span><span class="s1">intrinsic</span><span class="s2">\&quot;</span><span class="s1">, since usually it's not a keyword.</span><span class="s2">\n</span><span class="s1">function keywordTypeFromName(value: string): N.TsKeywordTypeType | undefined {</span><span class="s2">\n  </span><span class="s1">switch (value) {</span><span class="s2">\n    </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">any</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n      </span><span class="s1">return </span><span class="s2">\&quot;</span><span class="s1">TSAnyKeyword</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">boolean</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n      </span><span class="s1">return </span><span class="s2">\&quot;</span><span class="s1">TSBooleanKeyword</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">bigint</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n      </span><span class="s1">return </span><span class="s2">\&quot;</span><span class="s1">TSBigIntKeyword</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">never</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n      </span><span class="s1">return </span><span class="s2">\&quot;</span><span class="s1">TSNeverKeyword</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">number</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n      </span><span class="s1">return </span><span class="s2">\&quot;</span><span class="s1">TSNumberKeyword</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">object</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n      </span><span class="s1">return </span><span class="s2">\&quot;</span><span class="s1">TSObjectKeyword</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n      </span><span class="s1">return </span><span class="s2">\&quot;</span><span class="s1">TSStringKeyword</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">symbol</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n      </span><span class="s1">return </span><span class="s2">\&quot;</span><span class="s1">TSSymbolKeyword</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">undefined</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n      </span><span class="s1">return </span><span class="s2">\&quot;</span><span class="s1">TSUndefinedKeyword</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">unknown</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n      </span><span class="s1">return </span><span class="s2">\&quot;</span><span class="s1">TSUnknownKeyword</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">default:</span><span class="s2">\n      </span><span class="s1">return undefined;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function tsIsAccessModifier(modifier: string): modifier is N.Accessibility {</span><span class="s2">\n  </span><span class="s1">return (</span><span class="s2">\n    </span><span class="s1">modifier === </span><span class="s2">\&quot;</span><span class="s1">private</span><span class="s2">\&quot; </span><span class="s1">|| modifier === </span><span class="s2">\&quot;</span><span class="s1">public</span><span class="s2">\&quot; </span><span class="s1">|| modifier === </span><span class="s2">\&quot;</span><span class="s1">protected</span><span class="s2">\&quot;\n  </span><span class="s1">);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function tsIsVarianceAnnotations(</span><span class="s2">\n  </span><span class="s1">modifier: string,</span><span class="s2">\n</span><span class="s1">): modifier is N.VarianceAnnotations {</span><span class="s2">\n  </span><span class="s1">return modifier === </span><span class="s2">\&quot;</span><span class="s1">in</span><span class="s2">\&quot; </span><span class="s1">|| modifier === </span><span class="s2">\&quot;</span><span class="s1">out</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">type ClassWithMixin&lt;</span><span class="s2">\n  </span><span class="s1">T extends new (...args: any) =&gt; any,</span><span class="s2">\n  </span><span class="s1">M extends object,</span><span class="s2">\n</span><span class="s1">&gt; = T extends new (...args: infer P) =&gt; infer I</span><span class="s2">\n  </span><span class="s1">? new (...args: P) =&gt; I &amp; M</span><span class="s2">\n  </span><span class="s1">: never;</span><span class="s2">\n\n</span><span class="s1">export default (superClass: ClassWithMixin&lt;typeof Parser, IJSXParserMixin&gt;) =&gt;</span><span class="s2">\n  </span><span class="s1">class TypeScriptParserMixin extends superClass implements Parser {</span><span class="s2">\n    </span><span class="s1">getScopeHandler(): {</span><span class="s2">\n      </span><span class="s1">new (...args: any): TypeScriptScopeHandler;</span><span class="s2">\n    </span><span class="s1">} {</span><span class="s2">\n      </span><span class="s1">return TypeScriptScopeHandler;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsIsIdentifier(): boolean {</span><span class="s2">\n      </span><span class="s1">// TODO: actually a bit more complex in TypeScript, but shouldn't matter.</span><span class="s2">\n      </span><span class="s1">// See https://github.com/Microsoft/TypeScript/issues/15008</span><span class="s2">\n      </span><span class="s1">return tokenIsIdentifier(this.state.type);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsTokenCanFollowModifier() {</span><span class="s2">\n      </span><span class="s1">return (</span><span class="s2">\n        </span><span class="s1">(this.match(tt.bracketL) ||</span><span class="s2">\n          </span><span class="s1">this.match(tt.braceL) ||</span><span class="s2">\n          </span><span class="s1">this.match(tt.star) ||</span><span class="s2">\n          </span><span class="s1">this.match(tt.ellipsis) ||</span><span class="s2">\n          </span><span class="s1">this.match(tt.privateName) ||</span><span class="s2">\n          </span><span class="s1">this.isLiteralPropertyName()) &amp;&amp;</span><span class="s2">\n        </span><span class="s1">!this.hasPrecedingLineBreak()</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsNextTokenCanFollowModifier() {</span><span class="s2">\n      </span><span class="s1">// Note: TypeScript's implementation is much more complicated because</span><span class="s2">\n      </span><span class="s1">// more things are considered modifiers there.</span><span class="s2">\n      </span><span class="s1">// This implementation only handles modifiers not handled by @babel/parser itself. And </span><span class="s2">\&quot;</span><span class="s1">static</span><span class="s2">\&quot;</span><span class="s1">.</span><span class="s2">\n      </span><span class="s1">// TODO: Would be nice to avoid lookahead. Want a hasLineBreakUpNext() method...</span><span class="s2">\n      </span><span class="s1">this.next();</span><span class="s2">\n      </span><span class="s1">return this.tsTokenCanFollowModifier();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">/** Parses a modifier matching one the given modifier names. */</span><span class="s2">\n    </span><span class="s1">tsParseModifier&lt;T extends TsModifier&gt;(</span><span class="s2">\n      </span><span class="s1">allowedModifiers: T[],</span><span class="s2">\n      </span><span class="s1">stopOnStartOfClassStaticBlock?: boolean,</span><span class="s2">\n    </span><span class="s1">): T | undefined | null {</span><span class="s2">\n      </span><span class="s1">if (</span><span class="s2">\n        </span><span class="s1">!tokenIsIdentifier(this.state.type) &amp;&amp;</span><span class="s2">\n        </span><span class="s1">this.state.type !== tt._in &amp;&amp;</span><span class="s2">\n        </span><span class="s1">this.state.type !== tt._const</span><span class="s2">\n      </span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">return undefined;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">const modifier = this.state.value;</span><span class="s2">\n      </span><span class="s1">if (allowedModifiers.indexOf(modifier) !== -1) {</span><span class="s2">\n        </span><span class="s1">if (stopOnStartOfClassStaticBlock &amp;&amp; this.tsIsStartOfStaticBlocks()) {</span><span class="s2">\n          </span><span class="s1">return undefined;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {</span><span class="s2">\n          </span><span class="s1">return modifier;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return undefined;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">/** Parses a list of modifiers, in any order.</span><span class="s2">\n     </span><span class="s1">*  If you need a specific order, you must call this function multiple times:</span><span class="s2">\n     </span><span class="s1">*    this.tsParseModifiers({ modified: node, allowedModifiers: [</span><span class="s2">\&quot;</span><span class="s1">public</span><span class="s2">\&quot;</span><span class="s1">] });</span><span class="s2">\n     </span><span class="s1">*    this.tsParseModifiers({ modified: node, allowedModifiers: [</span><span class="s2">\&quot;</span><span class="s1">abstract</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">readonly</span><span class="s2">\&quot;</span><span class="s1">] });</span><span class="s2">\n     </span><span class="s1">*/</span><span class="s2">\n    </span><span class="s1">tsParseModifiers&lt;N extends ModifierBase&gt;(</span><span class="s2">\n      </span><span class="s1">{</span><span class="s2">\n        </span><span class="s1">allowedModifiers,</span><span class="s2">\n        </span><span class="s1">disallowedModifiers,</span><span class="s2">\n        </span><span class="s1">stopOnStartOfClassStaticBlock,</span><span class="s2">\n        </span><span class="s1">errorTemplate = TSErrors.InvalidModifierOnTypeMember,</span><span class="s2">\n      </span><span class="s1">}: {</span><span class="s2">\n        </span><span class="s1">allowedModifiers: readonly TsModifier[];</span><span class="s2">\n        </span><span class="s1">disallowedModifiers?: TsModifier[];</span><span class="s2">\n        </span><span class="s1">stopOnStartOfClassStaticBlock?: boolean;</span><span class="s2">\n        </span><span class="s1">errorTemplate?: typeof TSErrors.InvalidModifierOnTypeMember;</span><span class="s2">\n      </span><span class="s1">},</span><span class="s2">\n      </span><span class="s1">modified: N,</span><span class="s2">\n    </span><span class="s1">): void {</span><span class="s2">\n      </span><span class="s1">const enforceOrder = (</span><span class="s2">\n        </span><span class="s1">loc: Position,</span><span class="s2">\n        </span><span class="s1">modifier: TsModifier,</span><span class="s2">\n        </span><span class="s1">before: TsModifier,</span><span class="s2">\n        </span><span class="s1">after: TsModifier,</span><span class="s2">\n      </span><span class="s1">) =&gt; {</span><span class="s2">\n        </span><span class="s1">if (modifier === before &amp;&amp; modified[after]) {</span><span class="s2">\n          </span><span class="s1">this.raise(TSErrors.InvalidModifiersOrder, {</span><span class="s2">\n            </span><span class="s1">at: loc,</span><span class="s2">\n            </span><span class="s1">orderedModifiers: [before, after],</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">const incompatible = (</span><span class="s2">\n        </span><span class="s1">loc: Position,</span><span class="s2">\n        </span><span class="s1">modifier: TsModifier,</span><span class="s2">\n        </span><span class="s1">mod1: TsModifier,</span><span class="s2">\n        </span><span class="s1">mod2: TsModifier,</span><span class="s2">\n      </span><span class="s1">) =&gt; {</span><span class="s2">\n        </span><span class="s1">if (</span><span class="s2">\n          </span><span class="s1">(modified[mod1] &amp;&amp; modifier === mod2) ||</span><span class="s2">\n          </span><span class="s1">(modified[mod2] &amp;&amp; modifier === mod1)</span><span class="s2">\n        </span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">this.raise(TSErrors.IncompatibleModifiers, {</span><span class="s2">\n            </span><span class="s1">at: loc,</span><span class="s2">\n            </span><span class="s1">modifiers: [mod1, mod2],</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n\n      </span><span class="s1">for (;;) {</span><span class="s2">\n        </span><span class="s1">const { startLoc } = this.state;</span><span class="s2">\n        </span><span class="s1">const modifier: TsModifier | undefined | null = this.tsParseModifier(</span><span class="s2">\n          </span><span class="s1">allowedModifiers.concat(disallowedModifiers ?? []),</span><span class="s2">\n          </span><span class="s1">stopOnStartOfClassStaticBlock,</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n\n        </span><span class="s1">if (!modifier) break;</span><span class="s2">\n\n        </span><span class="s1">if (tsIsAccessModifier(modifier)) {</span><span class="s2">\n          </span><span class="s1">if (modified.accessibility) {</span><span class="s2">\n            </span><span class="s1">this.raise(TSErrors.DuplicateAccessibilityModifier, {</span><span class="s2">\n              </span><span class="s1">at: startLoc,</span><span class="s2">\n              </span><span class="s1">modifier,</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n          </span><span class="s1">} else {</span><span class="s2">\n            </span><span class="s1">enforceOrder(startLoc, modifier, modifier, </span><span class="s2">\&quot;</span><span class="s1">override</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n            </span><span class="s1">enforceOrder(startLoc, modifier, modifier, </span><span class="s2">\&quot;</span><span class="s1">static</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n            </span><span class="s1">enforceOrder(startLoc, modifier, modifier, </span><span class="s2">\&quot;</span><span class="s1">readonly</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n\n            </span><span class="s1">modified.accessibility = modifier;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">} else if (tsIsVarianceAnnotations(modifier)) {</span><span class="s2">\n          </span><span class="s1">if (modified[modifier]) {</span><span class="s2">\n            </span><span class="s1">this.raise(TSErrors.DuplicateModifier, { at: startLoc, modifier });</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">modified[modifier] = true;</span><span class="s2">\n\n          </span><span class="s1">enforceOrder(startLoc, modifier, </span><span class="s2">\&quot;</span><span class="s1">in</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">out</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">if (Object.hasOwnProperty.call(modified, modifier)) {</span><span class="s2">\n            </span><span class="s1">this.raise(TSErrors.DuplicateModifier, { at: startLoc, modifier });</span><span class="s2">\n          </span><span class="s1">} else {</span><span class="s2">\n            </span><span class="s1">enforceOrder(startLoc, modifier, </span><span class="s2">\&quot;</span><span class="s1">static</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">readonly</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n            </span><span class="s1">enforceOrder(startLoc, modifier, </span><span class="s2">\&quot;</span><span class="s1">static</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">override</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n            </span><span class="s1">enforceOrder(startLoc, modifier, </span><span class="s2">\&quot;</span><span class="s1">override</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">readonly</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n            </span><span class="s1">enforceOrder(startLoc, modifier, </span><span class="s2">\&quot;</span><span class="s1">abstract</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">override</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n\n            </span><span class="s1">incompatible(startLoc, modifier, </span><span class="s2">\&quot;</span><span class="s1">declare</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">override</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n            </span><span class="s1">incompatible(startLoc, modifier, </span><span class="s2">\&quot;</span><span class="s1">static</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">abstract</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">modified[modifier] = true;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">if (disallowedModifiers?.includes(modifier)) {</span><span class="s2">\n          </span><span class="s1">this.raise(errorTemplate, {</span><span class="s2">\n            </span><span class="s1">at: startLoc,</span><span class="s2">\n            </span><span class="s1">modifier,</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsIsListTerminator(kind: ParsingContext): boolean {</span><span class="s2">\n      </span><span class="s1">switch (kind) {</span><span class="s2">\n        </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">EnumMembers</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n        </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">TypeMembers</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n          </span><span class="s1">return this.match(tt.braceR);</span><span class="s2">\n        </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">HeritageClauseElement</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n          </span><span class="s1">return this.match(tt.braceL);</span><span class="s2">\n        </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">TupleElementTypes</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n          </span><span class="s1">return this.match(tt.bracketR);</span><span class="s2">\n        </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">TypeParametersOrArguments</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n          </span><span class="s1">return this.match(tt.gt);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsParseList&lt;T extends N.Node&gt;(</span><span class="s2">\n      </span><span class="s1">kind: ParsingContext,</span><span class="s2">\n      </span><span class="s1">parseElement: () =&gt; T,</span><span class="s2">\n    </span><span class="s1">): T[] {</span><span class="s2">\n      </span><span class="s1">const result: T[] = [];</span><span class="s2">\n      </span><span class="s1">while (!this.tsIsListTerminator(kind)) {</span><span class="s2">\n        </span><span class="s1">// Skipping </span><span class="s2">\&quot;</span><span class="s1">parseListElement</span><span class="s2">\&quot; </span><span class="s1">from the TS source since that's just for error handling.</span><span class="s2">\n        </span><span class="s1">result.push(parseElement());</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return result;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsParseDelimitedList&lt;T extends N.Node&gt;(</span><span class="s2">\n      </span><span class="s1">kind: ParsingContext,</span><span class="s2">\n      </span><span class="s1">parseElement: () =&gt; T,</span><span class="s2">\n      </span><span class="s1">refTrailingCommaPos?: {</span><span class="s2">\n        </span><span class="s1">value: number;</span><span class="s2">\n      </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">): T[] {</span><span class="s2">\n      </span><span class="s1">return nonNull(</span><span class="s2">\n        </span><span class="s1">this.tsParseDelimitedListWorker(</span><span class="s2">\n          </span><span class="s1">kind,</span><span class="s2">\n          </span><span class="s1">parseElement,</span><span class="s2">\n          </span><span class="s1">/* expectSuccess */ true,</span><span class="s2">\n          </span><span class="s1">refTrailingCommaPos,</span><span class="s2">\n        </span><span class="s1">),</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">/**</span><span class="s2">\n     </span><span class="s1">* If !expectSuccess, returns undefined instead of failing to parse.</span><span class="s2">\n     </span><span class="s1">* If expectSuccess, parseElement should always return a defined value.</span><span class="s2">\n     </span><span class="s1">*/</span><span class="s2">\n    </span><span class="s1">tsParseDelimitedListWorker&lt;T extends N.Node&gt;(</span><span class="s2">\n      </span><span class="s1">kind: ParsingContext,</span><span class="s2">\n      </span><span class="s1">parseElement: () =&gt; T | undefined | null,</span><span class="s2">\n      </span><span class="s1">expectSuccess: boolean,</span><span class="s2">\n      </span><span class="s1">refTrailingCommaPos?: {</span><span class="s2">\n        </span><span class="s1">value: number;</span><span class="s2">\n      </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">): T[] | undefined | null {</span><span class="s2">\n      </span><span class="s1">const result = [];</span><span class="s2">\n      </span><span class="s1">let trailingCommaPos = -1;</span><span class="s2">\n\n      </span><span class="s1">for (;;) {</span><span class="s2">\n        </span><span class="s1">if (this.tsIsListTerminator(kind)) {</span><span class="s2">\n          </span><span class="s1">break;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">trailingCommaPos = -1;</span><span class="s2">\n\n        </span><span class="s1">const element = parseElement();</span><span class="s2">\n        </span><span class="s1">if (element == null) {</span><span class="s2">\n          </span><span class="s1">return undefined;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">result.push(element);</span><span class="s2">\n\n        </span><span class="s1">if (this.eat(tt.comma)) {</span><span class="s2">\n          </span><span class="s1">trailingCommaPos = this.state.lastTokStart;</span><span class="s2">\n          </span><span class="s1">continue;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">if (this.tsIsListTerminator(kind)) {</span><span class="s2">\n          </span><span class="s1">break;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">if (expectSuccess) {</span><span class="s2">\n          </span><span class="s1">// This will fail with an error about a missing comma</span><span class="s2">\n          </span><span class="s1">this.expect(tt.comma);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return undefined;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">if (refTrailingCommaPos) {</span><span class="s2">\n        </span><span class="s1">refTrailingCommaPos.value = trailingCommaPos;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return result;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsParseBracketedList&lt;T extends N.Node&gt;(</span><span class="s2">\n      </span><span class="s1">kind: ParsingContext,</span><span class="s2">\n      </span><span class="s1">parseElement: () =&gt; T,</span><span class="s2">\n      </span><span class="s1">bracket: boolean,</span><span class="s2">\n      </span><span class="s1">skipFirstToken: boolean,</span><span class="s2">\n      </span><span class="s1">refTrailingCommaPos?: {</span><span class="s2">\n        </span><span class="s1">value: number;</span><span class="s2">\n      </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">): T[] {</span><span class="s2">\n      </span><span class="s1">if (!skipFirstToken) {</span><span class="s2">\n        </span><span class="s1">if (bracket) {</span><span class="s2">\n          </span><span class="s1">this.expect(tt.bracketL);</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">this.expect(tt.lt);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">const result = this.tsParseDelimitedList(</span><span class="s2">\n        </span><span class="s1">kind,</span><span class="s2">\n        </span><span class="s1">parseElement,</span><span class="s2">\n        </span><span class="s1">refTrailingCommaPos,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n\n      </span><span class="s1">if (bracket) {</span><span class="s2">\n        </span><span class="s1">this.expect(tt.bracketR);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">this.expect(tt.gt);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return result;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsParseImportType(): N.TsImportType {</span><span class="s2">\n      </span><span class="s1">const node = this.startNode&lt;N.TsImportType&gt;();</span><span class="s2">\n      </span><span class="s1">this.expect(tt._import);</span><span class="s2">\n      </span><span class="s1">this.expect(tt.parenL);</span><span class="s2">\n      </span><span class="s1">if (!this.match(tt.string)) {</span><span class="s2">\n        </span><span class="s1">this.raise(TSErrors.UnsupportedImportTypeArgument, {</span><span class="s2">\n          </span><span class="s1">at: this.state.startLoc,</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">// For compatibility to estree we cannot call parseLiteral directly here</span><span class="s2">\n      </span><span class="s1">node.argument = super.parseExprAtom() as N.StringLiteral;</span><span class="s2">\n      </span><span class="s1">this.expect(tt.parenR);</span><span class="s2">\n\n      </span><span class="s1">if (this.eat(tt.dot)) {</span><span class="s2">\n        </span><span class="s1">// In this instance, the entity name will actually itself be a</span><span class="s2">\n        </span><span class="s1">// qualifier, so allow it to be a reserved word as well.</span><span class="s2">\n        </span><span class="s1">node.qualifier = this.tsParseEntityName();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (this.match(tt.lt)) {</span><span class="s2">\n        </span><span class="s1">node.typeParameters = this.tsParseTypeArguments();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">TSImportType</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsParseEntityName(allowReservedWords: boolean = true): N.TsEntityName {</span><span class="s2">\n      </span><span class="s1">let entity: N.TsEntityName = this.parseIdentifier(allowReservedWords);</span><span class="s2">\n      </span><span class="s1">while (this.eat(tt.dot)) {</span><span class="s2">\n        </span><span class="s1">const node: Undone&lt;N.TsQualifiedName&gt; =</span><span class="s2">\n          </span><span class="s1">this.startNodeAtNode&lt;N.TsQualifiedName&gt;(entity);</span><span class="s2">\n        </span><span class="s1">node.left = entity;</span><span class="s2">\n        </span><span class="s1">node.right = this.parseIdentifier(allowReservedWords);</span><span class="s2">\n        </span><span class="s1">entity = this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">TSQualifiedName</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return entity;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsParseTypeReference(): N.TsTypeReference {</span><span class="s2">\n      </span><span class="s1">const node = this.startNode&lt;N.TsTypeReference&gt;();</span><span class="s2">\n      </span><span class="s1">node.typeName = this.tsParseEntityName();</span><span class="s2">\n      </span><span class="s1">if (!this.hasPrecedingLineBreak() &amp;&amp; this.match(tt.lt)) {</span><span class="s2">\n        </span><span class="s1">node.typeParameters = this.tsParseTypeArguments();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">TSTypeReference</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsParseThisTypePredicate(lhs: N.TsThisType): N.TsTypePredicate {</span><span class="s2">\n      </span><span class="s1">this.next();</span><span class="s2">\n      </span><span class="s1">const node = this.startNodeAtNode&lt;N.TsTypePredicate&gt;(lhs);</span><span class="s2">\n      </span><span class="s1">node.parameterName = lhs;</span><span class="s2">\n      </span><span class="s1">node.typeAnnotation = this.tsParseTypeAnnotation(/* eatColon */ false);</span><span class="s2">\n      </span><span class="s1">node.asserts = false;</span><span class="s2">\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">TSTypePredicate</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsParseThisTypeNode(): N.TsThisType {</span><span class="s2">\n      </span><span class="s1">const node = this.startNode&lt;N.TsThisType&gt;();</span><span class="s2">\n      </span><span class="s1">this.next();</span><span class="s2">\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">TSThisType</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsParseTypeQuery(): N.TsTypeQuery {</span><span class="s2">\n      </span><span class="s1">const node = this.startNode&lt;N.TsTypeQuery&gt;();</span><span class="s2">\n      </span><span class="s1">this.expect(tt._typeof);</span><span class="s2">\n      </span><span class="s1">if (this.match(tt._import)) {</span><span class="s2">\n        </span><span class="s1">node.exprName = this.tsParseImportType();</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">node.exprName = this.tsParseEntityName();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (!this.hasPrecedingLineBreak() &amp;&amp; this.match(tt.lt)) {</span><span class="s2">\n        </span><span class="s1">node.typeParameters = this.tsParseTypeArguments();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">TSTypeQuery</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsParseInOutModifiers = this.tsParseModifiers.bind(this, {</span><span class="s2">\n      </span><span class="s1">allowedModifiers: [</span><span class="s2">\&quot;</span><span class="s1">in</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">out</span><span class="s2">\&quot;</span><span class="s1">],</span><span class="s2">\n      </span><span class="s1">disallowedModifiers: [</span><span class="s2">\n        \&quot;</span><span class="s1">const</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        \&quot;</span><span class="s1">public</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        \&quot;</span><span class="s1">private</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        \&quot;</span><span class="s1">protected</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        \&quot;</span><span class="s1">readonly</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        \&quot;</span><span class="s1">declare</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        \&quot;</span><span class="s1">abstract</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        \&quot;</span><span class="s1">override</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">],</span><span class="s2">\n      </span><span class="s1">errorTemplate: TSErrors.InvalidModifierOnTypeParameter,</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n\n    </span><span class="s1">tsParseConstModifier = this.tsParseModifiers.bind(this, {</span><span class="s2">\n      </span><span class="s1">allowedModifiers: [</span><span class="s2">\&quot;</span><span class="s1">const</span><span class="s2">\&quot;</span><span class="s1">],</span><span class="s2">\n      </span><span class="s1">// for better error recovery</span><span class="s2">\n      </span><span class="s1">disallowedModifiers: [</span><span class="s2">\&quot;</span><span class="s1">in</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">out</span><span class="s2">\&quot;</span><span class="s1">],</span><span class="s2">\n      </span><span class="s1">errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions,</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n\n    </span><span class="s1">tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {</span><span class="s2">\n      </span><span class="s1">allowedModifiers: [</span><span class="s2">\&quot;</span><span class="s1">in</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">out</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">const</span><span class="s2">\&quot;</span><span class="s1">],</span><span class="s2">\n      </span><span class="s1">disallowedModifiers: [</span><span class="s2">\n        \&quot;</span><span class="s1">public</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        \&quot;</span><span class="s1">private</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        \&quot;</span><span class="s1">protected</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        \&quot;</span><span class="s1">readonly</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        \&quot;</span><span class="s1">declare</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        \&quot;</span><span class="s1">abstract</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        \&quot;</span><span class="s1">override</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">],</span><span class="s2">\n      </span><span class="s1">errorTemplate: TSErrors.InvalidModifierOnTypeParameter,</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n\n    </span><span class="s1">tsParseTypeParameter(</span><span class="s2">\n      </span><span class="s1">parseModifiers: (node: Undone&lt;N.TsTypeParameter&gt;) =&gt; void,</span><span class="s2">\n    </span><span class="s1">): N.TsTypeParameter {</span><span class="s2">\n      </span><span class="s1">const node = this.startNode&lt;N.TsTypeParameter&gt;();</span><span class="s2">\n\n      </span><span class="s1">parseModifiers(node);</span><span class="s2">\n\n      </span><span class="s1">node.name = this.tsParseTypeParameterName();</span><span class="s2">\n      </span><span class="s1">node.constraint = this.tsEatThenParseType(tt._extends);</span><span class="s2">\n      </span><span class="s1">node.default = this.tsEatThenParseType(tt.eq);</span><span class="s2">\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">TSTypeParameter</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsTryParseTypeParameters(</span><span class="s2">\n      </span><span class="s1">parseModifiers: (node: N.TsTypeParameter) =&gt; void,</span><span class="s2">\n    </span><span class="s1">): N.TsTypeParameterDeclaration | undefined | null {</span><span class="s2">\n      </span><span class="s1">if (this.match(tt.lt)) {</span><span class="s2">\n        </span><span class="s1">return this.tsParseTypeParameters(parseModifiers);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsParseTypeParameters(parseModifiers: (node: N.TsTypeParameter) =&gt; void) {</span><span class="s2">\n      </span><span class="s1">const node = this.startNode&lt;N.TsTypeParameterDeclaration&gt;();</span><span class="s2">\n\n      </span><span class="s1">if (this.match(tt.lt) || this.match(tt.jsxTagStart)) {</span><span class="s2">\n        </span><span class="s1">this.next();</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">this.unexpected();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">const refTrailingCommaPos = { value: -1 };</span><span class="s2">\n\n      </span><span class="s1">node.params = this.tsParseBracketedList(</span><span class="s2">\n        \&quot;</span><span class="s1">TypeParametersOrArguments</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error refine typings</span><span class="s2">\n        </span><span class="s1">this.tsParseTypeParameter.bind(this, parseModifiers),</span><span class="s2">\n        </span><span class="s1">/* bracket */ false,</span><span class="s2">\n        </span><span class="s1">/* skipFirstToken */ true,</span><span class="s2">\n        </span><span class="s1">refTrailingCommaPos,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">if (node.params.length === 0) {</span><span class="s2">\n        </span><span class="s1">this.raise(TSErrors.EmptyTypeParameters, { at: node });</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (refTrailingCommaPos.value !== -1) {</span><span class="s2">\n        </span><span class="s1">this.addExtra(node, </span><span class="s2">\&quot;</span><span class="s1">trailingComma</span><span class="s2">\&quot;</span><span class="s1">, refTrailingCommaPos.value);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">TSTypeParameterDeclaration</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// Note: In TypeScript implementation we must provide `yieldContext` and `awaitContext`,</span><span class="s2">\n    </span><span class="s1">// but here it's always false, because this is only used for types.</span><span class="s2">\n    </span><span class="s1">tsFillSignature(</span><span class="s2">\n      </span><span class="s1">returnToken: TokenType,</span><span class="s2">\n      </span><span class="s1">signature: Undone&lt;N.TsSignatureDeclaration&gt;,</span><span class="s2">\n    </span><span class="s1">): void {</span><span class="s2">\n      </span><span class="s1">// Arrow fns *must* have return token (`=&gt;`). Normal functions can omit it.</span><span class="s2">\n      </span><span class="s1">const returnTokenRequired = returnToken === tt.arrow;</span><span class="s2">\n\n      </span><span class="s1">// https://github.com/babel/babel/issues/9231</span><span class="s2">\n      </span><span class="s1">const paramsKey = process.env.BABEL_8_BREAKING ? </span><span class="s2">\&quot;</span><span class="s1">params</span><span class="s2">\&quot; </span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">parameters</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n      </span><span class="s1">const returnTypeKey = process.env.BABEL_8_BREAKING</span><span class="s2">\n        </span><span class="s1">? </span><span class="s2">\&quot;</span><span class="s1">returnType</span><span class="s2">\&quot;\n        </span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">typeAnnotation</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n      </span><span class="s1">signature.typeParameters = this.tsTryParseTypeParameters(</span><span class="s2">\n        </span><span class="s1">this.tsParseConstModifier,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">this.expect(tt.parenL);</span><span class="s2">\n      </span><span class="s1">signature[paramsKey] = this.tsParseBindingListForSignature();</span><span class="s2">\n      </span><span class="s1">if (returnTokenRequired) {</span><span class="s2">\n        </span><span class="s1">signature[returnTypeKey] =</span><span class="s2">\n          </span><span class="s1">this.tsParseTypeOrTypePredicateAnnotation(returnToken);</span><span class="s2">\n      </span><span class="s1">} else if (this.match(returnToken)) {</span><span class="s2">\n        </span><span class="s1">signature[returnTypeKey] =</span><span class="s2">\n          </span><span class="s1">this.tsParseTypeOrTypePredicateAnnotation(returnToken);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsParseBindingListForSignature(): Array&lt;</span><span class="s2">\n      </span><span class="s1">N.Identifier | N.RestElement | N.ObjectPattern | N.ArrayPattern</span><span class="s2">\n    </span><span class="s1">&gt; {</span><span class="s2">\n      </span><span class="s1">return super</span><span class="s2">\n        </span><span class="s1">.parseBindingList(</span><span class="s2">\n          </span><span class="s1">tt.parenR,</span><span class="s2">\n          </span><span class="s1">charCodes.rightParenthesis,</span><span class="s2">\n          </span><span class="s1">ParseBindingListFlags.IS_FUNCTION_PARAMS,</span><span class="s2">\n        </span><span class="s1">)</span><span class="s2">\n        </span><span class="s1">.map(pattern =&gt; {</span><span class="s2">\n          </span><span class="s1">if (</span><span class="s2">\n            </span><span class="s1">pattern.type !== </span><span class="s2">\&quot;</span><span class="s1">Identifier</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n            </span><span class="s1">pattern.type !== </span><span class="s2">\&quot;</span><span class="s1">RestElement</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n            </span><span class="s1">pattern.type !== </span><span class="s2">\&quot;</span><span class="s1">ObjectPattern</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n            </span><span class="s1">pattern.type !== </span><span class="s2">\&quot;</span><span class="s1">ArrayPattern</span><span class="s2">\&quot;\n          </span><span class="s1">) {</span><span class="s2">\n            </span><span class="s1">this.raise(TSErrors.UnsupportedSignatureParameterKind, {</span><span class="s2">\n              </span><span class="s1">at: pattern,</span><span class="s2">\n              </span><span class="s1">type: pattern.type,</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">return pattern as any;</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsParseTypeMemberSemicolon(): void {</span><span class="s2">\n      </span><span class="s1">if (!this.eat(tt.comma) &amp;&amp; !this.isLineTerminator()) {</span><span class="s2">\n        </span><span class="s1">this.expect(tt.semi);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsParseSignatureMember(</span><span class="s2">\n      </span><span class="s1">kind: </span><span class="s2">\&quot;</span><span class="s1">TSCallSignatureDeclaration</span><span class="s2">\&quot; </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">TSConstructSignatureDeclaration</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">node: Undone&lt;</span><span class="s2">\n        </span><span class="s1">N.TsCallSignatureDeclaration | N.TsConstructSignatureDeclaration</span><span class="s2">\n      </span><span class="s1">&gt;,</span><span class="s2">\n    </span><span class="s1">): N.TsCallSignatureDeclaration | N.TsConstructSignatureDeclaration {</span><span class="s2">\n      </span><span class="s1">this.tsFillSignature(tt.colon, node);</span><span class="s2">\n      </span><span class="s1">this.tsParseTypeMemberSemicolon();</span><span class="s2">\n      </span><span class="s1">return this.finishNode(node, kind);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsIsUnambiguouslyIndexSignature() {</span><span class="s2">\n      </span><span class="s1">this.next(); // Skip '{'</span><span class="s2">\n      </span><span class="s1">if (tokenIsIdentifier(this.state.type)) {</span><span class="s2">\n        </span><span class="s1">this.next();</span><span class="s2">\n        </span><span class="s1">return this.match(tt.colon);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return false;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsTryParseIndexSignature(</span><span class="s2">\n      </span><span class="s1">node: Undone&lt;N.TsIndexSignature&gt;,</span><span class="s2">\n    </span><span class="s1">): N.TsIndexSignature | undefined | null {</span><span class="s2">\n      </span><span class="s1">if (</span><span class="s2">\n        </span><span class="s1">!(</span><span class="s2">\n          </span><span class="s1">this.match(tt.bracketL) &amp;&amp;</span><span class="s2">\n          </span><span class="s1">this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))</span><span class="s2">\n        </span><span class="s1">)</span><span class="s2">\n      </span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">return undefined;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">this.expect(tt.bracketL);</span><span class="s2">\n      </span><span class="s1">const id = this.parseIdentifier();</span><span class="s2">\n      </span><span class="s1">id.typeAnnotation = this.tsParseTypeAnnotation();</span><span class="s2">\n      </span><span class="s1">this.resetEndLocation(id); // set end position to end of type</span><span class="s2">\n\n      </span><span class="s1">this.expect(tt.bracketR);</span><span class="s2">\n      </span><span class="s1">node.parameters = [id];</span><span class="s2">\n\n      </span><span class="s1">const type = this.tsTryParseTypeAnnotation();</span><span class="s2">\n      </span><span class="s1">if (type) node.typeAnnotation = type;</span><span class="s2">\n      </span><span class="s1">this.tsParseTypeMemberSemicolon();</span><span class="s2">\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">TSIndexSignature</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsParsePropertyOrMethodSignature(</span><span class="s2">\n      </span><span class="s1">node: N.TsPropertySignature | N.TsMethodSignature,</span><span class="s2">\n      </span><span class="s1">readonly: boolean,</span><span class="s2">\n    </span><span class="s1">): N.TsPropertySignature | N.TsMethodSignature {</span><span class="s2">\n      </span><span class="s1">if (this.eat(tt.question)) node.optional = true;</span><span class="s2">\n      </span><span class="s1">const nodeAny: any = node;</span><span class="s2">\n\n      </span><span class="s1">if (this.match(tt.parenL) || this.match(tt.lt)) {</span><span class="s2">\n        </span><span class="s1">if (readonly) {</span><span class="s2">\n          </span><span class="s1">this.raise(TSErrors.ReadonlyForMethodSignature, { at: node });</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">const method: N.TsMethodSignature = nodeAny;</span><span class="s2">\n        </span><span class="s1">if (method.kind &amp;&amp; this.match(tt.lt)) {</span><span class="s2">\n          </span><span class="s1">this.raise(TSErrors.AccesorCannotHaveTypeParameters, {</span><span class="s2">\n            </span><span class="s1">at: this.state.curPosition(),</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">this.tsFillSignature(tt.colon, method);</span><span class="s2">\n        </span><span class="s1">this.tsParseTypeMemberSemicolon();</span><span class="s2">\n        </span><span class="s1">const paramsKey = process.env.BABEL_8_BREAKING</span><span class="s2">\n          </span><span class="s1">? </span><span class="s2">\&quot;</span><span class="s1">params</span><span class="s2">\&quot;\n          </span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">parameters</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n        </span><span class="s1">const returnTypeKey = process.env.BABEL_8_BREAKING</span><span class="s2">\n          </span><span class="s1">? </span><span class="s2">\&quot;</span><span class="s1">returnType</span><span class="s2">\&quot;\n          </span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">typeAnnotation</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n        </span><span class="s1">if (method.kind === </span><span class="s2">\&quot;</span><span class="s1">get</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">if (method[paramsKey].length &gt; 0) {</span><span class="s2">\n            </span><span class="s1">this.raise(Errors.BadGetterArity, { at: this.state.curPosition() });</span><span class="s2">\n            </span><span class="s1">if (this.isThisParam(method[paramsKey][0])) {</span><span class="s2">\n              </span><span class="s1">this.raise(TSErrors.AccesorCannotDeclareThisParameter, {</span><span class="s2">\n                </span><span class="s1">at: this.state.curPosition(),</span><span class="s2">\n              </span><span class="s1">});</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">} else if (method.kind === </span><span class="s2">\&quot;</span><span class="s1">set</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">if (method[paramsKey].length !== 1) {</span><span class="s2">\n            </span><span class="s1">this.raise(Errors.BadSetterArity, { at: this.state.curPosition() });</span><span class="s2">\n          </span><span class="s1">} else {</span><span class="s2">\n            </span><span class="s1">const firstParameter = method[paramsKey][0];</span><span class="s2">\n            </span><span class="s1">if (this.isThisParam(firstParameter)) {</span><span class="s2">\n              </span><span class="s1">this.raise(TSErrors.AccesorCannotDeclareThisParameter, {</span><span class="s2">\n                </span><span class="s1">at: this.state.curPosition(),</span><span class="s2">\n              </span><span class="s1">});</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">if (</span><span class="s2">\n              </span><span class="s1">firstParameter.type === </span><span class="s2">\&quot;</span><span class="s1">Identifier</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n              </span><span class="s1">firstParameter.optional</span><span class="s2">\n            </span><span class="s1">) {</span><span class="s2">\n              </span><span class="s1">this.raise(TSErrors.SetAccesorCannotHaveOptionalParameter, {</span><span class="s2">\n                </span><span class="s1">at: this.state.curPosition(),</span><span class="s2">\n              </span><span class="s1">});</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">if (firstParameter.type === </span><span class="s2">\&quot;</span><span class="s1">RestElement</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n              </span><span class="s1">this.raise(TSErrors.SetAccesorCannotHaveRestParameter, {</span><span class="s2">\n                </span><span class="s1">at: this.state.curPosition(),</span><span class="s2">\n              </span><span class="s1">});</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">if (method[returnTypeKey]) {</span><span class="s2">\n            </span><span class="s1">this.raise(TSErrors.SetAccesorCannotHaveReturnType, {</span><span class="s2">\n              </span><span class="s1">at: method[returnTypeKey],</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">method.kind = </span><span class="s2">\&quot;</span><span class="s1">method</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return this.finishNode(method, </span><span class="s2">\&quot;</span><span class="s1">TSMethodSignature</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">const property: N.TsPropertySignature = nodeAny;</span><span class="s2">\n        </span><span class="s1">if (readonly) property.readonly = true;</span><span class="s2">\n        </span><span class="s1">const type = this.tsTryParseTypeAnnotation();</span><span class="s2">\n        </span><span class="s1">if (type) property.typeAnnotation = type;</span><span class="s2">\n        </span><span class="s1">this.tsParseTypeMemberSemicolon();</span><span class="s2">\n        </span><span class="s1">return this.finishNode(property, </span><span class="s2">\&quot;</span><span class="s1">TSPropertySignature</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsParseTypeMember(): N.TsTypeElement {</span><span class="s2">\n      </span><span class="s1">const node: any = this.startNode();</span><span class="s2">\n\n      </span><span class="s1">if (this.match(tt.parenL) || this.match(tt.lt)) {</span><span class="s2">\n        </span><span class="s1">return this.tsParseSignatureMember(</span><span class="s2">\&quot;</span><span class="s1">TSCallSignatureDeclaration</span><span class="s2">\&quot;</span><span class="s1">, node);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">if (this.match(tt._new)) {</span><span class="s2">\n        </span><span class="s1">const id = this.startNode&lt;N.Identifier&gt;();</span><span class="s2">\n        </span><span class="s1">this.next();</span><span class="s2">\n        </span><span class="s1">if (this.match(tt.parenL) || this.match(tt.lt)) {</span><span class="s2">\n          </span><span class="s1">return this.tsParseSignatureMember(</span><span class="s2">\n            \&quot;</span><span class="s1">TSConstructSignatureDeclaration</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n            </span><span class="s1">node,</span><span class="s2">\n          </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">node.key = this.createIdentifier(id, </span><span class="s2">\&quot;</span><span class="s1">new</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">return this.tsParsePropertyOrMethodSignature(node, false);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">this.tsParseModifiers(</span><span class="s2">\n        </span><span class="s1">{</span><span class="s2">\n          </span><span class="s1">allowedModifiers: [</span><span class="s2">\&quot;</span><span class="s1">readonly</span><span class="s2">\&quot;</span><span class="s1">],</span><span class="s2">\n          </span><span class="s1">disallowedModifiers: [</span><span class="s2">\n            \&quot;</span><span class="s1">declare</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n            \&quot;</span><span class="s1">abstract</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n            \&quot;</span><span class="s1">private</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n            \&quot;</span><span class="s1">protected</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n            \&quot;</span><span class="s1">public</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n            \&quot;</span><span class="s1">static</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n            \&quot;</span><span class="s1">override</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n          </span><span class="s1">],</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">node,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n\n      </span><span class="s1">const idx = this.tsTryParseIndexSignature(node);</span><span class="s2">\n      </span><span class="s1">if (idx) {</span><span class="s2">\n        </span><span class="s1">return idx;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">super.parsePropertyName(node);</span><span class="s2">\n      </span><span class="s1">if (</span><span class="s2">\n        </span><span class="s1">!node.computed &amp;&amp;</span><span class="s2">\n        </span><span class="s1">node.key.type === </span><span class="s2">\&quot;</span><span class="s1">Identifier</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n        </span><span class="s1">(node.key.name === </span><span class="s2">\&quot;</span><span class="s1">get</span><span class="s2">\&quot; </span><span class="s1">|| node.key.name === </span><span class="s2">\&quot;</span><span class="s1">set</span><span class="s2">\&quot;</span><span class="s1">) &amp;&amp;</span><span class="s2">\n        </span><span class="s1">this.tsTokenCanFollowModifier()</span><span class="s2">\n      </span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">node.kind = node.key.name;</span><span class="s2">\n        </span><span class="s1">super.parsePropertyName(node);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsParseTypeLiteral(): N.TsTypeLiteral {</span><span class="s2">\n      </span><span class="s1">const node = this.startNode&lt;N.TsTypeLiteral&gt;();</span><span class="s2">\n      </span><span class="s1">node.members = this.tsParseObjectTypeMembers();</span><span class="s2">\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">TSTypeLiteral</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsParseObjectTypeMembers(): Array&lt;N.TsTypeElement&gt; {</span><span class="s2">\n      </span><span class="s1">this.expect(tt.braceL);</span><span class="s2">\n      </span><span class="s1">const members = this.tsParseList(</span><span class="s2">\n        \&quot;</span><span class="s1">TypeMembers</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">this.tsParseTypeMember.bind(this),</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">this.expect(tt.braceR);</span><span class="s2">\n      </span><span class="s1">return members;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsIsStartOfMappedType(): boolean {</span><span class="s2">\n      </span><span class="s1">this.next();</span><span class="s2">\n      </span><span class="s1">if (this.eat(tt.plusMin)) {</span><span class="s2">\n        </span><span class="s1">return this.isContextual(tt._readonly);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (this.isContextual(tt._readonly)) {</span><span class="s2">\n        </span><span class="s1">this.next();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (!this.match(tt.bracketL)) {</span><span class="s2">\n        </span><span class="s1">return false;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">this.next();</span><span class="s2">\n      </span><span class="s1">if (!this.tsIsIdentifier()) {</span><span class="s2">\n        </span><span class="s1">return false;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">this.next();</span><span class="s2">\n      </span><span class="s1">return this.match(tt._in);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsParseMappedTypeParameter(): N.TsTypeParameter {</span><span class="s2">\n      </span><span class="s1">const node = this.startNode&lt;N.TsTypeParameter&gt;();</span><span class="s2">\n      </span><span class="s1">node.name = this.tsParseTypeParameterName();</span><span class="s2">\n      </span><span class="s1">node.constraint = this.tsExpectThenParseType(tt._in);</span><span class="s2">\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">TSTypeParameter</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsParseMappedType(): N.TsMappedType {</span><span class="s2">\n      </span><span class="s1">const node = this.startNode&lt;N.TsMappedType&gt;();</span><span class="s2">\n\n      </span><span class="s1">this.expect(tt.braceL);</span><span class="s2">\n\n      </span><span class="s1">if (this.match(tt.plusMin)) {</span><span class="s2">\n        </span><span class="s1">node.readonly = this.state.value;</span><span class="s2">\n        </span><span class="s1">this.next();</span><span class="s2">\n        </span><span class="s1">this.expectContextual(tt._readonly);</span><span class="s2">\n      </span><span class="s1">} else if (this.eatContextual(tt._readonly)) {</span><span class="s2">\n        </span><span class="s1">node.readonly = true;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">this.expect(tt.bracketL);</span><span class="s2">\n      </span><span class="s1">node.typeParameter = this.tsParseMappedTypeParameter();</span><span class="s2">\n      </span><span class="s1">node.nameType = this.eatContextual(tt._as) ? this.tsParseType() : null;</span><span class="s2">\n\n      </span><span class="s1">this.expect(tt.bracketR);</span><span class="s2">\n\n      </span><span class="s1">if (this.match(tt.plusMin)) {</span><span class="s2">\n        </span><span class="s1">node.optional = this.state.value;</span><span class="s2">\n        </span><span class="s1">this.next();</span><span class="s2">\n        </span><span class="s1">this.expect(tt.question);</span><span class="s2">\n      </span><span class="s1">} else if (this.eat(tt.question)) {</span><span class="s2">\n        </span><span class="s1">node.optional = true;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">node.typeAnnotation = this.tsTryParseType();</span><span class="s2">\n      </span><span class="s1">this.semicolon();</span><span class="s2">\n      </span><span class="s1">this.expect(tt.braceR);</span><span class="s2">\n\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">TSMappedType</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsParseTupleType(): N.TsTupleType {</span><span class="s2">\n      </span><span class="s1">const node = this.startNode&lt;N.TsTupleType&gt;();</span><span class="s2">\n      </span><span class="s1">node.elementTypes = this.tsParseBracketedList(</span><span class="s2">\n        \&quot;</span><span class="s1">TupleElementTypes</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">this.tsParseTupleElementType.bind(this),</span><span class="s2">\n        </span><span class="s1">/* bracket */ true,</span><span class="s2">\n        </span><span class="s1">/* skipFirstToken */ false,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n\n      </span><span class="s1">// Validate the elementTypes to ensure that no mandatory elements</span><span class="s2">\n      </span><span class="s1">// follow optional elements</span><span class="s2">\n      </span><span class="s1">let seenOptionalElement = false;</span><span class="s2">\n      </span><span class="s1">let labeledElements: boolean | null = null;</span><span class="s2">\n      </span><span class="s1">node.elementTypes.forEach(elementNode =&gt; {</span><span class="s2">\n        </span><span class="s1">const { type } = elementNode;</span><span class="s2">\n\n        </span><span class="s1">if (</span><span class="s2">\n          </span><span class="s1">seenOptionalElement &amp;&amp;</span><span class="s2">\n          </span><span class="s1">type !== </span><span class="s2">\&quot;</span><span class="s1">TSRestType</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n          </span><span class="s1">type !== </span><span class="s2">\&quot;</span><span class="s1">TSOptionalType</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n          </span><span class="s1">!(type === </span><span class="s2">\&quot;</span><span class="s1">TSNamedTupleMember</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; elementNode.optional)</span><span class="s2">\n        </span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">this.raise(TSErrors.OptionalTypeBeforeRequired, {</span><span class="s2">\n            </span><span class="s1">at: elementNode,</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">seenOptionalElement ||=</span><span class="s2">\n          </span><span class="s1">(type === </span><span class="s2">\&quot;</span><span class="s1">TSNamedTupleMember</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; elementNode.optional) ||</span><span class="s2">\n          </span><span class="s1">type === </span><span class="s2">\&quot;</span><span class="s1">TSOptionalType</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n        </span><span class="s1">// When checking labels, check the argument of the spread operator</span><span class="s2">\n        </span><span class="s1">let checkType = type;</span><span class="s2">\n        </span><span class="s1">if (type === </span><span class="s2">\&quot;</span><span class="s1">TSRestType</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">elementNode = elementNode.typeAnnotation;</span><span class="s2">\n          </span><span class="s1">checkType = elementNode.type;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">const isLabeled = checkType === </span><span class="s2">\&quot;</span><span class="s1">TSNamedTupleMember</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n        </span><span class="s1">labeledElements ??= isLabeled;</span><span class="s2">\n        </span><span class="s1">if (labeledElements !== isLabeled) {</span><span class="s2">\n          </span><span class="s1">this.raise(TSErrors.MixedLabeledAndUnlabeledElements, {</span><span class="s2">\n            </span><span class="s1">at: elementNode,</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">TSTupleType</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsParseTupleElementType(): N.TsNamedTupleMember | N.TsType {</span><span class="s2">\n      </span><span class="s1">// parses `...TsType[]`</span><span class="s2">\n\n      </span><span class="s1">const { startLoc } = this.state;</span><span class="s2">\n\n      </span><span class="s1">const rest = this.eat(tt.ellipsis);</span><span class="s2">\n\n      </span><span class="s1">let labeled: boolean;</span><span class="s2">\n      </span><span class="s1">let label: N.Identifier;</span><span class="s2">\n      </span><span class="s1">let optional: boolean;</span><span class="s2">\n      </span><span class="s1">let type: N.TsNamedTupleMember | N.TsType;</span><span class="s2">\n\n      </span><span class="s1">const isWord = tokenIsKeywordOrIdentifier(this.state.type);</span><span class="s2">\n      </span><span class="s1">const chAfterWord = isWord ? this.lookaheadCharCode() : null;</span><span class="s2">\n      </span><span class="s1">if (chAfterWord === charCodes.colon) {</span><span class="s2">\n        </span><span class="s1">labeled = true;</span><span class="s2">\n        </span><span class="s1">optional = false;</span><span class="s2">\n        </span><span class="s1">label = this.parseIdentifier(true);</span><span class="s2">\n        </span><span class="s1">this.expect(tt.colon);</span><span class="s2">\n        </span><span class="s1">type = this.tsParseType();</span><span class="s2">\n      </span><span class="s1">} else if (chAfterWord === charCodes.questionMark) {</span><span class="s2">\n        </span><span class="s1">optional = true;</span><span class="s2">\n        </span><span class="s1">const startLoc = this.state.startLoc;</span><span class="s2">\n        </span><span class="s1">const wordName = this.state.value;</span><span class="s2">\n        </span><span class="s1">const typeOrLabel = this.tsParseNonArrayType();</span><span class="s2">\n\n        </span><span class="s1">if (this.lookaheadCharCode() === charCodes.colon) {</span><span class="s2">\n          </span><span class="s1">labeled = true;</span><span class="s2">\n          </span><span class="s1">label = this.createIdentifier(</span><span class="s2">\n            </span><span class="s1">this.startNodeAt&lt;N.Identifier&gt;(startLoc),</span><span class="s2">\n            </span><span class="s1">wordName,</span><span class="s2">\n          </span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">this.expect(tt.question);</span><span class="s2">\n          </span><span class="s1">this.expect(tt.colon);</span><span class="s2">\n          </span><span class="s1">type = this.tsParseType();</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">labeled = false;</span><span class="s2">\n          </span><span class="s1">type = typeOrLabel;</span><span class="s2">\n          </span><span class="s1">this.expect(tt.question);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">type = this.tsParseType();</span><span class="s2">\n        </span><span class="s1">optional = this.eat(tt.question);</span><span class="s2">\n        </span><span class="s1">// In this case (labeled === true) could be only in invalid label.</span><span class="s2">\n        </span><span class="s1">// E.g. [x.y:type]</span><span class="s2">\n        </span><span class="s1">// An error is raised while processing node.</span><span class="s2">\n        </span><span class="s1">labeled = this.eat(tt.colon);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">if (labeled) {</span><span class="s2">\n        </span><span class="s1">let labeledNode: Undone&lt;N.TsNamedTupleMember&gt;;</span><span class="s2">\n        </span><span class="s1">if (label) {</span><span class="s2">\n          </span><span class="s1">labeledNode = this.startNodeAtNode&lt;N.TsNamedTupleMember&gt;(label);</span><span class="s2">\n          </span><span class="s1">labeledNode.optional = optional;</span><span class="s2">\n          </span><span class="s1">labeledNode.label = label;</span><span class="s2">\n          </span><span class="s1">labeledNode.elementType = type;</span><span class="s2">\n\n          </span><span class="s1">if (this.eat(tt.question)) {</span><span class="s2">\n            </span><span class="s1">labeledNode.optional = true;</span><span class="s2">\n            </span><span class="s1">this.raise(TSErrors.TupleOptionalAfterType, {</span><span class="s2">\n              </span><span class="s1">at: this.state.lastTokStartLoc,</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">labeledNode = this.startNodeAtNode&lt;N.TsNamedTupleMember&gt;(type);</span><span class="s2">\n          </span><span class="s1">labeledNode.optional = optional;</span><span class="s2">\n          </span><span class="s1">this.raise(TSErrors.InvalidTupleMemberLabel, { at: type });</span><span class="s2">\n          </span><span class="s1">// @ts-expect-error This produces an invalid AST, but at least we don't drop</span><span class="s2">\n          </span><span class="s1">// nodes representing the invalid source.</span><span class="s2">\n          </span><span class="s1">labeledNode.label = type;</span><span class="s2">\n          </span><span class="s1">labeledNode.elementType = this.tsParseType();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">type = this.finishNode(labeledNode, </span><span class="s2">\&quot;</span><span class="s1">TSNamedTupleMember</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">} else if (optional) {</span><span class="s2">\n        </span><span class="s1">const optionalTypeNode = this.startNodeAtNode&lt;N.TsOptionalType&gt;(type);</span><span class="s2">\n        </span><span class="s1">optionalTypeNode.typeAnnotation = type;</span><span class="s2">\n        </span><span class="s1">type = this.finishNode(optionalTypeNode, </span><span class="s2">\&quot;</span><span class="s1">TSOptionalType</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">if (rest) {</span><span class="s2">\n        </span><span class="s1">const restNode = this.startNodeAt&lt;N.TsRestType&gt;(startLoc);</span><span class="s2">\n        </span><span class="s1">restNode.typeAnnotation = type;</span><span class="s2">\n        </span><span class="s1">type = this.finishNode(restNode, </span><span class="s2">\&quot;</span><span class="s1">TSRestType</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return type;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsParseParenthesizedType(): N.TsParenthesizedType {</span><span class="s2">\n      </span><span class="s1">const node = this.startNode&lt;N.TsParenthesizedType&gt;();</span><span class="s2">\n      </span><span class="s1">this.expect(tt.parenL);</span><span class="s2">\n      </span><span class="s1">node.typeAnnotation = this.tsParseType();</span><span class="s2">\n      </span><span class="s1">this.expect(tt.parenR);</span><span class="s2">\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">TSParenthesizedType</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsParseFunctionOrConstructorType(</span><span class="s2">\n      </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">TSFunctionType</span><span class="s2">\&quot; </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">TSConstructorType</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">abstract?: boolean,</span><span class="s2">\n    </span><span class="s1">): N.TsFunctionOrConstructorType {</span><span class="s2">\n      </span><span class="s1">const node = this.startNode&lt;</span><span class="s2">\n        </span><span class="s1">N.TsFunctionOrConstructorType | N.TsConstructorType</span><span class="s2">\n      </span><span class="s1">&gt;();</span><span class="s2">\n      </span><span class="s1">if (type === </span><span class="s2">\&quot;</span><span class="s1">TSConstructorType</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">(node as Undone&lt;N.TsConstructorType&gt;).abstract = !!abstract;</span><span class="s2">\n        </span><span class="s1">if (abstract) this.next();</span><span class="s2">\n        </span><span class="s1">this.next(); // eat `new`</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">this.tsInAllowConditionalTypesContext(() =&gt;</span><span class="s2">\n        </span><span class="s1">this.tsFillSignature(tt.arrow, node),</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">return this.finishNode(node, type);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsParseLiteralTypeNode(): N.TsLiteralType {</span><span class="s2">\n      </span><span class="s1">const node = this.startNode&lt;N.TsLiteralType&gt;();</span><span class="s2">\n      </span><span class="s1">// @ts-expect-error refine typings</span><span class="s2">\n      </span><span class="s1">node.literal = (() =&gt; {</span><span class="s2">\n        </span><span class="s1">switch (this.state.type) {</span><span class="s2">\n          </span><span class="s1">case tt.num:</span><span class="s2">\n          </span><span class="s1">case tt.bigint:</span><span class="s2">\n          </span><span class="s1">case tt.string:</span><span class="s2">\n          </span><span class="s1">case tt._true:</span><span class="s2">\n          </span><span class="s1">case tt._false:</span><span class="s2">\n            </span><span class="s1">// For compatibility to estree we cannot call parseLiteral directly here</span><span class="s2">\n            </span><span class="s1">return super.parseExprAtom();</span><span class="s2">\n          </span><span class="s1">default:</span><span class="s2">\n            </span><span class="s1">this.unexpected();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">})();</span><span class="s2">\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">TSLiteralType</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsParseTemplateLiteralType(): N.TsType {</span><span class="s2">\n      </span><span class="s1">const node = this.startNode&lt;N.TsLiteralType&gt;();</span><span class="s2">\n      </span><span class="s1">node.literal = super.parseTemplate(false);</span><span class="s2">\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">TSLiteralType</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseTemplateSubstitution(): N.TsType | N.Node {</span><span class="s2">\n      </span><span class="s1">if (this.state.inType) return this.tsParseType();</span><span class="s2">\n      </span><span class="s1">return super.parseTemplateSubstitution();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsParseThisTypeOrThisTypePredicate(): N.TsThisType | N.TsTypePredicate {</span><span class="s2">\n      </span><span class="s1">const thisKeyword = this.tsParseThisTypeNode();</span><span class="s2">\n      </span><span class="s1">if (this.isContextual(tt._is) &amp;&amp; !this.hasPrecedingLineBreak()) {</span><span class="s2">\n        </span><span class="s1">return this.tsParseThisTypePredicate(thisKeyword);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">return thisKeyword;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsParseNonArrayType(): N.TsType {</span><span class="s2">\n      </span><span class="s1">switch (this.state.type) {</span><span class="s2">\n        </span><span class="s1">case tt.string:</span><span class="s2">\n        </span><span class="s1">case tt.num:</span><span class="s2">\n        </span><span class="s1">case tt.bigint:</span><span class="s2">\n        </span><span class="s1">case tt._true:</span><span class="s2">\n        </span><span class="s1">case tt._false:</span><span class="s2">\n          </span><span class="s1">return this.tsParseLiteralTypeNode();</span><span class="s2">\n        </span><span class="s1">case tt.plusMin:</span><span class="s2">\n          </span><span class="s1">if (this.state.value === </span><span class="s2">\&quot;</span><span class="s1">-</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n            </span><span class="s1">const node = this.startNode&lt;N.TsLiteralType&gt;();</span><span class="s2">\n            </span><span class="s1">const nextToken = this.lookahead();</span><span class="s2">\n            </span><span class="s1">if (nextToken.type !== tt.num &amp;&amp; nextToken.type !== tt.bigint) {</span><span class="s2">\n              </span><span class="s1">this.unexpected();</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">// @ts-expect-error: parseMaybeUnary must returns unary expression</span><span class="s2">\n            </span><span class="s1">node.literal = this.parseMaybeUnary();</span><span class="s2">\n            </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">TSLiteralType</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">break;</span><span class="s2">\n        </span><span class="s1">case tt._this:</span><span class="s2">\n          </span><span class="s1">return this.tsParseThisTypeOrThisTypePredicate();</span><span class="s2">\n        </span><span class="s1">case tt._typeof:</span><span class="s2">\n          </span><span class="s1">return this.tsParseTypeQuery();</span><span class="s2">\n        </span><span class="s1">case tt._import:</span><span class="s2">\n          </span><span class="s1">return this.tsParseImportType();</span><span class="s2">\n        </span><span class="s1">case tt.braceL:</span><span class="s2">\n          </span><span class="s1">return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this))</span><span class="s2">\n            </span><span class="s1">? this.tsParseMappedType()</span><span class="s2">\n            </span><span class="s1">: this.tsParseTypeLiteral();</span><span class="s2">\n        </span><span class="s1">case tt.bracketL:</span><span class="s2">\n          </span><span class="s1">return this.tsParseTupleType();</span><span class="s2">\n        </span><span class="s1">case tt.parenL:</span><span class="s2">\n          </span><span class="s1">if (process.env.BABEL_8_BREAKING) {</span><span class="s2">\n            </span><span class="s1">if (!this.options.createParenthesizedExpressions) {</span><span class="s2">\n              </span><span class="s1">const startLoc = this.state.startLoc;</span><span class="s2">\n              </span><span class="s1">this.next();</span><span class="s2">\n              </span><span class="s1">const type = this.tsParseType();</span><span class="s2">\n              </span><span class="s1">this.expect(tt.parenR);</span><span class="s2">\n              </span><span class="s1">this.addExtra(type, </span><span class="s2">\&quot;</span><span class="s1">parenthesized</span><span class="s2">\&quot;</span><span class="s1">, true);</span><span class="s2">\n              </span><span class="s1">this.addExtra(type, </span><span class="s2">\&quot;</span><span class="s1">parenStart</span><span class="s2">\&quot;</span><span class="s1">, startLoc.index);</span><span class="s2">\n              </span><span class="s1">return type;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n\n          </span><span class="s1">return this.tsParseParenthesizedType();</span><span class="s2">\n        </span><span class="s1">case tt.templateNonTail:</span><span class="s2">\n        </span><span class="s1">case tt.templateTail:</span><span class="s2">\n          </span><span class="s1">return this.tsParseTemplateLiteralType();</span><span class="s2">\n        </span><span class="s1">default: {</span><span class="s2">\n          </span><span class="s1">const { type } = this.state;</span><span class="s2">\n          </span><span class="s1">if (</span><span class="s2">\n            </span><span class="s1">tokenIsIdentifier(type) ||</span><span class="s2">\n            </span><span class="s1">type === tt._void ||</span><span class="s2">\n            </span><span class="s1">type === tt._null</span><span class="s2">\n          </span><span class="s1">) {</span><span class="s2">\n            </span><span class="s1">const nodeType =</span><span class="s2">\n              </span><span class="s1">type === tt._void</span><span class="s2">\n                </span><span class="s1">? </span><span class="s2">\&quot;</span><span class="s1">TSVoidKeyword</span><span class="s2">\&quot;\n                </span><span class="s1">: type === tt._null</span><span class="s2">\n                </span><span class="s1">? </span><span class="s2">\&quot;</span><span class="s1">TSNullKeyword</span><span class="s2">\&quot;\n                </span><span class="s1">: keywordTypeFromName(this.state.value);</span><span class="s2">\n            </span><span class="s1">if (</span><span class="s2">\n              </span><span class="s1">nodeType !== undefined &amp;&amp;</span><span class="s2">\n              </span><span class="s1">this.lookaheadCharCode() !== charCodes.dot</span><span class="s2">\n            </span><span class="s1">) {</span><span class="s2">\n              </span><span class="s1">const node = this.startNode&lt;N.TsKeywordType&gt;();</span><span class="s2">\n              </span><span class="s1">this.next();</span><span class="s2">\n              </span><span class="s1">return this.finishNode(node, nodeType);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">return this.tsParseTypeReference();</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">this.unexpected();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsParseArrayTypeOrHigher(): N.TsType {</span><span class="s2">\n      </span><span class="s1">let type = this.tsParseNonArrayType();</span><span class="s2">\n      </span><span class="s1">while (!this.hasPrecedingLineBreak() &amp;&amp; this.eat(tt.bracketL)) {</span><span class="s2">\n        </span><span class="s1">if (this.match(tt.bracketR)) {</span><span class="s2">\n          </span><span class="s1">const node = this.startNodeAtNode&lt;N.TsArrayType&gt;(type);</span><span class="s2">\n          </span><span class="s1">node.elementType = type;</span><span class="s2">\n          </span><span class="s1">this.expect(tt.bracketR);</span><span class="s2">\n          </span><span class="s1">type = this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">TSArrayType</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">const node = this.startNodeAtNode&lt;N.TsIndexedAccessType&gt;(type);</span><span class="s2">\n          </span><span class="s1">node.objectType = type;</span><span class="s2">\n          </span><span class="s1">node.indexType = this.tsParseType();</span><span class="s2">\n          </span><span class="s1">this.expect(tt.bracketR);</span><span class="s2">\n          </span><span class="s1">type = this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">TSIndexedAccessType</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return type;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsParseTypeOperator(): N.TsTypeOperator {</span><span class="s2">\n      </span><span class="s1">const node = this.startNode&lt;N.TsTypeOperator&gt;();</span><span class="s2">\n      </span><span class="s1">const operator = this.state.value;</span><span class="s2">\n      </span><span class="s1">this.next(); // eat operator</span><span class="s2">\n      </span><span class="s1">node.operator = operator;</span><span class="s2">\n      </span><span class="s1">node.typeAnnotation = this.tsParseTypeOperatorOrHigher();</span><span class="s2">\n\n      </span><span class="s1">if (operator === </span><span class="s2">\&quot;</span><span class="s1">readonly</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">this.tsCheckTypeAnnotationForReadOnly(</span><span class="s2">\n          </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts)</span><span class="s2">\n          </span><span class="s1">node,</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">TSTypeOperator</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsCheckTypeAnnotationForReadOnly(node: N.Node) {</span><span class="s2">\n      </span><span class="s1">switch (node.typeAnnotation.type) {</span><span class="s2">\n        </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">TSTupleType</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n        </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">TSArrayType</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n          </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">default:</span><span class="s2">\n          </span><span class="s1">this.raise(TSErrors.UnexpectedReadonly, { at: node });</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsParseInferType(): N.TsInferType {</span><span class="s2">\n      </span><span class="s1">const node = this.startNode&lt;N.TsInferType&gt;();</span><span class="s2">\n      </span><span class="s1">this.expectContextual(tt._infer);</span><span class="s2">\n      </span><span class="s1">const typeParameter = this.startNode&lt;N.TsTypeParameter&gt;();</span><span class="s2">\n      </span><span class="s1">typeParameter.name = this.tsParseTypeParameterName();</span><span class="s2">\n      </span><span class="s1">typeParameter.constraint = this.tsTryParse(() =&gt;</span><span class="s2">\n        </span><span class="s1">this.tsParseConstraintForInferType(),</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">node.typeParameter = this.finishNode(typeParameter, </span><span class="s2">\&quot;</span><span class="s1">TSTypeParameter</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">TSInferType</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsParseConstraintForInferType() {</span><span class="s2">\n      </span><span class="s1">if (this.eat(tt._extends)) {</span><span class="s2">\n        </span><span class="s1">const constraint = this.tsInDisallowConditionalTypesContext(() =&gt;</span><span class="s2">\n          </span><span class="s1">this.tsParseType(),</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">if (</span><span class="s2">\n          </span><span class="s1">this.state.inDisallowConditionalTypesContext ||</span><span class="s2">\n          </span><span class="s1">!this.match(tt.question)</span><span class="s2">\n        </span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">return constraint;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsParseTypeOperatorOrHigher(): N.TsType {</span><span class="s2">\n      </span><span class="s1">const isTypeOperator =</span><span class="s2">\n        </span><span class="s1">tokenIsTSTypeOperator(this.state.type) &amp;&amp; !this.state.containsEsc;</span><span class="s2">\n      </span><span class="s1">return isTypeOperator</span><span class="s2">\n        </span><span class="s1">? this.tsParseTypeOperator()</span><span class="s2">\n        </span><span class="s1">: this.isContextual(tt._infer)</span><span class="s2">\n        </span><span class="s1">? this.tsParseInferType()</span><span class="s2">\n        </span><span class="s1">: this.tsInAllowConditionalTypesContext(() =&gt;</span><span class="s2">\n            </span><span class="s1">this.tsParseArrayTypeOrHigher(),</span><span class="s2">\n          </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsParseUnionOrIntersectionType(</span><span class="s2">\n      </span><span class="s1">kind: </span><span class="s2">\&quot;</span><span class="s1">TSUnionType</span><span class="s2">\&quot; </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">TSIntersectionType</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">parseConstituentType: () =&gt; N.TsType,</span><span class="s2">\n      </span><span class="s1">operator: TokenType,</span><span class="s2">\n    </span><span class="s1">): N.TsType {</span><span class="s2">\n      </span><span class="s1">const node = this.startNode&lt;N.TsUnionType | N.TsIntersectionType&gt;();</span><span class="s2">\n      </span><span class="s1">const hasLeadingOperator = this.eat(operator);</span><span class="s2">\n      </span><span class="s1">const types = [];</span><span class="s2">\n      </span><span class="s1">do {</span><span class="s2">\n        </span><span class="s1">types.push(parseConstituentType());</span><span class="s2">\n      </span><span class="s1">} while (this.eat(operator));</span><span class="s2">\n      </span><span class="s1">if (types.length === 1 &amp;&amp; !hasLeadingOperator) {</span><span class="s2">\n        </span><span class="s1">return types[0];</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">node.types = types;</span><span class="s2">\n      </span><span class="s1">return this.finishNode(node, kind);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsParseIntersectionTypeOrHigher(): N.TsType {</span><span class="s2">\n      </span><span class="s1">return this.tsParseUnionOrIntersectionType(</span><span class="s2">\n        \&quot;</span><span class="s1">TSIntersectionType</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">this.tsParseTypeOperatorOrHigher.bind(this),</span><span class="s2">\n        </span><span class="s1">tt.bitwiseAND,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsParseUnionTypeOrHigher() {</span><span class="s2">\n      </span><span class="s1">return this.tsParseUnionOrIntersectionType(</span><span class="s2">\n        \&quot;</span><span class="s1">TSUnionType</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">this.tsParseIntersectionTypeOrHigher.bind(this),</span><span class="s2">\n        </span><span class="s1">tt.bitwiseOR,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsIsStartOfFunctionType() {</span><span class="s2">\n      </span><span class="s1">if (this.match(tt.lt)) {</span><span class="s2">\n        </span><span class="s1">return true;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return (</span><span class="s2">\n        </span><span class="s1">this.match(tt.parenL) &amp;&amp;</span><span class="s2">\n        </span><span class="s1">this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this))</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsSkipParameterStart(): boolean {</span><span class="s2">\n      </span><span class="s1">if (tokenIsIdentifier(this.state.type) || this.match(tt._this)) {</span><span class="s2">\n        </span><span class="s1">this.next();</span><span class="s2">\n        </span><span class="s1">return true;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">if (this.match(tt.braceL)) {</span><span class="s2">\n        </span><span class="s1">// Return true if we can parse an object pattern without errors</span><span class="s2">\n        </span><span class="s1">const { errors } = this.state;</span><span class="s2">\n        </span><span class="s1">const previousErrorCount = errors.length;</span><span class="s2">\n        </span><span class="s1">try {</span><span class="s2">\n          </span><span class="s1">this.parseObjectLike(tt.braceR, true);</span><span class="s2">\n          </span><span class="s1">return errors.length === previousErrorCount;</span><span class="s2">\n        </span><span class="s1">} catch {</span><span class="s2">\n          </span><span class="s1">return false;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">if (this.match(tt.bracketL)) {</span><span class="s2">\n        </span><span class="s1">this.next();</span><span class="s2">\n        </span><span class="s1">// Return true if we can parse an array pattern without errors</span><span class="s2">\n        </span><span class="s1">const { errors } = this.state;</span><span class="s2">\n        </span><span class="s1">const previousErrorCount = errors.length;</span><span class="s2">\n        </span><span class="s1">try {</span><span class="s2">\n          </span><span class="s1">super.parseBindingList(</span><span class="s2">\n            </span><span class="s1">tt.bracketR,</span><span class="s2">\n            </span><span class="s1">charCodes.rightSquareBracket,</span><span class="s2">\n            </span><span class="s1">ParseBindingListFlags.ALLOW_EMPTY,</span><span class="s2">\n          </span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">return errors.length === previousErrorCount;</span><span class="s2">\n        </span><span class="s1">} catch {</span><span class="s2">\n          </span><span class="s1">return false;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return false;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsIsUnambiguouslyStartOfFunctionType(): boolean {</span><span class="s2">\n      </span><span class="s1">this.next();</span><span class="s2">\n      </span><span class="s1">if (this.match(tt.parenR) || this.match(tt.ellipsis)) {</span><span class="s2">\n        </span><span class="s1">// ( )</span><span class="s2">\n        </span><span class="s1">// ( ...</span><span class="s2">\n        </span><span class="s1">return true;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (this.tsSkipParameterStart()) {</span><span class="s2">\n        </span><span class="s1">if (</span><span class="s2">\n          </span><span class="s1">this.match(tt.colon) ||</span><span class="s2">\n          </span><span class="s1">this.match(tt.comma) ||</span><span class="s2">\n          </span><span class="s1">this.match(tt.question) ||</span><span class="s2">\n          </span><span class="s1">this.match(tt.eq)</span><span class="s2">\n        </span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">// ( xxx :</span><span class="s2">\n          </span><span class="s1">// ( xxx ,</span><span class="s2">\n          </span><span class="s1">// ( xxx ?</span><span class="s2">\n          </span><span class="s1">// ( xxx =</span><span class="s2">\n          </span><span class="s1">return true;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (this.match(tt.parenR)) {</span><span class="s2">\n          </span><span class="s1">this.next();</span><span class="s2">\n          </span><span class="s1">if (this.match(tt.arrow)) {</span><span class="s2">\n            </span><span class="s1">// ( xxx ) =&gt;</span><span class="s2">\n            </span><span class="s1">return true;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return false;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsParseTypeOrTypePredicateAnnotation(</span><span class="s2">\n      </span><span class="s1">returnToken: TokenType,</span><span class="s2">\n    </span><span class="s1">): N.TsTypeAnnotation {</span><span class="s2">\n      </span><span class="s1">return this.tsInType(() =&gt; {</span><span class="s2">\n        </span><span class="s1">const t = this.startNode&lt;N.TsTypeAnnotation&gt;();</span><span class="s2">\n        </span><span class="s1">this.expect(returnToken);</span><span class="s2">\n\n        </span><span class="s1">const node = this.startNode&lt;N.TsTypePredicate&gt;();</span><span class="s2">\n\n        </span><span class="s1">const asserts = !!this.tsTryParse(</span><span class="s2">\n          </span><span class="s1">this.tsParseTypePredicateAsserts.bind(this),</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n\n        </span><span class="s1">if (asserts &amp;&amp; this.match(tt._this)) {</span><span class="s2">\n          </span><span class="s1">// When asserts is false, thisKeyword is handled by tsParseNonArrayType</span><span class="s2">\n          </span><span class="s1">// : asserts this is type</span><span class="s2">\n          </span><span class="s1">let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();</span><span class="s2">\n          </span><span class="s1">// if it turns out to be a `TSThisType`, wrap it with `TSTypePredicate`</span><span class="s2">\n          </span><span class="s1">// : asserts this</span><span class="s2">\n          </span><span class="s1">if (thisTypePredicate.type === </span><span class="s2">\&quot;</span><span class="s1">TSThisType</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n            </span><span class="s1">node.parameterName = thisTypePredicate;</span><span class="s2">\n            </span><span class="s1">node.asserts = true;</span><span class="s2">\n            </span><span class="s1">(node as N.TsTypePredicate).typeAnnotation = null;</span><span class="s2">\n            </span><span class="s1">thisTypePredicate = this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">TSTypePredicate</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">} else {</span><span class="s2">\n            </span><span class="s1">this.resetStartLocationFromNode(thisTypePredicate, node);</span><span class="s2">\n            </span><span class="s1">thisTypePredicate.asserts = true;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">t.typeAnnotation = thisTypePredicate;</span><span class="s2">\n          </span><span class="s1">return this.finishNode(t, </span><span class="s2">\&quot;</span><span class="s1">TSTypeAnnotation</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">const typePredicateVariable =</span><span class="s2">\n          </span><span class="s1">this.tsIsIdentifier() &amp;&amp;</span><span class="s2">\n          </span><span class="s1">this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));</span><span class="s2">\n\n        </span><span class="s1">if (!typePredicateVariable) {</span><span class="s2">\n          </span><span class="s1">if (!asserts) {</span><span class="s2">\n            </span><span class="s1">// : type</span><span class="s2">\n            </span><span class="s1">return this.tsParseTypeAnnotation(/* eatColon */ false, t);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n\n          </span><span class="s1">// : asserts foo</span><span class="s2">\n          </span><span class="s1">node.parameterName = this.parseIdentifier();</span><span class="s2">\n          </span><span class="s1">node.asserts = asserts;</span><span class="s2">\n          </span><span class="s1">(node as N.TsTypePredicate).typeAnnotation = null;</span><span class="s2">\n          </span><span class="s1">t.typeAnnotation = this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">TSTypePredicate</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">return this.finishNode(t, </span><span class="s2">\&quot;</span><span class="s1">TSTypeAnnotation</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">// : asserts foo is type</span><span class="s2">\n        </span><span class="s1">const type = this.tsParseTypeAnnotation(/* eatColon */ false);</span><span class="s2">\n        </span><span class="s1">node.parameterName = typePredicateVariable;</span><span class="s2">\n        </span><span class="s1">node.typeAnnotation = type;</span><span class="s2">\n        </span><span class="s1">node.asserts = asserts;</span><span class="s2">\n        </span><span class="s1">t.typeAnnotation = this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">TSTypePredicate</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">return this.finishNode(t, </span><span class="s2">\&quot;</span><span class="s1">TSTypeAnnotation</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsTryParseTypeOrTypePredicateAnnotation():</span><span class="s2">\n      </span><span class="s1">| N.TsTypeAnnotation</span><span class="s2">\n      </span><span class="s1">| undefined</span><span class="s2">\n      </span><span class="s1">| null {</span><span class="s2">\n      </span><span class="s1">return this.match(tt.colon)</span><span class="s2">\n        </span><span class="s1">? this.tsParseTypeOrTypePredicateAnnotation(tt.colon)</span><span class="s2">\n        </span><span class="s1">: undefined;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsTryParseTypeAnnotation(): N.TsTypeAnnotation | undefined | null {</span><span class="s2">\n      </span><span class="s1">return this.match(tt.colon) ? this.tsParseTypeAnnotation() : undefined;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsTryParseType(): N.TsType | undefined | null {</span><span class="s2">\n      </span><span class="s1">return this.tsEatThenParseType(tt.colon);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsParseTypePredicatePrefix(): N.Identifier | undefined | null {</span><span class="s2">\n      </span><span class="s1">const id = this.parseIdentifier();</span><span class="s2">\n      </span><span class="s1">if (this.isContextual(tt._is) &amp;&amp; !this.hasPrecedingLineBreak()) {</span><span class="s2">\n        </span><span class="s1">this.next();</span><span class="s2">\n        </span><span class="s1">return id;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsParseTypePredicateAsserts(): boolean {</span><span class="s2">\n      </span><span class="s1">if (this.state.type !== tt._asserts) {</span><span class="s2">\n        </span><span class="s1">return false;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">const containsEsc = this.state.containsEsc;</span><span class="s2">\n      </span><span class="s1">this.next();</span><span class="s2">\n      </span><span class="s1">if (!tokenIsIdentifier(this.state.type) &amp;&amp; !this.match(tt._this)) {</span><span class="s2">\n        </span><span class="s1">return false;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">if (containsEsc) {</span><span class="s2">\n        </span><span class="s1">this.raise(Errors.InvalidEscapedReservedWord, {</span><span class="s2">\n          </span><span class="s1">at: this.state.lastTokStartLoc,</span><span class="s2">\n          </span><span class="s1">reservedWord: </span><span class="s2">\&quot;</span><span class="s1">asserts</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return true;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsParseTypeAnnotation(</span><span class="s2">\n      </span><span class="s1">eatColon = true,</span><span class="s2">\n      </span><span class="s1">t: Undone&lt;N.TsTypeAnnotation&gt; = this.startNode&lt;N.TsTypeAnnotation&gt;(),</span><span class="s2">\n    </span><span class="s1">): N.TsTypeAnnotation {</span><span class="s2">\n      </span><span class="s1">this.tsInType(() =&gt; {</span><span class="s2">\n        </span><span class="s1">if (eatColon) this.expect(tt.colon);</span><span class="s2">\n        </span><span class="s1">t.typeAnnotation = this.tsParseType();</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">return this.finishNode(t, </span><span class="s2">\&quot;</span><span class="s1">TSTypeAnnotation</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">/** Be sure to be in a type context before calling this, using `tsInType`. */</span><span class="s2">\n    </span><span class="s1">tsParseType(): N.TsType {</span><span class="s2">\n      </span><span class="s1">// Need to set `state.inType` so that we don't parse JSX in a type context.</span><span class="s2">\n      </span><span class="s1">assert(this.state.inType);</span><span class="s2">\n      </span><span class="s1">const type = this.tsParseNonConditionalType();</span><span class="s2">\n\n      </span><span class="s1">if (</span><span class="s2">\n        </span><span class="s1">this.state.inDisallowConditionalTypesContext ||</span><span class="s2">\n        </span><span class="s1">this.hasPrecedingLineBreak() ||</span><span class="s2">\n        </span><span class="s1">!this.eat(tt._extends)</span><span class="s2">\n      </span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">return type;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">const node = this.startNodeAtNode&lt;N.TsConditionalType&gt;(type);</span><span class="s2">\n      </span><span class="s1">node.checkType = type;</span><span class="s2">\n\n      </span><span class="s1">node.extendsType = this.tsInDisallowConditionalTypesContext(() =&gt;</span><span class="s2">\n        </span><span class="s1">this.tsParseNonConditionalType(),</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n\n      </span><span class="s1">this.expect(tt.question);</span><span class="s2">\n      </span><span class="s1">node.trueType = this.tsInAllowConditionalTypesContext(() =&gt;</span><span class="s2">\n        </span><span class="s1">this.tsParseType(),</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n\n      </span><span class="s1">this.expect(tt.colon);</span><span class="s2">\n      </span><span class="s1">node.falseType = this.tsInAllowConditionalTypesContext(() =&gt;</span><span class="s2">\n        </span><span class="s1">this.tsParseType(),</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">TSConditionalType</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">isAbstractConstructorSignature(): boolean {</span><span class="s2">\n      </span><span class="s1">return (</span><span class="s2">\n        </span><span class="s1">this.isContextual(tt._abstract) &amp;&amp; this.lookahead().type === tt._new</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsParseNonConditionalType(): N.TsType {</span><span class="s2">\n      </span><span class="s1">if (this.tsIsStartOfFunctionType()) {</span><span class="s2">\n        </span><span class="s1">return this.tsParseFunctionOrConstructorType(</span><span class="s2">\&quot;</span><span class="s1">TSFunctionType</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (this.match(tt._new)) {</span><span class="s2">\n        </span><span class="s1">// As in `new () =&gt; Date`</span><span class="s2">\n        </span><span class="s1">return this.tsParseFunctionOrConstructorType(</span><span class="s2">\&quot;</span><span class="s1">TSConstructorType</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">} else if (this.isAbstractConstructorSignature()) {</span><span class="s2">\n        </span><span class="s1">// As in `abstract new () =&gt; Date`</span><span class="s2">\n        </span><span class="s1">return this.tsParseFunctionOrConstructorType(</span><span class="s2">\n          \&quot;</span><span class="s1">TSConstructorType</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n          </span><span class="s1">/* abstract */ true,</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return this.tsParseUnionTypeOrHigher();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsParseTypeAssertion(): N.TsTypeAssertion {</span><span class="s2">\n      </span><span class="s1">if (this.getPluginOption(</span><span class="s2">\&quot;</span><span class="s1">typescript</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">disallowAmbiguousJSXLike</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n        </span><span class="s1">this.raise(TSErrors.ReservedTypeAssertion, { at: this.state.startLoc });</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">const node = this.startNode&lt;N.TsTypeAssertion&gt;();</span><span class="s2">\n      </span><span class="s1">node.typeAnnotation = this.tsInType(() =&gt; {</span><span class="s2">\n        </span><span class="s1">this.next(); // </span><span class="s2">\&quot;</span><span class="s1">&lt;</span><span class="s2">\&quot;\n        </span><span class="s1">return this.match(tt._const)</span><span class="s2">\n          </span><span class="s1">? this.tsParseTypeReference()</span><span class="s2">\n          </span><span class="s1">: this.tsParseType();</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">this.expect(tt.gt);</span><span class="s2">\n      </span><span class="s1">node.expression = this.parseMaybeUnary();</span><span class="s2">\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">TSTypeAssertion</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsParseHeritageClause(</span><span class="s2">\n      </span><span class="s1">token: </span><span class="s2">\&quot;</span><span class="s1">extends</span><span class="s2">\&quot; </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">implements</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">): Array&lt;N.TsExpressionWithTypeArguments&gt; {</span><span class="s2">\n      </span><span class="s1">const originalStartLoc = this.state.startLoc;</span><span class="s2">\n\n      </span><span class="s1">const delimitedList = this.tsParseDelimitedList(</span><span class="s2">\n        \&quot;</span><span class="s1">HeritageClauseElement</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">() =&gt; {</span><span class="s2">\n          </span><span class="s1">const node = this.startNode&lt;N.TsExpressionWithTypeArguments&gt;();</span><span class="s2">\n          </span><span class="s1">node.expression = this.tsParseEntityName();</span><span class="s2">\n          </span><span class="s1">if (this.match(tt.lt)) {</span><span class="s2">\n            </span><span class="s1">node.typeParameters = this.tsParseTypeArguments();</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n\n          </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">TSExpressionWithTypeArguments</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n\n      </span><span class="s1">if (!delimitedList.length) {</span><span class="s2">\n        </span><span class="s1">this.raise(TSErrors.EmptyHeritageClauseType, {</span><span class="s2">\n          </span><span class="s1">at: originalStartLoc,</span><span class="s2">\n          </span><span class="s1">token,</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return delimitedList;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsParseInterfaceDeclaration(</span><span class="s2">\n      </span><span class="s1">node: Undone&lt;N.TsInterfaceDeclaration&gt;,</span><span class="s2">\n      </span><span class="s1">properties: {</span><span class="s2">\n        </span><span class="s1">declare?: true;</span><span class="s2">\n      </span><span class="s1">} = {},</span><span class="s2">\n    </span><span class="s1">): N.TsInterfaceDeclaration | undefined | null {</span><span class="s2">\n      </span><span class="s1">if (this.hasFollowingLineBreak()) return null;</span><span class="s2">\n      </span><span class="s1">this.expectContextual(tt._interface);</span><span class="s2">\n      </span><span class="s1">if (properties.declare) node.declare = true;</span><span class="s2">\n      </span><span class="s1">if (tokenIsIdentifier(this.state.type)) {</span><span class="s2">\n        </span><span class="s1">node.id = this.parseIdentifier();</span><span class="s2">\n        </span><span class="s1">this.checkIdentifier(node.id, BIND_TS_INTERFACE);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">node.id = null;</span><span class="s2">\n        </span><span class="s1">this.raise(TSErrors.MissingInterfaceName, { at: this.state.startLoc });</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">node.typeParameters = this.tsTryParseTypeParameters(</span><span class="s2">\n        </span><span class="s1">this.tsParseInOutConstModifiers,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">if (this.eat(tt._extends)) {</span><span class="s2">\n        </span><span class="s1">node.extends = this.tsParseHeritageClause(</span><span class="s2">\&quot;</span><span class="s1">extends</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">const body = this.startNode&lt;N.TSInterfaceBody&gt;();</span><span class="s2">\n      </span><span class="s1">body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));</span><span class="s2">\n      </span><span class="s1">node.body = this.finishNode(body, </span><span class="s2">\&quot;</span><span class="s1">TSInterfaceBody</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">TSInterfaceDeclaration</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsParseTypeAliasDeclaration(</span><span class="s2">\n      </span><span class="s1">node: N.TsTypeAliasDeclaration,</span><span class="s2">\n    </span><span class="s1">): N.TsTypeAliasDeclaration {</span><span class="s2">\n      </span><span class="s1">node.id = this.parseIdentifier();</span><span class="s2">\n      </span><span class="s1">this.checkIdentifier(node.id, BIND_TS_TYPE);</span><span class="s2">\n\n      </span><span class="s1">node.typeAnnotation = this.tsInType(() =&gt; {</span><span class="s2">\n        </span><span class="s1">node.typeParameters = this.tsTryParseTypeParameters(</span><span class="s2">\n          </span><span class="s1">this.tsParseInOutModifiers,</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n\n        </span><span class="s1">this.expect(tt.eq);</span><span class="s2">\n\n        </span><span class="s1">if (</span><span class="s2">\n          </span><span class="s1">this.isContextual(tt._intrinsic) &amp;&amp;</span><span class="s2">\n          </span><span class="s1">this.lookahead().type !== tt.dot</span><span class="s2">\n        </span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">const node = this.startNode&lt;N.TsKeywordType&gt;();</span><span class="s2">\n          </span><span class="s1">this.next();</span><span class="s2">\n          </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">TSIntrinsicKeyword</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">return this.tsParseType();</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n\n      </span><span class="s1">this.semicolon();</span><span class="s2">\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">TSTypeAliasDeclaration</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsInNoContext&lt;T&gt;(cb: () =&gt; T): T {</span><span class="s2">\n      </span><span class="s1">const oldContext = this.state.context;</span><span class="s2">\n      </span><span class="s1">this.state.context = [oldContext[0]];</span><span class="s2">\n      </span><span class="s1">try {</span><span class="s2">\n        </span><span class="s1">return cb();</span><span class="s2">\n      </span><span class="s1">} finally {</span><span class="s2">\n        </span><span class="s1">this.state.context = oldContext;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">/**</span><span class="s2">\n     </span><span class="s1">* Runs `cb` in a type context.</span><span class="s2">\n     </span><span class="s1">* This should be called one token *before* the first type token,</span><span class="s2">\n     </span><span class="s1">* so that the call to `next()` is run in type context.</span><span class="s2">\n     </span><span class="s1">*/</span><span class="s2">\n    </span><span class="s1">tsInType&lt;T&gt;(cb: () =&gt; T): T {</span><span class="s2">\n      </span><span class="s1">const oldInType = this.state.inType;</span><span class="s2">\n      </span><span class="s1">this.state.inType = true;</span><span class="s2">\n      </span><span class="s1">try {</span><span class="s2">\n        </span><span class="s1">return cb();</span><span class="s2">\n      </span><span class="s1">} finally {</span><span class="s2">\n        </span><span class="s1">this.state.inType = oldInType;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsInDisallowConditionalTypesContext&lt;T&gt;(cb: () =&gt; T): T {</span><span class="s2">\n      </span><span class="s1">const oldInDisallowConditionalTypesContext =</span><span class="s2">\n        </span><span class="s1">this.state.inDisallowConditionalTypesContext;</span><span class="s2">\n      </span><span class="s1">this.state.inDisallowConditionalTypesContext = true;</span><span class="s2">\n      </span><span class="s1">try {</span><span class="s2">\n        </span><span class="s1">return cb();</span><span class="s2">\n      </span><span class="s1">} finally {</span><span class="s2">\n        </span><span class="s1">this.state.inDisallowConditionalTypesContext =</span><span class="s2">\n          </span><span class="s1">oldInDisallowConditionalTypesContext;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsInAllowConditionalTypesContext&lt;T&gt;(cb: () =&gt; T): T {</span><span class="s2">\n      </span><span class="s1">const oldInDisallowConditionalTypesContext =</span><span class="s2">\n        </span><span class="s1">this.state.inDisallowConditionalTypesContext;</span><span class="s2">\n      </span><span class="s1">this.state.inDisallowConditionalTypesContext = false;</span><span class="s2">\n      </span><span class="s1">try {</span><span class="s2">\n        </span><span class="s1">return cb();</span><span class="s2">\n      </span><span class="s1">} finally {</span><span class="s2">\n        </span><span class="s1">this.state.inDisallowConditionalTypesContext =</span><span class="s2">\n          </span><span class="s1">oldInDisallowConditionalTypesContext;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsEatThenParseType(token: TokenType): N.TsType | undefined {</span><span class="s2">\n      </span><span class="s1">return !this.match(token) ? undefined : this.tsNextThenParseType();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsExpectThenParseType(token: TokenType): N.TsType {</span><span class="s2">\n      </span><span class="s1">return this.tsDoThenParseType(() =&gt; this.expect(token));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsNextThenParseType(): N.TsType {</span><span class="s2">\n      </span><span class="s1">return this.tsDoThenParseType(() =&gt; this.next());</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsDoThenParseType(cb: () =&gt; void): N.TsType {</span><span class="s2">\n      </span><span class="s1">return this.tsInType(() =&gt; {</span><span class="s2">\n        </span><span class="s1">cb();</span><span class="s2">\n        </span><span class="s1">return this.tsParseType();</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsParseEnumMember(): N.TsEnumMember {</span><span class="s2">\n      </span><span class="s1">const node = this.startNode&lt;N.TsEnumMember&gt;();</span><span class="s2">\n      </span><span class="s1">// Computed property names are grammar errors in an enum, so accept just string literal or identifier.</span><span class="s2">\n      </span><span class="s1">node.id = this.match(tt.string)</span><span class="s2">\n        </span><span class="s1">? super.parseStringLiteral(this.state.value)</span><span class="s2">\n        </span><span class="s1">: this.parseIdentifier(/* liberal */ true);</span><span class="s2">\n      </span><span class="s1">if (this.eat(tt.eq)) {</span><span class="s2">\n        </span><span class="s1">node.initializer = super.parseMaybeAssignAllowIn();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">TSEnumMember</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsParseEnumDeclaration(</span><span class="s2">\n      </span><span class="s1">node: Undone&lt;N.TsEnumDeclaration&gt;,</span><span class="s2">\n      </span><span class="s1">properties: {</span><span class="s2">\n        </span><span class="s1">const?: true;</span><span class="s2">\n        </span><span class="s1">declare?: true;</span><span class="s2">\n      </span><span class="s1">} = {},</span><span class="s2">\n    </span><span class="s1">): N.TsEnumDeclaration {</span><span class="s2">\n      </span><span class="s1">if (properties.const) node.const = true;</span><span class="s2">\n      </span><span class="s1">if (properties.declare) node.declare = true;</span><span class="s2">\n      </span><span class="s1">this.expectContextual(tt._enum);</span><span class="s2">\n      </span><span class="s1">node.id = this.parseIdentifier();</span><span class="s2">\n      </span><span class="s1">this.checkIdentifier(</span><span class="s2">\n        </span><span class="s1">node.id,</span><span class="s2">\n        </span><span class="s1">node.const ? BIND_TS_CONST_ENUM : BIND_TS_ENUM,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n\n      </span><span class="s1">this.expect(tt.braceL);</span><span class="s2">\n      </span><span class="s1">node.members = this.tsParseDelimitedList(</span><span class="s2">\n        \&quot;</span><span class="s1">EnumMembers</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">this.tsParseEnumMember.bind(this),</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">this.expect(tt.braceR);</span><span class="s2">\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">TSEnumDeclaration</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsParseModuleBlock(): N.TsModuleBlock {</span><span class="s2">\n      </span><span class="s1">const node = this.startNode&lt;N.TsModuleBlock&gt;();</span><span class="s2">\n      </span><span class="s1">this.scope.enter(SCOPE_OTHER);</span><span class="s2">\n\n      </span><span class="s1">this.expect(tt.braceL);</span><span class="s2">\n      </span><span class="s1">// Inside of a module block is considered </span><span class="s2">\&quot;</span><span class="s1">top-level</span><span class="s2">\&quot;</span><span class="s1">, meaning it can have imports and exports.</span><span class="s2">\n      </span><span class="s1">super.parseBlockOrModuleBlockBody(</span><span class="s2">\n        </span><span class="s1">(node.body = []),</span><span class="s2">\n        </span><span class="s1">/* directives */ undefined,</span><span class="s2">\n        </span><span class="s1">/* topLevel */ true,</span><span class="s2">\n        </span><span class="s1">/* end */ tt.braceR,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">this.scope.exit();</span><span class="s2">\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">TSModuleBlock</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsParseModuleOrNamespaceDeclaration(</span><span class="s2">\n      </span><span class="s1">node: Undone&lt;N.TsModuleDeclaration&gt;,</span><span class="s2">\n      </span><span class="s1">nested: boolean = false,</span><span class="s2">\n    </span><span class="s1">): N.TsModuleDeclaration {</span><span class="s2">\n      </span><span class="s1">node.id = this.parseIdentifier();</span><span class="s2">\n\n      </span><span class="s1">if (!nested) {</span><span class="s2">\n        </span><span class="s1">this.checkIdentifier(node.id, BIND_TS_NAMESPACE);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">if (this.eat(tt.dot)) {</span><span class="s2">\n        </span><span class="s1">const inner = this.startNode&lt;N.TsModuleDeclaration&gt;();</span><span class="s2">\n        </span><span class="s1">this.tsParseModuleOrNamespaceDeclaration(inner, true);</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error Fixme: refine typings</span><span class="s2">\n        </span><span class="s1">node.body = inner;</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">this.scope.enter(SCOPE_TS_MODULE);</span><span class="s2">\n        </span><span class="s1">this.prodParam.enter(PARAM);</span><span class="s2">\n        </span><span class="s1">node.body = this.tsParseModuleBlock();</span><span class="s2">\n        </span><span class="s1">this.prodParam.exit();</span><span class="s2">\n        </span><span class="s1">this.scope.exit();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">TSModuleDeclaration</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsParseAmbientExternalModuleDeclaration(</span><span class="s2">\n      </span><span class="s1">node: N.TsModuleDeclaration,</span><span class="s2">\n    </span><span class="s1">): N.TsModuleDeclaration {</span><span class="s2">\n      </span><span class="s1">if (this.isContextual(tt._global)) {</span><span class="s2">\n        </span><span class="s1">node.global = true;</span><span class="s2">\n        </span><span class="s1">node.id = this.parseIdentifier();</span><span class="s2">\n      </span><span class="s1">} else if (this.match(tt.string)) {</span><span class="s2">\n        </span><span class="s1">node.id = super.parseStringLiteral(this.state.value);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">this.unexpected();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (this.match(tt.braceL)) {</span><span class="s2">\n        </span><span class="s1">this.scope.enter(SCOPE_TS_MODULE);</span><span class="s2">\n        </span><span class="s1">this.prodParam.enter(PARAM);</span><span class="s2">\n        </span><span class="s1">node.body = this.tsParseModuleBlock();</span><span class="s2">\n        </span><span class="s1">this.prodParam.exit();</span><span class="s2">\n        </span><span class="s1">this.scope.exit();</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">this.semicolon();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">TSModuleDeclaration</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsParseImportEqualsDeclaration(</span><span class="s2">\n      </span><span class="s1">node: Undone&lt;N.TsImportEqualsDeclaration&gt;,</span><span class="s2">\n      </span><span class="s1">isExport?: boolean,</span><span class="s2">\n    </span><span class="s1">): N.TsImportEqualsDeclaration {</span><span class="s2">\n      </span><span class="s1">node.isExport = isExport || false;</span><span class="s2">\n      </span><span class="s1">node.id = this.parseIdentifier();</span><span class="s2">\n      </span><span class="s1">this.checkIdentifier(node.id, BIND_FLAGS_TS_IMPORT);</span><span class="s2">\n      </span><span class="s1">this.expect(tt.eq);</span><span class="s2">\n      </span><span class="s1">const moduleReference = this.tsParseModuleReference();</span><span class="s2">\n      </span><span class="s1">if (</span><span class="s2">\n        </span><span class="s1">node.importKind === </span><span class="s2">\&quot;</span><span class="s1">type</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n        </span><span class="s1">moduleReference.type !== </span><span class="s2">\&quot;</span><span class="s1">TSExternalModuleReference</span><span class="s2">\&quot;\n      </span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">this.raise(TSErrors.ImportAliasHasImportType, {</span><span class="s2">\n          </span><span class="s1">at: moduleReference,</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">node.moduleReference = moduleReference;</span><span class="s2">\n      </span><span class="s1">this.semicolon();</span><span class="s2">\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">TSImportEqualsDeclaration</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsIsExternalModuleReference(): boolean {</span><span class="s2">\n      </span><span class="s1">return (</span><span class="s2">\n        </span><span class="s1">this.isContextual(tt._require) &amp;&amp;</span><span class="s2">\n        </span><span class="s1">this.lookaheadCharCode() === charCodes.leftParenthesis</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsParseModuleReference(): N.TsModuleReference {</span><span class="s2">\n      </span><span class="s1">return this.tsIsExternalModuleReference()</span><span class="s2">\n        </span><span class="s1">? this.tsParseExternalModuleReference()</span><span class="s2">\n        </span><span class="s1">: this.tsParseEntityName(/* allowReservedWords */ false);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsParseExternalModuleReference(): N.TsExternalModuleReference {</span><span class="s2">\n      </span><span class="s1">const node = this.startNode&lt;N.TsExternalModuleReference&gt;();</span><span class="s2">\n      </span><span class="s1">this.expectContextual(tt._require);</span><span class="s2">\n      </span><span class="s1">this.expect(tt.parenL);</span><span class="s2">\n      </span><span class="s1">if (!this.match(tt.string)) {</span><span class="s2">\n        </span><span class="s1">this.unexpected();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">// For compatibility to estree we cannot call parseLiteral directly here</span><span class="s2">\n      </span><span class="s1">node.expression = super.parseExprAtom() as N.StringLiteral;</span><span class="s2">\n      </span><span class="s1">this.expect(tt.parenR);</span><span class="s2">\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">TSExternalModuleReference</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// Utilities</span><span class="s2">\n\n    </span><span class="s1">tsLookAhead&lt;T&gt;(f: () =&gt; T): T {</span><span class="s2">\n      </span><span class="s1">const state = this.state.clone();</span><span class="s2">\n      </span><span class="s1">const res = f();</span><span class="s2">\n      </span><span class="s1">this.state = state;</span><span class="s2">\n      </span><span class="s1">return res;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsTryParseAndCatch&lt;T extends N.NodeBase | undefined | null&gt;(</span><span class="s2">\n      </span><span class="s1">f: () =&gt; T,</span><span class="s2">\n    </span><span class="s1">): T | undefined | null {</span><span class="s2">\n      </span><span class="s1">const result = this.tryParse(</span><span class="s2">\n        </span><span class="s1">abort =&gt;</span><span class="s2">\n          </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts)</span><span class="s2">\n          </span><span class="s1">f() || abort(),</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n\n      </span><span class="s1">if (result.aborted || !result.node) return undefined;</span><span class="s2">\n      </span><span class="s1">if (result.error) this.state = result.failState;</span><span class="s2">\n      </span><span class="s1">// @ts-expect-error refine typings</span><span class="s2">\n      </span><span class="s1">return result.node;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsTryParse&lt;T&gt;(f: () =&gt; T | undefined | false): T | undefined {</span><span class="s2">\n      </span><span class="s1">const state = this.state.clone();</span><span class="s2">\n      </span><span class="s1">const result = f();</span><span class="s2">\n      </span><span class="s1">if (result !== undefined &amp;&amp; result !== false) {</span><span class="s2">\n        </span><span class="s1">return result;</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">this.state = state;</span><span class="s2">\n        </span><span class="s1">return undefined;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsTryParseDeclare(nany: any): N.Declaration | undefined | null {</span><span class="s2">\n      </span><span class="s1">if (this.isLineTerminator()) {</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">let starttype = this.state.type;</span><span class="s2">\n      </span><span class="s1">let kind: </span><span class="s2">\&quot;</span><span class="s1">let</span><span class="s2">\&quot; </span><span class="s1">| null;</span><span class="s2">\n\n      </span><span class="s1">if (this.isContextual(tt._let)) {</span><span class="s2">\n        </span><span class="s1">starttype = tt._var;</span><span class="s2">\n        </span><span class="s1">kind = </span><span class="s2">\&quot;</span><span class="s1">let</span><span class="s2">\&quot; </span><span class="s1">as const;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">// @ts-expect-error refine typings</span><span class="s2">\n      </span><span class="s1">return this.tsInAmbientContext(() =&gt; {</span><span class="s2">\n        </span><span class="s1">if (starttype === tt._function) {</span><span class="s2">\n          </span><span class="s1">nany.declare = true;</span><span class="s2">\n          </span><span class="s1">return super.parseFunctionStatement(</span><span class="s2">\n            </span><span class="s1">nany,</span><span class="s2">\n            </span><span class="s1">/* async */ false,</span><span class="s2">\n            </span><span class="s1">/* isHangingDeclaration */ false,</span><span class="s2">\n          </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">if (starttype === tt._class) {</span><span class="s2">\n          </span><span class="s1">// While this is also set by tsParseExpressionStatement, we need to set it</span><span class="s2">\n          </span><span class="s1">// before parsing the class declaration to know how to register it in the scope.</span><span class="s2">\n          </span><span class="s1">nany.declare = true;</span><span class="s2">\n          </span><span class="s1">return this.parseClass(</span><span class="s2">\n            </span><span class="s1">nany,</span><span class="s2">\n            </span><span class="s1">/* isStatement */ true,</span><span class="s2">\n            </span><span class="s1">/* optionalId */ false,</span><span class="s2">\n          </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">if (starttype === tt._enum) {</span><span class="s2">\n          </span><span class="s1">return this.tsParseEnumDeclaration(nany, { declare: true });</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">if (starttype === tt._global) {</span><span class="s2">\n          </span><span class="s1">return this.tsParseAmbientExternalModuleDeclaration(nany);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">if (starttype === tt._const || starttype === tt._var) {</span><span class="s2">\n          </span><span class="s1">if (!this.match(tt._const) || !this.isLookaheadContextual(</span><span class="s2">\&quot;</span><span class="s1">enum</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n            </span><span class="s1">nany.declare = true;</span><span class="s2">\n            </span><span class="s1">return this.parseVarStatement(nany, kind || this.state.value, true);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n\n          </span><span class="s1">// `const enum = 0;` not allowed because </span><span class="s2">\&quot;</span><span class="s1">enum</span><span class="s2">\&quot; </span><span class="s1">is a strict mode reserved word.</span><span class="s2">\n          </span><span class="s1">this.expect(tt._const);</span><span class="s2">\n          </span><span class="s1">return this.tsParseEnumDeclaration(nany, {</span><span class="s2">\n            </span><span class="s1">const: true,</span><span class="s2">\n            </span><span class="s1">declare: true,</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">if (starttype === tt._interface) {</span><span class="s2">\n          </span><span class="s1">const result = this.tsParseInterfaceDeclaration(nany, {</span><span class="s2">\n            </span><span class="s1">declare: true,</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n          </span><span class="s1">if (result) return result;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">if (tokenIsIdentifier(starttype)) {</span><span class="s2">\n          </span><span class="s1">return this.tsParseDeclaration(</span><span class="s2">\n            </span><span class="s1">nany,</span><span class="s2">\n            </span><span class="s1">this.state.value,</span><span class="s2">\n            </span><span class="s1">/* next */ true,</span><span class="s2">\n            </span><span class="s1">/* decorators */ null,</span><span class="s2">\n          </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// Note: this won't be called unless the keyword is allowed in `shouldParseExportDeclaration`.</span><span class="s2">\n    </span><span class="s1">tsTryParseExportDeclaration(): N.Declaration | undefined | null {</span><span class="s2">\n      </span><span class="s1">return this.tsParseDeclaration(</span><span class="s2">\n        </span><span class="s1">this.startNode(),</span><span class="s2">\n        </span><span class="s1">this.state.value,</span><span class="s2">\n        </span><span class="s1">/* next */ true,</span><span class="s2">\n        </span><span class="s1">/* decorators */ null,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsParseExpressionStatement(</span><span class="s2">\n      </span><span class="s1">node: Undone&lt;N.TsModuleDeclaration&gt;,</span><span class="s2">\n      </span><span class="s1">expr: N.Identifier,</span><span class="s2">\n      </span><span class="s1">decorators: N.Decorator[] | null,</span><span class="s2">\n    </span><span class="s1">): N.Declaration | undefined | null {</span><span class="s2">\n      </span><span class="s1">switch (expr.name) {</span><span class="s2">\n        </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">declare</span><span class="s2">\&quot;</span><span class="s1">: {</span><span class="s2">\n          </span><span class="s1">const declaration = this.tsTryParseDeclare(node);</span><span class="s2">\n          </span><span class="s1">if (declaration) {</span><span class="s2">\n            </span><span class="s1">declaration.declare = true;</span><span class="s2">\n            </span><span class="s1">return declaration;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">break;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">global</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n          </span><span class="s1">// `global { }` (with no `declare`) may appear inside an ambient module declaration.</span><span class="s2">\n          </span><span class="s1">// Would like to use tsParseAmbientExternalModuleDeclaration here, but already ran past </span><span class="s2">\&quot;</span><span class="s1">global</span><span class="s2">\&quot;</span><span class="s1">.</span><span class="s2">\n          </span><span class="s1">if (this.match(tt.braceL)) {</span><span class="s2">\n            </span><span class="s1">this.scope.enter(SCOPE_TS_MODULE);</span><span class="s2">\n            </span><span class="s1">this.prodParam.enter(PARAM);</span><span class="s2">\n            </span><span class="s1">const mod = node;</span><span class="s2">\n            </span><span class="s1">mod.global = true;</span><span class="s2">\n            </span><span class="s1">mod.id = expr;</span><span class="s2">\n            </span><span class="s1">mod.body = this.tsParseModuleBlock();</span><span class="s2">\n            </span><span class="s1">this.scope.exit();</span><span class="s2">\n            </span><span class="s1">this.prodParam.exit();</span><span class="s2">\n            </span><span class="s1">return this.finishNode(mod, </span><span class="s2">\&quot;</span><span class="s1">TSModuleDeclaration</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">break;</span><span class="s2">\n\n        </span><span class="s1">default:</span><span class="s2">\n          </span><span class="s1">return this.tsParseDeclaration(</span><span class="s2">\n            </span><span class="s1">node,</span><span class="s2">\n            </span><span class="s1">expr.name,</span><span class="s2">\n            </span><span class="s1">/* next */ false,</span><span class="s2">\n            </span><span class="s1">decorators,</span><span class="s2">\n          </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// Common to tsTryParseDeclare, tsTryParseExportDeclaration, and tsParseExpressionStatement.</span><span class="s2">\n    </span><span class="s1">tsParseDeclaration(</span><span class="s2">\n      </span><span class="s1">node: any,</span><span class="s2">\n      </span><span class="s1">value: string,</span><span class="s2">\n      </span><span class="s1">next: boolean,</span><span class="s2">\n      </span><span class="s1">decorators: N.Decorator[] | null,</span><span class="s2">\n    </span><span class="s1">): N.Declaration | undefined | null {</span><span class="s2">\n      </span><span class="s1">// no declaration apart from enum can be followed by a line break.</span><span class="s2">\n      </span><span class="s1">switch (value) {</span><span class="s2">\n        </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">abstract</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n          </span><span class="s1">if (</span><span class="s2">\n            </span><span class="s1">this.tsCheckLineTerminator(next) &amp;&amp;</span><span class="s2">\n            </span><span class="s1">(this.match(tt._class) || tokenIsIdentifier(this.state.type))</span><span class="s2">\n          </span><span class="s1">) {</span><span class="s2">\n            </span><span class="s1">return this.tsParseAbstractDeclaration(node, decorators);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">break;</span><span class="s2">\n\n        </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">module</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n          </span><span class="s1">if (this.tsCheckLineTerminator(next)) {</span><span class="s2">\n            </span><span class="s1">if (this.match(tt.string)) {</span><span class="s2">\n              </span><span class="s1">return this.tsParseAmbientExternalModuleDeclaration(node);</span><span class="s2">\n            </span><span class="s1">} else if (tokenIsIdentifier(this.state.type)) {</span><span class="s2">\n              </span><span class="s1">return this.tsParseModuleOrNamespaceDeclaration(node);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">break;</span><span class="s2">\n\n        </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">namespace</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n          </span><span class="s1">if (</span><span class="s2">\n            </span><span class="s1">this.tsCheckLineTerminator(next) &amp;&amp;</span><span class="s2">\n            </span><span class="s1">tokenIsIdentifier(this.state.type)</span><span class="s2">\n          </span><span class="s1">) {</span><span class="s2">\n            </span><span class="s1">return this.tsParseModuleOrNamespaceDeclaration(node);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">break;</span><span class="s2">\n\n        </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">type</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n          </span><span class="s1">if (</span><span class="s2">\n            </span><span class="s1">this.tsCheckLineTerminator(next) &amp;&amp;</span><span class="s2">\n            </span><span class="s1">tokenIsIdentifier(this.state.type)</span><span class="s2">\n          </span><span class="s1">) {</span><span class="s2">\n            </span><span class="s1">return this.tsParseTypeAliasDeclaration(node);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">break;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsCheckLineTerminator(next: boolean) {</span><span class="s2">\n      </span><span class="s1">if (next) {</span><span class="s2">\n        </span><span class="s1">if (this.hasFollowingLineBreak()) return false;</span><span class="s2">\n        </span><span class="s1">this.next();</span><span class="s2">\n        </span><span class="s1">return true;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return !this.isLineTerminator();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsTryParseGenericAsyncArrowFunction(</span><span class="s2">\n      </span><span class="s1">startLoc: Position,</span><span class="s2">\n    </span><span class="s1">): N.ArrowFunctionExpression | undefined | null {</span><span class="s2">\n      </span><span class="s1">if (!this.match(tt.lt)) {</span><span class="s2">\n        </span><span class="s1">return undefined;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;</span><span class="s2">\n      </span><span class="s1">this.state.maybeInArrowParameters = true;</span><span class="s2">\n\n      </span><span class="s1">const res: Undone&lt;N.ArrowFunctionExpression&gt; | undefined | null =</span><span class="s2">\n        </span><span class="s1">this.tsTryParseAndCatch(() =&gt; {</span><span class="s2">\n          </span><span class="s1">const node = this.startNodeAt&lt;N.ArrowFunctionExpression&gt;(startLoc);</span><span class="s2">\n          </span><span class="s1">node.typeParameters = this.tsParseTypeParameters(</span><span class="s2">\n            </span><span class="s1">this.tsParseConstModifier,</span><span class="s2">\n          </span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">// Don't use overloaded parseFunctionParams which would look for </span><span class="s2">\&quot;</span><span class="s1">&lt;</span><span class="s2">\&quot; </span><span class="s1">again.</span><span class="s2">\n          </span><span class="s1">super.parseFunctionParams(node);</span><span class="s2">\n          </span><span class="s1">node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();</span><span class="s2">\n          </span><span class="s1">this.expect(tt.arrow);</span><span class="s2">\n          </span><span class="s1">return node;</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n\n      </span><span class="s1">this.state.maybeInArrowParameters = oldMaybeInArrowParameters;</span><span class="s2">\n\n      </span><span class="s1">if (!res) {</span><span class="s2">\n        </span><span class="s1">return undefined;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return super.parseArrowExpression(</span><span class="s2">\n        </span><span class="s1">res,</span><span class="s2">\n        </span><span class="s1">/* params are already set */ null,</span><span class="s2">\n        </span><span class="s1">/* async */ true,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// Used when parsing type arguments from ES productions, where the first token</span><span class="s2">\n    </span><span class="s1">// has been created without state.inType. Thus we need to rescan the lt token.</span><span class="s2">\n    </span><span class="s1">tsParseTypeArgumentsInExpression(): N.TsTypeParameterInstantiation | void {</span><span class="s2">\n      </span><span class="s1">if (this.reScan_lt() !== tt.lt) {</span><span class="s2">\n        </span><span class="s1">return undefined;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return this.tsParseTypeArguments();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsParseTypeArguments(): N.TsTypeParameterInstantiation {</span><span class="s2">\n      </span><span class="s1">const node = this.startNode&lt;N.TsTypeParameterInstantiation&gt;();</span><span class="s2">\n      </span><span class="s1">node.params = this.tsInType(() =&gt;</span><span class="s2">\n        </span><span class="s1">// Temporarily remove a JSX parsing context, which makes us scan different tokens.</span><span class="s2">\n        </span><span class="s1">this.tsInNoContext(() =&gt; {</span><span class="s2">\n          </span><span class="s1">this.expect(tt.lt);</span><span class="s2">\n          </span><span class="s1">return this.tsParseDelimitedList(</span><span class="s2">\n            \&quot;</span><span class="s1">TypeParametersOrArguments</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n            </span><span class="s1">this.tsParseType.bind(this),</span><span class="s2">\n          </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">}),</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">if (node.params.length === 0) {</span><span class="s2">\n        </span><span class="s1">this.raise(TSErrors.EmptyTypeArguments, { at: node });</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">this.expect(tt.gt);</span><span class="s2">\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">TSTypeParameterInstantiation</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsIsDeclarationStart(): boolean {</span><span class="s2">\n      </span><span class="s1">return tokenIsTSDeclarationStart(this.state.type);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// ======================================================</span><span class="s2">\n    </span><span class="s1">// OVERRIDES</span><span class="s2">\n    </span><span class="s1">// ======================================================</span><span class="s2">\n\n    </span><span class="s1">isExportDefaultSpecifier(): boolean {</span><span class="s2">\n      </span><span class="s1">if (this.tsIsDeclarationStart()) return false;</span><span class="s2">\n      </span><span class="s1">return super.isExportDefaultSpecifier();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseAssignableListItem(</span><span class="s2">\n      </span><span class="s1">flags: ParseBindingListFlags,</span><span class="s2">\n      </span><span class="s1">decorators: N.Decorator[],</span><span class="s2">\n    </span><span class="s1">): N.Pattern | N.TSParameterProperty {</span><span class="s2">\n      </span><span class="s1">// Store original location to include modifiers in range</span><span class="s2">\n      </span><span class="s1">const startLoc = this.state.startLoc;</span><span class="s2">\n\n      </span><span class="s1">const modified: ModifierBase = {};</span><span class="s2">\n      </span><span class="s1">this.tsParseModifiers(</span><span class="s2">\n        </span><span class="s1">{</span><span class="s2">\n          </span><span class="s1">allowedModifiers: [</span><span class="s2">\n            \&quot;</span><span class="s1">public</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n            \&quot;</span><span class="s1">private</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n            \&quot;</span><span class="s1">protected</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n            \&quot;</span><span class="s1">override</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n            \&quot;</span><span class="s1">readonly</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n          </span><span class="s1">],</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">modified,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">const accessibility = modified.accessibility;</span><span class="s2">\n      </span><span class="s1">const override = modified.override;</span><span class="s2">\n      </span><span class="s1">const readonly = modified.readonly;</span><span class="s2">\n      </span><span class="s1">if (</span><span class="s2">\n        </span><span class="s1">!(flags &amp; ParseBindingListFlags.IS_CONSTRUCTOR_PARAMS) &amp;&amp;</span><span class="s2">\n        </span><span class="s1">(accessibility || readonly || override)</span><span class="s2">\n      </span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">this.raise(TSErrors.UnexpectedParameterModifier, { at: startLoc });</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">const left = this.parseMaybeDefault();</span><span class="s2">\n      </span><span class="s1">this.parseAssignableListItemTypes(left, flags);</span><span class="s2">\n      </span><span class="s1">const elt = this.parseMaybeDefault(left.loc.start, left);</span><span class="s2">\n      </span><span class="s1">if (accessibility || readonly || override) {</span><span class="s2">\n        </span><span class="s1">const pp = this.startNodeAt&lt;N.TSParameterProperty&gt;(startLoc);</span><span class="s2">\n        </span><span class="s1">if (decorators.length) {</span><span class="s2">\n          </span><span class="s1">pp.decorators = decorators;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (accessibility) pp.accessibility = accessibility;</span><span class="s2">\n        </span><span class="s1">if (readonly) pp.readonly = readonly;</span><span class="s2">\n        </span><span class="s1">if (override) pp.override = override;</span><span class="s2">\n        </span><span class="s1">if (elt.type !== </span><span class="s2">\&quot;</span><span class="s1">Identifier</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; elt.type !== </span><span class="s2">\&quot;</span><span class="s1">AssignmentPattern</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">this.raise(TSErrors.UnsupportedParameterPropertyKind, { at: pp });</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">pp.parameter = elt as any as N.Identifier | N.AssignmentPattern;</span><span class="s2">\n        </span><span class="s1">return this.finishNode(pp, </span><span class="s2">\&quot;</span><span class="s1">TSParameterProperty</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">if (decorators.length) {</span><span class="s2">\n        </span><span class="s1">left.decorators = decorators;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return elt;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">isSimpleParameter(node: N.Pattern | N.TSParameterProperty) {</span><span class="s2">\n      </span><span class="s1">return (</span><span class="s2">\n        </span><span class="s1">(node.type === </span><span class="s2">\&quot;</span><span class="s1">TSParameterProperty</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n          </span><span class="s1">super.isSimpleParameter(node.parameter)) ||</span><span class="s2">\n        </span><span class="s1">super.isSimpleParameter(node)</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsDisallowOptionalPattern(node: Undone&lt;N.Function&gt;) {</span><span class="s2">\n      </span><span class="s1">for (const param of node.params) {</span><span class="s2">\n        </span><span class="s1">if (</span><span class="s2">\n          </span><span class="s1">param.type !== </span><span class="s2">\&quot;</span><span class="s1">Identifier</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n          </span><span class="s1">(param as any).optional &amp;&amp;</span><span class="s2">\n          </span><span class="s1">!this.state.isAmbientContext</span><span class="s2">\n        </span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">this.raise(TSErrors.PatternIsOptional, { at: param });</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">setArrowFunctionParameters(</span><span class="s2">\n      </span><span class="s1">node: Undone&lt;N.ArrowFunctionExpression&gt;,</span><span class="s2">\n      </span><span class="s1">params: N.Expression[],</span><span class="s2">\n      </span><span class="s1">trailingCommaLoc?: Position | null,</span><span class="s2">\n    </span><span class="s1">): void {</span><span class="s2">\n      </span><span class="s1">super.setArrowFunctionParameters(node, params, trailingCommaLoc);</span><span class="s2">\n      </span><span class="s1">this.tsDisallowOptionalPattern(node);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseFunctionBodyAndFinish&lt;</span><span class="s2">\n      </span><span class="s1">T extends</span><span class="s2">\n        </span><span class="s1">| N.Function</span><span class="s2">\n        </span><span class="s1">| N.TSDeclareMethod</span><span class="s2">\n        </span><span class="s1">| N.TSDeclareFunction</span><span class="s2">\n        </span><span class="s1">| N.ClassPrivateMethod,</span><span class="s2">\n    </span><span class="s1">&gt;(node: Undone&lt;T&gt;, type: T[</span><span class="s2">\&quot;</span><span class="s1">type</span><span class="s2">\&quot;</span><span class="s1">], isMethod: boolean = false): T {</span><span class="s2">\n      </span><span class="s1">if (this.match(tt.colon)) {</span><span class="s2">\n        </span><span class="s1">node.returnType = this.tsParseTypeOrTypePredicateAnnotation(tt.colon);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">const bodilessType =</span><span class="s2">\n        </span><span class="s1">type === </span><span class="s2">\&quot;</span><span class="s1">FunctionDeclaration</span><span class="s2">\&quot;\n          </span><span class="s1">? </span><span class="s2">\&quot;</span><span class="s1">TSDeclareFunction</span><span class="s2">\&quot;\n          </span><span class="s1">: type === </span><span class="s2">\&quot;</span><span class="s1">ClassMethod</span><span class="s2">\&quot; </span><span class="s1">|| type === </span><span class="s2">\&quot;</span><span class="s1">ClassPrivateMethod</span><span class="s2">\&quot;\n          </span><span class="s1">? </span><span class="s2">\&quot;</span><span class="s1">TSDeclareMethod</span><span class="s2">\&quot;\n          </span><span class="s1">: undefined;</span><span class="s2">\n      </span><span class="s1">if (bodilessType &amp;&amp; !this.match(tt.braceL) &amp;&amp; this.isLineTerminator()) {</span><span class="s2">\n        </span><span class="s1">return this.finishNode(node, bodilessType);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (bodilessType === </span><span class="s2">\&quot;</span><span class="s1">TSDeclareFunction</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; this.state.isAmbientContext) {</span><span class="s2">\n        </span><span class="s1">this.raise(TSErrors.DeclareFunctionHasImplementation, { at: node });</span><span class="s2">\n        </span><span class="s1">if ((node as Undone&lt;N.FunctionDeclaration&gt;).declare) {</span><span class="s2">\n          </span><span class="s1">return super.parseFunctionBodyAndFinish(node, bodilessType, isMethod);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">this.tsDisallowOptionalPattern(node);</span><span class="s2">\n\n      </span><span class="s1">return super.parseFunctionBodyAndFinish(node, type, isMethod);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">registerFunctionStatementId(node: N.Function): void {</span><span class="s2">\n      </span><span class="s1">if (!node.body &amp;&amp; node.id) {</span><span class="s2">\n        </span><span class="s1">// Function ids are validated after parsing their body.</span><span class="s2">\n        </span><span class="s1">// For bodiless function, we need to do it here.</span><span class="s2">\n        </span><span class="s1">this.checkIdentifier(node.id, BIND_TS_AMBIENT);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">super.registerFunctionStatementId(node);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsCheckForInvalidTypeCasts(items: Array&lt;N.Expression | undefined | null&gt;) {</span><span class="s2">\n      </span><span class="s1">items.forEach(node =&gt; {</span><span class="s2">\n        </span><span class="s1">if (node?.type === </span><span class="s2">\&quot;</span><span class="s1">TSTypeCastExpression</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">this.raise(TSErrors.UnexpectedTypeAnnotation, {</span><span class="s2">\n            </span><span class="s1">at: node.typeAnnotation,</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">toReferencedList(</span><span class="s2">\n      </span><span class="s1">exprList: Array&lt;N.Expression | undefined | null&gt;,</span><span class="s2">\n      </span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-unused-vars</span><span class="s2">\n      </span><span class="s1">isInParens?: boolean,</span><span class="s2">\n    </span><span class="s1">): Array&lt;N.Expression | undefined | null&gt; {</span><span class="s2">\n      </span><span class="s1">// Handles invalid scenarios like: `f(a:b)`, `(a:b);`, and `(a:b,c:d)`.</span><span class="s2">\n      </span><span class="s1">//</span><span class="s2">\n      </span><span class="s1">// Note that `f&lt;T&gt;(a:b)` goes through a different path and is handled</span><span class="s2">\n      </span><span class="s1">// in `parseSubscript` directly.</span><span class="s2">\n      </span><span class="s1">this.tsCheckForInvalidTypeCasts(exprList);</span><span class="s2">\n      </span><span class="s1">return exprList;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseArrayLike(</span><span class="s2">\n      </span><span class="s1">close: TokenType,</span><span class="s2">\n      </span><span class="s1">canBePattern: boolean,</span><span class="s2">\n      </span><span class="s1">isTuple: boolean,</span><span class="s2">\n      </span><span class="s1">refExpressionErrors?: ExpressionErrors | null,</span><span class="s2">\n    </span><span class="s1">): N.ArrayExpression | N.TupleExpression {</span><span class="s2">\n      </span><span class="s1">const node = super.parseArrayLike(</span><span class="s2">\n        </span><span class="s1">close,</span><span class="s2">\n        </span><span class="s1">canBePattern,</span><span class="s2">\n        </span><span class="s1">isTuple,</span><span class="s2">\n        </span><span class="s1">refExpressionErrors,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n\n      </span><span class="s1">if (node.type === </span><span class="s2">\&quot;</span><span class="s1">ArrayExpression</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">this.tsCheckForInvalidTypeCasts(node.elements);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return node;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseSubscript(</span><span class="s2">\n      </span><span class="s1">base: N.Expression,</span><span class="s2">\n\n      </span><span class="s1">startLoc: Position,</span><span class="s2">\n      </span><span class="s1">noCalls: boolean | undefined | null,</span><span class="s2">\n      </span><span class="s1">state: N.ParseSubscriptState,</span><span class="s2">\n    </span><span class="s1">): N.Expression {</span><span class="s2">\n      </span><span class="s1">if (!this.hasPrecedingLineBreak() &amp;&amp; this.match(tt.bang)) {</span><span class="s2">\n        </span><span class="s1">// When ! is consumed as a postfix operator (non-null assertion),</span><span class="s2">\n        </span><span class="s1">// disallow JSX tag forming after. e.g. When parsing `p! &lt; n.p!`</span><span class="s2">\n        </span><span class="s1">// `&lt;n.p` can not be a start of JSX tag</span><span class="s2">\n        </span><span class="s1">this.state.canStartJSXElement = false;</span><span class="s2">\n        </span><span class="s1">this.next();</span><span class="s2">\n\n        </span><span class="s1">const nonNullExpression =</span><span class="s2">\n          </span><span class="s1">this.startNodeAt&lt;N.TsNonNullExpression&gt;(startLoc);</span><span class="s2">\n        </span><span class="s1">nonNullExpression.expression = base;</span><span class="s2">\n        </span><span class="s1">return this.finishNode(nonNullExpression, </span><span class="s2">\&quot;</span><span class="s1">TSNonNullExpression</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">let isOptionalCall = false;</span><span class="s2">\n      </span><span class="s1">if (</span><span class="s2">\n        </span><span class="s1">this.match(tt.questionDot) &amp;&amp;</span><span class="s2">\n        </span><span class="s1">this.lookaheadCharCode() === charCodes.lessThan</span><span class="s2">\n      </span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">if (noCalls) {</span><span class="s2">\n          </span><span class="s1">state.stop = true;</span><span class="s2">\n          </span><span class="s1">return base;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">state.optionalChainMember = isOptionalCall = true;</span><span class="s2">\n        </span><span class="s1">this.next();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">// handles 'f&lt;&lt;T&gt;'</span><span class="s2">\n      </span><span class="s1">if (this.match(tt.lt) || this.match(tt.bitShiftL)) {</span><span class="s2">\n        </span><span class="s1">let missingParenErrorLoc;</span><span class="s2">\n        </span><span class="s1">// tsTryParseAndCatch is expensive, so avoid if not necessary.</span><span class="s2">\n        </span><span class="s1">// There are number of things we are going to </span><span class="s2">\&quot;</span><span class="s1">maybe</span><span class="s2">\&quot; </span><span class="s1">parse, like type arguments on</span><span class="s2">\n        </span><span class="s1">// tagged template expressions. If any of them fail, walk it back and continue.</span><span class="s2">\n        </span><span class="s1">const result = this.tsTryParseAndCatch(() =&gt; {</span><span class="s2">\n          </span><span class="s1">if (!noCalls &amp;&amp; this.atPossibleAsyncArrow(base)) {</span><span class="s2">\n            </span><span class="s1">// Almost certainly this is a generic async function `async &lt;T&gt;() =&gt; ...</span><span class="s2">\n            </span><span class="s1">// But it might be a call with a type argument `async&lt;T&gt;();`</span><span class="s2">\n            </span><span class="s1">const asyncArrowFn =</span><span class="s2">\n              </span><span class="s1">this.tsTryParseGenericAsyncArrowFunction(startLoc);</span><span class="s2">\n            </span><span class="s1">if (asyncArrowFn) {</span><span class="s2">\n              </span><span class="s1">return asyncArrowFn;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n\n          </span><span class="s1">const typeArguments = this.tsParseTypeArgumentsInExpression();</span><span class="s2">\n          </span><span class="s1">if (!typeArguments) return;</span><span class="s2">\n\n          </span><span class="s1">if (isOptionalCall &amp;&amp; !this.match(tt.parenL)) {</span><span class="s2">\n            </span><span class="s1">missingParenErrorLoc = this.state.curPosition();</span><span class="s2">\n            </span><span class="s1">return;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n\n          </span><span class="s1">if (tokenIsTemplate(this.state.type)) {</span><span class="s2">\n            </span><span class="s1">const result = super.parseTaggedTemplateExpression(</span><span class="s2">\n              </span><span class="s1">base,</span><span class="s2">\n\n              </span><span class="s1">startLoc,</span><span class="s2">\n              </span><span class="s1">state,</span><span class="s2">\n            </span><span class="s1">);</span><span class="s2">\n            </span><span class="s1">result.typeParameters = typeArguments;</span><span class="s2">\n            </span><span class="s1">return result;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n\n          </span><span class="s1">if (!noCalls &amp;&amp; this.eat(tt.parenL)) {</span><span class="s2">\n            </span><span class="s1">const node = this.startNodeAt&lt;</span><span class="s2">\n              </span><span class="s1">N.CallExpression | N.OptionalCallExpression</span><span class="s2">\n            </span><span class="s1">&gt;(startLoc);</span><span class="s2">\n            </span><span class="s1">node.callee = base;</span><span class="s2">\n            </span><span class="s1">// possibleAsync always false here, because we would have handled it above.</span><span class="s2">\n            </span><span class="s1">// @ts-expect-error (won't be any undefined arguments)</span><span class="s2">\n            </span><span class="s1">node.arguments = this.parseCallExpressionArguments(</span><span class="s2">\n              </span><span class="s1">tt.parenR,</span><span class="s2">\n              </span><span class="s1">/* possibleAsync */ false,</span><span class="s2">\n            </span><span class="s1">);</span><span class="s2">\n\n            </span><span class="s1">// Handles invalid case: `f&lt;T&gt;(a:b)`</span><span class="s2">\n            </span><span class="s1">this.tsCheckForInvalidTypeCasts(node.arguments);</span><span class="s2">\n\n            </span><span class="s1">node.typeParameters = typeArguments;</span><span class="s2">\n            </span><span class="s1">if (state.optionalChainMember) {</span><span class="s2">\n              </span><span class="s1">(node as Undone&lt;N.OptionalCallExpression&gt;).optional =</span><span class="s2">\n                </span><span class="s1">isOptionalCall;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n\n            </span><span class="s1">return this.finishCallExpression(node, state.optionalChainMember);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n\n          </span><span class="s1">const tokenType = this.state.type;</span><span class="s2">\n          </span><span class="s1">if (</span><span class="s2">\n            </span><span class="s1">// a&lt;b&gt;&gt;c is not (a&lt;b&gt;)&gt;c, but a&lt;(b&gt;&gt;c)</span><span class="s2">\n            </span><span class="s1">tokenType === tt.gt ||</span><span class="s2">\n            </span><span class="s1">// a&lt;b&gt;&gt;&gt;c is not (a&lt;b&gt;)&gt;&gt;c, but a&lt;(b&gt;&gt;&gt;c)</span><span class="s2">\n            </span><span class="s1">tokenType === tt.bitShiftR ||</span><span class="s2">\n            </span><span class="s1">// a&lt;b&gt;c is (a&lt;b)&gt;c</span><span class="s2">\n            </span><span class="s1">(tokenType !== tt.parenL &amp;&amp;</span><span class="s2">\n              </span><span class="s1">tokenCanStartExpression(tokenType) &amp;&amp;</span><span class="s2">\n              </span><span class="s1">!this.hasPrecedingLineBreak())</span><span class="s2">\n          </span><span class="s1">) {</span><span class="s2">\n            </span><span class="s1">// Bail out.</span><span class="s2">\n            </span><span class="s1">return;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n\n          </span><span class="s1">const node = this.startNodeAt&lt;N.TsInstantiationExpression&gt;(startLoc);</span><span class="s2">\n          </span><span class="s1">node.expression = base;</span><span class="s2">\n          </span><span class="s1">node.typeParameters = typeArguments;</span><span class="s2">\n          </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">TSInstantiationExpression</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n\n        </span><span class="s1">if (missingParenErrorLoc) {</span><span class="s2">\n          </span><span class="s1">this.unexpected(missingParenErrorLoc, tt.parenL);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">if (result) {</span><span class="s2">\n          </span><span class="s1">if (</span><span class="s2">\n            </span><span class="s1">result.type === </span><span class="s2">\&quot;</span><span class="s1">TSInstantiationExpression</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n            </span><span class="s1">(this.match(tt.dot) ||</span><span class="s2">\n              </span><span class="s1">(this.match(tt.questionDot) &amp;&amp;</span><span class="s2">\n                </span><span class="s1">this.lookaheadCharCode() !== charCodes.leftParenthesis))</span><span class="s2">\n          </span><span class="s1">) {</span><span class="s2">\n            </span><span class="s1">this.raise(</span><span class="s2">\n              </span><span class="s1">TSErrors.InvalidPropertyAccessAfterInstantiationExpression,</span><span class="s2">\n              </span><span class="s1">{ at: this.state.startLoc },</span><span class="s2">\n            </span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">return result;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return super.parseSubscript(base, startLoc, noCalls, state);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseNewCallee(node: N.NewExpression): void {</span><span class="s2">\n      </span><span class="s1">super.parseNewCallee(node);</span><span class="s2">\n\n      </span><span class="s1">const { callee } = node;</span><span class="s2">\n      </span><span class="s1">if (</span><span class="s2">\n        </span><span class="s1">callee.type === </span><span class="s2">\&quot;</span><span class="s1">TSInstantiationExpression</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n        </span><span class="s1">!callee.extra?.parenthesized</span><span class="s2">\n      </span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">node.typeParameters = callee.typeParameters;</span><span class="s2">\n        </span><span class="s1">node.callee = callee.expression;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseExprOp(</span><span class="s2">\n      </span><span class="s1">left: N.Expression,</span><span class="s2">\n      </span><span class="s1">leftStartLoc: Position,</span><span class="s2">\n      </span><span class="s1">minPrec: number,</span><span class="s2">\n    </span><span class="s1">): N.Expression {</span><span class="s2">\n      </span><span class="s1">let isSatisfies: boolean;</span><span class="s2">\n      </span><span class="s1">if (</span><span class="s2">\n        </span><span class="s1">tokenOperatorPrecedence(tt._in) &gt; minPrec &amp;&amp;</span><span class="s2">\n        </span><span class="s1">!this.hasPrecedingLineBreak() &amp;&amp;</span><span class="s2">\n        </span><span class="s1">(this.isContextual(tt._as) ||</span><span class="s2">\n          </span><span class="s1">(isSatisfies = this.isContextual(tt._satisfies)))</span><span class="s2">\n      </span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">const node = this.startNodeAt&lt;</span><span class="s2">\n          </span><span class="s1">N.TsAsExpression | N.TsSatisfiesExpression</span><span class="s2">\n        </span><span class="s1">&gt;(leftStartLoc);</span><span class="s2">\n        </span><span class="s1">node.expression = left;</span><span class="s2">\n        </span><span class="s1">node.typeAnnotation = this.tsInType(() =&gt; {</span><span class="s2">\n          </span><span class="s1">this.next(); // </span><span class="s2">\&quot;</span><span class="s1">as</span><span class="s2">\&quot; </span><span class="s1">or </span><span class="s2">\&quot;</span><span class="s1">satisfies</span><span class="s2">\&quot;\n          </span><span class="s1">if (this.match(tt._const)) {</span><span class="s2">\n            </span><span class="s1">if (isSatisfies) {</span><span class="s2">\n              </span><span class="s1">this.raise(Errors.UnexpectedKeyword, {</span><span class="s2">\n                </span><span class="s1">at: this.state.startLoc,</span><span class="s2">\n                </span><span class="s1">keyword: </span><span class="s2">\&quot;</span><span class="s1">const</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n              </span><span class="s1">});</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">return this.tsParseTypeReference();</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n\n          </span><span class="s1">return this.tsParseType();</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">this.finishNode(</span><span class="s2">\n          </span><span class="s1">node,</span><span class="s2">\n          </span><span class="s1">isSatisfies ? </span><span class="s2">\&quot;</span><span class="s1">TSSatisfiesExpression</span><span class="s2">\&quot; </span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">TSAsExpression</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">// rescan `&lt;`, `&gt;` because they were scanned when this.state.inType was true</span><span class="s2">\n        </span><span class="s1">this.reScan_lt_gt();</span><span class="s2">\n        </span><span class="s1">return this.parseExprOp(</span><span class="s2">\n          </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts)</span><span class="s2">\n          </span><span class="s1">node,</span><span class="s2">\n          </span><span class="s1">leftStartLoc,</span><span class="s2">\n          </span><span class="s1">minPrec,</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return super.parseExprOp(left, leftStartLoc, minPrec);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">checkReservedWord(</span><span class="s2">\n      </span><span class="s1">word: string,</span><span class="s2">\n      </span><span class="s1">startLoc: Position,</span><span class="s2">\n      </span><span class="s1">checkKeywords: boolean,</span><span class="s2">\n      </span><span class="s1">isBinding: boolean,</span><span class="s2">\n    </span><span class="s1">): void {</span><span class="s2">\n      </span><span class="s1">// Strict mode words may be allowed as in `declare namespace N { const static: number; }`.</span><span class="s2">\n      </span><span class="s1">// And we have a type checker anyway, so don't bother having the parser do it.</span><span class="s2">\n      </span><span class="s1">if (!this.state.isAmbientContext) {</span><span class="s2">\n        </span><span class="s1">super.checkReservedWord(word, startLoc, checkKeywords, isBinding);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">checkImportReflection(node: Undone&lt;N.ImportDeclaration&gt;) {</span><span class="s2">\n      </span><span class="s1">super.checkImportReflection(node);</span><span class="s2">\n      </span><span class="s1">if (node.module &amp;&amp; node.importKind !== </span><span class="s2">\&quot;</span><span class="s1">value</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">this.raise(TSErrors.ImportReflectionHasImportType, {</span><span class="s2">\n          </span><span class="s1">at: node.specifiers[0].loc.start,</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">/*</span><span class="s2">\n    </span><span class="s1">Don't bother doing this check in TypeScript code because:</span><span class="s2">\n    </span><span class="s1">1. We may have a nested export statement with the same name:</span><span class="s2">\n      </span><span class="s1">export const x = 0;</span><span class="s2">\n      </span><span class="s1">export namespace N {</span><span class="s2">\n        </span><span class="s1">export const x = 1;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">2. We have a type checker to warn us about this sort of thing.</span><span class="s2">\n    </span><span class="s1">*/</span><span class="s2">\n    </span><span class="s1">checkDuplicateExports() {}</span><span class="s2">\n\n    </span><span class="s1">parseImport(</span><span class="s2">\n      </span><span class="s1">node: Undone&lt;N.ImportDeclaration | N.TsImportEqualsDeclaration&gt;,</span><span class="s2">\n    </span><span class="s1">): N.AnyImport {</span><span class="s2">\n      </span><span class="s1">node.importKind = </span><span class="s2">\&quot;</span><span class="s1">value</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n      </span><span class="s1">if (</span><span class="s2">\n        </span><span class="s1">tokenIsIdentifier(this.state.type) ||</span><span class="s2">\n        </span><span class="s1">this.match(tt.star) ||</span><span class="s2">\n        </span><span class="s1">this.match(tt.braceL)</span><span class="s2">\n      </span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">let ahead = this.lookahead();</span><span class="s2">\n\n        </span><span class="s1">if (</span><span class="s2">\n          </span><span class="s1">this.isContextual(tt._type) &amp;&amp;</span><span class="s2">\n          </span><span class="s1">// import type, { a } from </span><span class="s2">\&quot;</span><span class="s1">b</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n          </span><span class="s1">ahead.type !== tt.comma &amp;&amp;</span><span class="s2">\n          </span><span class="s1">// import type from </span><span class="s2">\&quot;</span><span class="s1">a</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n          </span><span class="s1">ahead.type !== tt._from &amp;&amp;</span><span class="s2">\n          </span><span class="s1">// import type = require(</span><span class="s2">\&quot;</span><span class="s1">a</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">ahead.type !== tt.eq</span><span class="s2">\n        </span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">node.importKind = </span><span class="s2">\&quot;</span><span class="s1">type</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n          </span><span class="s1">this.next();</span><span class="s2">\n          </span><span class="s1">ahead = this.lookahead();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">if (tokenIsIdentifier(this.state.type) &amp;&amp; ahead.type === tt.eq) {</span><span class="s2">\n          </span><span class="s1">return this.tsParseImportEqualsDeclaration(</span><span class="s2">\n            </span><span class="s1">node as Undone&lt;N.TsImportEqualsDeclaration&gt;,</span><span class="s2">\n          </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">const importNode = super.parseImport(node as Undone&lt;N.ImportDeclaration&gt;);</span><span class="s2">\n      </span><span class="s1">/*:: invariant(importNode.type !== </span><span class="s2">\&quot;</span><span class="s1">TSImportEqualsDeclaration</span><span class="s2">\&quot;</span><span class="s1">) */</span><span class="s2">\n\n      </span><span class="s1">// `import type` can only be used on imports with named imports or with a</span><span class="s2">\n      </span><span class="s1">// default import - but not both</span><span class="s2">\n      </span><span class="s1">if (</span><span class="s2">\n        </span><span class="s1">importNode.importKind === </span><span class="s2">\&quot;</span><span class="s1">type</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error refine typings</span><span class="s2">\n        </span><span class="s1">importNode.specifiers.length &gt; 1 &amp;&amp;</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error refine typings</span><span class="s2">\n        </span><span class="s1">importNode.specifiers[0].type === </span><span class="s2">\&quot;</span><span class="s1">ImportDefaultSpecifier</span><span class="s2">\&quot;\n      </span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">this.raise(TSErrors.TypeImportCannotSpecifyDefaultAndNamed, {</span><span class="s2">\n          </span><span class="s1">at: importNode,</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return importNode;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseExport(</span><span class="s2">\n      </span><span class="s1">node: Undone&lt;N.Node&gt;,</span><span class="s2">\n      </span><span class="s1">decorators: N.Decorator[] | null,</span><span class="s2">\n    </span><span class="s1">): N.AnyExport {</span><span class="s2">\n      </span><span class="s1">if (this.match(tt._import)) {</span><span class="s2">\n        </span><span class="s1">// `export import A = B;`</span><span class="s2">\n        </span><span class="s1">this.next(); // eat `tt._import`</span><span class="s2">\n        </span><span class="s1">if (</span><span class="s2">\n          </span><span class="s1">this.isContextual(tt._type) &amp;&amp;</span><span class="s2">\n          </span><span class="s1">this.lookaheadCharCode() !== charCodes.equalsTo</span><span class="s2">\n        </span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">node.importKind = </span><span class="s2">\&quot;</span><span class="s1">type</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n          </span><span class="s1">this.next(); // eat </span><span class="s2">\&quot;</span><span class="s1">type</span><span class="s2">\&quot;\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">node.importKind = </span><span class="s2">\&quot;</span><span class="s1">value</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return this.tsParseImportEqualsDeclaration(</span><span class="s2">\n          </span><span class="s1">node as Undone&lt;N.TsImportEqualsDeclaration&gt;,</span><span class="s2">\n          </span><span class="s1">/* isExport */ true,</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">} else if (this.eat(tt.eq)) {</span><span class="s2">\n        </span><span class="s1">// `export = x;`</span><span class="s2">\n        </span><span class="s1">const assign = node as Undone&lt;N.TsExportAssignment&gt;;</span><span class="s2">\n        </span><span class="s1">assign.expression = super.parseExpression();</span><span class="s2">\n        </span><span class="s1">this.semicolon();</span><span class="s2">\n        </span><span class="s1">return this.finishNode(assign, </span><span class="s2">\&quot;</span><span class="s1">TSExportAssignment</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">} else if (this.eatContextual(tt._as)) {</span><span class="s2">\n        </span><span class="s1">// `export as namespace A;`</span><span class="s2">\n        </span><span class="s1">const decl = node as Undone&lt;N.TsNamespaceExportDeclaration&gt;;</span><span class="s2">\n        </span><span class="s1">// See `parseNamespaceExportDeclaration` in TypeScript's own parser</span><span class="s2">\n        </span><span class="s1">this.expectContextual(tt._namespace);</span><span class="s2">\n        </span><span class="s1">decl.id = this.parseIdentifier();</span><span class="s2">\n        </span><span class="s1">this.semicolon();</span><span class="s2">\n        </span><span class="s1">return this.finishNode(decl, </span><span class="s2">\&quot;</span><span class="s1">TSNamespaceExportDeclaration</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">node.exportKind = </span><span class="s2">\&quot;</span><span class="s1">value</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n        </span><span class="s1">if (this.isContextual(tt._type)) {</span><span class="s2">\n          </span><span class="s1">const ch = this.lookaheadCharCode();</span><span class="s2">\n          </span><span class="s1">if (ch === charCodes.leftCurlyBrace || ch === charCodes.asterisk) {</span><span class="s2">\n            </span><span class="s1">this.next();</span><span class="s2">\n            </span><span class="s1">node.exportKind = </span><span class="s2">\&quot;</span><span class="s1">type</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">return super.parseExport(</span><span class="s2">\n          </span><span class="s1">node as Undone&lt;N.ExportAllDeclaration | N.ExportDefaultDeclaration&gt;,</span><span class="s2">\n          </span><span class="s1">decorators,</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">isAbstractClass(): boolean {</span><span class="s2">\n      </span><span class="s1">return (</span><span class="s2">\n        </span><span class="s1">this.isContextual(tt._abstract) &amp;&amp; this.lookahead().type === tt._class</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseExportDefaultExpression(): N.Expression | N.Declaration {</span><span class="s2">\n      </span><span class="s1">if (this.isAbstractClass()) {</span><span class="s2">\n        </span><span class="s1">const cls = this.startNode&lt;N.Class&gt;();</span><span class="s2">\n        </span><span class="s1">this.next(); // Skip </span><span class="s2">\&quot;</span><span class="s1">abstract</span><span class="s2">\&quot;\n        </span><span class="s1">cls.abstract = true;</span><span class="s2">\n        </span><span class="s1">return this.parseClass(cls, true, true);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">// export default interface allowed in:</span><span class="s2">\n      </span><span class="s1">// https://github.com/Microsoft/TypeScript/pull/16040</span><span class="s2">\n      </span><span class="s1">if (this.match(tt._interface)) {</span><span class="s2">\n        </span><span class="s1">const result = this.tsParseInterfaceDeclaration(</span><span class="s2">\n          </span><span class="s1">this.startNode&lt;N.TsInterfaceDeclaration&gt;(),</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">if (result) return result;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return super.parseExportDefaultExpression();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseVarStatement(</span><span class="s2">\n      </span><span class="s1">node: N.VariableDeclaration,</span><span class="s2">\n      </span><span class="s1">kind: </span><span class="s2">\&quot;</span><span class="s1">var</span><span class="s2">\&quot; </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">let</span><span class="s2">\&quot; </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">const</span><span class="s2">\&quot; </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">using</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">allowMissingInitializer: boolean = false,</span><span class="s2">\n    </span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">const { isAmbientContext } = this.state;</span><span class="s2">\n      </span><span class="s1">const declaration = super.parseVarStatement(</span><span class="s2">\n        </span><span class="s1">node,</span><span class="s2">\n        </span><span class="s1">kind,</span><span class="s2">\n        </span><span class="s1">allowMissingInitializer || isAmbientContext,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n\n      </span><span class="s1">if (!isAmbientContext) return declaration;</span><span class="s2">\n\n      </span><span class="s1">for (const { id, init } of declaration.declarations) {</span><span class="s2">\n        </span><span class="s1">// Empty initializer is the easy case that we want.</span><span class="s2">\n        </span><span class="s1">if (!init) continue;</span><span class="s2">\n\n        </span><span class="s1">// var and let aren't ever allowed initializers.</span><span class="s2">\n        </span><span class="s1">if (kind !== </span><span class="s2">\&quot;</span><span class="s1">const</span><span class="s2">\&quot; </span><span class="s1">|| !!id.typeAnnotation) {</span><span class="s2">\n          </span><span class="s1">this.raise(TSErrors.InitializerNotAllowedInAmbientContext, {</span><span class="s2">\n            </span><span class="s1">at: init,</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">} else if (</span><span class="s2">\n          </span><span class="s1">!isValidAmbientConstInitializer(init, this.hasPlugin(</span><span class="s2">\&quot;</span><span class="s1">estree</span><span class="s2">\&quot;</span><span class="s1">))</span><span class="s2">\n        </span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">this.raise(</span><span class="s2">\n            </span><span class="s1">TSErrors.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference,</span><span class="s2">\n            </span><span class="s1">{ at: init },</span><span class="s2">\n          </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return declaration;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseStatementContent(</span><span class="s2">\n      </span><span class="s1">flags: ParseStatementFlag,</span><span class="s2">\n      </span><span class="s1">decorators?: N.Decorator[] | null,</span><span class="s2">\n    </span><span class="s1">): N.Statement {</span><span class="s2">\n      </span><span class="s1">if (this.match(tt._const) &amp;&amp; this.isLookaheadContextual(</span><span class="s2">\&quot;</span><span class="s1">enum</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n        </span><span class="s1">const node = this.startNode&lt;N.TsEnumDeclaration&gt;();</span><span class="s2">\n        </span><span class="s1">this.expect(tt._const); // eat 'const'</span><span class="s2">\n        </span><span class="s1">return this.tsParseEnumDeclaration(node, { const: true });</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">if (this.isContextual(tt._enum)) {</span><span class="s2">\n        </span><span class="s1">return this.tsParseEnumDeclaration(</span><span class="s2">\n          </span><span class="s1">this.startNode&lt;N.TsEnumDeclaration&gt;(),</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">if (this.isContextual(tt._interface)) {</span><span class="s2">\n        </span><span class="s1">const result = this.tsParseInterfaceDeclaration(this.startNode());</span><span class="s2">\n        </span><span class="s1">if (result) return result;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return super.parseStatementContent(flags, decorators);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseAccessModifier(): N.Accessibility | undefined | null {</span><span class="s2">\n      </span><span class="s1">return this.tsParseModifier([</span><span class="s2">\&quot;</span><span class="s1">public</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">protected</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">private</span><span class="s2">\&quot;</span><span class="s1">]);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsHasSomeModifiers(member: any, modifiers: readonly TsModifier[]): boolean {</span><span class="s2">\n      </span><span class="s1">return modifiers.some(modifier =&gt; {</span><span class="s2">\n        </span><span class="s1">if (tsIsAccessModifier(modifier)) {</span><span class="s2">\n          </span><span class="s1">return member.accessibility === modifier;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return !!member[modifier];</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsIsStartOfStaticBlocks() {</span><span class="s2">\n      </span><span class="s1">return (</span><span class="s2">\n        </span><span class="s1">this.isContextual(tt._static) &amp;&amp;</span><span class="s2">\n        </span><span class="s1">this.lookaheadCharCode() === charCodes.leftCurlyBrace</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseClassMember(</span><span class="s2">\n      </span><span class="s1">classBody: N.ClassBody,</span><span class="s2">\n      </span><span class="s1">member: any,</span><span class="s2">\n      </span><span class="s1">state: N.ParseClassMemberState,</span><span class="s2">\n    </span><span class="s1">): void {</span><span class="s2">\n      </span><span class="s1">const modifiers = [</span><span class="s2">\n        \&quot;</span><span class="s1">declare</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        \&quot;</span><span class="s1">private</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        \&quot;</span><span class="s1">public</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        \&quot;</span><span class="s1">protected</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        \&quot;</span><span class="s1">override</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        \&quot;</span><span class="s1">abstract</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        \&quot;</span><span class="s1">readonly</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        \&quot;</span><span class="s1">static</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">] as const;</span><span class="s2">\n      </span><span class="s1">this.tsParseModifiers(</span><span class="s2">\n        </span><span class="s1">{</span><span class="s2">\n          </span><span class="s1">allowedModifiers: modifiers,</span><span class="s2">\n          </span><span class="s1">disallowedModifiers: [</span><span class="s2">\&quot;</span><span class="s1">in</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">out</span><span class="s2">\&quot;</span><span class="s1">],</span><span class="s2">\n          </span><span class="s1">stopOnStartOfClassStaticBlock: true,</span><span class="s2">\n          </span><span class="s1">errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions,</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">member,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n\n      </span><span class="s1">const callParseClassMemberWithIsStatic = () =&gt; {</span><span class="s2">\n        </span><span class="s1">if (this.tsIsStartOfStaticBlocks()) {</span><span class="s2">\n          </span><span class="s1">this.next(); // eat </span><span class="s2">\&quot;</span><span class="s1">static</span><span class="s2">\&quot;\n          </span><span class="s1">this.next(); // eat </span><span class="s2">\&quot;</span><span class="s1">{</span><span class="s2">\&quot;\n          </span><span class="s1">if (this.tsHasSomeModifiers(member, modifiers)) {</span><span class="s2">\n            </span><span class="s1">this.raise(TSErrors.StaticBlockCannotHaveModifier, {</span><span class="s2">\n              </span><span class="s1">at: this.state.curPosition(),</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">super.parseClassStaticBlock(classBody, member as N.StaticBlock);</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">this.parseClassMemberWithIsStatic(</span><span class="s2">\n            </span><span class="s1">classBody,</span><span class="s2">\n            </span><span class="s1">member,</span><span class="s2">\n            </span><span class="s1">state,</span><span class="s2">\n            </span><span class="s1">!!member.static,</span><span class="s2">\n          </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n      </span><span class="s1">if (member.declare) {</span><span class="s2">\n        </span><span class="s1">this.tsInAmbientContext(callParseClassMemberWithIsStatic);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">callParseClassMemberWithIsStatic();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseClassMemberWithIsStatic(</span><span class="s2">\n      </span><span class="s1">classBody: N.ClassBody,</span><span class="s2">\n      </span><span class="s1">member: Undone&lt;N.ClassMember | N.TsIndexSignature&gt;,</span><span class="s2">\n      </span><span class="s1">state: N.ParseClassMemberState,</span><span class="s2">\n      </span><span class="s1">isStatic: boolean,</span><span class="s2">\n    </span><span class="s1">): void {</span><span class="s2">\n      </span><span class="s1">const idx = this.tsTryParseIndexSignature(</span><span class="s2">\n        </span><span class="s1">member as Undone&lt;N.TsIndexSignature&gt;,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">if (idx) {</span><span class="s2">\n        </span><span class="s1">classBody.body.push(idx);</span><span class="s2">\n\n        </span><span class="s1">if ((member as any).abstract) {</span><span class="s2">\n          </span><span class="s1">this.raise(TSErrors.IndexSignatureHasAbstract, { at: member });</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if ((member as any).accessibility) {</span><span class="s2">\n          </span><span class="s1">this.raise(TSErrors.IndexSignatureHasAccessibility, {</span><span class="s2">\n            </span><span class="s1">at: member,</span><span class="s2">\n            </span><span class="s1">modifier: (member as any).accessibility,</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if ((member as any).declare) {</span><span class="s2">\n          </span><span class="s1">this.raise(TSErrors.IndexSignatureHasDeclare, { at: member });</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if ((member as any).override) {</span><span class="s2">\n          </span><span class="s1">this.raise(TSErrors.IndexSignatureHasOverride, { at: member });</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">if (!this.state.inAbstractClass &amp;&amp; (member as any).abstract) {</span><span class="s2">\n        </span><span class="s1">this.raise(TSErrors.NonAbstractClassHasAbstractMethod, {</span><span class="s2">\n          </span><span class="s1">at: member,</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">if ((member as any).override) {</span><span class="s2">\n        </span><span class="s1">if (!state.hadSuperClass) {</span><span class="s2">\n          </span><span class="s1">this.raise(TSErrors.OverrideNotInSubClass, { at: member });</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">/*:: invariant(member.type !== </span><span class="s2">\&quot;</span><span class="s1">TSIndexSignature</span><span class="s2">\&quot;</span><span class="s1">) */</span><span class="s2">\n\n      </span><span class="s1">super.parseClassMemberWithIsStatic(</span><span class="s2">\n        </span><span class="s1">classBody,</span><span class="s2">\n        </span><span class="s1">member as Undone&lt;N.ClassMember&gt;,</span><span class="s2">\n        </span><span class="s1">state,</span><span class="s2">\n        </span><span class="s1">isStatic,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parsePostMemberNameModifiers(</span><span class="s2">\n      </span><span class="s1">methodOrProp: N.ClassMethod | N.ClassProperty | N.ClassPrivateProperty,</span><span class="s2">\n    </span><span class="s1">): void {</span><span class="s2">\n      </span><span class="s1">const optional = this.eat(tt.question);</span><span class="s2">\n      </span><span class="s1">if (optional) methodOrProp.optional = true;</span><span class="s2">\n\n      </span><span class="s1">if ((methodOrProp as any).readonly &amp;&amp; this.match(tt.parenL)) {</span><span class="s2">\n        </span><span class="s1">this.raise(TSErrors.ClassMethodHasReadonly, { at: methodOrProp });</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">if ((methodOrProp as any).declare &amp;&amp; this.match(tt.parenL)) {</span><span class="s2">\n        </span><span class="s1">this.raise(TSErrors.ClassMethodHasDeclare, { at: methodOrProp });</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// Note: The reason we do this in `parseExpressionStatement` and not `parseStatement`</span><span class="s2">\n    </span><span class="s1">// is that e.g. `type()` is valid JS, so we must try parsing that first.</span><span class="s2">\n    </span><span class="s1">// If it's really a type, we will parse `type` as the statement, and can correct it here</span><span class="s2">\n    </span><span class="s1">// by parsing the rest.</span><span class="s2">\n    </span><span class="s1">// @ts-expect-error plugin overrides interfaces</span><span class="s2">\n    </span><span class="s1">parseExpressionStatement(</span><span class="s2">\n      </span><span class="s1">node: Undone&lt;N.ExpressionStatement&gt;,</span><span class="s2">\n      </span><span class="s1">expr: N.Expression,</span><span class="s2">\n      </span><span class="s1">decorators: N.Decorator[] | null,</span><span class="s2">\n    </span><span class="s1">): N.Statement {</span><span class="s2">\n      </span><span class="s1">const decl =</span><span class="s2">\n        </span><span class="s1">expr.type === </span><span class="s2">\&quot;</span><span class="s1">Identifier</span><span class="s2">\&quot;\n          </span><span class="s1">? // @ts-expect-error refine typings</span><span class="s2">\n            </span><span class="s1">this.tsParseExpressionStatement(node, expr, decorators)</span><span class="s2">\n          </span><span class="s1">: undefined;</span><span class="s2">\n      </span><span class="s1">return decl || super.parseExpressionStatement(node, expr, decorators);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// export type</span><span class="s2">\n    </span><span class="s1">// Should be true for anything parsed by `tsTryParseExportDeclaration`.</span><span class="s2">\n    </span><span class="s1">shouldParseExportDeclaration(): boolean {</span><span class="s2">\n      </span><span class="s1">if (this.tsIsDeclarationStart()) return true;</span><span class="s2">\n      </span><span class="s1">return super.shouldParseExportDeclaration();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// An apparent conditional expression could actually be an optional parameter in an arrow function.</span><span class="s2">\n    </span><span class="s1">parseConditional(</span><span class="s2">\n      </span><span class="s1">expr: N.Expression,</span><span class="s2">\n\n      </span><span class="s1">startLoc: Position,</span><span class="s2">\n      </span><span class="s1">refExpressionErrors?: ExpressionErrors | null,</span><span class="s2">\n    </span><span class="s1">): N.Expression {</span><span class="s2">\n      </span><span class="s1">// only do the expensive clone if there is a question mark</span><span class="s2">\n      </span><span class="s1">// and if we come from inside parens</span><span class="s2">\n      </span><span class="s1">if (!this.state.maybeInArrowParameters || !this.match(tt.question)) {</span><span class="s2">\n        </span><span class="s1">return super.parseConditional(</span><span class="s2">\n          </span><span class="s1">expr,</span><span class="s2">\n\n          </span><span class="s1">startLoc,</span><span class="s2">\n          </span><span class="s1">refExpressionErrors,</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">const result = this.tryParse(() =&gt;</span><span class="s2">\n        </span><span class="s1">super.parseConditional(expr, startLoc),</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n\n      </span><span class="s1">if (!result.node) {</span><span class="s2">\n        </span><span class="s1">if (result.error) {</span><span class="s2">\n          </span><span class="s1">/*:: invariant(refExpressionErrors != null) */</span><span class="s2">\n          </span><span class="s1">super.setOptionalParametersError(refExpressionErrors, result.error);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">return expr;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (result.error) this.state = result.failState;</span><span class="s2">\n      </span><span class="s1">return result.node;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// Note: These </span><span class="s2">\&quot;</span><span class="s1">type casts</span><span class="s2">\&quot; </span><span class="s1">are *not* valid TS expressions.</span><span class="s2">\n    </span><span class="s1">// But we parse them here and change them when completing the arrow function.</span><span class="s2">\n    </span><span class="s1">parseParenItem(</span><span class="s2">\n      </span><span class="s1">node: N.Expression,</span><span class="s2">\n\n      </span><span class="s1">startLoc: Position,</span><span class="s2">\n    </span><span class="s1">): N.Expression {</span><span class="s2">\n      </span><span class="s1">node = super.parseParenItem(node, startLoc);</span><span class="s2">\n      </span><span class="s1">if (this.eat(tt.question)) {</span><span class="s2">\n        </span><span class="s1">node.optional = true;</span><span class="s2">\n        </span><span class="s1">// Include questionmark in location of node</span><span class="s2">\n        </span><span class="s1">// Don't use this.finishNode() as otherwise we might process comments twice and</span><span class="s2">\n        </span><span class="s1">// include already consumed parens</span><span class="s2">\n        </span><span class="s1">this.resetEndLocation(node);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">if (this.match(tt.colon)) {</span><span class="s2">\n        </span><span class="s1">const typeCastNode = this.startNodeAt&lt;N.TsTypeCastExpression&gt;(startLoc);</span><span class="s2">\n        </span><span class="s1">typeCastNode.expression = node;</span><span class="s2">\n        </span><span class="s1">typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();</span><span class="s2">\n\n        </span><span class="s1">return this.finishNode(typeCastNode, </span><span class="s2">\&quot;</span><span class="s1">TSTypeCastExpression</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return node;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseExportDeclaration(</span><span class="s2">\n      </span><span class="s1">node: N.ExportNamedDeclaration,</span><span class="s2">\n    </span><span class="s1">): N.Declaration | undefined | null {</span><span class="s2">\n      </span><span class="s1">if (!this.state.isAmbientContext &amp;&amp; this.isContextual(tt._declare)) {</span><span class="s2">\n        </span><span class="s1">return this.tsInAmbientContext(() =&gt; this.parseExportDeclaration(node));</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">// Store original location</span><span class="s2">\n      </span><span class="s1">const startLoc = this.state.startLoc;</span><span class="s2">\n\n      </span><span class="s1">const isDeclare = this.eatContextual(tt._declare);</span><span class="s2">\n\n      </span><span class="s1">if (</span><span class="s2">\n        </span><span class="s1">isDeclare &amp;&amp;</span><span class="s2">\n        </span><span class="s1">(this.isContextual(tt._declare) || !this.shouldParseExportDeclaration())</span><span class="s2">\n      </span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">throw this.raise(TSErrors.ExpectedAmbientAfterExportDeclare, {</span><span class="s2">\n          </span><span class="s1">at: this.state.startLoc,</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">const isIdentifier = tokenIsIdentifier(this.state.type);</span><span class="s2">\n      </span><span class="s1">const declaration: N.Declaration | undefined | null =</span><span class="s2">\n        </span><span class="s1">(isIdentifier &amp;&amp; this.tsTryParseExportDeclaration()) ||</span><span class="s2">\n        </span><span class="s1">super.parseExportDeclaration(node);</span><span class="s2">\n\n      </span><span class="s1">if (!declaration) return null;</span><span class="s2">\n\n      </span><span class="s1">if (</span><span class="s2">\n        </span><span class="s1">declaration.type === </span><span class="s2">\&quot;</span><span class="s1">TSInterfaceDeclaration</span><span class="s2">\&quot; </span><span class="s1">||</span><span class="s2">\n        </span><span class="s1">declaration.type === </span><span class="s2">\&quot;</span><span class="s1">TSTypeAliasDeclaration</span><span class="s2">\&quot; </span><span class="s1">||</span><span class="s2">\n        </span><span class="s1">isDeclare</span><span class="s2">\n      </span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">node.exportKind = </span><span class="s2">\&quot;</span><span class="s1">type</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">if (isDeclare) {</span><span class="s2">\n        </span><span class="s1">// Reset location to include `declare` in range</span><span class="s2">\n        </span><span class="s1">this.resetStartLocation(declaration, startLoc);</span><span class="s2">\n\n        </span><span class="s1">declaration.declare = true;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return declaration;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseClassId(</span><span class="s2">\n      </span><span class="s1">node: N.Class,</span><span class="s2">\n      </span><span class="s1">isStatement: boolean,</span><span class="s2">\n      </span><span class="s1">optionalId?: boolean | null,</span><span class="s2">\n      </span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-unused-vars</span><span class="s2">\n      </span><span class="s1">bindingType?: BindingTypes,</span><span class="s2">\n    </span><span class="s1">): void {</span><span class="s2">\n      </span><span class="s1">if ((!isStatement || optionalId) &amp;&amp; this.isContextual(tt._implements)) {</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">super.parseClassId(</span><span class="s2">\n        </span><span class="s1">node,</span><span class="s2">\n        </span><span class="s1">isStatement,</span><span class="s2">\n        </span><span class="s1">optionalId,</span><span class="s2">\n        </span><span class="s1">(node as any).declare ? BIND_TS_AMBIENT : BIND_CLASS,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">const typeParameters = this.tsTryParseTypeParameters(</span><span class="s2">\n        </span><span class="s1">this.tsParseInOutConstModifiers,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">if (typeParameters) node.typeParameters = typeParameters;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseClassPropertyAnnotation(</span><span class="s2">\n      </span><span class="s1">node: N.ClassProperty | N.ClassPrivateProperty | N.ClassAccessorProperty,</span><span class="s2">\n    </span><span class="s1">): void {</span><span class="s2">\n      </span><span class="s1">if (!node.optional) {</span><span class="s2">\n        </span><span class="s1">if (this.eat(tt.bang)) {</span><span class="s2">\n          </span><span class="s1">node.definite = true;</span><span class="s2">\n        </span><span class="s1">} else if (this.eat(tt.question)) {</span><span class="s2">\n          </span><span class="s1">node.optional = true;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">const type = this.tsTryParseTypeAnnotation();</span><span class="s2">\n      </span><span class="s1">if (type) node.typeAnnotation = type;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseClassProperty(node: N.ClassProperty): N.ClassProperty {</span><span class="s2">\n      </span><span class="s1">this.parseClassPropertyAnnotation(node);</span><span class="s2">\n\n      </span><span class="s1">if (</span><span class="s2">\n        </span><span class="s1">this.state.isAmbientContext &amp;&amp;</span><span class="s2">\n        </span><span class="s1">!(node.readonly &amp;&amp; !node.typeAnnotation) &amp;&amp;</span><span class="s2">\n        </span><span class="s1">this.match(tt.eq)</span><span class="s2">\n      </span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">this.raise(TSErrors.DeclareClassFieldHasInitializer, {</span><span class="s2">\n          </span><span class="s1">at: this.state.startLoc,</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (node.abstract &amp;&amp; this.match(tt.eq)) {</span><span class="s2">\n        </span><span class="s1">const { key } = node;</span><span class="s2">\n        </span><span class="s1">this.raise(TSErrors.AbstractPropertyHasInitializer, {</span><span class="s2">\n          </span><span class="s1">at: this.state.startLoc,</span><span class="s2">\n          </span><span class="s1">propertyName:</span><span class="s2">\n            </span><span class="s1">key.type === </span><span class="s2">\&quot;</span><span class="s1">Identifier</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; !node.computed</span><span class="s2">\n              </span><span class="s1">? key.name</span><span class="s2">\n              </span><span class="s1">: `[${this.input.slice(key.start, key.end)}]`,</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return super.parseClassProperty(node);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseClassPrivateProperty(</span><span class="s2">\n      </span><span class="s1">node: N.ClassPrivateProperty,</span><span class="s2">\n    </span><span class="s1">): N.ClassPrivateProperty {</span><span class="s2">\n      </span><span class="s1">// @ts-expect-error abstract may not index node</span><span class="s2">\n      </span><span class="s1">if (node.abstract) {</span><span class="s2">\n        </span><span class="s1">this.raise(TSErrors.PrivateElementHasAbstract, { at: node });</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">// @ts-expect-error accessibility may not index node</span><span class="s2">\n      </span><span class="s1">if (node.accessibility) {</span><span class="s2">\n        </span><span class="s1">this.raise(TSErrors.PrivateElementHasAccessibility, {</span><span class="s2">\n          </span><span class="s1">at: node,</span><span class="s2">\n          </span><span class="s1">// @ts-expect-error refine typings</span><span class="s2">\n          </span><span class="s1">modifier: node.accessibility,</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">this.parseClassPropertyAnnotation(node);</span><span class="s2">\n      </span><span class="s1">return super.parseClassPrivateProperty(node);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseClassAccessorProperty(</span><span class="s2">\n      </span><span class="s1">node: N.ClassAccessorProperty,</span><span class="s2">\n    </span><span class="s1">): N.ClassAccessorProperty {</span><span class="s2">\n      </span><span class="s1">this.parseClassPropertyAnnotation(node);</span><span class="s2">\n      </span><span class="s1">if (node.optional) {</span><span class="s2">\n        </span><span class="s1">this.raise(TSErrors.AccessorCannotBeOptional, { at: node });</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return super.parseClassAccessorProperty(node);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">pushClassMethod(</span><span class="s2">\n      </span><span class="s1">classBody: N.ClassBody,</span><span class="s2">\n      </span><span class="s1">method: N.ClassMethod,</span><span class="s2">\n      </span><span class="s1">isGenerator: boolean,</span><span class="s2">\n      </span><span class="s1">isAsync: boolean,</span><span class="s2">\n      </span><span class="s1">isConstructor: boolean,</span><span class="s2">\n      </span><span class="s1">allowsDirectSuper: boolean,</span><span class="s2">\n    </span><span class="s1">): void {</span><span class="s2">\n      </span><span class="s1">const typeParameters = this.tsTryParseTypeParameters(</span><span class="s2">\n        </span><span class="s1">this.tsParseConstModifier,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">if (typeParameters &amp;&amp; isConstructor) {</span><span class="s2">\n        </span><span class="s1">this.raise(TSErrors.ConstructorHasTypeParameters, {</span><span class="s2">\n          </span><span class="s1">at: typeParameters,</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">// @ts-expect-error declare does not exist in ClassMethod</span><span class="s2">\n      </span><span class="s1">const { declare = false, kind } = method;</span><span class="s2">\n\n      </span><span class="s1">if (declare &amp;&amp; (kind === </span><span class="s2">\&quot;</span><span class="s1">get</span><span class="s2">\&quot; </span><span class="s1">|| kind === </span><span class="s2">\&quot;</span><span class="s1">set</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n        </span><span class="s1">this.raise(TSErrors.DeclareAccessor, { at: method, kind });</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (typeParameters) method.typeParameters = typeParameters;</span><span class="s2">\n      </span><span class="s1">super.pushClassMethod(</span><span class="s2">\n        </span><span class="s1">classBody,</span><span class="s2">\n        </span><span class="s1">method,</span><span class="s2">\n        </span><span class="s1">isGenerator,</span><span class="s2">\n        </span><span class="s1">isAsync,</span><span class="s2">\n        </span><span class="s1">isConstructor,</span><span class="s2">\n        </span><span class="s1">allowsDirectSuper,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">pushClassPrivateMethod(</span><span class="s2">\n      </span><span class="s1">classBody: N.ClassBody,</span><span class="s2">\n      </span><span class="s1">method: N.ClassPrivateMethod,</span><span class="s2">\n      </span><span class="s1">isGenerator: boolean,</span><span class="s2">\n      </span><span class="s1">isAsync: boolean,</span><span class="s2">\n    </span><span class="s1">): void {</span><span class="s2">\n      </span><span class="s1">const typeParameters = this.tsTryParseTypeParameters(</span><span class="s2">\n        </span><span class="s1">this.tsParseConstModifier,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">if (typeParameters) method.typeParameters = typeParameters;</span><span class="s2">\n      </span><span class="s1">super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">declareClassPrivateMethodInScope(</span><span class="s2">\n      </span><span class="s1">node: N.ClassPrivateMethod | N.EstreeMethodDefinition | N.TSDeclareMethod,</span><span class="s2">\n      </span><span class="s1">kind: number,</span><span class="s2">\n    </span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">if (node.type === </span><span class="s2">\&quot;</span><span class="s1">TSDeclareMethod</span><span class="s2">\&quot;</span><span class="s1">) return;</span><span class="s2">\n      </span><span class="s1">// This happens when using the </span><span class="s2">\&quot;</span><span class="s1">estree</span><span class="s2">\&quot; </span><span class="s1">plugin.</span><span class="s2">\n      </span><span class="s1">if (node.type === </span><span class="s2">\&quot;</span><span class="s1">MethodDefinition</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; !node.value.body) return;</span><span class="s2">\n\n      </span><span class="s1">super.declareClassPrivateMethodInScope(node, kind);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseClassSuper(node: N.Class): void {</span><span class="s2">\n      </span><span class="s1">super.parseClassSuper(node);</span><span class="s2">\n      </span><span class="s1">// handle `extends f&lt;&lt;T&gt;</span><span class="s2">\n      </span><span class="s1">if (node.superClass &amp;&amp; (this.match(tt.lt) || this.match(tt.bitShiftL))) {</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error refine typings</span><span class="s2">\n        </span><span class="s1">node.superTypeParameters = this.tsParseTypeArgumentsInExpression();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (this.eatContextual(tt._implements)) {</span><span class="s2">\n        </span><span class="s1">node.implements = this.tsParseHeritageClause(</span><span class="s2">\&quot;</span><span class="s1">implements</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseObjPropValue(</span><span class="s2">\n      </span><span class="s1">prop: Undone&lt;N.ObjectMethod | N.ObjectProperty&gt;,</span><span class="s2">\n      </span><span class="s1">startLoc: Position | undefined | null,</span><span class="s2">\n      </span><span class="s1">isGenerator: boolean,</span><span class="s2">\n      </span><span class="s1">isAsync: boolean,</span><span class="s2">\n      </span><span class="s1">isPattern: boolean,</span><span class="s2">\n      </span><span class="s1">isAccessor: boolean,</span><span class="s2">\n      </span><span class="s1">refExpressionErrors?: ExpressionErrors | null,</span><span class="s2">\n    </span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">const typeParameters = this.tsTryParseTypeParameters(</span><span class="s2">\n        </span><span class="s1">this.tsParseConstModifier,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">if (typeParameters) prop.typeParameters = typeParameters;</span><span class="s2">\n\n      </span><span class="s1">return super.parseObjPropValue(</span><span class="s2">\n        </span><span class="s1">prop,</span><span class="s2">\n\n        </span><span class="s1">startLoc,</span><span class="s2">\n        </span><span class="s1">isGenerator,</span><span class="s2">\n        </span><span class="s1">isAsync,</span><span class="s2">\n        </span><span class="s1">isPattern,</span><span class="s2">\n        </span><span class="s1">isAccessor,</span><span class="s2">\n        </span><span class="s1">refExpressionErrors,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseFunctionParams(node: N.Function, isConstructor: boolean): void {</span><span class="s2">\n      </span><span class="s1">const typeParameters = this.tsTryParseTypeParameters(</span><span class="s2">\n        </span><span class="s1">this.tsParseConstModifier,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">if (typeParameters) node.typeParameters = typeParameters;</span><span class="s2">\n      </span><span class="s1">super.parseFunctionParams(node, isConstructor);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// `let x: number;`</span><span class="s2">\n    </span><span class="s1">parseVarId(</span><span class="s2">\n      </span><span class="s1">decl: N.VariableDeclarator,</span><span class="s2">\n      </span><span class="s1">kind: </span><span class="s2">\&quot;</span><span class="s1">var</span><span class="s2">\&quot; </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">let</span><span class="s2">\&quot; </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">const</span><span class="s2">\&quot; </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">using</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">): void {</span><span class="s2">\n      </span><span class="s1">super.parseVarId(decl, kind);</span><span class="s2">\n      </span><span class="s1">if (</span><span class="s2">\n        </span><span class="s1">decl.id.type === </span><span class="s2">\&quot;</span><span class="s1">Identifier</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n        </span><span class="s1">!this.hasPrecedingLineBreak() &amp;&amp;</span><span class="s2">\n        </span><span class="s1">this.eat(tt.bang)</span><span class="s2">\n      </span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">decl.definite = true;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">const type = this.tsTryParseTypeAnnotation();</span><span class="s2">\n      </span><span class="s1">if (type) {</span><span class="s2">\n        </span><span class="s1">decl.id.typeAnnotation = type;</span><span class="s2">\n        </span><span class="s1">this.resetEndLocation(decl.id); // set end position to end of type</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// parse the return type of an async arrow function - let foo = (async (): number =&gt; {});</span><span class="s2">\n    </span><span class="s1">parseAsyncArrowFromCallExpression(</span><span class="s2">\n      </span><span class="s1">node: N.ArrowFunctionExpression,</span><span class="s2">\n      </span><span class="s1">call: N.CallExpression,</span><span class="s2">\n    </span><span class="s1">): N.ArrowFunctionExpression {</span><span class="s2">\n      </span><span class="s1">if (this.match(tt.colon)) {</span><span class="s2">\n        </span><span class="s1">node.returnType = this.tsParseTypeAnnotation();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return super.parseAsyncArrowFromCallExpression(node, call);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseMaybeAssign(</span><span class="s2">\n      </span><span class="s1">refExpressionErrors?: ExpressionErrors | null,</span><span class="s2">\n      </span><span class="s1">afterLeftParse?: Function,</span><span class="s2">\n    </span><span class="s1">): N.Expression {</span><span class="s2">\n      </span><span class="s1">// Note: When the JSX plugin is on, type assertions (`&lt;T&gt; x`) aren't valid syntax.</span><span class="s2">\n\n      </span><span class="s1">let state: State | undefined | null;</span><span class="s2">\n      </span><span class="s1">let jsx;</span><span class="s2">\n      </span><span class="s1">let typeCast;</span><span class="s2">\n\n      </span><span class="s1">if (</span><span class="s2">\n        </span><span class="s1">this.hasPlugin(</span><span class="s2">\&quot;</span><span class="s1">jsx</span><span class="s2">\&quot;</span><span class="s1">) &amp;&amp;</span><span class="s2">\n        </span><span class="s1">(this.match(tt.jsxTagStart) || this.match(tt.lt))</span><span class="s2">\n      </span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">// Prefer to parse JSX if possible. But may be an arrow fn.</span><span class="s2">\n        </span><span class="s1">state = this.state.clone();</span><span class="s2">\n\n        </span><span class="s1">jsx = this.tryParse(</span><span class="s2">\n          </span><span class="s1">() =&gt; super.parseMaybeAssign(refExpressionErrors, afterLeftParse),</span><span class="s2">\n          </span><span class="s1">state,</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n\n        </span><span class="s1">/*:: invariant(!jsx.aborted) */</span><span class="s2">\n        </span><span class="s1">/*:: invariant(jsx.node != null) */</span><span class="s2">\n        </span><span class="s1">if (!jsx.error) return jsx.node;</span><span class="s2">\n\n        </span><span class="s1">// Remove `tc.j_expr` or `tc.j_oTag` from context added</span><span class="s2">\n        </span><span class="s1">// by parsing `jsxTagStart` to stop the JSX plugin from</span><span class="s2">\n        </span><span class="s1">// messing with the tokens</span><span class="s2">\n        </span><span class="s1">const { context } = this.state;</span><span class="s2">\n        </span><span class="s1">const currentContext = context[context.length - 1];</span><span class="s2">\n        </span><span class="s1">if (currentContext === tc.j_oTag || currentContext === tc.j_expr) {</span><span class="s2">\n          </span><span class="s1">context.pop();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">if (!jsx?.error &amp;&amp; !this.match(tt.lt)) {</span><span class="s2">\n        </span><span class="s1">return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">// Either way, we're looking at a '&lt;': tt.jsxTagStart or relational.</span><span class="s2">\n\n      </span><span class="s1">// If the state was cloned in the JSX parsing branch above but there</span><span class="s2">\n      </span><span class="s1">// have been any error in the tryParse call, this.state is set to state</span><span class="s2">\n      </span><span class="s1">// so we still need to clone it.</span><span class="s2">\n      </span><span class="s1">if (!state || state === this.state) state = this.state.clone();</span><span class="s2">\n\n      </span><span class="s1">let typeParameters: N.TsTypeParameterDeclaration | undefined | null;</span><span class="s2">\n      </span><span class="s1">const arrow = this.tryParse(abort =&gt; {</span><span class="s2">\n        </span><span class="s1">// This is similar to TypeScript's `tryParseParenthesizedArrowFunctionExpression`.</span><span class="s2">\n        </span><span class="s1">typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);</span><span class="s2">\n        </span><span class="s1">const expr = super.parseMaybeAssign(</span><span class="s2">\n          </span><span class="s1">refExpressionErrors,</span><span class="s2">\n          </span><span class="s1">afterLeftParse,</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n\n        </span><span class="s1">if (</span><span class="s2">\n          </span><span class="s1">expr.type !== </span><span class="s2">\&quot;</span><span class="s1">ArrowFunctionExpression</span><span class="s2">\&quot; </span><span class="s1">||</span><span class="s2">\n          </span><span class="s1">expr.extra?.parenthesized</span><span class="s2">\n        </span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">abort();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">// Correct TypeScript code should have at least 1 type parameter, but don't crash on bad code.</span><span class="s2">\n        </span><span class="s1">if (typeParameters?.params.length !== 0) {</span><span class="s2">\n          </span><span class="s1">this.resetStartLocationFromNode(expr, typeParameters);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">expr.typeParameters = typeParameters;</span><span class="s2">\n\n        </span><span class="s1">if (process.env.BABEL_8_BREAKING) {</span><span class="s2">\n          </span><span class="s1">if (</span><span class="s2">\n            </span><span class="s1">this.hasPlugin(</span><span class="s2">\&quot;</span><span class="s1">jsx</span><span class="s2">\&quot;</span><span class="s1">) &amp;&amp;</span><span class="s2">\n            </span><span class="s1">expr.typeParameters.params.length === 1 &amp;&amp;</span><span class="s2">\n            </span><span class="s1">!expr.typeParameters.extra?.trailingComma</span><span class="s2">\n          </span><span class="s1">) {</span><span class="s2">\n            </span><span class="s1">// report error if single type parameter used without trailing comma.</span><span class="s2">\n            </span><span class="s1">const parameter = expr.typeParameters.params[0];</span><span class="s2">\n            </span><span class="s1">if (!parameter.constraint) {</span><span class="s2">\n              </span><span class="s1">// A single type parameter must either have constraints</span><span class="s2">\n              </span><span class="s1">// or a trailing comma, otherwise it's ambiguous with JSX.</span><span class="s2">\n              </span><span class="s1">this.raise(TSErrors.SingleTypeParameterWithoutTrailingComma, {</span><span class="s2">\n                </span><span class="s1">at: createPositionWithColumnOffset(parameter.loc.end, 1),</span><span class="s2">\n                </span><span class="s1">typeParameterName: parameter.name.name,</span><span class="s2">\n              </span><span class="s1">});</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">return expr;</span><span class="s2">\n      </span><span class="s1">}, state);</span><span class="s2">\n\n      </span><span class="s1">/*:: invariant(arrow.node != null) */</span><span class="s2">\n      </span><span class="s1">if (!arrow.error &amp;&amp; !arrow.aborted) {</span><span class="s2">\n        </span><span class="s1">// This error is reported outside of the this.tryParse call so that</span><span class="s2">\n        </span><span class="s1">// in case of &lt;T&gt;(x) =&gt; 2, we don't consider &lt;T&gt;(x) as a type assertion</span><span class="s2">\n        </span><span class="s1">// because of this error.</span><span class="s2">\n        </span><span class="s1">if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error refine typings</span><span class="s2">\n        </span><span class="s1">return arrow.node;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">if (!jsx) {</span><span class="s2">\n        </span><span class="s1">// Try parsing a type cast instead of an arrow function.</span><span class="s2">\n        </span><span class="s1">// This will never happen outside of JSX.</span><span class="s2">\n        </span><span class="s1">// (Because in JSX the '&lt;' should be a jsxTagStart and not a relational.</span><span class="s2">\n        </span><span class="s1">assert(!this.hasPlugin(</span><span class="s2">\&quot;</span><span class="s1">jsx</span><span class="s2">\&quot;</span><span class="s1">));</span><span class="s2">\n\n        </span><span class="s1">// This will start with a type assertion (via parseMaybeUnary).</span><span class="s2">\n        </span><span class="s1">// But don't directly call `this.tsParseTypeAssertion` because we want to handle any binary after it.</span><span class="s2">\n        </span><span class="s1">typeCast = this.tryParse(</span><span class="s2">\n          </span><span class="s1">() =&gt; super.parseMaybeAssign(refExpressionErrors, afterLeftParse),</span><span class="s2">\n          </span><span class="s1">state,</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">/*:: invariant(!typeCast.aborted) */</span><span class="s2">\n        </span><span class="s1">/*:: invariant(typeCast.node != null) */</span><span class="s2">\n        </span><span class="s1">if (!typeCast.error) return typeCast.node;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">if (jsx?.node) {</span><span class="s2">\n        </span><span class="s1">/*:: invariant(jsx.failState) */</span><span class="s2">\n        </span><span class="s1">this.state = jsx.failState;</span><span class="s2">\n        </span><span class="s1">return jsx.node;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">if (arrow.node) {</span><span class="s2">\n        </span><span class="s1">/*:: invariant(arrow.failState) */</span><span class="s2">\n        </span><span class="s1">this.state = arrow.failState;</span><span class="s2">\n        </span><span class="s1">if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error refine typings</span><span class="s2">\n        </span><span class="s1">return arrow.node;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">if (typeCast?.node) {</span><span class="s2">\n        </span><span class="s1">/*:: invariant(typeCast.failState) */</span><span class="s2">\n        </span><span class="s1">this.state = typeCast.failState;</span><span class="s2">\n        </span><span class="s1">return typeCast.node;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">if (jsx?.thrown) throw jsx.error;</span><span class="s2">\n      </span><span class="s1">if (arrow.thrown) throw arrow.error;</span><span class="s2">\n      </span><span class="s1">if (typeCast?.thrown) throw typeCast.error;</span><span class="s2">\n\n      </span><span class="s1">throw jsx?.error || arrow.error || typeCast?.error;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">reportReservedArrowTypeParam(node: any) {</span><span class="s2">\n      </span><span class="s1">if (</span><span class="s2">\n        </span><span class="s1">node.params.length === 1 &amp;&amp;</span><span class="s2">\n        </span><span class="s1">!node.params[0].constraint &amp;&amp;</span><span class="s2">\n        </span><span class="s1">!node.extra?.trailingComma &amp;&amp;</span><span class="s2">\n        </span><span class="s1">this.getPluginOption(</span><span class="s2">\&quot;</span><span class="s1">typescript</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">disallowAmbiguousJSXLike</span><span class="s2">\&quot;</span><span class="s1">)</span><span class="s2">\n      </span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">this.raise(TSErrors.ReservedArrowTypeParam, { at: node });</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// Handle type assertions</span><span class="s2">\n    </span><span class="s1">parseMaybeUnary(</span><span class="s2">\n      </span><span class="s1">refExpressionErrors?: ExpressionErrors | null,</span><span class="s2">\n      </span><span class="s1">sawUnary?: boolean,</span><span class="s2">\n    </span><span class="s1">): N.Expression {</span><span class="s2">\n      </span><span class="s1">if (!this.hasPlugin(</span><span class="s2">\&quot;</span><span class="s1">jsx</span><span class="s2">\&quot;</span><span class="s1">) &amp;&amp; this.match(tt.lt)) {</span><span class="s2">\n        </span><span class="s1">return this.tsParseTypeAssertion();</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">return super.parseMaybeUnary(refExpressionErrors, sawUnary);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseArrow(</span><span class="s2">\n      </span><span class="s1">node: Undone&lt;N.ArrowFunctionExpression&gt;,</span><span class="s2">\n    </span><span class="s1">): Undone&lt;N.ArrowFunctionExpression&gt; | undefined | null {</span><span class="s2">\n      </span><span class="s1">if (this.match(tt.colon)) {</span><span class="s2">\n        </span><span class="s1">// This is different from how the TS parser does it.</span><span class="s2">\n        </span><span class="s1">// TS uses lookahead. The Babel Parser parses it as a parenthesized expression and converts.</span><span class="s2">\n\n        </span><span class="s1">const result = this.tryParse(abort =&gt; {</span><span class="s2">\n          </span><span class="s1">const returnType = this.tsParseTypeOrTypePredicateAnnotation(</span><span class="s2">\n            </span><span class="s1">tt.colon,</span><span class="s2">\n          </span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">if (this.canInsertSemicolon() || !this.match(tt.arrow)) abort();</span><span class="s2">\n          </span><span class="s1">return returnType;</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n\n        </span><span class="s1">if (result.aborted) return;</span><span class="s2">\n\n        </span><span class="s1">if (!result.thrown) {</span><span class="s2">\n          </span><span class="s1">if (result.error) this.state = result.failState;</span><span class="s2">\n          </span><span class="s1">// @ts-expect-error refine typings</span><span class="s2">\n          </span><span class="s1">node.returnType = result.node;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return super.parseArrow(node);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// Allow type annotations inside of a parameter list.</span><span class="s2">\n    </span><span class="s1">parseAssignableListItemTypes(</span><span class="s2">\n      </span><span class="s1">param: N.Pattern,</span><span class="s2">\n      </span><span class="s1">flags: ParseBindingListFlags,</span><span class="s2">\n    </span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">if (!(flags &amp; ParseBindingListFlags.IS_FUNCTION_PARAMS)) return param;</span><span class="s2">\n\n      </span><span class="s1">if (this.eat(tt.question)) {</span><span class="s2">\n        </span><span class="s1">(param as any as N.Identifier).optional = true;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">const type = this.tsTryParseTypeAnnotation();</span><span class="s2">\n      </span><span class="s1">if (type) param.typeAnnotation = type;</span><span class="s2">\n      </span><span class="s1">this.resetEndLocation(param);</span><span class="s2">\n\n      </span><span class="s1">return param;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">isAssignable(node: N.Node, isBinding?: boolean): boolean {</span><span class="s2">\n      </span><span class="s1">switch (node.type) {</span><span class="s2">\n        </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">TSTypeCastExpression</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n          </span><span class="s1">return this.isAssignable(node.expression, isBinding);</span><span class="s2">\n        </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">TSParameterProperty</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n          </span><span class="s1">return true;</span><span class="s2">\n        </span><span class="s1">default:</span><span class="s2">\n          </span><span class="s1">return super.isAssignable(node, isBinding);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">toAssignable(node: N.Node, isLHS: boolean = false): void {</span><span class="s2">\n      </span><span class="s1">switch (node.type) {</span><span class="s2">\n        </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">ParenthesizedExpression</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n          </span><span class="s1">this.toAssignableParenthesizedExpression(node, isLHS);</span><span class="s2">\n          </span><span class="s1">break;</span><span class="s2">\n        </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">TSAsExpression</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n        </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">TSSatisfiesExpression</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n        </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">TSNonNullExpression</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n        </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">TSTypeAssertion</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n          </span><span class="s1">if (isLHS) {</span><span class="s2">\n            </span><span class="s1">this.expressionScope.recordArrowParameterBindingError(</span><span class="s2">\n              </span><span class="s1">TSErrors.UnexpectedTypeCastInParameter,</span><span class="s2">\n              </span><span class="s1">{ at: node },</span><span class="s2">\n            </span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">} else {</span><span class="s2">\n            </span><span class="s1">this.raise(TSErrors.UnexpectedTypeCastInParameter, { at: node });</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">this.toAssignable(node.expression, isLHS);</span><span class="s2">\n          </span><span class="s1">break;</span><span class="s2">\n        </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">AssignmentExpression</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n          </span><span class="s1">if (!isLHS &amp;&amp; node.left.type === </span><span class="s2">\&quot;</span><span class="s1">TSTypeCastExpression</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n            </span><span class="s1">node.left = this.typeCastToParameter(node.left);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">/* fall through */</span><span class="s2">\n        </span><span class="s1">default:</span><span class="s2">\n          </span><span class="s1">super.toAssignable(node, isLHS);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">toAssignableParenthesizedExpression(node: N.Node, isLHS: boolean): void {</span><span class="s2">\n      </span><span class="s1">switch (node.expression.type) {</span><span class="s2">\n        </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">TSAsExpression</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n        </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">TSSatisfiesExpression</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n        </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">TSNonNullExpression</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n        </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">TSTypeAssertion</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n        </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">ParenthesizedExpression</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n          </span><span class="s1">this.toAssignable(node.expression, isLHS);</span><span class="s2">\n          </span><span class="s1">break;</span><span class="s2">\n        </span><span class="s1">default:</span><span class="s2">\n          </span><span class="s1">super.toAssignable(node, isLHS);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">checkToRestConversion(node: N.Node, allowPattern: boolean): void {</span><span class="s2">\n      </span><span class="s1">switch (node.type) {</span><span class="s2">\n        </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">TSAsExpression</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n        </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">TSSatisfiesExpression</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n        </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">TSTypeAssertion</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n        </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">TSNonNullExpression</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n          </span><span class="s1">this.checkToRestConversion(node.expression, false);</span><span class="s2">\n          </span><span class="s1">break;</span><span class="s2">\n        </span><span class="s1">default:</span><span class="s2">\n          </span><span class="s1">super.checkToRestConversion(node, allowPattern);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// @ts-expect-error plugin overrides interfaces</span><span class="s2">\n    </span><span class="s1">isValidLVal(</span><span class="s2">\n      </span><span class="s1">type:</span><span class="s2">\n        </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">TSTypeCastExpression</span><span class="s2">\&quot;\n        </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">TSParameterProperty</span><span class="s2">\&quot;\n        </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">TSNonNullExpression</span><span class="s2">\&quot;\n        </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">TSAsExpression</span><span class="s2">\&quot;\n        </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">TSSatisfiesExpression</span><span class="s2">\&quot;\n        </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">TSTypeAssertion</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">isUnparenthesizedInAssign: boolean,</span><span class="s2">\n      </span><span class="s1">binding: BindingTypes,</span><span class="s2">\n    </span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">return (</span><span class="s2">\n        </span><span class="s1">getOwn(</span><span class="s2">\n          </span><span class="s1">{</span><span class="s2">\n            </span><span class="s1">// Allow </span><span class="s2">\&quot;</span><span class="s1">typecasts</span><span class="s2">\&quot; </span><span class="s1">to appear on the left of assignment expressions,</span><span class="s2">\n            </span><span class="s1">// because it may be in an arrow function.</span><span class="s2">\n            </span><span class="s1">// e.g. `const f = (foo: number = 0) =&gt; foo;`</span><span class="s2">\n            </span><span class="s1">TSTypeCastExpression: true,</span><span class="s2">\n            </span><span class="s1">TSParameterProperty: </span><span class="s2">\&quot;</span><span class="s1">parameter</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n            </span><span class="s1">TSNonNullExpression: </span><span class="s2">\&quot;</span><span class="s1">expression</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n            </span><span class="s1">TSAsExpression: (binding !== BIND_NONE ||</span><span class="s2">\n              </span><span class="s1">!isUnparenthesizedInAssign) &amp;&amp; [</span><span class="s2">\&quot;</span><span class="s1">expression</span><span class="s2">\&quot;</span><span class="s1">, true],</span><span class="s2">\n            </span><span class="s1">TSSatisfiesExpression: (binding !== BIND_NONE ||</span><span class="s2">\n              </span><span class="s1">!isUnparenthesizedInAssign) &amp;&amp; [</span><span class="s2">\&quot;</span><span class="s1">expression</span><span class="s2">\&quot;</span><span class="s1">, true],</span><span class="s2">\n            </span><span class="s1">TSTypeAssertion: (binding !== BIND_NONE ||</span><span class="s2">\n              </span><span class="s1">!isUnparenthesizedInAssign) &amp;&amp; [</span><span class="s2">\&quot;</span><span class="s1">expression</span><span class="s2">\&quot;</span><span class="s1">, true],</span><span class="s2">\n          </span><span class="s1">},</span><span class="s2">\n          </span><span class="s1">type,</span><span class="s2">\n        </span><span class="s1">) || super.isValidLVal(type, isUnparenthesizedInAssign, binding)</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseBindingAtom(): N.Pattern {</span><span class="s2">\n      </span><span class="s1">switch (this.state.type) {</span><span class="s2">\n        </span><span class="s1">case tt._this:</span><span class="s2">\n          </span><span class="s1">// </span><span class="s2">\&quot;</span><span class="s1">this</span><span class="s2">\&quot; </span><span class="s1">may be the name of a parameter, so allow it.</span><span class="s2">\n          </span><span class="s1">return this.parseIdentifier(/* liberal */ true);</span><span class="s2">\n        </span><span class="s1">default:</span><span class="s2">\n          </span><span class="s1">return super.parseBindingAtom();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseMaybeDecoratorArguments(expr: N.Expression): N.Expression {</span><span class="s2">\n      </span><span class="s1">// handles `@f&lt;&lt;T&gt;`</span><span class="s2">\n      </span><span class="s1">if (this.match(tt.lt) || this.match(tt.bitShiftL)) {</span><span class="s2">\n        </span><span class="s1">const typeArguments = this.tsParseTypeArgumentsInExpression();</span><span class="s2">\n\n        </span><span class="s1">if (this.match(tt.parenL)) {</span><span class="s2">\n          </span><span class="s1">const call = super.parseMaybeDecoratorArguments(expr);</span><span class="s2">\n          </span><span class="s1">call.typeParameters = typeArguments;</span><span class="s2">\n          </span><span class="s1">return call;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">this.unexpected(null, tt.parenL);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return super.parseMaybeDecoratorArguments(expr);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">checkCommaAfterRest(</span><span class="s2">\n      </span><span class="s1">close: (typeof charCodes)[keyof typeof charCodes],</span><span class="s2">\n    </span><span class="s1">): boolean {</span><span class="s2">\n      </span><span class="s1">if (</span><span class="s2">\n        </span><span class="s1">this.state.isAmbientContext &amp;&amp;</span><span class="s2">\n        </span><span class="s1">this.match(tt.comma) &amp;&amp;</span><span class="s2">\n        </span><span class="s1">this.lookaheadCharCode() === close</span><span class="s2">\n      </span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">this.next();</span><span class="s2">\n        </span><span class="s1">return false;</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">return super.checkCommaAfterRest(close);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// === === === === === === === === === === === === === === === ===</span><span class="s2">\n    </span><span class="s1">// Note: All below methods are duplicates of something in flow.js.</span><span class="s2">\n    </span><span class="s1">// Not sure what the best way to combine these is.</span><span class="s2">\n    </span><span class="s1">// === === === === === === === === === === === === === === === ===</span><span class="s2">\n\n    </span><span class="s1">isClassMethod(): boolean {</span><span class="s2">\n      </span><span class="s1">return this.match(tt.lt) || super.isClassMethod();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">isClassProperty(): boolean {</span><span class="s2">\n      </span><span class="s1">return (</span><span class="s2">\n        </span><span class="s1">this.match(tt.bang) || this.match(tt.colon) || super.isClassProperty()</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseMaybeDefault(</span><span class="s2">\n      </span><span class="s1">startLoc?: Position | null,</span><span class="s2">\n      </span><span class="s1">left?: Pattern | null,</span><span class="s2">\n    </span><span class="s1">): N.Pattern {</span><span class="s2">\n      </span><span class="s1">const node = super.parseMaybeDefault(startLoc, left);</span><span class="s2">\n\n      </span><span class="s1">if (</span><span class="s2">\n        </span><span class="s1">node.type === </span><span class="s2">\&quot;</span><span class="s1">AssignmentPattern</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n        </span><span class="s1">node.typeAnnotation &amp;&amp;</span><span class="s2">\n        </span><span class="s1">node.right.start &lt; node.typeAnnotation.start</span><span class="s2">\n      </span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">this.raise(TSErrors.TypeAnnotationAfterAssign, {</span><span class="s2">\n          </span><span class="s1">at: node.typeAnnotation,</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return node;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// ensure that inside types, we bypass the jsx parser plugin</span><span class="s2">\n    </span><span class="s1">getTokenFromCode(code: number): void {</span><span class="s2">\n      </span><span class="s1">if (this.state.inType) {</span><span class="s2">\n        </span><span class="s1">if (code === charCodes.greaterThan) {</span><span class="s2">\n          </span><span class="s1">this.finishOp(tt.gt, 1);</span><span class="s2">\n          </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (code === charCodes.lessThan) {</span><span class="s2">\n          </span><span class="s1">this.finishOp(tt.lt, 1);</span><span class="s2">\n          </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">super.getTokenFromCode(code);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// used after we have finished parsing types</span><span class="s2">\n    </span><span class="s1">reScan_lt_gt() {</span><span class="s2">\n      </span><span class="s1">const { type } = this.state;</span><span class="s2">\n      </span><span class="s1">if (type === tt.lt) {</span><span class="s2">\n        </span><span class="s1">this.state.pos -= 1;</span><span class="s2">\n        </span><span class="s1">this.readToken_lt();</span><span class="s2">\n      </span><span class="s1">} else if (type === tt.gt) {</span><span class="s2">\n        </span><span class="s1">this.state.pos -= 1;</span><span class="s2">\n        </span><span class="s1">this.readToken_gt();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">reScan_lt() {</span><span class="s2">\n      </span><span class="s1">const { type } = this.state;</span><span class="s2">\n      </span><span class="s1">if (type === tt.bitShiftL) {</span><span class="s2">\n        </span><span class="s1">this.state.pos -= 2;</span><span class="s2">\n        </span><span class="s1">this.finishOp(tt.lt, 1);</span><span class="s2">\n        </span><span class="s1">return tt.lt;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return type;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">toAssignableList(</span><span class="s2">\n      </span><span class="s1">exprList: Expression[],</span><span class="s2">\n      </span><span class="s1">trailingCommaLoc: Position | undefined | null,</span><span class="s2">\n      </span><span class="s1">isLHS: boolean,</span><span class="s2">\n    </span><span class="s1">): void {</span><span class="s2">\n      </span><span class="s1">for (let i = 0; i &lt; exprList.length; i++) {</span><span class="s2">\n        </span><span class="s1">const expr = exprList[i];</span><span class="s2">\n        </span><span class="s1">if (expr?.type === </span><span class="s2">\&quot;</span><span class="s1">TSTypeCastExpression</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">exprList[i] = this.typeCastToParameter(</span><span class="s2">\n            </span><span class="s1">expr as N.TsTypeCastExpression,</span><span class="s2">\n          </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">super.toAssignableList(exprList, trailingCommaLoc, isLHS);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">typeCastToParameter(node: N.TsTypeCastExpression): N.Node {</span><span class="s2">\n      </span><span class="s1">node.expression.typeAnnotation = node.typeAnnotation;</span><span class="s2">\n\n      </span><span class="s1">this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);</span><span class="s2">\n\n      </span><span class="s1">return node.expression;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">shouldParseArrow(params: Array&lt;N.Node&gt;) {</span><span class="s2">\n      </span><span class="s1">if (this.match(tt.colon)) {</span><span class="s2">\n        </span><span class="s1">return params.every(expr =&gt; this.isAssignable(expr, true));</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return super.shouldParseArrow(params);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">shouldParseAsyncArrow(): boolean {</span><span class="s2">\n      </span><span class="s1">return this.match(tt.colon) || super.shouldParseAsyncArrow();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">canHaveLeadingDecorator() {</span><span class="s2">\n      </span><span class="s1">// Avoid unnecessary lookahead in checking for abstract class unless needed!</span><span class="s2">\n      </span><span class="s1">return super.canHaveLeadingDecorator() || this.isAbstractClass();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">jsxParseOpeningElementAfterName(</span><span class="s2">\n      </span><span class="s1">node: N.JSXOpeningElement,</span><span class="s2">\n    </span><span class="s1">): N.JSXOpeningElement {</span><span class="s2">\n      </span><span class="s1">// handles `&lt;Component&lt;&lt;T&gt;`</span><span class="s2">\n      </span><span class="s1">if (this.match(tt.lt) || this.match(tt.bitShiftL)) {</span><span class="s2">\n        </span><span class="s1">const typeArguments = this.tsTryParseAndCatch(() =&gt;</span><span class="s2">\n          </span><span class="s1">// @ts-expect-error: refine typings</span><span class="s2">\n          </span><span class="s1">this.tsParseTypeArgumentsInExpression(),</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error: refine typings</span><span class="s2">\n        </span><span class="s1">if (typeArguments) node.typeParameters = typeArguments;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return super.jsxParseOpeningElementAfterName(node);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">getGetterSetterExpectedParamCount(</span><span class="s2">\n      </span><span class="s1">method: N.ObjectMethod | N.ClassMethod,</span><span class="s2">\n    </span><span class="s1">): number {</span><span class="s2">\n      </span><span class="s1">const baseCount = super.getGetterSetterExpectedParamCount(method);</span><span class="s2">\n      </span><span class="s1">const params = this.getObjectOrClassMethodParams(method);</span><span class="s2">\n      </span><span class="s1">const firstParam = params[0];</span><span class="s2">\n      </span><span class="s1">const hasContextParam = firstParam &amp;&amp; this.isThisParam(firstParam);</span><span class="s2">\n\n      </span><span class="s1">return hasContextParam ? baseCount + 1 : baseCount;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseCatchClauseParam(): N.Pattern {</span><span class="s2">\n      </span><span class="s1">const param = super.parseCatchClauseParam();</span><span class="s2">\n      </span><span class="s1">const type = this.tsTryParseTypeAnnotation();</span><span class="s2">\n\n      </span><span class="s1">if (type) {</span><span class="s2">\n        </span><span class="s1">param.typeAnnotation = type;</span><span class="s2">\n        </span><span class="s1">this.resetEndLocation(param);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return param;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsInAmbientContext&lt;T&gt;(cb: () =&gt; T): T {</span><span class="s2">\n      </span><span class="s1">const oldIsAmbientContext = this.state.isAmbientContext;</span><span class="s2">\n      </span><span class="s1">this.state.isAmbientContext = true;</span><span class="s2">\n      </span><span class="s1">try {</span><span class="s2">\n        </span><span class="s1">return cb();</span><span class="s2">\n      </span><span class="s1">} finally {</span><span class="s2">\n        </span><span class="s1">this.state.isAmbientContext = oldIsAmbientContext;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseClass&lt;T extends N.Class&gt;(</span><span class="s2">\n      </span><span class="s1">node: Undone&lt;T&gt;,</span><span class="s2">\n      </span><span class="s1">isStatement: boolean,</span><span class="s2">\n      </span><span class="s1">optionalId?: boolean,</span><span class="s2">\n    </span><span class="s1">): T {</span><span class="s2">\n      </span><span class="s1">const oldInAbstractClass = this.state.inAbstractClass;</span><span class="s2">\n      </span><span class="s1">this.state.inAbstractClass = !!(node as any).abstract;</span><span class="s2">\n      </span><span class="s1">try {</span><span class="s2">\n        </span><span class="s1">return super.parseClass(node, isStatement, optionalId);</span><span class="s2">\n      </span><span class="s1">} finally {</span><span class="s2">\n        </span><span class="s1">this.state.inAbstractClass = oldInAbstractClass;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsParseAbstractDeclaration(</span><span class="s2">\n      </span><span class="s1">node: any,</span><span class="s2">\n      </span><span class="s1">decorators: N.Decorator[] | null,</span><span class="s2">\n    </span><span class="s1">): N.ClassDeclaration | N.TsInterfaceDeclaration | undefined | null {</span><span class="s2">\n      </span><span class="s1">if (this.match(tt._class)) {</span><span class="s2">\n        </span><span class="s1">node.abstract = true;</span><span class="s2">\n        </span><span class="s1">return this.maybeTakeDecorators(</span><span class="s2">\n          </span><span class="s1">decorators,</span><span class="s2">\n          </span><span class="s1">this.parseClass&lt;N.ClassDeclaration&gt;(</span><span class="s2">\n            </span><span class="s1">node as N.ClassDeclaration,</span><span class="s2">\n            </span><span class="s1">/* isStatement */ true,</span><span class="s2">\n            </span><span class="s1">/* optionalId */ false,</span><span class="s2">\n          </span><span class="s1">),</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">} else if (this.isContextual(tt._interface)) {</span><span class="s2">\n        </span><span class="s1">// for invalid abstract interface</span><span class="s2">\n\n        </span><span class="s1">// To avoid</span><span class="s2">\n        </span><span class="s1">//   abstract interface</span><span class="s2">\n        </span><span class="s1">//   Foo {}</span><span class="s2">\n        </span><span class="s1">if (!this.hasFollowingLineBreak()) {</span><span class="s2">\n          </span><span class="s1">node.abstract = true;</span><span class="s2">\n          </span><span class="s1">this.raise(TSErrors.NonClassMethodPropertyHasAbstractModifer, {</span><span class="s2">\n            </span><span class="s1">at: node,</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n          </span><span class="s1">return this.tsParseInterfaceDeclaration(</span><span class="s2">\n            </span><span class="s1">node as N.TsInterfaceDeclaration,</span><span class="s2">\n          </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">this.unexpected(null, tt._class);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseMethod&lt;</span><span class="s2">\n      </span><span class="s1">T extends N.ObjectMethod | N.ClassMethod | N.ClassPrivateMethod,</span><span class="s2">\n    </span><span class="s1">&gt;(</span><span class="s2">\n      </span><span class="s1">node: Undone&lt;T&gt;,</span><span class="s2">\n      </span><span class="s1">isGenerator: boolean,</span><span class="s2">\n      </span><span class="s1">isAsync: boolean,</span><span class="s2">\n      </span><span class="s1">isConstructor: boolean,</span><span class="s2">\n      </span><span class="s1">allowDirectSuper: boolean,</span><span class="s2">\n      </span><span class="s1">type: T[</span><span class="s2">\&quot;</span><span class="s1">type</span><span class="s2">\&quot;</span><span class="s1">],</span><span class="s2">\n      </span><span class="s1">inClassScope?: boolean,</span><span class="s2">\n    </span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">const method = super.parseMethod&lt;T&gt;(</span><span class="s2">\n        </span><span class="s1">node,</span><span class="s2">\n        </span><span class="s1">isGenerator,</span><span class="s2">\n        </span><span class="s1">isAsync,</span><span class="s2">\n        </span><span class="s1">isConstructor,</span><span class="s2">\n        </span><span class="s1">allowDirectSuper,</span><span class="s2">\n        </span><span class="s1">type,</span><span class="s2">\n        </span><span class="s1">inClassScope,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts) property not defined for all types in union</span><span class="s2">\n      </span><span class="s1">if (method.abstract) {</span><span class="s2">\n        </span><span class="s1">const hasBody = this.hasPlugin(</span><span class="s2">\&quot;</span><span class="s1">estree</span><span class="s2">\&quot;</span><span class="s1">)</span><span class="s2">\n          </span><span class="s1">? // @ts-expect-error estree typings</span><span class="s2">\n            </span><span class="s1">!!method.value.body</span><span class="s2">\n          </span><span class="s1">: !!method.body;</span><span class="s2">\n        </span><span class="s1">if (hasBody) {</span><span class="s2">\n          </span><span class="s1">const { key } = method;</span><span class="s2">\n          </span><span class="s1">this.raise(TSErrors.AbstractMethodHasImplementation, {</span><span class="s2">\n            </span><span class="s1">at: method,</span><span class="s2">\n            </span><span class="s1">methodName:</span><span class="s2">\n              </span><span class="s1">key.type === </span><span class="s2">\&quot;</span><span class="s1">Identifier</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; !method.computed</span><span class="s2">\n                </span><span class="s1">? key.name</span><span class="s2">\n                </span><span class="s1">: `[${this.input.slice(key.start, key.end)}]`,</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return method;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">tsParseTypeParameterName(): N.Identifier | string {</span><span class="s2">\n      </span><span class="s1">const typeName: N.Identifier = this.parseIdentifier();</span><span class="s2">\n      </span><span class="s1">return process.env.BABEL_8_BREAKING ? typeName : typeName.name;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">shouldParseAsAmbientContext(): boolean {</span><span class="s2">\n      </span><span class="s1">return !!this.getPluginOption(</span><span class="s2">\&quot;</span><span class="s1">typescript</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">dts</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parse() {</span><span class="s2">\n      </span><span class="s1">if (this.shouldParseAsAmbientContext()) {</span><span class="s2">\n        </span><span class="s1">this.state.isAmbientContext = true;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return super.parse();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">getExpression() {</span><span class="s2">\n      </span><span class="s1">if (this.shouldParseAsAmbientContext()) {</span><span class="s2">\n        </span><span class="s1">this.state.isAmbientContext = true;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return super.getExpression();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseExportSpecifier(</span><span class="s2">\n      </span><span class="s1">node: Undone&lt;N.ExportSpecifier&gt;,</span><span class="s2">\n      </span><span class="s1">isString: boolean,</span><span class="s2">\n      </span><span class="s1">isInTypeExport: boolean,</span><span class="s2">\n      </span><span class="s1">isMaybeTypeOnly: boolean,</span><span class="s2">\n    </span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">if (!isString &amp;&amp; isMaybeTypeOnly) {</span><span class="s2">\n        </span><span class="s1">this.parseTypeOnlyImportExportSpecifier(</span><span class="s2">\n          </span><span class="s1">node,</span><span class="s2">\n          </span><span class="s1">/* isImport */ false,</span><span class="s2">\n          </span><span class="s1">isInTypeExport,</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">return this.finishNode&lt;N.ExportSpecifier&gt;(node, </span><span class="s2">\&quot;</span><span class="s1">ExportSpecifier</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">node.exportKind = </span><span class="s2">\&quot;</span><span class="s1">value</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n      </span><span class="s1">return super.parseExportSpecifier(</span><span class="s2">\n        </span><span class="s1">node,</span><span class="s2">\n        </span><span class="s1">isString,</span><span class="s2">\n        </span><span class="s1">isInTypeExport,</span><span class="s2">\n        </span><span class="s1">isMaybeTypeOnly,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseImportSpecifier(</span><span class="s2">\n      </span><span class="s1">specifier: Undone&lt;N.ImportSpecifier&gt;,</span><span class="s2">\n      </span><span class="s1">importedIsString: boolean,</span><span class="s2">\n      </span><span class="s1">isInTypeOnlyImport: boolean,</span><span class="s2">\n      </span><span class="s1">isMaybeTypeOnly: boolean,</span><span class="s2">\n      </span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-unused-vars</span><span class="s2">\n      </span><span class="s1">bindingType: BindingTypes | undefined,</span><span class="s2">\n    </span><span class="s1">): N.ImportSpecifier {</span><span class="s2">\n      </span><span class="s1">if (!importedIsString &amp;&amp; isMaybeTypeOnly) {</span><span class="s2">\n        </span><span class="s1">this.parseTypeOnlyImportExportSpecifier(</span><span class="s2">\n          </span><span class="s1">specifier,</span><span class="s2">\n          </span><span class="s1">/* isImport */ true,</span><span class="s2">\n          </span><span class="s1">isInTypeOnlyImport,</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">return this.finishNode&lt;N.ImportSpecifier&gt;(specifier, </span><span class="s2">\&quot;</span><span class="s1">ImportSpecifier</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">specifier.importKind = </span><span class="s2">\&quot;</span><span class="s1">value</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n      </span><span class="s1">return super.parseImportSpecifier(</span><span class="s2">\n        </span><span class="s1">specifier,</span><span class="s2">\n        </span><span class="s1">importedIsString,</span><span class="s2">\n        </span><span class="s1">isInTypeOnlyImport,</span><span class="s2">\n        </span><span class="s1">isMaybeTypeOnly,</span><span class="s2">\n        </span><span class="s1">isInTypeOnlyImport ? BIND_TS_TYPE_IMPORT : BIND_FLAGS_TS_IMPORT,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseTypeOnlyImportExportSpecifier(</span><span class="s2">\n      </span><span class="s1">node: any,</span><span class="s2">\n      </span><span class="s1">isImport: boolean,</span><span class="s2">\n      </span><span class="s1">isInTypeOnlyImportExport: boolean,</span><span class="s2">\n    </span><span class="s1">): void {</span><span class="s2">\n      </span><span class="s1">const leftOfAsKey = isImport ? </span><span class="s2">\&quot;</span><span class="s1">imported</span><span class="s2">\&quot; </span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">local</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n      </span><span class="s1">const rightOfAsKey = isImport ? </span><span class="s2">\&quot;</span><span class="s1">local</span><span class="s2">\&quot; </span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">exported</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n      </span><span class="s1">let leftOfAs = node[leftOfAsKey];</span><span class="s2">\n      </span><span class="s1">let rightOfAs;</span><span class="s2">\n\n      </span><span class="s1">let hasTypeSpecifier = false;</span><span class="s2">\n      </span><span class="s1">let canParseAsKeyword = true;</span><span class="s2">\n\n      </span><span class="s1">const loc = leftOfAs.loc.start;</span><span class="s2">\n\n      </span><span class="s1">// https://github.com/microsoft/TypeScript/blob/fc4f9d83d5939047aa6bb2a43965c6e9bbfbc35b/src/compiler/parser.ts#L7411-L7456</span><span class="s2">\n      </span><span class="s1">// import { type } from </span><span class="s2">\&quot;</span><span class="s1">mod</span><span class="s2">\&quot;</span><span class="s1">;          - hasTypeSpecifier: false, leftOfAs: type</span><span class="s2">\n      </span><span class="s1">// import { type as } from </span><span class="s2">\&quot;</span><span class="s1">mod</span><span class="s2">\&quot;</span><span class="s1">;       - hasTypeSpecifier: true,  leftOfAs: as</span><span class="s2">\n      </span><span class="s1">// import { type as as } from </span><span class="s2">\&quot;</span><span class="s1">mod</span><span class="s2">\&quot;</span><span class="s1">;    - hasTypeSpecifier: false, leftOfAs: type, rightOfAs: as</span><span class="s2">\n      </span><span class="s1">// import { type as as as } from </span><span class="s2">\&quot;</span><span class="s1">mod</span><span class="s2">\&quot;</span><span class="s1">; - hasTypeSpecifier: true,  leftOfAs: as,   rightOfAs: as</span><span class="s2">\n      </span><span class="s1">if (this.isContextual(tt._as)) {</span><span class="s2">\n        </span><span class="s1">// { type as ...? }</span><span class="s2">\n        </span><span class="s1">const firstAs = this.parseIdentifier();</span><span class="s2">\n        </span><span class="s1">if (this.isContextual(tt._as)) {</span><span class="s2">\n          </span><span class="s1">// { type as as ...? }</span><span class="s2">\n          </span><span class="s1">const secondAs = this.parseIdentifier();</span><span class="s2">\n          </span><span class="s1">if (tokenIsKeywordOrIdentifier(this.state.type)) {</span><span class="s2">\n            </span><span class="s1">// { type as as something }</span><span class="s2">\n            </span><span class="s1">hasTypeSpecifier = true;</span><span class="s2">\n            </span><span class="s1">leftOfAs = firstAs;</span><span class="s2">\n            </span><span class="s1">rightOfAs = isImport</span><span class="s2">\n              </span><span class="s1">? this.parseIdentifier()</span><span class="s2">\n              </span><span class="s1">: this.parseModuleExportName();</span><span class="s2">\n            </span><span class="s1">canParseAsKeyword = false;</span><span class="s2">\n          </span><span class="s1">} else {</span><span class="s2">\n            </span><span class="s1">// { type as as }</span><span class="s2">\n            </span><span class="s1">rightOfAs = secondAs;</span><span class="s2">\n            </span><span class="s1">canParseAsKeyword = false;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">} else if (tokenIsKeywordOrIdentifier(this.state.type)) {</span><span class="s2">\n          </span><span class="s1">// { type as something }</span><span class="s2">\n          </span><span class="s1">canParseAsKeyword = false;</span><span class="s2">\n          </span><span class="s1">rightOfAs = isImport</span><span class="s2">\n            </span><span class="s1">? this.parseIdentifier()</span><span class="s2">\n            </span><span class="s1">: this.parseModuleExportName();</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">// { type as }</span><span class="s2">\n          </span><span class="s1">hasTypeSpecifier = true;</span><span class="s2">\n          </span><span class="s1">leftOfAs = firstAs;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">} else if (tokenIsKeywordOrIdentifier(this.state.type)) {</span><span class="s2">\n        </span><span class="s1">// { type something ...? }</span><span class="s2">\n        </span><span class="s1">hasTypeSpecifier = true;</span><span class="s2">\n        </span><span class="s1">if (isImport) {</span><span class="s2">\n          </span><span class="s1">leftOfAs = this.parseIdentifier(true);</span><span class="s2">\n          </span><span class="s1">if (!this.isContextual(tt._as)) {</span><span class="s2">\n            </span><span class="s1">this.checkReservedWord(</span><span class="s2">\n              </span><span class="s1">leftOfAs.name,</span><span class="s2">\n              </span><span class="s1">leftOfAs.loc.start,</span><span class="s2">\n              </span><span class="s1">true,</span><span class="s2">\n              </span><span class="s1">true,</span><span class="s2">\n            </span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">leftOfAs = this.parseModuleExportName();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (hasTypeSpecifier &amp;&amp; isInTypeOnlyImportExport) {</span><span class="s2">\n        </span><span class="s1">this.raise(</span><span class="s2">\n          </span><span class="s1">isImport</span><span class="s2">\n            </span><span class="s1">? TSErrors.TypeModifierIsUsedInTypeImports</span><span class="s2">\n            </span><span class="s1">: TSErrors.TypeModifierIsUsedInTypeExports,</span><span class="s2">\n          </span><span class="s1">{ at: loc },</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">node[leftOfAsKey] = leftOfAs;</span><span class="s2">\n      </span><span class="s1">node[rightOfAsKey] = rightOfAs;</span><span class="s2">\n\n      </span><span class="s1">const kindKey = isImport ? </span><span class="s2">\&quot;</span><span class="s1">importKind</span><span class="s2">\&quot; </span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">exportKind</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n      </span><span class="s1">node[kindKey] = hasTypeSpecifier ? </span><span class="s2">\&quot;</span><span class="s1">type</span><span class="s2">\&quot; </span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">value</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n      </span><span class="s1">if (canParseAsKeyword &amp;&amp; this.eatContextual(tt._as)) {</span><span class="s2">\n        </span><span class="s1">node[rightOfAsKey] = isImport</span><span class="s2">\n          </span><span class="s1">? this.parseIdentifier()</span><span class="s2">\n          </span><span class="s1">: this.parseModuleExportName();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (!node[rightOfAsKey]) {</span><span class="s2">\n        </span><span class="s1">node[rightOfAsKey] = cloneIdentifier(node[leftOfAsKey]);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (isImport) {</span><span class="s2">\n        </span><span class="s1">this.checkIdentifier(</span><span class="s2">\n          </span><span class="s1">node[rightOfAsKey],</span><span class="s2">\n          </span><span class="s1">hasTypeSpecifier ? BIND_TS_TYPE_IMPORT : BIND_FLAGS_TS_IMPORT,</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">function isPossiblyLiteralEnum(expression: N.Expression): boolean {</span><span class="s2">\n  </span><span class="s1">if (expression.type !== </span><span class="s2">\&quot;</span><span class="s1">MemberExpression</span><span class="s2">\&quot;</span><span class="s1">) return false;</span><span class="s2">\n\n  </span><span class="s1">const { computed, property } = expression;</span><span class="s2">\n\n  </span><span class="s1">if (</span><span class="s2">\n    </span><span class="s1">computed &amp;&amp;</span><span class="s2">\n    </span><span class="s1">property.type !== </span><span class="s2">\&quot;</span><span class="s1">StringLiteral</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n    </span><span class="s1">(property.type !== </span><span class="s2">\&quot;</span><span class="s1">TemplateLiteral</span><span class="s2">\&quot; </span><span class="s1">|| property.expressions.length &gt; 0)</span><span class="s2">\n  </span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">return false;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">return isUncomputedMemberExpressionChain(expression.object);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// If a const declaration has no type annotation and is initialized to</span><span class="s2">\n</span><span class="s1">// a string literal, numeric literal, or enum reference, then it is</span><span class="s2">\n</span><span class="s1">// allowed. In an ideal world, we'd check whether init was *actually* an</span><span class="s2">\n</span><span class="s1">// enum reference, but we allow anything that </span><span class="s2">\&quot;</span><span class="s1">could be</span><span class="s2">\&quot; </span><span class="s1">a literal enum</span><span class="s2">\n</span><span class="s1">// in `isPossiblyLiteralEnum` since we don't have all the information</span><span class="s2">\n</span><span class="s1">// that the typescript compiler has.</span><span class="s2">\n</span><span class="s1">function isValidAmbientConstInitializer(</span><span class="s2">\n  </span><span class="s1">expression: N.Expression,</span><span class="s2">\n  </span><span class="s1">estree: boolean,</span><span class="s2">\n</span><span class="s1">): boolean {</span><span class="s2">\n  </span><span class="s1">const { type } = expression;</span><span class="s2">\n  </span><span class="s1">if (expression.extra?.parenthesized) {</span><span class="s2">\n    </span><span class="s1">return false;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (estree) {</span><span class="s2">\n    </span><span class="s1">if (type === </span><span class="s2">\&quot;</span><span class="s1">Literal</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">const { value } = expression;</span><span class="s2">\n      </span><span class="s1">if (typeof value === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">|| typeof value === </span><span class="s2">\&quot;</span><span class="s1">boolean</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">return true;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">if (type === </span><span class="s2">\&quot;</span><span class="s1">StringLiteral</span><span class="s2">\&quot; </span><span class="s1">|| type === </span><span class="s2">\&quot;</span><span class="s1">BooleanLiteral</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">return true;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (isNumber(expression, estree) || isNegativeNumber(expression, estree)) {</span><span class="s2">\n    </span><span class="s1">return true;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (type === </span><span class="s2">\&quot;</span><span class="s1">TemplateLiteral</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; expression.expressions.length === 0) {</span><span class="s2">\n    </span><span class="s1">return true;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">if (isPossiblyLiteralEnum(expression)) {</span><span class="s2">\n    </span><span class="s1">return true;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return false;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function isNumber(expression: N.Expression, estree: boolean): boolean {</span><span class="s2">\n  </span><span class="s1">if (estree) {</span><span class="s2">\n    </span><span class="s1">return (</span><span class="s2">\n      </span><span class="s1">expression.type === </span><span class="s2">\&quot;</span><span class="s1">Literal</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n      </span><span class="s1">(typeof expression.value === </span><span class="s2">\&quot;</span><span class="s1">number</span><span class="s2">\&quot; </span><span class="s1">|| </span><span class="s2">\&quot;</span><span class="s1">bigint</span><span class="s2">\&quot; </span><span class="s1">in expression)</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">return (</span><span class="s2">\n      </span><span class="s1">expression.type === </span><span class="s2">\&quot;</span><span class="s1">NumericLiteral</span><span class="s2">\&quot; </span><span class="s1">||</span><span class="s2">\n      </span><span class="s1">expression.type === </span><span class="s2">\&quot;</span><span class="s1">BigIntLiteral</span><span class="s2">\&quot;\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function isNegativeNumber(expression: N.Expression, estree: boolean): boolean {</span><span class="s2">\n  </span><span class="s1">if (expression.type === </span><span class="s2">\&quot;</span><span class="s1">UnaryExpression</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">const { operator, argument } = expression as N.UnaryExpression;</span><span class="s2">\n    </span><span class="s1">if (operator === </span><span class="s2">\&quot;</span><span class="s1">-</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; isNumber(argument, estree)) {</span><span class="s2">\n      </span><span class="s1">return true;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return false;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function isUncomputedMemberExpressionChain(expression: N.Expression): boolean {</span><span class="s2">\n  </span><span class="s1">if (expression.type === </span><span class="s2">\&quot;</span><span class="s1">Identifier</span><span class="s2">\&quot;</span><span class="s1">) return true;</span><span class="s2">\n  </span><span class="s1">if (expression.type !== </span><span class="s2">\&quot;</span><span class="s1">MemberExpression</span><span class="s2">\&quot;</span><span class="s1">) return false;</span><span class="s2">\n  </span><span class="s1">if (expression.computed) return false;</span><span class="s2">\n\n  </span><span class="s1">return isUncomputedMemberExpressionChain(expression.object);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">&quot;</span><span class="s2">,</span><span class="s1">&quot;import * as charCodes from </span><span class="s2">\&quot;</span><span class="s1">charcodes</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">import { tokenLabelName, tt } from </span><span class="s2">\&quot;</span><span class="s1">../tokenizer/types</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type Parser from </span><span class="s2">\&quot;</span><span class="s1">../parser</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type * as N from </span><span class="s2">\&quot;</span><span class="s1">../types</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import { ParseErrorEnum } from </span><span class="s2">\&quot;</span><span class="s1">../parse-error</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type { Undone } from </span><span class="s2">\&quot;</span><span class="s1">../parser/node</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type { ExpressionErrors } from </span><span class="s2">\&quot;</span><span class="s1">../parser/util</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type { BindingTypes } from </span><span class="s2">\&quot;</span><span class="s1">../util/scopeflags</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type { Position } from </span><span class="s2">\&quot;</span><span class="s1">../util/location</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">type PossiblePlaceholders = {</span><span class="s2">\n  </span><span class="s1">Identifier: N.Identifier;</span><span class="s2">\n  </span><span class="s1">StringLiteral: N.StringLiteral;</span><span class="s2">\n  </span><span class="s1">Expression: N.Expression;</span><span class="s2">\n  </span><span class="s1">Statement: N.Statement;</span><span class="s2">\n  </span><span class="s1">Declaration: N.Declaration;</span><span class="s2">\n  </span><span class="s1">BlockStatement: N.BlockStatement;</span><span class="s2">\n  </span><span class="s1">ClassBody: N.ClassBody;</span><span class="s2">\n  </span><span class="s1">Pattern: N.Pattern;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">export type PlaceholderTypes = keyof PossiblePlaceholders;</span><span class="s2">\n\n</span><span class="s1">type NodeOf&lt;T extends keyof PossiblePlaceholders&gt; = PossiblePlaceholders[T];</span><span class="s2">\n</span><span class="s1">// todo: when there  is proper union type for Node</span><span class="s2">\n</span><span class="s1">// type NodeOf&lt;T extends PlaceholderTypes&gt; = Extract&lt;N.Node, { type: T }&gt;;</span><span class="s2">\n\n</span><span class="s1">// todo: Placeholder&lt;T&gt; breaks everything, because its type is incompatible with</span><span class="s2">\n</span><span class="s1">// the substituted nodes.</span><span class="s2">\n</span><span class="s1">type MaybePlaceholder&lt;T extends PlaceholderTypes&gt; = NodeOf&lt;T&gt;; // | Placeholder&lt;T&gt;</span><span class="s2">\n\n</span><span class="s1">/* eslint sort-keys: </span><span class="s2">\&quot;</span><span class="s1">error</span><span class="s2">\&quot; </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const PlaceholderErrors = ParseErrorEnum`placeholders`({</span><span class="s2">\n  </span><span class="s1">ClassNameIsRequired: </span><span class="s2">\&quot;</span><span class="s1">A class name is required.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">UnexpectedSpace: </span><span class="s2">\&quot;</span><span class="s1">Unexpected space in placeholder.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n</span><span class="s1">});</span><span class="s2">\n\n</span><span class="s1">/* eslint-disable sort-keys */</span><span class="s2">\n\n</span><span class="s1">export default (superClass: typeof Parser) =&gt;</span><span class="s2">\n  </span><span class="s1">class PlaceholdersParserMixin extends superClass implements Parser {</span><span class="s2">\n    </span><span class="s1">parsePlaceholder&lt;T extends PlaceholderTypes&gt;(</span><span class="s2">\n      </span><span class="s1">expectedNode: T,</span><span class="s2">\n    </span><span class="s1">): /*?N.Placeholder&lt;T&gt;*/ MaybePlaceholder&lt;T&gt; | undefined | null {</span><span class="s2">\n      </span><span class="s1">if (this.match(tt.placeholder)) {</span><span class="s2">\n        </span><span class="s1">const node = this.startNode();</span><span class="s2">\n        </span><span class="s1">this.next();</span><span class="s2">\n        </span><span class="s1">this.assertNoSpace();</span><span class="s2">\n\n        </span><span class="s1">// We can't use this.parseIdentifier because</span><span class="s2">\n        </span><span class="s1">// we don't want nested placeholders.</span><span class="s2">\n        </span><span class="s1">node.name = super.parseIdentifier(/* liberal */ true);</span><span class="s2">\n\n        </span><span class="s1">this.assertNoSpace();</span><span class="s2">\n        </span><span class="s1">this.expect(tt.placeholder);</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error placeholder typings</span><span class="s2">\n        </span><span class="s1">return this.finishPlaceholder(node, expectedNode);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">finishPlaceholder&lt;T extends PlaceholderTypes&gt;(</span><span class="s2">\n      </span><span class="s1">node: N.Node,</span><span class="s2">\n      </span><span class="s1">expectedNode: T,</span><span class="s2">\n    </span><span class="s1">): /*N.Placeholder&lt;T&gt;*/ MaybePlaceholder&lt;T&gt; {</span><span class="s2">\n      </span><span class="s1">const isFinished = !!(node.expectedNode &amp;&amp; node.type === </span><span class="s2">\&quot;</span><span class="s1">Placeholder</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">node.expectedNode = expectedNode;</span><span class="s2">\n\n      </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts)</span><span class="s2">\n      </span><span class="s1">return isFinished ? node : this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">Placeholder</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">/* ============================================================ *</span><span class="s2">\n     </span><span class="s1">* tokenizer/index.js                                           *</span><span class="s2">\n     </span><span class="s1">* ============================================================ */</span><span class="s2">\n\n    </span><span class="s1">getTokenFromCode(code: number) {</span><span class="s2">\n      </span><span class="s1">if (</span><span class="s2">\n        </span><span class="s1">code === charCodes.percentSign &amp;&amp;</span><span class="s2">\n        </span><span class="s1">this.input.charCodeAt(this.state.pos + 1) === charCodes.percentSign</span><span class="s2">\n      </span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">this.finishOp(tt.placeholder, 2);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">super.getTokenFromCode(code);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">/* ============================================================ *</span><span class="s2">\n     </span><span class="s1">* parser/expression.js                                         *</span><span class="s2">\n     </span><span class="s1">* ============================================================ */</span><span class="s2">\n\n    </span><span class="s1">parseExprAtom(</span><span class="s2">\n      </span><span class="s1">refExpressionErrors?: ExpressionErrors | null,</span><span class="s2">\n    </span><span class="s1">): MaybePlaceholder&lt;</span><span class="s2">\&quot;</span><span class="s1">Expression</span><span class="s2">\&quot;</span><span class="s1">&gt; {</span><span class="s2">\n      </span><span class="s1">return (</span><span class="s2">\n        </span><span class="s1">this.parsePlaceholder(</span><span class="s2">\&quot;</span><span class="s1">Expression</span><span class="s2">\&quot;</span><span class="s1">) ||</span><span class="s2">\n        </span><span class="s1">super.parseExprAtom(refExpressionErrors)</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseIdentifier(liberal?: boolean): MaybePlaceholder&lt;</span><span class="s2">\&quot;</span><span class="s1">Identifier</span><span class="s2">\&quot;</span><span class="s1">&gt; {</span><span class="s2">\n      </span><span class="s1">// NOTE: This function only handles identifiers outside of</span><span class="s2">\n      </span><span class="s1">// expressions and binding patterns, since they are already</span><span class="s2">\n      </span><span class="s1">// handled by the parseExprAtom and parseBindingAtom functions.</span><span class="s2">\n      </span><span class="s1">// This is needed, for example, to parse </span><span class="s2">\&quot;</span><span class="s1">class %%NAME%% {}</span><span class="s2">\&quot;</span><span class="s1">.</span><span class="s2">\n      </span><span class="s1">return (</span><span class="s2">\n        </span><span class="s1">this.parsePlaceholder(</span><span class="s2">\&quot;</span><span class="s1">Identifier</span><span class="s2">\&quot;</span><span class="s1">) || super.parseIdentifier(liberal)</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">checkReservedWord(</span><span class="s2">\n      </span><span class="s1">word: string,</span><span class="s2">\n      </span><span class="s1">startLoc: Position,</span><span class="s2">\n      </span><span class="s1">checkKeywords: boolean,</span><span class="s2">\n      </span><span class="s1">isBinding: boolean,</span><span class="s2">\n    </span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">// Sometimes we call #checkReservedWord(node.name), expecting</span><span class="s2">\n      </span><span class="s1">// that node is an Identifier. If it is a Placeholder, name</span><span class="s2">\n      </span><span class="s1">// will be undefined.</span><span class="s2">\n      </span><span class="s1">if (word !== undefined) {</span><span class="s2">\n        </span><span class="s1">super.checkReservedWord(word, startLoc, checkKeywords, isBinding);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">/* ============================================================ *</span><span class="s2">\n     </span><span class="s1">* parser/lval.js                                               *</span><span class="s2">\n     </span><span class="s1">* ============================================================ */</span><span class="s2">\n\n    </span><span class="s1">parseBindingAtom(): MaybePlaceholder&lt;</span><span class="s2">\&quot;</span><span class="s1">Pattern</span><span class="s2">\&quot;</span><span class="s1">&gt; {</span><span class="s2">\n      </span><span class="s1">return this.parsePlaceholder(</span><span class="s2">\&quot;</span><span class="s1">Pattern</span><span class="s2">\&quot;</span><span class="s1">) || super.parseBindingAtom();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">isValidLVal(type: string, isParenthesized: boolean, binding: BindingTypes) {</span><span class="s2">\n      </span><span class="s1">return (</span><span class="s2">\n        </span><span class="s1">type === </span><span class="s2">\&quot;</span><span class="s1">Placeholder</span><span class="s2">\&quot; </span><span class="s1">||</span><span class="s2">\n        </span><span class="s1">super.isValidLVal(type, isParenthesized, binding)</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">toAssignable(node: N.Node, isLHS: boolean): void {</span><span class="s2">\n      </span><span class="s1">if (</span><span class="s2">\n        </span><span class="s1">node &amp;&amp;</span><span class="s2">\n        </span><span class="s1">node.type === </span><span class="s2">\&quot;</span><span class="s1">Placeholder</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n        </span><span class="s1">node.expectedNode === </span><span class="s2">\&quot;</span><span class="s1">Expression</span><span class="s2">\&quot;\n      </span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">node.expectedNode = </span><span class="s2">\&quot;</span><span class="s1">Pattern</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">super.toAssignable(node, isLHS);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">/* ============================================================ *</span><span class="s2">\n     </span><span class="s1">* parser/statement.js                                          *</span><span class="s2">\n     </span><span class="s1">* ============================================================ */</span><span class="s2">\n\n    </span><span class="s1">chStartsBindingIdentifier(ch: number, pos: number): boolean {</span><span class="s2">\n      </span><span class="s1">if (super.chStartsBindingIdentifier(ch, pos)) {</span><span class="s2">\n        </span><span class="s1">return true;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">// Accept </span><span class="s2">\&quot;</span><span class="s1">let %%</span><span class="s2">\&quot; </span><span class="s1">as the start of </span><span class="s2">\&quot;</span><span class="s1">let %%placeholder%%</span><span class="s2">\&quot;</span><span class="s1">, as though the</span><span class="s2">\n      </span><span class="s1">// placeholder were an identifier.</span><span class="s2">\n      </span><span class="s1">const nextToken = this.lookahead();</span><span class="s2">\n      </span><span class="s1">if (nextToken.type === tt.placeholder) {</span><span class="s2">\n        </span><span class="s1">return true;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return false;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">verifyBreakContinue(</span><span class="s2">\n      </span><span class="s1">node: N.BreakStatement | N.ContinueStatement,</span><span class="s2">\n      </span><span class="s1">isBreak: boolean,</span><span class="s2">\n    </span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">// @ts-expect-error: node.label could be Placeholder</span><span class="s2">\n      </span><span class="s1">if (node.label &amp;&amp; node.label.type === </span><span class="s2">\&quot;</span><span class="s1">Placeholder</span><span class="s2">\&quot;</span><span class="s1">) return;</span><span class="s2">\n      </span><span class="s1">super.verifyBreakContinue(node, isBreak);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// @ts-expect-error Plugin will override parser interface</span><span class="s2">\n    </span><span class="s1">parseExpressionStatement(</span><span class="s2">\n      </span><span class="s1">node: MaybePlaceholder&lt;</span><span class="s2">\&quot;</span><span class="s1">Statement</span><span class="s2">\&quot;</span><span class="s1">&gt;,</span><span class="s2">\n      </span><span class="s1">expr: N.Expression,</span><span class="s2">\n    </span><span class="s1">): MaybePlaceholder&lt;</span><span class="s2">\&quot;</span><span class="s1">Statement</span><span class="s2">\&quot;</span><span class="s1">&gt; {</span><span class="s2">\n      </span><span class="s1">if (</span><span class="s2">\n        </span><span class="s1">expr.type !== </span><span class="s2">\&quot;</span><span class="s1">Placeholder</span><span class="s2">\&quot; </span><span class="s1">||</span><span class="s2">\n        </span><span class="s1">(expr.extra &amp;&amp; expr.extra.parenthesized)</span><span class="s2">\n      </span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error placeholder typings</span><span class="s2">\n        </span><span class="s1">return super.parseExpressionStatement(node, expr);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">if (this.match(tt.colon)) {</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error placeholder typings</span><span class="s2">\n        </span><span class="s1">const stmt: N.LabeledStatement = node;</span><span class="s2">\n        </span><span class="s1">stmt.label = this.finishPlaceholder(expr, </span><span class="s2">\&quot;</span><span class="s1">Identifier</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">this.next();</span><span class="s2">\n        </span><span class="s1">stmt.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration();</span><span class="s2">\n        </span><span class="s1">return this.finishNode(stmt, </span><span class="s2">\&quot;</span><span class="s1">LabeledStatement</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">this.semicolon();</span><span class="s2">\n      </span><span class="s1">node.name = expr.name;</span><span class="s2">\n      </span><span class="s1">return this.finishPlaceholder(node, </span><span class="s2">\&quot;</span><span class="s1">Statement</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseBlock(</span><span class="s2">\n      </span><span class="s1">allowDirectives?: boolean,</span><span class="s2">\n      </span><span class="s1">createNewLexicalScope?: boolean,</span><span class="s2">\n      </span><span class="s1">afterBlockParse?: (hasStrictModeDirective: boolean) =&gt; void,</span><span class="s2">\n    </span><span class="s1">): MaybePlaceholder&lt;</span><span class="s2">\&quot;</span><span class="s1">BlockStatement</span><span class="s2">\&quot;</span><span class="s1">&gt; {</span><span class="s2">\n      </span><span class="s1">return (</span><span class="s2">\n        </span><span class="s1">this.parsePlaceholder(</span><span class="s2">\&quot;</span><span class="s1">BlockStatement</span><span class="s2">\&quot;</span><span class="s1">) ||</span><span class="s2">\n        </span><span class="s1">super.parseBlock(</span><span class="s2">\n          </span><span class="s1">allowDirectives,</span><span class="s2">\n          </span><span class="s1">createNewLexicalScope,</span><span class="s2">\n          </span><span class="s1">afterBlockParse,</span><span class="s2">\n        </span><span class="s1">)</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseFunctionId(</span><span class="s2">\n      </span><span class="s1">requireId?: boolean,</span><span class="s2">\n    </span><span class="s1">): MaybePlaceholder&lt;</span><span class="s2">\&quot;</span><span class="s1">Identifier</span><span class="s2">\&quot;</span><span class="s1">&gt; | undefined | null {</span><span class="s2">\n      </span><span class="s1">return (</span><span class="s2">\n        </span><span class="s1">this.parsePlaceholder(</span><span class="s2">\&quot;</span><span class="s1">Identifier</span><span class="s2">\&quot;</span><span class="s1">) || super.parseFunctionId(requireId)</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// @ts-expect-error Plugin will override parser interface</span><span class="s2">\n    </span><span class="s1">parseClass&lt;T extends N.Class&gt;(</span><span class="s2">\n      </span><span class="s1">node: T,</span><span class="s2">\n      </span><span class="s1">isStatement: /* T === ClassDeclaration */ boolean,</span><span class="s2">\n      </span><span class="s1">optionalId?: boolean,</span><span class="s2">\n    </span><span class="s1">): T {</span><span class="s2">\n      </span><span class="s1">const type = isStatement ? </span><span class="s2">\&quot;</span><span class="s1">ClassDeclaration</span><span class="s2">\&quot; </span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">ClassExpression</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n      </span><span class="s1">this.next();</span><span class="s2">\n      </span><span class="s1">const oldStrict = this.state.strict;</span><span class="s2">\n\n      </span><span class="s1">const placeholder = this.parsePlaceholder(</span><span class="s2">\&quot;</span><span class="s1">Identifier</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">if (placeholder) {</span><span class="s2">\n        </span><span class="s1">if (</span><span class="s2">\n          </span><span class="s1">this.match(tt._extends) ||</span><span class="s2">\n          </span><span class="s1">this.match(tt.placeholder) ||</span><span class="s2">\n          </span><span class="s1">this.match(tt.braceL)</span><span class="s2">\n        </span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">node.id = placeholder;</span><span class="s2">\n        </span><span class="s1">} else if (optionalId || !isStatement) {</span><span class="s2">\n          </span><span class="s1">node.id = null;</span><span class="s2">\n          </span><span class="s1">node.body = this.finishPlaceholder(placeholder, </span><span class="s2">\&quot;</span><span class="s1">ClassBody</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">return this.finishNode(node, type);</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">throw this.raise(PlaceholderErrors.ClassNameIsRequired, {</span><span class="s2">\n            </span><span class="s1">at: this.state.startLoc,</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">this.parseClassId(node, isStatement, optionalId);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">super.parseClassSuper(node);</span><span class="s2">\n      </span><span class="s1">node.body =</span><span class="s2">\n        </span><span class="s1">this.parsePlaceholder(</span><span class="s2">\&quot;</span><span class="s1">ClassBody</span><span class="s2">\&quot;</span><span class="s1">) ||</span><span class="s2">\n        </span><span class="s1">super.parseClassBody(!!node.superClass, oldStrict);</span><span class="s2">\n      </span><span class="s1">return this.finishNode(node, type);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseExport(node: N.Node, decorators: N.Decorator[] | null): N.AnyExport {</span><span class="s2">\n      </span><span class="s1">const placeholder = this.parsePlaceholder(</span><span class="s2">\&quot;</span><span class="s1">Identifier</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">if (!placeholder) return super.parseExport(node, decorators);</span><span class="s2">\n\n      </span><span class="s1">if (!this.isContextual(tt._from) &amp;&amp; !this.match(tt.comma)) {</span><span class="s2">\n        </span><span class="s1">// export %%DECL%%;</span><span class="s2">\n        </span><span class="s1">node.specifiers = [];</span><span class="s2">\n        </span><span class="s1">node.source = null;</span><span class="s2">\n        </span><span class="s1">node.declaration = this.finishPlaceholder(placeholder, </span><span class="s2">\&quot;</span><span class="s1">Declaration</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">ExportNamedDeclaration</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">// export %%NAME%% from </span><span class="s2">\&quot;</span><span class="s1">foo</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n      </span><span class="s1">this.expectPlugin(</span><span class="s2">\&quot;</span><span class="s1">exportDefaultFrom</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">const specifier = this.startNode();</span><span class="s2">\n      </span><span class="s1">specifier.exported = placeholder;</span><span class="s2">\n      </span><span class="s1">node.specifiers = [this.finishNode(specifier, </span><span class="s2">\&quot;</span><span class="s1">ExportDefaultSpecifier</span><span class="s2">\&quot;</span><span class="s1">)];</span><span class="s2">\n\n      </span><span class="s1">return super.parseExport(node, decorators);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">isExportDefaultSpecifier(): boolean {</span><span class="s2">\n      </span><span class="s1">if (this.match(tt._default)) {</span><span class="s2">\n        </span><span class="s1">const next = this.nextTokenStart();</span><span class="s2">\n        </span><span class="s1">if (this.isUnparsedContextual(next, </span><span class="s2">\&quot;</span><span class="s1">from</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n          </span><span class="s1">if (</span><span class="s2">\n            </span><span class="s1">this.input.startsWith(</span><span class="s2">\n              </span><span class="s1">tokenLabelName(tt.placeholder),</span><span class="s2">\n              </span><span class="s1">this.nextTokenStartSince(next + 4),</span><span class="s2">\n            </span><span class="s1">)</span><span class="s2">\n          </span><span class="s1">) {</span><span class="s2">\n            </span><span class="s1">return true;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return super.isExportDefaultSpecifier();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">maybeParseExportDefaultSpecifier(node: N.Node): boolean {</span><span class="s2">\n      </span><span class="s1">if (node.specifiers &amp;&amp; node.specifiers.length &gt; 0) {</span><span class="s2">\n        </span><span class="s1">// </span><span class="s2">\&quot;</span><span class="s1">export %%NAME%%</span><span class="s2">\&quot; </span><span class="s1">has already been parsed by #parseExport.</span><span class="s2">\n        </span><span class="s1">return true;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return super.maybeParseExportDefaultSpecifier(node);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">checkExport(node: N.ExportNamedDeclaration): void {</span><span class="s2">\n      </span><span class="s1">const { specifiers } = node;</span><span class="s2">\n      </span><span class="s1">if (specifiers?.length) {</span><span class="s2">\n        </span><span class="s1">node.specifiers = specifiers.filter(</span><span class="s2">\n          </span><span class="s1">// @ts-expect-error placeholder typings</span><span class="s2">\n          </span><span class="s1">node =&gt; node.exported.type === </span><span class="s2">\&quot;</span><span class="s1">Placeholder</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">super.checkExport(node);</span><span class="s2">\n      </span><span class="s1">node.specifiers = specifiers;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseImport(</span><span class="s2">\n      </span><span class="s1">node: Undone&lt;N.ImportDeclaration&gt;,</span><span class="s2">\n    </span><span class="s1">): N.ImportDeclaration | N.TsImportEqualsDeclaration {</span><span class="s2">\n      </span><span class="s1">const placeholder = this.parsePlaceholder(</span><span class="s2">\&quot;</span><span class="s1">Identifier</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">if (!placeholder) return super.parseImport(node);</span><span class="s2">\n\n      </span><span class="s1">node.specifiers = [];</span><span class="s2">\n\n      </span><span class="s1">if (!this.isContextual(tt._from) &amp;&amp; !this.match(tt.comma)) {</span><span class="s2">\n        </span><span class="s1">// import %%STRING%%;</span><span class="s2">\n        </span><span class="s1">node.source = this.finishPlaceholder(placeholder, </span><span class="s2">\&quot;</span><span class="s1">StringLiteral</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">this.semicolon();</span><span class="s2">\n        </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">ImportDeclaration</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">// import %%DEFAULT%% ...</span><span class="s2">\n      </span><span class="s1">const specifier =</span><span class="s2">\n        </span><span class="s1">this.startNodeAtNode&lt;N.ImportDefaultSpecifier&gt;(placeholder);</span><span class="s2">\n      </span><span class="s1">specifier.local = placeholder;</span><span class="s2">\n      </span><span class="s1">node.specifiers.push(</span><span class="s2">\n        </span><span class="s1">this.finishNode(specifier, </span><span class="s2">\&quot;</span><span class="s1">ImportDefaultSpecifier</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n\n      </span><span class="s1">if (this.eat(tt.comma)) {</span><span class="s2">\n        </span><span class="s1">// import %%DEFAULT%%, * as ...</span><span class="s2">\n        </span><span class="s1">const hasStarImport = this.maybeParseStarImportSpecifier(node);</span><span class="s2">\n\n        </span><span class="s1">// import %%DEFAULT%%, { ...</span><span class="s2">\n        </span><span class="s1">if (!hasStarImport) this.parseNamedImportSpecifiers(node);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">this.expectContextual(tt._from);</span><span class="s2">\n      </span><span class="s1">node.source = this.parseImportSource();</span><span class="s2">\n      </span><span class="s1">this.semicolon();</span><span class="s2">\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">ImportDeclaration</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">parseImportSource(): MaybePlaceholder&lt;</span><span class="s2">\&quot;</span><span class="s1">StringLiteral</span><span class="s2">\&quot;</span><span class="s1">&gt; {</span><span class="s2">\n      </span><span class="s1">// import ... from %%STRING%%;</span><span class="s2">\n\n      </span><span class="s1">return (</span><span class="s2">\n        </span><span class="s1">this.parsePlaceholder(</span><span class="s2">\&quot;</span><span class="s1">StringLiteral</span><span class="s2">\&quot;</span><span class="s1">) || super.parseImportSource()</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// Throws if the current token and the prev one are separated by a space.</span><span class="s2">\n    </span><span class="s1">assertNoSpace(): void {</span><span class="s2">\n      </span><span class="s1">if (this.state.start &gt; this.state.lastTokEndLoc.index) {</span><span class="s2">\n        </span><span class="s1">this.raise(PlaceholderErrors.UnexpectedSpace, {</span><span class="s2">\n          </span><span class="s1">at: this.state.lastTokEndLoc,</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">&quot;</span><span class="s2">,</span><span class="s1">&quot;import type Parser from </span><span class="s2">\&quot;</span><span class="s1">../parser</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import { tokenIsIdentifier, tt } from </span><span class="s2">\&quot;</span><span class="s1">../tokenizer/types</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type * as N from </span><span class="s2">\&quot;</span><span class="s1">../types</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type { ExpressionErrors } from </span><span class="s2">\&quot;</span><span class="s1">../parser/util</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">export default (superClass: typeof Parser) =&gt;</span><span class="s2">\n  </span><span class="s1">class V8IntrinsicMixin extends superClass implements Parser {</span><span class="s2">\n    </span><span class="s1">parseV8Intrinsic(): N.Expression {</span><span class="s2">\n      </span><span class="s1">if (this.match(tt.modulo)) {</span><span class="s2">\n        </span><span class="s1">const v8IntrinsicStartLoc = this.state.startLoc;</span><span class="s2">\n        </span><span class="s1">// let the `loc` of Identifier starts from `%`</span><span class="s2">\n        </span><span class="s1">const node = this.startNode&lt;N.Identifier&gt;();</span><span class="s2">\n        </span><span class="s1">this.next(); // eat '%'</span><span class="s2">\n        </span><span class="s1">if (tokenIsIdentifier(this.state.type)) {</span><span class="s2">\n          </span><span class="s1">const name = this.parseIdentifierName();</span><span class="s2">\n          </span><span class="s1">const identifier = this.createIdentifier(node, name);</span><span class="s2">\n          </span><span class="s1">// @ts-expect-error: avoid mutating AST types</span><span class="s2">\n          </span><span class="s1">identifier.type = </span><span class="s2">\&quot;</span><span class="s1">V8IntrinsicIdentifier</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n          </span><span class="s1">if (this.match(tt.parenL)) {</span><span class="s2">\n            </span><span class="s1">return identifier;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">this.unexpected(v8IntrinsicStartLoc);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">/* ============================================================ *</span><span class="s2">\n     </span><span class="s1">* parser/expression.js                                         *</span><span class="s2">\n     </span><span class="s1">* ============================================================ */</span><span class="s2">\n\n    </span><span class="s1">parseExprAtom(refExpressionErrors?: ExpressionErrors | null): N.Expression {</span><span class="s2">\n      </span><span class="s1">return (</span><span class="s2">\n        </span><span class="s1">this.parseV8Intrinsic() || super.parseExprAtom(refExpressionErrors)</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">&quot;</span><span class="s2">,</span><span class="s1">&quot;import type Parser from </span><span class="s2">\&quot;</span><span class="s1">./parser</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type {</span><span class="s2">\n  </span><span class="s1">ParserPluginWithOptions,</span><span class="s2">\n  </span><span class="s1">PluginConfig,</span><span class="s2">\n  </span><span class="s1">PluginOptions,</span><span class="s2">\n</span><span class="s1">} from </span><span class="s2">\&quot;</span><span class="s1">./typings</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">export type Plugin = PluginConfig;</span><span class="s2">\n\n</span><span class="s1">export type PluginList = PluginConfig[];</span><span class="s2">\n\n</span><span class="s1">export type MixinPlugin = (superClass: { new (...args: any): Parser }) =&gt; {</span><span class="s2">\n  </span><span class="s1">new (...args: any): Parser;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">// This function’s second parameter accepts either a string (plugin name) or an</span><span class="s2">\n</span><span class="s1">// array pair (plugin name and options object). If an options object is given,</span><span class="s2">\n</span><span class="s1">// then each value is non-recursively checked for identity with the actual</span><span class="s2">\n</span><span class="s1">// option value of each plugin in the first argument (which is an array of</span><span class="s2">\n</span><span class="s1">// plugin names or array pairs).</span><span class="s2">\n</span><span class="s1">export function hasPlugin(</span><span class="s2">\n  </span><span class="s1">plugins: PluginList,</span><span class="s2">\n  </span><span class="s1">expectedConfig: PluginConfig,</span><span class="s2">\n</span><span class="s1">): boolean {</span><span class="s2">\n  </span><span class="s1">// The expectedOptions object is by default an empty object if the given</span><span class="s2">\n  </span><span class="s1">// expectedConfig argument does not give an options object (i.e., if it is a</span><span class="s2">\n  </span><span class="s1">// string).</span><span class="s2">\n  </span><span class="s1">const [expectedName, expectedOptions] =</span><span class="s2">\n    </span><span class="s1">typeof expectedConfig === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot; </span><span class="s1">? [expectedConfig, {}] : expectedConfig;</span><span class="s2">\n\n  </span><span class="s1">const expectedKeys = Object.keys(expectedOptions);</span><span class="s2">\n\n  </span><span class="s1">const expectedOptionsIsEmpty = expectedKeys.length === 0;</span><span class="s2">\n\n  </span><span class="s1">return plugins.some(p =&gt; {</span><span class="s2">\n    </span><span class="s1">if (typeof p === </span><span class="s2">\&quot;</span><span class="s1">string</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">return expectedOptionsIsEmpty &amp;&amp; p === expectedName;</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">const [pluginName, pluginOptions] = p;</span><span class="s2">\n      </span><span class="s1">if (pluginName !== expectedName) {</span><span class="s2">\n        </span><span class="s1">return false;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">for (const key of expectedKeys) {</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error key may not exist in plugin options</span><span class="s2">\n        </span><span class="s1">if (pluginOptions[key] !== expectedOptions[key]) {</span><span class="s2">\n          </span><span class="s1">return false;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return true;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">export function getPluginOption&lt;</span><span class="s2">\n  </span><span class="s1">PluginName extends ParserPluginWithOptions[0],</span><span class="s2">\n  </span><span class="s1">OptionName extends keyof PluginOptions&lt;PluginName&gt;,</span><span class="s2">\n</span><span class="s1">&gt;(plugins: PluginList, name: PluginName, option: OptionName) {</span><span class="s2">\n  </span><span class="s1">const plugin = plugins.find(plugin =&gt; {</span><span class="s2">\n    </span><span class="s1">if (Array.isArray(plugin)) {</span><span class="s2">\n      </span><span class="s1">return plugin[0] === name;</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">return plugin === name;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">});</span><span class="s2">\n\n  </span><span class="s1">if (plugin &amp;&amp; Array.isArray(plugin) &amp;&amp; plugin.length &gt; 1) {</span><span class="s2">\n    </span><span class="s1">return (plugin[1] as PluginOptions&lt;PluginName&gt;)[option];</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">return null;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">const PIPELINE_PROPOSALS = [</span><span class="s2">\&quot;</span><span class="s1">minimal</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">fsharp</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">hack</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">smart</span><span class="s2">\&quot;</span><span class="s1">];</span><span class="s2">\n</span><span class="s1">const TOPIC_TOKENS = [</span><span class="s2">\&quot;</span><span class="s1">^^</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">@@</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">^</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">%</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">#</span><span class="s2">\&quot;</span><span class="s1">];</span><span class="s2">\n</span><span class="s1">const RECORD_AND_TUPLE_SYNTAX_TYPES = [</span><span class="s2">\&quot;</span><span class="s1">hash</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">bar</span><span class="s2">\&quot;</span><span class="s1">];</span><span class="s2">\n\n</span><span class="s1">export function validatePlugins(plugins: PluginList) {</span><span class="s2">\n  </span><span class="s1">if (hasPlugin(plugins, </span><span class="s2">\&quot;</span><span class="s1">decorators</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n    </span><span class="s1">if (hasPlugin(plugins, </span><span class="s2">\&quot;</span><span class="s1">decorators-legacy</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n      </span><span class="s1">throw new Error(</span><span class="s2">\n        \&quot;</span><span class="s1">Cannot use the decorators and decorators-legacy plugin together</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">const decoratorsBeforeExport = getPluginOption(</span><span class="s2">\n      </span><span class="s1">plugins,</span><span class="s2">\n      \&quot;</span><span class="s1">decorators</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      \&quot;</span><span class="s1">decoratorsBeforeExport</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">if (</span><span class="s2">\n      </span><span class="s1">decoratorsBeforeExport != null &amp;&amp;</span><span class="s2">\n      </span><span class="s1">typeof decoratorsBeforeExport !== </span><span class="s2">\&quot;</span><span class="s1">boolean</span><span class="s2">\&quot;\n    </span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">throw new Error(</span><span class="s2">\n        \&quot;</span><span class="s1">'decoratorsBeforeExport' must be a boolean, if specified.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">const allowCallParenthesized = getPluginOption(</span><span class="s2">\n      </span><span class="s1">plugins,</span><span class="s2">\n      \&quot;</span><span class="s1">decorators</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      \&quot;</span><span class="s1">allowCallParenthesized</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">if (</span><span class="s2">\n      </span><span class="s1">allowCallParenthesized != null &amp;&amp;</span><span class="s2">\n      </span><span class="s1">typeof allowCallParenthesized !== </span><span class="s2">\&quot;</span><span class="s1">boolean</span><span class="s2">\&quot;\n    </span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">throw new Error(</span><span class="s2">\&quot;</span><span class="s1">'allowCallParenthesized' must be a boolean.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">if (hasPlugin(plugins, </span><span class="s2">\&quot;</span><span class="s1">flow</span><span class="s2">\&quot;</span><span class="s1">) &amp;&amp; hasPlugin(plugins, </span><span class="s2">\&quot;</span><span class="s1">typescript</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n    </span><span class="s1">throw new Error(</span><span class="s2">\&quot;</span><span class="s1">Cannot combine flow and typescript plugins.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">if (hasPlugin(plugins, </span><span class="s2">\&quot;</span><span class="s1">placeholders</span><span class="s2">\&quot;</span><span class="s1">) &amp;&amp; hasPlugin(plugins, </span><span class="s2">\&quot;</span><span class="s1">v8intrinsic</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n    </span><span class="s1">throw new Error(</span><span class="s2">\&quot;</span><span class="s1">Cannot combine placeholders and v8intrinsic plugins.</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">if (hasPlugin(plugins, </span><span class="s2">\&quot;</span><span class="s1">pipelineOperator</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n    </span><span class="s1">const proposal = getPluginOption(plugins, </span><span class="s2">\&quot;</span><span class="s1">pipelineOperator</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">proposal</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n\n    </span><span class="s1">if (!PIPELINE_PROPOSALS.includes(proposal)) {</span><span class="s2">\n      </span><span class="s1">const proposalList = PIPELINE_PROPOSALS.map(p =&gt; `</span><span class="s2">\&quot;</span><span class="s1">${p}</span><span class="s2">\&quot;</span><span class="s1">`).join(</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">throw new Error(</span><span class="s2">\n        </span><span class="s1">`</span><span class="s2">\&quot;</span><span class="s1">pipelineOperator</span><span class="s2">\&quot; </span><span class="s1">requires </span><span class="s2">\&quot;</span><span class="s1">proposal</span><span class="s2">\&quot; </span><span class="s1">option whose value must be one of: ${proposalList}.`,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">const tupleSyntaxIsHash = hasPlugin(plugins, [</span><span class="s2">\n      \&quot;</span><span class="s1">recordAndTuple</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">{ syntaxType: </span><span class="s2">\&quot;</span><span class="s1">hash</span><span class="s2">\&quot; </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">]);</span><span class="s2">\n\n    </span><span class="s1">if (proposal === </span><span class="s2">\&quot;</span><span class="s1">hack</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">if (hasPlugin(plugins, </span><span class="s2">\&quot;</span><span class="s1">placeholders</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n        </span><span class="s1">throw new Error(</span><span class="s2">\n          \&quot;</span><span class="s1">Cannot combine placeholders plugin and Hack-style pipes.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">if (hasPlugin(plugins, </span><span class="s2">\&quot;</span><span class="s1">v8intrinsic</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n        </span><span class="s1">throw new Error(</span><span class="s2">\n          \&quot;</span><span class="s1">Cannot combine v8intrinsic plugin and Hack-style pipes.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">const topicToken = getPluginOption(</span><span class="s2">\n        </span><span class="s1">plugins,</span><span class="s2">\n        \&quot;</span><span class="s1">pipelineOperator</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        \&quot;</span><span class="s1">topicToken</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n\n      </span><span class="s1">if (!TOPIC_TOKENS.includes(topicToken)) {</span><span class="s2">\n        </span><span class="s1">const tokenList = TOPIC_TOKENS.map(t =&gt; `</span><span class="s2">\&quot;</span><span class="s1">${t}</span><span class="s2">\&quot;</span><span class="s1">`).join(</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n\n        </span><span class="s1">throw new Error(</span><span class="s2">\n          </span><span class="s1">`</span><span class="s2">\&quot;</span><span class="s1">pipelineOperator</span><span class="s2">\&quot; </span><span class="s1">in </span><span class="s2">\&quot;</span><span class="s1">proposal</span><span class="s2">\&quot;</span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">hack</span><span class="s2">\&quot; </span><span class="s1">mode also requires a </span><span class="s2">\&quot;</span><span class="s1">topicToken</span><span class="s2">\&quot; </span><span class="s1">option whose value must be one of: ${tokenList}.`,</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">if (topicToken === </span><span class="s2">\&quot;</span><span class="s1">#</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; tupleSyntaxIsHash) {</span><span class="s2">\n        </span><span class="s1">throw new Error(</span><span class="s2">\n          </span><span class="s1">'Plugin conflict between `[</span><span class="s2">\&quot;</span><span class="s1">pipelineOperator</span><span class="s2">\&quot;</span><span class="s1">, { proposal: </span><span class="s2">\&quot;</span><span class="s1">hack</span><span class="s2">\&quot;</span><span class="s1">, topicToken: </span><span class="s2">\&quot;</span><span class="s1">#</span><span class="s2">\&quot; </span><span class="s1">}]` and `[</span><span class="s2">\&quot;</span><span class="s1">recordAndtuple</span><span class="s2">\&quot;</span><span class="s1">, { syntaxType: </span><span class="s2">\&quot;</span><span class="s1">hash</span><span class="s2">\&quot;</span><span class="s1">}]`.',</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else if (proposal === </span><span class="s2">\&quot;</span><span class="s1">smart</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; tupleSyntaxIsHash) {</span><span class="s2">\n      </span><span class="s1">throw new Error(</span><span class="s2">\n        </span><span class="s1">'Plugin conflict between `[</span><span class="s2">\&quot;</span><span class="s1">pipelineOperator</span><span class="s2">\&quot;</span><span class="s1">, { proposal: </span><span class="s2">\&quot;</span><span class="s1">smart</span><span class="s2">\&quot; </span><span class="s1">}]` and `[</span><span class="s2">\&quot;</span><span class="s1">recordAndtuple</span><span class="s2">\&quot;</span><span class="s1">, { syntaxType: </span><span class="s2">\&quot;</span><span class="s1">hash</span><span class="s2">\&quot;</span><span class="s1">}]`.',</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">if (hasPlugin(plugins, </span><span class="s2">\&quot;</span><span class="s1">moduleAttributes</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n    </span><span class="s1">if (process.env.BABEL_8_BREAKING) {</span><span class="s2">\n      </span><span class="s1">throw new Error(</span><span class="s2">\n        \&quot;</span><span class="s1">`moduleAttributes` has been removed in Babel 8, please use `importAssertions` parser plugin, or `@babel/plugin-syntax-import-assertions`.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">if (hasPlugin(plugins, </span><span class="s2">\&quot;</span><span class="s1">importAssertions</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n        </span><span class="s1">throw new Error(</span><span class="s2">\n          \&quot;</span><span class="s1">Cannot combine importAssertions and moduleAttributes plugins.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">const moduleAttributesVersionPluginOption = getPluginOption(</span><span class="s2">\n        </span><span class="s1">plugins,</span><span class="s2">\n        \&quot;</span><span class="s1">moduleAttributes</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        \&quot;</span><span class="s1">version</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">if (moduleAttributesVersionPluginOption !== </span><span class="s2">\&quot;</span><span class="s1">may-2020</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">throw new Error(</span><span class="s2">\n          \&quot;</span><span class="s1">The 'moduleAttributes' plugin requires a 'version' option,</span><span class="s2">\&quot; </span><span class="s1">+</span><span class="s2">\n            \&quot; </span><span class="s1">representing the last proposal update. Currently, the</span><span class="s2">\&quot; </span><span class="s1">+</span><span class="s2">\n            \&quot; </span><span class="s1">only supported value is 'may-2020'.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">if (</span><span class="s2">\n    </span><span class="s1">hasPlugin(plugins, </span><span class="s2">\&quot;</span><span class="s1">recordAndTuple</span><span class="s2">\&quot;</span><span class="s1">) &amp;&amp;</span><span class="s2">\n    </span><span class="s1">getPluginOption(plugins, </span><span class="s2">\&quot;</span><span class="s1">recordAndTuple</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">syntaxType</span><span class="s2">\&quot;</span><span class="s1">) != null &amp;&amp;</span><span class="s2">\n    </span><span class="s1">!RECORD_AND_TUPLE_SYNTAX_TYPES.includes(</span><span class="s2">\n      </span><span class="s1">getPluginOption(plugins, </span><span class="s2">\&quot;</span><span class="s1">recordAndTuple</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">syntaxType</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n    </span><span class="s1">)</span><span class="s2">\n  </span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">throw new Error(</span><span class="s2">\n      \&quot;</span><span class="s1">The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: </span><span class="s2">\&quot; </span><span class="s1">+</span><span class="s2">\n        </span><span class="s1">RECORD_AND_TUPLE_SYNTAX_TYPES.map(p =&gt; `'${p}'`).join(</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">if (</span><span class="s2">\n    </span><span class="s1">hasPlugin(plugins, </span><span class="s2">\&quot;</span><span class="s1">asyncDoExpressions</span><span class="s2">\&quot;</span><span class="s1">) &amp;&amp;</span><span class="s2">\n    </span><span class="s1">!hasPlugin(plugins, </span><span class="s2">\&quot;</span><span class="s1">doExpressions</span><span class="s2">\&quot;</span><span class="s1">)</span><span class="s2">\n  </span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">const error = new Error(</span><span class="s2">\n      \&quot;</span><span class="s1">'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">// @ts-expect-error so @babel/core can provide better error message</span><span class="s2">\n    </span><span class="s1">error.missingPlugins = </span><span class="s2">\&quot;</span><span class="s1">doExpressions</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">throw error;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// These plugins are defined using a mixin which extends the parser class.</span><span class="s2">\n\n</span><span class="s1">import estree from </span><span class="s2">\&quot;</span><span class="s1">./plugins/estree</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import flow from </span><span class="s2">\&quot;</span><span class="s1">./plugins/flow</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import jsx from </span><span class="s2">\&quot;</span><span class="s1">./plugins/jsx</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import typescript from </span><span class="s2">\&quot;</span><span class="s1">./plugins/typescript</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import placeholders from </span><span class="s2">\&quot;</span><span class="s1">./plugins/placeholders</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import v8intrinsic from </span><span class="s2">\&quot;</span><span class="s1">./plugins/v8intrinsic</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">// NOTE: order is important. estree must come first; placeholders must come last.</span><span class="s2">\n</span><span class="s1">export const mixinPlugins = {</span><span class="s2">\n  </span><span class="s1">estree,</span><span class="s2">\n  </span><span class="s1">jsx,</span><span class="s2">\n  </span><span class="s1">flow,</span><span class="s2">\n  </span><span class="s1">typescript,</span><span class="s2">\n  </span><span class="s1">v8intrinsic,</span><span class="s2">\n  </span><span class="s1">placeholders,</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">export const mixinPluginNames = Object.keys(mixinPlugins) as ReadonlyArray&lt;</span><span class="s2">\n  \&quot;</span><span class="s1">estree</span><span class="s2">\&quot; </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">jsx</span><span class="s2">\&quot; </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">flow</span><span class="s2">\&quot; </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">typescript</span><span class="s2">\&quot; </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">v8intrinsic</span><span class="s2">\&quot; </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">placeholders</span><span class="s2">\&quot;\n</span><span class="s1">&gt;;</span><span class="s2">\n</span><span class="s1">&quot;</span><span class="s2">,</span><span class="s1">&quot;// A recursive descent parser operates by defining functions for all</span><span class="s2">\n</span><span class="s1">// syntactic elements, and recursively calling those, each function</span><span class="s2">\n</span><span class="s1">// advancing the input stream and returning an AST node. Precedence</span><span class="s2">\n</span><span class="s1">// of constructs (for example, the fact that `!x[1]` means `!(x[1])`</span><span class="s2">\n</span><span class="s1">// instead of `(!x)[1]` is handled by the fact that the parser</span><span class="s2">\n</span><span class="s1">// function that parses unary prefix operators is called first, and</span><span class="s2">\n</span><span class="s1">// in turn calls the function that parses `[]` subscripts — that</span><span class="s2">\n</span><span class="s1">// way, it'll receive the node for `x[1]` already parsed, and wraps</span><span class="s2">\n</span><span class="s1">// *that* in the unary operator node.</span><span class="s2">\n</span><span class="s1">//</span><span class="s2">\n</span><span class="s1">// Acorn uses an [operator precedence parser][opp] to handle binary</span><span class="s2">\n</span><span class="s1">// operator precedence, because it is much more compact than using</span><span class="s2">\n</span><span class="s1">// the technique outlined above, which uses different, nesting</span><span class="s2">\n</span><span class="s1">// functions to specify precedence, for all of the ten binary</span><span class="s2">\n</span><span class="s1">// precedence levels that JavaScript defines.</span><span class="s2">\n</span><span class="s1">//</span><span class="s2">\n</span><span class="s1">// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser</span><span class="s2">\n\n</span><span class="s1">import {</span><span class="s2">\n  </span><span class="s1">tokenCanStartExpression,</span><span class="s2">\n  </span><span class="s1">tokenIsAssignment,</span><span class="s2">\n  </span><span class="s1">tokenIsIdentifier,</span><span class="s2">\n  </span><span class="s1">tokenIsKeywordOrIdentifier,</span><span class="s2">\n  </span><span class="s1">tokenIsOperator,</span><span class="s2">\n  </span><span class="s1">tokenIsPostfix,</span><span class="s2">\n  </span><span class="s1">tokenIsPrefix,</span><span class="s2">\n  </span><span class="s1">tokenIsRightAssociative,</span><span class="s2">\n  </span><span class="s1">tokenIsTemplate,</span><span class="s2">\n  </span><span class="s1">tokenKeywordOrIdentifierIsKeyword,</span><span class="s2">\n  </span><span class="s1">tokenLabelName,</span><span class="s2">\n  </span><span class="s1">tokenOperatorPrecedence,</span><span class="s2">\n  </span><span class="s1">tt,</span><span class="s2">\n  </span><span class="s1">type TokenType,</span><span class="s2">\n</span><span class="s1">} from </span><span class="s2">\&quot;</span><span class="s1">../tokenizer/types</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type * as N from </span><span class="s2">\&quot;</span><span class="s1">../types</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import LValParser from </span><span class="s2">\&quot;</span><span class="s1">./lval</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import {</span><span class="s2">\n  </span><span class="s1">isKeyword,</span><span class="s2">\n  </span><span class="s1">isReservedWord,</span><span class="s2">\n  </span><span class="s1">isStrictReservedWord,</span><span class="s2">\n  </span><span class="s1">isStrictBindReservedWord,</span><span class="s2">\n  </span><span class="s1">isIdentifierStart,</span><span class="s2">\n  </span><span class="s1">canBeReservedWord,</span><span class="s2">\n</span><span class="s1">} from </span><span class="s2">\&quot;</span><span class="s1">../util/identifier</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import {</span><span class="s2">\n  </span><span class="s1">type Position,</span><span class="s2">\n  </span><span class="s1">createPositionWithColumnOffset,</span><span class="s2">\n</span><span class="s1">} from </span><span class="s2">\&quot;</span><span class="s1">../util/location</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import * as charCodes from </span><span class="s2">\&quot;</span><span class="s1">charcodes</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import {</span><span class="s2">\n  </span><span class="s1">BIND_OUTSIDE,</span><span class="s2">\n  </span><span class="s1">BIND_VAR,</span><span class="s2">\n  </span><span class="s1">SCOPE_ARROW,</span><span class="s2">\n  </span><span class="s1">SCOPE_CLASS,</span><span class="s2">\n  </span><span class="s1">SCOPE_DIRECT_SUPER,</span><span class="s2">\n  </span><span class="s1">SCOPE_FUNCTION,</span><span class="s2">\n  </span><span class="s1">SCOPE_SUPER,</span><span class="s2">\n</span><span class="s1">} from </span><span class="s2">\&quot;</span><span class="s1">../util/scopeflags</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import { ExpressionErrors } from </span><span class="s2">\&quot;</span><span class="s1">./util</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import {</span><span class="s2">\n  </span><span class="s1">PARAM_AWAIT,</span><span class="s2">\n  </span><span class="s1">PARAM_IN,</span><span class="s2">\n  </span><span class="s1">PARAM_RETURN,</span><span class="s2">\n  </span><span class="s1">functionFlags,</span><span class="s2">\n</span><span class="s1">} from </span><span class="s2">\&quot;</span><span class="s1">../util/production-parameter</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import {</span><span class="s2">\n  </span><span class="s1">newArrowHeadScope,</span><span class="s2">\n  </span><span class="s1">newAsyncArrowScope,</span><span class="s2">\n  </span><span class="s1">newExpressionScope,</span><span class="s2">\n</span><span class="s1">} from </span><span class="s2">\&quot;</span><span class="s1">../util/expression-scope</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import { Errors, type ParseError } from </span><span class="s2">\&quot;</span><span class="s1">../parse-error</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import { UnparenthesizedPipeBodyDescriptions } from </span><span class="s2">\&quot;</span><span class="s1">../parse-error/pipeline-operator-errors</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import { setInnerComments } from </span><span class="s2">\&quot;</span><span class="s1">./comments</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import { cloneIdentifier, type Undone } from </span><span class="s2">\&quot;</span><span class="s1">./node</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type Parser from </span><span class="s2">\&quot;</span><span class="s1">.</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">import type { SourceType } from </span><span class="s2">\&quot;</span><span class="s1">../options</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">export default abstract class ExpressionParser extends LValParser {</span><span class="s2">\n  </span><span class="s1">// Forward-declaration: defined in statement.js</span><span class="s2">\n  </span><span class="s1">abstract parseBlock(</span><span class="s2">\n    </span><span class="s1">allowDirectives?: boolean,</span><span class="s2">\n    </span><span class="s1">createNewLexicalScope?: boolean,</span><span class="s2">\n    </span><span class="s1">afterBlockParse?: (hasStrictModeDirective: boolean) =&gt; void,</span><span class="s2">\n  </span><span class="s1">): N.BlockStatement;</span><span class="s2">\n  </span><span class="s1">abstract parseClass(</span><span class="s2">\n    </span><span class="s1">node: N.Class,</span><span class="s2">\n    </span><span class="s1">isStatement: boolean,</span><span class="s2">\n    </span><span class="s1">optionalId?: boolean,</span><span class="s2">\n  </span><span class="s1">): N.Class;</span><span class="s2">\n  </span><span class="s1">abstract parseDecorators(allowExport?: boolean): void;</span><span class="s2">\n  </span><span class="s1">abstract parseFunction&lt;T extends N.NormalFunction&gt;(</span><span class="s2">\n    </span><span class="s1">node: T,</span><span class="s2">\n    </span><span class="s1">statement?: number,</span><span class="s2">\n    </span><span class="s1">allowExpressionBody?: boolean,</span><span class="s2">\n    </span><span class="s1">isAsync?: boolean,</span><span class="s2">\n  </span><span class="s1">): T;</span><span class="s2">\n  </span><span class="s1">abstract parseFunctionParams(node: N.Function, isConstructor?: boolean): void;</span><span class="s2">\n  </span><span class="s1">abstract parseBlockOrModuleBlockBody(</span><span class="s2">\n    </span><span class="s1">body: N.Statement[],</span><span class="s2">\n    </span><span class="s1">directives: N.Directive[] | null | undefined,</span><span class="s2">\n    </span><span class="s1">topLevel: boolean,</span><span class="s2">\n    </span><span class="s1">end: TokenType,</span><span class="s2">\n    </span><span class="s1">afterBlockParse?: (hasStrictModeDirective: boolean) =&gt; void,</span><span class="s2">\n  </span><span class="s1">): void;</span><span class="s2">\n  </span><span class="s1">abstract parseProgram(</span><span class="s2">\n    </span><span class="s1">program: N.Program,</span><span class="s2">\n    </span><span class="s1">end: TokenType,</span><span class="s2">\n    </span><span class="s1">sourceType?: SourceType,</span><span class="s2">\n  </span><span class="s1">): N.Program;</span><span class="s2">\n\n  </span><span class="s1">// For object literal, check if property __proto__ has been used more than once.</span><span class="s2">\n  </span><span class="s1">// If the expression is a destructuring assignment, then __proto__ may appear</span><span class="s2">\n  </span><span class="s1">// multiple times. Otherwise, __proto__ is a duplicated key.</span><span class="s2">\n\n  </span><span class="s1">// For record expression, check if property __proto__ exists</span><span class="s2">\n\n  </span><span class="s1">checkProto(</span><span class="s2">\n    </span><span class="s1">prop: N.ObjectMember | N.SpreadElement,</span><span class="s2">\n    </span><span class="s1">isRecord: boolean | undefined | null,</span><span class="s2">\n    </span><span class="s1">protoRef: {</span><span class="s2">\n      </span><span class="s1">used: boolean;</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">refExpressionErrors?: ExpressionErrors | null,</span><span class="s2">\n  </span><span class="s1">): void {</span><span class="s2">\n    </span><span class="s1">if (</span><span class="s2">\n      </span><span class="s1">prop.type === </span><span class="s2">\&quot;</span><span class="s1">SpreadElement</span><span class="s2">\&quot; </span><span class="s1">||</span><span class="s2">\n      </span><span class="s1">this.isObjectMethod(prop) ||</span><span class="s2">\n      </span><span class="s1">prop.computed ||</span><span class="s2">\n      </span><span class="s1">// @ts-expect-error prop must be an ObjectProperty</span><span class="s2">\n      </span><span class="s1">prop.shorthand</span><span class="s2">\n    </span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">const key = prop.key;</span><span class="s2">\n    </span><span class="s1">// It is either an Identifier or a String/NumericLiteral</span><span class="s2">\n    </span><span class="s1">const name = key.type === </span><span class="s2">\&quot;</span><span class="s1">Identifier</span><span class="s2">\&quot; </span><span class="s1">? key.name : key.value;</span><span class="s2">\n\n    </span><span class="s1">if (name === </span><span class="s2">\&quot;</span><span class="s1">__proto__</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">if (isRecord) {</span><span class="s2">\n        </span><span class="s1">this.raise(Errors.RecordNoProto, { at: key });</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (protoRef.used) {</span><span class="s2">\n        </span><span class="s1">if (refExpressionErrors) {</span><span class="s2">\n          </span><span class="s1">// Store the first redefinition's position, otherwise ignore because</span><span class="s2">\n          </span><span class="s1">// we are parsing ambiguous pattern</span><span class="s2">\n          </span><span class="s1">if (refExpressionErrors.doubleProtoLoc === null) {</span><span class="s2">\n            </span><span class="s1">refExpressionErrors.doubleProtoLoc = key.loc.start;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">this.raise(Errors.DuplicateProto, { at: key });</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">protoRef.used = true;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">shouldExitDescending(expr: N.Expression, potentialArrowAt: number): boolean {</span><span class="s2">\n    </span><span class="s1">return (</span><span class="s2">\n      </span><span class="s1">expr.type === </span><span class="s2">\&quot;</span><span class="s1">ArrowFunctionExpression</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; expr.start === potentialArrowAt</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Convenience method to parse an Expression only</span><span class="s2">\n  </span><span class="s1">getExpression(this: Parser): N.Expression &amp; N.ParserOutput {</span><span class="s2">\n    </span><span class="s1">this.enterInitialScopes();</span><span class="s2">\n    </span><span class="s1">this.nextToken();</span><span class="s2">\n    </span><span class="s1">const expr = this.parseExpression();</span><span class="s2">\n    </span><span class="s1">if (!this.match(tt.eof)) {</span><span class="s2">\n      </span><span class="s1">this.unexpected();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// Unlike parseTopLevel, we need to drain remaining commentStacks</span><span class="s2">\n    </span><span class="s1">// because the top level node is _not_ Program.</span><span class="s2">\n    </span><span class="s1">this.finalizeRemainingComments();</span><span class="s2">\n    </span><span class="s1">expr.comments = this.state.comments;</span><span class="s2">\n    </span><span class="s1">expr.errors = this.state.errors;</span><span class="s2">\n    </span><span class="s1">if (this.options.tokens) {</span><span class="s2">\n      </span><span class="s1">expr.tokens = this.tokens;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// @ts-expect-error fixme: refine types</span><span class="s2">\n    </span><span class="s1">return expr;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// ### Expression parsing</span><span class="s2">\n\n  </span><span class="s1">// These nest, from the most general expression type at the top to</span><span class="s2">\n  </span><span class="s1">// 'atomic', nondivisible expression types at the bottom. Most of</span><span class="s2">\n  </span><span class="s1">// the functions will simply let the function (s) below them parse,</span><span class="s2">\n  </span><span class="s1">// and, *if* the syntactic construct they handle is present, wrap</span><span class="s2">\n  </span><span class="s1">// the AST node that the inner parser gave them in another node.</span><span class="s2">\n\n  </span><span class="s1">// Parse a full expression.</span><span class="s2">\n  </span><span class="s1">// - `disallowIn`</span><span class="s2">\n  </span><span class="s1">//   is used to forbid the `in` operator (in for loops initialization expressions)</span><span class="s2">\n  </span><span class="s1">//   When `disallowIn` is true, the production parameter [In] is not present.</span><span class="s2">\n\n  </span><span class="s1">// - `refExpressionErrors `</span><span class="s2">\n  </span><span class="s1">//   provides reference for storing '=' operator inside shorthand</span><span class="s2">\n  </span><span class="s1">//   property assignment in contexts where both object expression</span><span class="s2">\n  </span><span class="s1">//   and object pattern might appear (so it's possible to raise</span><span class="s2">\n  </span><span class="s1">//   delayed syntax error at correct position).</span><span class="s2">\n\n  </span><span class="s1">parseExpression(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">disallowIn?: boolean,</span><span class="s2">\n    </span><span class="s1">refExpressionErrors?: ExpressionErrors,</span><span class="s2">\n  </span><span class="s1">): N.Expression {</span><span class="s2">\n    </span><span class="s1">if (disallowIn) {</span><span class="s2">\n      </span><span class="s1">return this.disallowInAnd(() =&gt;</span><span class="s2">\n        </span><span class="s1">this.parseExpressionBase(refExpressionErrors),</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return this.allowInAnd(() =&gt; this.parseExpressionBase(refExpressionErrors));</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// https://tc39.es/ecma262/#prod-Expression</span><span class="s2">\n  </span><span class="s1">parseExpressionBase(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">refExpressionErrors?: ExpressionErrors,</span><span class="s2">\n  </span><span class="s1">): N.Expression {</span><span class="s2">\n    </span><span class="s1">const startLoc = this.state.startLoc;</span><span class="s2">\n    </span><span class="s1">const expr = this.parseMaybeAssign(refExpressionErrors);</span><span class="s2">\n    </span><span class="s1">if (this.match(tt.comma)) {</span><span class="s2">\n      </span><span class="s1">const node = this.startNodeAt(startLoc);</span><span class="s2">\n      </span><span class="s1">node.expressions = [expr];</span><span class="s2">\n      </span><span class="s1">while (this.eat(tt.comma)) {</span><span class="s2">\n        </span><span class="s1">node.expressions.push(this.parseMaybeAssign(refExpressionErrors));</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">this.toReferencedList(node.expressions);</span><span class="s2">\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">SequenceExpression</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return expr;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Set [~In] parameter for assignment expression</span><span class="s2">\n  </span><span class="s1">parseMaybeAssignDisallowIn(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">refExpressionErrors?: ExpressionErrors | null,</span><span class="s2">\n    </span><span class="s1">afterLeftParse?: Function,</span><span class="s2">\n  </span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">return this.disallowInAnd(() =&gt;</span><span class="s2">\n      </span><span class="s1">this.parseMaybeAssign(refExpressionErrors, afterLeftParse),</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Set [+In] parameter for assignment expression</span><span class="s2">\n  </span><span class="s1">parseMaybeAssignAllowIn(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">refExpressionErrors?: ExpressionErrors | null,</span><span class="s2">\n    </span><span class="s1">afterLeftParse?: Function,</span><span class="s2">\n  </span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">return this.allowInAnd(() =&gt;</span><span class="s2">\n      </span><span class="s1">this.parseMaybeAssign(refExpressionErrors, afterLeftParse),</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// This method is only used by</span><span class="s2">\n  </span><span class="s1">// the typescript and flow plugins.</span><span class="s2">\n  </span><span class="s1">setOptionalParametersError(</span><span class="s2">\n    </span><span class="s1">refExpressionErrors: ExpressionErrors,</span><span class="s2">\n    </span><span class="s1">resultError?: ParseError&lt;any&gt;,</span><span class="s2">\n  </span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">refExpressionErrors.optionalParametersLoc =</span><span class="s2">\n      </span><span class="s1">resultError?.loc ?? this.state.startLoc;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Parse an assignment expression. This includes applications of</span><span class="s2">\n  </span><span class="s1">// operators like `+=`.</span><span class="s2">\n  </span><span class="s1">// https://tc39.es/ecma262/#prod-AssignmentExpression</span><span class="s2">\n  </span><span class="s1">parseMaybeAssign(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">refExpressionErrors?: ExpressionErrors | null,</span><span class="s2">\n    </span><span class="s1">afterLeftParse?: Function,</span><span class="s2">\n  </span><span class="s1">): N.Expression {</span><span class="s2">\n    </span><span class="s1">const startLoc = this.state.startLoc;</span><span class="s2">\n    </span><span class="s1">if (this.isContextual(tt._yield)) {</span><span class="s2">\n      </span><span class="s1">if (this.prodParam.hasYield) {</span><span class="s2">\n        </span><span class="s1">let left = this.parseYield();</span><span class="s2">\n        </span><span class="s1">if (afterLeftParse) {</span><span class="s2">\n          </span><span class="s1">left = afterLeftParse.call(this, left, startLoc);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return left;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">let ownExpressionErrors;</span><span class="s2">\n    </span><span class="s1">if (refExpressionErrors) {</span><span class="s2">\n      </span><span class="s1">ownExpressionErrors = false;</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">refExpressionErrors = new ExpressionErrors();</span><span class="s2">\n      </span><span class="s1">ownExpressionErrors = true;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">const { type } = this.state;</span><span class="s2">\n\n    </span><span class="s1">if (type === tt.parenL || tokenIsIdentifier(type)) {</span><span class="s2">\n      </span><span class="s1">this.state.potentialArrowAt = this.state.start;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">let left = this.parseMaybeConditional(refExpressionErrors);</span><span class="s2">\n    </span><span class="s1">if (afterLeftParse) {</span><span class="s2">\n      </span><span class="s1">left = afterLeftParse.call(this, left, startLoc);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (tokenIsAssignment(this.state.type)) {</span><span class="s2">\n      </span><span class="s1">const node = this.startNodeAt&lt;N.AssignmentExpression&gt;(startLoc);</span><span class="s2">\n      </span><span class="s1">const operator = this.state.value;</span><span class="s2">\n      </span><span class="s1">node.operator = operator;</span><span class="s2">\n\n      </span><span class="s1">if (this.match(tt.eq)) {</span><span class="s2">\n        </span><span class="s1">this.toAssignable(left, /* isLHS */ true);</span><span class="s2">\n        </span><span class="s1">node.left = left;</span><span class="s2">\n\n        </span><span class="s1">const startIndex = startLoc.index;</span><span class="s2">\n        </span><span class="s1">if (</span><span class="s2">\n          </span><span class="s1">refExpressionErrors.doubleProtoLoc != null &amp;&amp;</span><span class="s2">\n          </span><span class="s1">refExpressionErrors.doubleProtoLoc.index &gt;= startIndex</span><span class="s2">\n        </span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">refExpressionErrors.doubleProtoLoc = null; // reset because double __proto__ is valid in assignment expression</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (</span><span class="s2">\n          </span><span class="s1">refExpressionErrors.shorthandAssignLoc != null &amp;&amp;</span><span class="s2">\n          </span><span class="s1">refExpressionErrors.shorthandAssignLoc.index &gt;= startIndex</span><span class="s2">\n        </span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">refExpressionErrors.shorthandAssignLoc = null; // reset because shorthand default was used correctly</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (</span><span class="s2">\n          </span><span class="s1">refExpressionErrors.privateKeyLoc != null &amp;&amp;</span><span class="s2">\n          </span><span class="s1">refExpressionErrors.privateKeyLoc.index &gt;= startIndex</span><span class="s2">\n        </span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">this.checkDestructuringPrivate(refExpressionErrors);</span><span class="s2">\n          </span><span class="s1">refExpressionErrors.privateKeyLoc = null; // reset because `({ #x: x })` is an assignable pattern</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">node.left = left;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">this.next();</span><span class="s2">\n      </span><span class="s1">node.right = this.parseMaybeAssign();</span><span class="s2">\n      </span><span class="s1">this.checkLVal(left, {</span><span class="s2">\n        </span><span class="s1">in: this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">AssignmentExpression</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts) improve node types</span><span class="s2">\n      </span><span class="s1">return node;</span><span class="s2">\n    </span><span class="s1">} else if (ownExpressionErrors) {</span><span class="s2">\n      </span><span class="s1">this.checkExpressionErrors(refExpressionErrors, true);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">return left;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Parse a ternary conditional (`?:`) operator.</span><span class="s2">\n  </span><span class="s1">// https://tc39.es/ecma262/#prod-ConditionalExpression</span><span class="s2">\n\n  </span><span class="s1">parseMaybeConditional(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">refExpressionErrors: ExpressionErrors,</span><span class="s2">\n  </span><span class="s1">): N.Expression {</span><span class="s2">\n    </span><span class="s1">const startLoc = this.state.startLoc;</span><span class="s2">\n    </span><span class="s1">const potentialArrowAt = this.state.potentialArrowAt;</span><span class="s2">\n    </span><span class="s1">const expr = this.parseExprOps(refExpressionErrors);</span><span class="s2">\n\n    </span><span class="s1">if (this.shouldExitDescending(expr, potentialArrowAt)) {</span><span class="s2">\n      </span><span class="s1">return expr;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">return this.parseConditional(expr, startLoc, refExpressionErrors);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">parseConditional(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">expr: N.Expression,</span><span class="s2">\n    </span><span class="s1">startLoc: Position,</span><span class="s2">\n    </span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-unused-vars</span><span class="s2">\n    </span><span class="s1">refExpressionErrors?: ExpressionErrors | null,</span><span class="s2">\n  </span><span class="s1">): N.Expression {</span><span class="s2">\n    </span><span class="s1">if (this.eat(tt.question)) {</span><span class="s2">\n      </span><span class="s1">const node = this.startNodeAt(startLoc);</span><span class="s2">\n      </span><span class="s1">node.test = expr;</span><span class="s2">\n      </span><span class="s1">node.consequent = this.parseMaybeAssignAllowIn();</span><span class="s2">\n      </span><span class="s1">this.expect(tt.colon);</span><span class="s2">\n      </span><span class="s1">node.alternate = this.parseMaybeAssign();</span><span class="s2">\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">ConditionalExpression</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return expr;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">parseMaybeUnaryOrPrivate(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">refExpressionErrors?: ExpressionErrors,</span><span class="s2">\n  </span><span class="s1">): N.Expression | N.PrivateName {</span><span class="s2">\n    </span><span class="s1">return this.match(tt.privateName)</span><span class="s2">\n      </span><span class="s1">? this.parsePrivateName()</span><span class="s2">\n      </span><span class="s1">: this.parseMaybeUnary(refExpressionErrors);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Start the precedence parser.</span><span class="s2">\n  </span><span class="s1">// https://tc39.es/ecma262/#prod-ShortCircuitExpression</span><span class="s2">\n\n  </span><span class="s1">parseExprOps(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">refExpressionErrors: ExpressionErrors,</span><span class="s2">\n  </span><span class="s1">): N.Expression {</span><span class="s2">\n    </span><span class="s1">const startLoc = this.state.startLoc;</span><span class="s2">\n    </span><span class="s1">const potentialArrowAt = this.state.potentialArrowAt;</span><span class="s2">\n    </span><span class="s1">const expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors);</span><span class="s2">\n\n    </span><span class="s1">if (this.shouldExitDescending(expr, potentialArrowAt)) {</span><span class="s2">\n      </span><span class="s1">return expr;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">return this.parseExprOp(expr, startLoc, -1);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Parse binary operators with the operator precedence parsing</span><span class="s2">\n  </span><span class="s1">// algorithm. `left` is the left-hand side of the operator.</span><span class="s2">\n  </span><span class="s1">// `minPrec` provides context that allows the function to stop and</span><span class="s2">\n  </span><span class="s1">// defer further parser to one of its callers when it encounters an</span><span class="s2">\n  </span><span class="s1">// operator that has a lower precedence than the set it is parsing.</span><span class="s2">\n\n  </span><span class="s1">parseExprOp(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">left: N.Expression | N.PrivateName,</span><span class="s2">\n    </span><span class="s1">leftStartLoc: Position,</span><span class="s2">\n    </span><span class="s1">minPrec: number,</span><span class="s2">\n  </span><span class="s1">): N.Expression {</span><span class="s2">\n    </span><span class="s1">if (this.isPrivateName(left)) {</span><span class="s2">\n      </span><span class="s1">// https://tc39.es/ecma262/#prod-RelationalExpression</span><span class="s2">\n      </span><span class="s1">// RelationalExpression [In, Yield, Await]</span><span class="s2">\n      </span><span class="s1">//   [+In] PrivateIdentifier in ShiftExpression[?Yield, ?Await]</span><span class="s2">\n\n      </span><span class="s1">const value = this.getPrivateNameSV(left);</span><span class="s2">\n\n      </span><span class="s1">if (</span><span class="s2">\n        </span><span class="s1">minPrec &gt;= tokenOperatorPrecedence(tt._in) ||</span><span class="s2">\n        </span><span class="s1">!this.prodParam.hasIn ||</span><span class="s2">\n        </span><span class="s1">!this.match(tt._in)</span><span class="s2">\n      </span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">this.raise(Errors.PrivateInExpectedIn, {</span><span class="s2">\n          </span><span class="s1">at: left,</span><span class="s2">\n          </span><span class="s1">identifierName: value,</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">this.classScope.usePrivateName(value, left.loc.start);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">const op = this.state.type;</span><span class="s2">\n    </span><span class="s1">if (tokenIsOperator(op) &amp;&amp; (this.prodParam.hasIn || !this.match(tt._in))) {</span><span class="s2">\n      </span><span class="s1">let prec = tokenOperatorPrecedence(op);</span><span class="s2">\n      </span><span class="s1">if (prec &gt; minPrec) {</span><span class="s2">\n        </span><span class="s1">if (op === tt.pipeline) {</span><span class="s2">\n          </span><span class="s1">this.expectPlugin(</span><span class="s2">\&quot;</span><span class="s1">pipelineOperator</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">if (this.state.inFSharpPipelineDirectBody) {</span><span class="s2">\n            </span><span class="s1">return left;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">this.checkPipelineAtInfixOperator(left, leftStartLoc);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">const node = this.startNodeAt&lt;N.LogicalExpression | N.BinaryExpression&gt;(</span><span class="s2">\n          </span><span class="s1">leftStartLoc,</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">node.left = left;</span><span class="s2">\n        </span><span class="s1">node.operator = this.state.value;</span><span class="s2">\n\n        </span><span class="s1">const logical = op === tt.logicalOR || op === tt.logicalAND;</span><span class="s2">\n        </span><span class="s1">const coalesce = op === tt.nullishCoalescing;</span><span class="s2">\n\n        </span><span class="s1">if (coalesce) {</span><span class="s2">\n          </span><span class="s1">// Handle the precedence of `tt.coalesce` as equal to the range of logical expressions.</span><span class="s2">\n          </span><span class="s1">// In other words, `node.right` shouldn't contain logical expressions in order to check the mixed error.</span><span class="s2">\n          </span><span class="s1">prec = tokenOperatorPrecedence(tt.logicalAND);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">this.next();</span><span class="s2">\n\n        </span><span class="s1">if (</span><span class="s2">\n          </span><span class="s1">op === tt.pipeline &amp;&amp;</span><span class="s2">\n          </span><span class="s1">this.hasPlugin([</span><span class="s2">\&quot;</span><span class="s1">pipelineOperator</span><span class="s2">\&quot;</span><span class="s1">, { proposal: </span><span class="s2">\&quot;</span><span class="s1">minimal</span><span class="s2">\&quot; </span><span class="s1">}])</span><span class="s2">\n        </span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">if (this.state.type === tt._await &amp;&amp; this.prodParam.hasAwait) {</span><span class="s2">\n            </span><span class="s1">throw this.raise(Errors.UnexpectedAwaitAfterPipelineBody, {</span><span class="s2">\n              </span><span class="s1">at: this.state.startLoc,</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">node.right = this.parseExprOpRightExpr(op, prec);</span><span class="s2">\n        </span><span class="s1">const finishedNode = this.finishNode(</span><span class="s2">\n          </span><span class="s1">node,</span><span class="s2">\n          </span><span class="s1">logical || coalesce ? </span><span class="s2">\&quot;</span><span class="s1">LogicalExpression</span><span class="s2">\&quot; </span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">BinaryExpression</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">/* this check is for all ?? operators</span><span class="s2">\n         </span><span class="s1">* a ?? b &amp;&amp; c for this example</span><span class="s2">\n         </span><span class="s1">* when op is coalesce and nextOp is logical (&amp;&amp;), throw at the pos of nextOp that it can not be mixed.</span><span class="s2">\n         </span><span class="s1">* Symmetrically it also throws when op is logical and nextOp is coalesce</span><span class="s2">\n         </span><span class="s1">*/</span><span class="s2">\n        </span><span class="s1">const nextOp = this.state.type;</span><span class="s2">\n        </span><span class="s1">if (</span><span class="s2">\n          </span><span class="s1">(coalesce &amp;&amp; (nextOp === tt.logicalOR || nextOp === tt.logicalAND)) ||</span><span class="s2">\n          </span><span class="s1">(logical &amp;&amp; nextOp === tt.nullishCoalescing)</span><span class="s2">\n        </span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">throw this.raise(Errors.MixingCoalesceWithLogical, {</span><span class="s2">\n            </span><span class="s1">at: this.state.startLoc,</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">return this.parseExprOp(finishedNode, leftStartLoc, minPrec);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return left;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Helper function for `parseExprOp`. Parse the right-hand side of binary-</span><span class="s2">\n  </span><span class="s1">// operator expressions, then apply any operator-specific functions.</span><span class="s2">\n\n  </span><span class="s1">parseExprOpRightExpr(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">op: TokenType,</span><span class="s2">\n    </span><span class="s1">prec: number,</span><span class="s2">\n  </span><span class="s1">): N.Expression {</span><span class="s2">\n    </span><span class="s1">const startLoc = this.state.startLoc;</span><span class="s2">\n    </span><span class="s1">switch (op) {</span><span class="s2">\n      </span><span class="s1">case tt.pipeline:</span><span class="s2">\n        </span><span class="s1">switch (this.getPluginOption(</span><span class="s2">\&quot;</span><span class="s1">pipelineOperator</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">proposal</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n          </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">hack</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n            </span><span class="s1">return this.withTopicBindingContext(() =&gt; {</span><span class="s2">\n              </span><span class="s1">return this.parseHackPipeBody();</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n\n          </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">smart</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n            </span><span class="s1">return this.withTopicBindingContext(() =&gt; {</span><span class="s2">\n              </span><span class="s1">if (this.prodParam.hasYield &amp;&amp; this.isContextual(tt._yield)) {</span><span class="s2">\n                </span><span class="s1">throw this.raise(Errors.PipeBodyIsTighter, {</span><span class="s2">\n                  </span><span class="s1">at: this.state.startLoc,</span><span class="s2">\n                </span><span class="s1">});</span><span class="s2">\n              </span><span class="s1">}</span><span class="s2">\n              </span><span class="s1">return this.parseSmartPipelineBodyInStyle(</span><span class="s2">\n                </span><span class="s1">this.parseExprOpBaseRightExpr(op, prec),</span><span class="s2">\n                </span><span class="s1">startLoc,</span><span class="s2">\n              </span><span class="s1">);</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n\n          </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">fsharp</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n            </span><span class="s1">return this.withSoloAwaitPermittingContext(() =&gt; {</span><span class="s2">\n              </span><span class="s1">return this.parseFSharpPipelineBody(prec);</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">// Falls through.</span><span class="s2">\n      </span><span class="s1">default:</span><span class="s2">\n        </span><span class="s1">return this.parseExprOpBaseRightExpr(op, prec);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Helper function for `parseExprOpRightExpr`. Parse the right-hand side of</span><span class="s2">\n  </span><span class="s1">// binary-operator expressions without applying any operator-specific functions.</span><span class="s2">\n\n  </span><span class="s1">parseExprOpBaseRightExpr(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">op: TokenType,</span><span class="s2">\n    </span><span class="s1">prec: number,</span><span class="s2">\n  </span><span class="s1">): N.Expression {</span><span class="s2">\n    </span><span class="s1">const startLoc = this.state.startLoc;</span><span class="s2">\n\n    </span><span class="s1">return this.parseExprOp(</span><span class="s2">\n      </span><span class="s1">this.parseMaybeUnaryOrPrivate(),</span><span class="s2">\n      </span><span class="s1">startLoc,</span><span class="s2">\n      </span><span class="s1">tokenIsRightAssociative(op) ? prec - 1 : prec,</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">parseHackPipeBody(this: Parser): N.Expression {</span><span class="s2">\n    </span><span class="s1">const { startLoc } = this.state;</span><span class="s2">\n    </span><span class="s1">const body = this.parseMaybeAssign();</span><span class="s2">\n    </span><span class="s1">const requiredParentheses = UnparenthesizedPipeBodyDescriptions.has(</span><span class="s2">\n      </span><span class="s1">// @ts-expect-error TS2345: Argument of type 'string' is not assignable to parameter of type '</span><span class="s2">\&quot;</span><span class="s1">ArrowFunctionExpression</span><span class="s2">\&quot; </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">YieldExpression</span><span class="s2">\&quot; </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">AssignmentExpression</span><span class="s2">\&quot; </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">ConditionalExpression</span><span class="s2">\&quot;</span><span class="s1">'.</span><span class="s2">\n      </span><span class="s1">body.type,</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n\n    </span><span class="s1">// TODO: Check how to handle type casts in Flow and TS once they are supported</span><span class="s2">\n    </span><span class="s1">if (requiredParentheses &amp;&amp; !body.extra?.parenthesized) {</span><span class="s2">\n      </span><span class="s1">this.raise(Errors.PipeUnparenthesizedBody, {</span><span class="s2">\n        </span><span class="s1">at: startLoc,</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error TS2322: Type 'string' is not assignable to type '</span><span class="s2">\&quot;</span><span class="s1">AssignmentExpression</span><span class="s2">\&quot; </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">ArrowFunctionExpression</span><span class="s2">\&quot; </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">ConditionalExpression</span><span class="s2">\&quot; </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">YieldExpression</span><span class="s2">\&quot;</span><span class="s1">'.</span><span class="s2">\n        </span><span class="s1">type: body.type,</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (!this.topicReferenceWasUsedInCurrentContext()) {</span><span class="s2">\n      </span><span class="s1">// A Hack pipe body must use the topic reference at least once.</span><span class="s2">\n      </span><span class="s1">this.raise(Errors.PipeTopicUnused, { at: startLoc });</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">return body;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">checkExponentialAfterUnary(</span><span class="s2">\n    </span><span class="s1">node: N.AwaitExpression | Undone&lt;N.UnaryExpression&gt;,</span><span class="s2">\n  </span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">if (this.match(tt.exponent)) {</span><span class="s2">\n      </span><span class="s1">this.raise(Errors.UnexpectedTokenUnaryExponentiation, {</span><span class="s2">\n        </span><span class="s1">at: node.argument,</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Parse unary operators, both prefix and postfix.</span><span class="s2">\n  </span><span class="s1">// https://tc39.es/ecma262/#prod-UnaryExpression</span><span class="s2">\n  </span><span class="s1">parseMaybeUnary(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">refExpressionErrors?: ExpressionErrors | null,</span><span class="s2">\n    </span><span class="s1">sawUnary?: boolean,</span><span class="s2">\n  </span><span class="s1">): N.Expression {</span><span class="s2">\n    </span><span class="s1">const startLoc = this.state.startLoc;</span><span class="s2">\n    </span><span class="s1">const isAwait = this.isContextual(tt._await);</span><span class="s2">\n\n    </span><span class="s1">if (isAwait &amp;&amp; this.isAwaitAllowed()) {</span><span class="s2">\n      </span><span class="s1">this.next();</span><span class="s2">\n      </span><span class="s1">const expr = this.parseAwait(startLoc);</span><span class="s2">\n      </span><span class="s1">if (!sawUnary) this.checkExponentialAfterUnary(expr);</span><span class="s2">\n      </span><span class="s1">return expr;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">const update = this.match(tt.incDec);</span><span class="s2">\n    </span><span class="s1">const node = this.startNode&lt;N.UnaryExpression | N.UpdateExpression&gt;();</span><span class="s2">\n    </span><span class="s1">if (tokenIsPrefix(this.state.type)) {</span><span class="s2">\n      </span><span class="s1">node.operator = this.state.value;</span><span class="s2">\n      </span><span class="s1">node.prefix = true;</span><span class="s2">\n\n      </span><span class="s1">if (this.match(tt._throw)) {</span><span class="s2">\n        </span><span class="s1">this.expectPlugin(</span><span class="s2">\&quot;</span><span class="s1">throwExpressions</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">const isDelete = this.match(tt._delete);</span><span class="s2">\n      </span><span class="s1">this.next();</span><span class="s2">\n\n      </span><span class="s1">node.argument = this.parseMaybeUnary(null, true);</span><span class="s2">\n\n      </span><span class="s1">this.checkExpressionErrors(refExpressionErrors, true);</span><span class="s2">\n\n      </span><span class="s1">if (this.state.strict &amp;&amp; isDelete) {</span><span class="s2">\n        </span><span class="s1">const arg = node.argument;</span><span class="s2">\n\n        </span><span class="s1">if (arg.type === </span><span class="s2">\&quot;</span><span class="s1">Identifier</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">this.raise(Errors.StrictDelete, { at: node });</span><span class="s2">\n        </span><span class="s1">} else if (this.hasPropertyAsPrivateName(arg)) {</span><span class="s2">\n          </span><span class="s1">this.raise(Errors.DeletePrivateField, { at: node });</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">if (!update) {</span><span class="s2">\n        </span><span class="s1">if (!sawUnary) {</span><span class="s2">\n          </span><span class="s1">this.checkExponentialAfterUnary(node as Undone&lt;N.UnaryExpression&gt;);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">UnaryExpression</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">const expr = this.parseUpdate(</span><span class="s2">\n      </span><span class="s1">// @ts-expect-error using </span><span class="s2">\&quot;</span><span class="s1">Undone</span><span class="s2">\&quot; </span><span class="s1">node as </span><span class="s2">\&quot;</span><span class="s1">done</span><span class="s2">\&quot;\n      </span><span class="s1">node,</span><span class="s2">\n      </span><span class="s1">update,</span><span class="s2">\n      </span><span class="s1">refExpressionErrors,</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n\n    </span><span class="s1">if (isAwait) {</span><span class="s2">\n      </span><span class="s1">const { type } = this.state;</span><span class="s2">\n      </span><span class="s1">const startsExpr = this.hasPlugin(</span><span class="s2">\&quot;</span><span class="s1">v8intrinsic</span><span class="s2">\&quot;</span><span class="s1">)</span><span class="s2">\n        </span><span class="s1">? tokenCanStartExpression(type)</span><span class="s2">\n        </span><span class="s1">: tokenCanStartExpression(type) &amp;&amp; !this.match(tt.modulo);</span><span class="s2">\n      </span><span class="s1">if (startsExpr &amp;&amp; !this.isAmbiguousAwait()) {</span><span class="s2">\n        </span><span class="s1">this.raiseOverwrite(Errors.AwaitNotInAsyncContext, { at: startLoc });</span><span class="s2">\n        </span><span class="s1">return this.parseAwait(startLoc);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">return expr;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// https://tc39.es/ecma262/#prod-UpdateExpression</span><span class="s2">\n  </span><span class="s1">parseUpdate(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">node: N.Expression,</span><span class="s2">\n    </span><span class="s1">update: boolean,</span><span class="s2">\n    </span><span class="s1">refExpressionErrors?: ExpressionErrors | null,</span><span class="s2">\n  </span><span class="s1">): N.Expression {</span><span class="s2">\n    </span><span class="s1">if (update) {</span><span class="s2">\n      </span><span class="s1">// @ts-expect-error Type 'Node' is missing the following properties from type 'Undone&lt;UpdateExpression&gt;': prefix, operator, argument</span><span class="s2">\n      </span><span class="s1">const updateExpressionNode = node as Undone&lt;N.UpdateExpression&gt;;</span><span class="s2">\n      </span><span class="s1">this.checkLVal(updateExpressionNode.argument, {</span><span class="s2">\n        </span><span class="s1">in: this.finishNode(updateExpressionNode, </span><span class="s2">\&quot;</span><span class="s1">UpdateExpression</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">return node;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">const startLoc = this.state.startLoc;</span><span class="s2">\n    </span><span class="s1">let expr = this.parseExprSubscripts(refExpressionErrors);</span><span class="s2">\n    </span><span class="s1">if (this.checkExpressionErrors(refExpressionErrors, false)) return expr;</span><span class="s2">\n    </span><span class="s1">while (tokenIsPostfix(this.state.type) &amp;&amp; !this.canInsertSemicolon()) {</span><span class="s2">\n      </span><span class="s1">const node = this.startNodeAt&lt;N.UpdateExpression&gt;(startLoc);</span><span class="s2">\n      </span><span class="s1">node.operator = this.state.value;</span><span class="s2">\n      </span><span class="s1">node.prefix = false;</span><span class="s2">\n      </span><span class="s1">node.argument = expr;</span><span class="s2">\n      </span><span class="s1">this.next();</span><span class="s2">\n      </span><span class="s1">this.checkLVal(expr, {</span><span class="s2">\n        </span><span class="s1">in: (expr = this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">UpdateExpression</span><span class="s2">\&quot;</span><span class="s1">)),</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return expr;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Parse call, dot, and `[]`-subscript expressions.</span><span class="s2">\n  </span><span class="s1">// https://tc39.es/ecma262/#prod-LeftHandSideExpression</span><span class="s2">\n  </span><span class="s1">parseExprSubscripts(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">refExpressionErrors?: ExpressionErrors | null,</span><span class="s2">\n  </span><span class="s1">): N.Expression {</span><span class="s2">\n    </span><span class="s1">const startLoc = this.state.startLoc;</span><span class="s2">\n    </span><span class="s1">const potentialArrowAt = this.state.potentialArrowAt;</span><span class="s2">\n    </span><span class="s1">const expr = this.parseExprAtom(refExpressionErrors);</span><span class="s2">\n\n    </span><span class="s1">if (this.shouldExitDescending(expr, potentialArrowAt)) {</span><span class="s2">\n      </span><span class="s1">return expr;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">return this.parseSubscripts(expr, startLoc);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">parseSubscripts(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">base: N.Expression,</span><span class="s2">\n    </span><span class="s1">startLoc: Position,</span><span class="s2">\n    </span><span class="s1">noCalls?: boolean | null,</span><span class="s2">\n  </span><span class="s1">): N.Expression {</span><span class="s2">\n    </span><span class="s1">const state = {</span><span class="s2">\n      </span><span class="s1">optionalChainMember: false,</span><span class="s2">\n      </span><span class="s1">maybeAsyncArrow: this.atPossibleAsyncArrow(base),</span><span class="s2">\n      </span><span class="s1">stop: false,</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">do {</span><span class="s2">\n      </span><span class="s1">base = this.parseSubscript(base, startLoc, noCalls, state);</span><span class="s2">\n\n      </span><span class="s1">// After parsing a subscript, this isn't </span><span class="s2">\&quot;</span><span class="s1">async</span><span class="s2">\&quot; </span><span class="s1">for sure.</span><span class="s2">\n      </span><span class="s1">state.maybeAsyncArrow = false;</span><span class="s2">\n    </span><span class="s1">} while (!state.stop);</span><span class="s2">\n    </span><span class="s1">return base;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* @param state Set 'state.stop = true' to indicate that we should stop parsing subscripts.</span><span class="s2">\n   </span><span class="s1">*   state.optionalChainMember to indicate that the member is currently in OptionalChain</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">parseSubscript(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">base: N.Expression,</span><span class="s2">\n    </span><span class="s1">startLoc: Position,</span><span class="s2">\n    </span><span class="s1">noCalls: boolean | undefined | null,</span><span class="s2">\n    </span><span class="s1">state: N.ParseSubscriptState,</span><span class="s2">\n  </span><span class="s1">): N.Expression {</span><span class="s2">\n    </span><span class="s1">const { type } = this.state;</span><span class="s2">\n    </span><span class="s1">if (!noCalls &amp;&amp; type === tt.doubleColon) {</span><span class="s2">\n      </span><span class="s1">return this.parseBind(base, startLoc, noCalls, state);</span><span class="s2">\n    </span><span class="s1">} else if (tokenIsTemplate(type)) {</span><span class="s2">\n      </span><span class="s1">return this.parseTaggedTemplateExpression(base, startLoc, state);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">let optional = false;</span><span class="s2">\n\n    </span><span class="s1">if (type === tt.questionDot) {</span><span class="s2">\n      </span><span class="s1">if (noCalls) {</span><span class="s2">\n        </span><span class="s1">this.raise(Errors.OptionalChainingNoNew, {</span><span class="s2">\n          </span><span class="s1">at: this.state.startLoc,</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">if (this.lookaheadCharCode() === charCodes.leftParenthesis) {</span><span class="s2">\n          </span><span class="s1">// stop at `?.` when parsing `new a?.()`</span><span class="s2">\n          </span><span class="s1">state.stop = true;</span><span class="s2">\n          </span><span class="s1">return base;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">state.optionalChainMember = optional = true;</span><span class="s2">\n      </span><span class="s1">this.next();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">if (!noCalls &amp;&amp; this.match(tt.parenL)) {</span><span class="s2">\n      </span><span class="s1">return this.parseCoverCallAndAsyncArrowHead(</span><span class="s2">\n        </span><span class="s1">base,</span><span class="s2">\n        </span><span class="s1">startLoc,</span><span class="s2">\n        </span><span class="s1">state,</span><span class="s2">\n        </span><span class="s1">optional,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">const computed = this.eat(tt.bracketL);</span><span class="s2">\n      </span><span class="s1">if (computed || optional || this.eat(tt.dot)) {</span><span class="s2">\n        </span><span class="s1">return this.parseMember(base, startLoc, state, computed, optional);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">state.stop = true;</span><span class="s2">\n        </span><span class="s1">return base;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// base[?Yield, ?Await] [ Expression[+In, ?Yield, ?Await] ]</span><span class="s2">\n  </span><span class="s1">// base[?Yield, ?Await] . IdentifierName</span><span class="s2">\n  </span><span class="s1">// base[?Yield, ?Await] . PrivateIdentifier</span><span class="s2">\n  </span><span class="s1">//   where `base` is one of CallExpression, MemberExpression and OptionalChain</span><span class="s2">\n  </span><span class="s1">parseMember(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">base: N.Expression,</span><span class="s2">\n    </span><span class="s1">startLoc: Position,</span><span class="s2">\n    </span><span class="s1">state: N.ParseSubscriptState,</span><span class="s2">\n    </span><span class="s1">computed: boolean,</span><span class="s2">\n    </span><span class="s1">optional: boolean,</span><span class="s2">\n  </span><span class="s1">): N.OptionalMemberExpression | N.MemberExpression {</span><span class="s2">\n    </span><span class="s1">const node = this.startNodeAt&lt;</span><span class="s2">\n      </span><span class="s1">N.OptionalMemberExpression | N.MemberExpression</span><span class="s2">\n    </span><span class="s1">&gt;(startLoc);</span><span class="s2">\n    </span><span class="s1">node.object = base;</span><span class="s2">\n    </span><span class="s1">node.computed = computed;</span><span class="s2">\n    </span><span class="s1">if (computed) {</span><span class="s2">\n      </span><span class="s1">node.property = this.parseExpression();</span><span class="s2">\n      </span><span class="s1">this.expect(tt.bracketR);</span><span class="s2">\n    </span><span class="s1">} else if (this.match(tt.privateName)) {</span><span class="s2">\n      </span><span class="s1">if (base.type === </span><span class="s2">\&quot;</span><span class="s1">Super</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">this.raise(Errors.SuperPrivateField, { at: startLoc });</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">this.classScope.usePrivateName(this.state.value, this.state.startLoc);</span><span class="s2">\n      </span><span class="s1">node.property = this.parsePrivateName();</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">node.property = this.parseIdentifier(true);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">if (state.optionalChainMember) {</span><span class="s2">\n      </span><span class="s1">(node as N.OptionalMemberExpression).optional = optional;</span><span class="s2">\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">OptionalMemberExpression</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">MemberExpression</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// https://github.com/tc39/proposal-bind-operator#syntax</span><span class="s2">\n  </span><span class="s1">parseBind(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">base: N.Expression,</span><span class="s2">\n    </span><span class="s1">startLoc: Position,</span><span class="s2">\n    </span><span class="s1">noCalls: boolean | undefined | null,</span><span class="s2">\n    </span><span class="s1">state: N.ParseSubscriptState,</span><span class="s2">\n  </span><span class="s1">): N.Expression {</span><span class="s2">\n    </span><span class="s1">const node = this.startNodeAt(startLoc);</span><span class="s2">\n    </span><span class="s1">node.object = base;</span><span class="s2">\n    </span><span class="s1">this.next(); // eat '::'</span><span class="s2">\n    </span><span class="s1">node.callee = this.parseNoCallExpr();</span><span class="s2">\n    </span><span class="s1">state.stop = true;</span><span class="s2">\n    </span><span class="s1">return this.parseSubscripts(</span><span class="s2">\n      </span><span class="s1">this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">BindExpression</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n      </span><span class="s1">startLoc,</span><span class="s2">\n      </span><span class="s1">noCalls,</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// https://tc39.es/ecma262/#prod-CoverCallExpressionAndAsyncArrowHead</span><span class="s2">\n  </span><span class="s1">// CoverCallExpressionAndAsyncArrowHead</span><span class="s2">\n  </span><span class="s1">// CallExpression[?Yield, ?Await] Arguments[?Yield, ?Await]</span><span class="s2">\n  </span><span class="s1">// OptionalChain[?Yield, ?Await] Arguments[?Yield, ?Await]</span><span class="s2">\n  </span><span class="s1">parseCoverCallAndAsyncArrowHead(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">base: N.Expression,</span><span class="s2">\n    </span><span class="s1">startLoc: Position,</span><span class="s2">\n    </span><span class="s1">state: N.ParseSubscriptState,</span><span class="s2">\n    </span><span class="s1">optional: boolean,</span><span class="s2">\n  </span><span class="s1">): N.Expression {</span><span class="s2">\n    </span><span class="s1">const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;</span><span class="s2">\n    </span><span class="s1">let refExpressionErrors: ExpressionErrors | null = null;</span><span class="s2">\n\n    </span><span class="s1">this.state.maybeInArrowParameters = true;</span><span class="s2">\n    </span><span class="s1">this.next(); // eat `(`</span><span class="s2">\n\n    </span><span class="s1">const node = this.startNodeAt&lt;N.CallExpression | N.OptionalCallExpression&gt;(</span><span class="s2">\n      </span><span class="s1">startLoc,</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">node.callee = base;</span><span class="s2">\n    </span><span class="s1">const { maybeAsyncArrow, optionalChainMember } = state;</span><span class="s2">\n\n    </span><span class="s1">if (maybeAsyncArrow) {</span><span class="s2">\n      </span><span class="s1">this.expressionScope.enter(newAsyncArrowScope());</span><span class="s2">\n      </span><span class="s1">refExpressionErrors = new ExpressionErrors();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">if (optionalChainMember) {</span><span class="s2">\n      </span><span class="s1">// @ts-expect-error when optionalChainMember is true, node must be an optional call</span><span class="s2">\n      </span><span class="s1">node.optional = optional;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">if (optional) {</span><span class="s2">\n      </span><span class="s1">node.arguments = this.parseCallExpressionArguments(tt.parenR);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">node.arguments = this.parseCallExpressionArguments(</span><span class="s2">\n        </span><span class="s1">tt.parenR,</span><span class="s2">\n        </span><span class="s1">base.type === </span><span class="s2">\&quot;</span><span class="s1">Import</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">base.type !== </span><span class="s2">\&quot;</span><span class="s1">Super</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts)</span><span class="s2">\n        </span><span class="s1">node,</span><span class="s2">\n        </span><span class="s1">refExpressionErrors,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let finishedNode:</span><span class="s2">\n      </span><span class="s1">| N.CallExpression</span><span class="s2">\n      </span><span class="s1">| N.OptionalCallExpression</span><span class="s2">\n      </span><span class="s1">| N.ArrowFunctionExpression = this.finishCallExpression(</span><span class="s2">\n      </span><span class="s1">node,</span><span class="s2">\n      </span><span class="s1">optionalChainMember,</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n\n    </span><span class="s1">if (maybeAsyncArrow &amp;&amp; this.shouldParseAsyncArrow() &amp;&amp; !optional) {</span><span class="s2">\n      </span><span class="s1">/*:: invariant(refExpressionErrors != null) */</span><span class="s2">\n      </span><span class="s1">state.stop = true;</span><span class="s2">\n      </span><span class="s1">this.checkDestructuringPrivate(refExpressionErrors);</span><span class="s2">\n      </span><span class="s1">this.expressionScope.validateAsPattern();</span><span class="s2">\n      </span><span class="s1">this.expressionScope.exit();</span><span class="s2">\n      </span><span class="s1">finishedNode = this.parseAsyncArrowFromCallExpression(</span><span class="s2">\n        </span><span class="s1">this.startNodeAt&lt;N.ArrowFunctionExpression&gt;(startLoc),</span><span class="s2">\n        </span><span class="s1">finishedNode as N.CallExpression,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">if (maybeAsyncArrow) {</span><span class="s2">\n        </span><span class="s1">this.checkExpressionErrors(refExpressionErrors, true);</span><span class="s2">\n        </span><span class="s1">this.expressionScope.exit();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">this.toReferencedArguments(finishedNode);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">this.state.maybeInArrowParameters = oldMaybeInArrowParameters;</span><span class="s2">\n\n    </span><span class="s1">return finishedNode;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">toReferencedArguments(</span><span class="s2">\n    </span><span class="s1">node: N.CallExpression | N.OptionalCallExpression,</span><span class="s2">\n    </span><span class="s1">isParenthesizedExpr?: boolean,</span><span class="s2">\n  </span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">this.toReferencedListDeep(node.arguments, isParenthesizedExpr);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// MemberExpression [?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged]</span><span class="s2">\n  </span><span class="s1">// CallExpression [?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged]</span><span class="s2">\n  </span><span class="s1">parseTaggedTemplateExpression(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">base: N.Expression,</span><span class="s2">\n    </span><span class="s1">startLoc: Position,</span><span class="s2">\n    </span><span class="s1">state: N.ParseSubscriptState,</span><span class="s2">\n  </span><span class="s1">): N.TaggedTemplateExpression {</span><span class="s2">\n    </span><span class="s1">const node = this.startNodeAt&lt;N.TaggedTemplateExpression&gt;(startLoc);</span><span class="s2">\n    </span><span class="s1">node.tag = base;</span><span class="s2">\n    </span><span class="s1">node.quasi = this.parseTemplate(true);</span><span class="s2">\n    </span><span class="s1">if (state.optionalChainMember) {</span><span class="s2">\n      </span><span class="s1">this.raise(Errors.OptionalChainingNoTemplate, { at: startLoc });</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">TaggedTemplateExpression</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">atPossibleAsyncArrow(base: N.Expression): boolean {</span><span class="s2">\n    </span><span class="s1">return (</span><span class="s2">\n      </span><span class="s1">base.type === </span><span class="s2">\&quot;</span><span class="s1">Identifier</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n      </span><span class="s1">base.name === </span><span class="s2">\&quot;</span><span class="s1">async</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n      </span><span class="s1">this.state.lastTokEndLoc.index === base.end &amp;&amp;</span><span class="s2">\n      </span><span class="s1">!this.canInsertSemicolon() &amp;&amp;</span><span class="s2">\n      </span><span class="s1">// check there are no escape sequences, such as </span><span class="s2">\\</span><span class="s1">u{61}sync</span><span class="s2">\n      </span><span class="s1">base.end - base.start === 5 &amp;&amp;</span><span class="s2">\n      </span><span class="s1">base.start === this.state.potentialArrowAt</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">finishCallExpression&lt;T extends N.CallExpression | N.OptionalCallExpression&gt;(</span><span class="s2">\n    </span><span class="s1">node: Undone&lt;T&gt;,</span><span class="s2">\n    </span><span class="s1">optional: boolean,</span><span class="s2">\n  </span><span class="s1">): T {</span><span class="s2">\n    </span><span class="s1">if (node.callee.type === </span><span class="s2">\&quot;</span><span class="s1">Import</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">if (node.arguments.length === 2) {</span><span class="s2">\n        </span><span class="s1">if (process.env.BABEL_8_BREAKING) {</span><span class="s2">\n          </span><span class="s1">this.expectPlugin(</span><span class="s2">\&quot;</span><span class="s1">importAssertions</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">if (!this.hasPlugin(</span><span class="s2">\&quot;</span><span class="s1">moduleAttributes</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n            </span><span class="s1">this.expectPlugin(</span><span class="s2">\&quot;</span><span class="s1">importAssertions</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (node.arguments.length === 0 || node.arguments.length &gt; 2) {</span><span class="s2">\n        </span><span class="s1">this.raise(Errors.ImportCallArity, {</span><span class="s2">\n          </span><span class="s1">at: node,</span><span class="s2">\n          </span><span class="s1">maxArgumentCount:</span><span class="s2">\n            </span><span class="s1">this.hasPlugin(</span><span class="s2">\&quot;</span><span class="s1">importAssertions</span><span class="s2">\&quot;</span><span class="s1">) ||</span><span class="s2">\n            </span><span class="s1">this.hasPlugin(</span><span class="s2">\&quot;</span><span class="s1">moduleAttributes</span><span class="s2">\&quot;</span><span class="s1">)</span><span class="s2">\n              </span><span class="s1">? 2</span><span class="s2">\n              </span><span class="s1">: 1,</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">for (const arg of node.arguments) {</span><span class="s2">\n          </span><span class="s1">if (arg.type === </span><span class="s2">\&quot;</span><span class="s1">SpreadElement</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n            </span><span class="s1">this.raise(Errors.ImportCallSpreadArgument, { at: arg });</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return this.finishNode(</span><span class="s2">\n      </span><span class="s1">node,</span><span class="s2">\n      </span><span class="s1">optional ? </span><span class="s2">\&quot;</span><span class="s1">OptionalCallExpression</span><span class="s2">\&quot; </span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">CallExpression</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">parseCallExpressionArguments(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">close: TokenType,</span><span class="s2">\n    </span><span class="s1">dynamicImport?: boolean,</span><span class="s2">\n    </span><span class="s1">allowPlaceholder?: boolean,</span><span class="s2">\n    </span><span class="s1">nodeForExtra?: N.Node | null,</span><span class="s2">\n    </span><span class="s1">refExpressionErrors?: ExpressionErrors | null,</span><span class="s2">\n  </span><span class="s1">): Array&lt;N.Expression | undefined | null&gt; {</span><span class="s2">\n    </span><span class="s1">const elts: N.Expression[] = [];</span><span class="s2">\n    </span><span class="s1">let first = true;</span><span class="s2">\n    </span><span class="s1">const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;</span><span class="s2">\n    </span><span class="s1">this.state.inFSharpPipelineDirectBody = false;</span><span class="s2">\n\n    </span><span class="s1">while (!this.eat(close)) {</span><span class="s2">\n      </span><span class="s1">if (first) {</span><span class="s2">\n        </span><span class="s1">first = false;</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">this.expect(tt.comma);</span><span class="s2">\n        </span><span class="s1">if (this.match(close)) {</span><span class="s2">\n          </span><span class="s1">if (</span><span class="s2">\n            </span><span class="s1">dynamicImport &amp;&amp;</span><span class="s2">\n            </span><span class="s1">!this.hasPlugin(</span><span class="s2">\&quot;</span><span class="s1">importAssertions</span><span class="s2">\&quot;</span><span class="s1">) &amp;&amp;</span><span class="s2">\n            </span><span class="s1">!this.hasPlugin(</span><span class="s2">\&quot;</span><span class="s1">moduleAttributes</span><span class="s2">\&quot;</span><span class="s1">)</span><span class="s2">\n          </span><span class="s1">) {</span><span class="s2">\n            </span><span class="s1">this.raise(Errors.ImportCallArgumentTrailingComma, {</span><span class="s2">\n              </span><span class="s1">at: this.state.lastTokStartLoc,</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">if (nodeForExtra) {</span><span class="s2">\n            </span><span class="s1">this.addTrailingCommaExtraToNode(nodeForExtra);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">this.next();</span><span class="s2">\n          </span><span class="s1">break;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">elts.push(</span><span class="s2">\n        </span><span class="s1">this.parseExprListItem(false, refExpressionErrors, allowPlaceholder),</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;</span><span class="s2">\n\n    </span><span class="s1">return elts;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">shouldParseAsyncArrow(): boolean {</span><span class="s2">\n    </span><span class="s1">return this.match(tt.arrow) &amp;&amp; !this.canInsertSemicolon();</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">parseAsyncArrowFromCallExpression(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">node: Undone&lt;N.ArrowFunctionExpression&gt;,</span><span class="s2">\n    </span><span class="s1">call: N.CallExpression,</span><span class="s2">\n  </span><span class="s1">): N.ArrowFunctionExpression {</span><span class="s2">\n    </span><span class="s1">this.resetPreviousNodeTrailingComments(call);</span><span class="s2">\n    </span><span class="s1">this.expect(tt.arrow);</span><span class="s2">\n    </span><span class="s1">this.parseArrowExpression(</span><span class="s2">\n      </span><span class="s1">node,</span><span class="s2">\n      </span><span class="s1">call.arguments,</span><span class="s2">\n      </span><span class="s1">true,</span><span class="s2">\n      </span><span class="s1">call.extra?.trailingCommaLoc,</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">// mark inner comments of `async()` as inner comments of `async () =&gt;`</span><span class="s2">\n    </span><span class="s1">if (call.innerComments) {</span><span class="s2">\n      </span><span class="s1">setInnerComments(node, call.innerComments);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// mark trailing comments of `async` to be inner comments</span><span class="s2">\n    </span><span class="s1">if (call.callee.trailingComments) {</span><span class="s2">\n      </span><span class="s1">setInnerComments(node, call.callee.trailingComments);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return node as N.ArrowFunctionExpression;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Parse a no-call expression (like argument of `new` or `::` operators).</span><span class="s2">\n  </span><span class="s1">// https://tc39.es/ecma262/#prod-MemberExpression</span><span class="s2">\n  </span><span class="s1">parseNoCallExpr(this: Parser): N.Expression {</span><span class="s2">\n    </span><span class="s1">const startLoc = this.state.startLoc;</span><span class="s2">\n    </span><span class="s1">return this.parseSubscripts(this.parseExprAtom(), startLoc, true);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Parse an atomic expression — either a single token that is an</span><span class="s2">\n  </span><span class="s1">// expression, an expression started by a keyword like `function` or</span><span class="s2">\n  </span><span class="s1">// `new`, or an expression wrapped in punctuation like `()`, `[]`,</span><span class="s2">\n  </span><span class="s1">// or `{}`.</span><span class="s2">\n\n  </span><span class="s1">// https://tc39.es/ecma262/#prod-PrimaryExpression</span><span class="s2">\n  </span><span class="s1">// https://tc39.es/ecma262/#prod-AsyncArrowFunction</span><span class="s2">\n  </span><span class="s1">// PrimaryExpression</span><span class="s2">\n  </span><span class="s1">// Super</span><span class="s2">\n  </span><span class="s1">// Import</span><span class="s2">\n  </span><span class="s1">// AsyncArrowFunction</span><span class="s2">\n\n  </span><span class="s1">parseExprAtom(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">refExpressionErrors?: ExpressionErrors | null,</span><span class="s2">\n  </span><span class="s1">): N.Expression {</span><span class="s2">\n    </span><span class="s1">let node;</span><span class="s2">\n    </span><span class="s1">let decorators: N.Decorator[] | null = null;</span><span class="s2">\n\n    </span><span class="s1">const { type } = this.state;</span><span class="s2">\n    </span><span class="s1">switch (type) {</span><span class="s2">\n      </span><span class="s1">case tt._super:</span><span class="s2">\n        </span><span class="s1">return this.parseSuper();</span><span class="s2">\n\n      </span><span class="s1">case tt._import:</span><span class="s2">\n        </span><span class="s1">node = this.startNode&lt;N.MetaProperty | N.Import&gt;();</span><span class="s2">\n        </span><span class="s1">this.next();</span><span class="s2">\n\n        </span><span class="s1">if (this.match(tt.dot)) {</span><span class="s2">\n          </span><span class="s1">return this.parseImportMetaProperty(node as Undone&lt;N.MetaProperty&gt;);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">if (!this.match(tt.parenL)) {</span><span class="s2">\n          </span><span class="s1">this.raise(Errors.UnsupportedImport, {</span><span class="s2">\n            </span><span class="s1">at: this.state.lastTokStartLoc,</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">Import</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">case tt._this:</span><span class="s2">\n        </span><span class="s1">node = this.startNode();</span><span class="s2">\n        </span><span class="s1">this.next();</span><span class="s2">\n        </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">ThisExpression</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n\n      </span><span class="s1">case tt._do: {</span><span class="s2">\n        </span><span class="s1">return this.parseDo(this.startNode(), false);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">case tt.slash:</span><span class="s2">\n      </span><span class="s1">case tt.slashAssign: {</span><span class="s2">\n        </span><span class="s1">this.readRegexp();</span><span class="s2">\n        </span><span class="s1">return this.parseRegExpLiteral(this.state.value);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">case tt.num:</span><span class="s2">\n        </span><span class="s1">return this.parseNumericLiteral(this.state.value);</span><span class="s2">\n\n      </span><span class="s1">case tt.bigint:</span><span class="s2">\n        </span><span class="s1">return this.parseBigIntLiteral(this.state.value);</span><span class="s2">\n\n      </span><span class="s1">case tt.decimal:</span><span class="s2">\n        </span><span class="s1">return this.parseDecimalLiteral(this.state.value);</span><span class="s2">\n\n      </span><span class="s1">case tt.string:</span><span class="s2">\n        </span><span class="s1">return this.parseStringLiteral(this.state.value);</span><span class="s2">\n\n      </span><span class="s1">case tt._null:</span><span class="s2">\n        </span><span class="s1">return this.parseNullLiteral();</span><span class="s2">\n\n      </span><span class="s1">case tt._true:</span><span class="s2">\n        </span><span class="s1">return this.parseBooleanLiteral(true);</span><span class="s2">\n      </span><span class="s1">case tt._false:</span><span class="s2">\n        </span><span class="s1">return this.parseBooleanLiteral(false);</span><span class="s2">\n\n      </span><span class="s1">case tt.parenL: {</span><span class="s2">\n        </span><span class="s1">const canBeArrow = this.state.potentialArrowAt === this.state.start;</span><span class="s2">\n        </span><span class="s1">return this.parseParenAndDistinguishExpression(canBeArrow);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">case tt.bracketBarL:</span><span class="s2">\n      </span><span class="s1">case tt.bracketHashL: {</span><span class="s2">\n        </span><span class="s1">return this.parseArrayLike(</span><span class="s2">\n          </span><span class="s1">this.state.type === tt.bracketBarL ? tt.bracketBarR : tt.bracketR,</span><span class="s2">\n          </span><span class="s1">/* canBePattern */ false,</span><span class="s2">\n          </span><span class="s1">/* isTuple */ true,</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">case tt.bracketL: {</span><span class="s2">\n        </span><span class="s1">return this.parseArrayLike(</span><span class="s2">\n          </span><span class="s1">tt.bracketR,</span><span class="s2">\n          </span><span class="s1">/* canBePattern */ true,</span><span class="s2">\n          </span><span class="s1">/* isTuple */ false,</span><span class="s2">\n          </span><span class="s1">refExpressionErrors,</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">case tt.braceBarL:</span><span class="s2">\n      </span><span class="s1">case tt.braceHashL: {</span><span class="s2">\n        </span><span class="s1">return this.parseObjectLike(</span><span class="s2">\n          </span><span class="s1">this.state.type === tt.braceBarL ? tt.braceBarR : tt.braceR,</span><span class="s2">\n          </span><span class="s1">/* isPattern */ false,</span><span class="s2">\n          </span><span class="s1">/* isRecord */ true,</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">case tt.braceL: {</span><span class="s2">\n        </span><span class="s1">return this.parseObjectLike(</span><span class="s2">\n          </span><span class="s1">tt.braceR,</span><span class="s2">\n          </span><span class="s1">/* isPattern */ false,</span><span class="s2">\n          </span><span class="s1">/* isRecord */ false,</span><span class="s2">\n          </span><span class="s1">refExpressionErrors,</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">case tt._function:</span><span class="s2">\n        </span><span class="s1">return this.parseFunctionOrFunctionSent();</span><span class="s2">\n\n      </span><span class="s1">case tt.at:</span><span class="s2">\n        </span><span class="s1">decorators = this.parseDecorators();</span><span class="s2">\n      </span><span class="s1">// fall through</span><span class="s2">\n      </span><span class="s1">case tt._class:</span><span class="s2">\n        </span><span class="s1">return this.parseClass(</span><span class="s2">\n          </span><span class="s1">this.maybeTakeDecorators(decorators, this.startNode()),</span><span class="s2">\n          </span><span class="s1">false,</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n\n      </span><span class="s1">case tt._new:</span><span class="s2">\n        </span><span class="s1">return this.parseNewOrNewTarget();</span><span class="s2">\n\n      </span><span class="s1">case tt.templateNonTail:</span><span class="s2">\n      </span><span class="s1">case tt.templateTail:</span><span class="s2">\n        </span><span class="s1">return this.parseTemplate(false);</span><span class="s2">\n\n      </span><span class="s1">// BindExpression[Yield]</span><span class="s2">\n      </span><span class="s1">//   :: MemberExpression[?Yield]</span><span class="s2">\n      </span><span class="s1">case tt.doubleColon: {</span><span class="s2">\n        </span><span class="s1">node = this.startNode();</span><span class="s2">\n        </span><span class="s1">this.next();</span><span class="s2">\n        </span><span class="s1">node.object = null;</span><span class="s2">\n        </span><span class="s1">const callee = (node.callee = this.parseNoCallExpr());</span><span class="s2">\n        </span><span class="s1">if (callee.type === </span><span class="s2">\&quot;</span><span class="s1">MemberExpression</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">BindExpression</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">throw this.raise(Errors.UnsupportedBind, { at: callee });</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">case tt.privateName: {</span><span class="s2">\n        </span><span class="s1">// Standalone private names are only allowed in </span><span class="s2">\&quot;</span><span class="s1">#x in obj</span><span class="s2">\&quot;\n        </span><span class="s1">// expressions, and they are directly handled by callers of</span><span class="s2">\n        </span><span class="s1">// parseExprOp. If we reach this, the input is always invalid.</span><span class="s2">\n        </span><span class="s1">// We can throw a better error message and recover, rather than</span><span class="s2">\n        </span><span class="s1">// just throwing </span><span class="s2">\&quot;</span><span class="s1">Unexpected token</span><span class="s2">\&quot; </span><span class="s1">(which is the default</span><span class="s2">\n        </span><span class="s1">// behavior of this big switch statement).</span><span class="s2">\n        </span><span class="s1">this.raise(Errors.PrivateInExpectedIn, {</span><span class="s2">\n          </span><span class="s1">at: this.state.startLoc,</span><span class="s2">\n          </span><span class="s1">identifierName: this.state.value,</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">return this.parsePrivateName();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">case tt.moduloAssign: {</span><span class="s2">\n        </span><span class="s1">return this.parseTopicReferenceThenEqualsSign(tt.modulo, </span><span class="s2">\&quot;</span><span class="s1">%</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">case tt.xorAssign: {</span><span class="s2">\n        </span><span class="s1">return this.parseTopicReferenceThenEqualsSign(tt.bitwiseXOR, </span><span class="s2">\&quot;</span><span class="s1">^</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">case tt.doubleCaret:</span><span class="s2">\n      </span><span class="s1">case tt.doubleAt: {</span><span class="s2">\n        </span><span class="s1">return this.parseTopicReference(</span><span class="s2">\&quot;</span><span class="s1">hack</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">case tt.bitwiseXOR:</span><span class="s2">\n      </span><span class="s1">case tt.modulo:</span><span class="s2">\n      </span><span class="s1">case tt.hash: {</span><span class="s2">\n        </span><span class="s1">const pipeProposal = this.getPluginOption(</span><span class="s2">\n          \&quot;</span><span class="s1">pipelineOperator</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n          \&quot;</span><span class="s1">proposal</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n\n        </span><span class="s1">if (pipeProposal) {</span><span class="s2">\n          </span><span class="s1">return this.parseTopicReference(pipeProposal);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">this.unexpected();</span><span class="s2">\n        </span><span class="s1">break;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">case tt.lt: {</span><span class="s2">\n        </span><span class="s1">const lookaheadCh = this.input.codePointAt(this.nextTokenStart());</span><span class="s2">\n        </span><span class="s1">if (</span><span class="s2">\n          </span><span class="s1">isIdentifierStart(lookaheadCh) || // Element/Type Parameter &lt;foo&gt;</span><span class="s2">\n          </span><span class="s1">lookaheadCh === charCodes.greaterThan // Fragment &lt;&gt;</span><span class="s2">\n        </span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">this.expectOnePlugin([</span><span class="s2">\&quot;</span><span class="s1">jsx</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">flow</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">typescript</span><span class="s2">\&quot;</span><span class="s1">]);</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">this.unexpected();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">break;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">default:</span><span class="s2">\n        </span><span class="s1">if (tokenIsIdentifier(type)) {</span><span class="s2">\n          </span><span class="s1">if (</span><span class="s2">\n            </span><span class="s1">this.isContextual(tt._module) &amp;&amp;</span><span class="s2">\n            </span><span class="s1">this.lookaheadInLineCharCode() === charCodes.leftCurlyBrace</span><span class="s2">\n          </span><span class="s1">) {</span><span class="s2">\n            </span><span class="s1">return this.parseModuleExpression();</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">const canBeArrow = this.state.potentialArrowAt === this.state.start;</span><span class="s2">\n          </span><span class="s1">const containsEsc = this.state.containsEsc;</span><span class="s2">\n          </span><span class="s1">const id = this.parseIdentifier();</span><span class="s2">\n\n          </span><span class="s1">if (</span><span class="s2">\n            </span><span class="s1">!containsEsc &amp;&amp;</span><span class="s2">\n            </span><span class="s1">id.name === </span><span class="s2">\&quot;</span><span class="s1">async</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n            </span><span class="s1">!this.canInsertSemicolon()</span><span class="s2">\n          </span><span class="s1">) {</span><span class="s2">\n            </span><span class="s1">const { type } = this.state;</span><span class="s2">\n            </span><span class="s1">if (type === tt._function) {</span><span class="s2">\n              </span><span class="s1">this.resetPreviousNodeTrailingComments(id);</span><span class="s2">\n              </span><span class="s1">this.next();</span><span class="s2">\n              </span><span class="s1">return this.parseAsyncFunctionExpression(</span><span class="s2">\n                </span><span class="s1">this.startNodeAtNode(id),</span><span class="s2">\n              </span><span class="s1">);</span><span class="s2">\n            </span><span class="s1">} else if (tokenIsIdentifier(type)) {</span><span class="s2">\n              </span><span class="s1">// If the next token begins with </span><span class="s2">\&quot;</span><span class="s1">=</span><span class="s2">\&quot;</span><span class="s1">, commit to parsing an async</span><span class="s2">\n              </span><span class="s1">// arrow function. (Peeking ahead for </span><span class="s2">\&quot;</span><span class="s1">=</span><span class="s2">\&quot; </span><span class="s1">lets us avoid a more</span><span class="s2">\n              </span><span class="s1">// expensive full-token lookahead on this common path.)</span><span class="s2">\n              </span><span class="s1">if (this.lookaheadCharCode() === charCodes.equalsTo) {</span><span class="s2">\n                </span><span class="s1">// although `id` is not used in async arrow unary function,</span><span class="s2">\n                </span><span class="s1">// we don't need to reset `async`'s trailing comments because</span><span class="s2">\n                </span><span class="s1">// it will be attached to the upcoming async arrow binding identifier</span><span class="s2">\n                </span><span class="s1">return this.parseAsyncArrowUnaryFunction(</span><span class="s2">\n                  </span><span class="s1">this.startNodeAtNode(id),</span><span class="s2">\n                </span><span class="s1">);</span><span class="s2">\n              </span><span class="s1">} else {</span><span class="s2">\n                </span><span class="s1">// Otherwise, treat </span><span class="s2">\&quot;</span><span class="s1">async</span><span class="s2">\&quot; </span><span class="s1">as an identifier and let calling code</span><span class="s2">\n                </span><span class="s1">// deal with the current tt.name token.</span><span class="s2">\n                </span><span class="s1">return id;</span><span class="s2">\n              </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">} else if (type === tt._do) {</span><span class="s2">\n              </span><span class="s1">this.resetPreviousNodeTrailingComments(id);</span><span class="s2">\n              </span><span class="s1">return this.parseDo(this.startNodeAtNode(id), true);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n\n          </span><span class="s1">if (</span><span class="s2">\n            </span><span class="s1">canBeArrow &amp;&amp;</span><span class="s2">\n            </span><span class="s1">this.match(tt.arrow) &amp;&amp;</span><span class="s2">\n            </span><span class="s1">!this.canInsertSemicolon()</span><span class="s2">\n          </span><span class="s1">) {</span><span class="s2">\n            </span><span class="s1">this.next();</span><span class="s2">\n            </span><span class="s1">return this.parseArrowExpression(</span><span class="s2">\n              </span><span class="s1">this.startNodeAtNode(id),</span><span class="s2">\n              </span><span class="s1">[id],</span><span class="s2">\n              </span><span class="s1">false,</span><span class="s2">\n            </span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n\n          </span><span class="s1">return id;</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">this.unexpected();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// This helper method should only be called</span><span class="s2">\n  </span><span class="s1">// when the parser has reached a potential Hack pipe topic token</span><span class="s2">\n  </span><span class="s1">// that is followed by an equals sign.</span><span class="s2">\n  </span><span class="s1">// See &lt;https://github.com/js-choi/proposal-hack-pipes&gt;.</span><span class="s2">\n  </span><span class="s1">// If we find ^= or %= in an expression position</span><span class="s2">\n  </span><span class="s1">// (i.e., the tt.moduloAssign or tt.xorAssign token types), and if the</span><span class="s2">\n  </span><span class="s1">// Hack-pipes proposal is active with ^ or % as its topicToken, then the ^ or</span><span class="s2">\n  </span><span class="s1">// % could be the topic token (e.g., in x |&gt; ^==y or x |&gt; ^===y), and so we</span><span class="s2">\n  </span><span class="s1">// reparse the current token as ^ or %.</span><span class="s2">\n  </span><span class="s1">// Otherwise, this throws an unexpected-token error.</span><span class="s2">\n  </span><span class="s1">parseTopicReferenceThenEqualsSign(</span><span class="s2">\n    </span><span class="s1">topicTokenType: TokenType,</span><span class="s2">\n    </span><span class="s1">topicTokenValue: string,</span><span class="s2">\n  </span><span class="s1">): N.Expression {</span><span class="s2">\n    </span><span class="s1">const pipeProposal = this.getPluginOption(</span><span class="s2">\&quot;</span><span class="s1">pipelineOperator</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">proposal</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n\n    </span><span class="s1">if (pipeProposal) {</span><span class="s2">\n      </span><span class="s1">// Set the most-recent token to be a topic token</span><span class="s2">\n      </span><span class="s1">// given by the tokenType and tokenValue.</span><span class="s2">\n      </span><span class="s1">// Now the next readToken() call (in parseTopicReference)</span><span class="s2">\n      </span><span class="s1">// will consume that “topic token”.</span><span class="s2">\n      </span><span class="s1">this.state.type = topicTokenType;</span><span class="s2">\n      </span><span class="s1">this.state.value = topicTokenValue;</span><span class="s2">\n      </span><span class="s1">// Rewind the tokenizer to the end of the “topic token”, so that the</span><span class="s2">\n      </span><span class="s1">// following token starts at the equals sign after that topic token.</span><span class="s2">\n      </span><span class="s1">this.state.pos--;</span><span class="s2">\n      </span><span class="s1">this.state.end--;</span><span class="s2">\n      </span><span class="s1">// This is safe to do since the preceding character was either ^ or %, and</span><span class="s2">\n      </span><span class="s1">// thus not a newline.</span><span class="s2">\n      </span><span class="s1">this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1);</span><span class="s2">\n      </span><span class="s1">// Now actually consume the topic token.</span><span class="s2">\n      </span><span class="s1">return this.parseTopicReference(pipeProposal);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">this.unexpected();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// This helper method should only be called</span><span class="s2">\n  </span><span class="s1">// when the proposal-pipeline-operator plugin is active,</span><span class="s2">\n  </span><span class="s1">// and when the parser has reached a potential Hack pipe topic token.</span><span class="s2">\n  </span><span class="s1">// Although a pipe-operator proposal is assumed to be active,</span><span class="s2">\n  </span><span class="s1">// its configuration might not match the current token’s type.</span><span class="s2">\n  </span><span class="s1">// See &lt;https://github.com/js-choi/proposal-hack-pipes&gt;.</span><span class="s2">\n  </span><span class="s1">parseTopicReference(pipeProposal: string): N.Expression {</span><span class="s2">\n    </span><span class="s1">const node = this.startNode&lt;N.TopicReference&gt;();</span><span class="s2">\n    </span><span class="s1">const startLoc = this.state.startLoc;</span><span class="s2">\n    </span><span class="s1">const tokenType = this.state.type;</span><span class="s2">\n\n    </span><span class="s1">// Consume the current token.</span><span class="s2">\n    </span><span class="s1">this.next();</span><span class="s2">\n\n    </span><span class="s1">// If the pipe-operator plugin’s configuration matches the current token’s type,</span><span class="s2">\n    </span><span class="s1">// then this will return `node`, will have been finished as a topic reference.</span><span class="s2">\n    </span><span class="s1">// Otherwise, this will throw a `PipeTopicUnconfiguredToken` error.</span><span class="s2">\n    </span><span class="s1">return this.finishTopicReference(node, startLoc, pipeProposal, tokenType);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// This helper method attempts to finish the given `node`</span><span class="s2">\n  </span><span class="s1">// into a topic-reference node for the given `pipeProposal`.</span><span class="s2">\n  </span><span class="s1">// See &lt;https://github.com/js-choi/proposal-hack-pipes&gt;.</span><span class="s2">\n  </span><span class="s1">//</span><span class="s2">\n  </span><span class="s1">// The method assumes that any topic token was consumed before it was called.</span><span class="s2">\n  </span><span class="s1">//</span><span class="s2">\n  </span><span class="s1">// If the `pipelineOperator` plugin is active,</span><span class="s2">\n  </span><span class="s1">// and if the given `tokenType` matches the plugin’s configuration,</span><span class="s2">\n  </span><span class="s1">// then this method will return the finished `node`.</span><span class="s2">\n  </span><span class="s1">//</span><span class="s2">\n  </span><span class="s1">// If the `pipelineOperator` plugin is active,</span><span class="s2">\n  </span><span class="s1">// but if the given `tokenType` does not match the plugin’s configuration,</span><span class="s2">\n  </span><span class="s1">// then this method will throw a `PipeTopicUnconfiguredToken` error.</span><span class="s2">\n  </span><span class="s1">finishTopicReference(</span><span class="s2">\n    </span><span class="s1">node: Undone&lt;N.Node&gt;,</span><span class="s2">\n    </span><span class="s1">startLoc: Position,</span><span class="s2">\n    </span><span class="s1">pipeProposal: string,</span><span class="s2">\n    </span><span class="s1">tokenType: TokenType,</span><span class="s2">\n  </span><span class="s1">): N.Expression {</span><span class="s2">\n    </span><span class="s1">if (</span><span class="s2">\n      </span><span class="s1">this.testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType)</span><span class="s2">\n    </span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">// The token matches the plugin’s configuration.</span><span class="s2">\n      </span><span class="s1">// The token is therefore a topic reference.</span><span class="s2">\n\n      </span><span class="s1">// Determine the node type for the topic reference</span><span class="s2">\n      </span><span class="s1">// that is appropriate for the active pipe-operator proposal.</span><span class="s2">\n      </span><span class="s1">const nodeType =</span><span class="s2">\n        </span><span class="s1">pipeProposal === </span><span class="s2">\&quot;</span><span class="s1">smart</span><span class="s2">\&quot;\n          </span><span class="s1">? </span><span class="s2">\&quot;</span><span class="s1">PipelinePrimaryTopicReference</span><span class="s2">\&quot;\n          </span><span class="s1">: // The proposal must otherwise be </span><span class="s2">\&quot;</span><span class="s1">hack</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n            </span><span class="s1">// as enforced by testTopicReferenceConfiguration.</span><span class="s2">\n            \&quot;</span><span class="s1">TopicReference</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n      </span><span class="s1">if (!this.topicReferenceIsAllowedInCurrentContext()) {</span><span class="s2">\n        </span><span class="s1">this.raise(</span><span class="s2">\n          </span><span class="s1">// The topic reference is not allowed in the current context:</span><span class="s2">\n          </span><span class="s1">// it is outside of a pipe body.</span><span class="s2">\n          </span><span class="s1">// Raise recoverable errors.</span><span class="s2">\n          </span><span class="s1">pipeProposal === </span><span class="s2">\&quot;</span><span class="s1">smart</span><span class="s2">\&quot;\n            </span><span class="s1">? Errors.PrimaryTopicNotAllowed</span><span class="s2">\n            </span><span class="s1">: // In this case, `pipeProposal === </span><span class="s2">\&quot;</span><span class="s1">hack</span><span class="s2">\&quot;</span><span class="s1">` is true.</span><span class="s2">\n              </span><span class="s1">Errors.PipeTopicUnbound,</span><span class="s2">\n          </span><span class="s1">{ at: startLoc },</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">// Register the topic reference so that its pipe body knows</span><span class="s2">\n      </span><span class="s1">// that its topic was used at least once.</span><span class="s2">\n      </span><span class="s1">this.registerTopicReference();</span><span class="s2">\n\n      </span><span class="s1">return this.finishNode(node, nodeType);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">// The token does not match the plugin’s configuration.</span><span class="s2">\n      </span><span class="s1">throw this.raise(Errors.PipeTopicUnconfiguredToken, {</span><span class="s2">\n        </span><span class="s1">at: startLoc,</span><span class="s2">\n        </span><span class="s1">token: tokenLabelName(tokenType),</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// This helper method tests whether the given token type</span><span class="s2">\n  </span><span class="s1">// matches the pipelineOperator parser plugin’s configuration.</span><span class="s2">\n  </span><span class="s1">// If the active pipe proposal is Hack style,</span><span class="s2">\n  </span><span class="s1">// and if the given token is the same as the plugin configuration’s `topicToken`,</span><span class="s2">\n  </span><span class="s1">// then this is a valid topic reference.</span><span class="s2">\n  </span><span class="s1">// If the active pipe proposal is smart mix,</span><span class="s2">\n  </span><span class="s1">// then the topic token must always be `#`.</span><span class="s2">\n  </span><span class="s1">// If the active pipe proposal is neither (e.g., </span><span class="s2">\&quot;</span><span class="s1">minimal</span><span class="s2">\&quot; </span><span class="s1">or </span><span class="s2">\&quot;</span><span class="s1">fsharp</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n  </span><span class="s1">// then an error is thrown.</span><span class="s2">\n  </span><span class="s1">testTopicReferenceConfiguration(</span><span class="s2">\n    </span><span class="s1">pipeProposal: string,</span><span class="s2">\n    </span><span class="s1">startLoc: Position,</span><span class="s2">\n    </span><span class="s1">tokenType: TokenType,</span><span class="s2">\n  </span><span class="s1">): boolean {</span><span class="s2">\n    </span><span class="s1">switch (pipeProposal) {</span><span class="s2">\n      </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">hack</span><span class="s2">\&quot;</span><span class="s1">: {</span><span class="s2">\n        </span><span class="s1">return this.hasPlugin([</span><span class="s2">\n          \&quot;</span><span class="s1">pipelineOperator</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n          </span><span class="s1">{</span><span class="s2">\n            </span><span class="s1">// @ts-expect-error token must have a label</span><span class="s2">\n            </span><span class="s1">topicToken: tokenLabelName(tokenType),</span><span class="s2">\n          </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">]);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">smart</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n        </span><span class="s1">return tokenType === tt.hash;</span><span class="s2">\n      </span><span class="s1">default:</span><span class="s2">\n        </span><span class="s1">throw this.raise(Errors.PipeTopicRequiresHackPipes, { at: startLoc });</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// async [no LineTerminator here] AsyncArrowBindingIdentifier[?Yield] [no LineTerminator here] =&gt; AsyncConciseBody[?In]</span><span class="s2">\n  </span><span class="s1">parseAsyncArrowUnaryFunction(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">node: Undone&lt;N.ArrowFunctionExpression&gt;,</span><span class="s2">\n  </span><span class="s1">): N.ArrowFunctionExpression {</span><span class="s2">\n    </span><span class="s1">// We don't need to push a new ParameterDeclarationScope here since we are sure</span><span class="s2">\n    </span><span class="s1">// 1) it is an async arrow, 2) no biding pattern is allowed in params</span><span class="s2">\n    </span><span class="s1">this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));</span><span class="s2">\n    </span><span class="s1">const params = [this.parseIdentifier()];</span><span class="s2">\n    </span><span class="s1">this.prodParam.exit();</span><span class="s2">\n    </span><span class="s1">if (this.hasPrecedingLineBreak()) {</span><span class="s2">\n      </span><span class="s1">this.raise(Errors.LineTerminatorBeforeArrow, {</span><span class="s2">\n        </span><span class="s1">at: this.state.curPosition(),</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">this.expect(tt.arrow);</span><span class="s2">\n    </span><span class="s1">// let foo = async bar =&gt; {};</span><span class="s2">\n    </span><span class="s1">return this.parseArrowExpression(node, params, true);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// https://github.com/tc39/proposal-do-expressions</span><span class="s2">\n  </span><span class="s1">// https://github.com/tc39/proposal-async-do-expressions</span><span class="s2">\n  </span><span class="s1">parseDo(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">node: Undone&lt;N.DoExpression&gt;,</span><span class="s2">\n    </span><span class="s1">isAsync: boolean,</span><span class="s2">\n  </span><span class="s1">): N.DoExpression {</span><span class="s2">\n    </span><span class="s1">this.expectPlugin(</span><span class="s2">\&quot;</span><span class="s1">doExpressions</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">if (isAsync) {</span><span class="s2">\n      </span><span class="s1">this.expectPlugin(</span><span class="s2">\&quot;</span><span class="s1">asyncDoExpressions</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">node.async = isAsync;</span><span class="s2">\n    </span><span class="s1">this.next(); // eat `do`</span><span class="s2">\n    </span><span class="s1">const oldLabels = this.state.labels;</span><span class="s2">\n    </span><span class="s1">this.state.labels = [];</span><span class="s2">\n    </span><span class="s1">if (isAsync) {</span><span class="s2">\n      </span><span class="s1">// AsyncDoExpression :</span><span class="s2">\n      </span><span class="s1">// async [no LineTerminator here] do Block[~Yield, +Await, ~Return]</span><span class="s2">\n      </span><span class="s1">this.prodParam.enter(PARAM_AWAIT);</span><span class="s2">\n      </span><span class="s1">node.body = this.parseBlock();</span><span class="s2">\n      </span><span class="s1">this.prodParam.exit();</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">node.body = this.parseBlock();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">this.state.labels = oldLabels;</span><span class="s2">\n    </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">DoExpression</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Parse the `super` keyword</span><span class="s2">\n  </span><span class="s1">parseSuper(): N.Super {</span><span class="s2">\n    </span><span class="s1">const node = this.startNode&lt;N.Super&gt;();</span><span class="s2">\n    </span><span class="s1">this.next(); // eat `super`</span><span class="s2">\n    </span><span class="s1">if (</span><span class="s2">\n      </span><span class="s1">this.match(tt.parenL) &amp;&amp;</span><span class="s2">\n      </span><span class="s1">!this.scope.allowDirectSuper &amp;&amp;</span><span class="s2">\n      </span><span class="s1">!this.options.allowSuperOutsideMethod</span><span class="s2">\n    </span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">this.raise(Errors.SuperNotAllowed, { at: node });</span><span class="s2">\n    </span><span class="s1">} else if (</span><span class="s2">\n      </span><span class="s1">!this.scope.allowSuper &amp;&amp;</span><span class="s2">\n      </span><span class="s1">!this.options.allowSuperOutsideMethod</span><span class="s2">\n    </span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">this.raise(Errors.UnexpectedSuper, { at: node });</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">if (</span><span class="s2">\n      </span><span class="s1">!this.match(tt.parenL) &amp;&amp;</span><span class="s2">\n      </span><span class="s1">!this.match(tt.bracketL) &amp;&amp;</span><span class="s2">\n      </span><span class="s1">!this.match(tt.dot)</span><span class="s2">\n    </span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">this.raise(Errors.UnsupportedSuper, { at: node });</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">Super</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">parsePrivateName(): N.PrivateName {</span><span class="s2">\n    </span><span class="s1">const node = this.startNode&lt;N.PrivateName&gt;();</span><span class="s2">\n    </span><span class="s1">const id = this.startNodeAt&lt;N.Identifier&gt;(</span><span class="s2">\n      </span><span class="s1">// The position is hardcoded because we merge `#` and name into a single</span><span class="s2">\n      </span><span class="s1">// tt.privateName token</span><span class="s2">\n      </span><span class="s1">createPositionWithColumnOffset(this.state.startLoc, 1),</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">const name = this.state.value;</span><span class="s2">\n    </span><span class="s1">this.next(); // eat #name;</span><span class="s2">\n    </span><span class="s1">node.id = this.createIdentifier(id, name);</span><span class="s2">\n    </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">PrivateName</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">parseFunctionOrFunctionSent(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n  </span><span class="s1">): N.FunctionExpression | N.MetaProperty {</span><span class="s2">\n    </span><span class="s1">const node = this.startNode&lt;N.FunctionExpression | N.MetaProperty&gt;();</span><span class="s2">\n\n    </span><span class="s1">// We do not do parseIdentifier here because when parseFunctionOrFunctionSent</span><span class="s2">\n    </span><span class="s1">// is called we already know that the current token is a </span><span class="s2">\&quot;</span><span class="s1">name</span><span class="s2">\&quot; </span><span class="s1">with the value </span><span class="s2">\&quot;</span><span class="s1">function</span><span class="s2">\&quot;\n    </span><span class="s1">// This will improve perf a tiny little bit as we do not do validation but more importantly</span><span class="s2">\n    </span><span class="s1">// here is that parseIdentifier will remove an item from the expression stack</span><span class="s2">\n    </span><span class="s1">// if </span><span class="s2">\&quot;</span><span class="s1">function</span><span class="s2">\&quot; </span><span class="s1">or </span><span class="s2">\&quot;</span><span class="s1">class</span><span class="s2">\&quot; </span><span class="s1">is parsed as identifier (in objects e.g.), which should not happen here.</span><span class="s2">\n    </span><span class="s1">this.next(); // eat `function`</span><span class="s2">\n\n    </span><span class="s1">if (this.prodParam.hasYield &amp;&amp; this.match(tt.dot)) {</span><span class="s2">\n      </span><span class="s1">const meta = this.createIdentifier(</span><span class="s2">\n        </span><span class="s1">this.startNodeAtNode&lt;N.Identifier&gt;(node),</span><span class="s2">\n        \&quot;</span><span class="s1">function</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">this.next(); // eat `.`</span><span class="s2">\n      </span><span class="s1">// https://github.com/tc39/proposal-function.sent#syntax-1</span><span class="s2">\n      </span><span class="s1">if (this.match(tt._sent)) {</span><span class="s2">\n        </span><span class="s1">this.expectPlugin(</span><span class="s2">\&quot;</span><span class="s1">functionSent</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">} else if (!this.hasPlugin(</span><span class="s2">\&quot;</span><span class="s1">functionSent</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n        </span><span class="s1">// The code wasn't `function.sent` but just `function.`, so a simple error is less confusing.</span><span class="s2">\n        </span><span class="s1">this.unexpected();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return this.parseMetaProperty(</span><span class="s2">\n        </span><span class="s1">node as Undone&lt;N.MetaProperty&gt;,</span><span class="s2">\n        </span><span class="s1">meta,</span><span class="s2">\n        \&quot;</span><span class="s1">sent</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return this.parseFunction(node as Undone&lt;N.FunctionExpression&gt;);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">parseMetaProperty(</span><span class="s2">\n    </span><span class="s1">node: Undone&lt;N.MetaProperty&gt;,</span><span class="s2">\n    </span><span class="s1">meta: N.Identifier,</span><span class="s2">\n    </span><span class="s1">propertyName: string,</span><span class="s2">\n  </span><span class="s1">): N.MetaProperty {</span><span class="s2">\n    </span><span class="s1">node.meta = meta;</span><span class="s2">\n\n    </span><span class="s1">const containsEsc = this.state.containsEsc;</span><span class="s2">\n\n    </span><span class="s1">node.property = this.parseIdentifier(true);</span><span class="s2">\n\n    </span><span class="s1">if (node.property.name !== propertyName || containsEsc) {</span><span class="s2">\n      </span><span class="s1">this.raise(Errors.UnsupportedMetaProperty, {</span><span class="s2">\n        </span><span class="s1">at: node.property,</span><span class="s2">\n        </span><span class="s1">target: meta.name,</span><span class="s2">\n        </span><span class="s1">onlyValidPropertyName: propertyName,</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">MetaProperty</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// https://tc39.es/ecma262/#prod-ImportMeta</span><span class="s2">\n  </span><span class="s1">parseImportMetaProperty(node: Undone&lt;N.MetaProperty&gt;): N.MetaProperty {</span><span class="s2">\n    </span><span class="s1">const id = this.createIdentifier(</span><span class="s2">\n      </span><span class="s1">this.startNodeAtNode&lt;N.Identifier&gt;(node),</span><span class="s2">\n      \&quot;</span><span class="s1">import</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">this.next(); // eat `.`</span><span class="s2">\n\n    </span><span class="s1">if (this.isContextual(tt._meta)) {</span><span class="s2">\n      </span><span class="s1">if (!this.inModule) {</span><span class="s2">\n        </span><span class="s1">this.raise(Errors.ImportMetaOutsideModule, { at: id });</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">this.sawUnambiguousESM = true;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">return this.parseMetaProperty(node, id, </span><span class="s2">\&quot;</span><span class="s1">meta</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">parseLiteralAtNode&lt;T extends N.Node&gt;(</span><span class="s2">\n    </span><span class="s1">value: any,</span><span class="s2">\n    </span><span class="s1">type: T[</span><span class="s2">\&quot;</span><span class="s1">type</span><span class="s2">\&quot;</span><span class="s1">],</span><span class="s2">\n    </span><span class="s1">node: any,</span><span class="s2">\n  </span><span class="s1">): T {</span><span class="s2">\n    </span><span class="s1">this.addExtra(node, </span><span class="s2">\&quot;</span><span class="s1">rawValue</span><span class="s2">\&quot;</span><span class="s1">, value);</span><span class="s2">\n    </span><span class="s1">this.addExtra(node, </span><span class="s2">\&quot;</span><span class="s1">raw</span><span class="s2">\&quot;</span><span class="s1">, this.input.slice(node.start, this.state.end));</span><span class="s2">\n    </span><span class="s1">node.value = value;</span><span class="s2">\n    </span><span class="s1">this.next();</span><span class="s2">\n    </span><span class="s1">return this.finishNode&lt;T&gt;(node, type);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">parseLiteral&lt;T extends N.Node&gt;(value: any, type: T[</span><span class="s2">\&quot;</span><span class="s1">type</span><span class="s2">\&quot;</span><span class="s1">]): T {</span><span class="s2">\n    </span><span class="s1">const node = this.startNode();</span><span class="s2">\n    </span><span class="s1">return this.parseLiteralAtNode(value, type, node);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">parseStringLiteral(value: any) {</span><span class="s2">\n    </span><span class="s1">return this.parseLiteral&lt;N.StringLiteral&gt;(value, </span><span class="s2">\&quot;</span><span class="s1">StringLiteral</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">parseNumericLiteral(value: any) {</span><span class="s2">\n    </span><span class="s1">return this.parseLiteral&lt;N.NumericLiteral&gt;(value, </span><span class="s2">\&quot;</span><span class="s1">NumericLiteral</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">parseBigIntLiteral(value: any) {</span><span class="s2">\n    </span><span class="s1">return this.parseLiteral&lt;N.BigIntLiteral&gt;(value, </span><span class="s2">\&quot;</span><span class="s1">BigIntLiteral</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">parseDecimalLiteral(value: any) {</span><span class="s2">\n    </span><span class="s1">return this.parseLiteral&lt;N.DecimalLiteral&gt;(value, </span><span class="s2">\&quot;</span><span class="s1">DecimalLiteral</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">parseRegExpLiteral(value: {</span><span class="s2">\n    </span><span class="s1">value: any;</span><span class="s2">\n    </span><span class="s1">pattern: string;</span><span class="s2">\n    </span><span class="s1">flags: N.RegExpLiteral[</span><span class="s2">\&quot;</span><span class="s1">flags</span><span class="s2">\&quot;</span><span class="s1">];</span><span class="s2">\n  </span><span class="s1">}) {</span><span class="s2">\n    </span><span class="s1">const node = this.parseLiteral&lt;N.RegExpLiteral&gt;(</span><span class="s2">\n      </span><span class="s1">value.value,</span><span class="s2">\n      \&quot;</span><span class="s1">RegExpLiteral</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">node.pattern = value.pattern;</span><span class="s2">\n    </span><span class="s1">node.flags = value.flags;</span><span class="s2">\n    </span><span class="s1">return node;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">parseBooleanLiteral(value: boolean) {</span><span class="s2">\n    </span><span class="s1">const node = this.startNode&lt;N.BooleanLiteral&gt;();</span><span class="s2">\n    </span><span class="s1">node.value = value;</span><span class="s2">\n    </span><span class="s1">this.next();</span><span class="s2">\n    </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">BooleanLiteral</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">parseNullLiteral() {</span><span class="s2">\n    </span><span class="s1">const node = this.startNode&lt;N.NullLiteral&gt;();</span><span class="s2">\n    </span><span class="s1">this.next();</span><span class="s2">\n    </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">NullLiteral</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// https://tc39.es/ecma262/#prod-CoverParenthesizedExpressionAndArrowParameterList</span><span class="s2">\n  </span><span class="s1">parseParenAndDistinguishExpression(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">canBeArrow: boolean,</span><span class="s2">\n  </span><span class="s1">): N.Expression {</span><span class="s2">\n    </span><span class="s1">const startLoc = this.state.startLoc;</span><span class="s2">\n\n    </span><span class="s1">let val;</span><span class="s2">\n    </span><span class="s1">this.next(); // eat `(`</span><span class="s2">\n    </span><span class="s1">this.expressionScope.enter(newArrowHeadScope());</span><span class="s2">\n\n    </span><span class="s1">const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;</span><span class="s2">\n    </span><span class="s1">const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;</span><span class="s2">\n    </span><span class="s1">this.state.maybeInArrowParameters = true;</span><span class="s2">\n    </span><span class="s1">this.state.inFSharpPipelineDirectBody = false;</span><span class="s2">\n\n    </span><span class="s1">const innerStartLoc = this.state.startLoc;</span><span class="s2">\n    </span><span class="s1">const exprList: N.Expression[] = [];</span><span class="s2">\n    </span><span class="s1">const refExpressionErrors = new ExpressionErrors();</span><span class="s2">\n    </span><span class="s1">let first = true;</span><span class="s2">\n    </span><span class="s1">let spreadStartLoc;</span><span class="s2">\n    </span><span class="s1">let optionalCommaStartLoc;</span><span class="s2">\n\n    </span><span class="s1">while (!this.match(tt.parenR)) {</span><span class="s2">\n      </span><span class="s1">if (first) {</span><span class="s2">\n        </span><span class="s1">first = false;</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">this.expect(</span><span class="s2">\n          </span><span class="s1">tt.comma,</span><span class="s2">\n          </span><span class="s1">refExpressionErrors.optionalParametersLoc === null</span><span class="s2">\n            </span><span class="s1">? null</span><span class="s2">\n            </span><span class="s1">: refExpressionErrors.optionalParametersLoc,</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">if (this.match(tt.parenR)) {</span><span class="s2">\n          </span><span class="s1">optionalCommaStartLoc = this.state.startLoc;</span><span class="s2">\n          </span><span class="s1">break;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">if (this.match(tt.ellipsis)) {</span><span class="s2">\n        </span><span class="s1">const spreadNodeStartLoc = this.state.startLoc;</span><span class="s2">\n        </span><span class="s1">spreadStartLoc = this.state.startLoc;</span><span class="s2">\n        </span><span class="s1">exprList.push(</span><span class="s2">\n          </span><span class="s1">this.parseParenItem(this.parseRestBinding(), spreadNodeStartLoc),</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n\n        </span><span class="s1">if (!this.checkCommaAfterRest(charCodes.rightParenthesis)) {</span><span class="s2">\n          </span><span class="s1">break;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">exprList.push(</span><span class="s2">\n          </span><span class="s1">this.parseMaybeAssignAllowIn(</span><span class="s2">\n            </span><span class="s1">refExpressionErrors,</span><span class="s2">\n            </span><span class="s1">this.parseParenItem,</span><span class="s2">\n          </span><span class="s1">),</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">const innerEndLoc = this.state.lastTokEndLoc;</span><span class="s2">\n    </span><span class="s1">this.expect(tt.parenR);</span><span class="s2">\n\n    </span><span class="s1">this.state.maybeInArrowParameters = oldMaybeInArrowParameters;</span><span class="s2">\n    </span><span class="s1">this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;</span><span class="s2">\n\n    </span><span class="s1">let arrowNode = this.startNodeAt&lt;N.ArrowFunctionExpression&gt;(startLoc);</span><span class="s2">\n    </span><span class="s1">if (</span><span class="s2">\n      </span><span class="s1">canBeArrow &amp;&amp;</span><span class="s2">\n      </span><span class="s1">this.shouldParseArrow(exprList) &amp;&amp;</span><span class="s2">\n      </span><span class="s1">(arrowNode = this.parseArrow(arrowNode))</span><span class="s2">\n    </span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">this.checkDestructuringPrivate(refExpressionErrors);</span><span class="s2">\n      </span><span class="s1">this.expressionScope.validateAsPattern();</span><span class="s2">\n      </span><span class="s1">this.expressionScope.exit();</span><span class="s2">\n      </span><span class="s1">this.parseArrowExpression(arrowNode, exprList, false);</span><span class="s2">\n      </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts) improve node types</span><span class="s2">\n      </span><span class="s1">return arrowNode;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">this.expressionScope.exit();</span><span class="s2">\n\n    </span><span class="s1">if (!exprList.length) {</span><span class="s2">\n      </span><span class="s1">this.unexpected(this.state.lastTokStartLoc);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (optionalCommaStartLoc) this.unexpected(optionalCommaStartLoc);</span><span class="s2">\n    </span><span class="s1">if (spreadStartLoc) this.unexpected(spreadStartLoc);</span><span class="s2">\n    </span><span class="s1">this.checkExpressionErrors(refExpressionErrors, true);</span><span class="s2">\n\n    </span><span class="s1">this.toReferencedListDeep(exprList, /* isParenthesizedExpr */ true);</span><span class="s2">\n    </span><span class="s1">if (exprList.length &gt; 1) {</span><span class="s2">\n      </span><span class="s1">val = this.startNodeAt&lt;N.SequenceExpression&gt;(innerStartLoc);</span><span class="s2">\n      </span><span class="s1">val.expressions = exprList;</span><span class="s2">\n      </span><span class="s1">// finish node at current location so it can pick up comments after `)`</span><span class="s2">\n      </span><span class="s1">this.finishNode(val, </span><span class="s2">\&quot;</span><span class="s1">SequenceExpression</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">this.resetEndLocation(val, innerEndLoc);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">val = exprList[0];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">return this.wrapParenthesis(</span><span class="s2">\n      </span><span class="s1">startLoc,</span><span class="s2">\n      </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts)</span><span class="s2">\n      </span><span class="s1">val,</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">wrapParenthesis(startLoc: Position, expression: N.Expression): N.Expression {</span><span class="s2">\n    </span><span class="s1">if (!this.options.createParenthesizedExpressions) {</span><span class="s2">\n      </span><span class="s1">this.addExtra(expression, </span><span class="s2">\&quot;</span><span class="s1">parenthesized</span><span class="s2">\&quot;</span><span class="s1">, true);</span><span class="s2">\n      </span><span class="s1">this.addExtra(expression, </span><span class="s2">\&quot;</span><span class="s1">parenStart</span><span class="s2">\&quot;</span><span class="s1">, startLoc.index);</span><span class="s2">\n\n      </span><span class="s1">this.takeSurroundingComments(</span><span class="s2">\n        </span><span class="s1">expression,</span><span class="s2">\n        </span><span class="s1">startLoc.index,</span><span class="s2">\n        </span><span class="s1">this.state.lastTokEndLoc.index,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n\n      </span><span class="s1">return expression;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">const parenExpression =</span><span class="s2">\n      </span><span class="s1">this.startNodeAt&lt;N.ParenthesizedExpression&gt;(startLoc);</span><span class="s2">\n    </span><span class="s1">parenExpression.expression = expression;</span><span class="s2">\n    </span><span class="s1">return this.finishNode(parenExpression, </span><span class="s2">\&quot;</span><span class="s1">ParenthesizedExpression</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-unused-vars -- `params` is used in typescript plugin</span><span class="s2">\n  </span><span class="s1">shouldParseArrow(params: Array&lt;N.Node&gt;): boolean {</span><span class="s2">\n    </span><span class="s1">return !this.canInsertSemicolon();</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">parseArrow(</span><span class="s2">\n    </span><span class="s1">node: Undone&lt;N.ArrowFunctionExpression&gt;,</span><span class="s2">\n  </span><span class="s1">): Undone&lt;N.ArrowFunctionExpression&gt; | undefined {</span><span class="s2">\n    </span><span class="s1">if (this.eat(tt.arrow)) {</span><span class="s2">\n      </span><span class="s1">return node;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">parseParenItem(</span><span class="s2">\n    </span><span class="s1">node: N.Expression,</span><span class="s2">\n    </span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-unused-vars</span><span class="s2">\n    </span><span class="s1">startLoc: Position,</span><span class="s2">\n  </span><span class="s1">): N.Expression {</span><span class="s2">\n    </span><span class="s1">return node;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">parseNewOrNewTarget(this: Parser): N.NewExpression | N.MetaProperty {</span><span class="s2">\n    </span><span class="s1">const node = this.startNode&lt;N.NewExpression | N.MetaProperty&gt;();</span><span class="s2">\n    </span><span class="s1">this.next();</span><span class="s2">\n    </span><span class="s1">if (this.match(tt.dot)) {</span><span class="s2">\n      </span><span class="s1">// https://tc39.es/ecma262/#prod-NewTarget</span><span class="s2">\n      </span><span class="s1">const meta = this.createIdentifier(</span><span class="s2">\n        </span><span class="s1">this.startNodeAtNode&lt;N.Identifier&gt;(node),</span><span class="s2">\n        \&quot;</span><span class="s1">new</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">this.next();</span><span class="s2">\n      </span><span class="s1">const metaProp = this.parseMetaProperty(</span><span class="s2">\n        </span><span class="s1">node as Undone&lt;N.MetaProperty&gt;,</span><span class="s2">\n        </span><span class="s1">meta,</span><span class="s2">\n        \&quot;</span><span class="s1">target</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n\n      </span><span class="s1">if (</span><span class="s2">\n        </span><span class="s1">!this.scope.inNonArrowFunction &amp;&amp;</span><span class="s2">\n        </span><span class="s1">!this.scope.inClass &amp;&amp;</span><span class="s2">\n        </span><span class="s1">!this.options.allowNewTargetOutsideFunction</span><span class="s2">\n      </span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">this.raise(Errors.UnexpectedNewTarget, { at: metaProp });</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return metaProp;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">return this.parseNew(node as Undone&lt;N.NewExpression&gt;);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// New's precedence is slightly tricky. It must allow its argument to</span><span class="s2">\n  </span><span class="s1">// be a `[]` or dot subscript expression, but not a call — at least,</span><span class="s2">\n  </span><span class="s1">// not without wrapping it in parentheses. Thus, it uses the noCalls</span><span class="s2">\n  </span><span class="s1">// argument to parseSubscripts to prevent it from consuming the</span><span class="s2">\n  </span><span class="s1">// argument list.</span><span class="s2">\n  </span><span class="s1">// https://tc39.es/ecma262/#prod-NewExpression</span><span class="s2">\n  </span><span class="s1">parseNew(this: Parser, node: Undone&lt;N.NewExpression&gt;): N.NewExpression {</span><span class="s2">\n    </span><span class="s1">this.parseNewCallee(node);</span><span class="s2">\n\n    </span><span class="s1">if (this.eat(tt.parenL)) {</span><span class="s2">\n      </span><span class="s1">const args = this.parseExprList(tt.parenR);</span><span class="s2">\n      </span><span class="s1">this.toReferencedList(args);</span><span class="s2">\n      </span><span class="s1">// (parseExprList should be all non-null in this case)</span><span class="s2">\n      </span><span class="s1">node.arguments = args;</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">node.arguments = [];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">NewExpression</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">parseNewCallee(this: Parser, node: Undone&lt;N.NewExpression&gt;): void {</span><span class="s2">\n    </span><span class="s1">node.callee = this.parseNoCallExpr();</span><span class="s2">\n    </span><span class="s1">if (node.callee.type === </span><span class="s2">\&quot;</span><span class="s1">Import</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">this.raise(Errors.ImportCallNotNewExpression, { at: node.callee });</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Parse template expression.</span><span class="s2">\n\n  </span><span class="s1">parseTemplateElement(isTagged: boolean): N.TemplateElement {</span><span class="s2">\n    </span><span class="s1">const { start, startLoc, end, value } = this.state;</span><span class="s2">\n    </span><span class="s1">const elemStart = start + 1;</span><span class="s2">\n    </span><span class="s1">const elem = this.startNodeAt&lt;N.TemplateElement&gt;(</span><span class="s2">\n      </span><span class="s1">createPositionWithColumnOffset(startLoc, 1),</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">if (value === null) {</span><span class="s2">\n      </span><span class="s1">if (!isTagged) {</span><span class="s2">\n        </span><span class="s1">this.raise(Errors.InvalidEscapeSequenceTemplate, {</span><span class="s2">\n          </span><span class="s1">// FIXME: Adding 1 is probably wrong.</span><span class="s2">\n          </span><span class="s1">at: createPositionWithColumnOffset(</span><span class="s2">\n            </span><span class="s1">this.state.firstInvalidTemplateEscapePos,</span><span class="s2">\n            </span><span class="s1">1,</span><span class="s2">\n          </span><span class="s1">),</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">const isTail = this.match(tt.templateTail);</span><span class="s2">\n    </span><span class="s1">const endOffset = isTail ? -1 : -2;</span><span class="s2">\n    </span><span class="s1">const elemEnd = end + endOffset;</span><span class="s2">\n    </span><span class="s1">elem.value = {</span><span class="s2">\n      </span><span class="s1">raw: this.input.slice(elemStart, elemEnd).replace(/</span><span class="s2">\\</span><span class="s1">r</span><span class="s2">\\</span><span class="s1">n?/g, </span><span class="s2">\&quot;\\</span><span class="s1">n</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n      </span><span class="s1">cooked: value === null ? null : value.slice(1, endOffset),</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">elem.tail = isTail;</span><span class="s2">\n    </span><span class="s1">this.next();</span><span class="s2">\n    </span><span class="s1">const finishedNode = this.finishNode(elem, </span><span class="s2">\&quot;</span><span class="s1">TemplateElement</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">this.resetEndLocation(</span><span class="s2">\n      </span><span class="s1">finishedNode,</span><span class="s2">\n      </span><span class="s1">createPositionWithColumnOffset(this.state.lastTokEndLoc, endOffset),</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">return finishedNode;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// https://tc39.es/ecma262/#prod-TemplateLiteral</span><span class="s2">\n  </span><span class="s1">parseTemplate(this: Parser, isTagged: boolean): N.TemplateLiteral {</span><span class="s2">\n    </span><span class="s1">const node = this.startNode&lt;N.TemplateLiteral&gt;();</span><span class="s2">\n    </span><span class="s1">node.expressions = [];</span><span class="s2">\n    </span><span class="s1">let curElt = this.parseTemplateElement(isTagged);</span><span class="s2">\n    </span><span class="s1">node.quasis = [curElt];</span><span class="s2">\n    </span><span class="s1">while (!curElt.tail) {</span><span class="s2">\n      </span><span class="s1">node.expressions.push(this.parseTemplateSubstitution());</span><span class="s2">\n      </span><span class="s1">this.readTemplateContinuation();</span><span class="s2">\n      </span><span class="s1">node.quasis.push((curElt = this.parseTemplateElement(isTagged)));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">TemplateLiteral</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// This is overwritten by the TypeScript plugin to parse template types</span><span class="s2">\n  </span><span class="s1">parseTemplateSubstitution(this: Parser): N.Expression {</span><span class="s2">\n    </span><span class="s1">return this.parseExpression();</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Parse an object literal, binding pattern, or record.</span><span class="s2">\n\n  </span><span class="s1">parseObjectLike(</span><span class="s2">\n    </span><span class="s1">close: TokenType,</span><span class="s2">\n    </span><span class="s1">isPattern: true,</span><span class="s2">\n    </span><span class="s1">isRecord?: boolean | null,</span><span class="s2">\n    </span><span class="s1">refExpressionErrors?: ExpressionErrors | null,</span><span class="s2">\n  </span><span class="s1">): N.ObjectPattern;</span><span class="s2">\n  </span><span class="s1">parseObjectLike(</span><span class="s2">\n    </span><span class="s1">close: TokenType,</span><span class="s2">\n    </span><span class="s1">isPattern: false,</span><span class="s2">\n    </span><span class="s1">isRecord?: false | null,</span><span class="s2">\n    </span><span class="s1">refExpressionErrors?: ExpressionErrors | null,</span><span class="s2">\n  </span><span class="s1">): N.ObjectExpression;</span><span class="s2">\n  </span><span class="s1">parseObjectLike(</span><span class="s2">\n    </span><span class="s1">close: TokenType,</span><span class="s2">\n    </span><span class="s1">isPattern: false,</span><span class="s2">\n    </span><span class="s1">isRecord?: true,</span><span class="s2">\n    </span><span class="s1">refExpressionErrors?: ExpressionErrors | null,</span><span class="s2">\n  </span><span class="s1">): N.RecordExpression;</span><span class="s2">\n  </span><span class="s1">parseObjectLike&lt;T extends N.ObjectPattern | N.ObjectExpression&gt;(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">close: TokenType,</span><span class="s2">\n    </span><span class="s1">isPattern: boolean,</span><span class="s2">\n    </span><span class="s1">isRecord?: boolean | null,</span><span class="s2">\n    </span><span class="s1">refExpressionErrors?: ExpressionErrors | null,</span><span class="s2">\n  </span><span class="s1">): T {</span><span class="s2">\n    </span><span class="s1">if (isRecord) {</span><span class="s2">\n      </span><span class="s1">this.expectPlugin(</span><span class="s2">\&quot;</span><span class="s1">recordAndTuple</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;</span><span class="s2">\n    </span><span class="s1">this.state.inFSharpPipelineDirectBody = false;</span><span class="s2">\n    </span><span class="s1">const propHash: any = Object.create(null);</span><span class="s2">\n    </span><span class="s1">let first = true;</span><span class="s2">\n    </span><span class="s1">const node = this.startNode&lt;</span><span class="s2">\n      </span><span class="s1">N.ObjectExpression | N.ObjectPattern | N.RecordExpression</span><span class="s2">\n    </span><span class="s1">&gt;();</span><span class="s2">\n\n    </span><span class="s1">node.properties = [];</span><span class="s2">\n    </span><span class="s1">this.next();</span><span class="s2">\n\n    </span><span class="s1">while (!this.match(close)) {</span><span class="s2">\n      </span><span class="s1">if (first) {</span><span class="s2">\n        </span><span class="s1">first = false;</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">this.expect(tt.comma);</span><span class="s2">\n        </span><span class="s1">if (this.match(close)) {</span><span class="s2">\n          </span><span class="s1">this.addTrailingCommaExtraToNode(</span><span class="s2">\n            </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts) improve node types</span><span class="s2">\n            </span><span class="s1">node,</span><span class="s2">\n          </span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">break;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">let prop;</span><span class="s2">\n      </span><span class="s1">if (isPattern) {</span><span class="s2">\n        </span><span class="s1">prop = this.parseBindingProperty();</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">prop = this.parsePropertyDefinition(refExpressionErrors);</span><span class="s2">\n        </span><span class="s1">this.checkProto(prop, isRecord, propHash, refExpressionErrors);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">if (</span><span class="s2">\n        </span><span class="s1">isRecord &amp;&amp;</span><span class="s2">\n        </span><span class="s1">!this.isObjectProperty(prop) &amp;&amp;</span><span class="s2">\n        </span><span class="s1">prop.type !== </span><span class="s2">\&quot;</span><span class="s1">SpreadElement</span><span class="s2">\&quot;\n      </span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">this.raise(Errors.InvalidRecordProperty, { at: prop });</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">// @ts-expect-error shorthand may not index prop</span><span class="s2">\n      </span><span class="s1">if (prop.shorthand) {</span><span class="s2">\n        </span><span class="s1">this.addExtra(prop, </span><span class="s2">\&quot;</span><span class="s1">shorthand</span><span class="s2">\&quot;</span><span class="s1">, true);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">// @ts-expect-error Fixme: refine typings</span><span class="s2">\n      </span><span class="s1">node.properties.push(prop);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">this.next();</span><span class="s2">\n\n    </span><span class="s1">this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;</span><span class="s2">\n    </span><span class="s1">let type = </span><span class="s2">\&quot;</span><span class="s1">ObjectExpression</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">if (isPattern) {</span><span class="s2">\n      </span><span class="s1">type = </span><span class="s2">\&quot;</span><span class="s1">ObjectPattern</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">} else if (isRecord) {</span><span class="s2">\n      </span><span class="s1">type = </span><span class="s2">\&quot;</span><span class="s1">RecordExpression</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// @ts-expect-error type is well defined</span><span class="s2">\n    </span><span class="s1">return this.finishNode(node, type);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">addTrailingCommaExtraToNode(node: N.Node): void {</span><span class="s2">\n    </span><span class="s1">this.addExtra(node, </span><span class="s2">\&quot;</span><span class="s1">trailingComma</span><span class="s2">\&quot;</span><span class="s1">, this.state.lastTokStart);</span><span class="s2">\n    </span><span class="s1">this.addExtra(node, </span><span class="s2">\&quot;</span><span class="s1">trailingCommaLoc</span><span class="s2">\&quot;</span><span class="s1">, this.state.lastTokStartLoc, false);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Check grammar production:</span><span class="s2">\n  </span><span class="s1">//   IdentifierName *_opt PropertyName</span><span class="s2">\n  </span><span class="s1">// It is used in `parsePropertyDefinition` to detect AsyncMethod and Accessors</span><span class="s2">\n  </span><span class="s1">maybeAsyncOrAccessorProp(prop: Undone&lt;N.ObjectProperty&gt;): boolean {</span><span class="s2">\n    </span><span class="s1">return (</span><span class="s2">\n      </span><span class="s1">!prop.computed &amp;&amp;</span><span class="s2">\n      </span><span class="s1">prop.key.type === </span><span class="s2">\&quot;</span><span class="s1">Identifier</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n      </span><span class="s1">(this.isLiteralPropertyName() ||</span><span class="s2">\n        </span><span class="s1">this.match(tt.bracketL) ||</span><span class="s2">\n        </span><span class="s1">this.match(tt.star))</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// https://tc39.es/ecma262/#prod-PropertyDefinition</span><span class="s2">\n  </span><span class="s1">parsePropertyDefinition(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">refExpressionErrors?: ExpressionErrors | null,</span><span class="s2">\n  </span><span class="s1">): N.ObjectMember | N.SpreadElement {</span><span class="s2">\n    </span><span class="s1">let decorators = [];</span><span class="s2">\n    </span><span class="s1">if (this.match(tt.at)) {</span><span class="s2">\n      </span><span class="s1">if (this.hasPlugin(</span><span class="s2">\&quot;</span><span class="s1">decorators</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n        </span><span class="s1">this.raise(Errors.UnsupportedPropertyDecorator, {</span><span class="s2">\n          </span><span class="s1">at: this.state.startLoc,</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">// we needn't check if decorators (stage 0) plugin is enabled since it's checked by</span><span class="s2">\n      </span><span class="s1">// the call to this.parseDecorator</span><span class="s2">\n      </span><span class="s1">while (this.match(tt.at)) {</span><span class="s2">\n        </span><span class="s1">decorators.push(this.parseDecorator());</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">const prop = this.startNode&lt;N.ObjectProperty&gt;();</span><span class="s2">\n    </span><span class="s1">let isAsync = false;</span><span class="s2">\n    </span><span class="s1">let isAccessor = false;</span><span class="s2">\n    </span><span class="s1">let startLoc;</span><span class="s2">\n\n    </span><span class="s1">if (this.match(tt.ellipsis)) {</span><span class="s2">\n      </span><span class="s1">if (decorators.length) this.unexpected();</span><span class="s2">\n      </span><span class="s1">return this.parseSpread();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">if (decorators.length) {</span><span class="s2">\n      </span><span class="s1">prop.decorators = decorators;</span><span class="s2">\n      </span><span class="s1">decorators = [];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">prop.method = false;</span><span class="s2">\n\n    </span><span class="s1">if (refExpressionErrors) {</span><span class="s2">\n      </span><span class="s1">startLoc = this.state.startLoc;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">let isGenerator = this.eat(tt.star);</span><span class="s2">\n    </span><span class="s1">this.parsePropertyNamePrefixOperator(prop);</span><span class="s2">\n    </span><span class="s1">const containsEsc = this.state.containsEsc;</span><span class="s2">\n    </span><span class="s1">const key = this.parsePropertyName(prop, refExpressionErrors);</span><span class="s2">\n\n    </span><span class="s1">if (!isGenerator &amp;&amp; !containsEsc &amp;&amp; this.maybeAsyncOrAccessorProp(prop)) {</span><span class="s2">\n      </span><span class="s1">const keyName = key.name;</span><span class="s2">\n      </span><span class="s1">// https://tc39.es/ecma262/#prod-AsyncMethod</span><span class="s2">\n      </span><span class="s1">// https://tc39.es/ecma262/#prod-AsyncGeneratorMethod</span><span class="s2">\n      </span><span class="s1">if (keyName === </span><span class="s2">\&quot;</span><span class="s1">async</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; !this.hasPrecedingLineBreak()) {</span><span class="s2">\n        </span><span class="s1">isAsync = true;</span><span class="s2">\n        </span><span class="s1">this.resetPreviousNodeTrailingComments(key);</span><span class="s2">\n        </span><span class="s1">isGenerator = this.eat(tt.star);</span><span class="s2">\n        </span><span class="s1">this.parsePropertyName(prop);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">// get PropertyName[?Yield, ?Await] () { FunctionBody[~Yield, ~Await] }</span><span class="s2">\n      </span><span class="s1">// set PropertyName[?Yield, ?Await] ( PropertySetParameterList ) { FunctionBody[~Yield, ~Await] }</span><span class="s2">\n      </span><span class="s1">if (keyName === </span><span class="s2">\&quot;</span><span class="s1">get</span><span class="s2">\&quot; </span><span class="s1">|| keyName === </span><span class="s2">\&quot;</span><span class="s1">set</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">isAccessor = true;</span><span class="s2">\n        </span><span class="s1">this.resetPreviousNodeTrailingComments(key);</span><span class="s2">\n        </span><span class="s1">prop.kind = keyName;</span><span class="s2">\n        </span><span class="s1">if (this.match(tt.star)) {</span><span class="s2">\n          </span><span class="s1">isGenerator = true;</span><span class="s2">\n          </span><span class="s1">this.raise(Errors.AccessorIsGenerator, {</span><span class="s2">\n            </span><span class="s1">at: this.state.curPosition(),</span><span class="s2">\n            </span><span class="s1">kind: keyName,</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n          </span><span class="s1">this.next();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">this.parsePropertyName(prop);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">return this.parseObjPropValue(</span><span class="s2">\n      </span><span class="s1">prop,</span><span class="s2">\n      </span><span class="s1">startLoc,</span><span class="s2">\n      </span><span class="s1">isGenerator,</span><span class="s2">\n      </span><span class="s1">isAsync,</span><span class="s2">\n      </span><span class="s1">false /* isPattern */,</span><span class="s2">\n      </span><span class="s1">isAccessor,</span><span class="s2">\n      </span><span class="s1">refExpressionErrors,</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">getGetterSetterExpectedParamCount(</span><span class="s2">\n    </span><span class="s1">method: N.ObjectMethod | N.ClassMethod,</span><span class="s2">\n  </span><span class="s1">): number {</span><span class="s2">\n    </span><span class="s1">return method.kind === </span><span class="s2">\&quot;</span><span class="s1">get</span><span class="s2">\&quot; </span><span class="s1">? 0 : 1;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// This exists so we can override within the ESTree plugin</span><span class="s2">\n  </span><span class="s1">getObjectOrClassMethodParams(method: N.ObjectMethod | N.ClassMethod) {</span><span class="s2">\n    </span><span class="s1">return method.params;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// get methods aren't allowed to have any parameters</span><span class="s2">\n  </span><span class="s1">// set methods must have exactly 1 parameter which is not a rest parameter</span><span class="s2">\n  </span><span class="s1">checkGetterSetterParams(method: N.ObjectMethod | N.ClassMethod): void {</span><span class="s2">\n    </span><span class="s1">const paramCount = this.getGetterSetterExpectedParamCount(method);</span><span class="s2">\n    </span><span class="s1">const params = this.getObjectOrClassMethodParams(method);</span><span class="s2">\n\n    </span><span class="s1">if (params.length !== paramCount) {</span><span class="s2">\n      </span><span class="s1">this.raise(</span><span class="s2">\n        </span><span class="s1">method.kind === </span><span class="s2">\&quot;</span><span class="s1">get</span><span class="s2">\&quot; </span><span class="s1">? Errors.BadGetterArity : Errors.BadSetterArity,</span><span class="s2">\n        </span><span class="s1">{ at: method },</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">if (</span><span class="s2">\n      </span><span class="s1">method.kind === </span><span class="s2">\&quot;</span><span class="s1">set</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n      </span><span class="s1">params[params.length - 1]?.type === </span><span class="s2">\&quot;</span><span class="s1">RestElement</span><span class="s2">\&quot;\n    </span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">this.raise(Errors.BadSetterRestParameter, { at: method });</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// https://tc39.es/ecma262/#prod-MethodDefinition</span><span class="s2">\n  </span><span class="s1">parseObjectMethod(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">prop: Undone&lt;N.ObjectMethod&gt;,</span><span class="s2">\n    </span><span class="s1">isGenerator: boolean,</span><span class="s2">\n    </span><span class="s1">isAsync: boolean,</span><span class="s2">\n    </span><span class="s1">isPattern: boolean,</span><span class="s2">\n    </span><span class="s1">isAccessor: boolean,</span><span class="s2">\n  </span><span class="s1">): N.ObjectMethod | undefined | null {</span><span class="s2">\n    </span><span class="s1">if (isAccessor) {</span><span class="s2">\n      </span><span class="s1">// isAccessor implies isAsync: false, isPattern: false, isGenerator: false</span><span class="s2">\n      </span><span class="s1">const finishedProp = this.parseMethod(</span><span class="s2">\n        </span><span class="s1">prop,</span><span class="s2">\n        </span><span class="s1">// This _should_ be false, but with error recovery, we allow it to be</span><span class="s2">\n        </span><span class="s1">// set for informational purposes</span><span class="s2">\n        </span><span class="s1">isGenerator,</span><span class="s2">\n        </span><span class="s1">/* isAsync */ false,</span><span class="s2">\n        </span><span class="s1">/* isConstructor */ false,</span><span class="s2">\n        </span><span class="s1">false,</span><span class="s2">\n        \&quot;</span><span class="s1">ObjectMethod</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">this.checkGetterSetterParams(finishedProp);</span><span class="s2">\n      </span><span class="s1">return finishedProp;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">if (isAsync || isGenerator || this.match(tt.parenL)) {</span><span class="s2">\n      </span><span class="s1">if (isPattern) this.unexpected();</span><span class="s2">\n      </span><span class="s1">prop.kind = </span><span class="s2">\&quot;</span><span class="s1">method</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n      </span><span class="s1">prop.method = true;</span><span class="s2">\n      </span><span class="s1">return this.parseMethod(</span><span class="s2">\n        </span><span class="s1">prop,</span><span class="s2">\n        </span><span class="s1">isGenerator,</span><span class="s2">\n        </span><span class="s1">isAsync,</span><span class="s2">\n        </span><span class="s1">/* isConstructor */ false,</span><span class="s2">\n        </span><span class="s1">false,</span><span class="s2">\n        \&quot;</span><span class="s1">ObjectMethod</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// if `isPattern` is true, parse https://tc39.es/ecma262/#prod-BindingProperty</span><span class="s2">\n  </span><span class="s1">// else https://tc39.es/ecma262/#prod-PropertyDefinition</span><span class="s2">\n  </span><span class="s1">parseObjectProperty(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">prop: Undone&lt;N.ObjectProperty&gt;,</span><span class="s2">\n    </span><span class="s1">startLoc: Position | undefined | null,</span><span class="s2">\n    </span><span class="s1">isPattern: boolean,</span><span class="s2">\n    </span><span class="s1">refExpressionErrors?: ExpressionErrors | null,</span><span class="s2">\n  </span><span class="s1">): N.ObjectProperty | undefined | null {</span><span class="s2">\n    </span><span class="s1">prop.shorthand = false;</span><span class="s2">\n\n    </span><span class="s1">if (this.eat(tt.colon)) {</span><span class="s2">\n      </span><span class="s1">prop.value = isPattern</span><span class="s2">\n        </span><span class="s1">? this.parseMaybeDefault(this.state.startLoc)</span><span class="s2">\n        </span><span class="s1">: this.parseMaybeAssignAllowIn(refExpressionErrors);</span><span class="s2">\n\n      </span><span class="s1">return this.finishNode(prop, </span><span class="s2">\&quot;</span><span class="s1">ObjectProperty</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">if (!prop.computed &amp;&amp; prop.key.type === </span><span class="s2">\&quot;</span><span class="s1">Identifier</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">// PropertyDefinition:</span><span class="s2">\n      </span><span class="s1">//   IdentifierReference</span><span class="s2">\n      </span><span class="s1">//   CoverInitializedName</span><span class="s2">\n      </span><span class="s1">// Note: `{ eval } = {}` will be checked in `checkLVal` later.</span><span class="s2">\n      </span><span class="s1">this.checkReservedWord(prop.key.name, prop.key.loc.start, true, false);</span><span class="s2">\n\n      </span><span class="s1">if (isPattern) {</span><span class="s2">\n        </span><span class="s1">prop.value = this.parseMaybeDefault(</span><span class="s2">\n          </span><span class="s1">startLoc,</span><span class="s2">\n          </span><span class="s1">cloneIdentifier(prop.key),</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">} else if (this.match(tt.eq)) {</span><span class="s2">\n        </span><span class="s1">const shorthandAssignLoc = this.state.startLoc;</span><span class="s2">\n        </span><span class="s1">if (refExpressionErrors != null) {</span><span class="s2">\n          </span><span class="s1">if (refExpressionErrors.shorthandAssignLoc === null) {</span><span class="s2">\n            </span><span class="s1">refExpressionErrors.shorthandAssignLoc = shorthandAssignLoc;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">this.raise(Errors.InvalidCoverInitializedName, {</span><span class="s2">\n            </span><span class="s1">at: shorthandAssignLoc,</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">prop.value = this.parseMaybeDefault(</span><span class="s2">\n          </span><span class="s1">startLoc,</span><span class="s2">\n          </span><span class="s1">cloneIdentifier(prop.key),</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">prop.value = cloneIdentifier(prop.key);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">prop.shorthand = true;</span><span class="s2">\n\n      </span><span class="s1">return this.finishNode(prop, </span><span class="s2">\&quot;</span><span class="s1">ObjectProperty</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">parseObjPropValue(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">prop: Undone&lt;N.ObjectMethod | N.ObjectProperty&gt;,</span><span class="s2">\n    </span><span class="s1">startLoc: Position | undefined | null,</span><span class="s2">\n    </span><span class="s1">isGenerator: boolean,</span><span class="s2">\n    </span><span class="s1">isAsync: boolean,</span><span class="s2">\n    </span><span class="s1">isPattern: boolean,</span><span class="s2">\n    </span><span class="s1">isAccessor: boolean,</span><span class="s2">\n    </span><span class="s1">refExpressionErrors?: ExpressionErrors | null,</span><span class="s2">\n  </span><span class="s1">): N.ObjectMethod | N.ObjectProperty {</span><span class="s2">\n    </span><span class="s1">const node =</span><span class="s2">\n      </span><span class="s1">this.parseObjectMethod(</span><span class="s2">\n        </span><span class="s1">prop as Undone&lt;N.ObjectMethod&gt;,</span><span class="s2">\n        </span><span class="s1">isGenerator,</span><span class="s2">\n        </span><span class="s1">isAsync,</span><span class="s2">\n        </span><span class="s1">isPattern,</span><span class="s2">\n        </span><span class="s1">isAccessor,</span><span class="s2">\n      </span><span class="s1">) ||</span><span class="s2">\n      </span><span class="s1">this.parseObjectProperty(</span><span class="s2">\n        </span><span class="s1">prop as Undone&lt;N.ObjectProperty&gt;,</span><span class="s2">\n        </span><span class="s1">startLoc,</span><span class="s2">\n        </span><span class="s1">isPattern,</span><span class="s2">\n        </span><span class="s1">refExpressionErrors,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n\n    </span><span class="s1">if (!node) this.unexpected();</span><span class="s2">\n\n    </span><span class="s1">return node;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// https://tc39.es/ecma262/#prod-PropertyName</span><span class="s2">\n  </span><span class="s1">// when refExpressionErrors presents, it will parse private name</span><span class="s2">\n  </span><span class="s1">// and record the position of the first private name</span><span class="s2">\n  </span><span class="s1">parsePropertyName(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">prop:</span><span class="s2">\n      </span><span class="s1">| Undone&lt;N.ObjectOrClassMember | N.ClassMember&gt;</span><span class="s2">\n      </span><span class="s1">| N.TsNamedTypeElementBase,</span><span class="s2">\n    </span><span class="s1">refExpressionErrors?: ExpressionErrors | null,</span><span class="s2">\n  </span><span class="s1">): N.Expression | N.Identifier {</span><span class="s2">\n    </span><span class="s1">if (this.eat(tt.bracketL)) {</span><span class="s2">\n      </span><span class="s1">(prop as Undone&lt;N.ObjectOrClassMember&gt;).computed = true;</span><span class="s2">\n      </span><span class="s1">prop.key = this.parseMaybeAssignAllowIn();</span><span class="s2">\n      </span><span class="s1">this.expect(tt.bracketR);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">// We check if it's valid for it to be a private name when we push it.</span><span class="s2">\n      </span><span class="s1">const { type, value } = this.state;</span><span class="s2">\n      </span><span class="s1">let key;</span><span class="s2">\n      </span><span class="s1">// most un-computed property names are identifiers</span><span class="s2">\n      </span><span class="s1">if (tokenIsKeywordOrIdentifier(type)) {</span><span class="s2">\n        </span><span class="s1">key = this.parseIdentifier(true);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">switch (type) {</span><span class="s2">\n          </span><span class="s1">case tt.num:</span><span class="s2">\n            </span><span class="s1">key = this.parseNumericLiteral(value);</span><span class="s2">\n            </span><span class="s1">break;</span><span class="s2">\n          </span><span class="s1">case tt.string:</span><span class="s2">\n            </span><span class="s1">key = this.parseStringLiteral(value);</span><span class="s2">\n            </span><span class="s1">break;</span><span class="s2">\n          </span><span class="s1">case tt.bigint:</span><span class="s2">\n            </span><span class="s1">key = this.parseBigIntLiteral(value);</span><span class="s2">\n            </span><span class="s1">break;</span><span class="s2">\n          </span><span class="s1">case tt.decimal:</span><span class="s2">\n            </span><span class="s1">key = this.parseDecimalLiteral(value);</span><span class="s2">\n            </span><span class="s1">break;</span><span class="s2">\n          </span><span class="s1">case tt.privateName: {</span><span class="s2">\n            </span><span class="s1">// the class private key has been handled in parseClassElementName</span><span class="s2">\n            </span><span class="s1">const privateKeyLoc = this.state.startLoc;</span><span class="s2">\n            </span><span class="s1">if (refExpressionErrors != null) {</span><span class="s2">\n              </span><span class="s1">if (refExpressionErrors.privateKeyLoc === null) {</span><span class="s2">\n                </span><span class="s1">refExpressionErrors.privateKeyLoc = privateKeyLoc;</span><span class="s2">\n              </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">} else {</span><span class="s2">\n              </span><span class="s1">this.raise(Errors.UnexpectedPrivateField, {</span><span class="s2">\n                </span><span class="s1">at: privateKeyLoc,</span><span class="s2">\n              </span><span class="s1">});</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">key = this.parsePrivateName();</span><span class="s2">\n            </span><span class="s1">break;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">default:</span><span class="s2">\n            </span><span class="s1">this.unexpected();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">(prop as any).key = key;</span><span class="s2">\n      </span><span class="s1">if (type !== tt.privateName) {</span><span class="s2">\n        </span><span class="s1">// ClassPrivateProperty is never computed, so we don't assign in that case.</span><span class="s2">\n        </span><span class="s1">prop.computed = false;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">return prop.key;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Initialize empty function node.</span><span class="s2">\n\n  </span><span class="s1">initFunction(node: N.BodilessFunctionOrMethodBase, isAsync: boolean): void {</span><span class="s2">\n    </span><span class="s1">node.id = null;</span><span class="s2">\n    </span><span class="s1">node.generator = false;</span><span class="s2">\n    </span><span class="s1">node.async = isAsync;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Parse object or class method.</span><span class="s2">\n\n  </span><span class="s1">parseMethod&lt;T extends N.ObjectMethod | N.ClassMethod | N.ClassPrivateMethod&gt;(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">node: Undone&lt;T&gt;,</span><span class="s2">\n    </span><span class="s1">isGenerator: boolean,</span><span class="s2">\n    </span><span class="s1">isAsync: boolean,</span><span class="s2">\n    </span><span class="s1">isConstructor: boolean,</span><span class="s2">\n    </span><span class="s1">allowDirectSuper: boolean,</span><span class="s2">\n    </span><span class="s1">type: T[</span><span class="s2">\&quot;</span><span class="s1">type</span><span class="s2">\&quot;</span><span class="s1">],</span><span class="s2">\n    </span><span class="s1">inClassScope: boolean = false,</span><span class="s2">\n  </span><span class="s1">): T {</span><span class="s2">\n    </span><span class="s1">this.initFunction(node, isAsync);</span><span class="s2">\n    </span><span class="s1">node.generator = isGenerator;</span><span class="s2">\n    </span><span class="s1">this.scope.enter(</span><span class="s2">\n      </span><span class="s1">SCOPE_FUNCTION |</span><span class="s2">\n        </span><span class="s1">SCOPE_SUPER |</span><span class="s2">\n        </span><span class="s1">(inClassScope ? SCOPE_CLASS : 0) |</span><span class="s2">\n        </span><span class="s1">(allowDirectSuper ? SCOPE_DIRECT_SUPER : 0),</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">this.prodParam.enter(functionFlags(isAsync, node.generator));</span><span class="s2">\n    </span><span class="s1">this.parseFunctionParams(node, isConstructor);</span><span class="s2">\n    </span><span class="s1">const finishedNode = this.parseFunctionBodyAndFinish(node, type, true);</span><span class="s2">\n    </span><span class="s1">this.prodParam.exit();</span><span class="s2">\n    </span><span class="s1">this.scope.exit();</span><span class="s2">\n\n    </span><span class="s1">return finishedNode;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// parse an array literal or tuple literal</span><span class="s2">\n  </span><span class="s1">// https://tc39.es/ecma262/#prod-ArrayLiteral</span><span class="s2">\n  </span><span class="s1">// https://tc39.es/proposal-record-tuple/#prod-TupleLiteral</span><span class="s2">\n  </span><span class="s1">parseArrayLike(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">close: TokenType,</span><span class="s2">\n    </span><span class="s1">canBePattern: boolean,</span><span class="s2">\n    </span><span class="s1">isTuple: boolean,</span><span class="s2">\n    </span><span class="s1">refExpressionErrors?: ExpressionErrors | null,</span><span class="s2">\n  </span><span class="s1">): N.ArrayExpression | N.TupleExpression {</span><span class="s2">\n    </span><span class="s1">if (isTuple) {</span><span class="s2">\n      </span><span class="s1">this.expectPlugin(</span><span class="s2">\&quot;</span><span class="s1">recordAndTuple</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;</span><span class="s2">\n    </span><span class="s1">this.state.inFSharpPipelineDirectBody = false;</span><span class="s2">\n    </span><span class="s1">const node = this.startNode&lt;N.ArrayExpression | N.TupleExpression&gt;();</span><span class="s2">\n    </span><span class="s1">this.next();</span><span class="s2">\n    </span><span class="s1">node.elements = this.parseExprList(</span><span class="s2">\n      </span><span class="s1">close,</span><span class="s2">\n      </span><span class="s1">/* allowEmpty */ !isTuple,</span><span class="s2">\n      </span><span class="s1">refExpressionErrors,</span><span class="s2">\n      </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts)</span><span class="s2">\n      </span><span class="s1">node,</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;</span><span class="s2">\n    </span><span class="s1">return this.finishNode(</span><span class="s2">\n      </span><span class="s1">node,</span><span class="s2">\n      </span><span class="s1">isTuple ? </span><span class="s2">\&quot;</span><span class="s1">TupleExpression</span><span class="s2">\&quot; </span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">ArrayExpression</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Parse arrow function expression.</span><span class="s2">\n  </span><span class="s1">// If the parameters are provided, they will be converted to an</span><span class="s2">\n  </span><span class="s1">// assignable list.</span><span class="s2">\n  </span><span class="s1">parseArrowExpression(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">node: Undone&lt;N.ArrowFunctionExpression&gt;,</span><span class="s2">\n    </span><span class="s1">params: N.Expression[] | undefined | null,</span><span class="s2">\n    </span><span class="s1">isAsync: boolean,</span><span class="s2">\n    </span><span class="s1">trailingCommaLoc?: Position | null,</span><span class="s2">\n  </span><span class="s1">): N.ArrowFunctionExpression {</span><span class="s2">\n    </span><span class="s1">this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);</span><span class="s2">\n    </span><span class="s1">let flags = functionFlags(isAsync, false);</span><span class="s2">\n    </span><span class="s1">// ConciseBody[In] :</span><span class="s2">\n    </span><span class="s1">//   [lookahead ≠ {] ExpressionBody[?In, ~Await]</span><span class="s2">\n    </span><span class="s1">//   { FunctionBody[~Yield, ~Await] }</span><span class="s2">\n    </span><span class="s1">if (!this.match(tt.braceL) &amp;&amp; this.prodParam.hasIn) {</span><span class="s2">\n      </span><span class="s1">flags |= PARAM_IN;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">this.prodParam.enter(flags);</span><span class="s2">\n    </span><span class="s1">this.initFunction(node, isAsync);</span><span class="s2">\n    </span><span class="s1">const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;</span><span class="s2">\n\n    </span><span class="s1">if (params) {</span><span class="s2">\n      </span><span class="s1">this.state.maybeInArrowParameters = true;</span><span class="s2">\n      </span><span class="s1">this.setArrowFunctionParameters(node, params, trailingCommaLoc);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">this.state.maybeInArrowParameters = false;</span><span class="s2">\n    </span><span class="s1">this.parseFunctionBody(node, true);</span><span class="s2">\n\n    </span><span class="s1">this.prodParam.exit();</span><span class="s2">\n    </span><span class="s1">this.scope.exit();</span><span class="s2">\n    </span><span class="s1">this.state.maybeInArrowParameters = oldMaybeInArrowParameters;</span><span class="s2">\n\n    </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">ArrowFunctionExpression</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">setArrowFunctionParameters(</span><span class="s2">\n    </span><span class="s1">node: Undone&lt;N.ArrowFunctionExpression&gt;,</span><span class="s2">\n    </span><span class="s1">params: N.Expression[],</span><span class="s2">\n    </span><span class="s1">trailingCommaLoc?: Position | null,</span><span class="s2">\n  </span><span class="s1">): void {</span><span class="s2">\n    </span><span class="s1">this.toAssignableList(params, trailingCommaLoc, false);</span><span class="s2">\n    </span><span class="s1">node.params = params as (N.Pattern | N.TSParameterProperty)[];</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">parseFunctionBodyAndFinish&lt;</span><span class="s2">\n    </span><span class="s1">T extends</span><span class="s2">\n      </span><span class="s1">| N.Function</span><span class="s2">\n      </span><span class="s1">| N.TSDeclareMethod</span><span class="s2">\n      </span><span class="s1">| N.TSDeclareFunction</span><span class="s2">\n      </span><span class="s1">| N.ClassPrivateMethod,</span><span class="s2">\n  </span><span class="s1">&gt;(node: Undone&lt;T&gt;, type: T[</span><span class="s2">\&quot;</span><span class="s1">type</span><span class="s2">\&quot;</span><span class="s1">], isMethod: boolean = false): T {</span><span class="s2">\n    </span><span class="s1">// @ts-expect-error (node is not bodiless if we get here)</span><span class="s2">\n    </span><span class="s1">this.parseFunctionBody(node, false, isMethod);</span><span class="s2">\n    </span><span class="s1">return this.finishNode(node, type);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Parse function body and check parameters.</span><span class="s2">\n  </span><span class="s1">parseFunctionBody(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">node: Undone&lt;N.Function&gt;,</span><span class="s2">\n    </span><span class="s1">allowExpression?: boolean | null,</span><span class="s2">\n    </span><span class="s1">isMethod: boolean = false,</span><span class="s2">\n  </span><span class="s1">): void {</span><span class="s2">\n    </span><span class="s1">const isExpression = allowExpression &amp;&amp; !this.match(tt.braceL);</span><span class="s2">\n    </span><span class="s1">this.expressionScope.enter(newExpressionScope());</span><span class="s2">\n\n    </span><span class="s1">if (isExpression) {</span><span class="s2">\n      </span><span class="s1">// https://tc39.es/ecma262/#prod-ExpressionBody</span><span class="s2">\n      </span><span class="s1">(node as Undone&lt;N.ArrowFunctionExpression&gt;).body =</span><span class="s2">\n        </span><span class="s1">this.parseMaybeAssign();</span><span class="s2">\n      </span><span class="s1">this.checkParams(node, false, allowExpression, false);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">const oldStrict = this.state.strict;</span><span class="s2">\n      </span><span class="s1">// Start a new scope with regard to labels</span><span class="s2">\n      </span><span class="s1">// flag (restore them to their old value afterwards).</span><span class="s2">\n      </span><span class="s1">const oldLabels = this.state.labels;</span><span class="s2">\n      </span><span class="s1">this.state.labels = [];</span><span class="s2">\n\n      </span><span class="s1">// FunctionBody[Yield, Await]:</span><span class="s2">\n      </span><span class="s1">//   StatementList[?Yield, ?Await, +Return] opt</span><span class="s2">\n      </span><span class="s1">this.prodParam.enter(this.prodParam.currentFlags() | PARAM_RETURN);</span><span class="s2">\n      </span><span class="s1">node.body = this.parseBlock(</span><span class="s2">\n        </span><span class="s1">true,</span><span class="s2">\n        </span><span class="s1">false,</span><span class="s2">\n        </span><span class="s1">// Strict mode function checks after we parse the statements in the function body.</span><span class="s2">\n        </span><span class="s1">(hasStrictModeDirective: boolean) =&gt; {</span><span class="s2">\n          </span><span class="s1">const nonSimple = !this.isSimpleParamList(node.params);</span><span class="s2">\n\n          </span><span class="s1">if (hasStrictModeDirective &amp;&amp; nonSimple) {</span><span class="s2">\n            </span><span class="s1">// This logic is here to align the error location with the ESTree plugin.</span><span class="s2">\n            </span><span class="s1">this.raise(Errors.IllegalLanguageModeDirective, {</span><span class="s2">\n              </span><span class="s1">at:</span><span class="s2">\n                </span><span class="s1">// @ts-expect-error kind may not index node</span><span class="s2">\n                </span><span class="s1">(node.kind === </span><span class="s2">\&quot;</span><span class="s1">method</span><span class="s2">\&quot; </span><span class="s1">|| node.kind === </span><span class="s2">\&quot;</span><span class="s1">constructor</span><span class="s2">\&quot;</span><span class="s1">) &amp;&amp;</span><span class="s2">\n                </span><span class="s1">// @ts-expect-error key may not index node</span><span class="s2">\n                </span><span class="s1">!!node.key</span><span class="s2">\n                  </span><span class="s1">? // @ts-expect-error node.key has been guarded</span><span class="s2">\n                    </span><span class="s1">node.key.loc.end</span><span class="s2">\n                  </span><span class="s1">: node,</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n\n          </span><span class="s1">const strictModeChanged = !oldStrict &amp;&amp; this.state.strict;</span><span class="s2">\n\n          </span><span class="s1">// Add the params to varDeclaredNames to ensure that an error is thrown</span><span class="s2">\n          </span><span class="s1">// if a let/const declaration in the function clashes with one of the params.</span><span class="s2">\n          </span><span class="s1">this.checkParams(</span><span class="s2">\n            </span><span class="s1">node,</span><span class="s2">\n            </span><span class="s1">!this.state.strict &amp;&amp; !allowExpression &amp;&amp; !isMethod &amp;&amp; !nonSimple,</span><span class="s2">\n            </span><span class="s1">allowExpression,</span><span class="s2">\n            </span><span class="s1">strictModeChanged,</span><span class="s2">\n          </span><span class="s1">);</span><span class="s2">\n\n          </span><span class="s1">// Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'</span><span class="s2">\n          </span><span class="s1">if (this.state.strict &amp;&amp; node.id) {</span><span class="s2">\n            </span><span class="s1">this.checkIdentifier(node.id, BIND_OUTSIDE, strictModeChanged);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">this.prodParam.exit();</span><span class="s2">\n      </span><span class="s1">this.state.labels = oldLabels;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">this.expressionScope.exit();</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">isSimpleParameter(node: N.Pattern | N.TSParameterProperty) {</span><span class="s2">\n    </span><span class="s1">return node.type === </span><span class="s2">\&quot;</span><span class="s1">Identifier</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">isSimpleParamList(</span><span class="s2">\n    </span><span class="s1">params: ReadonlyArray&lt;N.Pattern | N.TSParameterProperty&gt;,</span><span class="s2">\n  </span><span class="s1">): boolean {</span><span class="s2">\n    </span><span class="s1">for (let i = 0, len = params.length; i &lt; len; i++) {</span><span class="s2">\n      </span><span class="s1">if (!this.isSimpleParameter(params[i])) return false;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return true;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">checkParams(</span><span class="s2">\n    </span><span class="s1">node: Undone&lt;N.Function&gt;,</span><span class="s2">\n    </span><span class="s1">allowDuplicates: boolean,</span><span class="s2">\n    </span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-unused-vars</span><span class="s2">\n    </span><span class="s1">isArrowFunction?: boolean | null,</span><span class="s2">\n    </span><span class="s1">strictModeChanged: boolean = true,</span><span class="s2">\n  </span><span class="s1">): void {</span><span class="s2">\n    </span><span class="s1">const checkClashes = !allowDuplicates &amp;&amp; new Set&lt;string&gt;();</span><span class="s2">\n    </span><span class="s1">// We create a fake node with the </span><span class="s2">\&quot;</span><span class="s1">ephemeral</span><span class="s2">\&quot; </span><span class="s1">type `FormalParameters`[1]</span><span class="s2">\n    </span><span class="s1">// since we just store an array of parameters. Perhaps someday we can have</span><span class="s2">\n    </span><span class="s1">// something like class FormalParameters extends Array { ... }, which would</span><span class="s2">\n    </span><span class="s1">// also be helpful when traversing this node.</span><span class="s2">\n    </span><span class="s1">//</span><span class="s2">\n    </span><span class="s1">// 1. https://tc39.es/ecma262/#prod-FormalParameters</span><span class="s2">\n    </span><span class="s1">const formalParameters = { type: </span><span class="s2">\&quot;</span><span class="s1">FormalParameters</span><span class="s2">\&quot; </span><span class="s1">} as const;</span><span class="s2">\n    </span><span class="s1">for (const param of node.params) {</span><span class="s2">\n      </span><span class="s1">this.checkLVal(param, {</span><span class="s2">\n        </span><span class="s1">in: formalParameters,</span><span class="s2">\n        </span><span class="s1">binding: BIND_VAR,</span><span class="s2">\n        </span><span class="s1">checkClashes,</span><span class="s2">\n        </span><span class="s1">strictModeChanged,</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Parses a comma-separated list of expressions, and returns them as</span><span class="s2">\n  </span><span class="s1">// an array. `close` is the token type that ends the list, and</span><span class="s2">\n  </span><span class="s1">// `allowEmpty` can be turned on to allow subsequent commas with</span><span class="s2">\n  </span><span class="s1">// nothing in between them to be parsed as `null` (which is needed</span><span class="s2">\n  </span><span class="s1">// for array literals).</span><span class="s2">\n\n  </span><span class="s1">parseExprList(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">close: TokenType,</span><span class="s2">\n    </span><span class="s1">allowEmpty?: boolean,</span><span class="s2">\n    </span><span class="s1">refExpressionErrors?: ExpressionErrors | null,</span><span class="s2">\n    </span><span class="s1">nodeForExtra?: N.Node | null,</span><span class="s2">\n  </span><span class="s1">): (N.Expression | null)[] {</span><span class="s2">\n    </span><span class="s1">const elts: (N.Expression | null)[] = [];</span><span class="s2">\n    </span><span class="s1">let first = true;</span><span class="s2">\n\n    </span><span class="s1">while (!this.eat(close)) {</span><span class="s2">\n      </span><span class="s1">if (first) {</span><span class="s2">\n        </span><span class="s1">first = false;</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">this.expect(tt.comma);</span><span class="s2">\n        </span><span class="s1">if (this.match(close)) {</span><span class="s2">\n          </span><span class="s1">if (nodeForExtra) {</span><span class="s2">\n            </span><span class="s1">this.addTrailingCommaExtraToNode(nodeForExtra);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">this.next();</span><span class="s2">\n          </span><span class="s1">break;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return elts;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">parseExprListItem(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">allowEmpty?: boolean,</span><span class="s2">\n    </span><span class="s1">refExpressionErrors?: ExpressionErrors | null,</span><span class="s2">\n    </span><span class="s1">allowPlaceholder?: boolean | null,</span><span class="s2">\n  </span><span class="s1">): N.Expression | null;</span><span class="s2">\n  </span><span class="s1">parseExprListItem(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">allowEmpty?: false,</span><span class="s2">\n    </span><span class="s1">refExpressionErrors?: ExpressionErrors | null,</span><span class="s2">\n    </span><span class="s1">allowPlaceholder?: boolean | null,</span><span class="s2">\n  </span><span class="s1">): N.Expression;</span><span class="s2">\n  </span><span class="s1">parseExprListItem(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">allowEmpty?: boolean | null,</span><span class="s2">\n    </span><span class="s1">refExpressionErrors?: ExpressionErrors | null,</span><span class="s2">\n    </span><span class="s1">allowPlaceholder?: boolean | null,</span><span class="s2">\n  </span><span class="s1">): N.Expression | null {</span><span class="s2">\n    </span><span class="s1">let elt;</span><span class="s2">\n    </span><span class="s1">if (this.match(tt.comma)) {</span><span class="s2">\n      </span><span class="s1">if (!allowEmpty) {</span><span class="s2">\n        </span><span class="s1">this.raise(Errors.UnexpectedToken, {</span><span class="s2">\n          </span><span class="s1">at: this.state.curPosition(),</span><span class="s2">\n          </span><span class="s1">unexpected: </span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">elt = null;</span><span class="s2">\n    </span><span class="s1">} else if (this.match(tt.ellipsis)) {</span><span class="s2">\n      </span><span class="s1">const spreadNodeStartLoc = this.state.startLoc;</span><span class="s2">\n\n      </span><span class="s1">elt = this.parseParenItem(</span><span class="s2">\n        </span><span class="s1">this.parseSpread(refExpressionErrors),</span><span class="s2">\n        </span><span class="s1">spreadNodeStartLoc,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">} else if (this.match(tt.question)) {</span><span class="s2">\n      </span><span class="s1">this.expectPlugin(</span><span class="s2">\&quot;</span><span class="s1">partialApplication</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">if (!allowPlaceholder) {</span><span class="s2">\n        </span><span class="s1">this.raise(Errors.UnexpectedArgumentPlaceholder, {</span><span class="s2">\n          </span><span class="s1">at: this.state.startLoc,</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">const node = this.startNode();</span><span class="s2">\n      </span><span class="s1">this.next();</span><span class="s2">\n      </span><span class="s1">elt = this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">ArgumentPlaceholder</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">elt = this.parseMaybeAssignAllowIn(</span><span class="s2">\n        </span><span class="s1">refExpressionErrors,</span><span class="s2">\n        </span><span class="s1">this.parseParenItem,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return elt;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Parse the next token as an identifier. If `liberal` is true (used</span><span class="s2">\n  </span><span class="s1">// when parsing properties), it will also convert keywords into</span><span class="s2">\n  </span><span class="s1">// identifiers.</span><span class="s2">\n  </span><span class="s1">// This shouldn't be used to parse the keywords of meta properties, since they</span><span class="s2">\n  </span><span class="s1">// are not identifiers and cannot contain escape sequences.</span><span class="s2">\n\n  </span><span class="s1">parseIdentifier(liberal?: boolean): N.Identifier {</span><span class="s2">\n    </span><span class="s1">const node = this.startNode&lt;N.Identifier&gt;();</span><span class="s2">\n    </span><span class="s1">const name = this.parseIdentifierName(liberal);</span><span class="s2">\n\n    </span><span class="s1">return this.createIdentifier(node, name);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">createIdentifier(</span><span class="s2">\n    </span><span class="s1">node: Omit&lt;N.Identifier, </span><span class="s2">\&quot;</span><span class="s1">type</span><span class="s2">\&quot;</span><span class="s1">&gt;,</span><span class="s2">\n    </span><span class="s1">name: string,</span><span class="s2">\n  </span><span class="s1">): N.Identifier {</span><span class="s2">\n    </span><span class="s1">node.name = name;</span><span class="s2">\n    </span><span class="s1">node.loc.identifierName = name;</span><span class="s2">\n\n    </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">Identifier</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">parseIdentifierName(liberal?: boolean): string {</span><span class="s2">\n    </span><span class="s1">let name: string;</span><span class="s2">\n\n    </span><span class="s1">const { startLoc, type } = this.state;</span><span class="s2">\n\n    </span><span class="s1">if (tokenIsKeywordOrIdentifier(type)) {</span><span class="s2">\n      </span><span class="s1">name = this.state.value;</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">this.unexpected();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">const tokenIsKeyword = tokenKeywordOrIdentifierIsKeyword(type);</span><span class="s2">\n\n    </span><span class="s1">if (liberal) {</span><span class="s2">\n      </span><span class="s1">// If the current token is not used as a keyword, set its type to </span><span class="s2">\&quot;</span><span class="s1">tt.name</span><span class="s2">\&quot;</span><span class="s1">.</span><span class="s2">\n      </span><span class="s1">// This will prevent this.next() from throwing about unexpected escapes.</span><span class="s2">\n      </span><span class="s1">if (tokenIsKeyword) {</span><span class="s2">\n        </span><span class="s1">this.replaceToken(tt.name);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">this.checkReservedWord(name, startLoc, tokenIsKeyword, false);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">this.next();</span><span class="s2">\n\n    </span><span class="s1">return name;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">checkReservedWord(</span><span class="s2">\n    </span><span class="s1">word: string,</span><span class="s2">\n    </span><span class="s1">startLoc: Position,</span><span class="s2">\n    </span><span class="s1">checkKeywords: boolean,</span><span class="s2">\n    </span><span class="s1">isBinding: boolean,</span><span class="s2">\n  </span><span class="s1">): void {</span><span class="s2">\n    </span><span class="s1">// Every JavaScript reserved word is 10 characters or less.</span><span class="s2">\n    </span><span class="s1">if (word.length &gt; 10) {</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// Most identifiers are not reservedWord-like, they don't need special</span><span class="s2">\n    </span><span class="s1">// treatments afterward, which very likely ends up throwing errors</span><span class="s2">\n    </span><span class="s1">if (!canBeReservedWord(word)) {</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">if (checkKeywords &amp;&amp; isKeyword(word)) {</span><span class="s2">\n      </span><span class="s1">this.raise(Errors.UnexpectedKeyword, {</span><span class="s2">\n        </span><span class="s1">at: startLoc,</span><span class="s2">\n        </span><span class="s1">keyword: word,</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">const reservedTest = !this.state.strict</span><span class="s2">\n      </span><span class="s1">? isReservedWord</span><span class="s2">\n      </span><span class="s1">: isBinding</span><span class="s2">\n      </span><span class="s1">? isStrictBindReservedWord</span><span class="s2">\n      </span><span class="s1">: isStrictReservedWord;</span><span class="s2">\n\n    </span><span class="s1">if (reservedTest(word, this.inModule)) {</span><span class="s2">\n      </span><span class="s1">this.raise(Errors.UnexpectedReservedWord, {</span><span class="s2">\n        </span><span class="s1">at: startLoc,</span><span class="s2">\n        </span><span class="s1">reservedWord: word,</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">} else if (word === </span><span class="s2">\&quot;</span><span class="s1">yield</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">if (this.prodParam.hasYield) {</span><span class="s2">\n        </span><span class="s1">this.raise(Errors.YieldBindingIdentifier, { at: startLoc });</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else if (word === </span><span class="s2">\&quot;</span><span class="s1">await</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">if (this.prodParam.hasAwait) {</span><span class="s2">\n        </span><span class="s1">this.raise(Errors.AwaitBindingIdentifier, { at: startLoc });</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">if (this.scope.inStaticBlock) {</span><span class="s2">\n        </span><span class="s1">this.raise(Errors.AwaitBindingIdentifierInStaticBlock, {</span><span class="s2">\n          </span><span class="s1">at: startLoc,</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">this.expressionScope.recordAsyncArrowParametersError({ at: startLoc });</span><span class="s2">\n    </span><span class="s1">} else if (word === </span><span class="s2">\&quot;</span><span class="s1">arguments</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">if (this.scope.inClassAndNotInNonArrowFunction) {</span><span class="s2">\n        </span><span class="s1">this.raise(Errors.ArgumentsInClass, { at: startLoc });</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">isAwaitAllowed(): boolean {</span><span class="s2">\n    </span><span class="s1">if (this.prodParam.hasAwait) return true;</span><span class="s2">\n    </span><span class="s1">if (this.options.allowAwaitOutsideFunction &amp;&amp; !this.scope.inFunction) {</span><span class="s2">\n      </span><span class="s1">return true;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return false;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Parses await expression inside async function.</span><span class="s2">\n\n  </span><span class="s1">parseAwait(this: Parser, startLoc: Position): N.AwaitExpression {</span><span class="s2">\n    </span><span class="s1">const node = this.startNodeAt&lt;N.AwaitExpression&gt;(startLoc);</span><span class="s2">\n\n    </span><span class="s1">this.expressionScope.recordParameterInitializerError(</span><span class="s2">\n      </span><span class="s1">Errors.AwaitExpressionFormalParameter,</span><span class="s2">\n      </span><span class="s1">{</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts)</span><span class="s2">\n        </span><span class="s1">at: node,</span><span class="s2">\n      </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n\n    </span><span class="s1">if (this.eat(tt.star)) {</span><span class="s2">\n      </span><span class="s1">this.raise(Errors.ObsoleteAwaitStar, { at: node });</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">if (!this.scope.inFunction &amp;&amp; !this.options.allowAwaitOutsideFunction) {</span><span class="s2">\n      </span><span class="s1">if (this.isAmbiguousAwait()) {</span><span class="s2">\n        </span><span class="s1">this.ambiguousScriptDifferentAst = true;</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">this.sawUnambiguousESM = true;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">if (!this.state.soloAwait) {</span><span class="s2">\n      </span><span class="s1">node.argument = this.parseMaybeUnary(null, true);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">AwaitExpression</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">isAmbiguousAwait(): boolean {</span><span class="s2">\n    </span><span class="s1">if (this.hasPrecedingLineBreak()) return true;</span><span class="s2">\n    </span><span class="s1">const { type } = this.state;</span><span class="s2">\n    </span><span class="s1">return (</span><span class="s2">\n      </span><span class="s1">// All the following expressions are ambiguous:</span><span class="s2">\n      </span><span class="s1">//   await + 0, await - 0, await ( 0 ), await [ 0 ], await / 0 /u, await ``, await of []</span><span class="s2">\n      </span><span class="s1">type === tt.plusMin ||</span><span class="s2">\n      </span><span class="s1">type === tt.parenL ||</span><span class="s2">\n      </span><span class="s1">type === tt.bracketL ||</span><span class="s2">\n      </span><span class="s1">tokenIsTemplate(type) ||</span><span class="s2">\n      </span><span class="s1">(type === tt._of &amp;&amp; !this.state.containsEsc) ||</span><span class="s2">\n      </span><span class="s1">// Sometimes the tokenizer generates tt.slash for regexps, and this is</span><span class="s2">\n      </span><span class="s1">// handler by parseExprAtom</span><span class="s2">\n      </span><span class="s1">type === tt.regexp ||</span><span class="s2">\n      </span><span class="s1">type === tt.slash ||</span><span class="s2">\n      </span><span class="s1">// This code could be parsed both as a modulo operator or as an intrinsic:</span><span class="s2">\n      </span><span class="s1">//   await %x(0)</span><span class="s2">\n      </span><span class="s1">(this.hasPlugin(</span><span class="s2">\&quot;</span><span class="s1">v8intrinsic</span><span class="s2">\&quot;</span><span class="s1">) &amp;&amp; type === tt.modulo)</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Parses yield expression inside generator.</span><span class="s2">\n\n  </span><span class="s1">parseYield(this: Parser): N.YieldExpression {</span><span class="s2">\n    </span><span class="s1">const node = this.startNode&lt;N.YieldExpression&gt;();</span><span class="s2">\n\n    </span><span class="s1">this.expressionScope.recordParameterInitializerError(</span><span class="s2">\n      </span><span class="s1">Errors.YieldInParameter,</span><span class="s2">\n      </span><span class="s1">{</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts)</span><span class="s2">\n        </span><span class="s1">at: node,</span><span class="s2">\n      </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n\n    </span><span class="s1">this.next();</span><span class="s2">\n    </span><span class="s1">let delegating = false;</span><span class="s2">\n    </span><span class="s1">let argument: N.Expression | null = null;</span><span class="s2">\n    </span><span class="s1">if (!this.hasPrecedingLineBreak()) {</span><span class="s2">\n      </span><span class="s1">delegating = this.eat(tt.star);</span><span class="s2">\n      </span><span class="s1">switch (this.state.type) {</span><span class="s2">\n        </span><span class="s1">case tt.semi:</span><span class="s2">\n        </span><span class="s1">case tt.eof:</span><span class="s2">\n        </span><span class="s1">case tt.braceR:</span><span class="s2">\n        </span><span class="s1">case tt.parenR:</span><span class="s2">\n        </span><span class="s1">case tt.bracketR:</span><span class="s2">\n        </span><span class="s1">case tt.braceBarR:</span><span class="s2">\n        </span><span class="s1">case tt.colon:</span><span class="s2">\n        </span><span class="s1">case tt.comma:</span><span class="s2">\n          </span><span class="s1">// The above is the complete set of tokens that can</span><span class="s2">\n          </span><span class="s1">// follow an AssignmentExpression, and none of them</span><span class="s2">\n          </span><span class="s1">// can start an AssignmentExpression</span><span class="s2">\n          </span><span class="s1">if (!delegating) break;</span><span class="s2">\n        </span><span class="s1">/* fallthrough */</span><span class="s2">\n        </span><span class="s1">default:</span><span class="s2">\n          </span><span class="s1">argument = this.parseMaybeAssign();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">node.delegate = delegating;</span><span class="s2">\n    </span><span class="s1">node.argument = argument;</span><span class="s2">\n    </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">YieldExpression</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Validates a pipeline (for any of the pipeline Babylon plugins) at the point</span><span class="s2">\n  </span><span class="s1">// of the infix operator `|&gt;`.</span><span class="s2">\n\n  </span><span class="s1">checkPipelineAtInfixOperator(left: N.Expression, leftStartLoc: Position) {</span><span class="s2">\n    </span><span class="s1">if (this.hasPlugin([</span><span class="s2">\&quot;</span><span class="s1">pipelineOperator</span><span class="s2">\&quot;</span><span class="s1">, { proposal: </span><span class="s2">\&quot;</span><span class="s1">smart</span><span class="s2">\&quot; </span><span class="s1">}])) {</span><span class="s2">\n      </span><span class="s1">if (left.type === </span><span class="s2">\&quot;</span><span class="s1">SequenceExpression</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">// Ensure that the pipeline head is not a comma-delimited</span><span class="s2">\n        </span><span class="s1">// sequence expression.</span><span class="s2">\n        </span><span class="s1">this.raise(Errors.PipelineHeadSequenceExpression, {</span><span class="s2">\n          </span><span class="s1">at: leftStartLoc,</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">parseSmartPipelineBodyInStyle(childExpr: N.Expression, startLoc: Position) {</span><span class="s2">\n    </span><span class="s1">if (this.isSimpleReference(childExpr)) {</span><span class="s2">\n      </span><span class="s1">const bodyNode = this.startNodeAt&lt;N.PipelineBareFunction&gt;(startLoc);</span><span class="s2">\n      </span><span class="s1">bodyNode.callee = childExpr;</span><span class="s2">\n      </span><span class="s1">return this.finishNode(bodyNode, </span><span class="s2">\&quot;</span><span class="s1">PipelineBareFunction</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">const bodyNode = this.startNodeAt&lt;N.PipelineTopicExpression&gt;(startLoc);</span><span class="s2">\n      </span><span class="s1">this.checkSmartPipeTopicBodyEarlyErrors(startLoc);</span><span class="s2">\n      </span><span class="s1">bodyNode.expression = childExpr;</span><span class="s2">\n      </span><span class="s1">return this.finishNode(bodyNode, </span><span class="s2">\&quot;</span><span class="s1">PipelineTopicExpression</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">isSimpleReference(expression: N.Expression): boolean {</span><span class="s2">\n    </span><span class="s1">switch (expression.type) {</span><span class="s2">\n      </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">MemberExpression</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n        </span><span class="s1">return (</span><span class="s2">\n          </span><span class="s1">!expression.computed &amp;&amp; this.isSimpleReference(expression.object)</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">Identifier</span><span class="s2">\&quot;</span><span class="s1">:</span><span class="s2">\n        </span><span class="s1">return true;</span><span class="s2">\n      </span><span class="s1">default:</span><span class="s2">\n        </span><span class="s1">return false;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// This helper method is to be called immediately</span><span class="s2">\n  </span><span class="s1">// after a topic-style smart-mix pipe body is parsed.</span><span class="s2">\n  </span><span class="s1">// The `startLoc` is the starting position of the pipe body.</span><span class="s2">\n\n  </span><span class="s1">checkSmartPipeTopicBodyEarlyErrors(startLoc: Position): void {</span><span class="s2">\n    </span><span class="s1">// If the following token is invalidly `=&gt;`, then throw a human-friendly error</span><span class="s2">\n    </span><span class="s1">// instead of something like 'Unexpected token, expected </span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\&quot;</span><span class="s1">'.</span><span class="s2">\n    </span><span class="s1">// For example, `x =&gt; x |&gt; y =&gt; #` (assuming `#` is the topic reference)</span><span class="s2">\n    </span><span class="s1">// groups into `x =&gt; (x |&gt; y) =&gt; #`,</span><span class="s2">\n    </span><span class="s1">// and `(x |&gt; y) =&gt; #` is an invalid arrow function.</span><span class="s2">\n    </span><span class="s1">// This is because smart-mix `|&gt;` has tighter precedence than `=&gt;`.</span><span class="s2">\n    </span><span class="s1">if (this.match(tt.arrow)) {</span><span class="s2">\n      </span><span class="s1">throw this.raise(Errors.PipelineBodyNoArrow, { at: this.state.startLoc });</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// A topic-style smart-mix pipe body must use the topic reference at least once.</span><span class="s2">\n    </span><span class="s1">if (!this.topicReferenceWasUsedInCurrentContext()) {</span><span class="s2">\n      </span><span class="s1">this.raise(Errors.PipelineTopicUnused, { at: startLoc });</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Enable topic references from outer contexts within Hack-style pipe bodies.</span><span class="s2">\n  </span><span class="s1">// The function modifies the parser's topic-context state to enable or disable</span><span class="s2">\n  </span><span class="s1">// the use of topic references.</span><span class="s2">\n  </span><span class="s1">// The function then calls a callback, then resets the parser</span><span class="s2">\n  </span><span class="s1">// to the old topic-context state that it had before the function was called.</span><span class="s2">\n\n  </span><span class="s1">withTopicBindingContext&lt;T&gt;(callback: () =&gt; T): T {</span><span class="s2">\n    </span><span class="s1">const outerContextTopicState = this.state.topicContext;</span><span class="s2">\n    </span><span class="s1">this.state.topicContext = {</span><span class="s2">\n      </span><span class="s1">// Enable the use of the primary topic reference.</span><span class="s2">\n      </span><span class="s1">maxNumOfResolvableTopics: 1,</span><span class="s2">\n      </span><span class="s1">// Hide the use of any topic references from outer contexts.</span><span class="s2">\n      </span><span class="s1">maxTopicIndex: null,</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n\n    </span><span class="s1">try {</span><span class="s2">\n      </span><span class="s1">return callback();</span><span class="s2">\n    </span><span class="s1">} finally {</span><span class="s2">\n      </span><span class="s1">this.state.topicContext = outerContextTopicState;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// This helper method is used only with the deprecated smart-mix pipe proposal.</span><span class="s2">\n  </span><span class="s1">// Disables topic references from outer contexts within syntax constructs</span><span class="s2">\n  </span><span class="s1">// such as the bodies of iteration statements.</span><span class="s2">\n  </span><span class="s1">// The function modifies the parser's topic-context state to enable or disable</span><span class="s2">\n  </span><span class="s1">// the use of topic references with the smartPipelines plugin. They then run a</span><span class="s2">\n  </span><span class="s1">// callback, then they reset the parser to the old topic-context state that it</span><span class="s2">\n  </span><span class="s1">// had before the function was called.</span><span class="s2">\n\n  </span><span class="s1">withSmartMixTopicForbiddingContext&lt;T&gt;(callback: () =&gt; T): T {</span><span class="s2">\n    </span><span class="s1">if (this.hasPlugin([</span><span class="s2">\&quot;</span><span class="s1">pipelineOperator</span><span class="s2">\&quot;</span><span class="s1">, { proposal: </span><span class="s2">\&quot;</span><span class="s1">smart</span><span class="s2">\&quot; </span><span class="s1">}])) {</span><span class="s2">\n      </span><span class="s1">// Reset the parser’s topic context only if the smart-mix pipe proposal is active.</span><span class="s2">\n      </span><span class="s1">const outerContextTopicState = this.state.topicContext;</span><span class="s2">\n      </span><span class="s1">this.state.topicContext = {</span><span class="s2">\n        </span><span class="s1">// Disable the use of the primary topic reference.</span><span class="s2">\n        </span><span class="s1">maxNumOfResolvableTopics: 0,</span><span class="s2">\n        </span><span class="s1">// Hide the use of any topic references from outer contexts.</span><span class="s2">\n        </span><span class="s1">maxTopicIndex: null,</span><span class="s2">\n      </span><span class="s1">};</span><span class="s2">\n\n      </span><span class="s1">try {</span><span class="s2">\n        </span><span class="s1">return callback();</span><span class="s2">\n      </span><span class="s1">} finally {</span><span class="s2">\n        </span><span class="s1">this.state.topicContext = outerContextTopicState;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">// If the pipe proposal is </span><span class="s2">\&quot;</span><span class="s1">minimal</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">fsharp</span><span class="s2">\&quot;</span><span class="s1">, or </span><span class="s2">\&quot;</span><span class="s1">hack</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">// or if no pipe proposal is active,</span><span class="s2">\n      </span><span class="s1">// then the callback result is returned</span><span class="s2">\n      </span><span class="s1">// without touching any extra parser state.</span><span class="s2">\n      </span><span class="s1">return callback();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">withSoloAwaitPermittingContext&lt;T&gt;(callback: () =&gt; T): T {</span><span class="s2">\n    </span><span class="s1">const outerContextSoloAwaitState = this.state.soloAwait;</span><span class="s2">\n    </span><span class="s1">this.state.soloAwait = true;</span><span class="s2">\n\n    </span><span class="s1">try {</span><span class="s2">\n      </span><span class="s1">return callback();</span><span class="s2">\n    </span><span class="s1">} finally {</span><span class="s2">\n      </span><span class="s1">this.state.soloAwait = outerContextSoloAwaitState;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">allowInAnd&lt;T&gt;(callback: () =&gt; T): T {</span><span class="s2">\n    </span><span class="s1">const flags = this.prodParam.currentFlags();</span><span class="s2">\n    </span><span class="s1">const prodParamToSet = PARAM_IN &amp; ~flags;</span><span class="s2">\n    </span><span class="s1">if (prodParamToSet) {</span><span class="s2">\n      </span><span class="s1">this.prodParam.enter(flags | PARAM_IN);</span><span class="s2">\n      </span><span class="s1">try {</span><span class="s2">\n        </span><span class="s1">return callback();</span><span class="s2">\n      </span><span class="s1">} finally {</span><span class="s2">\n        </span><span class="s1">this.prodParam.exit();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return callback();</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">disallowInAnd&lt;T&gt;(callback: () =&gt; T): T {</span><span class="s2">\n    </span><span class="s1">const flags = this.prodParam.currentFlags();</span><span class="s2">\n    </span><span class="s1">const prodParamToClear = PARAM_IN &amp; flags;</span><span class="s2">\n    </span><span class="s1">if (prodParamToClear) {</span><span class="s2">\n      </span><span class="s1">this.prodParam.enter(flags &amp; ~PARAM_IN);</span><span class="s2">\n      </span><span class="s1">try {</span><span class="s2">\n        </span><span class="s1">return callback();</span><span class="s2">\n      </span><span class="s1">} finally {</span><span class="s2">\n        </span><span class="s1">this.prodParam.exit();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return callback();</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Register the use of a topic reference within the current</span><span class="s2">\n  </span><span class="s1">// topic-binding context.</span><span class="s2">\n  </span><span class="s1">registerTopicReference(): void {</span><span class="s2">\n    </span><span class="s1">this.state.topicContext.maxTopicIndex = 0;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">topicReferenceIsAllowedInCurrentContext(): boolean {</span><span class="s2">\n    </span><span class="s1">return this.state.topicContext.maxNumOfResolvableTopics &gt;= 1;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">topicReferenceWasUsedInCurrentContext(): boolean {</span><span class="s2">\n    </span><span class="s1">return (</span><span class="s2">\n      </span><span class="s1">this.state.topicContext.maxTopicIndex != null &amp;&amp;</span><span class="s2">\n      </span><span class="s1">this.state.topicContext.maxTopicIndex &gt;= 0</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">parseFSharpPipelineBody(this: Parser, prec: number): N.Expression {</span><span class="s2">\n    </span><span class="s1">const startLoc = this.state.startLoc;</span><span class="s2">\n\n    </span><span class="s1">this.state.potentialArrowAt = this.state.start;</span><span class="s2">\n    </span><span class="s1">const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;</span><span class="s2">\n    </span><span class="s1">this.state.inFSharpPipelineDirectBody = true;</span><span class="s2">\n\n    </span><span class="s1">const ret = this.parseExprOp(</span><span class="s2">\n      </span><span class="s1">this.parseMaybeUnaryOrPrivate(),</span><span class="s2">\n      </span><span class="s1">startLoc,</span><span class="s2">\n      </span><span class="s1">prec,</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n\n    </span><span class="s1">this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;</span><span class="s2">\n\n    </span><span class="s1">return ret;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// https://github.com/tc39/proposal-js-module-blocks</span><span class="s2">\n  </span><span class="s1">parseModuleExpression(this: Parser): N.ModuleExpression {</span><span class="s2">\n    </span><span class="s1">this.expectPlugin(</span><span class="s2">\&quot;</span><span class="s1">moduleBlocks</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">const node = this.startNode&lt;N.ModuleExpression&gt;();</span><span class="s2">\n    </span><span class="s1">this.next(); // eat </span><span class="s2">\&quot;</span><span class="s1">module</span><span class="s2">\&quot;\n    </span><span class="s1">if (!this.match(tt.braceL)) {</span><span class="s2">\n      </span><span class="s1">this.unexpected(null, tt.braceL);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// start program node immediately after `{`</span><span class="s2">\n    </span><span class="s1">const program = this.startNodeAt&lt;N.Program&gt;(this.state.endLoc);</span><span class="s2">\n    </span><span class="s1">this.next(); // eat `{`</span><span class="s2">\n\n    </span><span class="s1">const revertScopes = this.initializeScopes(/** inModule */ true);</span><span class="s2">\n    </span><span class="s1">this.enterInitialScopes();</span><span class="s2">\n\n    </span><span class="s1">try {</span><span class="s2">\n      </span><span class="s1">node.body = this.parseProgram(program, tt.braceR, </span><span class="s2">\&quot;</span><span class="s1">module</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">} finally {</span><span class="s2">\n      </span><span class="s1">revertScopes();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return this.finishNode&lt;N.ModuleExpression&gt;(node, </span><span class="s2">\&quot;</span><span class="s1">ModuleExpression</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Used in Flow plugin</span><span class="s2">\n  </span><span class="s1">parsePropertyNamePrefixOperator(</span><span class="s2">\n    </span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-unused-vars</span><span class="s2">\n    </span><span class="s1">prop: Undone&lt;N.ObjectOrClassMember | N.ClassMember&gt;,</span><span class="s2">\n  </span><span class="s1">): void {}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">&quot;</span><span class="s2">,</span><span class="s1">&quot;import type * as N from </span><span class="s2">\&quot;</span><span class="s1">../types</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import {</span><span class="s2">\n  </span><span class="s1">tokenIsIdentifier,</span><span class="s2">\n  </span><span class="s1">tokenIsLoop,</span><span class="s2">\n  </span><span class="s1">tokenIsTemplate,</span><span class="s2">\n  </span><span class="s1">tt,</span><span class="s2">\n  </span><span class="s1">type TokenType,</span><span class="s2">\n  </span><span class="s1">getExportedToken,</span><span class="s2">\n</span><span class="s1">} from </span><span class="s2">\&quot;</span><span class="s1">../tokenizer/types</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import ExpressionParser from </span><span class="s2">\&quot;</span><span class="s1">./expression</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import { Errors } from </span><span class="s2">\&quot;</span><span class="s1">../parse-error</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import { isIdentifierChar, isIdentifierStart } from </span><span class="s2">\&quot;</span><span class="s1">../util/identifier</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import { lineBreak } from </span><span class="s2">\&quot;</span><span class="s1">../util/whitespace</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import * as charCodes from </span><span class="s2">\&quot;</span><span class="s1">charcodes</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import {</span><span class="s2">\n  </span><span class="s1">BIND_CLASS,</span><span class="s2">\n  </span><span class="s1">BIND_LEXICAL,</span><span class="s2">\n  </span><span class="s1">BIND_VAR,</span><span class="s2">\n  </span><span class="s1">BIND_FUNCTION,</span><span class="s2">\n  </span><span class="s1">SCOPE_CLASS,</span><span class="s2">\n  </span><span class="s1">SCOPE_FUNCTION,</span><span class="s2">\n  </span><span class="s1">SCOPE_OTHER,</span><span class="s2">\n  </span><span class="s1">SCOPE_SIMPLE_CATCH,</span><span class="s2">\n  </span><span class="s1">SCOPE_STATIC_BLOCK,</span><span class="s2">\n  </span><span class="s1">SCOPE_SUPER,</span><span class="s2">\n  </span><span class="s1">CLASS_ELEMENT_OTHER,</span><span class="s2">\n  </span><span class="s1">CLASS_ELEMENT_INSTANCE_GETTER,</span><span class="s2">\n  </span><span class="s1">CLASS_ELEMENT_INSTANCE_SETTER,</span><span class="s2">\n  </span><span class="s1">CLASS_ELEMENT_STATIC_GETTER,</span><span class="s2">\n  </span><span class="s1">CLASS_ELEMENT_STATIC_SETTER,</span><span class="s2">\n  </span><span class="s1">type BindingTypes,</span><span class="s2">\n  </span><span class="s1">BIND_CATCH_PARAM,</span><span class="s2">\n</span><span class="s1">} from </span><span class="s2">\&quot;</span><span class="s1">../util/scopeflags</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import { ExpressionErrors } from </span><span class="s2">\&quot;</span><span class="s1">./util</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import { PARAM, functionFlags } from </span><span class="s2">\&quot;</span><span class="s1">../util/production-parameter</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import {</span><span class="s2">\n  </span><span class="s1">newExpressionScope,</span><span class="s2">\n  </span><span class="s1">newParameterDeclarationScope,</span><span class="s2">\n</span><span class="s1">} from </span><span class="s2">\&quot;</span><span class="s1">../util/expression-scope</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type { SourceType } from </span><span class="s2">\&quot;</span><span class="s1">../options</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import { Token } from </span><span class="s2">\&quot;</span><span class="s1">../tokenizer</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type { Position } from </span><span class="s2">\&quot;</span><span class="s1">../util/location</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import { createPositionWithColumnOffset } from </span><span class="s2">\&quot;</span><span class="s1">../util/location</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import { cloneStringLiteral, cloneIdentifier, type Undone } from </span><span class="s2">\&quot;</span><span class="s1">./node</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type Parser from </span><span class="s2">\&quot;</span><span class="s1">./index</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import { ParseBindingListFlags } from </span><span class="s2">\&quot;</span><span class="s1">./lval</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">const loopLabel = { kind: </span><span class="s2">\&quot;</span><span class="s1">loop</span><span class="s2">\&quot; </span><span class="s1">} as const,</span><span class="s2">\n  </span><span class="s1">switchLabel = { kind: </span><span class="s2">\&quot;</span><span class="s1">switch</span><span class="s2">\&quot; </span><span class="s1">} as const;</span><span class="s2">\n\n</span><span class="s1">export const enum ParseFunctionFlag {</span><span class="s2">\n  </span><span class="s1">Expression = 0b0000,</span><span class="s2">\n  </span><span class="s1">Declaration = 0b0001,</span><span class="s2">\n  </span><span class="s1">HangingDeclaration = 0b0010,</span><span class="s2">\n  </span><span class="s1">NullableId = 0b0100,</span><span class="s2">\n  </span><span class="s1">Async = 0b1000,</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">export const enum ParseStatementFlag {</span><span class="s2">\n  </span><span class="s1">StatementOnly = 0b0000,</span><span class="s2">\n  </span><span class="s1">AllowImportExport = 0b0001,</span><span class="s2">\n  </span><span class="s1">AllowDeclaration = 0b0010,</span><span class="s2">\n  </span><span class="s1">AllowFunctionDeclaration = 0b0100,</span><span class="s2">\n  </span><span class="s1">AllowLabeledFunction = 0b1000,</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">const loneSurrogate = /[</span><span class="s2">\\</span><span class="s1">uD800-</span><span class="s2">\\</span><span class="s1">uDFFF]/u;</span><span class="s2">\n\n</span><span class="s1">const keywordRelationalOperator = /in(?:stanceof)?/y;</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Convert tokens for backward Babel 7 compat.</span><span class="s2">\n </span><span class="s1">* tt.privateName =&gt; tt.hash + tt.name</span><span class="s2">\n </span><span class="s1">* tt.templateTail =&gt; tt.backquote/tt.braceR + tt.template + tt.backquote</span><span class="s2">\n </span><span class="s1">* tt.templateNonTail =&gt; tt.backquote/tt.braceR + tt.template + tt.dollarBraceL</span><span class="s2">\n </span><span class="s1">* For performance reasons this routine mutates `tokens`, it is okay</span><span class="s2">\n </span><span class="s1">* here since we execute `parseTopLevel` once for every file.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function babel7CompatTokens(tokens: (Token | N.Comment)[], input: string) {</span><span class="s2">\n  </span><span class="s1">for (let i = 0; i &lt; tokens.length; i++) {</span><span class="s2">\n    </span><span class="s1">const token = tokens[i];</span><span class="s2">\n    </span><span class="s1">const { type } = token;</span><span class="s2">\n    </span><span class="s1">if (typeof type === </span><span class="s2">\&quot;</span><span class="s1">number</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">if (!process.env.BABEL_8_BREAKING) {</span><span class="s2">\n        </span><span class="s1">if (type === tt.privateName) {</span><span class="s2">\n          </span><span class="s1">const { loc, start, value, end } = token;</span><span class="s2">\n          </span><span class="s1">const hashEndPos = start + 1;</span><span class="s2">\n          </span><span class="s1">const hashEndLoc = createPositionWithColumnOffset(loc.start, 1);</span><span class="s2">\n          </span><span class="s1">tokens.splice(</span><span class="s2">\n            </span><span class="s1">i,</span><span class="s2">\n            </span><span class="s1">1,</span><span class="s2">\n            </span><span class="s1">new Token({</span><span class="s2">\n              </span><span class="s1">// @ts-expect-error: hacky way to create token</span><span class="s2">\n              </span><span class="s1">type: getExportedToken(tt.hash),</span><span class="s2">\n              </span><span class="s1">value: </span><span class="s2">\&quot;</span><span class="s1">#</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n              </span><span class="s1">start: start,</span><span class="s2">\n              </span><span class="s1">end: hashEndPos,</span><span class="s2">\n              </span><span class="s1">startLoc: loc.start,</span><span class="s2">\n              </span><span class="s1">endLoc: hashEndLoc,</span><span class="s2">\n            </span><span class="s1">}),</span><span class="s2">\n            </span><span class="s1">new Token({</span><span class="s2">\n              </span><span class="s1">// @ts-expect-error: hacky way to create token</span><span class="s2">\n              </span><span class="s1">type: getExportedToken(tt.name),</span><span class="s2">\n              </span><span class="s1">value: value,</span><span class="s2">\n              </span><span class="s1">start: hashEndPos,</span><span class="s2">\n              </span><span class="s1">end: end,</span><span class="s2">\n              </span><span class="s1">startLoc: hashEndLoc,</span><span class="s2">\n              </span><span class="s1">endLoc: loc.end,</span><span class="s2">\n            </span><span class="s1">}),</span><span class="s2">\n          </span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">i++;</span><span class="s2">\n          </span><span class="s1">continue;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">if (tokenIsTemplate(type)) {</span><span class="s2">\n          </span><span class="s1">const { loc, start, value, end } = token;</span><span class="s2">\n          </span><span class="s1">const backquoteEnd = start + 1;</span><span class="s2">\n          </span><span class="s1">const backquoteEndLoc = createPositionWithColumnOffset(loc.start, 1);</span><span class="s2">\n          </span><span class="s1">let startToken;</span><span class="s2">\n          </span><span class="s1">if (input.charCodeAt(start) === charCodes.graveAccent) {</span><span class="s2">\n            </span><span class="s1">startToken = new Token({</span><span class="s2">\n              </span><span class="s1">// @ts-expect-error: hacky way to create token</span><span class="s2">\n              </span><span class="s1">type: getExportedToken(tt.backQuote),</span><span class="s2">\n              </span><span class="s1">value: </span><span class="s2">\&quot;</span><span class="s1">`</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n              </span><span class="s1">start: start,</span><span class="s2">\n              </span><span class="s1">end: backquoteEnd,</span><span class="s2">\n              </span><span class="s1">startLoc: loc.start,</span><span class="s2">\n              </span><span class="s1">endLoc: backquoteEndLoc,</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n          </span><span class="s1">} else {</span><span class="s2">\n            </span><span class="s1">startToken = new Token({</span><span class="s2">\n              </span><span class="s1">// @ts-expect-error: hacky way to create token</span><span class="s2">\n              </span><span class="s1">type: getExportedToken(tt.braceR),</span><span class="s2">\n              </span><span class="s1">value: </span><span class="s2">\&quot;</span><span class="s1">}</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n              </span><span class="s1">start: start,</span><span class="s2">\n              </span><span class="s1">end: backquoteEnd,</span><span class="s2">\n              </span><span class="s1">startLoc: loc.start,</span><span class="s2">\n              </span><span class="s1">endLoc: backquoteEndLoc,</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">let templateValue,</span><span class="s2">\n            </span><span class="s1">templateElementEnd,</span><span class="s2">\n            </span><span class="s1">templateElementEndLoc,</span><span class="s2">\n            </span><span class="s1">endToken;</span><span class="s2">\n          </span><span class="s1">if (type === tt.templateTail) {</span><span class="s2">\n            </span><span class="s1">// ends with '`'</span><span class="s2">\n            </span><span class="s1">templateElementEnd = end - 1;</span><span class="s2">\n            </span><span class="s1">templateElementEndLoc = createPositionWithColumnOffset(loc.end, -1);</span><span class="s2">\n            </span><span class="s1">templateValue = value === null ? null : value.slice(1, -1);</span><span class="s2">\n            </span><span class="s1">endToken = new Token({</span><span class="s2">\n              </span><span class="s1">// @ts-expect-error: hacky way to create token</span><span class="s2">\n              </span><span class="s1">type: getExportedToken(tt.backQuote),</span><span class="s2">\n              </span><span class="s1">value: </span><span class="s2">\&quot;</span><span class="s1">`</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n              </span><span class="s1">start: templateElementEnd,</span><span class="s2">\n              </span><span class="s1">end: end,</span><span class="s2">\n              </span><span class="s1">startLoc: templateElementEndLoc,</span><span class="s2">\n              </span><span class="s1">endLoc: loc.end,</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n          </span><span class="s1">} else {</span><span class="s2">\n            </span><span class="s1">// ends with `${`</span><span class="s2">\n            </span><span class="s1">templateElementEnd = end - 2;</span><span class="s2">\n            </span><span class="s1">templateElementEndLoc = createPositionWithColumnOffset(loc.end, -2);</span><span class="s2">\n            </span><span class="s1">templateValue = value === null ? null : value.slice(1, -2);</span><span class="s2">\n            </span><span class="s1">endToken = new Token({</span><span class="s2">\n              </span><span class="s1">// @ts-expect-error: hacky way to create token</span><span class="s2">\n              </span><span class="s1">type: getExportedToken(tt.dollarBraceL),</span><span class="s2">\n              </span><span class="s1">value: </span><span class="s2">\&quot;</span><span class="s1">${</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n              </span><span class="s1">start: templateElementEnd,</span><span class="s2">\n              </span><span class="s1">end: end,</span><span class="s2">\n              </span><span class="s1">startLoc: templateElementEndLoc,</span><span class="s2">\n              </span><span class="s1">endLoc: loc.end,</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">tokens.splice(</span><span class="s2">\n            </span><span class="s1">i,</span><span class="s2">\n            </span><span class="s1">1,</span><span class="s2">\n            </span><span class="s1">startToken,</span><span class="s2">\n            </span><span class="s1">new Token({</span><span class="s2">\n              </span><span class="s1">// @ts-expect-error: hacky way to create token</span><span class="s2">\n              </span><span class="s1">type: getExportedToken(tt.template),</span><span class="s2">\n              </span><span class="s1">value: templateValue,</span><span class="s2">\n              </span><span class="s1">start: backquoteEnd,</span><span class="s2">\n              </span><span class="s1">end: templateElementEnd,</span><span class="s2">\n              </span><span class="s1">startLoc: backquoteEndLoc,</span><span class="s2">\n              </span><span class="s1">endLoc: templateElementEndLoc,</span><span class="s2">\n            </span><span class="s1">}),</span><span class="s2">\n            </span><span class="s1">endToken,</span><span class="s2">\n          </span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">i += 2;</span><span class="s2">\n          </span><span class="s1">continue;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">// @ts-expect-error: we manipulate `token` for performance reasons</span><span class="s2">\n      </span><span class="s1">token.type = getExportedToken(type);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return tokens;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">export default abstract class StatementParser extends ExpressionParser {</span><span class="s2">\n  </span><span class="s1">// ### Statement parsing</span><span class="s2">\n\n  </span><span class="s1">// Parse a program. Initializes the parser, reads any number of</span><span class="s2">\n  </span><span class="s1">// statements, and wraps them in a Program node.  Optionally takes a</span><span class="s2">\n  </span><span class="s1">// `program` argument.  If present, the statements will be appended</span><span class="s2">\n  </span><span class="s1">// to its body instead of creating a new node.</span><span class="s2">\n\n  </span><span class="s1">parseTopLevel(this: Parser, file: N.File, program: N.Program): N.File {</span><span class="s2">\n    </span><span class="s1">file.program = this.parseProgram(program);</span><span class="s2">\n    </span><span class="s1">file.comments = this.state.comments;</span><span class="s2">\n\n    </span><span class="s1">if (this.options.tokens) {</span><span class="s2">\n      </span><span class="s1">file.tokens = babel7CompatTokens(this.tokens, this.input);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">return this.finishNode(file, </span><span class="s2">\&quot;</span><span class="s1">File</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">parseProgram(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">program: Undone&lt;N.Program&gt;,</span><span class="s2">\n    </span><span class="s1">end: TokenType = tt.eof,</span><span class="s2">\n    </span><span class="s1">sourceType: SourceType = this.options.sourceType,</span><span class="s2">\n  </span><span class="s1">): N.Program {</span><span class="s2">\n    </span><span class="s1">program.sourceType = sourceType;</span><span class="s2">\n    </span><span class="s1">program.interpreter = this.parseInterpreterDirective();</span><span class="s2">\n    </span><span class="s1">this.parseBlockBody(program, true, true, end);</span><span class="s2">\n    </span><span class="s1">if (</span><span class="s2">\n      </span><span class="s1">this.inModule &amp;&amp;</span><span class="s2">\n      </span><span class="s1">!this.options.allowUndeclaredExports &amp;&amp;</span><span class="s2">\n      </span><span class="s1">this.scope.undefinedExports.size &gt; 0</span><span class="s2">\n    </span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">for (const [localName, at] of Array.from(this.scope.undefinedExports)) {</span><span class="s2">\n        </span><span class="s1">this.raise(Errors.ModuleExportUndefined, { at, localName });</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let finishedProgram: N.Program;</span><span class="s2">\n    </span><span class="s1">if (end === tt.eof) {</span><span class="s2">\n      </span><span class="s1">// finish at eof for top level program</span><span class="s2">\n      </span><span class="s1">finishedProgram = this.finishNode(program, </span><span class="s2">\&quot;</span><span class="s1">Program</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">// finish immediately before the end token</span><span class="s2">\n      </span><span class="s1">finishedProgram = this.finishNodeAt(</span><span class="s2">\n        </span><span class="s1">program,</span><span class="s2">\n        \&quot;</span><span class="s1">Program</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">createPositionWithColumnOffset(this.state.startLoc, -1),</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return finishedProgram;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* cast a Statement to a Directive. This method mutates input statement.</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">stmtToDirective(stmt: N.Statement): N.Directive {</span><span class="s2">\n    </span><span class="s1">const directive = stmt as any;</span><span class="s2">\n    </span><span class="s1">directive.type = </span><span class="s2">\&quot;</span><span class="s1">Directive</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n    </span><span class="s1">directive.value = directive.expression;</span><span class="s2">\n    </span><span class="s1">delete directive.expression;</span><span class="s2">\n\n    </span><span class="s1">const directiveLiteral = directive.value;</span><span class="s2">\n    </span><span class="s1">const expressionValue = directiveLiteral.value;</span><span class="s2">\n    </span><span class="s1">const raw = this.input.slice(directiveLiteral.start, directiveLiteral.end);</span><span class="s2">\n    </span><span class="s1">const val = (directiveLiteral.value = raw.slice(1, -1)); // remove quotes</span><span class="s2">\n\n    </span><span class="s1">this.addExtra(directiveLiteral, </span><span class="s2">\&quot;</span><span class="s1">raw</span><span class="s2">\&quot;</span><span class="s1">, raw);</span><span class="s2">\n    </span><span class="s1">this.addExtra(directiveLiteral, </span><span class="s2">\&quot;</span><span class="s1">rawValue</span><span class="s2">\&quot;</span><span class="s1">, val);</span><span class="s2">\n    </span><span class="s1">this.addExtra(directiveLiteral, </span><span class="s2">\&quot;</span><span class="s1">expressionValue</span><span class="s2">\&quot;</span><span class="s1">, expressionValue);</span><span class="s2">\n\n    </span><span class="s1">directiveLiteral.type = </span><span class="s2">\&quot;</span><span class="s1">DirectiveLiteral</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n    </span><span class="s1">return directive;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">parseInterpreterDirective(): N.InterpreterDirective | null {</span><span class="s2">\n    </span><span class="s1">if (!this.match(tt.interpreterDirective)) {</span><span class="s2">\n      </span><span class="s1">return null;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">const node = this.startNode&lt;N.InterpreterDirective&gt;();</span><span class="s2">\n    </span><span class="s1">node.value = this.state.value;</span><span class="s2">\n    </span><span class="s1">this.next();</span><span class="s2">\n    </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">InterpreterDirective</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">isLet(): boolean {</span><span class="s2">\n    </span><span class="s1">if (!this.isContextual(tt._let)) {</span><span class="s2">\n      </span><span class="s1">return false;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return this.hasFollowingBindingAtom();</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">chStartsBindingIdentifier(ch: number, pos: number) {</span><span class="s2">\n    </span><span class="s1">if (isIdentifierStart(ch)) {</span><span class="s2">\n      </span><span class="s1">keywordRelationalOperator.lastIndex = pos;</span><span class="s2">\n      </span><span class="s1">if (keywordRelationalOperator.test(this.input)) {</span><span class="s2">\n        </span><span class="s1">// We have seen `in` or `instanceof` so far, now check if the identifier</span><span class="s2">\n        </span><span class="s1">// ends here</span><span class="s2">\n        </span><span class="s1">const endCh = this.codePointAtPos(keywordRelationalOperator.lastIndex);</span><span class="s2">\n        </span><span class="s1">if (!isIdentifierChar(endCh) &amp;&amp; endCh !== charCodes.backslash) {</span><span class="s2">\n          </span><span class="s1">return false;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return true;</span><span class="s2">\n    </span><span class="s1">} else if (ch === charCodes.backslash) {</span><span class="s2">\n      </span><span class="s1">return true;</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">return false;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">chStartsBindingPattern(ch: number) {</span><span class="s2">\n    </span><span class="s1">return (</span><span class="s2">\n      </span><span class="s1">ch === charCodes.leftSquareBracket || ch === charCodes.leftCurlyBrace</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* Assuming we have seen a contextual `let` and declaration is allowed, check if it</span><span class="s2">\n   </span><span class="s1">* starts a variable declaration so that it should be interpreted as a keyword.</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">hasFollowingBindingAtom(): boolean {</span><span class="s2">\n    </span><span class="s1">const next = this.nextTokenStart();</span><span class="s2">\n    </span><span class="s1">const nextCh = this.codePointAtPos(next);</span><span class="s2">\n    </span><span class="s1">return (</span><span class="s2">\n      </span><span class="s1">this.chStartsBindingPattern(nextCh) ||</span><span class="s2">\n      </span><span class="s1">this.chStartsBindingIdentifier(nextCh, next)</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* Assuming we have seen a contextual `using` and declaration is allowed, check if it</span><span class="s2">\n   </span><span class="s1">* starts a variable declaration in the same line so that it should be interpreted as</span><span class="s2">\n   </span><span class="s1">* a keyword.</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">hasInLineFollowingBindingIdentifier(): boolean {</span><span class="s2">\n    </span><span class="s1">const next = this.nextTokenInLineStart();</span><span class="s2">\n    </span><span class="s1">const nextCh = this.codePointAtPos(next);</span><span class="s2">\n    </span><span class="s1">return this.chStartsBindingIdentifier(nextCh, next);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">startsUsingForOf(): boolean {</span><span class="s2">\n    </span><span class="s1">const { type, containsEsc } = this.lookahead();</span><span class="s2">\n    </span><span class="s1">if (type === tt._of &amp;&amp; !containsEsc) {</span><span class="s2">\n      </span><span class="s1">// `using of` must start a for-lhs-of statement</span><span class="s2">\n      </span><span class="s1">return false;</span><span class="s2">\n    </span><span class="s1">} else if (tokenIsIdentifier(type) &amp;&amp; !this.hasFollowingLineBreak()) {</span><span class="s2">\n      </span><span class="s1">this.expectPlugin(</span><span class="s2">\&quot;</span><span class="s1">explicitResourceManagement</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">return true;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// https://tc39.es/ecma262/#prod-ModuleItem</span><span class="s2">\n  </span><span class="s1">parseModuleItem(this: Parser) {</span><span class="s2">\n    </span><span class="s1">return this.parseStatementLike(</span><span class="s2">\n      </span><span class="s1">ParseStatementFlag.AllowImportExport |</span><span class="s2">\n        </span><span class="s1">ParseStatementFlag.AllowDeclaration |</span><span class="s2">\n        </span><span class="s1">ParseStatementFlag.AllowFunctionDeclaration |</span><span class="s2">\n        </span><span class="s1">// This function is actually also used to parse StatementItems,</span><span class="s2">\n        </span><span class="s1">// which with Annex B enabled allows labeled functions.</span><span class="s2">\n        </span><span class="s1">ParseStatementFlag.AllowLabeledFunction,</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// https://tc39.es/ecma262/#prod-StatementListItem</span><span class="s2">\n  </span><span class="s1">parseStatementListItem(this: Parser) {</span><span class="s2">\n    </span><span class="s1">return this.parseStatementLike(</span><span class="s2">\n      </span><span class="s1">ParseStatementFlag.AllowDeclaration |</span><span class="s2">\n        </span><span class="s1">ParseStatementFlag.AllowFunctionDeclaration |</span><span class="s2">\n        </span><span class="s1">(!this.options.annexB || this.state.strict</span><span class="s2">\n          </span><span class="s1">? 0</span><span class="s2">\n          </span><span class="s1">: ParseStatementFlag.AllowLabeledFunction),</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">parseStatementOrSloppyAnnexBFunctionDeclaration(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">allowLabeledFunction: boolean = false,</span><span class="s2">\n  </span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">let flags: ParseStatementFlag = ParseStatementFlag.StatementOnly;</span><span class="s2">\n    </span><span class="s1">if (this.options.annexB &amp;&amp; !this.state.strict) {</span><span class="s2">\n      </span><span class="s1">flags |= ParseStatementFlag.AllowFunctionDeclaration;</span><span class="s2">\n      </span><span class="s1">if (allowLabeledFunction) {</span><span class="s2">\n        </span><span class="s1">flags |= ParseStatementFlag.AllowLabeledFunction;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return this.parseStatementLike(flags);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Parse a single statement.</span><span class="s2">\n  </span><span class="s1">//</span><span class="s2">\n  </span><span class="s1">// If expecting a statement and finding a slash operator, parse a</span><span class="s2">\n  </span><span class="s1">// regular expression literal. This is to handle cases like</span><span class="s2">\n  </span><span class="s1">// `if (foo) /blah/.exec(foo)`, where looking at the previous token</span><span class="s2">\n  </span><span class="s1">// does not help.</span><span class="s2">\n  </span><span class="s1">// https://tc39.es/ecma262/#prod-Statement</span><span class="s2">\n  </span><span class="s1">parseStatement(this: Parser) {</span><span class="s2">\n    </span><span class="s1">return this.parseStatementLike(ParseStatementFlag.StatementOnly);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// ImportDeclaration and ExportDeclaration are also handled here so we can throw recoverable errors</span><span class="s2">\n  </span><span class="s1">// when they are not at the top level</span><span class="s2">\n  </span><span class="s1">parseStatementLike(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">flags: ParseStatementFlag,</span><span class="s2">\n  </span><span class="s1">):</span><span class="s2">\n    </span><span class="s1">| N.Statement</span><span class="s2">\n    </span><span class="s1">| N.Declaration</span><span class="s2">\n    </span><span class="s1">| N.ImportDeclaration</span><span class="s2">\n    </span><span class="s1">| N.ExportDefaultDeclaration</span><span class="s2">\n    </span><span class="s1">| N.ExportNamedDeclaration</span><span class="s2">\n    </span><span class="s1">| N.ExportAllDeclaration {</span><span class="s2">\n    </span><span class="s1">let decorators: N.Decorator[] | null = null;</span><span class="s2">\n\n    </span><span class="s1">if (this.match(tt.at)) {</span><span class="s2">\n      </span><span class="s1">decorators = this.parseDecorators(true);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return this.parseStatementContent(flags, decorators);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">parseStatementContent(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">flags: ParseStatementFlag,</span><span class="s2">\n    </span><span class="s1">decorators?: N.Decorator[] | null,</span><span class="s2">\n  </span><span class="s1">): N.Statement {</span><span class="s2">\n    </span><span class="s1">const starttype = this.state.type;</span><span class="s2">\n    </span><span class="s1">const node = this.startNode();</span><span class="s2">\n    </span><span class="s1">const allowDeclaration = !!(flags &amp; ParseStatementFlag.AllowDeclaration);</span><span class="s2">\n    </span><span class="s1">const allowFunctionDeclaration = !!(</span><span class="s2">\n      </span><span class="s1">flags &amp; ParseStatementFlag.AllowFunctionDeclaration</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">const topLevel = flags &amp; ParseStatementFlag.AllowImportExport;</span><span class="s2">\n\n    </span><span class="s1">// Most types of statements are recognized by the keyword they</span><span class="s2">\n    </span><span class="s1">// start with. Many are trivial to parse, some require a bit of</span><span class="s2">\n    </span><span class="s1">// complexity.</span><span class="s2">\n\n    </span><span class="s1">switch (starttype) {</span><span class="s2">\n      </span><span class="s1">case tt._break:</span><span class="s2">\n        </span><span class="s1">return this.parseBreakContinueStatement(node, /* isBreak */ true);</span><span class="s2">\n      </span><span class="s1">case tt._continue:</span><span class="s2">\n        </span><span class="s1">return this.parseBreakContinueStatement(node, /* isBreak */ false);</span><span class="s2">\n      </span><span class="s1">case tt._debugger:</span><span class="s2">\n        </span><span class="s1">return this.parseDebuggerStatement(node as Undone&lt;N.DebuggerStatement&gt;);</span><span class="s2">\n      </span><span class="s1">case tt._do:</span><span class="s2">\n        </span><span class="s1">return this.parseDoWhileStatement(node as Undone&lt;N.DoWhileStatement&gt;);</span><span class="s2">\n      </span><span class="s1">case tt._for:</span><span class="s2">\n        </span><span class="s1">return this.parseForStatement(node as Undone&lt;N.ForStatement&gt;);</span><span class="s2">\n      </span><span class="s1">case tt._function:</span><span class="s2">\n        </span><span class="s1">if (this.lookaheadCharCode() === charCodes.dot) break;</span><span class="s2">\n        </span><span class="s1">if (!allowFunctionDeclaration) {</span><span class="s2">\n          </span><span class="s1">this.raise(</span><span class="s2">\n            </span><span class="s1">this.state.strict</span><span class="s2">\n              </span><span class="s1">? Errors.StrictFunction</span><span class="s2">\n              </span><span class="s1">: this.options.annexB</span><span class="s2">\n              </span><span class="s1">? Errors.SloppyFunctionAnnexB</span><span class="s2">\n              </span><span class="s1">: Errors.SloppyFunction,</span><span class="s2">\n            </span><span class="s1">{ at: this.state.startLoc },</span><span class="s2">\n          </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return this.parseFunctionStatement(</span><span class="s2">\n          </span><span class="s1">node as Undone&lt;N.FunctionDeclaration&gt;,</span><span class="s2">\n          </span><span class="s1">false,</span><span class="s2">\n          </span><span class="s1">!allowDeclaration &amp;&amp; allowFunctionDeclaration,</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">case tt._class:</span><span class="s2">\n        </span><span class="s1">if (!allowDeclaration) this.unexpected();</span><span class="s2">\n        </span><span class="s1">return this.parseClass(</span><span class="s2">\n          </span><span class="s1">this.maybeTakeDecorators(</span><span class="s2">\n            </span><span class="s1">decorators,</span><span class="s2">\n            </span><span class="s1">node as Undone&lt;N.ClassDeclaration&gt;,</span><span class="s2">\n          </span><span class="s1">),</span><span class="s2">\n          </span><span class="s1">true,</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n\n      </span><span class="s1">case tt._if:</span><span class="s2">\n        </span><span class="s1">return this.parseIfStatement(node as Undone&lt;N.IfStatement&gt;);</span><span class="s2">\n      </span><span class="s1">case tt._return:</span><span class="s2">\n        </span><span class="s1">return this.parseReturnStatement(node as Undone&lt;N.ReturnStatement&gt;);</span><span class="s2">\n      </span><span class="s1">case tt._switch:</span><span class="s2">\n        </span><span class="s1">return this.parseSwitchStatement(node as Undone&lt;N.SwitchStatement&gt;);</span><span class="s2">\n      </span><span class="s1">case tt._throw:</span><span class="s2">\n        </span><span class="s1">return this.parseThrowStatement(node as Undone&lt;N.ThrowStatement&gt;);</span><span class="s2">\n      </span><span class="s1">case tt._try:</span><span class="s2">\n        </span><span class="s1">return this.parseTryStatement(node as Undone&lt;N.TryStatement&gt;);</span><span class="s2">\n\n      </span><span class="s1">case tt._using:</span><span class="s2">\n        </span><span class="s1">// using [no LineTerminator here][lookahead != `await`] BindingList[+Using]</span><span class="s2">\n        </span><span class="s1">if (</span><span class="s2">\n          </span><span class="s1">this.state.containsEsc ||</span><span class="s2">\n          </span><span class="s1">!this.hasInLineFollowingBindingIdentifier()</span><span class="s2">\n        </span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">break;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">this.expectPlugin(</span><span class="s2">\&quot;</span><span class="s1">explicitResourceManagement</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">if (!this.scope.inModule &amp;&amp; this.scope.inTopLevel) {</span><span class="s2">\n          </span><span class="s1">this.raise(Errors.UnexpectedUsingDeclaration, {</span><span class="s2">\n            </span><span class="s1">at: this.state.startLoc,</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">} else if (!allowDeclaration) {</span><span class="s2">\n          </span><span class="s1">this.raise(Errors.UnexpectedLexicalDeclaration, {</span><span class="s2">\n            </span><span class="s1">at: this.state.startLoc,</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return this.parseVarStatement(</span><span class="s2">\n          </span><span class="s1">node as Undone&lt;N.VariableDeclaration&gt;,</span><span class="s2">\n          \&quot;</span><span class="s1">using</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">case tt._let: {</span><span class="s2">\n        </span><span class="s1">if (this.state.containsEsc) {</span><span class="s2">\n          </span><span class="s1">break;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// `let [` is an explicit negative lookahead for</span><span class="s2">\n        </span><span class="s1">// ExpressionStatement, so special-case it first.</span><span class="s2">\n        </span><span class="s1">const next = this.nextTokenStart();</span><span class="s2">\n        </span><span class="s1">const nextCh = this.codePointAtPos(next);</span><span class="s2">\n        </span><span class="s1">if (nextCh !== charCodes.leftSquareBracket) {</span><span class="s2">\n          </span><span class="s1">if (!allowDeclaration &amp;&amp; this.hasFollowingLineBreak()) break;</span><span class="s2">\n          </span><span class="s1">if (</span><span class="s2">\n            </span><span class="s1">!this.chStartsBindingIdentifier(nextCh, next) &amp;&amp;</span><span class="s2">\n            </span><span class="s1">nextCh !== charCodes.leftCurlyBrace</span><span class="s2">\n          </span><span class="s1">) {</span><span class="s2">\n            </span><span class="s1">break;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">// fall through</span><span class="s2">\n      </span><span class="s1">case tt._const: {</span><span class="s2">\n        </span><span class="s1">if (!allowDeclaration) {</span><span class="s2">\n          </span><span class="s1">this.raise(Errors.UnexpectedLexicalDeclaration, {</span><span class="s2">\n            </span><span class="s1">at: this.state.startLoc,</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">// fall through</span><span class="s2">\n      </span><span class="s1">case tt._var: {</span><span class="s2">\n        </span><span class="s1">const kind = this.state.value;</span><span class="s2">\n        </span><span class="s1">return this.parseVarStatement(</span><span class="s2">\n          </span><span class="s1">node as Undone&lt;N.VariableDeclaration&gt;,</span><span class="s2">\n          </span><span class="s1">kind,</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">case tt._while:</span><span class="s2">\n        </span><span class="s1">return this.parseWhileStatement(node as Undone&lt;N.WhileStatement&gt;);</span><span class="s2">\n      </span><span class="s1">case tt._with:</span><span class="s2">\n        </span><span class="s1">return this.parseWithStatement(node as Undone&lt;N.WithStatement&gt;);</span><span class="s2">\n      </span><span class="s1">case tt.braceL:</span><span class="s2">\n        </span><span class="s1">return this.parseBlock();</span><span class="s2">\n      </span><span class="s1">case tt.semi:</span><span class="s2">\n        </span><span class="s1">return this.parseEmptyStatement(node as Undone&lt;N.EmptyStatement&gt;);</span><span class="s2">\n      </span><span class="s1">case tt._import: {</span><span class="s2">\n        </span><span class="s1">const nextTokenCharCode = this.lookaheadCharCode();</span><span class="s2">\n        </span><span class="s1">if (</span><span class="s2">\n          </span><span class="s1">nextTokenCharCode === charCodes.leftParenthesis || // import()</span><span class="s2">\n          </span><span class="s1">nextTokenCharCode === charCodes.dot // import.meta</span><span class="s2">\n        </span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">break;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">// fall through</span><span class="s2">\n      </span><span class="s1">case tt._export: {</span><span class="s2">\n        </span><span class="s1">if (!this.options.allowImportExportEverywhere &amp;&amp; !topLevel) {</span><span class="s2">\n          </span><span class="s1">this.raise(Errors.UnexpectedImportExport, {</span><span class="s2">\n            </span><span class="s1">at: this.state.startLoc,</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">this.next(); // eat `import`/`export`</span><span class="s2">\n\n        </span><span class="s1">let result;</span><span class="s2">\n        </span><span class="s1">if (starttype === tt._import) {</span><span class="s2">\n          </span><span class="s1">result = this.parseImport(node as Undone&lt;N.ImportDeclaration&gt;);</span><span class="s2">\n\n          </span><span class="s1">if (</span><span class="s2">\n            </span><span class="s1">result.type === </span><span class="s2">\&quot;</span><span class="s1">ImportDeclaration</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n            </span><span class="s1">(!result.importKind || result.importKind === </span><span class="s2">\&quot;</span><span class="s1">value</span><span class="s2">\&quot;</span><span class="s1">)</span><span class="s2">\n          </span><span class="s1">) {</span><span class="s2">\n            </span><span class="s1">this.sawUnambiguousESM = true;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">result = this.parseExport(</span><span class="s2">\n            </span><span class="s1">node as Undone&lt;</span><span class="s2">\n              </span><span class="s1">| N.ExportAllDeclaration</span><span class="s2">\n              </span><span class="s1">| N.ExportDefaultDeclaration</span><span class="s2">\n              </span><span class="s1">| N.ExportDefaultDeclaration</span><span class="s2">\n            </span><span class="s1">&gt;,</span><span class="s2">\n            </span><span class="s1">decorators,</span><span class="s2">\n          </span><span class="s1">);</span><span class="s2">\n\n          </span><span class="s1">if (</span><span class="s2">\n            </span><span class="s1">(result.type === </span><span class="s2">\&quot;</span><span class="s1">ExportNamedDeclaration</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n              </span><span class="s1">(!result.exportKind || result.exportKind === </span><span class="s2">\&quot;</span><span class="s1">value</span><span class="s2">\&quot;</span><span class="s1">)) ||</span><span class="s2">\n            </span><span class="s1">(result.type === </span><span class="s2">\&quot;</span><span class="s1">ExportAllDeclaration</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n              </span><span class="s1">(!result.exportKind || result.exportKind === </span><span class="s2">\&quot;</span><span class="s1">value</span><span class="s2">\&quot;</span><span class="s1">)) ||</span><span class="s2">\n            </span><span class="s1">result.type === </span><span class="s2">\&quot;</span><span class="s1">ExportDefaultDeclaration</span><span class="s2">\&quot;\n          </span><span class="s1">) {</span><span class="s2">\n            </span><span class="s1">this.sawUnambiguousESM = true;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">this.assertModuleNodeAllowed(result);</span><span class="s2">\n\n        </span><span class="s1">return result;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">default: {</span><span class="s2">\n        </span><span class="s1">if (this.isAsyncFunction()) {</span><span class="s2">\n          </span><span class="s1">if (!allowDeclaration) {</span><span class="s2">\n            </span><span class="s1">this.raise(Errors.AsyncFunctionInSingleStatementContext, {</span><span class="s2">\n              </span><span class="s1">at: this.state.startLoc,</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">this.next(); // eat 'async'</span><span class="s2">\n          </span><span class="s1">return this.parseFunctionStatement(</span><span class="s2">\n            </span><span class="s1">node as Undone&lt;N.FunctionDeclaration&gt;,</span><span class="s2">\n            </span><span class="s1">true,</span><span class="s2">\n            </span><span class="s1">!allowDeclaration &amp;&amp; allowFunctionDeclaration,</span><span class="s2">\n          </span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// If the statement does not start with a statement keyword or a</span><span class="s2">\n    </span><span class="s1">// brace, it's an ExpressionStatement or LabeledStatement. We</span><span class="s2">\n    </span><span class="s1">// simply start parsing an expression, and afterwards, if the</span><span class="s2">\n    </span><span class="s1">// next token is a colon and the expression was a simple</span><span class="s2">\n    </span><span class="s1">// Identifier node, we switch to interpreting it as a label.</span><span class="s2">\n    </span><span class="s1">const maybeName = this.state.value;</span><span class="s2">\n    </span><span class="s1">const expr = this.parseExpression();</span><span class="s2">\n\n    </span><span class="s1">if (</span><span class="s2">\n      </span><span class="s1">tokenIsIdentifier(starttype) &amp;&amp;</span><span class="s2">\n      </span><span class="s1">expr.type === </span><span class="s2">\&quot;</span><span class="s1">Identifier</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n      </span><span class="s1">this.eat(tt.colon)</span><span class="s2">\n    </span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">return this.parseLabeledStatement(</span><span class="s2">\n        </span><span class="s1">node as Undone&lt;N.LabeledStatement&gt;,</span><span class="s2">\n        </span><span class="s1">maybeName,</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error migrate to Babel types</span><span class="s2">\n        </span><span class="s1">expr,</span><span class="s2">\n        </span><span class="s1">flags,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">return this.parseExpressionStatement(</span><span class="s2">\n        </span><span class="s1">node as Undone&lt;N.ExpressionStatement&gt;,</span><span class="s2">\n        </span><span class="s1">expr,</span><span class="s2">\n        </span><span class="s1">decorators,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">assertModuleNodeAllowed(node: N.Node): void {</span><span class="s2">\n    </span><span class="s1">if (!this.options.allowImportExportEverywhere &amp;&amp; !this.inModule) {</span><span class="s2">\n      </span><span class="s1">this.raise(Errors.ImportOutsideModule, { at: node });</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">decoratorsEnabledBeforeExport(): boolean {</span><span class="s2">\n    </span><span class="s1">if (this.hasPlugin(</span><span class="s2">\&quot;</span><span class="s1">decorators-legacy</span><span class="s2">\&quot;</span><span class="s1">)) return true;</span><span class="s2">\n    </span><span class="s1">return (</span><span class="s2">\n      </span><span class="s1">this.hasPlugin(</span><span class="s2">\&quot;</span><span class="s1">decorators</span><span class="s2">\&quot;</span><span class="s1">) &amp;&amp;</span><span class="s2">\n      </span><span class="s1">this.getPluginOption(</span><span class="s2">\&quot;</span><span class="s1">decorators</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">decoratorsBeforeExport</span><span class="s2">\&quot;</span><span class="s1">) !== false</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Attach the decorators to the given class.</span><span class="s2">\n  </span><span class="s1">// NOTE: This method changes the .start location of the class, and thus</span><span class="s2">\n  </span><span class="s1">// can affect comment attachment. Calling it before or after finalizing</span><span class="s2">\n  </span><span class="s1">// the class node (and thus finalizing its comments) changes how comments</span><span class="s2">\n  </span><span class="s1">// before the `class` keyword or before the final .start location of the</span><span class="s2">\n  </span><span class="s1">// class are attached.</span><span class="s2">\n  </span><span class="s1">maybeTakeDecorators&lt;T extends Undone&lt;N.Class&gt;&gt;(</span><span class="s2">\n    </span><span class="s1">maybeDecorators: N.Decorator[] | null,</span><span class="s2">\n    </span><span class="s1">classNode: T,</span><span class="s2">\n    </span><span class="s1">exportNode?: Undone&lt;N.ExportDefaultDeclaration | N.ExportNamedDeclaration&gt;,</span><span class="s2">\n  </span><span class="s1">): T {</span><span class="s2">\n    </span><span class="s1">if (maybeDecorators) {</span><span class="s2">\n      </span><span class="s1">if (classNode.decorators &amp;&amp; classNode.decorators.length &gt; 0) {</span><span class="s2">\n        </span><span class="s1">// Note: decorators attachment is only attempred multiple times</span><span class="s2">\n        </span><span class="s1">// when the class is part of an export declaration.</span><span class="s2">\n        </span><span class="s1">if (</span><span class="s2">\n          </span><span class="s1">typeof this.getPluginOption(</span><span class="s2">\n            \&quot;</span><span class="s1">decorators</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n            \&quot;</span><span class="s1">decoratorsBeforeExport</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n          </span><span class="s1">) !== </span><span class="s2">\&quot;</span><span class="s1">boolean</span><span class="s2">\&quot;\n        </span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">// If `decoratorsBeforeExport` was set to `true` or `false`, we</span><span class="s2">\n          </span><span class="s1">// already threw an error about decorators not being in a valid</span><span class="s2">\n          </span><span class="s1">// position.</span><span class="s2">\n          </span><span class="s1">this.raise(Errors.DecoratorsBeforeAfterExport, {</span><span class="s2">\n            </span><span class="s1">at: classNode.decorators[0],</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">classNode.decorators.unshift(...maybeDecorators);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">classNode.decorators = maybeDecorators;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">this.resetStartLocationFromNode(classNode, maybeDecorators[0]);</span><span class="s2">\n      </span><span class="s1">if (exportNode) this.resetStartLocationFromNode(exportNode, classNode);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return classNode;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">canHaveLeadingDecorator(): boolean {</span><span class="s2">\n    </span><span class="s1">return this.match(tt._class);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">parseDecorators(this: Parser, allowExport?: boolean): N.Decorator[] {</span><span class="s2">\n    </span><span class="s1">const decorators = [];</span><span class="s2">\n    </span><span class="s1">do {</span><span class="s2">\n      </span><span class="s1">decorators.push(this.parseDecorator());</span><span class="s2">\n    </span><span class="s1">} while (this.match(tt.at));</span><span class="s2">\n\n    </span><span class="s1">if (this.match(tt._export)) {</span><span class="s2">\n      </span><span class="s1">if (!allowExport) {</span><span class="s2">\n        </span><span class="s1">this.unexpected();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">if (!this.decoratorsEnabledBeforeExport()) {</span><span class="s2">\n        </span><span class="s1">this.raise(Errors.DecoratorExportClass, { at: this.state.startLoc });</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else if (!this.canHaveLeadingDecorator()) {</span><span class="s2">\n      </span><span class="s1">throw this.raise(Errors.UnexpectedLeadingDecorator, {</span><span class="s2">\n        </span><span class="s1">at: this.state.startLoc,</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">return decorators;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">parseDecorator(this: Parser): N.Decorator {</span><span class="s2">\n    </span><span class="s1">this.expectOnePlugin([</span><span class="s2">\&quot;</span><span class="s1">decorators</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">decorators-legacy</span><span class="s2">\&quot;</span><span class="s1">]);</span><span class="s2">\n\n    </span><span class="s1">const node = this.startNode&lt;N.Decorator&gt;();</span><span class="s2">\n    </span><span class="s1">this.next();</span><span class="s2">\n\n    </span><span class="s1">if (this.hasPlugin(</span><span class="s2">\&quot;</span><span class="s1">decorators</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n      </span><span class="s1">const startLoc = this.state.startLoc;</span><span class="s2">\n      </span><span class="s1">let expr: N.Expression;</span><span class="s2">\n\n      </span><span class="s1">if (this.match(tt.parenL)) {</span><span class="s2">\n        </span><span class="s1">const startLoc = this.state.startLoc;</span><span class="s2">\n        </span><span class="s1">this.next(); // eat '('</span><span class="s2">\n        </span><span class="s1">expr = this.parseExpression();</span><span class="s2">\n        </span><span class="s1">this.expect(tt.parenR);</span><span class="s2">\n        </span><span class="s1">expr = this.wrapParenthesis(startLoc, expr);</span><span class="s2">\n\n        </span><span class="s1">const paramsStartLoc = this.state.startLoc;</span><span class="s2">\n        </span><span class="s1">node.expression = this.parseMaybeDecoratorArguments(expr);</span><span class="s2">\n        </span><span class="s1">if (</span><span class="s2">\n          </span><span class="s1">this.getPluginOption(</span><span class="s2">\&quot;</span><span class="s1">decorators</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">allowCallParenthesized</span><span class="s2">\&quot;</span><span class="s1">) ===</span><span class="s2">\n            </span><span class="s1">false &amp;&amp;</span><span class="s2">\n          </span><span class="s1">node.expression !== expr</span><span class="s2">\n        </span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">this.raise(Errors.DecoratorArgumentsOutsideParentheses, {</span><span class="s2">\n            </span><span class="s1">at: paramsStartLoc,</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">expr = this.parseIdentifier(false);</span><span class="s2">\n\n        </span><span class="s1">while (this.eat(tt.dot)) {</span><span class="s2">\n          </span><span class="s1">const node = this.startNodeAt(startLoc);</span><span class="s2">\n          </span><span class="s1">node.object = expr;</span><span class="s2">\n          </span><span class="s1">if (this.match(tt.privateName)) {</span><span class="s2">\n            </span><span class="s1">this.classScope.usePrivateName(</span><span class="s2">\n              </span><span class="s1">this.state.value,</span><span class="s2">\n              </span><span class="s1">this.state.startLoc,</span><span class="s2">\n            </span><span class="s1">);</span><span class="s2">\n            </span><span class="s1">node.property = this.parsePrivateName();</span><span class="s2">\n          </span><span class="s1">} else {</span><span class="s2">\n            </span><span class="s1">node.property = this.parseIdentifier(true);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">node.computed = false;</span><span class="s2">\n          </span><span class="s1">expr = this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">MemberExpression</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">node.expression = this.parseMaybeDecoratorArguments(expr);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">node.expression = this.parseExprSubscripts();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">Decorator</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">parseMaybeDecoratorArguments(this: Parser, expr: N.Expression): N.Expression {</span><span class="s2">\n    </span><span class="s1">if (this.eat(tt.parenL)) {</span><span class="s2">\n      </span><span class="s1">const node = this.startNodeAtNode(expr);</span><span class="s2">\n      </span><span class="s1">node.callee = expr;</span><span class="s2">\n      </span><span class="s1">node.arguments = this.parseCallExpressionArguments(tt.parenR, false);</span><span class="s2">\n      </span><span class="s1">this.toReferencedList(node.arguments);</span><span class="s2">\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">CallExpression</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">return expr;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">parseBreakContinueStatement(</span><span class="s2">\n    </span><span class="s1">node: Undone&lt;N.Node&gt;,</span><span class="s2">\n    </span><span class="s1">isBreak: true,</span><span class="s2">\n  </span><span class="s1">): N.BreakStatement;</span><span class="s2">\n  </span><span class="s1">parseBreakContinueStatement(</span><span class="s2">\n    </span><span class="s1">node: Undone&lt;N.Node&gt;,</span><span class="s2">\n    </span><span class="s1">isBreak: false,</span><span class="s2">\n  </span><span class="s1">): N.ContinueStatement;</span><span class="s2">\n  </span><span class="s1">parseBreakContinueStatement(</span><span class="s2">\n    </span><span class="s1">node: Undone&lt;N.BreakStatement | N.ContinueStatement&gt;,</span><span class="s2">\n    </span><span class="s1">isBreak: boolean,</span><span class="s2">\n  </span><span class="s1">): N.BreakStatement | N.ContinueStatement {</span><span class="s2">\n    </span><span class="s1">this.next();</span><span class="s2">\n\n    </span><span class="s1">if (this.isLineTerminator()) {</span><span class="s2">\n      </span><span class="s1">node.label = null;</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">node.label = this.parseIdentifier();</span><span class="s2">\n      </span><span class="s1">this.semicolon();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">this.verifyBreakContinue(node, isBreak);</span><span class="s2">\n\n    </span><span class="s1">return this.finishNode(</span><span class="s2">\n      </span><span class="s1">node,</span><span class="s2">\n      </span><span class="s1">isBreak ? </span><span class="s2">\&quot;</span><span class="s1">BreakStatement</span><span class="s2">\&quot; </span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">ContinueStatement</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">verifyBreakContinue(</span><span class="s2">\n    </span><span class="s1">node: Undone&lt;N.BreakStatement | N.ContinueStatement&gt;,</span><span class="s2">\n    </span><span class="s1">isBreak: boolean,</span><span class="s2">\n  </span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">let i;</span><span class="s2">\n    </span><span class="s1">for (i = 0; i &lt; this.state.labels.length; ++i) {</span><span class="s2">\n      </span><span class="s1">const lab = this.state.labels[i];</span><span class="s2">\n      </span><span class="s1">if (node.label == null || lab.name === node.label.name) {</span><span class="s2">\n        </span><span class="s1">if (lab.kind != null &amp;&amp; (isBreak || lab.kind === </span><span class="s2">\&quot;</span><span class="s1">loop</span><span class="s2">\&quot;</span><span class="s1">)) break;</span><span class="s2">\n        </span><span class="s1">if (node.label &amp;&amp; isBreak) break;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (i === this.state.labels.length) {</span><span class="s2">\n      </span><span class="s1">const type = isBreak ? </span><span class="s2">\&quot;</span><span class="s1">BreakStatement</span><span class="s2">\&quot; </span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">ContinueStatement</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n      </span><span class="s1">this.raise(Errors.IllegalBreakContinue, { at: node, type });</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">parseDebuggerStatement(</span><span class="s2">\n    </span><span class="s1">node: Undone&lt;N.DebuggerStatement&gt;,</span><span class="s2">\n  </span><span class="s1">): N.DebuggerStatement {</span><span class="s2">\n    </span><span class="s1">this.next();</span><span class="s2">\n    </span><span class="s1">this.semicolon();</span><span class="s2">\n    </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">DebuggerStatement</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">parseHeaderExpression(this: Parser): N.Expression {</span><span class="s2">\n    </span><span class="s1">this.expect(tt.parenL);</span><span class="s2">\n    </span><span class="s1">const val = this.parseExpression();</span><span class="s2">\n    </span><span class="s1">this.expect(tt.parenR);</span><span class="s2">\n    </span><span class="s1">return val;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// https://tc39.es/ecma262/#prod-DoWhileStatement</span><span class="s2">\n  </span><span class="s1">parseDoWhileStatement(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">node: Undone&lt;N.DoWhileStatement&gt;,</span><span class="s2">\n  </span><span class="s1">): N.DoWhileStatement {</span><span class="s2">\n    </span><span class="s1">this.next();</span><span class="s2">\n    </span><span class="s1">this.state.labels.push(loopLabel);</span><span class="s2">\n\n    </span><span class="s1">// Parse the loop body's body.</span><span class="s2">\n    </span><span class="s1">node.body =</span><span class="s2">\n      </span><span class="s1">// For the smartPipelines plugin: Disable topic references from outer</span><span class="s2">\n      </span><span class="s1">// contexts within the loop body. They are permitted in test expressions,</span><span class="s2">\n      </span><span class="s1">// outside of the loop body.</span><span class="s2">\n      </span><span class="s1">this.withSmartMixTopicForbiddingContext(() =&gt;</span><span class="s2">\n        </span><span class="s1">// Parse the loop body's body.</span><span class="s2">\n        </span><span class="s1">this.parseStatement(),</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n\n    </span><span class="s1">this.state.labels.pop();</span><span class="s2">\n\n    </span><span class="s1">this.expect(tt._while);</span><span class="s2">\n    </span><span class="s1">node.test = this.parseHeaderExpression();</span><span class="s2">\n    </span><span class="s1">this.eat(tt.semi);</span><span class="s2">\n    </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">DoWhileStatement</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Disambiguating between a `for` and a `for`/`in` or `for`/`of`</span><span class="s2">\n  </span><span class="s1">// loop is non-trivial. Basically, we have to parse the init `var`</span><span class="s2">\n  </span><span class="s1">// statement or expression, disallowing the `in` operator (see</span><span class="s2">\n  </span><span class="s1">// the second parameter to `parseExpression`), and then check</span><span class="s2">\n  </span><span class="s1">// whether the next token is `in` or `of`. When there is no init</span><span class="s2">\n  </span><span class="s1">// part (semicolon immediately after the opening parenthesis), it</span><span class="s2">\n  </span><span class="s1">// is a regular `for` loop.</span><span class="s2">\n\n  </span><span class="s1">parseForStatement(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">node: Undone&lt;N.ForStatement | N.ForInOf&gt;,</span><span class="s2">\n  </span><span class="s1">): N.ForLike {</span><span class="s2">\n    </span><span class="s1">this.next();</span><span class="s2">\n    </span><span class="s1">this.state.labels.push(loopLabel);</span><span class="s2">\n\n    </span><span class="s1">let awaitAt = null;</span><span class="s2">\n\n    </span><span class="s1">if (this.isAwaitAllowed() &amp;&amp; this.eatContextual(tt._await)) {</span><span class="s2">\n      </span><span class="s1">awaitAt = this.state.lastTokStartLoc;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">this.scope.enter(SCOPE_OTHER);</span><span class="s2">\n    </span><span class="s1">this.expect(tt.parenL);</span><span class="s2">\n\n    </span><span class="s1">if (this.match(tt.semi)) {</span><span class="s2">\n      </span><span class="s1">if (awaitAt !== null) {</span><span class="s2">\n        </span><span class="s1">this.unexpected(awaitAt);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return this.parseFor(node as Undone&lt;N.ForStatement&gt;, null);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">const startsWithLet = this.isContextual(tt._let);</span><span class="s2">\n    </span><span class="s1">const startsWithUsing = this.isContextual(tt._using);</span><span class="s2">\n    </span><span class="s1">const isLetOrUsing =</span><span class="s2">\n      </span><span class="s1">(startsWithLet &amp;&amp; this.hasFollowingBindingAtom()) ||</span><span class="s2">\n      </span><span class="s1">(startsWithUsing &amp;&amp; this.startsUsingForOf());</span><span class="s2">\n    </span><span class="s1">if (this.match(tt._var) || this.match(tt._const) || isLetOrUsing) {</span><span class="s2">\n      </span><span class="s1">const initNode = this.startNode&lt;N.VariableDeclaration&gt;();</span><span class="s2">\n      </span><span class="s1">const kind = this.state.value;</span><span class="s2">\n      </span><span class="s1">this.next();</span><span class="s2">\n      </span><span class="s1">this.parseVar(initNode, true, kind);</span><span class="s2">\n      </span><span class="s1">const init = this.finishNode(initNode, </span><span class="s2">\&quot;</span><span class="s1">VariableDeclaration</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n\n      </span><span class="s1">const isForIn = this.match(tt._in);</span><span class="s2">\n      </span><span class="s1">if (isForIn &amp;&amp; startsWithUsing) {</span><span class="s2">\n        </span><span class="s1">this.raise(Errors.ForInUsing, { at: init });</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (</span><span class="s2">\n        </span><span class="s1">(isForIn || this.isContextual(tt._of)) &amp;&amp;</span><span class="s2">\n        </span><span class="s1">init.declarations.length === 1</span><span class="s2">\n      </span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">return this.parseForIn(node as Undone&lt;N.ForInOf&gt;, init, awaitAt);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (awaitAt !== null) {</span><span class="s2">\n        </span><span class="s1">this.unexpected(awaitAt);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return this.parseFor(node as Undone&lt;N.ForStatement&gt;, init);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">// Check whether the first token is possibly a contextual keyword, so that</span><span class="s2">\n    </span><span class="s1">// we can forbid `for (async of` if this turns out to be a for-of loop.</span><span class="s2">\n    </span><span class="s1">const startsWithAsync = this.isContextual(tt._async);</span><span class="s2">\n\n    </span><span class="s1">const refExpressionErrors = new ExpressionErrors();</span><span class="s2">\n    </span><span class="s1">const init = this.parseExpression(true, refExpressionErrors);</span><span class="s2">\n    </span><span class="s1">const isForOf = this.isContextual(tt._of);</span><span class="s2">\n    </span><span class="s1">if (isForOf) {</span><span class="s2">\n      </span><span class="s1">// Check for leading tokens that are forbidden in for-of loops:</span><span class="s2">\n      </span><span class="s1">if (startsWithLet) {</span><span class="s2">\n        </span><span class="s1">this.raise(Errors.ForOfLet, { at: init });</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">if (</span><span class="s2">\n        </span><span class="s1">// `for await (async of []);` is allowed.</span><span class="s2">\n        </span><span class="s1">awaitAt === null &amp;&amp;</span><span class="s2">\n        </span><span class="s1">startsWithAsync &amp;&amp;</span><span class="s2">\n        </span><span class="s1">init.type === </span><span class="s2">\&quot;</span><span class="s1">Identifier</span><span class="s2">\&quot;\n      </span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">// This catches the case where the `async` in `for (async of` was</span><span class="s2">\n        </span><span class="s1">// parsed as an identifier. If it was parsed as the start of an async</span><span class="s2">\n        </span><span class="s1">// arrow function (e.g. `for (async of =&gt; {} of []);`), the LVal check</span><span class="s2">\n        </span><span class="s1">// further down will raise a more appropriate error.</span><span class="s2">\n        </span><span class="s1">this.raise(Errors.ForOfAsync, { at: init });</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (isForOf || this.match(tt._in)) {</span><span class="s2">\n      </span><span class="s1">this.checkDestructuringPrivate(refExpressionErrors);</span><span class="s2">\n      </span><span class="s1">this.toAssignable(init, /* isLHS */ true);</span><span class="s2">\n      </span><span class="s1">const type = isForOf ? </span><span class="s2">\&quot;</span><span class="s1">ForOfStatement</span><span class="s2">\&quot; </span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">ForInStatement</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n      </span><span class="s1">this.checkLVal(init, { in: { type } });</span><span class="s2">\n      </span><span class="s1">return this.parseForIn(</span><span class="s2">\n        </span><span class="s1">node as Undone&lt;N.ForInStatement | N.ForOfStatement&gt;,</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error init has been transformed to an assignable</span><span class="s2">\n        </span><span class="s1">init,</span><span class="s2">\n        </span><span class="s1">awaitAt,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">this.checkExpressionErrors(refExpressionErrors, true);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (awaitAt !== null) {</span><span class="s2">\n      </span><span class="s1">this.unexpected(awaitAt);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return this.parseFor(node as Undone&lt;N.ForStatement&gt;, init);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// https://tc39.es/ecma262/#prod-HoistableDeclaration</span><span class="s2">\n  </span><span class="s1">parseFunctionStatement(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">node: Undone&lt;N.FunctionDeclaration&gt;,</span><span class="s2">\n    </span><span class="s1">isAsync: boolean,</span><span class="s2">\n    </span><span class="s1">isHangingDeclaration: boolean,</span><span class="s2">\n  </span><span class="s1">): N.FunctionDeclaration {</span><span class="s2">\n    </span><span class="s1">this.next(); // eat 'function'</span><span class="s2">\n    </span><span class="s1">return this.parseFunction(</span><span class="s2">\n      </span><span class="s1">node,</span><span class="s2">\n      </span><span class="s1">ParseFunctionFlag.Declaration |</span><span class="s2">\n        </span><span class="s1">(isHangingDeclaration ? ParseFunctionFlag.HangingDeclaration : 0) |</span><span class="s2">\n        </span><span class="s1">(isAsync ? ParseFunctionFlag.Async : 0),</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// https://tc39.es/ecma262/#prod-IfStatement</span><span class="s2">\n  </span><span class="s1">parseIfStatement(this: Parser, node: Undone&lt;N.IfStatement&gt;) {</span><span class="s2">\n    </span><span class="s1">this.next();</span><span class="s2">\n    </span><span class="s1">node.test = this.parseHeaderExpression();</span><span class="s2">\n    </span><span class="s1">// Annex B.3.3</span><span class="s2">\n    </span><span class="s1">// https://tc39.es/ecma262/#sec-functiondeclarations-in-ifstatement-statement-clauses</span><span class="s2">\n    </span><span class="s1">node.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration();</span><span class="s2">\n    </span><span class="s1">node.alternate = this.eat(tt._else)</span><span class="s2">\n      </span><span class="s1">? this.parseStatementOrSloppyAnnexBFunctionDeclaration()</span><span class="s2">\n      </span><span class="s1">: null;</span><span class="s2">\n    </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">IfStatement</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">parseReturnStatement(this: Parser, node: Undone&lt;N.ReturnStatement&gt;) {</span><span class="s2">\n    </span><span class="s1">if (!this.prodParam.hasReturn &amp;&amp; !this.options.allowReturnOutsideFunction) {</span><span class="s2">\n      </span><span class="s1">this.raise(Errors.IllegalReturn, { at: this.state.startLoc });</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">this.next();</span><span class="s2">\n\n    </span><span class="s1">// In `return` (and `break`/`continue`), the keywords with</span><span class="s2">\n    </span><span class="s1">// optional arguments, we eagerly look for a semicolon or the</span><span class="s2">\n    </span><span class="s1">// possibility to insert one.</span><span class="s2">\n\n    </span><span class="s1">if (this.isLineTerminator()) {</span><span class="s2">\n      </span><span class="s1">node.argument = null;</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">node.argument = this.parseExpression();</span><span class="s2">\n      </span><span class="s1">this.semicolon();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">ReturnStatement</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// https://tc39.es/ecma262/#prod-SwitchStatement</span><span class="s2">\n  </span><span class="s1">parseSwitchStatement(this: Parser, node: Undone&lt;N.SwitchStatement&gt;) {</span><span class="s2">\n    </span><span class="s1">this.next();</span><span class="s2">\n    </span><span class="s1">node.discriminant = this.parseHeaderExpression();</span><span class="s2">\n    </span><span class="s1">const cases: N.SwitchStatement[</span><span class="s2">\&quot;</span><span class="s1">cases</span><span class="s2">\&quot;</span><span class="s1">] = (node.cases = []);</span><span class="s2">\n    </span><span class="s1">this.expect(tt.braceL);</span><span class="s2">\n    </span><span class="s1">this.state.labels.push(switchLabel);</span><span class="s2">\n    </span><span class="s1">this.scope.enter(SCOPE_OTHER);</span><span class="s2">\n\n    </span><span class="s1">// Statements under must be grouped (by label) in SwitchCase</span><span class="s2">\n    </span><span class="s1">// nodes. `cur` is used to keep the node that we are currently</span><span class="s2">\n    </span><span class="s1">// adding statements to.</span><span class="s2">\n\n    </span><span class="s1">let cur;</span><span class="s2">\n    </span><span class="s1">for (let sawDefault; !this.match(tt.braceR); ) {</span><span class="s2">\n      </span><span class="s1">if (this.match(tt._case) || this.match(tt._default)) {</span><span class="s2">\n        </span><span class="s1">const isCase = this.match(tt._case);</span><span class="s2">\n        </span><span class="s1">if (cur) this.finishNode(cur, </span><span class="s2">\&quot;</span><span class="s1">SwitchCase</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error Fixme</span><span class="s2">\n        </span><span class="s1">cases.push((cur = this.startNode()));</span><span class="s2">\n        </span><span class="s1">cur.consequent = [];</span><span class="s2">\n        </span><span class="s1">this.next();</span><span class="s2">\n        </span><span class="s1">if (isCase) {</span><span class="s2">\n          </span><span class="s1">cur.test = this.parseExpression();</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">if (sawDefault) {</span><span class="s2">\n            </span><span class="s1">this.raise(Errors.MultipleDefaultsInSwitch, {</span><span class="s2">\n              </span><span class="s1">at: this.state.lastTokStartLoc,</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">sawDefault = true;</span><span class="s2">\n          </span><span class="s1">cur.test = null;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">this.expect(tt.colon);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">if (cur) {</span><span class="s2">\n          </span><span class="s1">cur.consequent.push(this.parseStatementListItem());</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">this.unexpected();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">this.scope.exit();</span><span class="s2">\n    </span><span class="s1">if (cur) this.finishNode(cur, </span><span class="s2">\&quot;</span><span class="s1">SwitchCase</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">this.next(); // Closing brace</span><span class="s2">\n    </span><span class="s1">this.state.labels.pop();</span><span class="s2">\n    </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">SwitchStatement</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">parseThrowStatement(this: Parser, node: Undone&lt;N.ThrowStatement&gt;) {</span><span class="s2">\n    </span><span class="s1">this.next();</span><span class="s2">\n    </span><span class="s1">if (this.hasPrecedingLineBreak()) {</span><span class="s2">\n      </span><span class="s1">this.raise(Errors.NewlineAfterThrow, { at: this.state.lastTokEndLoc });</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">node.argument = this.parseExpression();</span><span class="s2">\n    </span><span class="s1">this.semicolon();</span><span class="s2">\n    </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">ThrowStatement</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">parseCatchClauseParam(this: Parser): N.Pattern {</span><span class="s2">\n    </span><span class="s1">const param = this.parseBindingAtom();</span><span class="s2">\n\n    </span><span class="s1">this.scope.enter(</span><span class="s2">\n      </span><span class="s1">this.options.annexB &amp;&amp; param.type === </span><span class="s2">\&quot;</span><span class="s1">Identifier</span><span class="s2">\&quot;\n        </span><span class="s1">? SCOPE_SIMPLE_CATCH</span><span class="s2">\n        </span><span class="s1">: 0,</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">this.checkLVal(param, {</span><span class="s2">\n      </span><span class="s1">in: { type: </span><span class="s2">\&quot;</span><span class="s1">CatchClause</span><span class="s2">\&quot; </span><span class="s1">},</span><span class="s2">\n      </span><span class="s1">binding: BIND_CATCH_PARAM,</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n\n    </span><span class="s1">return param;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">parseTryStatement(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">node: Undone&lt;N.TryStatement&gt;,</span><span class="s2">\n  </span><span class="s1">): N.TryStatement {</span><span class="s2">\n    </span><span class="s1">this.next();</span><span class="s2">\n\n    </span><span class="s1">node.block = this.parseBlock();</span><span class="s2">\n    </span><span class="s1">node.handler = null;</span><span class="s2">\n\n    </span><span class="s1">if (this.match(tt._catch)) {</span><span class="s2">\n      </span><span class="s1">const clause = this.startNode&lt;N.CatchClause&gt;();</span><span class="s2">\n      </span><span class="s1">this.next();</span><span class="s2">\n      </span><span class="s1">if (this.match(tt.parenL)) {</span><span class="s2">\n        </span><span class="s1">this.expect(tt.parenL);</span><span class="s2">\n        </span><span class="s1">clause.param = this.parseCatchClauseParam();</span><span class="s2">\n        </span><span class="s1">this.expect(tt.parenR);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">clause.param = null;</span><span class="s2">\n        </span><span class="s1">this.scope.enter(SCOPE_OTHER);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">// Parse the catch clause's body.</span><span class="s2">\n      </span><span class="s1">clause.body =</span><span class="s2">\n        </span><span class="s1">// For the smartPipelines plugin: Disable topic references from outer</span><span class="s2">\n        </span><span class="s1">// contexts within the catch clause's body.</span><span class="s2">\n        </span><span class="s1">this.withSmartMixTopicForbiddingContext(() =&gt;</span><span class="s2">\n          </span><span class="s1">// Parse the catch clause's body.</span><span class="s2">\n          </span><span class="s1">this.parseBlock(false, false),</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n\n      </span><span class="s1">this.scope.exit();</span><span class="s2">\n      </span><span class="s1">node.handler = this.finishNode(clause, </span><span class="s2">\&quot;</span><span class="s1">CatchClause</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">node.finalizer = this.eat(tt._finally) ? this.parseBlock() : null;</span><span class="s2">\n\n    </span><span class="s1">if (!node.handler &amp;&amp; !node.finalizer) {</span><span class="s2">\n      </span><span class="s1">this.raise(Errors.NoCatchOrFinally, { at: node });</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">TryStatement</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// https://tc39.es/ecma262/#prod-VariableStatement</span><span class="s2">\n  </span><span class="s1">// https://tc39.es/ecma262/#prod-LexicalDeclaration</span><span class="s2">\n  </span><span class="s1">parseVarStatement(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">node: Undone&lt;N.VariableDeclaration&gt;,</span><span class="s2">\n    </span><span class="s1">kind: </span><span class="s2">\&quot;</span><span class="s1">var</span><span class="s2">\&quot; </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">let</span><span class="s2">\&quot; </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">const</span><span class="s2">\&quot; </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">using</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">allowMissingInitializer: boolean = false,</span><span class="s2">\n  </span><span class="s1">): N.VariableDeclaration {</span><span class="s2">\n    </span><span class="s1">this.next();</span><span class="s2">\n    </span><span class="s1">this.parseVar(node, false, kind, allowMissingInitializer);</span><span class="s2">\n    </span><span class="s1">this.semicolon();</span><span class="s2">\n    </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">VariableDeclaration</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// https://tc39.es/ecma262/#prod-WhileStatement</span><span class="s2">\n  </span><span class="s1">parseWhileStatement(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">node: Undone&lt;N.WhileStatement&gt;,</span><span class="s2">\n  </span><span class="s1">): N.WhileStatement {</span><span class="s2">\n    </span><span class="s1">this.next();</span><span class="s2">\n    </span><span class="s1">node.test = this.parseHeaderExpression();</span><span class="s2">\n    </span><span class="s1">this.state.labels.push(loopLabel);</span><span class="s2">\n\n    </span><span class="s1">// Parse the loop body.</span><span class="s2">\n    </span><span class="s1">node.body =</span><span class="s2">\n      </span><span class="s1">// For the smartPipelines plugin:</span><span class="s2">\n      </span><span class="s1">// Disable topic references from outer contexts within the loop body.</span><span class="s2">\n      </span><span class="s1">// They are permitted in test expressions, outside of the loop body.</span><span class="s2">\n      </span><span class="s1">this.withSmartMixTopicForbiddingContext(() =&gt;</span><span class="s2">\n        </span><span class="s1">// Parse loop body.</span><span class="s2">\n        </span><span class="s1">this.parseStatement(),</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n\n    </span><span class="s1">this.state.labels.pop();</span><span class="s2">\n\n    </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">WhileStatement</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">parseWithStatement(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">node: Undone&lt;N.WithStatement&gt;,</span><span class="s2">\n  </span><span class="s1">): N.WithStatement {</span><span class="s2">\n    </span><span class="s1">if (this.state.strict) {</span><span class="s2">\n      </span><span class="s1">this.raise(Errors.StrictWith, { at: this.state.startLoc });</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">this.next();</span><span class="s2">\n    </span><span class="s1">node.object = this.parseHeaderExpression();</span><span class="s2">\n\n    </span><span class="s1">// Parse the statement body.</span><span class="s2">\n    </span><span class="s1">node.body =</span><span class="s2">\n      </span><span class="s1">// For the smartPipelines plugin:</span><span class="s2">\n      </span><span class="s1">// Disable topic references from outer contexts within the with statement's body.</span><span class="s2">\n      </span><span class="s1">// They are permitted in function default-parameter expressions, which are</span><span class="s2">\n      </span><span class="s1">// part of the outer context, outside of the with statement's body.</span><span class="s2">\n      </span><span class="s1">this.withSmartMixTopicForbiddingContext(() =&gt;</span><span class="s2">\n        </span><span class="s1">// Parse the statement body.</span><span class="s2">\n        </span><span class="s1">this.parseStatement(),</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n\n    </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">WithStatement</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">parseEmptyStatement(node: Undone&lt;N.EmptyStatement&gt;): N.EmptyStatement {</span><span class="s2">\n    </span><span class="s1">this.next();</span><span class="s2">\n    </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">EmptyStatement</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// https://tc39.es/ecma262/#prod-LabelledStatement</span><span class="s2">\n  </span><span class="s1">parseLabeledStatement(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">node: Undone&lt;N.LabeledStatement&gt;,</span><span class="s2">\n    </span><span class="s1">maybeName: string,</span><span class="s2">\n    </span><span class="s1">expr: N.Identifier,</span><span class="s2">\n    </span><span class="s1">flags: ParseStatementFlag,</span><span class="s2">\n  </span><span class="s1">): N.LabeledStatement {</span><span class="s2">\n    </span><span class="s1">for (const label of this.state.labels) {</span><span class="s2">\n      </span><span class="s1">if (label.name === maybeName) {</span><span class="s2">\n        </span><span class="s1">this.raise(Errors.LabelRedeclaration, {</span><span class="s2">\n          </span><span class="s1">at: expr,</span><span class="s2">\n          </span><span class="s1">labelName: maybeName,</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">const kind = tokenIsLoop(this.state.type)</span><span class="s2">\n      </span><span class="s1">? </span><span class="s2">\&quot;</span><span class="s1">loop</span><span class="s2">\&quot;\n      </span><span class="s1">: this.match(tt._switch)</span><span class="s2">\n      </span><span class="s1">? </span><span class="s2">\&quot;</span><span class="s1">switch</span><span class="s2">\&quot;\n      </span><span class="s1">: null;</span><span class="s2">\n    </span><span class="s1">for (let i = this.state.labels.length - 1; i &gt;= 0; i--) {</span><span class="s2">\n      </span><span class="s1">const label = this.state.labels[i];</span><span class="s2">\n      </span><span class="s1">if (label.statementStart === node.start) {</span><span class="s2">\n        </span><span class="s1">label.statementStart = this.state.start;</span><span class="s2">\n        </span><span class="s1">label.kind = kind;</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">break;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">this.state.labels.push({</span><span class="s2">\n      </span><span class="s1">name: maybeName,</span><span class="s2">\n      </span><span class="s1">kind: kind,</span><span class="s2">\n      </span><span class="s1">statementStart: this.state.start,</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">// https://tc39.es/ecma262/#prod-LabelledItem</span><span class="s2">\n    </span><span class="s1">node.body =</span><span class="s2">\n      </span><span class="s1">flags &amp; ParseStatementFlag.AllowLabeledFunction</span><span class="s2">\n        </span><span class="s1">? this.parseStatementOrSloppyAnnexBFunctionDeclaration(true)</span><span class="s2">\n        </span><span class="s1">: this.parseStatement();</span><span class="s2">\n\n    </span><span class="s1">this.state.labels.pop();</span><span class="s2">\n    </span><span class="s1">node.label = expr;</span><span class="s2">\n    </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">LabeledStatement</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">parseExpressionStatement(</span><span class="s2">\n    </span><span class="s1">node: Undone&lt;N.ExpressionStatement&gt;,</span><span class="s2">\n    </span><span class="s1">expr: N.Expression,</span><span class="s2">\n    </span><span class="s1">/* eslint-disable-next-line @typescript-eslint/no-unused-vars -- used in TypeScript parser */</span><span class="s2">\n    </span><span class="s1">decorators: N.Decorator[] | null,</span><span class="s2">\n  </span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">node.expression = expr;</span><span class="s2">\n    </span><span class="s1">this.semicolon();</span><span class="s2">\n    </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">ExpressionStatement</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Parse a semicolon-enclosed block of statements, handling `</span><span class="s2">\&quot;</span><span class="s1">use</span><span class="s2">\n  </span><span class="s1">// strict</span><span class="s2">\&quot;</span><span class="s1">` declarations when `allowDirectives` is true (used for</span><span class="s2">\n  </span><span class="s1">// function bodies).</span><span class="s2">\n\n  </span><span class="s1">parseBlock(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">allowDirectives: boolean = false,</span><span class="s2">\n    </span><span class="s1">createNewLexicalScope: boolean = true,</span><span class="s2">\n    </span><span class="s1">afterBlockParse?: (hasStrictModeDirective: boolean) =&gt; void,</span><span class="s2">\n  </span><span class="s1">): N.BlockStatement {</span><span class="s2">\n    </span><span class="s1">const node = this.startNode&lt;N.BlockStatement&gt;();</span><span class="s2">\n    </span><span class="s1">if (allowDirectives) {</span><span class="s2">\n      </span><span class="s1">this.state.strictErrors.clear();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">this.expect(tt.braceL);</span><span class="s2">\n    </span><span class="s1">if (createNewLexicalScope) {</span><span class="s2">\n      </span><span class="s1">this.scope.enter(SCOPE_OTHER);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">this.parseBlockBody(</span><span class="s2">\n      </span><span class="s1">node,</span><span class="s2">\n      </span><span class="s1">allowDirectives,</span><span class="s2">\n      </span><span class="s1">false,</span><span class="s2">\n      </span><span class="s1">tt.braceR,</span><span class="s2">\n      </span><span class="s1">afterBlockParse,</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">if (createNewLexicalScope) {</span><span class="s2">\n      </span><span class="s1">this.scope.exit();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">BlockStatement</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">isValidDirective(stmt: N.Statement): boolean {</span><span class="s2">\n    </span><span class="s1">return (</span><span class="s2">\n      </span><span class="s1">stmt.type === </span><span class="s2">\&quot;</span><span class="s1">ExpressionStatement</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n      </span><span class="s1">stmt.expression.type === </span><span class="s2">\&quot;</span><span class="s1">StringLiteral</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n      </span><span class="s1">!stmt.expression.extra.parenthesized</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">parseBlockBody(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">node: Undone&lt;N.BlockStatementLike&gt;,</span><span class="s2">\n    </span><span class="s1">allowDirectives: boolean | undefined | null,</span><span class="s2">\n    </span><span class="s1">topLevel: boolean,</span><span class="s2">\n    </span><span class="s1">end: TokenType,</span><span class="s2">\n    </span><span class="s1">afterBlockParse?: (hasStrictModeDirective: boolean) =&gt; void,</span><span class="s2">\n  </span><span class="s1">): void {</span><span class="s2">\n    </span><span class="s1">const body: N.BlockStatementLike[</span><span class="s2">\&quot;</span><span class="s1">body</span><span class="s2">\&quot;</span><span class="s1">] = (node.body = []);</span><span class="s2">\n    </span><span class="s1">const directives: N.BlockStatementLike[</span><span class="s2">\&quot;</span><span class="s1">directives</span><span class="s2">\&quot;</span><span class="s1">] = (node.directives =</span><span class="s2">\n      </span><span class="s1">[]);</span><span class="s2">\n    </span><span class="s1">this.parseBlockOrModuleBlockBody(</span><span class="s2">\n      </span><span class="s1">body,</span><span class="s2">\n      </span><span class="s1">allowDirectives ? directives : undefined,</span><span class="s2">\n      </span><span class="s1">topLevel,</span><span class="s2">\n      </span><span class="s1">end,</span><span class="s2">\n      </span><span class="s1">afterBlockParse,</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Undefined directives means that directives are not allowed.</span><span class="s2">\n  </span><span class="s1">// https://tc39.es/ecma262/#prod-Block</span><span class="s2">\n  </span><span class="s1">// https://tc39.es/ecma262/#prod-ModuleBody</span><span class="s2">\n  </span><span class="s1">parseBlockOrModuleBlockBody(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">body: N.Statement[],</span><span class="s2">\n    </span><span class="s1">directives: N.Directive[] | undefined | null,</span><span class="s2">\n    </span><span class="s1">topLevel: boolean,</span><span class="s2">\n    </span><span class="s1">end: TokenType,</span><span class="s2">\n    </span><span class="s1">afterBlockParse?: (hasStrictModeDirective: boolean) =&gt; void,</span><span class="s2">\n  </span><span class="s1">): void {</span><span class="s2">\n    </span><span class="s1">const oldStrict = this.state.strict;</span><span class="s2">\n    </span><span class="s1">let hasStrictModeDirective = false;</span><span class="s2">\n    </span><span class="s1">let parsedNonDirective = false;</span><span class="s2">\n\n    </span><span class="s1">while (!this.match(end)) {</span><span class="s2">\n      </span><span class="s1">const stmt = topLevel</span><span class="s2">\n        </span><span class="s1">? this.parseModuleItem()</span><span class="s2">\n        </span><span class="s1">: this.parseStatementListItem();</span><span class="s2">\n\n      </span><span class="s1">if (directives &amp;&amp; !parsedNonDirective) {</span><span class="s2">\n        </span><span class="s1">if (this.isValidDirective(stmt)) {</span><span class="s2">\n          </span><span class="s1">const directive = this.stmtToDirective(stmt);</span><span class="s2">\n          </span><span class="s1">directives.push(directive);</span><span class="s2">\n\n          </span><span class="s1">if (</span><span class="s2">\n            </span><span class="s1">!hasStrictModeDirective &amp;&amp;</span><span class="s2">\n            </span><span class="s1">directive.value.value === </span><span class="s2">\&quot;</span><span class="s1">use strict</span><span class="s2">\&quot;\n          </span><span class="s1">) {</span><span class="s2">\n            </span><span class="s1">hasStrictModeDirective = true;</span><span class="s2">\n            </span><span class="s1">this.setStrict(true);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n\n          </span><span class="s1">continue;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">parsedNonDirective = true;</span><span class="s2">\n        </span><span class="s1">// clear strict errors since the strict mode will not change within the block</span><span class="s2">\n        </span><span class="s1">this.state.strictErrors.clear();</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">body.push(stmt);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">if (afterBlockParse) {</span><span class="s2">\n      </span><span class="s1">afterBlockParse.call(this, hasStrictModeDirective);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">if (!oldStrict) {</span><span class="s2">\n      </span><span class="s1">this.setStrict(false);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">this.next();</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Parse a regular `for` loop. The disambiguation code in</span><span class="s2">\n  </span><span class="s1">// `parseStatement` will already have parsed the init statement or</span><span class="s2">\n  </span><span class="s1">// expression.</span><span class="s2">\n\n  </span><span class="s1">parseFor(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">node: Undone&lt;N.ForStatement&gt;,</span><span class="s2">\n    </span><span class="s1">init?: N.VariableDeclaration | N.Expression | null,</span><span class="s2">\n  </span><span class="s1">): N.ForStatement {</span><span class="s2">\n    </span><span class="s1">node.init = init;</span><span class="s2">\n    </span><span class="s1">this.semicolon(/* allowAsi */ false);</span><span class="s2">\n    </span><span class="s1">node.test = this.match(tt.semi) ? null : this.parseExpression();</span><span class="s2">\n    </span><span class="s1">this.semicolon(/* allowAsi */ false);</span><span class="s2">\n    </span><span class="s1">node.update = this.match(tt.parenR) ? null : this.parseExpression();</span><span class="s2">\n    </span><span class="s1">this.expect(tt.parenR);</span><span class="s2">\n\n    </span><span class="s1">// Parse the loop body.</span><span class="s2">\n    </span><span class="s1">node.body =</span><span class="s2">\n      </span><span class="s1">// For the smartPipelines plugin: Disable topic references from outer</span><span class="s2">\n      </span><span class="s1">// contexts within the loop body. They are permitted in test expressions,</span><span class="s2">\n      </span><span class="s1">// outside of the loop body.</span><span class="s2">\n      </span><span class="s1">this.withSmartMixTopicForbiddingContext(() =&gt;</span><span class="s2">\n        </span><span class="s1">// Parse the loop body.</span><span class="s2">\n        </span><span class="s1">this.parseStatement(),</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n\n    </span><span class="s1">this.scope.exit();</span><span class="s2">\n    </span><span class="s1">this.state.labels.pop();</span><span class="s2">\n\n    </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">ForStatement</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Parse a `for`/`in` and `for`/`of` loop, which are almost</span><span class="s2">\n  </span><span class="s1">// same from parser's perspective.</span><span class="s2">\n\n  </span><span class="s1">parseForIn(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">node: Undone&lt;N.ForInOf&gt;,</span><span class="s2">\n    </span><span class="s1">init: N.VariableDeclaration | N.AssignmentPattern,</span><span class="s2">\n    </span><span class="s1">awaitAt?: Position | null,</span><span class="s2">\n  </span><span class="s1">): N.ForInOf {</span><span class="s2">\n    </span><span class="s1">const isForIn = this.match(tt._in);</span><span class="s2">\n    </span><span class="s1">this.next();</span><span class="s2">\n\n    </span><span class="s1">if (isForIn) {</span><span class="s2">\n      </span><span class="s1">if (awaitAt !== null) this.unexpected(awaitAt);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">node.await = awaitAt !== null;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">if (</span><span class="s2">\n      </span><span class="s1">init.type === </span><span class="s2">\&quot;</span><span class="s1">VariableDeclaration</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n      </span><span class="s1">init.declarations[0].init != null &amp;&amp;</span><span class="s2">\n      </span><span class="s1">(!isForIn ||</span><span class="s2">\n        </span><span class="s1">!this.options.annexB ||</span><span class="s2">\n        </span><span class="s1">this.state.strict ||</span><span class="s2">\n        </span><span class="s1">init.kind !== </span><span class="s2">\&quot;</span><span class="s1">var</span><span class="s2">\&quot; </span><span class="s1">||</span><span class="s2">\n        </span><span class="s1">init.declarations[0].id.type !== </span><span class="s2">\&quot;</span><span class="s1">Identifier</span><span class="s2">\&quot;</span><span class="s1">)</span><span class="s2">\n    </span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">this.raise(Errors.ForInOfLoopInitializer, {</span><span class="s2">\n        </span><span class="s1">at: init,</span><span class="s2">\n        </span><span class="s1">type: isForIn ? </span><span class="s2">\&quot;</span><span class="s1">ForInStatement</span><span class="s2">\&quot; </span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">ForOfStatement</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">if (init.type === </span><span class="s2">\&quot;</span><span class="s1">AssignmentPattern</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">this.raise(Errors.InvalidLhs, {</span><span class="s2">\n        </span><span class="s1">at: init,</span><span class="s2">\n        </span><span class="s1">ancestor: { type: </span><span class="s2">\&quot;</span><span class="s1">ForStatement</span><span class="s2">\&quot; </span><span class="s1">},</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">node.left = init;</span><span class="s2">\n    </span><span class="s1">node.right = isForIn</span><span class="s2">\n      </span><span class="s1">? this.parseExpression()</span><span class="s2">\n      </span><span class="s1">: this.parseMaybeAssignAllowIn();</span><span class="s2">\n    </span><span class="s1">this.expect(tt.parenR);</span><span class="s2">\n\n    </span><span class="s1">// Parse the loop body.</span><span class="s2">\n    </span><span class="s1">node.body =</span><span class="s2">\n      </span><span class="s1">// For the smartPipelines plugin:</span><span class="s2">\n      </span><span class="s1">// Disable topic references from outer contexts within the loop body.</span><span class="s2">\n      </span><span class="s1">// They are permitted in test expressions, outside of the loop body.</span><span class="s2">\n      </span><span class="s1">this.withSmartMixTopicForbiddingContext(() =&gt;</span><span class="s2">\n        </span><span class="s1">// Parse loop body.</span><span class="s2">\n        </span><span class="s1">this.parseStatement(),</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n\n    </span><span class="s1">this.scope.exit();</span><span class="s2">\n    </span><span class="s1">this.state.labels.pop();</span><span class="s2">\n\n    </span><span class="s1">return this.finishNode(node, isForIn ? </span><span class="s2">\&quot;</span><span class="s1">ForInStatement</span><span class="s2">\&quot; </span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">ForOfStatement</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Parse a list of variable declarations.</span><span class="s2">\n\n  </span><span class="s1">parseVar(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">node: Undone&lt;N.VariableDeclaration&gt;,</span><span class="s2">\n    </span><span class="s1">isFor: boolean,</span><span class="s2">\n    </span><span class="s1">kind: </span><span class="s2">\&quot;</span><span class="s1">var</span><span class="s2">\&quot; </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">let</span><span class="s2">\&quot; </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">const</span><span class="s2">\&quot; </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">using</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">allowMissingInitializer: boolean = false,</span><span class="s2">\n  </span><span class="s1">): Undone&lt;N.VariableDeclaration&gt; {</span><span class="s2">\n    </span><span class="s1">const declarations: N.VariableDeclarator[] = (node.declarations = []);</span><span class="s2">\n    </span><span class="s1">node.kind = kind;</span><span class="s2">\n    </span><span class="s1">for (;;) {</span><span class="s2">\n      </span><span class="s1">const decl = this.startNode&lt;N.VariableDeclarator&gt;();</span><span class="s2">\n      </span><span class="s1">this.parseVarId(decl, kind);</span><span class="s2">\n      </span><span class="s1">decl.init = !this.eat(tt.eq)</span><span class="s2">\n        </span><span class="s1">? null</span><span class="s2">\n        </span><span class="s1">: isFor</span><span class="s2">\n        </span><span class="s1">? this.parseMaybeAssignDisallowIn()</span><span class="s2">\n        </span><span class="s1">: this.parseMaybeAssignAllowIn();</span><span class="s2">\n\n      </span><span class="s1">if (decl.init === null &amp;&amp; !allowMissingInitializer) {</span><span class="s2">\n        </span><span class="s1">if (</span><span class="s2">\n          </span><span class="s1">decl.id.type !== </span><span class="s2">\&quot;</span><span class="s1">Identifier</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n          </span><span class="s1">!(isFor &amp;&amp; (this.match(tt._in) || this.isContextual(tt._of)))</span><span class="s2">\n        </span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">this.raise(Errors.DeclarationMissingInitializer, {</span><span class="s2">\n            </span><span class="s1">at: this.state.lastTokEndLoc,</span><span class="s2">\n            </span><span class="s1">kind: </span><span class="s2">\&quot;</span><span class="s1">destructuring</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">} else if (</span><span class="s2">\n          </span><span class="s1">kind === </span><span class="s2">\&quot;</span><span class="s1">const</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n          </span><span class="s1">!(this.match(tt._in) || this.isContextual(tt._of))</span><span class="s2">\n        </span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">this.raise(Errors.DeclarationMissingInitializer, {</span><span class="s2">\n            </span><span class="s1">at: this.state.lastTokEndLoc,</span><span class="s2">\n            </span><span class="s1">kind: </span><span class="s2">\&quot;</span><span class="s1">const</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">declarations.push(this.finishNode(decl, </span><span class="s2">\&quot;</span><span class="s1">VariableDeclarator</span><span class="s2">\&quot;</span><span class="s1">));</span><span class="s2">\n      </span><span class="s1">if (!this.eat(tt.comma)) break;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return node;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">parseVarId(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">decl: Undone&lt;N.VariableDeclarator&gt;,</span><span class="s2">\n    </span><span class="s1">kind: </span><span class="s2">\&quot;</span><span class="s1">var</span><span class="s2">\&quot; </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">let</span><span class="s2">\&quot; </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">const</span><span class="s2">\&quot; </span><span class="s1">| </span><span class="s2">\&quot;</span><span class="s1">using</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n  </span><span class="s1">): void {</span><span class="s2">\n    </span><span class="s1">// Unlike </span><span class="s2">\&quot;</span><span class="s1">let</span><span class="s2">\&quot; </span><span class="s1">which must be handled in checkLVal, it suffices to check</span><span class="s2">\n    </span><span class="s1">// await here because `using` must not precede binding patterns.</span><span class="s2">\n    </span><span class="s1">if (kind === </span><span class="s2">\&quot;</span><span class="s1">using</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; !this.inModule &amp;&amp; this.match(tt._await)) {</span><span class="s2">\n      </span><span class="s1">this.raise(Errors.AwaitInUsingBinding, { at: this.state.startLoc });</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">const id = this.parseBindingAtom();</span><span class="s2">\n    </span><span class="s1">this.checkLVal(id, {</span><span class="s2">\n      </span><span class="s1">in: { type: </span><span class="s2">\&quot;</span><span class="s1">VariableDeclarator</span><span class="s2">\&quot; </span><span class="s1">},</span><span class="s2">\n      </span><span class="s1">binding: kind === </span><span class="s2">\&quot;</span><span class="s1">var</span><span class="s2">\&quot; </span><span class="s1">? BIND_VAR : BIND_LEXICAL,</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">decl.id = id;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// https://tc39.es/ecma262/#prod-AsyncFunctionExpression</span><span class="s2">\n  </span><span class="s1">parseAsyncFunctionExpression(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">node: Undone&lt;N.FunctionExpression&gt;,</span><span class="s2">\n  </span><span class="s1">): N.FunctionExpression {</span><span class="s2">\n    </span><span class="s1">return this.parseFunction(node, ParseFunctionFlag.Async);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Parse a function declaration or expression (depending on the</span><span class="s2">\n  </span><span class="s1">// ParseFunctionFlag.Declaration flag).</span><span class="s2">\n\n  </span><span class="s1">parseFunction&lt;T extends N.NormalFunction&gt;(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">node: Undone&lt;T&gt;,</span><span class="s2">\n    </span><span class="s1">flags: ParseFunctionFlag = ParseFunctionFlag.Expression,</span><span class="s2">\n  </span><span class="s1">): T {</span><span class="s2">\n    </span><span class="s1">const hangingDeclaration = flags &amp; ParseFunctionFlag.HangingDeclaration;</span><span class="s2">\n    </span><span class="s1">const isDeclaration = !!(flags &amp; ParseFunctionFlag.Declaration);</span><span class="s2">\n    </span><span class="s1">const requireId = isDeclaration &amp;&amp; !(flags &amp; ParseFunctionFlag.NullableId);</span><span class="s2">\n    </span><span class="s1">const isAsync = !!(flags &amp; ParseFunctionFlag.Async);</span><span class="s2">\n\n    </span><span class="s1">this.initFunction(node, isAsync);</span><span class="s2">\n\n    </span><span class="s1">if (this.match(tt.star)) {</span><span class="s2">\n      </span><span class="s1">if (hangingDeclaration) {</span><span class="s2">\n        </span><span class="s1">this.raise(Errors.GeneratorInSingleStatementContext, {</span><span class="s2">\n          </span><span class="s1">at: this.state.startLoc,</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">this.next(); // eat *</span><span class="s2">\n      </span><span class="s1">node.generator = true;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">if (isDeclaration) {</span><span class="s2">\n      </span><span class="s1">node.id = this.parseFunctionId(requireId);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;</span><span class="s2">\n    </span><span class="s1">this.state.maybeInArrowParameters = false;</span><span class="s2">\n    </span><span class="s1">this.scope.enter(SCOPE_FUNCTION);</span><span class="s2">\n    </span><span class="s1">this.prodParam.enter(functionFlags(isAsync, node.generator));</span><span class="s2">\n\n    </span><span class="s1">if (!isDeclaration) {</span><span class="s2">\n      </span><span class="s1">node.id = this.parseFunctionId();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">this.parseFunctionParams(node, /* isConstructor */ false);</span><span class="s2">\n\n    </span><span class="s1">// For the smartPipelines plugin: Disable topic references from outer</span><span class="s2">\n    </span><span class="s1">// contexts within the function body. They are permitted in function</span><span class="s2">\n    </span><span class="s1">// default-parameter expressions, outside of the function body.</span><span class="s2">\n    </span><span class="s1">this.withSmartMixTopicForbiddingContext(() =&gt; {</span><span class="s2">\n      </span><span class="s1">// Parse the function body.</span><span class="s2">\n      </span><span class="s1">this.parseFunctionBodyAndFinish(</span><span class="s2">\n        </span><span class="s1">node,</span><span class="s2">\n        </span><span class="s1">isDeclaration ? </span><span class="s2">\&quot;</span><span class="s1">FunctionDeclaration</span><span class="s2">\&quot; </span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">FunctionExpression</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n\n    </span><span class="s1">this.prodParam.exit();</span><span class="s2">\n    </span><span class="s1">this.scope.exit();</span><span class="s2">\n\n    </span><span class="s1">if (isDeclaration &amp;&amp; !hangingDeclaration) {</span><span class="s2">\n      </span><span class="s1">// We need to register this _after_ parsing the function body</span><span class="s2">\n      </span><span class="s1">// because of TypeScript body-less function declarations,</span><span class="s2">\n      </span><span class="s1">// which shouldn't be added to the scope.</span><span class="s2">\n      </span><span class="s1">this.registerFunctionStatementId(node as T);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">this.state.maybeInArrowParameters = oldMaybeInArrowParameters;</span><span class="s2">\n    </span><span class="s1">return node as T;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">parseFunctionId(requireId?: boolean): N.Identifier | undefined | null {</span><span class="s2">\n    </span><span class="s1">return requireId || tokenIsIdentifier(this.state.type)</span><span class="s2">\n      </span><span class="s1">? this.parseIdentifier()</span><span class="s2">\n      </span><span class="s1">: null;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">parseFunctionParams(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">node: Undone&lt;N.Function&gt;,</span><span class="s2">\n    </span><span class="s1">isConstructor?: boolean,</span><span class="s2">\n  </span><span class="s1">): void {</span><span class="s2">\n    </span><span class="s1">this.expect(tt.parenL);</span><span class="s2">\n    </span><span class="s1">this.expressionScope.enter(newParameterDeclarationScope());</span><span class="s2">\n    </span><span class="s1">node.params = this.parseBindingList(</span><span class="s2">\n      </span><span class="s1">tt.parenR,</span><span class="s2">\n      </span><span class="s1">charCodes.rightParenthesis,</span><span class="s2">\n      </span><span class="s1">ParseBindingListFlags.IS_FUNCTION_PARAMS |</span><span class="s2">\n        </span><span class="s1">(isConstructor ? ParseBindingListFlags.IS_CONSTRUCTOR_PARAMS : 0),</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n\n    </span><span class="s1">this.expressionScope.exit();</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">registerFunctionStatementId(node: N.Function): void {</span><span class="s2">\n    </span><span class="s1">if (!node.id) return;</span><span class="s2">\n\n    </span><span class="s1">// If it is a regular function declaration in sloppy mode, then it is</span><span class="s2">\n    </span><span class="s1">// subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding</span><span class="s2">\n    </span><span class="s1">// mode depends on properties of the current scope (see</span><span class="s2">\n    </span><span class="s1">// treatFunctionsAsVar).</span><span class="s2">\n    </span><span class="s1">this.scope.declareName(</span><span class="s2">\n      </span><span class="s1">node.id.name,</span><span class="s2">\n      </span><span class="s1">!this.options.annexB || this.state.strict || node.generator || node.async</span><span class="s2">\n        </span><span class="s1">? this.scope.treatFunctionsAsVar</span><span class="s2">\n          </span><span class="s1">? BIND_VAR</span><span class="s2">\n          </span><span class="s1">: BIND_LEXICAL</span><span class="s2">\n        </span><span class="s1">: BIND_FUNCTION,</span><span class="s2">\n      </span><span class="s1">node.id.loc.start,</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Parse a class declaration or literal (depending on the</span><span class="s2">\n  </span><span class="s1">// `isStatement` parameter).</span><span class="s2">\n\n  </span><span class="s1">parseClass&lt;T extends N.Class&gt;(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">node: Undone&lt;T&gt;,</span><span class="s2">\n    </span><span class="s1">isStatement: /* T === ClassDeclaration */ boolean,</span><span class="s2">\n    </span><span class="s1">optionalId?: boolean,</span><span class="s2">\n  </span><span class="s1">): T {</span><span class="s2">\n    </span><span class="s1">this.next(); // 'class'</span><span class="s2">\n\n    </span><span class="s1">// A class definition is always strict mode code.</span><span class="s2">\n    </span><span class="s1">const oldStrict = this.state.strict;</span><span class="s2">\n    </span><span class="s1">this.state.strict = true;</span><span class="s2">\n\n    </span><span class="s1">this.parseClassId(node, isStatement, optionalId);</span><span class="s2">\n    </span><span class="s1">this.parseClassSuper(node);</span><span class="s2">\n    </span><span class="s1">// this.state.strict is restored in parseClassBody</span><span class="s2">\n    </span><span class="s1">node.body = this.parseClassBody(!!node.superClass, oldStrict);</span><span class="s2">\n\n    </span><span class="s1">return this.finishNode(</span><span class="s2">\n      </span><span class="s1">node,</span><span class="s2">\n      </span><span class="s1">isStatement ? </span><span class="s2">\&quot;</span><span class="s1">ClassDeclaration</span><span class="s2">\&quot; </span><span class="s1">: </span><span class="s2">\&quot;</span><span class="s1">ClassExpression</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">isClassProperty(): boolean {</span><span class="s2">\n    </span><span class="s1">return this.match(tt.eq) || this.match(tt.semi) || this.match(tt.braceR);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">isClassMethod(): boolean {</span><span class="s2">\n    </span><span class="s1">return this.match(tt.parenL);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">isNonstaticConstructor(method: N.ClassMethod | N.ClassProperty): boolean {</span><span class="s2">\n    </span><span class="s1">return (</span><span class="s2">\n      </span><span class="s1">!method.computed &amp;&amp;</span><span class="s2">\n      </span><span class="s1">!method.static &amp;&amp;</span><span class="s2">\n      </span><span class="s1">(method.key.name === </span><span class="s2">\&quot;</span><span class="s1">constructor</span><span class="s2">\&quot; </span><span class="s1">|| // Identifier</span><span class="s2">\n        </span><span class="s1">method.key.value === </span><span class="s2">\&quot;</span><span class="s1">constructor</span><span class="s2">\&quot;</span><span class="s1">) // String literal</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// https://tc39.es/ecma262/#prod-ClassBody</span><span class="s2">\n  </span><span class="s1">parseClassBody(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">hadSuperClass: boolean,</span><span class="s2">\n    </span><span class="s1">oldStrict: boolean,</span><span class="s2">\n  </span><span class="s1">): N.ClassBody {</span><span class="s2">\n    </span><span class="s1">this.classScope.enter();</span><span class="s2">\n\n    </span><span class="s1">const state: N.ParseClassMemberState = {</span><span class="s2">\n      </span><span class="s1">hadConstructor: false,</span><span class="s2">\n      </span><span class="s1">hadSuperClass,</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">let decorators: N.Decorator[] = [];</span><span class="s2">\n    </span><span class="s1">const classBody = this.startNode&lt;N.ClassBody&gt;();</span><span class="s2">\n    </span><span class="s1">classBody.body = [];</span><span class="s2">\n\n    </span><span class="s1">this.expect(tt.braceL);</span><span class="s2">\n\n    </span><span class="s1">// For the smartPipelines plugin: Disable topic references from outer</span><span class="s2">\n    </span><span class="s1">// contexts within the class body.</span><span class="s2">\n    </span><span class="s1">this.withSmartMixTopicForbiddingContext(() =&gt; {</span><span class="s2">\n      </span><span class="s1">// Parse the contents within the braces.</span><span class="s2">\n      </span><span class="s1">while (!this.match(tt.braceR)) {</span><span class="s2">\n        </span><span class="s1">if (this.eat(tt.semi)) {</span><span class="s2">\n          </span><span class="s1">if (decorators.length &gt; 0) {</span><span class="s2">\n            </span><span class="s1">throw this.raise(Errors.DecoratorSemicolon, {</span><span class="s2">\n              </span><span class="s1">at: this.state.lastTokEndLoc,</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">continue;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">if (this.match(tt.at)) {</span><span class="s2">\n          </span><span class="s1">decorators.push(this.parseDecorator());</span><span class="s2">\n          </span><span class="s1">continue;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">const member = this.startNode&lt;N.ClassMember&gt;();</span><span class="s2">\n\n        </span><span class="s1">// steal the decorators if there are any</span><span class="s2">\n        </span><span class="s1">if (decorators.length) {</span><span class="s2">\n          </span><span class="s1">// @ts-expect-error Fixme</span><span class="s2">\n          </span><span class="s1">member.decorators = decorators;</span><span class="s2">\n          </span><span class="s1">this.resetStartLocationFromNode(member, decorators[0]);</span><span class="s2">\n          </span><span class="s1">decorators = [];</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">this.parseClassMember(classBody, member, state);</span><span class="s2">\n\n        </span><span class="s1">if (</span><span class="s2">\n          </span><span class="s1">// @ts-expect-error Fixme</span><span class="s2">\n          </span><span class="s1">member.kind === </span><span class="s2">\&quot;</span><span class="s1">constructor</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n          </span><span class="s1">// @ts-expect-error Fixme</span><span class="s2">\n          </span><span class="s1">member.decorators &amp;&amp;</span><span class="s2">\n          </span><span class="s1">// @ts-expect-error Fixme</span><span class="s2">\n          </span><span class="s1">member.decorators.length &gt; 0</span><span class="s2">\n        </span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">this.raise(Errors.DecoratorConstructor, { at: member });</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n\n    </span><span class="s1">this.state.strict = oldStrict;</span><span class="s2">\n\n    </span><span class="s1">this.next(); // eat `}`</span><span class="s2">\n\n    </span><span class="s1">if (decorators.length) {</span><span class="s2">\n      </span><span class="s1">throw this.raise(Errors.TrailingDecorator, { at: this.state.startLoc });</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">this.classScope.exit();</span><span class="s2">\n\n    </span><span class="s1">return this.finishNode(classBody, </span><span class="s2">\&quot;</span><span class="s1">ClassBody</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// returns true if the current identifier is a method/field name,</span><span class="s2">\n  </span><span class="s1">// false if it is a modifier</span><span class="s2">\n  </span><span class="s1">parseClassMemberFromModifier(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">classBody: Undone&lt;N.ClassBody&gt;,</span><span class="s2">\n    </span><span class="s1">member: Undone&lt;N.ClassMember&gt;,</span><span class="s2">\n  </span><span class="s1">): boolean {</span><span class="s2">\n    </span><span class="s1">const key = this.parseIdentifier(true); // eats the modifier</span><span class="s2">\n\n    </span><span class="s1">if (this.isClassMethod()) {</span><span class="s2">\n      </span><span class="s1">const method: N.ClassMethod = member as any;</span><span class="s2">\n\n      </span><span class="s1">// a method named like the modifier</span><span class="s2">\n      </span><span class="s1">method.kind = </span><span class="s2">\&quot;</span><span class="s1">method</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n      </span><span class="s1">method.computed = false;</span><span class="s2">\n      </span><span class="s1">method.key = key;</span><span class="s2">\n      </span><span class="s1">method.static = false;</span><span class="s2">\n      </span><span class="s1">this.pushClassMethod(</span><span class="s2">\n        </span><span class="s1">classBody,</span><span class="s2">\n        </span><span class="s1">method,</span><span class="s2">\n        </span><span class="s1">false,</span><span class="s2">\n        </span><span class="s1">false,</span><span class="s2">\n        </span><span class="s1">/* isConstructor */ false,</span><span class="s2">\n        </span><span class="s1">false,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">return true;</span><span class="s2">\n    </span><span class="s1">} else if (this.isClassProperty()) {</span><span class="s2">\n      </span><span class="s1">const prop: N.ClassProperty = member as any;</span><span class="s2">\n\n      </span><span class="s1">// a property named like the modifier</span><span class="s2">\n      </span><span class="s1">prop.computed = false;</span><span class="s2">\n      </span><span class="s1">prop.key = key;</span><span class="s2">\n      </span><span class="s1">prop.static = false;</span><span class="s2">\n      </span><span class="s1">classBody.body.push(this.parseClassProperty(prop));</span><span class="s2">\n      </span><span class="s1">return true;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">this.resetPreviousNodeTrailingComments(key);</span><span class="s2">\n    </span><span class="s1">return false;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">parseClassMember(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">classBody: Undone&lt;N.ClassBody&gt;,</span><span class="s2">\n    </span><span class="s1">member: Undone&lt;N.ClassMember&gt;,</span><span class="s2">\n    </span><span class="s1">state: N.ParseClassMemberState,</span><span class="s2">\n  </span><span class="s1">): void {</span><span class="s2">\n    </span><span class="s1">const isStatic = this.isContextual(tt._static);</span><span class="s2">\n\n    </span><span class="s1">if (isStatic) {</span><span class="s2">\n      </span><span class="s1">if (this.parseClassMemberFromModifier(classBody, member)) {</span><span class="s2">\n        </span><span class="s1">// a class element named 'static'</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (this.eat(tt.braceL)) {</span><span class="s2">\n        </span><span class="s1">this.parseClassStaticBlock(classBody, member as any as N.StaticBlock);</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">parseClassMemberWithIsStatic(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">classBody: Undone&lt;N.ClassBody&gt;,</span><span class="s2">\n    </span><span class="s1">member: Undone&lt;N.ClassMember&gt;,</span><span class="s2">\n    </span><span class="s1">state: N.ParseClassMemberState,</span><span class="s2">\n    </span><span class="s1">isStatic: boolean,</span><span class="s2">\n  </span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">const publicMethod = member as N.ClassMethod;</span><span class="s2">\n    </span><span class="s1">const privateMethod = member as N.ClassPrivateMethod;</span><span class="s2">\n    </span><span class="s1">const publicProp = member as N.ClassProperty;</span><span class="s2">\n    </span><span class="s1">const privateProp = member as N.ClassPrivateProperty;</span><span class="s2">\n    </span><span class="s1">const accessorProp = member as N.ClassAccessorProperty;</span><span class="s2">\n\n    </span><span class="s1">const method: typeof publicMethod | typeof privateMethod = publicMethod;</span><span class="s2">\n    </span><span class="s1">const publicMember: typeof publicMethod | typeof publicProp = publicMethod;</span><span class="s2">\n\n    </span><span class="s1">member.static = isStatic;</span><span class="s2">\n    </span><span class="s1">this.parsePropertyNamePrefixOperator(member);</span><span class="s2">\n\n    </span><span class="s1">if (this.eat(tt.star)) {</span><span class="s2">\n      </span><span class="s1">// a generator</span><span class="s2">\n      </span><span class="s1">method.kind = </span><span class="s2">\&quot;</span><span class="s1">method</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n      </span><span class="s1">const isPrivateName = this.match(tt.privateName);</span><span class="s2">\n      </span><span class="s1">this.parseClassElementName(method);</span><span class="s2">\n\n      </span><span class="s1">if (isPrivateName) {</span><span class="s2">\n        </span><span class="s1">// Private generator method</span><span class="s2">\n        </span><span class="s1">this.pushClassPrivateMethod(classBody, privateMethod, true, false);</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">if (this.isNonstaticConstructor(publicMethod)) {</span><span class="s2">\n        </span><span class="s1">this.raise(Errors.ConstructorIsGenerator, {</span><span class="s2">\n          </span><span class="s1">at: publicMethod.key,</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">this.pushClassMethod(</span><span class="s2">\n        </span><span class="s1">classBody,</span><span class="s2">\n        </span><span class="s1">publicMethod,</span><span class="s2">\n        </span><span class="s1">true,</span><span class="s2">\n        </span><span class="s1">false,</span><span class="s2">\n        </span><span class="s1">/* isConstructor */ false,</span><span class="s2">\n        </span><span class="s1">false,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n\n      </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">const isContextual =</span><span class="s2">\n      </span><span class="s1">tokenIsIdentifier(this.state.type) &amp;&amp; !this.state.containsEsc;</span><span class="s2">\n    </span><span class="s1">const isPrivate = this.match(tt.privateName);</span><span class="s2">\n    </span><span class="s1">const key = this.parseClassElementName(member);</span><span class="s2">\n    </span><span class="s1">const maybeQuestionTokenStartLoc = this.state.startLoc;</span><span class="s2">\n\n    </span><span class="s1">this.parsePostMemberNameModifiers(publicMember);</span><span class="s2">\n\n    </span><span class="s1">if (this.isClassMethod()) {</span><span class="s2">\n      </span><span class="s1">method.kind = </span><span class="s2">\&quot;</span><span class="s1">method</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n      </span><span class="s1">if (isPrivate) {</span><span class="s2">\n        </span><span class="s1">this.pushClassPrivateMethod(classBody, privateMethod, false, false);</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">// a normal method</span><span class="s2">\n      </span><span class="s1">const isConstructor = this.isNonstaticConstructor(publicMethod);</span><span class="s2">\n      </span><span class="s1">let allowsDirectSuper = false;</span><span class="s2">\n      </span><span class="s1">if (isConstructor) {</span><span class="s2">\n        </span><span class="s1">publicMethod.kind = </span><span class="s2">\&quot;</span><span class="s1">constructor</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n        </span><span class="s1">// TypeScript allows multiple overloaded constructor declarations.</span><span class="s2">\n        </span><span class="s1">if (state.hadConstructor &amp;&amp; !this.hasPlugin(</span><span class="s2">\&quot;</span><span class="s1">typescript</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n          </span><span class="s1">this.raise(Errors.DuplicateConstructor, { at: key });</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (isConstructor &amp;&amp; this.hasPlugin(</span><span class="s2">\&quot;</span><span class="s1">typescript</span><span class="s2">\&quot;</span><span class="s1">) &amp;&amp; member.override) {</span><span class="s2">\n          </span><span class="s1">this.raise(Errors.OverrideOnConstructor, { at: key });</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">state.hadConstructor = true;</span><span class="s2">\n        </span><span class="s1">allowsDirectSuper = state.hadSuperClass;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">this.pushClassMethod(</span><span class="s2">\n        </span><span class="s1">classBody,</span><span class="s2">\n        </span><span class="s1">publicMethod,</span><span class="s2">\n        </span><span class="s1">false,</span><span class="s2">\n        </span><span class="s1">false,</span><span class="s2">\n        </span><span class="s1">isConstructor,</span><span class="s2">\n        </span><span class="s1">allowsDirectSuper,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">} else if (this.isClassProperty()) {</span><span class="s2">\n      </span><span class="s1">if (isPrivate) {</span><span class="s2">\n        </span><span class="s1">this.pushClassPrivateProperty(classBody, privateProp);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">this.pushClassProperty(classBody, publicProp);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else if (</span><span class="s2">\n      </span><span class="s1">isContextual &amp;&amp;</span><span class="s2">\n      </span><span class="s1">key.name === </span><span class="s2">\&quot;</span><span class="s1">async</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n      </span><span class="s1">!this.isLineTerminator()</span><span class="s2">\n    </span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">// an async method</span><span class="s2">\n      </span><span class="s1">this.resetPreviousNodeTrailingComments(key);</span><span class="s2">\n      </span><span class="s1">const isGenerator = this.eat(tt.star);</span><span class="s2">\n\n      </span><span class="s1">if (publicMember.optional) {</span><span class="s2">\n        </span><span class="s1">this.unexpected(maybeQuestionTokenStartLoc);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">method.kind = </span><span class="s2">\&quot;</span><span class="s1">method</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n      </span><span class="s1">// The so-called parsed name would have been </span><span class="s2">\&quot;</span><span class="s1">async</span><span class="s2">\&quot;</span><span class="s1">: get the real name.</span><span class="s2">\n      </span><span class="s1">const isPrivate = this.match(tt.privateName);</span><span class="s2">\n      </span><span class="s1">this.parseClassElementName(method);</span><span class="s2">\n      </span><span class="s1">this.parsePostMemberNameModifiers(publicMember);</span><span class="s2">\n\n      </span><span class="s1">if (isPrivate) {</span><span class="s2">\n        </span><span class="s1">// private async method</span><span class="s2">\n        </span><span class="s1">this.pushClassPrivateMethod(</span><span class="s2">\n          </span><span class="s1">classBody,</span><span class="s2">\n          </span><span class="s1">privateMethod,</span><span class="s2">\n          </span><span class="s1">isGenerator,</span><span class="s2">\n          </span><span class="s1">true,</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">if (this.isNonstaticConstructor(publicMethod)) {</span><span class="s2">\n          </span><span class="s1">this.raise(Errors.ConstructorIsAsync, { at: publicMethod.key });</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">this.pushClassMethod(</span><span class="s2">\n          </span><span class="s1">classBody,</span><span class="s2">\n          </span><span class="s1">publicMethod,</span><span class="s2">\n          </span><span class="s1">isGenerator,</span><span class="s2">\n          </span><span class="s1">true,</span><span class="s2">\n          </span><span class="s1">/* isConstructor */ false,</span><span class="s2">\n          </span><span class="s1">false,</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else if (</span><span class="s2">\n      </span><span class="s1">isContextual &amp;&amp;</span><span class="s2">\n      </span><span class="s1">(key.name === </span><span class="s2">\&quot;</span><span class="s1">get</span><span class="s2">\&quot; </span><span class="s1">|| key.name === </span><span class="s2">\&quot;</span><span class="s1">set</span><span class="s2">\&quot;</span><span class="s1">) &amp;&amp;</span><span class="s2">\n      </span><span class="s1">!(this.match(tt.star) &amp;&amp; this.isLineTerminator())</span><span class="s2">\n    </span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">// `get</span><span class="s2">\\</span><span class="s1">n*` is an uninitialized property named 'get' followed by a generator.</span><span class="s2">\n      </span><span class="s1">// a getter or setter</span><span class="s2">\n      </span><span class="s1">this.resetPreviousNodeTrailingComments(key);</span><span class="s2">\n      </span><span class="s1">method.kind = key.name;</span><span class="s2">\n      </span><span class="s1">// The so-called parsed name would have been </span><span class="s2">\&quot;</span><span class="s1">get/set</span><span class="s2">\&quot;</span><span class="s1">: get the real name.</span><span class="s2">\n      </span><span class="s1">const isPrivate = this.match(tt.privateName);</span><span class="s2">\n      </span><span class="s1">this.parseClassElementName(publicMethod);</span><span class="s2">\n\n      </span><span class="s1">if (isPrivate) {</span><span class="s2">\n        </span><span class="s1">// private getter/setter</span><span class="s2">\n        </span><span class="s1">this.pushClassPrivateMethod(classBody, privateMethod, false, false);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">if (this.isNonstaticConstructor(publicMethod)) {</span><span class="s2">\n          </span><span class="s1">this.raise(Errors.ConstructorIsAccessor, { at: publicMethod.key });</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">this.pushClassMethod(</span><span class="s2">\n          </span><span class="s1">classBody,</span><span class="s2">\n          </span><span class="s1">publicMethod,</span><span class="s2">\n          </span><span class="s1">false,</span><span class="s2">\n          </span><span class="s1">false,</span><span class="s2">\n          </span><span class="s1">/* isConstructor */ false,</span><span class="s2">\n          </span><span class="s1">false,</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">this.checkGetterSetterParams(publicMethod);</span><span class="s2">\n    </span><span class="s1">} else if (</span><span class="s2">\n      </span><span class="s1">isContextual &amp;&amp;</span><span class="s2">\n      </span><span class="s1">key.name === </span><span class="s2">\&quot;</span><span class="s1">accessor</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n      </span><span class="s1">!this.isLineTerminator()</span><span class="s2">\n    </span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">this.expectPlugin(</span><span class="s2">\&quot;</span><span class="s1">decoratorAutoAccessors</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">this.resetPreviousNodeTrailingComments(key);</span><span class="s2">\n\n      </span><span class="s1">// The so-called parsed name would have been </span><span class="s2">\&quot;</span><span class="s1">accessor</span><span class="s2">\&quot;</span><span class="s1">: get the real name.</span><span class="s2">\n      </span><span class="s1">const isPrivate = this.match(tt.privateName);</span><span class="s2">\n      </span><span class="s1">this.parseClassElementName(publicProp);</span><span class="s2">\n      </span><span class="s1">this.pushClassAccessorProperty(classBody, accessorProp, isPrivate);</span><span class="s2">\n    </span><span class="s1">} else if (this.isLineTerminator()) {</span><span class="s2">\n      </span><span class="s1">// an uninitialized class property (due to ASI, since we don't otherwise recognize the next token)</span><span class="s2">\n      </span><span class="s1">if (isPrivate) {</span><span class="s2">\n        </span><span class="s1">this.pushClassPrivateProperty(classBody, privateProp);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">this.pushClassProperty(classBody, publicProp);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">this.unexpected();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// https://tc39.es/ecma262/#prod-ClassElementName</span><span class="s2">\n  </span><span class="s1">parseClassElementName(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">member: Undone&lt;N.ClassMember&gt;,</span><span class="s2">\n  </span><span class="s1">): N.Expression | N.Identifier {</span><span class="s2">\n    </span><span class="s1">const { type, value } = this.state;</span><span class="s2">\n    </span><span class="s1">if (</span><span class="s2">\n      </span><span class="s1">(type === tt.name || type === tt.string) &amp;&amp;</span><span class="s2">\n      </span><span class="s1">member.static &amp;&amp;</span><span class="s2">\n      </span><span class="s1">value === </span><span class="s2">\&quot;</span><span class="s1">prototype</span><span class="s2">\&quot;\n    </span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">this.raise(Errors.StaticPrototype, { at: this.state.startLoc });</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">if (type === tt.privateName) {</span><span class="s2">\n      </span><span class="s1">if (value === </span><span class="s2">\&quot;</span><span class="s1">constructor</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">this.raise(Errors.ConstructorClassPrivateField, {</span><span class="s2">\n          </span><span class="s1">at: this.state.startLoc,</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">const key = this.parsePrivateName();</span><span class="s2">\n      </span><span class="s1">member.key = key;</span><span class="s2">\n      </span><span class="s1">return key;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">return this.parsePropertyName(member);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">parseClassStaticBlock(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">classBody: Undone&lt;N.ClassBody&gt;,</span><span class="s2">\n    </span><span class="s1">member: Undone&lt;</span><span class="s2">\n      </span><span class="s1">N.StaticBlock &amp; {</span><span class="s2">\n        </span><span class="s1">decorators?: Array&lt;N.Decorator&gt;;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">&gt;,</span><span class="s2">\n  </span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">// Start a new lexical scope</span><span class="s2">\n    </span><span class="s1">this.scope.enter(SCOPE_CLASS | SCOPE_STATIC_BLOCK | SCOPE_SUPER);</span><span class="s2">\n    </span><span class="s1">// Start a new scope with regard to loop labels</span><span class="s2">\n    </span><span class="s1">const oldLabels = this.state.labels;</span><span class="s2">\n    </span><span class="s1">this.state.labels = [];</span><span class="s2">\n    </span><span class="s1">// ClassStaticBlockStatementList:</span><span class="s2">\n    </span><span class="s1">//   StatementList[~Yield, ~Await, ~Return] opt</span><span class="s2">\n    </span><span class="s1">this.prodParam.enter(PARAM);</span><span class="s2">\n    </span><span class="s1">const body: N.Node[] = (member.body = []);</span><span class="s2">\n    </span><span class="s1">this.parseBlockOrModuleBlockBody(body, undefined, false, tt.braceR);</span><span class="s2">\n    </span><span class="s1">this.prodParam.exit();</span><span class="s2">\n    </span><span class="s1">this.scope.exit();</span><span class="s2">\n    </span><span class="s1">this.state.labels = oldLabels;</span><span class="s2">\n    </span><span class="s1">classBody.body.push(this.finishNode&lt;N.StaticBlock&gt;(member, </span><span class="s2">\&quot;</span><span class="s1">StaticBlock</span><span class="s2">\&quot;</span><span class="s1">));</span><span class="s2">\n    </span><span class="s1">if (member.decorators?.length) {</span><span class="s2">\n      </span><span class="s1">this.raise(Errors.DecoratorStaticBlock, { at: member });</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">pushClassProperty(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">classBody: Undone&lt;N.ClassBody&gt;,</span><span class="s2">\n    </span><span class="s1">prop: N.ClassProperty,</span><span class="s2">\n  </span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">if (</span><span class="s2">\n      </span><span class="s1">!prop.computed &amp;&amp;</span><span class="s2">\n      </span><span class="s1">(prop.key.name === </span><span class="s2">\&quot;</span><span class="s1">constructor</span><span class="s2">\&quot; </span><span class="s1">|| prop.key.value === </span><span class="s2">\&quot;</span><span class="s1">constructor</span><span class="s2">\&quot;</span><span class="s1">)</span><span class="s2">\n    </span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">// Non-computed field, which is either an identifier named </span><span class="s2">\&quot;</span><span class="s1">constructor</span><span class="s2">\&quot;\n      </span><span class="s1">// or a string literal named </span><span class="s2">\&quot;</span><span class="s1">constructor</span><span class="s2">\&quot;\n      </span><span class="s1">this.raise(Errors.ConstructorClassField, { at: prop.key });</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">classBody.body.push(this.parseClassProperty(prop));</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">pushClassPrivateProperty(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">classBody: Undone&lt;N.ClassBody&gt;,</span><span class="s2">\n    </span><span class="s1">prop: Undone&lt;N.ClassPrivateProperty&gt;,</span><span class="s2">\n  </span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">const node = this.parseClassPrivateProperty(prop);</span><span class="s2">\n    </span><span class="s1">classBody.body.push(node);</span><span class="s2">\n\n    </span><span class="s1">this.classScope.declarePrivateName(</span><span class="s2">\n      </span><span class="s1">this.getPrivateNameSV(node.key),</span><span class="s2">\n      </span><span class="s1">CLASS_ELEMENT_OTHER,</span><span class="s2">\n      </span><span class="s1">node.key.loc.start,</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">pushClassAccessorProperty(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">classBody: Undone&lt;N.ClassBody&gt;,</span><span class="s2">\n    </span><span class="s1">prop: N.ClassAccessorProperty,</span><span class="s2">\n    </span><span class="s1">isPrivate: boolean,</span><span class="s2">\n  </span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">if (!isPrivate &amp;&amp; !prop.computed) {</span><span class="s2">\n      </span><span class="s1">// Not private, so not node is not a PrivateName and we can safely cast</span><span class="s2">\n      </span><span class="s1">const key = prop.key as N.Expression;</span><span class="s2">\n\n      </span><span class="s1">if (key.name === </span><span class="s2">\&quot;</span><span class="s1">constructor</span><span class="s2">\&quot; </span><span class="s1">|| key.value === </span><span class="s2">\&quot;</span><span class="s1">constructor</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">// Non-computed field, which is either an identifier named </span><span class="s2">\&quot;</span><span class="s1">constructor</span><span class="s2">\&quot;\n        </span><span class="s1">// or a string literal named </span><span class="s2">\&quot;</span><span class="s1">constructor</span><span class="s2">\&quot;\n        </span><span class="s1">this.raise(Errors.ConstructorClassField, { at: key });</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">const node = this.parseClassAccessorProperty(prop);</span><span class="s2">\n    </span><span class="s1">classBody.body.push(node);</span><span class="s2">\n\n    </span><span class="s1">if (isPrivate) {</span><span class="s2">\n      </span><span class="s1">this.classScope.declarePrivateName(</span><span class="s2">\n        </span><span class="s1">this.getPrivateNameSV(node.key),</span><span class="s2">\n        </span><span class="s1">CLASS_ELEMENT_OTHER,</span><span class="s2">\n        </span><span class="s1">node.key.loc.start,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">pushClassMethod(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">classBody: Undone&lt;N.ClassBody&gt;,</span><span class="s2">\n    </span><span class="s1">method: Undone&lt;N.ClassMethod&gt;,</span><span class="s2">\n    </span><span class="s1">isGenerator: boolean,</span><span class="s2">\n    </span><span class="s1">isAsync: boolean,</span><span class="s2">\n    </span><span class="s1">isConstructor: boolean,</span><span class="s2">\n    </span><span class="s1">allowsDirectSuper: boolean,</span><span class="s2">\n  </span><span class="s1">): void {</span><span class="s2">\n    </span><span class="s1">classBody.body.push(</span><span class="s2">\n      </span><span class="s1">this.parseMethod(</span><span class="s2">\n        </span><span class="s1">method,</span><span class="s2">\n        </span><span class="s1">isGenerator,</span><span class="s2">\n        </span><span class="s1">isAsync,</span><span class="s2">\n        </span><span class="s1">isConstructor,</span><span class="s2">\n        </span><span class="s1">allowsDirectSuper,</span><span class="s2">\n        \&quot;</span><span class="s1">ClassMethod</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">true,</span><span class="s2">\n      </span><span class="s1">),</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">pushClassPrivateMethod(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">classBody: Undone&lt;N.ClassBody&gt;,</span><span class="s2">\n    </span><span class="s1">method: Undone&lt;N.ClassPrivateMethod&gt;,</span><span class="s2">\n    </span><span class="s1">isGenerator: boolean,</span><span class="s2">\n    </span><span class="s1">isAsync: boolean,</span><span class="s2">\n  </span><span class="s1">): void {</span><span class="s2">\n    </span><span class="s1">const node = this.parseMethod(</span><span class="s2">\n      </span><span class="s1">method,</span><span class="s2">\n      </span><span class="s1">isGenerator,</span><span class="s2">\n      </span><span class="s1">isAsync,</span><span class="s2">\n      </span><span class="s1">/* isConstructor */ false,</span><span class="s2">\n      </span><span class="s1">false,</span><span class="s2">\n      \&quot;</span><span class="s1">ClassPrivateMethod</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">true,</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">classBody.body.push(node);</span><span class="s2">\n\n    </span><span class="s1">const kind =</span><span class="s2">\n      </span><span class="s1">node.kind === </span><span class="s2">\&quot;</span><span class="s1">get</span><span class="s2">\&quot;\n        </span><span class="s1">? node.static</span><span class="s2">\n          </span><span class="s1">? CLASS_ELEMENT_STATIC_GETTER</span><span class="s2">\n          </span><span class="s1">: CLASS_ELEMENT_INSTANCE_GETTER</span><span class="s2">\n        </span><span class="s1">: node.kind === </span><span class="s2">\&quot;</span><span class="s1">set</span><span class="s2">\&quot;\n        </span><span class="s1">? node.static</span><span class="s2">\n          </span><span class="s1">? CLASS_ELEMENT_STATIC_SETTER</span><span class="s2">\n          </span><span class="s1">: CLASS_ELEMENT_INSTANCE_SETTER</span><span class="s2">\n        </span><span class="s1">: CLASS_ELEMENT_OTHER;</span><span class="s2">\n    </span><span class="s1">this.declareClassPrivateMethodInScope(node, kind);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">declareClassPrivateMethodInScope(</span><span class="s2">\n    </span><span class="s1">node: Undone&lt;</span><span class="s2">\n      </span><span class="s1">N.ClassPrivateMethod | N.EstreeMethodDefinition | N.TSDeclareMethod</span><span class="s2">\n    </span><span class="s1">&gt;,</span><span class="s2">\n    </span><span class="s1">kind: number,</span><span class="s2">\n  </span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">this.classScope.declarePrivateName(</span><span class="s2">\n      </span><span class="s1">this.getPrivateNameSV(node.key),</span><span class="s2">\n      </span><span class="s1">kind,</span><span class="s2">\n      </span><span class="s1">node.key.loc.start,</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Overridden in typescript.js</span><span class="s2">\n  </span><span class="s1">parsePostMemberNameModifiers(</span><span class="s2">\n    </span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-unused-vars</span><span class="s2">\n    </span><span class="s1">methodOrProp: Undone&lt;N.ClassMethod | N.ClassProperty&gt;,</span><span class="s2">\n  </span><span class="s1">): void {}</span><span class="s2">\n\n  </span><span class="s1">// https://tc39.es/ecma262/#prod-FieldDefinition</span><span class="s2">\n  </span><span class="s1">parseClassPrivateProperty(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">node: Undone&lt;N.ClassPrivateProperty&gt;,</span><span class="s2">\n  </span><span class="s1">): N.ClassPrivateProperty {</span><span class="s2">\n    </span><span class="s1">this.parseInitializer(node);</span><span class="s2">\n    </span><span class="s1">this.semicolon();</span><span class="s2">\n    </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">ClassPrivateProperty</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// https://tc39.es/ecma262/#prod-FieldDefinition</span><span class="s2">\n  </span><span class="s1">parseClassProperty(this: Parser, node: N.ClassProperty): N.ClassProperty {</span><span class="s2">\n    </span><span class="s1">this.parseInitializer(node);</span><span class="s2">\n    </span><span class="s1">this.semicolon();</span><span class="s2">\n    </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">ClassProperty</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">parseClassAccessorProperty(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">node: N.ClassAccessorProperty,</span><span class="s2">\n  </span><span class="s1">): N.ClassAccessorProperty {</span><span class="s2">\n    </span><span class="s1">this.parseInitializer(node);</span><span class="s2">\n    </span><span class="s1">this.semicolon();</span><span class="s2">\n    </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">ClassAccessorProperty</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// https://tc39.es/ecma262/#prod-Initializer</span><span class="s2">\n  </span><span class="s1">parseInitializer(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">node: Undone&lt;</span><span class="s2">\n      </span><span class="s1">N.ClassProperty | N.ClassPrivateProperty | N.ClassAccessorProperty</span><span class="s2">\n    </span><span class="s1">&gt;,</span><span class="s2">\n  </span><span class="s1">): void {</span><span class="s2">\n    </span><span class="s1">this.scope.enter(SCOPE_CLASS | SCOPE_SUPER);</span><span class="s2">\n    </span><span class="s1">this.expressionScope.enter(newExpressionScope());</span><span class="s2">\n    </span><span class="s1">this.prodParam.enter(PARAM);</span><span class="s2">\n    </span><span class="s1">node.value = this.eat(tt.eq) ? this.parseMaybeAssignAllowIn() : null;</span><span class="s2">\n    </span><span class="s1">this.expressionScope.exit();</span><span class="s2">\n    </span><span class="s1">this.prodParam.exit();</span><span class="s2">\n    </span><span class="s1">this.scope.exit();</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">parseClassId(</span><span class="s2">\n    </span><span class="s1">node: Undone&lt;N.Class&gt;,</span><span class="s2">\n    </span><span class="s1">isStatement: boolean,</span><span class="s2">\n    </span><span class="s1">optionalId?: boolean | null,</span><span class="s2">\n    </span><span class="s1">bindingType: BindingTypes = BIND_CLASS,</span><span class="s2">\n  </span><span class="s1">): void {</span><span class="s2">\n    </span><span class="s1">if (tokenIsIdentifier(this.state.type)) {</span><span class="s2">\n      </span><span class="s1">node.id = this.parseIdentifier();</span><span class="s2">\n      </span><span class="s1">if (isStatement) {</span><span class="s2">\n        </span><span class="s1">this.declareNameFromIdentifier(node.id, bindingType);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">if (optionalId || !isStatement) {</span><span class="s2">\n        </span><span class="s1">node.id = null;</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">throw this.raise(Errors.MissingClassName, { at: this.state.startLoc });</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// https://tc39.es/ecma262/#prod-ClassHeritage</span><span class="s2">\n  </span><span class="s1">parseClassSuper(this: Parser, node: Undone&lt;N.Class&gt;): void {</span><span class="s2">\n    </span><span class="s1">node.superClass = this.eat(tt._extends) ? this.parseExprSubscripts() : null;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Parses module export declaration.</span><span class="s2">\n  </span><span class="s1">// https://tc39.es/ecma262/#prod-ExportDeclaration</span><span class="s2">\n\n  </span><span class="s1">parseExport(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">node: Undone&lt;</span><span class="s2">\n      </span><span class="s1">| N.ExportDefaultDeclaration</span><span class="s2">\n      </span><span class="s1">| N.ExportAllDeclaration</span><span class="s2">\n      </span><span class="s1">| N.ExportNamedDeclaration</span><span class="s2">\n    </span><span class="s1">&gt;,</span><span class="s2">\n    </span><span class="s1">decorators: N.Decorator[] | null,</span><span class="s2">\n  </span><span class="s1">): N.AnyExport {</span><span class="s2">\n    </span><span class="s1">const hasDefault = this.maybeParseExportDefaultSpecifier(</span><span class="s2">\n      </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts)</span><span class="s2">\n      </span><span class="s1">node,</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">const parseAfterDefault = !hasDefault || this.eat(tt.comma);</span><span class="s2">\n    </span><span class="s1">const hasStar =</span><span class="s2">\n      </span><span class="s1">parseAfterDefault &amp;&amp;</span><span class="s2">\n      </span><span class="s1">this.eatExportStar(</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts)</span><span class="s2">\n        </span><span class="s1">node,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">const hasNamespace =</span><span class="s2">\n      </span><span class="s1">hasStar &amp;&amp;</span><span class="s2">\n      </span><span class="s1">this.maybeParseExportNamespaceSpecifier(</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts)</span><span class="s2">\n        </span><span class="s1">node,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">const parseAfterNamespace =</span><span class="s2">\n      </span><span class="s1">parseAfterDefault &amp;&amp; (!hasNamespace || this.eat(tt.comma));</span><span class="s2">\n    </span><span class="s1">const isFromRequired = hasDefault || hasStar;</span><span class="s2">\n\n    </span><span class="s1">if (hasStar &amp;&amp; !hasNamespace) {</span><span class="s2">\n      </span><span class="s1">if (hasDefault) this.unexpected();</span><span class="s2">\n      </span><span class="s1">if (decorators) {</span><span class="s2">\n        </span><span class="s1">throw this.raise(Errors.UnsupportedDecoratorExport, { at: node });</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">this.parseExportFrom(node as Undone&lt;N.ExportNamedDeclaration&gt;, true);</span><span class="s2">\n\n      </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">ExportAllDeclaration</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">const hasSpecifiers = this.maybeParseExportNamedSpecifiers(</span><span class="s2">\n      </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts)</span><span class="s2">\n      </span><span class="s1">node,</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n\n    </span><span class="s1">if (hasDefault &amp;&amp; parseAfterDefault &amp;&amp; !hasStar &amp;&amp; !hasSpecifiers) {</span><span class="s2">\n      </span><span class="s1">this.unexpected(null, tt.braceL);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">if (hasNamespace &amp;&amp; parseAfterNamespace) {</span><span class="s2">\n      </span><span class="s1">this.unexpected(null, tt._from);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">let hasDeclaration;</span><span class="s2">\n    </span><span class="s1">if (isFromRequired || hasSpecifiers) {</span><span class="s2">\n      </span><span class="s1">hasDeclaration = false;</span><span class="s2">\n      </span><span class="s1">if (decorators) {</span><span class="s2">\n        </span><span class="s1">throw this.raise(Errors.UnsupportedDecoratorExport, { at: node });</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">this.parseExportFrom(</span><span class="s2">\n        </span><span class="s1">node as Undone&lt;N.ExportNamedDeclaration&gt;,</span><span class="s2">\n        </span><span class="s1">isFromRequired,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">hasDeclaration = this.maybeParseExportDeclaration(</span><span class="s2">\n        </span><span class="s1">node as Undone&lt;N.ExportNamedDeclaration&gt;,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">if (isFromRequired || hasSpecifiers || hasDeclaration) {</span><span class="s2">\n      </span><span class="s1">const node2 = node as Undone&lt;N.ExportNamedDeclaration&gt;;</span><span class="s2">\n      </span><span class="s1">this.checkExport(node2, true, false, !!node2.source);</span><span class="s2">\n      </span><span class="s1">if (node2.declaration?.type === </span><span class="s2">\&quot;</span><span class="s1">ClassDeclaration</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">this.maybeTakeDecorators(decorators, node2.declaration, node2);</span><span class="s2">\n      </span><span class="s1">} else if (decorators) {</span><span class="s2">\n        </span><span class="s1">throw this.raise(Errors.UnsupportedDecoratorExport, { at: node });</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return this.finishNode(node2, </span><span class="s2">\&quot;</span><span class="s1">ExportNamedDeclaration</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">if (this.eat(tt._default)) {</span><span class="s2">\n      </span><span class="s1">const node2 = node as Undone&lt;N.ExportDefaultDeclaration&gt;;</span><span class="s2">\n      </span><span class="s1">// export default ...</span><span class="s2">\n      </span><span class="s1">const decl = this.parseExportDefaultExpression();</span><span class="s2">\n      </span><span class="s1">node2.declaration = decl;</span><span class="s2">\n\n      </span><span class="s1">if (decl.type === </span><span class="s2">\&quot;</span><span class="s1">ClassDeclaration</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">this.maybeTakeDecorators(decorators, decl as N.ClassDeclaration, node2);</span><span class="s2">\n      </span><span class="s1">} else if (decorators) {</span><span class="s2">\n        </span><span class="s1">throw this.raise(Errors.UnsupportedDecoratorExport, { at: node });</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">this.checkExport(node2, true, true);</span><span class="s2">\n\n      </span><span class="s1">return this.finishNode(node2, </span><span class="s2">\&quot;</span><span class="s1">ExportDefaultDeclaration</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">this.unexpected(null, tt.braceL);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-unused-vars</span><span class="s2">\n  </span><span class="s1">eatExportStar(node: N.Node): boolean {</span><span class="s2">\n    </span><span class="s1">return this.eat(tt.star);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">maybeParseExportDefaultSpecifier(node: N.Node): boolean {</span><span class="s2">\n    </span><span class="s1">if (this.isExportDefaultSpecifier()) {</span><span class="s2">\n      </span><span class="s1">// export defaultObj ...</span><span class="s2">\n      </span><span class="s1">this.expectPlugin(</span><span class="s2">\&quot;</span><span class="s1">exportDefaultFrom</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">const specifier = this.startNode();</span><span class="s2">\n      </span><span class="s1">specifier.exported = this.parseIdentifier(true);</span><span class="s2">\n      </span><span class="s1">node.specifiers = [this.finishNode(specifier, </span><span class="s2">\&quot;</span><span class="s1">ExportDefaultSpecifier</span><span class="s2">\&quot;</span><span class="s1">)];</span><span class="s2">\n      </span><span class="s1">return true;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return false;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">maybeParseExportNamespaceSpecifier(node: N.Node): boolean {</span><span class="s2">\n    </span><span class="s1">if (this.isContextual(tt._as)) {</span><span class="s2">\n      </span><span class="s1">if (!node.specifiers) node.specifiers = [];</span><span class="s2">\n\n      </span><span class="s1">const specifier = this.startNodeAt(this.state.lastTokStartLoc);</span><span class="s2">\n\n      </span><span class="s1">this.next();</span><span class="s2">\n\n      </span><span class="s1">specifier.exported = this.parseModuleExportName();</span><span class="s2">\n      </span><span class="s1">node.specifiers.push(</span><span class="s2">\n        </span><span class="s1">this.finishNode(specifier, </span><span class="s2">\&quot;</span><span class="s1">ExportNamespaceSpecifier</span><span class="s2">\&quot;</span><span class="s1">),</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">return true;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return false;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">maybeParseExportNamedSpecifiers(node: N.Node): boolean {</span><span class="s2">\n    </span><span class="s1">if (this.match(tt.braceL)) {</span><span class="s2">\n      </span><span class="s1">if (!node.specifiers) node.specifiers = [];</span><span class="s2">\n      </span><span class="s1">const isTypeExport = node.exportKind === </span><span class="s2">\&quot;</span><span class="s1">type</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n      </span><span class="s1">node.specifiers.push(...this.parseExportSpecifiers(isTypeExport));</span><span class="s2">\n\n      </span><span class="s1">node.source = null;</span><span class="s2">\n      </span><span class="s1">node.declaration = null;</span><span class="s2">\n      </span><span class="s1">if (this.hasPlugin(</span><span class="s2">\&quot;</span><span class="s1">importAssertions</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n        </span><span class="s1">node.assertions = [];</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return true;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return false;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">maybeParseExportDeclaration(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">node: Undone&lt;N.ExportNamedDeclaration&gt;,</span><span class="s2">\n  </span><span class="s1">): boolean {</span><span class="s2">\n    </span><span class="s1">if (this.shouldParseExportDeclaration()) {</span><span class="s2">\n      </span><span class="s1">node.specifiers = [];</span><span class="s2">\n      </span><span class="s1">node.source = null;</span><span class="s2">\n      </span><span class="s1">if (this.hasPlugin(</span><span class="s2">\&quot;</span><span class="s1">importAssertions</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n        </span><span class="s1">node.assertions = [];</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">node.declaration = this.parseExportDeclaration(node);</span><span class="s2">\n      </span><span class="s1">return true;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return false;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">isAsyncFunction(): boolean {</span><span class="s2">\n    </span><span class="s1">if (!this.isContextual(tt._async)) return false;</span><span class="s2">\n    </span><span class="s1">const next = this.nextTokenStart();</span><span class="s2">\n    </span><span class="s1">return (</span><span class="s2">\n      </span><span class="s1">!lineBreak.test(this.input.slice(this.state.pos, next)) &amp;&amp;</span><span class="s2">\n      </span><span class="s1">this.isUnparsedContextual(next, </span><span class="s2">\&quot;</span><span class="s1">function</span><span class="s2">\&quot;</span><span class="s1">)</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">parseExportDefaultExpression(this: Parser): N.Expression | N.Declaration {</span><span class="s2">\n    </span><span class="s1">const expr = this.startNode();</span><span class="s2">\n\n    </span><span class="s1">if (this.match(tt._function)) {</span><span class="s2">\n      </span><span class="s1">this.next();</span><span class="s2">\n      </span><span class="s1">return this.parseFunction(</span><span class="s2">\n        </span><span class="s1">expr as Undone&lt;N.FunctionDeclaration&gt;,</span><span class="s2">\n        </span><span class="s1">ParseFunctionFlag.Declaration | ParseFunctionFlag.NullableId,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">} else if (this.isAsyncFunction()) {</span><span class="s2">\n      </span><span class="s1">this.next(); // eat 'async'</span><span class="s2">\n      </span><span class="s1">this.next(); // eat 'function'</span><span class="s2">\n      </span><span class="s1">return this.parseFunction(</span><span class="s2">\n        </span><span class="s1">expr as Undone&lt;N.FunctionDeclaration&gt;,</span><span class="s2">\n        </span><span class="s1">ParseFunctionFlag.Declaration |</span><span class="s2">\n          </span><span class="s1">ParseFunctionFlag.NullableId |</span><span class="s2">\n          </span><span class="s1">ParseFunctionFlag.Async,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">if (this.match(tt._class)) {</span><span class="s2">\n      </span><span class="s1">return this.parseClass(expr as Undone&lt;N.ClassExpression&gt;, true, true);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">if (this.match(tt.at)) {</span><span class="s2">\n      </span><span class="s1">if (</span><span class="s2">\n        </span><span class="s1">this.hasPlugin(</span><span class="s2">\&quot;</span><span class="s1">decorators</span><span class="s2">\&quot;</span><span class="s1">) &amp;&amp;</span><span class="s2">\n        </span><span class="s1">this.getPluginOption(</span><span class="s2">\&quot;</span><span class="s1">decorators</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">decoratorsBeforeExport</span><span class="s2">\&quot;</span><span class="s1">) === true</span><span class="s2">\n      </span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">this.raise(Errors.DecoratorBeforeExport, { at: this.state.startLoc });</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return this.parseClass(</span><span class="s2">\n        </span><span class="s1">this.maybeTakeDecorators(</span><span class="s2">\n          </span><span class="s1">this.parseDecorators(false),</span><span class="s2">\n          </span><span class="s1">this.startNode&lt;N.ClassDeclaration&gt;(),</span><span class="s2">\n        </span><span class="s1">),</span><span class="s2">\n        </span><span class="s1">true,</span><span class="s2">\n        </span><span class="s1">true,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">if (this.match(tt._const) || this.match(tt._var) || this.isLet()) {</span><span class="s2">\n      </span><span class="s1">throw this.raise(Errors.UnsupportedDefaultExport, {</span><span class="s2">\n        </span><span class="s1">at: this.state.startLoc,</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">const res = this.parseMaybeAssignAllowIn();</span><span class="s2">\n    </span><span class="s1">this.semicolon();</span><span class="s2">\n    </span><span class="s1">return res;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// https://tc39.es/ecma262/#prod-ExportDeclaration</span><span class="s2">\n  </span><span class="s1">parseExportDeclaration(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-unused-vars</span><span class="s2">\n    </span><span class="s1">node: Undone&lt;N.ExportNamedDeclaration&gt;,</span><span class="s2">\n  </span><span class="s1">): N.Declaration | undefined | null {</span><span class="s2">\n    </span><span class="s1">if (this.match(tt._class)) {</span><span class="s2">\n      </span><span class="s1">const node = this.parseClass(</span><span class="s2">\n        </span><span class="s1">this.startNode&lt;N.ClassDeclaration&gt;(),</span><span class="s2">\n        </span><span class="s1">true,</span><span class="s2">\n        </span><span class="s1">false,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">return node;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return this.parseStatementListItem() as N.Declaration;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">isExportDefaultSpecifier(): boolean {</span><span class="s2">\n    </span><span class="s1">const { type } = this.state;</span><span class="s2">\n    </span><span class="s1">if (tokenIsIdentifier(type)) {</span><span class="s2">\n      </span><span class="s1">if ((type === tt._async &amp;&amp; !this.state.containsEsc) || type === tt._let) {</span><span class="s2">\n        </span><span class="s1">return false;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (</span><span class="s2">\n        </span><span class="s1">(type === tt._type || type === tt._interface) &amp;&amp;</span><span class="s2">\n        </span><span class="s1">!this.state.containsEsc</span><span class="s2">\n      </span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">const { type: nextType } = this.lookahead();</span><span class="s2">\n        </span><span class="s1">// If we see any variable name other than `from` after `type` keyword,</span><span class="s2">\n        </span><span class="s1">// we consider it as flow/typescript type exports</span><span class="s2">\n        </span><span class="s1">// note that this approach may fail on some pedantic cases</span><span class="s2">\n        </span><span class="s1">// export type from = number</span><span class="s2">\n        </span><span class="s1">if (</span><span class="s2">\n          </span><span class="s1">(tokenIsIdentifier(nextType) &amp;&amp; nextType !== tt._from) ||</span><span class="s2">\n          </span><span class="s1">nextType === tt.braceL</span><span class="s2">\n        </span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">this.expectOnePlugin([</span><span class="s2">\&quot;</span><span class="s1">flow</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">typescript</span><span class="s2">\&quot;</span><span class="s1">]);</span><span class="s2">\n          </span><span class="s1">return false;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else if (!this.match(tt._default)) {</span><span class="s2">\n      </span><span class="s1">return false;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">const next = this.nextTokenStart();</span><span class="s2">\n    </span><span class="s1">const hasFrom = this.isUnparsedContextual(next, </span><span class="s2">\&quot;</span><span class="s1">from</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">if (</span><span class="s2">\n      </span><span class="s1">this.input.charCodeAt(next) === charCodes.comma ||</span><span class="s2">\n      </span><span class="s1">(tokenIsIdentifier(this.state.type) &amp;&amp; hasFrom)</span><span class="s2">\n    </span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">return true;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// lookahead again when `export default from` is seen</span><span class="s2">\n    </span><span class="s1">if (this.match(tt._default) &amp;&amp; hasFrom) {</span><span class="s2">\n      </span><span class="s1">const nextAfterFrom = this.input.charCodeAt(</span><span class="s2">\n        </span><span class="s1">this.nextTokenStartSince(next + 4),</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">return (</span><span class="s2">\n        </span><span class="s1">nextAfterFrom === charCodes.quotationMark ||</span><span class="s2">\n        </span><span class="s1">nextAfterFrom === charCodes.apostrophe</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return false;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">parseExportFrom(</span><span class="s2">\n    </span><span class="s1">this: Parser,</span><span class="s2">\n    </span><span class="s1">node: Undone&lt;N.ExportNamedDeclaration&gt;,</span><span class="s2">\n    </span><span class="s1">expect?: boolean,</span><span class="s2">\n  </span><span class="s1">): void {</span><span class="s2">\n    </span><span class="s1">if (this.eatContextual(tt._from)) {</span><span class="s2">\n      </span><span class="s1">node.source = this.parseImportSource();</span><span class="s2">\n      </span><span class="s1">this.checkExport(node);</span><span class="s2">\n      </span><span class="s1">const assertions = this.maybeParseImportAssertions();</span><span class="s2">\n      </span><span class="s1">if (assertions) {</span><span class="s2">\n        </span><span class="s1">node.assertions = assertions;</span><span class="s2">\n        </span><span class="s1">this.checkJSONModuleImport(node);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else if (expect) {</span><span class="s2">\n      </span><span class="s1">this.unexpected();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">this.semicolon();</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">shouldParseExportDeclaration(): boolean {</span><span class="s2">\n    </span><span class="s1">const { type } = this.state;</span><span class="s2">\n    </span><span class="s1">if (type === tt.at) {</span><span class="s2">\n      </span><span class="s1">this.expectOnePlugin([</span><span class="s2">\&quot;</span><span class="s1">decorators</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">decorators-legacy</span><span class="s2">\&quot;</span><span class="s1">]);</span><span class="s2">\n      </span><span class="s1">if (this.hasPlugin(</span><span class="s2">\&quot;</span><span class="s1">decorators</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n        </span><span class="s1">if (</span><span class="s2">\n          </span><span class="s1">this.getPluginOption(</span><span class="s2">\&quot;</span><span class="s1">decorators</span><span class="s2">\&quot;</span><span class="s1">, </span><span class="s2">\&quot;</span><span class="s1">decoratorsBeforeExport</span><span class="s2">\&quot;</span><span class="s1">) === true</span><span class="s2">\n        </span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">this.raise(Errors.DecoratorBeforeExport, {</span><span class="s2">\n            </span><span class="s1">at: this.state.startLoc,</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">return true;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">return (</span><span class="s2">\n      </span><span class="s1">type === tt._var ||</span><span class="s2">\n      </span><span class="s1">type === tt._const ||</span><span class="s2">\n      </span><span class="s1">type === tt._function ||</span><span class="s2">\n      </span><span class="s1">type === tt._class ||</span><span class="s2">\n      </span><span class="s1">this.isLet() ||</span><span class="s2">\n      </span><span class="s1">this.isAsyncFunction()</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">checkExport(</span><span class="s2">\n    </span><span class="s1">node: Undone&lt;N.ExportNamedDeclaration | N.ExportDefaultDeclaration&gt;,</span><span class="s2">\n    </span><span class="s1">checkNames?: boolean,</span><span class="s2">\n    </span><span class="s1">isDefault?: boolean,</span><span class="s2">\n    </span><span class="s1">isFrom?: boolean,</span><span class="s2">\n  </span><span class="s1">): void {</span><span class="s2">\n    </span><span class="s1">if (checkNames) {</span><span class="s2">\n      </span><span class="s1">// Check for duplicate exports</span><span class="s2">\n      </span><span class="s1">if (isDefault) {</span><span class="s2">\n        </span><span class="s1">// Default exports</span><span class="s2">\n        </span><span class="s1">this.checkDuplicateExports(node, </span><span class="s2">\&quot;</span><span class="s1">default</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n        </span><span class="s1">if (this.hasPlugin(</span><span class="s2">\&quot;</span><span class="s1">exportDefaultFrom</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n          </span><span class="s1">const declaration = (node as any as N.ExportDefaultDeclaration)</span><span class="s2">\n            </span><span class="s1">.declaration;</span><span class="s2">\n          </span><span class="s1">if (</span><span class="s2">\n            </span><span class="s1">declaration.type === </span><span class="s2">\&quot;</span><span class="s1">Identifier</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n            </span><span class="s1">declaration.name === </span><span class="s2">\&quot;</span><span class="s1">from</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n            </span><span class="s1">declaration.end - declaration.start === 4 &amp;&amp; // does not contain escape</span><span class="s2">\n            </span><span class="s1">!declaration.extra?.parenthesized</span><span class="s2">\n          </span><span class="s1">) {</span><span class="s2">\n            </span><span class="s1">this.raise(Errors.ExportDefaultFromAsIdentifier, {</span><span class="s2">\n              </span><span class="s1">at: declaration,</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error node.specifiers may not exist</span><span class="s2">\n      </span><span class="s1">} else if (node.specifiers &amp;&amp; node.specifiers.length) {</span><span class="s2">\n        </span><span class="s1">// Named exports</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error node.specifiers may not exist</span><span class="s2">\n        </span><span class="s1">for (const specifier of node.specifiers) {</span><span class="s2">\n          </span><span class="s1">const { exported } = specifier;</span><span class="s2">\n          </span><span class="s1">const exportName =</span><span class="s2">\n            </span><span class="s1">exported.type === </span><span class="s2">\&quot;</span><span class="s1">Identifier</span><span class="s2">\&quot; </span><span class="s1">? exported.name : exported.value;</span><span class="s2">\n          </span><span class="s1">this.checkDuplicateExports(specifier, exportName);</span><span class="s2">\n          </span><span class="s1">if (!isFrom &amp;&amp; specifier.local) {</span><span class="s2">\n            </span><span class="s1">const { local } = specifier;</span><span class="s2">\n            </span><span class="s1">if (local.type !== </span><span class="s2">\&quot;</span><span class="s1">Identifier</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n              </span><span class="s1">this.raise(Errors.ExportBindingIsString, {</span><span class="s2">\n                </span><span class="s1">at: specifier,</span><span class="s2">\n                </span><span class="s1">localName: local.value,</span><span class="s2">\n                </span><span class="s1">exportName,</span><span class="s2">\n              </span><span class="s1">});</span><span class="s2">\n            </span><span class="s1">} else {</span><span class="s2">\n              </span><span class="s1">// check for keywords used as local names</span><span class="s2">\n              </span><span class="s1">this.checkReservedWord(local.name, local.loc.start, true, false);</span><span class="s2">\n              </span><span class="s1">// check if export is defined</span><span class="s2">\n              </span><span class="s1">this.scope.checkLocalExport(local);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">} else if (node.declaration) {</span><span class="s2">\n        </span><span class="s1">// Exported declarations</span><span class="s2">\n        </span><span class="s1">if (</span><span class="s2">\n          </span><span class="s1">node.declaration.type === </span><span class="s2">\&quot;</span><span class="s1">FunctionDeclaration</span><span class="s2">\&quot; </span><span class="s1">||</span><span class="s2">\n          </span><span class="s1">node.declaration.type === </span><span class="s2">\&quot;</span><span class="s1">ClassDeclaration</span><span class="s2">\&quot;\n        </span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">const id = node.declaration.id;</span><span class="s2">\n          </span><span class="s1">if (!id) throw new Error(</span><span class="s2">\&quot;</span><span class="s1">Assertion failure</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n\n          </span><span class="s1">this.checkDuplicateExports(node, id.name);</span><span class="s2">\n        </span><span class="s1">} else if (node.declaration.type === </span><span class="s2">\&quot;</span><span class="s1">VariableDeclaration</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n          </span><span class="s1">for (const declaration of node.declaration.declarations) {</span><span class="s2">\n            </span><span class="s1">this.checkDeclaration(declaration.id);</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">checkDeclaration(node: N.Pattern | N.ObjectProperty): void {</span><span class="s2">\n    </span><span class="s1">if (node.type === </span><span class="s2">\&quot;</span><span class="s1">Identifier</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">this.checkDuplicateExports(node, node.name);</span><span class="s2">\n    </span><span class="s1">} else if (node.type === </span><span class="s2">\&quot;</span><span class="s1">ObjectPattern</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">for (const prop of node.properties) {</span><span class="s2">\n        </span><span class="s1">this.checkDeclaration(prop);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else if (node.type === </span><span class="s2">\&quot;</span><span class="s1">ArrayPattern</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">for (const elem of node.elements) {</span><span class="s2">\n        </span><span class="s1">if (elem) {</span><span class="s2">\n          </span><span class="s1">this.checkDeclaration(elem);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">} else if (node.type === </span><span class="s2">\&quot;</span><span class="s1">ObjectProperty</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">// @ts-expect-error migrate to Babel types</span><span class="s2">\n      </span><span class="s1">this.checkDeclaration(node.value);</span><span class="s2">\n    </span><span class="s1">} else if (node.type === </span><span class="s2">\&quot;</span><span class="s1">RestElement</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">this.checkDeclaration(node.argument);</span><span class="s2">\n    </span><span class="s1">} else if (node.type === </span><span class="s2">\&quot;</span><span class="s1">AssignmentPattern</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">this.checkDeclaration(node.left);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">checkDuplicateExports(</span><span class="s2">\n    </span><span class="s1">node: Undone&lt;</span><span class="s2">\n      </span><span class="s1">| N.Identifier</span><span class="s2">\n      </span><span class="s1">| N.StringLiteral</span><span class="s2">\n      </span><span class="s1">| N.ExportNamedDeclaration</span><span class="s2">\n      </span><span class="s1">| N.ExportSpecifier</span><span class="s2">\n      </span><span class="s1">| N.ExportDefaultSpecifier</span><span class="s2">\n    </span><span class="s1">&gt;,</span><span class="s2">\n    </span><span class="s1">exportName: string,</span><span class="s2">\n  </span><span class="s1">): void {</span><span class="s2">\n    </span><span class="s1">if (this.exportedIdentifiers.has(exportName)) {</span><span class="s2">\n      </span><span class="s1">if (exportName === </span><span class="s2">\&quot;</span><span class="s1">default</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">this.raise(Errors.DuplicateDefaultExport, { at: node });</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">this.raise(Errors.DuplicateExport, { at: node, exportName });</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">this.exportedIdentifiers.add(exportName);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Parses a comma-separated list of module exports.</span><span class="s2">\n\n  </span><span class="s1">parseExportSpecifiers(isInTypeExport: boolean): Array&lt;N.ExportSpecifier&gt; {</span><span class="s2">\n    </span><span class="s1">const nodes = [];</span><span class="s2">\n    </span><span class="s1">let first = true;</span><span class="s2">\n\n    </span><span class="s1">// export { x, y as z } [from '...']</span><span class="s2">\n    </span><span class="s1">this.expect(tt.braceL);</span><span class="s2">\n\n    </span><span class="s1">while (!this.eat(tt.braceR)) {</span><span class="s2">\n      </span><span class="s1">if (first) {</span><span class="s2">\n        </span><span class="s1">first = false;</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">this.expect(tt.comma);</span><span class="s2">\n        </span><span class="s1">if (this.eat(tt.braceR)) break;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">const isMaybeTypeOnly = this.isContextual(tt._type);</span><span class="s2">\n      </span><span class="s1">const isString = this.match(tt.string);</span><span class="s2">\n      </span><span class="s1">const node = this.startNode();</span><span class="s2">\n      </span><span class="s1">node.local = this.parseModuleExportName();</span><span class="s2">\n      </span><span class="s1">nodes.push(</span><span class="s2">\n        </span><span class="s1">this.parseExportSpecifier(</span><span class="s2">\n          </span><span class="s1">node,</span><span class="s2">\n          </span><span class="s1">isString,</span><span class="s2">\n          </span><span class="s1">isInTypeExport,</span><span class="s2">\n          </span><span class="s1">isMaybeTypeOnly,</span><span class="s2">\n        </span><span class="s1">),</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n\n    </span><span class="s1">return nodes;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">parseExportSpecifier(</span><span class="s2">\n    </span><span class="s1">node: any,</span><span class="s2">\n    </span><span class="s1">isString: boolean,</span><span class="s2">\n    </span><span class="s1">/* eslint-disable @typescript-eslint/no-unused-vars -- used in TypeScript parser */</span><span class="s2">\n    </span><span class="s1">isInTypeExport: boolean,</span><span class="s2">\n    </span><span class="s1">isMaybeTypeOnly: boolean,</span><span class="s2">\n    </span><span class="s1">/* eslint-enable @typescript-eslint/no-unused-vars */</span><span class="s2">\n  </span><span class="s1">): N.ExportSpecifier {</span><span class="s2">\n    </span><span class="s1">if (this.eatContextual(tt._as)) {</span><span class="s2">\n      </span><span class="s1">node.exported = this.parseModuleExportName();</span><span class="s2">\n    </span><span class="s1">} else if (isString) {</span><span class="s2">\n      </span><span class="s1">node.exported = cloneStringLiteral(node.local);</span><span class="s2">\n    </span><span class="s1">} else if (!node.exported) {</span><span class="s2">\n      </span><span class="s1">node.exported = cloneIdentifier(node.local);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return this.finishNode&lt;N.ExportSpecifier&gt;(node, </span><span class="s2">\&quot;</span><span class="s1">ExportSpecifier</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// https://tc39.es/ecma262/#prod-ModuleExportName</span><span class="s2">\n  </span><span class="s1">parseModuleExportName(): N.StringLiteral | N.Identifier {</span><span class="s2">\n    </span><span class="s1">if (this.match(tt.string)) {</span><span class="s2">\n      </span><span class="s1">const result = this.parseStringLiteral(this.state.value);</span><span class="s2">\n      </span><span class="s1">const surrogate = result.value.match(loneSurrogate);</span><span class="s2">\n      </span><span class="s1">if (surrogate) {</span><span class="s2">\n        </span><span class="s1">this.raise(Errors.ModuleExportNameHasLoneSurrogate, {</span><span class="s2">\n          </span><span class="s1">at: result,</span><span class="s2">\n          </span><span class="s1">surrogateCharCode: surrogate[0].charCodeAt(0),</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">return result;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return this.parseIdentifier(true);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">isJSONModuleImport(</span><span class="s2">\n    </span><span class="s1">node: Undone&lt;</span><span class="s2">\n      </span><span class="s1">N.ExportAllDeclaration | N.ExportNamedDeclaration | N.ImportDeclaration</span><span class="s2">\n    </span><span class="s1">&gt;,</span><span class="s2">\n  </span><span class="s1">): boolean {</span><span class="s2">\n    </span><span class="s1">if (node.assertions != null) {</span><span class="s2">\n      </span><span class="s1">return node.assertions.some(({ key, value }) =&gt; {</span><span class="s2">\n        </span><span class="s1">return (</span><span class="s2">\n          </span><span class="s1">value.value === </span><span class="s2">\&quot;</span><span class="s1">json</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s2">\n          </span><span class="s1">(key.type === </span><span class="s2">\&quot;</span><span class="s1">Identifier</span><span class="s2">\&quot;\n            </span><span class="s1">? key.name === </span><span class="s2">\&quot;</span><span class="s1">type</span><span class="s2">\&quot;\n            </span><span class="s1">: key.value === </span><span class="s2">\&quot;</span><span class="s1">type</span><span class="s2">\&quot;</span><span class="s1">)</span><span class="s2">\n        </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return false;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">checkImportReflection(node: Undone&lt;N.ImportDeclaration&gt;) {</span><span class="s2">\n    </span><span class="s1">if (node.module) {</span><span class="s2">\n      </span><span class="s1">if (</span><span class="s2">\n        </span><span class="s1">node.specifiers.length !== 1 ||</span><span class="s2">\n        </span><span class="s1">node.specifiers[0].type !== </span><span class="s2">\&quot;</span><span class="s1">ImportDefaultSpecifier</span><span class="s2">\&quot;\n      </span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">this.raise(Errors.ImportReflectionNotBinding, {</span><span class="s2">\n          </span><span class="s1">at: node.specifiers[0].loc.start,</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">if (node.assertions?.length &gt; 0) {</span><span class="s2">\n        </span><span class="s1">this.raise(Errors.ImportReflectionHasAssertion, {</span><span class="s2">\n          </span><span class="s1">at: node.specifiers[0].loc.start,</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">checkJSONModuleImport(</span><span class="s2">\n    </span><span class="s1">node: Undone&lt;</span><span class="s2">\n      </span><span class="s1">N.ExportAllDeclaration | N.ExportNamedDeclaration | N.ImportDeclaration</span><span class="s2">\n    </span><span class="s1">&gt;,</span><span class="s2">\n  </span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">// @ts-expect-error Fixme: node.type must be undefined because they are undone</span><span class="s2">\n    </span><span class="s1">if (this.isJSONModuleImport(node) &amp;&amp; node.type !== </span><span class="s2">\&quot;</span><span class="s1">ExportAllDeclaration</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n      </span><span class="s1">// @ts-expect-error specifiers may not index node</span><span class="s2">\n      </span><span class="s1">const { specifiers } = node;</span><span class="s2">\n      </span><span class="s1">if (specifiers != null) {</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error refine specifier types</span><span class="s2">\n        </span><span class="s1">const nonDefaultNamedSpecifier = specifiers.find(specifier =&gt; {</span><span class="s2">\n          </span><span class="s1">let imported;</span><span class="s2">\n          </span><span class="s1">if (specifier.type === </span><span class="s2">\&quot;</span><span class="s1">ExportSpecifier</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n            </span><span class="s1">imported = specifier.local;</span><span class="s2">\n          </span><span class="s1">} else if (specifier.type === </span><span class="s2">\&quot;</span><span class="s1">ImportSpecifier</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n            </span><span class="s1">imported = specifier.imported;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n          </span><span class="s1">if (imported !== undefined) {</span><span class="s2">\n            </span><span class="s1">return imported.type === </span><span class="s2">\&quot;</span><span class="s1">Identifier</span><span class="s2">\&quot;\n              </span><span class="s1">? imported.name !== </span><span class="s2">\&quot;</span><span class="s1">default</span><span class="s2">\&quot;\n              </span><span class="s1">: imported.value !== </span><span class="s2">\&quot;</span><span class="s1">default</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">if (nonDefaultNamedSpecifier !== undefined) {</span><span class="s2">\n          </span><span class="s1">this.raise(Errors.ImportJSONBindingNotDefault, {</span><span class="s2">\n            </span><span class="s1">at: nonDefaultNamedSpecifier.loc.start,</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">parseMaybeImportReflection(node: Undone&lt;N.ImportDeclaration&gt;) {</span><span class="s2">\n    </span><span class="s1">let isImportReflection = false;</span><span class="s2">\n    </span><span class="s1">if (this.isContextual(tt._module)) {</span><span class="s2">\n      </span><span class="s1">const lookahead = this.lookahead();</span><span class="s2">\n      </span><span class="s1">const nextType = lookahead.type;</span><span class="s2">\n      </span><span class="s1">if (tokenIsIdentifier(nextType)) {</span><span class="s2">\n        </span><span class="s1">if (nextType !== tt._from) {</span><span class="s2">\n          </span><span class="s1">// import module x</span><span class="s2">\n          </span><span class="s1">isImportReflection = true;</span><span class="s2">\n        </span><span class="s1">} else {</span><span class="s2">\n          </span><span class="s1">const nextNextTokenFirstChar = this.input.charCodeAt(</span><span class="s2">\n            </span><span class="s1">this.nextTokenStartSince(lookahead.end),</span><span class="s2">\n          </span><span class="s1">);</span><span class="s2">\n          </span><span class="s1">if (nextNextTokenFirstChar === charCodes.lowercaseF) {</span><span class="s2">\n            </span><span class="s1">// import module from from ...</span><span class="s2">\n            </span><span class="s1">isImportReflection = true;</span><span class="s2">\n          </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">} else if (nextType !== tt.comma) {</span><span class="s2">\n        </span><span class="s1">// import module { x } ...</span><span class="s2">\n        </span><span class="s1">// import module </span><span class="s2">\&quot;</span><span class="s1">foo</span><span class="s2">\&quot;\n        </span><span class="s1">// They are invalid, we will continue parsing and throw</span><span class="s2">\n        </span><span class="s1">// a recoverable error later</span><span class="s2">\n        </span><span class="s1">isImportReflection = true;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (isImportReflection) {</span><span class="s2">\n      </span><span class="s1">this.expectPlugin(</span><span class="s2">\&quot;</span><span class="s1">importReflection</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">this.next(); // eat tt._module;</span><span class="s2">\n      </span><span class="s1">node.module = true;</span><span class="s2">\n    </span><span class="s1">} else if (this.hasPlugin(</span><span class="s2">\&quot;</span><span class="s1">importReflection</span><span class="s2">\&quot;</span><span class="s1">)) {</span><span class="s2">\n      </span><span class="s1">node.module = false;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// Parses import declaration.</span><span class="s2">\n  </span><span class="s1">// https://tc39.es/ecma262/#prod-ImportDeclaration</span><span class="s2">\n\n  </span><span class="s1">parseImport(this: Parser, node: Undone&lt;N.ImportDeclaration&gt;): N.AnyImport {</span><span class="s2">\n    </span><span class="s1">// import '...'</span><span class="s2">\n    </span><span class="s1">node.specifiers = [];</span><span class="s2">\n    </span><span class="s1">if (!this.match(tt.string)) {</span><span class="s2">\n      </span><span class="s1">this.parseMaybeImportReflection(node);</span><span class="s2">\n      </span><span class="s1">// check if we have a default import like</span><span class="s2">\n      </span><span class="s1">// import React from </span><span class="s2">\&quot;</span><span class="s1">react</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n      </span><span class="s1">const hasDefault = this.maybeParseDefaultImportSpecifier(node);</span><span class="s2">\n      </span><span class="s1">/* we are checking if we do not have a default import, then it is obvious that we need named imports</span><span class="s2">\n       </span><span class="s1">* import { get } from </span><span class="s2">\&quot;</span><span class="s1">axios</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n       </span><span class="s1">* but if we do have a default import</span><span class="s2">\n       </span><span class="s1">* we need to check if we have a comma after that and</span><span class="s2">\n       </span><span class="s1">* that is where this `|| this.eat` condition comes into play</span><span class="s2">\n       </span><span class="s1">*/</span><span class="s2">\n      </span><span class="s1">const parseNext = !hasDefault || this.eat(tt.comma);</span><span class="s2">\n      </span><span class="s1">// if we do have to parse the next set of specifiers, we first check for star imports</span><span class="s2">\n      </span><span class="s1">// import React, * from </span><span class="s2">\&quot;</span><span class="s1">react</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n      </span><span class="s1">const hasStar = parseNext &amp;&amp; this.maybeParseStarImportSpecifier(node);</span><span class="s2">\n      </span><span class="s1">// now we check if we need to parse the next imports</span><span class="s2">\n      </span><span class="s1">// but only if they are not importing * (everything)</span><span class="s2">\n      </span><span class="s1">if (parseNext &amp;&amp; !hasStar) this.parseNamedImportSpecifiers(node);</span><span class="s2">\n      </span><span class="s1">this.expectContextual(tt._from);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">node.source = this.parseImportSource();</span><span class="s2">\n    </span><span class="s1">// https://github.com/tc39/proposal-import-assertions</span><span class="s2">\n    </span><span class="s1">// parse module import assertions if the next token is `assert` or ignore</span><span class="s2">\n    </span><span class="s1">// and finish the ImportDeclaration node.</span><span class="s2">\n    </span><span class="s1">const assertions = this.maybeParseImportAssertions();</span><span class="s2">\n    </span><span class="s1">if (assertions) {</span><span class="s2">\n      </span><span class="s1">node.assertions = assertions;</span><span class="s2">\n    </span><span class="s1">} else if (!process.env.BABEL_8_BREAKING) {</span><span class="s2">\n      </span><span class="s1">const attributes = this.maybeParseModuleAttributes();</span><span class="s2">\n      </span><span class="s1">if (attributes) {</span><span class="s2">\n        </span><span class="s1">// @ts-expect-error attributes have been deprecated</span><span class="s2">\n        </span><span class="s1">node.attributes = attributes;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">this.checkImportReflection(node);</span><span class="s2">\n    </span><span class="s1">this.checkJSONModuleImport(node);</span><span class="s2">\n\n    </span><span class="s1">this.semicolon();</span><span class="s2">\n    </span><span class="s1">return this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">ImportDeclaration</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">parseImportSource(this: Parser): N.StringLiteral {</span><span class="s2">\n    </span><span class="s1">if (!this.match(tt.string)) this.unexpected();</span><span class="s2">\n    </span><span class="s1">return this.parseExprAtom() as N.StringLiteral;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-unused-vars</span><span class="s2">\n  </span><span class="s1">shouldParseDefaultImport(node: Undone&lt;N.ImportDeclaration&gt;): boolean {</span><span class="s2">\n    </span><span class="s1">return tokenIsIdentifier(this.state.type);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">parseImportSpecifierLocal&lt;</span><span class="s2">\n    </span><span class="s1">T extends</span><span class="s2">\n      </span><span class="s1">| N.ImportSpecifier</span><span class="s2">\n      </span><span class="s1">| N.ImportDefaultSpecifier</span><span class="s2">\n      </span><span class="s1">| N.ImportNamespaceSpecifier,</span><span class="s2">\n  </span><span class="s1">&gt;(</span><span class="s2">\n    </span><span class="s1">node: Undone&lt;N.ImportDeclaration&gt;,</span><span class="s2">\n    </span><span class="s1">specifier: Undone&lt;T&gt;,</span><span class="s2">\n    </span><span class="s1">type: T[</span><span class="s2">\&quot;</span><span class="s1">type</span><span class="s2">\&quot;</span><span class="s1">],</span><span class="s2">\n  </span><span class="s1">): void {</span><span class="s2">\n    </span><span class="s1">specifier.local = this.parseIdentifier();</span><span class="s2">\n    </span><span class="s1">node.specifiers.push(this.finishImportSpecifier(specifier, type));</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">finishImportSpecifier&lt;</span><span class="s2">\n    </span><span class="s1">T extends</span><span class="s2">\n      </span><span class="s1">| N.ImportSpecifier</span><span class="s2">\n      </span><span class="s1">| N.ImportDefaultSpecifier</span><span class="s2">\n      </span><span class="s1">| N.ImportNamespaceSpecifier,</span><span class="s2">\n  </span><span class="s1">&gt;(specifier: Undone&lt;T&gt;, type: T[</span><span class="s2">\&quot;</span><span class="s1">type</span><span class="s2">\&quot;</span><span class="s1">], bindingType = BIND_LEXICAL) {</span><span class="s2">\n    </span><span class="s1">this.checkLVal(specifier.local, {</span><span class="s2">\n      </span><span class="s1">in: { type },</span><span class="s2">\n      </span><span class="s1">binding: bindingType,</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">return this.finishNode(specifier, type);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* parse assert entries</span><span class="s2">\n   </span><span class="s1">*</span><span class="s2">\n   </span><span class="s1">* @see {@link https://tc39.es/proposal-import-assertions/#prod-AssertEntries AssertEntries}</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">parseAssertEntries(): N.ImportAttribute[] {</span><span class="s2">\n    </span><span class="s1">const attrs = [];</span><span class="s2">\n    </span><span class="s1">const attrNames = new Set();</span><span class="s2">\n\n    </span><span class="s1">do {</span><span class="s2">\n      </span><span class="s1">if (this.match(tt.braceR)) {</span><span class="s2">\n        </span><span class="s1">break;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">const node = this.startNode&lt;N.ImportAttribute&gt;();</span><span class="s2">\n\n      </span><span class="s1">// parse AssertionKey : IdentifierName, StringLiteral</span><span class="s2">\n      </span><span class="s1">const keyName = this.state.value;</span><span class="s2">\n      </span><span class="s1">// check if we already have an entry for an attribute</span><span class="s2">\n      </span><span class="s1">// if a duplicate entry is found, throw an error</span><span class="s2">\n      </span><span class="s1">// for now this logic will come into play only when someone declares `type` twice</span><span class="s2">\n      </span><span class="s1">if (attrNames.has(keyName)) {</span><span class="s2">\n        </span><span class="s1">this.raise(Errors.ModuleAttributesWithDuplicateKeys, {</span><span class="s2">\n          </span><span class="s1">at: this.state.startLoc,</span><span class="s2">\n          </span><span class="s1">key: keyName,</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">attrNames.add(keyName);</span><span class="s2">\n      </span><span class="s1">if (this.match(tt.string)) {</span><span class="s2">\n        </span><span class="s1">node.key = this.parseStringLiteral(keyName);</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">node.key = this.parseIdentifier(true);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">this.expect(tt.colon);</span><span class="s2">\n\n      </span><span class="s1">if (!this.match(tt.string)) {</span><span class="s2">\n        </span><span class="s1">throw this.raise(Errors.ModuleAttributeInvalidValue, {</span><span class="s2">\n          </span><span class="s1">at: this.state.startLoc,</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">node.value = this.parseStringLiteral(this.state.value);</span><span class="s2">\n      </span><span class="s1">attrs.push(this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">ImportAttribute</span><span class="s2">\&quot;</span><span class="s1">));</span><span class="s2">\n    </span><span class="s1">} while (this.eat(tt.comma));</span><span class="s2">\n\n    </span><span class="s1">return attrs;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">/**</span><span class="s2">\n   </span><span class="s1">* parse module attributes</span><span class="s2">\n   </span><span class="s1">* @deprecated It will be removed in Babel 8</span><span class="s2">\n   </span><span class="s1">*/</span><span class="s2">\n  </span><span class="s1">maybeParseModuleAttributes() {</span><span class="s2">\n    </span><span class="s1">if (this.match(tt._with) &amp;&amp; !this.hasPrecedingLineBreak()) {</span><span class="s2">\n      </span><span class="s1">this.expectPlugin(</span><span class="s2">\&quot;</span><span class="s1">moduleAttributes</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">this.next();</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">if (this.hasPlugin(</span><span class="s2">\&quot;</span><span class="s1">moduleAttributes</span><span class="s2">\&quot;</span><span class="s1">)) return [];</span><span class="s2">\n      </span><span class="s1">return null;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">const attrs = [];</span><span class="s2">\n    </span><span class="s1">const attributes = new Set();</span><span class="s2">\n    </span><span class="s1">do {</span><span class="s2">\n      </span><span class="s1">const node = this.startNode();</span><span class="s2">\n      </span><span class="s1">node.key = this.parseIdentifier(true);</span><span class="s2">\n\n      </span><span class="s1">if (node.key.name !== </span><span class="s2">\&quot;</span><span class="s1">type</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n        </span><span class="s1">this.raise(Errors.ModuleAttributeDifferentFromType, {</span><span class="s2">\n          </span><span class="s1">at: node.key,</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">if (attributes.has(node.key.name)) {</span><span class="s2">\n        </span><span class="s1">this.raise(Errors.ModuleAttributesWithDuplicateKeys, {</span><span class="s2">\n          </span><span class="s1">at: node.key,</span><span class="s2">\n          </span><span class="s1">key: node.key.name,</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">attributes.add(node.key.name);</span><span class="s2">\n      </span><span class="s1">this.expect(tt.colon);</span><span class="s2">\n      </span><span class="s1">if (!this.match(tt.string)) {</span><span class="s2">\n        </span><span class="s1">throw this.raise(Errors.ModuleAttributeInvalidValue, {</span><span class="s2">\n          </span><span class="s1">at: this.state.startLoc,</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">node.value = this.parseStringLiteral(this.state.value);</span><span class="s2">\n      </span><span class="s1">this.finishNode(node, </span><span class="s2">\&quot;</span><span class="s1">ImportAttribute</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">attrs.push(node);</span><span class="s2">\n    </span><span class="s1">} while (this.eat(tt.comma));</span><span class="s2">\n\n    </span><span class="s1">return attrs;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">maybeParseImportAssertions() {</span><span class="s2">\n    </span><span class="s1">// [no LineTerminator here] AssertClause</span><span class="s2">\n    </span><span class="s1">if (this.isContextual(tt._assert) &amp;&amp; !this.hasPrecedingLineBreak()) {</span><span class="s2">\n      </span><span class="s1">this.expectPlugin(</span><span class="s2">\&quot;</span><span class="s1">importAssertions</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">this.next(); // eat `assert`</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">if (this.hasPlugin(</span><span class="s2">\&quot;</span><span class="s1">importAssertions</span><span class="s2">\&quot;</span><span class="s1">)) return [];</span><span class="s2">\n      </span><span class="s1">return null;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// https://tc39.es/proposal-import-assertions/#prod-AssertClause</span><span class="s2">\n    </span><span class="s1">this.eat(tt.braceL);</span><span class="s2">\n    </span><span class="s1">const attrs = this.parseAssertEntries();</span><span class="s2">\n    </span><span class="s1">this.eat(tt.braceR);</span><span class="s2">\n\n    </span><span class="s1">return attrs;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">maybeParseDefaultImportSpecifier(node: Undone&lt;N.ImportDeclaration&gt;): boolean {</span><span class="s2">\n    </span><span class="s1">if (this.shouldParseDefaultImport(node)) {</span><span class="s2">\n      </span><span class="s1">// import defaultObj, { x, y as z } from '...'</span><span class="s2">\n      </span><span class="s1">this.parseImportSpecifierLocal(</span><span class="s2">\n        </span><span class="s1">node,</span><span class="s2">\n        </span><span class="s1">this.startNode&lt;N.ImportDefaultSpecifier&gt;(),</span><span class="s2">\n        \&quot;</span><span class="s1">ImportDefaultSpecifier</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">return true;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return false;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">maybeParseStarImportSpecifier(node: Undone&lt;N.ImportDeclaration&gt;): boolean {</span><span class="s2">\n    </span><span class="s1">if (this.match(tt.star)) {</span><span class="s2">\n      </span><span class="s1">const specifier = this.startNode&lt;N.ImportNamespaceSpecifier&gt;();</span><span class="s2">\n      </span><span class="s1">this.next();</span><span class="s2">\n      </span><span class="s1">this.expectContextual(tt._as);</span><span class="s2">\n\n      </span><span class="s1">this.parseImportSpecifierLocal(</span><span class="s2">\n        </span><span class="s1">node,</span><span class="s2">\n        </span><span class="s1">specifier,</span><span class="s2">\n        \&quot;</span><span class="s1">ImportNamespaceSpecifier</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">return true;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return false;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">parseNamedImportSpecifiers(node: Undone&lt;N.ImportDeclaration&gt;) {</span><span class="s2">\n    </span><span class="s1">let first = true;</span><span class="s2">\n    </span><span class="s1">this.expect(tt.braceL);</span><span class="s2">\n    </span><span class="s1">while (!this.eat(tt.braceR)) {</span><span class="s2">\n      </span><span class="s1">if (first) {</span><span class="s2">\n        </span><span class="s1">first = false;</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">// Detect an attempt to deep destructure</span><span class="s2">\n        </span><span class="s1">if (this.eat(tt.colon)) {</span><span class="s2">\n          </span><span class="s1">throw this.raise(Errors.DestructureNamedImport, {</span><span class="s2">\n            </span><span class="s1">at: this.state.startLoc,</span><span class="s2">\n          </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n\n        </span><span class="s1">this.expect(tt.comma);</span><span class="s2">\n        </span><span class="s1">if (this.eat(tt.braceR)) break;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">const specifier = this.startNode&lt;N.ImportSpecifier&gt;();</span><span class="s2">\n      </span><span class="s1">const importedIsString = this.match(tt.string);</span><span class="s2">\n      </span><span class="s1">const isMaybeTypeOnly = this.isContextual(tt._type);</span><span class="s2">\n      </span><span class="s1">specifier.imported = this.parseModuleExportName();</span><span class="s2">\n      </span><span class="s1">const importSpecifier = this.parseImportSpecifier(</span><span class="s2">\n        </span><span class="s1">specifier,</span><span class="s2">\n        </span><span class="s1">importedIsString,</span><span class="s2">\n        </span><span class="s1">node.importKind === </span><span class="s2">\&quot;</span><span class="s1">type</span><span class="s2">\&quot; </span><span class="s1">|| node.importKind === </span><span class="s2">\&quot;</span><span class="s1">typeof</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n        </span><span class="s1">isMaybeTypeOnly,</span><span class="s2">\n        </span><span class="s1">undefined,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">node.specifiers.push(importSpecifier);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// https://tc39.es/ecma262/#prod-ImportSpecifier</span><span class="s2">\n  </span><span class="s1">parseImportSpecifier(</span><span class="s2">\n    </span><span class="s1">specifier: Undone&lt;N.ImportSpecifier&gt;,</span><span class="s2">\n    </span><span class="s1">importedIsString: boolean,</span><span class="s2">\n    </span><span class="s1">/* eslint-disable @typescript-eslint/no-unused-vars -- used in TypeScript and Flow parser */</span><span class="s2">\n    </span><span class="s1">isInTypeOnlyImport: boolean,</span><span class="s2">\n    </span><span class="s1">isMaybeTypeOnly: boolean,</span><span class="s2">\n    </span><span class="s1">bindingType: BindingTypes | undefined,</span><span class="s2">\n    </span><span class="s1">/* eslint-enable @typescript-eslint/no-unused-vars */</span><span class="s2">\n  </span><span class="s1">): N.ImportSpecifier {</span><span class="s2">\n    </span><span class="s1">if (this.eatContextual(tt._as)) {</span><span class="s2">\n      </span><span class="s1">specifier.local = this.parseIdentifier();</span><span class="s2">\n    </span><span class="s1">} else {</span><span class="s2">\n      </span><span class="s1">const { imported } = specifier;</span><span class="s2">\n      </span><span class="s1">if (importedIsString) {</span><span class="s2">\n        </span><span class="s1">throw this.raise(Errors.ImportBindingIsString, {</span><span class="s2">\n          </span><span class="s1">at: specifier,</span><span class="s2">\n          </span><span class="s1">importName: (imported as N.StringLiteral).value,</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n      </span><span class="s1">this.checkReservedWord(</span><span class="s2">\n        </span><span class="s1">(imported as N.Identifier).name,</span><span class="s2">\n        </span><span class="s1">specifier.loc.start,</span><span class="s2">\n        </span><span class="s1">true,</span><span class="s2">\n        </span><span class="s1">true,</span><span class="s2">\n      </span><span class="s1">);</span><span class="s2">\n      </span><span class="s1">if (!specifier.local) {</span><span class="s2">\n        </span><span class="s1">specifier.local = cloneIdentifier(imported);</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return this.finishImportSpecifier(</span><span class="s2">\n      </span><span class="s1">specifier,</span><span class="s2">\n      \&quot;</span><span class="s1">ImportSpecifier</span><span class="s2">\&quot;</span><span class="s1">,</span><span class="s2">\n      </span><span class="s1">bindingType,</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// This is used in flow and typescript plugin</span><span class="s2">\n  </span><span class="s1">// Determine whether a parameter is a this param</span><span class="s2">\n  </span><span class="s1">isThisParam(</span><span class="s2">\n    </span><span class="s1">param: N.Pattern | N.Identifier | N.TSParameterProperty,</span><span class="s2">\n  </span><span class="s1">): boolean {</span><span class="s2">\n    </span><span class="s1">return param.type === </span><span class="s2">\&quot;</span><span class="s1">Identifier</span><span class="s2">\&quot; </span><span class="s1">&amp;&amp; param.name === </span><span class="s2">\&quot;</span><span class="s1">this</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">&quot;</span><span class="s2">,</span><span class="s1">&quot;import type { Options } from </span><span class="s2">\&quot;</span><span class="s1">../options</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type * as N from </span><span class="s2">\&quot;</span><span class="s1">../types</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type { PluginList } from </span><span class="s2">\&quot;</span><span class="s1">../plugin-utils</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import { getOptions } from </span><span class="s2">\&quot;</span><span class="s1">../options</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import StatementParser from </span><span class="s2">\&quot;</span><span class="s1">./statement</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import ScopeHandler from </span><span class="s2">\&quot;</span><span class="s1">../util/scope</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">export type PluginsMap = Map&lt;</span><span class="s2">\n  </span><span class="s1">string,</span><span class="s2">\n  </span><span class="s1">{</span><span class="s2">\n    </span><span class="s1">[x: string]: any;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">&gt;;</span><span class="s2">\n\n</span><span class="s1">export default class Parser extends StatementParser {</span><span class="s2">\n  </span><span class="s1">// Forward-declaration so typescript plugin can override jsx plugin</span><span class="s2">\n  </span><span class="s1">// todo(flow-&gt;ts) - this probably can be removed</span><span class="s2">\n  </span><span class="s1">// abstract jsxParseOpeningElementAfterName(</span><span class="s2">\n  </span><span class="s1">//   node: N.JSXOpeningElement,</span><span class="s2">\n  </span><span class="s1">// ): N.JSXOpeningElement;</span><span class="s2">\n\n  </span><span class="s1">constructor(options: Options | undefined | null, input: string) {</span><span class="s2">\n    </span><span class="s1">options = getOptions(options);</span><span class="s2">\n    </span><span class="s1">super(options, input);</span><span class="s2">\n\n    </span><span class="s1">this.options = options;</span><span class="s2">\n    </span><span class="s1">this.initializeScopes();</span><span class="s2">\n    </span><span class="s1">this.plugins = pluginsMap(this.options.plugins);</span><span class="s2">\n    </span><span class="s1">this.filename = options.sourceFilename;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">// This can be overwritten, for example, by the TypeScript plugin.</span><span class="s2">\n  </span><span class="s1">getScopeHandler(): {</span><span class="s2">\n    </span><span class="s1">new (...args: any): ScopeHandler;</span><span class="s2">\n  </span><span class="s1">} {</span><span class="s2">\n    </span><span class="s1">return ScopeHandler;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">parse(): N.File {</span><span class="s2">\n    </span><span class="s1">this.enterInitialScopes();</span><span class="s2">\n    </span><span class="s1">const file = this.startNode() as N.File;</span><span class="s2">\n    </span><span class="s1">const program = this.startNode() as N.Program;</span><span class="s2">\n    </span><span class="s1">this.nextToken();</span><span class="s2">\n    </span><span class="s1">file.errors = null;</span><span class="s2">\n    </span><span class="s1">this.parseTopLevel(file, program);</span><span class="s2">\n    </span><span class="s1">file.errors = this.state.errors;</span><span class="s2">\n    </span><span class="s1">return file;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function pluginsMap(plugins: PluginList): PluginsMap {</span><span class="s2">\n  </span><span class="s1">const pluginMap: PluginsMap = new Map();</span><span class="s2">\n  </span><span class="s1">for (const plugin of plugins) {</span><span class="s2">\n    </span><span class="s1">const [name, options] = Array.isArray(plugin) ? plugin : [plugin, {}];</span><span class="s2">\n    </span><span class="s1">if (!pluginMap.has(name)) pluginMap.set(name, options || {});</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return pluginMap;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">&quot;</span><span class="s2">,</span><span class="s1">&quot;import { type Options } from </span><span class="s2">\&quot;</span><span class="s1">./options</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import {</span><span class="s2">\n  </span><span class="s1">hasPlugin,</span><span class="s2">\n  </span><span class="s1">validatePlugins,</span><span class="s2">\n  </span><span class="s1">mixinPluginNames,</span><span class="s2">\n  </span><span class="s1">mixinPlugins,</span><span class="s2">\n  </span><span class="s1">type PluginList,</span><span class="s2">\n</span><span class="s1">} from </span><span class="s2">\&quot;</span><span class="s1">./plugin-utils</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import type {</span><span class="s2">\n  </span><span class="s1">PluginConfig as ParserPlugin,</span><span class="s2">\n  </span><span class="s1">FlowPluginOptions,</span><span class="s2">\n  </span><span class="s1">RecordAndTuplePluginOptions,</span><span class="s2">\n  </span><span class="s1">PipelineOperatorPluginOptions,</span><span class="s2">\n</span><span class="s1">} from </span><span class="s2">\&quot;</span><span class="s1">./typings</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import Parser from </span><span class="s2">\&quot;</span><span class="s1">./parser</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">import type { ExportedTokenType } from </span><span class="s2">\&quot;</span><span class="s1">./tokenizer/types</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import {</span><span class="s2">\n  </span><span class="s1">getExportedToken,</span><span class="s2">\n  </span><span class="s1">tt as internalTokenTypes,</span><span class="s2">\n  </span><span class="s1">type InternalTokenTypes,</span><span class="s2">\n</span><span class="s1">} from </span><span class="s2">\&quot;</span><span class="s1">./tokenizer/types</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">import </span><span class="s2">\&quot;</span><span class="s1">./tokenizer/context</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">import type { Expression, File } from </span><span class="s2">\&quot;</span><span class="s1">./types</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">export function parse(input: string, options?: Options): File {</span><span class="s2">\n  </span><span class="s1">if (options?.sourceType === </span><span class="s2">\&quot;</span><span class="s1">unambiguous</span><span class="s2">\&quot;</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">options = {</span><span class="s2">\n      </span><span class="s1">...options,</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">try {</span><span class="s2">\n      </span><span class="s1">options.sourceType = </span><span class="s2">\&quot;</span><span class="s1">module</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n      </span><span class="s1">const parser = getParser(options, input);</span><span class="s2">\n      </span><span class="s1">const ast = parser.parse();</span><span class="s2">\n\n      </span><span class="s1">if (parser.sawUnambiguousESM) {</span><span class="s2">\n        </span><span class="s1">return ast;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">if (parser.ambiguousScriptDifferentAst) {</span><span class="s2">\n        </span><span class="s1">// Top level await introduces code which can be both a valid script and</span><span class="s2">\n        </span><span class="s1">// a valid module, but which produces different ASTs:</span><span class="s2">\n        </span><span class="s1">//    await</span><span class="s2">\n        </span><span class="s1">//    0</span><span class="s2">\n        </span><span class="s1">// can be parsed either as an AwaitExpression, or as two ExpressionStatements.</span><span class="s2">\n        </span><span class="s1">try {</span><span class="s2">\n          </span><span class="s1">options.sourceType = </span><span class="s2">\&quot;</span><span class="s1">script</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n          </span><span class="s1">return getParser(options, input).parse();</span><span class="s2">\n        </span><span class="s1">} catch {}</span><span class="s2">\n      </span><span class="s1">} else {</span><span class="s2">\n        </span><span class="s1">// This is both a valid module and a valid script, but</span><span class="s2">\n        </span><span class="s1">// we parse it as a script by default</span><span class="s2">\n        </span><span class="s1">ast.program.sourceType = </span><span class="s2">\&quot;</span><span class="s1">script</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n      </span><span class="s1">}</span><span class="s2">\n\n      </span><span class="s1">return ast;</span><span class="s2">\n    </span><span class="s1">} catch (moduleError) {</span><span class="s2">\n      </span><span class="s1">try {</span><span class="s2">\n        </span><span class="s1">options.sourceType = </span><span class="s2">\&quot;</span><span class="s1">script</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n        </span><span class="s1">return getParser(options, input).parse();</span><span class="s2">\n      </span><span class="s1">} catch {}</span><span class="s2">\n\n      </span><span class="s1">throw moduleError;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">} else {</span><span class="s2">\n    </span><span class="s1">return getParser(options, input).parse();</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">export function parseExpression(input: string, options?: Options): Expression {</span><span class="s2">\n  </span><span class="s1">const parser = getParser(options, input);</span><span class="s2">\n  </span><span class="s1">if (parser.options.strictMode) {</span><span class="s2">\n    </span><span class="s1">parser.state.strict = true;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return parser.getExpression();</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function generateExportedTokenTypes(</span><span class="s2">\n  </span><span class="s1">internalTokenTypes: InternalTokenTypes,</span><span class="s2">\n</span><span class="s1">): Record&lt;string, ExportedTokenType&gt; {</span><span class="s2">\n  </span><span class="s1">const tokenTypes: Record&lt;string, ExportedTokenType&gt; = {};</span><span class="s2">\n  </span><span class="s1">for (const typeName of Object.keys(</span><span class="s2">\n    </span><span class="s1">internalTokenTypes,</span><span class="s2">\n  </span><span class="s1">) as (keyof InternalTokenTypes)[]) {</span><span class="s2">\n    </span><span class="s1">tokenTypes[typeName] = getExportedToken(internalTokenTypes[typeName]);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return tokenTypes;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">export const tokTypes = generateExportedTokenTypes(internalTokenTypes);</span><span class="s2">\n\n</span><span class="s1">function getParser(options: Options | undefined | null, input: string): Parser {</span><span class="s2">\n  </span><span class="s1">let cls = Parser;</span><span class="s2">\n  </span><span class="s1">if (options?.plugins) {</span><span class="s2">\n    </span><span class="s1">validatePlugins(options.plugins);</span><span class="s2">\n    </span><span class="s1">cls = getParserClass(options.plugins);</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n\n  </span><span class="s1">return new cls(options, input);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">const parserClassCache: { [key: string]: { new (...args: any): Parser } } = {};</span><span class="s2">\n\n</span><span class="s1">/** Get a Parser class with plugins applied. */</span><span class="s2">\n</span><span class="s1">function getParserClass(pluginsFromOptions: PluginList): {</span><span class="s2">\n  </span><span class="s1">new (...args: any): Parser;</span><span class="s2">\n</span><span class="s1">} {</span><span class="s2">\n  </span><span class="s1">const pluginList = mixinPluginNames.filter(name =&gt;</span><span class="s2">\n    </span><span class="s1">hasPlugin(pluginsFromOptions, name),</span><span class="s2">\n  </span><span class="s1">);</span><span class="s2">\n\n  </span><span class="s1">const key = pluginList.join(</span><span class="s2">\&quot;</span><span class="s1">/</span><span class="s2">\&quot;</span><span class="s1">);</span><span class="s2">\n  </span><span class="s1">let cls = parserClassCache[key];</span><span class="s2">\n  </span><span class="s1">if (!cls) {</span><span class="s2">\n    </span><span class="s1">cls = Parser;</span><span class="s2">\n    </span><span class="s1">for (const plugin of pluginList) {</span><span class="s2">\n      </span><span class="s1">// @ts-expect-error todo(flow-&gt;ts)</span><span class="s2">\n      </span><span class="s1">cls = mixinPlugins[plugin](cls);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">parserClassCache[key] = cls;</span><span class="s2">\n  </span><span class="s1">}</span><span class="s2">\n  </span><span class="s1">return cls;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">export type {</span><span class="s2">\n  </span><span class="s1">FlowPluginOptions,</span><span class="s2">\n  </span><span class="s1">ParserPlugin,</span><span class="s2">\n  </span><span class="s1">PipelineOperatorPluginOptions,</span><span class="s2">\n  </span><span class="s1">RecordAndTuplePluginOptions,</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">export type ParserOptions = Partial&lt;Options&gt;;</span><span class="s2">\n</span><span class="s1">&quot;</span><span class="s0">]</span><span class="s2">,</span><span class="s1">&quot;names&quot;</span><span class="s2">:</span><span class="s0">[</span><span class="s1">&quot;defaultOptions&quot;</span><span class="s2">,</span><span class="s1">&quot;sourceType&quot;</span><span class="s2">,</span><span class="s1">&quot;sourceFilename&quot;</span><span class="s2">,</span><span class="s1">&quot;undefined&quot;</span><span class="s2">,</span><span class="s1">&quot;startColumn&quot;</span><span class="s2">,</span><span class="s1">&quot;startLine&quot;</span><span class="s2">,</span><span class="s1">&quot;allowAwaitOutsideFunction&quot;</span><span class="s2">,</span><span class="s1">&quot;allowReturnOutsideFunction&quot;</span><span class="s2">,</span><span class="s1">&quot;allowNewTargetOutsideFunction&quot;</span><span class="s2">,</span><span class="s1">&quot;allowImportExportEverywhere&quot;</span><span class="s2">,</span><span class="s1">&quot;allowSuperOutsideMethod&quot;</span><span class="s2">,</span><span class="s1">&quot;allowUndeclaredExports&quot;</span><span class="s2">,</span><span class="s1">&quot;plugins&quot;</span><span class="s2">,</span><span class="s1">&quot;strictMode&quot;</span><span class="s2">,</span><span class="s1">&quot;ranges&quot;</span><span class="s2">,</span><span class="s1">&quot;tokens&quot;</span><span class="s2">,</span><span class="s1">&quot;createParenthesizedExpressions&quot;</span><span class="s2">,</span><span class="s1">&quot;errorRecovery&quot;</span><span class="s2">,</span><span class="s1">&quot;attachComment&quot;</span><span class="s2">,</span><span class="s1">&quot;annexB&quot;</span><span class="s2">,</span><span class="s1">&quot;getOptions&quot;</span><span class="s2">,</span><span class="s1">&quot;opts&quot;</span><span class="s2">,</span><span class="s1">&quot;Error&quot;</span><span class="s2">,</span><span class="s1">&quot;options&quot;</span><span class="s2">,</span><span class="s1">&quot;key&quot;</span><span class="s2">,</span><span class="s1">&quot;Object&quot;</span><span class="s2">,</span><span class="s1">&quot;keys&quot;</span><span class="s2">,</span><span class="s1">&quot;TokContext&quot;</span><span class="s2">,</span><span class="s1">&quot;constructor&quot;</span><span class="s2">,</span><span class="s1">&quot;token&quot;</span><span class="s2">,</span><span class="s1">&quot;preserveSpace&quot;</span><span class="s2">,</span><span class="s1">&quot;types&quot;</span><span class="s2">,</span><span class="s1">&quot;brace&quot;</span><span class="s2">,</span><span class="s1">&quot;j_oTag&quot;</span><span class="s2">,</span><span class="s1">&quot;j_cTag&quot;</span><span class="s2">,</span><span class="s1">&quot;j_expr&quot;</span><span class="s2">,</span><span class="s1">&quot;template&quot;</span><span class="s2">,</span><span class="s1">&quot;beforeExpr&quot;</span><span class="s2">,</span><span class="s1">&quot;startsExpr&quot;</span><span class="s2">,</span><span class="s1">&quot;isLoop&quot;</span><span class="s2">,</span><span class="s1">&quot;isAssign&quot;</span><span class="s2">,</span><span class="s1">&quot;prefix&quot;</span><span class="s2">,</span><span class="s1">&quot;postfix&quot;</span><span class="s2">,</span><span class="s1">&quot;ExportedTokenType&quot;</span><span class="s2">,</span><span class="s1">&quot;label&quot;</span><span class="s2">,</span><span class="s1">&quot;conf&quot;</span><span class="s2">,</span><span class="s1">&quot;keyword&quot;</span><span class="s2">,</span><span class="s1">&quot;rightAssociative&quot;</span><span class="s2">,</span><span class="s1">&quot;binop&quot;</span><span class="s2">,</span><span class="s1">&quot;updateContext&quot;</span><span class="s2">,</span><span class="s1">&quot;keywords&quot;</span><span class="s2">,</span><span class="s1">&quot;Map&quot;</span><span class="s2">,</span><span class="s1">&quot;createKeyword&quot;</span><span class="s2">,</span><span class="s1">&quot;name&quot;</span><span class="s2">,</span><span class="s1">&quot;createToken&quot;</span><span class="s2">,</span><span class="s1">&quot;set&quot;</span><span class="s2">,</span><span class="s1">&quot;createBinop&quot;</span><span class="s2">,</span><span class="s1">&quot;tokenTypeCounter&quot;</span><span class="s2">,</span><span class="s1">&quot;tokenTypes&quot;</span><span class="s2">,</span><span class="s1">&quot;tokenLabels&quot;</span><span class="s2">,</span><span class="s1">&quot;tokenBinops&quot;</span><span class="s2">,</span><span class="s1">&quot;tokenBeforeExprs&quot;</span><span class="s2">,</span><span class="s1">&quot;tokenStartsExprs&quot;</span><span class="s2">,</span><span class="s1">&quot;tokenPrefixes&quot;</span><span class="s2">,</span><span class="s1">&quot;_options$binop&quot;</span><span class="s2">,</span><span class="s1">&quot;_options$beforeExpr&quot;</span><span class="s2">,</span><span class="s1">&quot;_options$startsExpr&quot;</span><span class="s2">,</span><span class="s1">&quot;_options$prefix&quot;</span><span class="s2">,</span><span class="s1">&quot;push&quot;</span><span class="s2">,</span><span class="s1">&quot;createKeywordLike&quot;</span><span class="s2">,</span><span class="s1">&quot;_options$binop2&quot;</span><span class="s2">,</span><span class="s1">&quot;_options$beforeExpr2&quot;</span><span class="s2">,</span><span class="s1">&quot;_options$startsExpr2&quot;</span><span class="s2">,</span><span class="s1">&quot;_options$prefix2&quot;</span><span class="s2">,</span><span class="s1">&quot;tt&quot;</span><span class="s2">,</span><span class="s1">&quot;bracketL&quot;</span><span class="s2">,</span><span class="s1">&quot;bracketHashL&quot;</span><span class="s2">,</span><span class="s1">&quot;bracketBarL&quot;</span><span class="s2">,</span><span class="s1">&quot;bracketR&quot;</span><span class="s2">,</span><span class="s1">&quot;bracketBarR&quot;</span><span class="s2">,</span><span class="s1">&quot;braceL&quot;</span><span class="s2">,</span><span class="s1">&quot;braceBarL&quot;</span><span class="s2">,</span><span class="s1">&quot;braceHashL&quot;</span><span class="s2">,</span><span class="s1">&quot;braceR&quot;</span><span class="s2">,</span><span class="s1">&quot;braceBarR&quot;</span><span class="s2">,</span><span class="s1">&quot;parenL&quot;</span><span class="s2">,</span><span class="s1">&quot;parenR&quot;</span><span class="s2">,</span><span class="s1">&quot;comma&quot;</span><span class="s2">,</span><span class="s1">&quot;semi&quot;</span><span class="s2">,</span><span class="s1">&quot;colon&quot;</span><span class="s2">,</span><span class="s1">&quot;doubleColon&quot;</span><span class="s2">,</span><span class="s1">&quot;dot&quot;</span><span class="s2">,</span><span class="s1">&quot;question&quot;</span><span class="s2">,</span><span class="s1">&quot;questionDot&quot;</span><span class="s2">,</span><span class="s1">&quot;arrow&quot;</span><span class="s2">,</span><span class="s1">&quot;ellipsis&quot;</span><span class="s2">,</span><span class="s1">&quot;backQuote&quot;</span><span class="s2">,</span><span class="s1">&quot;dollarBraceL&quot;</span><span class="s2">,</span><span class="s1">&quot;templateTail&quot;</span><span class="s2">,</span><span class="s1">&quot;templateNonTail&quot;</span><span class="s2">,</span><span class="s1">&quot;at&quot;</span><span class="s2">,</span><span class="s1">&quot;hash&quot;</span><span class="s2">,</span><span class="s1">&quot;interpreterDirective&quot;</span><span class="s2">,</span><span class="s1">&quot;eq&quot;</span><span class="s2">,</span><span class="s1">&quot;assign&quot;</span><span class="s2">,</span><span class="s1">&quot;slashAssign&quot;</span><span class="s2">,</span><span class="s1">&quot;xorAssign&quot;</span><span class="s2">,</span><span class="s1">&quot;moduloAssign&quot;</span><span class="s2">,</span><span class="s1">&quot;incDec&quot;</span><span class="s2">,</span><span class="s1">&quot;bang&quot;</span><span class="s2">,</span><span class="s1">&quot;tilde&quot;</span><span class="s2">,</span><span class="s1">&quot;doubleCaret&quot;</span><span class="s2">,</span><span class="s1">&quot;doubleAt&quot;</span><span class="s2">,</span><span class="s1">&quot;pipeline&quot;</span><span class="s2">,</span><span class="s1">&quot;nullishCoalescing&quot;</span><span class="s2">,</span><span class="s1">&quot;logicalOR&quot;</span><span class="s2">,</span><span class="s1">&quot;logicalAND&quot;</span><span class="s2">,</span><span class="s1">&quot;bitwiseOR&quot;</span><span class="s2">,</span><span class="s1">&quot;bitwiseXOR&quot;</span><span class="s2">,</span><span class="s1">&quot;bitwiseAND&quot;</span><span class="s2">,</span><span class="s1">&quot;equality&quot;</span><span class="s2">,</span><span class="s1">&quot;lt&quot;</span><span class="s2">,</span><span class="s1">&quot;gt&quot;</span><span class="s2">,</span><span class="s1">&quot;relational&quot;</span><span class="s2">,</span><span class="s1">&quot;bitShift&quot;</span><span class="s2">,</span><span class="s1">&quot;bitShiftL&quot;</span><span class="s2">,</span><span class="s1">&quot;bitShiftR&quot;</span><span class="s2">,</span><span class="s1">&quot;plusMin&quot;</span><span class="s2">,</span><span class="s1">&quot;modulo&quot;</span><span class="s2">,</span><span class="s1">&quot;star&quot;</span><span class="s2">,</span><span class="s1">&quot;slash&quot;</span><span class="s2">,</span><span class="s1">&quot;exponent&quot;</span><span class="s2">,</span><span class="s1">&quot;_in&quot;</span><span class="s2">,</span><span class="s1">&quot;_instanceof&quot;</span><span class="s2">,</span><span class="s1">&quot;_break&quot;</span><span class="s2">,</span><span class="s1">&quot;_case&quot;</span><span class="s2">,</span><span class="s1">&quot;_catch&quot;</span><span class="s2">,</span><span class="s1">&quot;_continue&quot;</span><span class="s2">,</span><span class="s1">&quot;_debugger&quot;</span><span class="s2">,</span><span class="s1">&quot;_default&quot;</span><span class="s2">,</span><span class="s1">&quot;_else&quot;</span><span class="s2">,</span><span class="s1">&quot;_finally&quot;</span><span class="s2">,</span><span class="s1">&quot;_function&quot;</span><span class="s2">,</span><span class="s1">&quot;_if&quot;</span><span class="s2">,</span><span class="s1">&quot;_return&quot;</span><span class="s2">,</span><span class="s1">&quot;_switch&quot;</span><span class="s2">,</span><span class="s1">&quot;_throw&quot;</span><span class="s2">,</span><span class="s1">&quot;_try&quot;</span><span class="s2">,</span><span class="s1">&quot;_var&quot;</span><span class="s2">,</span><span class="s1">&quot;_const&quot;</span><span class="s2">,</span><span class="s1">&quot;_with&quot;</span><span class="s2">,</span><span class="s1">&quot;_new&quot;</span><span class="s2">,</span><span class="s1">&quot;_this&quot;</span><span class="s2">,</span><span class="s1">&quot;_super&quot;</span><span class="s2">,</span><span class="s1">&quot;_class&quot;</span><span class="s2">,</span><span class="s1">&quot;_extends&quot;</span><span class="s2">,</span><span class="s1">&quot;_export&quot;</span><span class="s2">,</span><span class="s1">&quot;_import&quot;</span><span class="s2">,</span><span class="s1">&quot;_null&quot;</span><span class="s2">,</span><span class="s1">&quot;_true&quot;</span><span class="s2">,</span><span class="s1">&quot;_false&quot;</span><span class="s2">,</span><span class="s1">&quot;_typeof&quot;</span><span class="s2">,</span><span class="s1">&quot;_void&quot;</span><span class="s2">,</span><span class="s1">&quot;_delete&quot;</span><span class="s2">,</span><span class="s1">&quot;_do&quot;</span><span class="s2">,</span><span class="s1">&quot;_for&quot;</span><span class="s2">,</span><span class="s1">&quot;_while&quot;</span><span class="s2">,</span><span class="s1">&quot;_as&quot;</span><span class="s2">,</span><span class="s1">&quot;_assert&quot;</span><span class="s2">,</span><span class="s1">&quot;_async&quot;</span><span class="s2">,</span><span class="s1">&quot;_await&quot;</span><span class="s2">,</span><span class="s1">&quot;_from&quot;</span><span class="s2">,</span><span class="s1">&quot;_get&quot;</span><span class="s2">,</span><span class="s1">&quot;_let&quot;</span><span class="s2">,</span><span class="s1">&quot;_meta&quot;</span><span class="s2">,</span><span class="s1">&quot;_of&quot;</span><span class="s2">,</span><span class="s1">&quot;_sent&quot;</span><span class="s2">,</span><span class="s1">&quot;_set&quot;</span><span class="s2">,</span><span class="s1">&quot;_static&quot;</span><span class="s2">,</span><span class="s1">&quot;_using&quot;</span><span class="s2">,</span><span class="s1">&quot;_yield&quot;</span><span class="s2">,</span><span class="s1">&quot;_asserts&quot;</span><span class="s2">,</span><span class="s1">&quot;_checks&quot;</span><span class="s2">,</span><span class="s1">&quot;_exports&quot;</span><span class="s2">,</span><span class="s1">&quot;_global&quot;</span><span class="s2">,</span><span class="s1">&quot;_implements&quot;</span><span class="s2">,</span><span class="s1">&quot;_intrinsic&quot;</span><span class="s2">,</span><span class="s1">&quot;_infer&quot;</span><span class="s2">,</span><span class="s1">&quot;_is&quot;</span><span class="s2">,</span><span class="s1">&quot;_mixins&quot;</span><span class="s2">,</span><span class="s1">&quot;_proto&quot;</span><span class="s2">,</span><span class="s1">&quot;_require&quot;</span><span class="s2">,</span><span class="s1">&quot;_satisfies&quot;</span><span class="s2">,</span><span class="s1">&quot;_keyof&quot;</span><span class="s2">,</span><span class="s1">&quot;_readonly&quot;</span><span class="s2">,</span><span class="s1">&quot;_unique&quot;</span><span class="s2">,</span><span class="s1">&quot;_abstract&quot;</span><span class="s2">,</span><span class="s1">&quot;_declare&quot;</span><span class="s2">,</span><span class="s1">&quot;_enum&quot;</span><span class="s2">,</span><span class="s1">&quot;_module&quot;</span><span class="s2">,</span><span class="s1">&quot;_namespace&quot;</span><span class="s2">,</span><span class="s1">&quot;_interface&quot;</span><span class="s2">,</span><span class="s1">&quot;_type&quot;</span><span class="s2">,</span><span class="s1">&quot;_opaque&quot;</span><span class="s2">,</span><span class="s1">&quot;string&quot;</span><span class="s2">,</span><span class="s1">&quot;num&quot;</span><span class="s2">,</span><span class="s1">&quot;bigint&quot;</span><span class="s2">,</span><span class="s1">&quot;decimal&quot;</span><span class="s2">,</span><span class="s1">&quot;regexp&quot;</span><span class="s2">,</span><span class="s1">&quot;privateName&quot;</span><span class="s2">,</span><span class="s1">&quot;eof&quot;</span><span class="s2">,</span><span class="s1">&quot;jsxName&quot;</span><span class="s2">,</span><span class="s1">&quot;jsxText&quot;</span><span class="s2">,</span><span class="s1">&quot;jsxTagStart&quot;</span><span class="s2">,</span><span class="s1">&quot;jsxTagEnd&quot;</span><span class="s2">,</span><span class="s1">&quot;placeholder&quot;</span><span class="s2">,</span><span class="s1">&quot;tokenIsIdentifier&quot;</span><span class="s2">,</span><span class="s1">&quot;tokenKeywordOrIdentifierIsKeyword&quot;</span><span class="s2">,</span><span class="s1">&quot;tokenIsKeywordOrIdentifier&quot;</span><span class="s2">,</span><span class="s1">&quot;tokenIsLiteralPropertyName&quot;</span><span class="s2">,</span><span class="s1">&quot;tokenComesBeforeExpression&quot;</span><span class="s2">,</span><span class="s1">&quot;tokenCanStartExpression&quot;</span><span class="s2">,</span><span class="s1">&quot;tokenIsAssignment&quot;</span><span class="s2">,</span><span class="s1">&quot;tokenIsFlowInterfaceOrTypeOrOpaque&quot;</span><span class="s2">,</span><span class="s1">&quot;tokenIsLoop&quot;</span><span class="s2">,</span><span class="s1">&quot;tokenIsKeyword&quot;</span><span class="s2">,</span><span class="s1">&quot;tokenIsOperator&quot;</span><span class="s2">,</span><span class="s1">&quot;tokenIsPostfix&quot;</span><span class="s2">,</span><span class="s1">&quot;tokenIsPrefix&quot;</span><span class="s2">,</span><span class="s1">&quot;tokenIsTSTypeOperator&quot;</span><span class="s2">,</span><span class="s1">&quot;tokenIsTSDeclarationStart&quot;</span><span class="s2">,</span><span class="s1">&quot;tokenLabelName&quot;</span><span class="s2">,</span><span class="s1">&quot;tokenOperatorPrecedence&quot;</span><span class="s2">,</span><span class="s1">&quot;tokenIsRightAssociative&quot;</span><span class="s2">,</span><span class="s1">&quot;tokenIsTemplate&quot;</span><span class="s2">,</span><span class="s1">&quot;getExportedToken&quot;</span><span class="s2">,</span><span class="s1">&quot;context&quot;</span><span class="s2">,</span><span class="s1">&quot;pop&quot;</span><span class="s2">,</span><span class="s1">&quot;tc&quot;</span><span class="s2">,</span><span class="s1">&quot;length&quot;</span><span class="s2">,</span><span class="s1">&quot;Position&quot;</span><span class="s2">,</span><span class="s1">&quot;line&quot;</span><span class="s2">,</span><span class="s1">&quot;col&quot;</span><span class="s2">,</span><span class="s1">&quot;index&quot;</span><span class="s2">,</span><span class="s1">&quot;column&quot;</span><span class="s2">,</span><span class="s1">&quot;SourceLocation&quot;</span><span class="s2">,</span><span class="s1">&quot;start&quot;</span><span class="s2">,</span><span class="s1">&quot;end&quot;</span><span class="s2">,</span><span class="s1">&quot;filename&quot;</span><span class="s2">,</span><span class="s1">&quot;identifierName&quot;</span><span class="s2">,</span><span class="s1">&quot;createPositionWithColumnOffset&quot;</span><span class="s2">,</span><span class="s1">&quot;position&quot;</span><span class="s2">,</span><span class="s1">&quot;columnOffset&quot;</span><span class="s2">,</span><span class="s1">&quot;ParseErrorCode&quot;</span><span class="s2">,</span><span class="s1">&quot;SyntaxError&quot;</span><span class="s2">,</span><span class="s1">&quot;SourceTypeModuleError&quot;</span><span class="s2">,</span><span class="s1">&quot;reflect&quot;</span><span class="s2">,</span><span class="s1">&quot;last&quot;</span><span class="s2">,</span><span class="s1">&quot;get&quot;</span><span class="s2">,</span><span class="s1">&quot;reduce&quot;</span><span class="s2">,</span><span class="s1">&quot;object&quot;</span><span class="s2">,</span><span class="s1">&quot;value&quot;</span><span class="s2">,</span><span class="s1">&quot;item&quot;</span><span class="s2">,</span><span class="s1">&quot;i&quot;</span><span class="s2">,</span><span class="s1">&quot;instantiate&quot;</span><span class="s2">,</span><span class="s1">&quot;properties&quot;</span><span class="s2">,</span><span class="s1">&quot;descriptors&quot;</span><span class="s2">,</span><span class="s1">&quot;map&quot;</span><span class="s2">,</span><span class="s1">&quot;filter&quot;</span><span class="s2">,</span><span class="s1">&quot;descriptor&quot;</span><span class="s2">,</span><span class="s1">&quot;enumerable&quot;</span><span class="s2">,</span><span class="s1">&quot;split&quot;</span><span class="s2">,</span><span class="s1">&quot;instance&quot;</span><span class="s2">,</span><span class="s1">&quot;defineProperty&quot;</span><span class="s2">,</span><span class="s1">&quot;configurable&quot;</span><span class="s2">,</span><span class="s1">&quot;ModuleErrors&quot;</span><span class="s2">,</span><span class="s1">&quot;ImportMetaOutsideModule&quot;</span><span class="s2">,</span><span class="s1">&quot;message&quot;</span><span class="s2">,</span><span class="s1">&quot;code&quot;</span><span class="s2">,</span><span class="s1">&quot;ImportOutsideModule&quot;</span><span class="s2">,</span><span class="s1">&quot;NodeDescriptions&quot;</span><span class="s2">,</span><span class="s1">&quot;ArrayPattern&quot;</span><span class="s2">,</span><span class="s1">&quot;AssignmentExpression&quot;</span><span class="s2">,</span><span class="s1">&quot;AssignmentPattern&quot;</span><span class="s2">,</span><span class="s1">&quot;ArrowFunctionExpression&quot;</span><span class="s2">,</span><span class="s1">&quot;ConditionalExpression&quot;</span><span class="s2">,</span><span class="s1">&quot;CatchClause&quot;</span><span class="s2">,</span><span class="s1">&quot;ForOfStatement&quot;</span><span class="s2">,</span><span class="s1">&quot;ForInStatement&quot;</span><span class="s2">,</span><span class="s1">&quot;ForStatement&quot;</span><span class="s2">,</span><span class="s1">&quot;FormalParameters&quot;</span><span class="s2">,</span><span class="s1">&quot;Identifier&quot;</span><span class="s2">,</span><span class="s1">&quot;ImportSpecifier&quot;</span><span class="s2">,</span><span class="s1">&quot;ImportDefaultSpecifier&quot;</span><span class="s2">,</span><span class="s1">&quot;ImportNamespaceSpecifier&quot;</span><span class="s2">,</span><span class="s1">&quot;ObjectPattern&quot;</span><span class="s2">,</span><span class="s1">&quot;ParenthesizedExpression&quot;</span><span class="s2">,</span><span class="s1">&quot;RestElement&quot;</span><span class="s2">,</span><span class="s1">&quot;UpdateExpression&quot;</span><span class="s2">,</span><span class="s1">&quot;true&quot;</span><span class="s2">,</span><span class="s1">&quot;false&quot;</span><span class="s2">,</span><span class="s1">&quot;VariableDeclarator&quot;</span><span class="s2">,</span><span class="s1">&quot;YieldExpression&quot;</span><span class="s2">,</span><span class="s1">&quot;toNodeDescription&quot;</span><span class="s2">,</span><span class="s1">&quot;type&quot;</span><span class="s2">,</span><span class="s1">&quot;String&quot;</span><span class="s2">,</span><span class="s1">&quot;StandardErrors&quot;</span><span class="s2">,</span><span class="s1">&quot;AccessorIsGenerator&quot;</span><span class="s2">,</span><span class="s1">&quot;kind&quot;</span><span class="s2">,</span><span class="s1">&quot;ArgumentsInClass&quot;</span><span class="s2">,</span><span class="s1">&quot;AsyncFunctionInSingleStatementContext&quot;</span><span class="s2">,</span><span class="s1">&quot;AwaitBindingIdentifier&quot;</span><span class="s2">,</span><span class="s1">&quot;AwaitBindingIdentifierInStaticBlock&quot;</span><span class="s2">,</span><span class="s1">&quot;AwaitExpressionFormalParameter&quot;</span><span class="s2">,</span><span class="s1">&quot;AwaitInUsingBinding&quot;</span><span class="s2">,</span><span class="s1">&quot;AwaitNotInAsyncContext&quot;</span><span class="s2">,</span><span class="s1">&quot;AwaitNotInAsyncFunction&quot;</span><span class="s2">,</span><span class="s1">&quot;BadGetterArity&quot;</span><span class="s2">,</span><span class="s1">&quot;BadSetterArity&quot;</span><span class="s2">,</span><span class="s1">&quot;BadSetterRestParameter&quot;</span><span class="s2">,</span><span class="s1">&quot;ConstructorClassField&quot;</span><span class="s2">,</span><span class="s1">&quot;ConstructorClassPrivateField&quot;</span><span class="s2">,</span><span class="s1">&quot;ConstructorIsAccessor&quot;</span><span class="s2">,</span><span class="s1">&quot;ConstructorIsAsync&quot;</span><span class="s2">,</span><span class="s1">&quot;ConstructorIsGenerator&quot;</span><span class="s2">,</span><span class="s1">&quot;DeclarationMissingInitializer&quot;</span><span class="s2">,</span><span class="s1">&quot;DecoratorArgumentsOutsideParentheses&quot;</span><span class="s2">,</span><span class="s1">&quot;DecoratorBeforeExport&quot;</span><span class="s2">,</span><span class="s1">&quot;DecoratorsBeforeAfterExport&quot;</span><span class="s2">,</span><span class="s1">&quot;DecoratorConstructor&quot;</span><span class="s2">,</span><span class="s1">&quot;DecoratorExportClass&quot;</span><span class="s2">,</span><span class="s1">&quot;DecoratorSemicolon&quot;</span><span class="s2">,</span><span class="s1">&quot;DecoratorStaticBlock&quot;</span><span class="s2">,</span><span class="s1">&quot;DeletePrivateField&quot;</span><span class="s2">,</span><span class="s1">&quot;DestructureNamedImport&quot;</span><span class="s2">,</span><span class="s1">&quot;DuplicateConstructor&quot;</span><span class="s2">,</span><span class="s1">&quot;DuplicateDefaultExport&quot;</span><span class="s2">,</span><span class="s1">&quot;DuplicateExport&quot;</span><span class="s2">,</span><span class="s1">&quot;exportName&quot;</span><span class="s2">,</span><span class="s1">&quot;DuplicateProto&quot;</span><span class="s2">,</span><span class="s1">&quot;DuplicateRegExpFlags&quot;</span><span class="s2">,</span><span class="s1">&quot;ElementAfterRest&quot;</span><span class="s2">,</span><span class="s1">&quot;EscapedCharNotAnIdentifier&quot;</span><span class="s2">,</span><span class="s1">&quot;ExportBindingIsString&quot;</span><span class="s2">,</span><span class="s1">&quot;localName&quot;</span><span class="s2">,</span><span class="s1">&quot;ExportDefaultFromAsIdentifier&quot;</span><span class="s2">,</span><span class="s1">&quot;ForInOfLoopInitializer&quot;</span><span class="s2">,</span><span class="s1">&quot;ForInUsing&quot;</span><span class="s2">,</span><span class="s1">&quot;ForOfAsync&quot;</span><span class="s2">,</span><span class="s1">&quot;ForOfLet&quot;</span><span class="s2">,</span><span class="s1">&quot;GeneratorInSingleStatementContext&quot;</span><span class="s2">,</span><span class="s1">&quot;IllegalBreakContinue&quot;</span><span class="s2">,</span><span class="s1">&quot;IllegalLanguageModeDirective&quot;</span><span class="s2">,</span><span class="s1">&quot;IllegalReturn&quot;</span><span class="s2">,</span><span class="s1">&quot;ImportBindingIsString&quot;</span><span class="s2">,</span><span class="s1">&quot;importName&quot;</span><span class="s2">,</span><span class="s1">&quot;ImportCallArgumentTrailingComma&quot;</span><span class="s2">,</span><span class="s1">&quot;ImportCallArity&quot;</span><span class="s2">,</span><span class="s1">&quot;maxArgumentCount&quot;</span><span class="s2">,</span><span class="s1">&quot;ImportCallNotNewExpression&quot;</span><span class="s2">,</span><span class="s1">&quot;ImportCallSpreadArgument&quot;</span><span class="s2">,</span><span class="s1">&quot;ImportJSONBindingNotDefault&quot;</span><span class="s2">,</span><span class="s1">&quot;ImportReflectionHasAssertion&quot;</span><span class="s2">,</span><span class="s1">&quot;ImportReflectionNotBinding&quot;</span><span class="s2">,</span><span class="s1">&quot;IncompatibleRegExpUVFlags&quot;</span><span class="s2">,</span><span class="s1">&quot;InvalidBigIntLiteral&quot;</span><span class="s2">,</span><span class="s1">&quot;InvalidCodePoint&quot;</span><span class="s2">,</span><span class="s1">&quot;InvalidCoverInitializedName&quot;</span><span class="s2">,</span><span class="s1">&quot;InvalidDecimal&quot;</span><span class="s2">,</span><span class="s1">&quot;InvalidDigit&quot;</span><span class="s2">,</span><span class="s1">&quot;radix&quot;</span><span class="s2">,</span><span class="s1">&quot;InvalidEscapeSequence&quot;</span><span class="s2">,</span><span class="s1">&quot;InvalidEscapeSequenceTemplate&quot;</span><span class="s2">,</span><span class="s1">&quot;InvalidEscapedReservedWord&quot;</span><span class="s2">,</span><span class="s1">&quot;reservedWord&quot;</span><span class="s2">,</span><span class="s1">&quot;InvalidIdentifier&quot;</span><span class="s2">,</span><span class="s1">&quot;InvalidLhs&quot;</span><span class="s2">,</span><span class="s1">&quot;ancestor&quot;</span><span class="s2">,</span><span class="s1">&quot;InvalidLhsBinding&quot;</span><span class="s2">,</span><span class="s1">&quot;InvalidNumber&quot;</span><span class="s2">,</span><span class="s1">&quot;InvalidOrMissingExponent&quot;</span><span class="s2">,</span><span class="s1">&quot;InvalidOrUnexpectedToken&quot;</span><span class="s2">,</span><span class="s1">&quot;unexpected&quot;</span><span class="s2">,</span><span class="s1">&quot;InvalidParenthesizedAssignment&quot;</span><span class="s2">,</span><span class="s1">&quot;InvalidPrivateFieldResolution&quot;</span><span class="s2">,</span><span class="s1">&quot;InvalidPropertyBindingPattern&quot;</span><span class="s2">,</span><span class="s1">&quot;InvalidRecordProperty&quot;</span><span class="s2">,</span><span class="s1">&quot;InvalidRestAssignmentPattern&quot;</span><span class="s2">,</span><span class="s1">&quot;LabelRedeclaration&quot;</span><span class="s2">,</span><span class="s1">&quot;labelName&quot;</span><span class="s2">,</span><span class="s1">&quot;LetInLexicalBinding&quot;</span><span class="s2">,</span><span class="s1">&quot;LineTerminatorBeforeArrow&quot;</span><span class="s2">,</span><span class="s1">&quot;MalformedRegExpFlags&quot;</span><span class="s2">,</span><span class="s1">&quot;MissingClassName&quot;</span><span class="s2">,</span><span class="s1">&quot;MissingEqInAssignment&quot;</span><span class="s2">,</span><span class="s1">&quot;MissingSemicolon&quot;</span><span class="s2">,</span><span class="s1">&quot;MissingPlugin&quot;</span><span class="s2">,</span><span class="s1">&quot;missingPlugin&quot;</span><span class="s2">,</span><span class="s1">&quot;JSON&quot;</span><span class="s2">,</span><span class="s1">&quot;stringify&quot;</span><span class="s2">,</span><span class="s1">&quot;join&quot;</span><span class="s2">,</span><span class="s1">&quot;MissingOneOfPlugins&quot;</span><span class="s2">,</span><span class="s1">&quot;MissingUnicodeEscape&quot;</span><span class="s2">,</span><span class="s1">&quot;MixingCoalesceWithLogical&quot;</span><span class="s2">,</span><span class="s1">&quot;ModuleAttributeDifferentFromType&quot;</span><span class="s2">,</span><span class="s1">&quot;ModuleAttributeInvalidValue&quot;</span><span class="s2">,</span><span class="s1">&quot;ModuleAttributesWithDuplicateKeys&quot;</span><span class="s2">,</span><span class="s1">&quot;ModuleExportNameHasLoneSurrogate&quot;</span><span class="s2">,</span><span class="s1">&quot;surrogateCharCode&quot;</span><span class="s2">,</span><span class="s1">&quot;toString&quot;</span><span class="s2">,</span><span class="s1">&quot;ModuleExportUndefined&quot;</span><span class="s2">,</span><span class="s1">&quot;MultipleDefaultsInSwitch&quot;</span><span class="s2">,</span><span class="s1">&quot;NewlineAfterThrow&quot;</span><span class="s2">,</span><span class="s1">&quot;NoCatchOrFinally&quot;</span><span class="s2">,</span><span class="s1">&quot;NumberIdentifier&quot;</span><span class="s2">,</span><span class="s1">&quot;NumericSeparatorInEscapeSequence&quot;</span><span class="s2">,</span><span class="s1">&quot;ObsoleteAwaitStar&quot;</span><span class="s2">,</span><span class="s1">&quot;OptionalChainingNoNew&quot;</span><span class="s2">,</span><span class="s1">&quot;OptionalChainingNoTemplate&quot;</span><span class="s2">,</span><span class="s1">&quot;OverrideOnConstructor&quot;</span><span class="s2">,</span><span class="s1">&quot;ParamDupe&quot;</span><span class="s2">,</span><span class="s1">&quot;PatternHasAccessor&quot;</span><span class="s2">,</span><span class="s1">&quot;PatternHasMethod&quot;</span><span class="s2">,</span><span class="s1">&quot;PrivateInExpectedIn&quot;</span><span class="s2">,</span><span class="s1">&quot;PrivateNameRedeclaration&quot;</span><span class="s2">,</span><span class="s1">&quot;RecordExpressionBarIncorrectEndSyntaxType&quot;</span><span class="s2">,</span><span class="s1">&quot;RecordExpressionBarIncorrectStartSyntaxType&quot;</span><span class="s2">,</span><span class="s1">&quot;RecordExpressionHashIncorrectStartSyntaxType&quot;</span><span class="s2">,</span><span class="s1">&quot;RecordNoProto&quot;</span><span class="s2">,</span><span class="s1">&quot;RestTrailingComma&quot;</span><span class="s2">,</span><span class="s1">&quot;SloppyFunction&quot;</span><span class="s2">,</span><span class="s1">&quot;SloppyFunctionAnnexB&quot;</span><span class="s2">,</span><span class="s1">&quot;StaticPrototype&quot;</span><span class="s2">,</span><span class="s1">&quot;SuperNotAllowed&quot;</span><span class="s2">,</span><span class="s1">&quot;SuperPrivateField&quot;</span><span class="s2">,</span><span class="s1">&quot;TrailingDecorator&quot;</span><span class="s2">,</span><span class="s1">&quot;TupleExpressionBarIncorrectEndSyntaxType&quot;</span><span class="s2">,</span><span class="s1">&quot;TupleExpressionBarIncorrectStartSyntaxType&quot;</span><span class="s2">,</span><span class="s1">&quot;TupleExpressionHashIncorrectStartSyntaxType&quot;</span><span class="s2">,</span><span class="s1">&quot;UnexpectedArgumentPlaceholder&quot;</span><span class="s2">,</span><span class="s1">&quot;UnexpectedAwaitAfterPipelineBody&quot;</span><span class="s2">,</span><span class="s1">&quot;UnexpectedDigitAfterHash&quot;</span><span class="s2">,</span><span class="s1">&quot;UnexpectedImportExport&quot;</span><span class="s2">,</span><span class="s1">&quot;UnexpectedKeyword&quot;</span><span class="s2">,</span><span class="s1">&quot;UnexpectedLeadingDecorator&quot;</span><span class="s2">,</span><span class="s1">&quot;UnexpectedLexicalDeclaration&quot;</span><span class="s2">,</span><span class="s1">&quot;UnexpectedNewTarget&quot;</span><span class="s2">,</span><span class="s1">&quot;UnexpectedNumericSeparator&quot;</span><span class="s2">,</span><span class="s1">&quot;UnexpectedPrivateField&quot;</span><span class="s2">,</span><span class="s1">&quot;UnexpectedReservedWord&quot;</span><span class="s2">,</span><span class="s1">&quot;UnexpectedSuper&quot;</span><span class="s2">,</span><span class="s1">&quot;UnexpectedToken&quot;</span><span class="s2">,</span><span class="s1">&quot;expected&quot;</span><span class="s2">,</span><span class="s1">&quot;UnexpectedTokenUnaryExponentiation&quot;</span><span class="s2">,</span><span class="s1">&quot;UnexpectedUsingDeclaration&quot;</span><span class="s2">,</span><span class="s1">&quot;UnsupportedBind&quot;</span><span class="s2">,</span><span class="s1">&quot;UnsupportedDecoratorExport&quot;</span><span class="s2">,</span><span class="s1">&quot;UnsupportedDefaultExport&quot;</span><span class="s2">,</span><span class="s1">&quot;UnsupportedImport&quot;</span><span class="s2">,</span><span class="s1">&quot;UnsupportedMetaProperty&quot;</span><span class="s2">,</span><span class="s1">&quot;target&quot;</span><span class="s2">,</span><span class="s1">&quot;onlyValidPropertyName&quot;</span><span class="s2">,</span><span class="s1">&quot;UnsupportedParameterDecorator&quot;</span><span class="s2">,</span><span class="s1">&quot;UnsupportedPropertyDecorator&quot;</span><span class="s2">,</span><span class="s1">&quot;UnsupportedSuper&quot;</span><span class="s2">,</span><span class="s1">&quot;UnterminatedComment&quot;</span><span class="s2">,</span><span class="s1">&quot;UnterminatedRegExp&quot;</span><span class="s2">,</span><span class="s1">&quot;UnterminatedString&quot;</span><span class="s2">,</span><span class="s1">&quot;UnterminatedTemplate&quot;</span><span class="s2">,</span><span class="s1">&quot;UsingDeclarationHasBindingPattern&quot;</span><span class="s2">,</span><span class="s1">&quot;VarRedeclaration&quot;</span><span class="s2">,</span><span class="s1">&quot;YieldBindingIdentifier&quot;</span><span class="s2">,</span><span class="s1">&quot;YieldInParameter&quot;</span><span class="s2">,</span><span class="s1">&quot;ZeroDigitNumericSeparator&quot;</span><span class="s2">,</span><span class="s1">&quot;StrictModeErrors&quot;</span><span class="s2">,</span><span class="s1">&quot;StrictDelete&quot;</span><span class="s2">,</span><span class="s1">&quot;StrictEvalArguments&quot;</span><span class="s2">,</span><span class="s1">&quot;referenceName&quot;</span><span class="s2">,</span><span class="s1">&quot;StrictEvalArgumentsBinding&quot;</span><span class="s2">,</span><span class="s1">&quot;bindingName&quot;</span><span class="s2">,</span><span class="s1">&quot;StrictFunction&quot;</span><span class="s2">,</span><span class="s1">&quot;StrictNumericEscape&quot;</span><span class="s2">,</span><span class="s1">&quot;StrictOctalLiteral&quot;</span><span class="s2">,</span><span class="s1">&quot;StrictWith&quot;</span><span class="s2">,</span><span class="s1">&quot;UnparenthesizedPipeBodyDescriptions&quot;</span><span class="s2">,</span><span class="s1">&quot;Set&quot;</span><span class="s2">,</span><span class="s1">&quot;PipelineOperatorErrors&quot;</span><span class="s2">,</span><span class="s1">&quot;PipeBodyIsTighter&quot;</span><span class="s2">,</span><span class="s1">&quot;PipeTopicRequiresHackPipes&quot;</span><span class="s2">,</span><span class="s1">&quot;PipeTopicUnbound&quot;</span><span class="s2">,</span><span class="s1">&quot;PipeTopicUnconfiguredToken&quot;</span><span class="s2">,</span><span class="s1">&quot;PipeTopicUnused&quot;</span><span class="s2">,</span><span class="s1">&quot;PipeUnparenthesizedBody&quot;</span><span class="s2">,</span><span class="s1">&quot;PipelineBodyNoArrow&quot;</span><span class="s2">,</span><span class="s1">&quot;PipelineBodySequenceExpression&quot;</span><span class="s2">,</span><span class="s1">&quot;PipelineHeadSequenceExpression&quot;</span><span class="s2">,</span><span class="s1">&quot;PipelineTopicUnused&quot;</span><span class="s2">,</span><span class="s1">&quot;PrimaryTopicNotAllowed&quot;</span><span class="s2">,</span><span class="s1">&quot;PrimaryTopicRequiresSmartPipeline&quot;</span><span class="s2">,</span><span class="s1">&quot;toParseErrorConstructor&quot;</span><span class="s2">,</span><span class="s1">&quot;_ref&quot;</span><span class="s2">,</span><span class="s1">&quot;toMessage&quot;</span><span class="s2">,</span><span class="s1">&quot;_objectWithoutPropertiesLoose&quot;</span><span class="s2">,</span><span class="s1">&quot;_excluded&quot;</span><span class="s2">,</span><span class="s1">&quot;loc&quot;</span><span class="s2">,</span><span class="s1">&quot;details&quot;</span><span class="s2">,</span><span class="s1">&quot;clone&quot;</span><span class="s2">,</span><span class="s1">&quot;overrides&quot;</span><span class="s2">,</span><span class="s1">&quot;pos&quot;</span><span class="s2">,</span><span class="s1">&quot;ParseErrorEnum&quot;</span><span class="s2">,</span><span class="s1">&quot;argument&quot;</span><span class="s2">,</span><span class="s1">&quot;syntaxPlugin&quot;</span><span class="s2">,</span><span class="s1">&quot;Array&quot;</span><span class="s2">,</span><span class="s1">&quot;isArray&quot;</span><span class="s2">,</span><span class="s1">&quot;parseErrorTemplates&quot;</span><span class="s2">,</span><span class="s1">&quot;ParseErrorConstructors&quot;</span><span class="s2">,</span><span class="s1">&quot;reasonCode&quot;</span><span class="s2">,</span><span class="s1">&quot;_ref2&quot;</span><span class="s2">,</span><span class="s1">&quot;rest&quot;</span><span class="s2">,</span><span class="s1">&quot;_excluded2&quot;</span><span class="s2">,</span><span class="s1">&quot;Errors&quot;</span><span class="s2">,</span><span class="s1">&quot;toUnenumerable&quot;</span><span class="s2">,</span><span class="s1">&quot;toESTreeLocation&quot;</span><span class="s2">,</span><span class="s1">&quot;node&quot;</span><span class="s2">,</span><span class="s1">&quot;estree&quot;</span><span class="s2">,</span><span class="s1">&quot;superClass&quot;</span><span class="s2">,</span><span class="s1">&quot;ESTreeParserMixin&quot;</span><span class="s2">,</span><span class="s1">&quot;parse&quot;</span><span class="s2">,</span><span class="s1">&quot;file&quot;</span><span class="s2">,</span><span class="s1">&quot;parseRegExpLiteral&quot;</span><span class="s2">,</span><span class="s1">&quot;pattern&quot;</span><span class="s2">,</span><span class="s1">&quot;flags&quot;</span><span class="s2">,</span><span class="s1">&quot;regex&quot;</span><span class="s2">,</span><span class="s1">&quot;RegExp&quot;</span><span class="s2">,</span><span class="s1">&quot;e&quot;</span><span class="s2">,</span><span class="s1">&quot;estreeParseLiteral&quot;</span><span class="s2">,</span><span class="s1">&quot;parseBigIntLiteral&quot;</span><span class="s2">,</span><span class="s1">&quot;bigInt&quot;</span><span class="s2">,</span><span class="s1">&quot;BigInt&quot;</span><span class="s2">,</span><span class="s1">&quot;_unused&quot;</span><span class="s2">,</span><span class="s1">&quot;parseDecimalLiteral&quot;</span><span class="s2">,</span><span class="s1">&quot;parseLiteral&quot;</span><span class="s2">,</span><span class="s1">&quot;parseStringLiteral&quot;</span><span class="s2">,</span><span class="s1">&quot;parseNumericLiteral&quot;</span><span class="s2">,</span><span class="s1">&quot;parseNullLiteral&quot;</span><span class="s2">,</span><span class="s1">&quot;parseBooleanLiteral&quot;</span><span class="s2">,</span><span class="s1">&quot;directiveToStmt&quot;</span><span class="s2">,</span><span class="s1">&quot;directive&quot;</span><span class="s2">,</span><span class="s1">&quot;expression&quot;</span><span class="s2">,</span><span class="s1">&quot;raw&quot;</span><span class="s2">,</span><span class="s1">&quot;extra&quot;</span><span class="s2">,</span><span class="s1">&quot;expressionValue&quot;</span><span class="s2">,</span><span class="s1">&quot;stmt&quot;</span><span class="s2">,</span><span class="s1">&quot;rawValue&quot;</span><span class="s2">,</span><span class="s1">&quot;initFunction&quot;</span><span class="s2">,</span><span class="s1">&quot;isAsync&quot;</span><span class="s2">,</span><span class="s1">&quot;checkDeclaration&quot;</span><span class="s2">,</span><span class="s1">&quot;isObjectProperty&quot;</span><span class="s2">,</span><span class="s1">&quot;getObjectOrClassMethodParams&quot;</span><span class="s2">,</span><span class="s1">&quot;method&quot;</span><span class="s2">,</span><span class="s1">&quot;params&quot;</span><span class="s2">,</span><span class="s1">&quot;isValidDirective&quot;</span><span class="s2">,</span><span class="s1">&quot;_stmt$expression$extr&quot;</span><span class="s2">,</span><span class="s1">&quot;parenthesized&quot;</span><span class="s2">,</span><span class="s1">&quot;parseBlockBody&quot;</span><span class="s2">,</span><span class="s1">&quot;allowDirectives&quot;</span><span class="s2">,</span><span class="s1">&quot;topLevel&quot;</span><span class="s2">,</span><span class="s1">&quot;afterBlockParse&quot;</span><span class="s2">,</span><span class="s1">&quot;directiveStatements&quot;</span><span class="s2">,</span><span class="s1">&quot;directives&quot;</span><span class="s2">,</span><span class="s1">&quot;d&quot;</span><span class="s2">,</span><span class="s1">&quot;body&quot;</span><span class="s2">,</span><span class="s1">&quot;concat&quot;</span><span class="s2">,</span><span class="s1">&quot;pushClassMethod&quot;</span><span class="s2">,</span><span class="s1">&quot;classBody&quot;</span><span class="s2">,</span><span class="s1">&quot;isGenerator&quot;</span><span class="s2">,</span><span class="s1">&quot;isConstructor&quot;</span><span class="s2">,</span><span class="s1">&quot;allowsDirectSuper&quot;</span><span class="s2">,</span><span class="s1">&quot;parseMethod&quot;</span><span class="s2">,</span><span class="s1">&quot;typeParameters&quot;</span><span class="s2">,</span><span class="s1">&quot;parsePrivateName&quot;</span><span class="s2">,</span><span class="s1">&quot;getPluginOption&quot;</span><span class="s2">,</span><span class="s1">&quot;convertPrivateNameToPrivateIdentifier&quot;</span><span class="s2">,</span><span class="s1">&quot;getPrivateNameSV&quot;</span><span class="s2">,</span><span class="s1">&quot;id&quot;</span><span class="s2">,</span><span class="s1">&quot;isPrivateName&quot;</span><span class="s2">,</span><span class="s1">&quot;parseFunctionBody&quot;</span><span class="s2">,</span><span class="s1">&quot;allowExpression&quot;</span><span class="s2">,</span><span class="s1">&quot;isMethod&quot;</span><span class="s2">,</span><span class="s1">&quot;allowDirectSuper&quot;</span><span class="s2">,</span><span class="s1">&quot;inClassScope&quot;</span><span class="s2">,</span><span class="s1">&quot;funcNode&quot;</span><span class="s2">,</span><span class="s1">&quot;startNode&quot;</span><span class="s2">,</span><span class="s1">&quot;computed&quot;</span><span class="s2">,</span><span class="s1">&quot;finishNode&quot;</span><span class="s2">,</span><span class="s1">&quot;parseClassProperty&quot;</span><span class="s2">,</span><span class="s1">&quot;args&quot;</span><span class="s2">,</span><span class="s1">&quot;propertyNode&quot;</span><span class="s2">,</span><span class="s1">&quot;parseClassPrivateProperty&quot;</span><span class="s2">,</span><span class="s1">&quot;parseObjectMethod&quot;</span><span class="s2">,</span><span class="s1">&quot;prop&quot;</span><span class="s2">,</span><span class="s1">&quot;isPattern&quot;</span><span class="s2">,</span><span class="s1">&quot;isAccessor&quot;</span><span class="s2">,</span><span class="s1">&quot;shorthand&quot;</span><span class="s2">,</span><span class="s1">&quot;parseObjectProperty&quot;</span><span class="s2">,</span><span class="s1">&quot;startLoc&quot;</span><span class="s2">,</span><span class="s1">&quot;refExpressionErrors&quot;</span><span class="s2">,</span><span class="s1">&quot;isValidLVal&quot;</span><span class="s2">,</span><span class="s1">&quot;isUnparenthesizedInAssign&quot;</span><span class="s2">,</span><span class="s1">&quot;binding&quot;</span><span class="s2">,</span><span class="s1">&quot;isAssignable&quot;</span><span class="s2">,</span><span class="s1">&quot;isBinding&quot;</span><span class="s2">,</span><span class="s1">&quot;toAssignable&quot;</span><span class="s2">,</span><span class="s1">&quot;isLHS&quot;</span><span class="s2">,</span><span class="s1">&quot;classScope&quot;</span><span class="s2">,</span><span class="s1">&quot;usePrivateName&quot;</span><span class="s2">,</span><span class="s1">&quot;toAssignableObjectExpressionProp&quot;</span><span class="s2">,</span><span class="s1">&quot;isLast&quot;</span><span class="s2">,</span><span class="s1">&quot;raise&quot;</span><span class="s2">,</span><span class="s1">&quot;finishCallExpression&quot;</span><span class="s2">,</span><span class="s1">&quot;unfinished&quot;</span><span class="s2">,</span><span class="s1">&quot;optional&quot;</span><span class="s2">,</span><span class="s1">&quot;callee&quot;</span><span class="s2">,</span><span class="s1">&quot;source&quot;</span><span class="s2">,</span><span class="s1">&quot;arguments&quot;</span><span class="s2">,</span><span class="s1">&quot;hasPlugin&quot;</span><span class="s2">,</span><span class="s1">&quot;_node$arguments$&quot;</span><span class="s2">,</span><span class="s1">&quot;attributes&quot;</span><span class="s2">,</span><span class="s1">&quot;toReferencedArguments&quot;</span><span class="s2">,</span><span class="s1">&quot;parseExport&quot;</span><span class="s2">,</span><span class="s1">&quot;decorators&quot;</span><span class="s2">,</span><span class="s1">&quot;exportStartLoc&quot;</span><span class="s2">,</span><span class="s1">&quot;state&quot;</span><span class="s2">,</span><span class="s1">&quot;lastTokStartLoc&quot;</span><span class="s2">,</span><span class="s1">&quot;exported&quot;</span><span class="s2">,</span><span class="s1">&quot;specifiers&quot;</span><span class="s2">,</span><span class="s1">&quot;_declaration$decorato&quot;</span><span class="s2">,</span><span class="s1">&quot;declaration&quot;</span><span class="s2">,</span><span class="s1">&quot;resetStartLocation&quot;</span><span class="s2">,</span><span class="s1">&quot;parseSubscript&quot;</span><span class="s2">,</span><span class="s1">&quot;base&quot;</span><span class="s2">,</span><span class="s1">&quot;noCalls&quot;</span><span class="s2">,</span><span class="s1">&quot;optionalChainMember&quot;</span><span class="s2">,</span><span class="s1">&quot;substring&quot;</span><span class="s2">,</span><span class="s1">&quot;stop&quot;</span><span class="s2">,</span><span class="s1">&quot;chain&quot;</span><span class="s2">,</span><span class="s1">&quot;startNodeAtNode&quot;</span><span class="s2">,</span><span class="s1">&quot;hasPropertyAsPrivateName&quot;</span><span class="s2">,</span><span class="s1">&quot;isObjectMethod&quot;</span><span class="s2">,</span><span class="s1">&quot;finishNodeAt&quot;</span><span class="s2">,</span><span class="s1">&quot;endLoc&quot;</span><span class="s2">,</span><span class="s1">&quot;resetEndLocation&quot;</span><span class="s2">,</span><span class="s1">&quot;lastTokEndLoc&quot;</span><span class="s2">,</span><span class="s1">&quot;nonASCIIidentifierStartChars&quot;</span><span class="s2">,</span><span class="s1">&quot;nonASCIIidentifierChars&quot;</span><span class="s2">,</span><span class="s1">&quot;nonASCIIidentifierStart&quot;</span><span class="s2">,</span><span class="s1">&quot;nonASCIIidentifier&quot;</span><span class="s2">,</span><span class="s1">&quot;astralIdentifierStartCodes&quot;</span><span class="s2">,</span><span class="s1">&quot;astralIdentifierCodes&quot;</span><span class="s2">,</span><span class="s1">&quot;isInAstralSet&quot;</span><span class="s2">,</span><span class="s1">&quot;isIdentifierStart&quot;</span><span class="s2">,</span><span class="s1">&quot;test&quot;</span><span class="s2">,</span><span class="s1">&quot;fromCharCode&quot;</span><span class="s2">,</span><span class="s1">&quot;isIdentifierChar&quot;</span><span class="s2">,</span><span class="s1">&quot;reservedWords&quot;</span><span class="s2">,</span><span class="s1">&quot;strict&quot;</span><span class="s2">,</span><span class="s1">&quot;strictBind&quot;</span><span class="s2">,</span><span class="s1">&quot;reservedWordsStrictSet&quot;</span><span class="s2">,</span><span class="s1">&quot;reservedWordsStrictBindSet&quot;</span><span class="s2">,</span><span class="s1">&quot;isReservedWord&quot;</span><span class="s2">,</span><span class="s1">&quot;word&quot;</span><span class="s2">,</span><span class="s1">&quot;inModule&quot;</span><span class="s2">,</span><span class="s1">&quot;isStrictReservedWord&quot;</span><span class="s2">,</span><span class="s1">&quot;has&quot;</span><span class="s2">,</span><span class="s1">&quot;isStrictBindOnlyReservedWord&quot;</span><span class="s2">,</span><span class="s1">&quot;isStrictBindReservedWord&quot;</span><span class="s2">,</span><span class="s1">&quot;isKeyword&quot;</span><span class="s2">,</span><span class="s1">&quot;isIteratorStart&quot;</span><span class="s2">,</span><span class="s1">&quot;current&quot;</span><span class="s2">,</span><span class="s1">&quot;next&quot;</span><span class="s2">,</span><span class="s1">&quot;next2&quot;</span><span class="s2">,</span><span class="s1">&quot;reservedWordLikeSet&quot;</span><span class="s2">,</span><span class="s1">&quot;canBeReservedWord&quot;</span><span class="s2">,</span><span class="s1">&quot;SCOPE_OTHER&quot;</span><span class="s2">,</span><span class="s1">&quot;SCOPE_PROGRAM&quot;</span><span class="s2">,</span><span class="s1">&quot;SCOPE_FUNCTION&quot;</span><span class="s2">,</span><span class="s1">&quot;SCOPE_ARROW&quot;</span><span class="s2">,</span><span class="s1">&quot;SCOPE_SIMPLE_CATCH&quot;</span><span class="s2">,</span><span class="s1">&quot;SCOPE_SUPER&quot;</span><span class="s2">,</span><span class="s1">&quot;SCOPE_DIRECT_SUPER&quot;</span><span class="s2">,</span><span class="s1">&quot;SCOPE_CLASS&quot;</span><span class="s2">,</span><span class="s1">&quot;SCOPE_STATIC_BLOCK&quot;</span><span class="s2">,</span><span class="s1">&quot;SCOPE_TS_MODULE&quot;</span><span class="s2">,</span><span class="s1">&quot;SCOPE_VAR&quot;</span><span class="s2">,</span><span class="s1">&quot;BIND_KIND_VALUE&quot;</span><span class="s2">,</span><span class="s1">&quot;BIND_KIND_TYPE&quot;</span><span class="s2">,</span><span class="s1">&quot;BIND_SCOPE_VAR&quot;</span><span class="s2">,</span><span class="s1">&quot;BIND_SCOPE_LEXICAL&quot;</span><span class="s2">,</span><span class="s1">&quot;BIND_SCOPE_FUNCTION&quot;</span><span class="s2">,</span><span class="s1">&quot;BIND_FLAGS_NONE&quot;</span><span class="s2">,</span><span class="s1">&quot;BIND_FLAGS_CLASS&quot;</span><span class="s2">,</span><span class="s1">&quot;BIND_FLAGS_TS_ENUM&quot;</span><span class="s2">,</span><span class="s1">&quot;BIND_FLAGS_TS_CONST_ENUM&quot;</span><span class="s2">,</span><span class="s1">&quot;BIND_FLAGS_TS_EXPORT_ONLY&quot;</span><span class="s2">,</span><span class="s1">&quot;BIND_FLAGS_FLOW_DECLARE_FN&quot;</span><span class="s2">,</span><span class="s1">&quot;BIND_FLAGS_TS_IMPORT&quot;</span><span class="s2">,</span><span class="s1">&quot;BIND_FLAGS_NO_LET_IN_LEXICAL&quot;</span><span class="s2">,</span><span class="s1">&quot;BIND_CLASS&quot;</span><span class="s2">,</span><span class="s1">&quot;BIND_LEXICAL&quot;</span><span class="s2">,</span><span class="s1">&quot;BIND_CATCH_PARAM&quot;</span><span class="s2">,</span><span class="s1">&quot;BIND_VAR&quot;</span><span class="s2">,</span><span class="s1">&quot;BIND_FUNCTION&quot;</span><span class="s2">,</span><span class="s1">&quot;BIND_TS_INTERFACE&quot;</span><span class="s2">,</span><span class="s1">&quot;BIND_TS_TYPE&quot;</span><span class="s2">,</span><span class="s1">&quot;BIND_TS_ENUM&quot;</span><span class="s2">,</span><span class="s1">&quot;BIND_TS_AMBIENT&quot;</span><span class="s2">,</span><span class="s1">&quot;BIND_NONE&quot;</span><span class="s2">,</span><span class="s1">&quot;BIND_OUTSIDE&quot;</span><span class="s2">,</span><span class="s1">&quot;BIND_TS_CONST_ENUM&quot;</span><span class="s2">,</span><span class="s1">&quot;BIND_TS_NAMESPACE&quot;</span><span class="s2">,</span><span class="s1">&quot;BIND_TS_TYPE_IMPORT&quot;</span><span class="s2">,</span><span class="s1">&quot;BIND_FLOW_DECLARE_FN&quot;</span><span class="s2">,</span><span class="s1">&quot;CLASS_ELEMENT_FLAG_STATIC&quot;</span><span class="s2">,</span><span class="s1">&quot;CLASS_ELEMENT_KIND_GETTER&quot;</span><span class="s2">,</span><span class="s1">&quot;CLASS_ELEMENT_KIND_SETTER&quot;</span><span class="s2">,</span><span class="s1">&quot;CLASS_ELEMENT_KIND_ACCESSOR&quot;</span><span class="s2">,</span><span class="s1">&quot;CLASS_ELEMENT_STATIC_GETTER&quot;</span><span class="s2">,</span><span class="s1">&quot;CLASS_ELEMENT_STATIC_SETTER&quot;</span><span class="s2">,</span><span class="s1">&quot;CLASS_ELEMENT_INSTANCE_GETTER&quot;</span><span class="s2">,</span><span class="s1">&quot;CLASS_ELEMENT_INSTANCE_SETTER&quot;</span><span class="s2">,</span><span class="s1">&quot;CLASS_ELEMENT_OTHER&quot;</span><span class="s2">,</span><span class="s1">&quot;Scope&quot;</span><span class="s2">,</span><span class="s1">&quot;var&quot;</span><span class="s2">,</span><span class="s1">&quot;lexical&quot;</span><span class="s2">,</span><span class="s1">&quot;functions&quot;</span><span class="s2">,</span><span class="s1">&quot;ScopeHandler&quot;</span><span class="s2">,</span><span class="s1">&quot;parser&quot;</span><span class="s2">,</span><span class="s1">&quot;scopeStack&quot;</span><span class="s2">,</span><span class="s1">&quot;undefinedExports&quot;</span><span class="s2">,</span><span class="s1">&quot;inTopLevel&quot;</span><span class="s2">,</span><span class="s1">&quot;currentScope&quot;</span><span class="s2">,</span><span class="s1">&quot;inFunction&quot;</span><span class="s2">,</span><span class="s1">&quot;currentVarScopeFlags&quot;</span><span class="s2">,</span><span class="s1">&quot;allowSuper&quot;</span><span class="s2">,</span><span class="s1">&quot;currentThisScopeFlags&quot;</span><span class="s2">,</span><span class="s1">&quot;inClass&quot;</span><span class="s2">,</span><span class="s1">&quot;inClassAndNotInNonArrowFunction&quot;</span><span class="s2">,</span><span class="s1">&quot;inStaticBlock&quot;</span><span class="s2">,</span><span class="s1">&quot;inNonArrowFunction&quot;</span><span class="s2">,</span><span class="s1">&quot;treatFunctionsAsVar&quot;</span><span class="s2">,</span><span class="s1">&quot;treatFunctionsAsVarInScope&quot;</span><span class="s2">,</span><span class="s1">&quot;createScope&quot;</span><span class="s2">,</span><span class="s1">&quot;enter&quot;</span><span class="s2">,</span><span class="s1">&quot;exit&quot;</span><span class="s2">,</span><span class="s1">&quot;scope&quot;</span><span class="s2">,</span><span class="s1">&quot;declareName&quot;</span><span class="s2">,</span><span class="s1">&quot;bindingType&quot;</span><span class="s2">,</span><span class="s1">&quot;checkRedeclarationInScope&quot;</span><span class="s2">,</span><span class="s1">&quot;add&quot;</span><span class="s2">,</span><span class="s1">&quot;maybeExportDefined&quot;</span><span class="s2">,</span><span class="s1">&quot;delete&quot;</span><span class="s2">,</span><span class="s1">&quot;isRedeclaredInScope&quot;</span><span class="s2">,</span><span class="s1">&quot;values&quot;</span><span class="s2">,</span><span class="s1">&quot;checkLocalExport&quot;</span><span class="s2">,</span><span class="s1">&quot;topLevelScope&quot;</span><span class="s2">,</span><span class="s1">&quot;FlowScope&quot;</span><span class="s2">,</span><span class="s1">&quot;declareFunctions&quot;</span><span class="s2">,</span><span class="s1">&quot;FlowScopeHandler&quot;</span><span class="s2">,</span><span class="s1">&quot;BaseParser&quot;</span><span class="s2">,</span><span class="s1">&quot;sawUnambiguousESM&quot;</span><span class="s2">,</span><span class="s1">&quot;ambiguousScriptDifferentAst&quot;</span><span class="s2">,</span><span class="s1">&quot;pluginConfig&quot;</span><span class="s2">,</span><span class="s1">&quot;pluginName&quot;</span><span class="s2">,</span><span class="s1">&quot;pluginOptions&quot;</span><span class="s2">,</span><span class="s1">&quot;actualOptions&quot;</span><span class="s2">,</span><span class="s1">&quot;plugin&quot;</span><span class="s2">,</span><span class="s1">&quot;_this$plugins$get&quot;</span><span class="s2">,</span><span class="s1">&quot;setTrailingComments&quot;</span><span class="s2">,</span><span class="s1">&quot;comments&quot;</span><span class="s2">,</span><span class="s1">&quot;trailingComments&quot;</span><span class="s2">,</span><span class="s1">&quot;unshift&quot;</span><span class="s2">,</span><span class="s1">&quot;setLeadingComments&quot;</span><span class="s2">,</span><span class="s1">&quot;leadingComments&quot;</span><span class="s2">,</span><span class="s1">&quot;setInnerComments&quot;</span><span class="s2">,</span><span class="s1">&quot;innerComments&quot;</span><span class="s2">,</span><span class="s1">&quot;adjustInnerComments&quot;</span><span class="s2">,</span><span class="s1">&quot;elements&quot;</span><span class="s2">,</span><span class="s1">&quot;commentWS&quot;</span><span class="s2">,</span><span class="s1">&quot;lastElement&quot;</span><span class="s2">,</span><span class="s1">&quot;CommentsParser&quot;</span><span class="s2">,</span><span class="s1">&quot;addComment&quot;</span><span class="s2">,</span><span class="s1">&quot;comment&quot;</span><span class="s2">,</span><span class="s1">&quot;processComment&quot;</span><span class="s2">,</span><span class="s1">&quot;commentStack&quot;</span><span class="s2">,</span><span class="s1">&quot;commentStackLength&quot;</span><span class="s2">,</span><span class="s1">&quot;lastCommentWS&quot;</span><span class="s2">,</span><span class="s1">&quot;leadingNode&quot;</span><span class="s2">,</span><span class="s1">&quot;nodeStart&quot;</span><span class="s2">,</span><span class="s1">&quot;commentEnd&quot;</span><span class="s2">,</span><span class="s1">&quot;containingNode&quot;</span><span class="s2">,</span><span class="s1">&quot;finalizeComment&quot;</span><span class="s2">,</span><span class="s1">&quot;splice&quot;</span><span class="s2">,</span><span class="s1">&quot;trailingNode&quot;</span><span class="s2">,</span><span class="s1">&quot;commentStart&quot;</span><span class="s2">,</span><span class="s1">&quot;input&quot;</span><span class="s2">,</span><span class="s1">&quot;charCodeAt&quot;</span><span class="s2">,</span><span class="s1">&quot;finalizeRemainingComments&quot;</span><span class="s2">,</span><span class="s1">&quot;resetPreviousNodeTrailingComments&quot;</span><span class="s2">,</span><span class="s1">&quot;takeSurroundingComments&quot;</span><span class="s2">,</span><span class="s1">&quot;lineBreak&quot;</span><span class="s2">,</span><span class="s1">&quot;lineBreakG&quot;</span><span class="s2">,</span><span class="s1">&quot;isNewLine&quot;</span><span class="s2">,</span><span class="s1">&quot;skipWhiteSpace&quot;</span><span class="s2">,</span><span class="s1">&quot;skipWhiteSpaceInLine&quot;</span><span class="s2">,</span><span class="s1">&quot;skipWhiteSpaceToLineBreak&quot;</span><span class="s2">,</span><span class="s1">&quot;isWhitespace&quot;</span><span class="s2">,</span><span class="s1">&quot;State&quot;</span><span class="s2">,</span><span class="s1">&quot;curLine&quot;</span><span class="s2">,</span><span class="s1">&quot;lineStart&quot;</span><span class="s2">,</span><span class="s1">&quot;errors&quot;</span><span class="s2">,</span><span class="s1">&quot;potentialArrowAt&quot;</span><span class="s2">,</span><span class="s1">&quot;noArrowAt&quot;</span><span class="s2">,</span><span class="s1">&quot;noArrowParamsConversionAt&quot;</span><span class="s2">,</span><span class="s1">&quot;maybeInArrowParameters&quot;</span><span class="s2">,</span><span class="s1">&quot;inType&quot;</span><span class="s2">,</span><span class="s1">&quot;noAnonFunctionType&quot;</span><span class="s2">,</span><span class="s1">&quot;hasFlowComment&quot;</span><span class="s2">,</span><span class="s1">&quot;isAmbientContext&quot;</span><span class="s2">,</span><span class="s1">&quot;inAbstractClass&quot;</span><span class="s2">,</span><span class="s1">&quot;inDisallowConditionalTypesContext&quot;</span><span class="s2">,</span><span class="s1">&quot;topicContext&quot;</span><span class="s2">,</span><span class="s1">&quot;maxNumOfResolvableTopics&quot;</span><span class="s2">,</span><span class="s1">&quot;maxTopicIndex&quot;</span><span class="s2">,</span><span class="s1">&quot;soloAwait&quot;</span><span class="s2">,</span><span class="s1">&quot;inFSharpPipelineDirectBody&quot;</span><span class="s2">,</span><span class="s1">&quot;labels&quot;</span><span class="s2">,</span><span class="s1">&quot;lastTokStart&quot;</span><span class="s2">,</span><span class="s1">&quot;ct&quot;</span><span class="s2">,</span><span class="s1">&quot;canStartJSXElement&quot;</span><span class="s2">,</span><span class="s1">&quot;containsEsc&quot;</span><span class="s2">,</span><span class="s1">&quot;firstInvalidTemplateEscapePos&quot;</span><span class="s2">,</span><span class="s1">&quot;strictErrors&quot;</span><span class="s2">,</span><span class="s1">&quot;tokensLength&quot;</span><span class="s2">,</span><span class="s1">&quot;init&quot;</span><span class="s2">,</span><span class="s1">&quot;curPosition&quot;</span><span class="s2">,</span><span class="s1">&quot;skipArrays&quot;</span><span class="s2">,</span><span class="s1">&quot;val&quot;</span><span class="s2">,</span><span class="s1">&quot;slice&quot;</span><span class="s2">,</span><span class="s1">&quot;isDigit&quot;</span><span class="s2">,</span><span class="s1">&quot;forbiddenNumericSeparatorSiblings&quot;</span><span class="s2">,</span><span class="s1">&quot;decBinOct&quot;</span><span class="s2">,</span><span class="s1">&quot;hex&quot;</span><span class="s2">,</span><span class="s1">&quot;isAllowedNumericSeparatorSibling&quot;</span><span class="s2">,</span><span class="s1">&quot;bin&quot;</span><span class="s2">,</span><span class="s1">&quot;ch&quot;</span><span class="s2">,</span><span class="s1">&quot;oct&quot;</span><span class="s2">,</span><span class="s1">&quot;dec&quot;</span><span class="s2">,</span><span class="s1">&quot;readStringContents&quot;</span><span class="s2">,</span><span class="s1">&quot;initialPos&quot;</span><span class="s2">,</span><span class="s1">&quot;initialLineStart&quot;</span><span class="s2">,</span><span class="s1">&quot;initialCurLine&quot;</span><span class="s2">,</span><span class="s1">&quot;out&quot;</span><span class="s2">,</span><span class="s1">&quot;firstInvalidLoc&quot;</span><span class="s2">,</span><span class="s1">&quot;chunkStart&quot;</span><span class="s2">,</span><span class="s1">&quot;unterminated&quot;</span><span class="s2">,</span><span class="s1">&quot;isStringEnd&quot;</span><span class="s2">,</span><span class="s1">&quot;res&quot;</span><span class="s2">,</span><span class="s1">&quot;readEscapedChar&quot;</span><span class="s2">,</span><span class="s1">&quot;str&quot;</span><span class="s2">,</span><span class="s1">&quot;containsInvalid&quot;</span><span class="s2">,</span><span class="s1">&quot;inTemplate&quot;</span><span class="s2">,</span><span class="s1">&quot;throwOnInvalid&quot;</span><span class="s2">,</span><span class="s1">&quot;readHexChar&quot;</span><span class="s2">,</span><span class="s1">&quot;readCodePoint&quot;</span><span class="s2">,</span><span class="s1">&quot;fromCodePoint&quot;</span><span class="s2">,</span><span class="s1">&quot;strictNumericEscape&quot;</span><span class="s2">,</span><span class="s1">&quot;startPos&quot;</span><span class="s2">,</span><span class="s1">&quot;match&quot;</span><span class="s2">,</span><span class="s1">&quot;octalStr&quot;</span><span class="s2">,</span><span class="s1">&quot;octal&quot;</span><span class="s2">,</span><span class="s1">&quot;parseInt&quot;</span><span class="s2">,</span><span class="s1">&quot;len&quot;</span><span class="s2">,</span><span class="s1">&quot;forceLen&quot;</span><span class="s2">,</span><span class="s1">&quot;n&quot;</span><span class="s2">,</span><span class="s1">&quot;readInt&quot;</span><span class="s2">,</span><span class="s1">&quot;invalidEscapeSequence&quot;</span><span class="s2">,</span><span class="s1">&quot;allowNumSeparator&quot;</span><span class="s2">,</span><span class="s1">&quot;bailOnError&quot;</span><span class="s2">,</span><span class="s1">&quot;forbiddenSiblings&quot;</span><span class="s2">,</span><span class="s1">&quot;isAllowedSibling&quot;</span><span class="s2">,</span><span class="s1">&quot;invalid&quot;</span><span class="s2">,</span><span class="s1">&quot;total&quot;</span><span class="s2">,</span><span class="s1">&quot;Infinity&quot;</span><span class="s2">,</span><span class="s1">&quot;prev&quot;</span><span class="s2">,</span><span class="s1">&quot;numericSeparatorInEscapeSequence&quot;</span><span class="s2">,</span><span class="s1">&quot;Number&quot;</span><span class="s2">,</span><span class="s1">&quot;isNaN&quot;</span><span class="s2">,</span><span class="s1">&quot;unexpectedNumericSeparator&quot;</span><span class="s2">,</span><span class="s1">&quot;_isDigit&quot;</span><span class="s2">,</span><span class="s1">&quot;invalidDigit&quot;</span><span class="s2">,</span><span class="s1">&quot;indexOf&quot;</span><span class="s2">,</span><span class="s1">&quot;invalidCodePoint&quot;</span><span class="s2">,</span><span class="s1">&quot;buildPosition&quot;</span><span class="s2">,</span><span class="s1">&quot;VALID_REGEX_FLAGS&quot;</span><span class="s2">,</span><span class="s1">&quot;Token&quot;</span><span class="s2">,</span><span class="s1">&quot;Tokenizer&quot;</span><span class="s2">,</span><span class="s1">&quot;isLookahead&quot;</span><span class="s2">,</span><span class="s1">&quot;errorHandlers_readInt&quot;</span><span class="s2">,</span><span class="s1">&quot;errorBuilder&quot;</span><span class="s2">,</span><span class="s1">&quot;errorHandlers_readCodePoint&quot;</span><span class="s2">,</span><span class="s1">&quot;errorHandlers_readStringContents_string&quot;</span><span class="s2">,</span><span class="s1">&quot;recordStrictModeErrors&quot;</span><span class="s2">,</span><span class="s1">&quot;errorHandlers_readStringContents_template&quot;</span><span class="s2">,</span><span class="s1">&quot;pushToken&quot;</span><span class="s2">,</span><span class="s1">&quot;checkKeywordEscapes&quot;</span><span class="s2">,</span><span class="s1">&quot;nextToken&quot;</span><span class="s2">,</span><span class="s1">&quot;eat&quot;</span><span class="s2">,</span><span class="s1">&quot;createLookaheadState&quot;</span><span class="s2">,</span><span class="s1">&quot;curContext&quot;</span><span class="s2">,</span><span class="s1">&quot;lookahead&quot;</span><span class="s2">,</span><span class="s1">&quot;old&quot;</span><span class="s2">,</span><span class="s1">&quot;curr&quot;</span><span class="s2">,</span><span class="s1">&quot;nextTokenStart&quot;</span><span class="s2">,</span><span class="s1">&quot;nextTokenStartSince&quot;</span><span class="s2">,</span><span class="s1">&quot;lastIndex&quot;</span><span class="s2">,</span><span class="s1">&quot;lookaheadCharCode&quot;</span><span class="s2">,</span><span class="s1">&quot;nextTokenInLineStart&quot;</span><span class="s2">,</span><span class="s1">&quot;nextTokenInLineStartSince&quot;</span><span class="s2">,</span><span class="s1">&quot;lookaheadInLineCharCode&quot;</span><span class="s2">,</span><span class="s1">&quot;codePointAtPos&quot;</span><span class="s2">,</span><span class="s1">&quot;cp&quot;</span><span class="s2">,</span><span class="s1">&quot;trail&quot;</span><span class="s2">,</span><span class="s1">&quot;setStrict&quot;</span><span class="s2">,</span><span class="s1">&quot;forEach&quot;</span><span class="s2">,</span><span class="s1">&quot;toParseError&quot;</span><span class="s2">,</span><span class="s1">&quot;clear&quot;</span><span class="s2">,</span><span class="s1">&quot;skipSpace&quot;</span><span class="s2">,</span><span class="s1">&quot;finishToken&quot;</span><span class="s2">,</span><span class="s1">&quot;getTokenFromCode&quot;</span><span class="s2">,</span><span class="s1">&quot;skipBlockComment&quot;</span><span class="s2">,</span><span class="s1">&quot;skipLineComment&quot;</span><span class="s2">,</span><span class="s1">&quot;startSkip&quot;</span><span class="s2">,</span><span class="s1">&quot;spaceStart&quot;</span><span class="s2">,</span><span class="s1">&quot;loop&quot;</span><span class="s2">,</span><span class="s1">&quot;commentWhitespace&quot;</span><span class="s2">,</span><span class="s1">&quot;prevType&quot;</span><span class="s2">,</span><span class="s1">&quot;replaceToken&quot;</span><span class="s2">,</span><span class="s1">&quot;readToken_numberSign&quot;</span><span class="s2">,</span><span class="s1">&quot;readToken_interpreter&quot;</span><span class="s2">,</span><span class="s1">&quot;nextPos&quot;</span><span class="s2">,</span><span class="s1">&quot;expectPlugin&quot;</span><span class="s2">,</span><span class="s1">&quot;readWord1&quot;</span><span class="s2">,</span><span class="s1">&quot;finishOp&quot;</span><span class="s2">,</span><span class="s1">&quot;readToken_dot&quot;</span><span class="s2">,</span><span class="s1">&quot;readNumber&quot;</span><span class="s2">,</span><span class="s1">&quot;readToken_slash&quot;</span><span class="s2">,</span><span class="s1">&quot;readToken_mult_modulo&quot;</span><span class="s2">,</span><span class="s1">&quot;width&quot;</span><span class="s2">,</span><span class="s1">&quot;readToken_pipe_amp&quot;</span><span class="s2">,</span><span class="s1">&quot;readToken_caret&quot;</span><span class="s2">,</span><span class="s1">&quot;proposal&quot;</span><span class="s2">,</span><span class="s1">&quot;topicToken&quot;</span><span class="s2">,</span><span class="s1">&quot;lookaheadCh&quot;</span><span class="s2">,</span><span class="s1">&quot;codePointAt&quot;</span><span class="s2">,</span><span class="s1">&quot;readToken_atSign&quot;</span><span class="s2">,</span><span class="s1">&quot;readToken_plus_min&quot;</span><span class="s2">,</span><span class="s1">&quot;readToken_lt&quot;</span><span class="s2">,</span><span class="s1">&quot;readToken_gt&quot;</span><span class="s2">,</span><span class="s1">&quot;size&quot;</span><span class="s2">,</span><span class="s1">&quot;readToken_eq_excl&quot;</span><span class="s2">,</span><span class="s1">&quot;readToken_question&quot;</span><span class="s2">,</span><span class="s1">&quot;readTemplateToken&quot;</span><span class="s2">,</span><span class="s1">&quot;readRadixNumber&quot;</span><span class="s2">,</span><span class="s1">&quot;readString&quot;</span><span class="s2">,</span><span class="s1">&quot;readWord&quot;</span><span class="s2">,</span><span class="s1">&quot;readRegexp&quot;</span><span class="s2">,</span><span class="s1">&quot;escaped&quot;</span><span class="s2">,</span><span class="s1">&quot;content&quot;</span><span class="s2">,</span><span class="s1">&quot;mods&quot;</span><span class="s2">,</span><span class="s1">&quot;char&quot;</span><span class="s2">,</span><span class="s1">&quot;includes&quot;</span><span class="s2">,</span><span class="s1">&quot;isBigInt&quot;</span><span class="s2">,</span><span class="s1">&quot;replace&quot;</span><span class="s2">,</span><span class="s1">&quot;startsWithDot&quot;</span><span class="s2">,</span><span class="s1">&quot;isFloat&quot;</span><span class="s2">,</span><span class="s1">&quot;isDecimal&quot;</span><span class="s2">,</span><span class="s1">&quot;hasExponent&quot;</span><span class="s2">,</span><span class="s1">&quot;isOctal&quot;</span><span class="s2">,</span><span class="s1">&quot;hasLeadingZero&quot;</span><span class="s2">,</span><span class="s1">&quot;integer&quot;</span><span class="s2">,</span><span class="s1">&quot;underscorePos&quot;</span><span class="s2">,</span><span class="s1">&quot;parseFloat&quot;</span><span class="s2">,</span><span class="s1">&quot;quote&quot;</span><span class="s2">,</span><span class="s1">&quot;readTemplateContinuation&quot;</span><span class="s2">,</span><span class="s1">&quot;opening&quot;</span><span class="s2">,</span><span class="s1">&quot;firstCode&quot;</span><span class="s2">,</span><span class="s1">&quot;escStart&quot;</span><span class="s2">,</span><span class="s1">&quot;identifierCheck&quot;</span><span class="s2">,</span><span class="s1">&quot;esc&quot;</span><span class="s2">,</span><span class="s1">&quot;keywordTypes&quot;</span><span class="s2">,</span><span class="s1">&quot;raiseProperties&quot;</span><span class="s2">,</span><span class="s1">&quot;error&quot;</span><span class="s2">,</span><span class="s1">&quot;raiseOverwrite&quot;</span><span class="s2">,</span><span class="s1">&quot;expectOnePlugin&quot;</span><span class="s2">,</span><span class="s1">&quot;pluginNames&quot;</span><span class="s2">,</span><span class="s1">&quot;some&quot;</span><span class="s2">,</span><span class="s1">&quot;ClassScope&quot;</span><span class="s2">,</span><span class="s1">&quot;privateNames&quot;</span><span class="s2">,</span><span class="s1">&quot;loneAccessors&quot;</span><span class="s2">,</span><span class="s1">&quot;undefinedPrivateNames&quot;</span><span class="s2">,</span><span class="s1">&quot;ClassScopeHandler&quot;</span><span class="s2">,</span><span class="s1">&quot;stack&quot;</span><span class="s2">,</span><span class="s1">&quot;oldClassScope&quot;</span><span class="s2">,</span><span class="s1">&quot;from&quot;</span><span class="s2">,</span><span class="s1">&quot;declarePrivateName&quot;</span><span class="s2">,</span><span class="s1">&quot;elementType&quot;</span><span class="s2">,</span><span class="s1">&quot;redefined&quot;</span><span class="s2">,</span><span class="s1">&quot;accessor&quot;</span><span class="s2">,</span><span class="s1">&quot;oldStatic&quot;</span><span class="s2">,</span><span class="s1">&quot;newStatic&quot;</span><span class="s2">,</span><span class="s1">&quot;oldKind&quot;</span><span class="s2">,</span><span class="s1">&quot;newKind&quot;</span><span class="s2">,</span><span class="s1">&quot;kExpression&quot;</span><span class="s2">,</span><span class="s1">&quot;kMaybeArrowParameterDeclaration&quot;</span><span class="s2">,</span><span class="s1">&quot;kMaybeAsyncArrowParameterDeclaration&quot;</span><span class="s2">,</span><span class="s1">&quot;kParameterDeclaration&quot;</span><span class="s2">,</span><span class="s1">&quot;ExpressionScope&quot;</span><span class="s2">,</span><span class="s1">&quot;canBeArrowParameterDeclaration&quot;</span><span class="s2">,</span><span class="s1">&quot;isCertainlyParameterDeclaration&quot;</span><span class="s2">,</span><span class="s1">&quot;ArrowHeadParsingScope&quot;</span><span class="s2">,</span><span class="s1">&quot;declarationErrors&quot;</span><span class="s2">,</span><span class="s1">&quot;recordDeclarationError&quot;</span><span class="s2">,</span><span class="s1">&quot;ParsingErrorClass&quot;</span><span class="s2">,</span><span class="s1">&quot;clearDeclarationError&quot;</span><span class="s2">,</span><span class="s1">&quot;iterateErrors&quot;</span><span class="s2">,</span><span class="s1">&quot;iterator&quot;</span><span class="s2">,</span><span class="s1">&quot;ExpressionScopeHandler&quot;</span><span class="s2">,</span><span class="s1">&quot;recordParameterInitializerError&quot;</span><span class="s2">,</span><span class="s1">&quot;origin&quot;</span><span class="s2">,</span><span class="s1">&quot;recordArrowParameterBindingError&quot;</span><span class="s2">,</span><span class="s1">&quot;recordAsyncArrowParametersError&quot;</span><span class="s2">,</span><span class="s1">&quot;validateAsPattern&quot;</span><span class="s2">,</span><span class="s1">&quot;newParameterDeclarationScope&quot;</span><span class="s2">,</span><span class="s1">&quot;newArrowHeadScope&quot;</span><span class="s2">,</span><span class="s1">&quot;newAsyncArrowScope&quot;</span><span class="s2">,</span><span class="s1">&quot;newExpressionScope&quot;</span><span class="s2">,</span><span class="s1">&quot;PARAM&quot;</span><span class="s2">,</span><span class="s1">&quot;PARAM_YIELD&quot;</span><span class="s2">,</span><span class="s1">&quot;PARAM_AWAIT&quot;</span><span class="s2">,</span><span class="s1">&quot;PARAM_RETURN&quot;</span><span class="s2">,</span><span class="s1">&quot;PARAM_IN&quot;</span><span class="s2">,</span><span class="s1">&quot;ProductionParameterHandler&quot;</span><span class="s2">,</span><span class="s1">&quot;stacks&quot;</span><span class="s2">,</span><span class="s1">&quot;currentFlags&quot;</span><span class="s2">,</span><span class="s1">&quot;hasAwait&quot;</span><span class="s2">,</span><span class="s1">&quot;hasYield&quot;</span><span class="s2">,</span><span class="s1">&quot;hasReturn&quot;</span><span class="s2">,</span><span class="s1">&quot;hasIn&quot;</span><span class="s2">,</span><span class="s1">&quot;functionFlags&quot;</span><span class="s2">,</span><span class="s1">&quot;UtilParser&quot;</span><span class="s2">,</span><span class="s1">&quot;addExtra&quot;</span><span class="s2">,</span><span class="s1">&quot;isContextual&quot;</span><span class="s2">,</span><span class="s1">&quot;isUnparsedContextual&quot;</span><span class="s2">,</span><span class="s1">&quot;nameStart&quot;</span><span class="s2">,</span><span class="s1">&quot;nameEnd&quot;</span><span class="s2">,</span><span class="s1">&quot;nextCh&quot;</span><span class="s2">,</span><span class="s1">&quot;isLookaheadContextual&quot;</span><span class="s2">,</span><span class="s1">&quot;eatContextual&quot;</span><span class="s2">,</span><span class="s1">&quot;expectContextual&quot;</span><span class="s2">,</span><span class="s1">&quot;canInsertSemicolon&quot;</span><span class="s2">,</span><span class="s1">&quot;hasPrecedingLineBreak&quot;</span><span class="s2">,</span><span class="s1">&quot;hasFollowingLineBreak&quot;</span><span class="s2">,</span><span class="s1">&quot;isLineTerminator&quot;</span><span class="s2">,</span><span class="s1">&quot;semicolon&quot;</span><span class="s2">,</span><span class="s1">&quot;allowAsi&quot;</span><span class="s2">,</span><span class="s1">&quot;expect&quot;</span><span class="s2">,</span><span class="s1">&quot;tryParse&quot;</span><span class="s2">,</span><span class="s1">&quot;fn&quot;</span><span class="s2">,</span><span class="s1">&quot;oldState&quot;</span><span class="s2">,</span><span class="s1">&quot;abortSignal&quot;</span><span class="s2">,</span><span class="s1">&quot;failState&quot;</span><span class="s2">,</span><span class="s1">&quot;thrown&quot;</span><span class="s2">,</span><span class="s1">&quot;aborted&quot;</span><span class="s2">,</span><span class="s1">&quot;checkExpressionErrors&quot;</span><span class="s2">,</span><span class="s1">&quot;andThrow&quot;</span><span class="s2">,</span><span class="s1">&quot;shorthandAssignLoc&quot;</span><span class="s2">,</span><span class="s1">&quot;doubleProtoLoc&quot;</span><span class="s2">,</span><span class="s1">&quot;privateKeyLoc&quot;</span><span class="s2">,</span><span class="s1">&quot;optionalParametersLoc&quot;</span><span class="s2">,</span><span class="s1">&quot;hasErrors&quot;</span><span class="s2">,</span><span class="s1">&quot;isLiteralPropertyName&quot;</span><span class="s2">,</span><span class="s1">&quot;property&quot;</span><span class="s2">,</span><span class="s1">&quot;initializeScopes&quot;</span><span class="s2">,</span><span class="s1">&quot;oldLabels&quot;</span><span class="s2">,</span><span class="s1">&quot;oldExportedIdentifiers&quot;</span><span class="s2">,</span><span class="s1">&quot;exportedIdentifiers&quot;</span><span class="s2">,</span><span class="s1">&quot;oldInModule&quot;</span><span class="s2">,</span><span class="s1">&quot;oldScope&quot;</span><span class="s2">,</span><span class="s1">&quot;getScopeHandler&quot;</span><span class="s2">,</span><span class="s1">&quot;oldProdParam&quot;</span><span class="s2">,</span><span class="s1">&quot;prodParam&quot;</span><span class="s2">,</span><span class="s1">&quot;oldExpressionScope&quot;</span><span class="s2">,</span><span class="s1">&quot;expressionScope&quot;</span><span class="s2">,</span><span class="s1">&quot;enterInitialScopes&quot;</span><span class="s2">,</span><span class="s1">&quot;paramFlags&quot;</span><span class="s2">,</span><span class="s1">&quot;checkDestructuringPrivate&quot;</span><span class="s2">,</span><span class="s1">&quot;ExpressionErrors&quot;</span><span class="s2">,</span><span class="s1">&quot;Node&quot;</span><span class="s2">,</span><span class="s1">&quot;range&quot;</span><span class="s2">,</span><span class="s1">&quot;NodePrototype&quot;</span><span class="s2">,</span><span class="s1">&quot;prototype&quot;</span><span class="s2">,</span><span class="s1">&quot;__clone&quot;</span><span class="s2">,</span><span class="s1">&quot;newNode&quot;</span><span class="s2">,</span><span class="s1">&quot;clonePlaceholder&quot;</span><span class="s2">,</span><span class="s1">&quot;cloneIdentifier&quot;</span><span class="s2">,</span><span class="s1">&quot;cloned&quot;</span><span class="s2">,</span><span class="s1">&quot;create&quot;</span><span class="s2">,</span><span class="s1">&quot;expectedNode&quot;</span><span class="s2">,</span><span class="s1">&quot;cloneStringLiteral&quot;</span><span class="s2">,</span><span class="s1">&quot;NodeUtils&quot;</span><span class="s2">,</span><span class="s1">&quot;startNodeAt&quot;</span><span class="s2">,</span><span class="s1">&quot;resetStartLocationFromNode&quot;</span><span class="s2">,</span><span class="s1">&quot;locationNode&quot;</span><span class="s2">,</span><span class="s1">&quot;reservedTypes&quot;</span><span class="s2">,</span><span class="s1">&quot;FlowErrors&quot;</span><span class="s2">,</span><span class="s1">&quot;AmbiguousConditionalArrow&quot;</span><span class="s2">,</span><span class="s1">&quot;AmbiguousDeclareModuleKind&quot;</span><span class="s2">,</span><span class="s1">&quot;AssignReservedType&quot;</span><span class="s2">,</span><span class="s1">&quot;reservedType&quot;</span><span class="s2">,</span><span class="s1">&quot;DeclareClassElement&quot;</span><span class="s2">,</span><span class="s1">&quot;DeclareClassFieldInitializer&quot;</span><span class="s2">,</span><span class="s1">&quot;DuplicateDeclareModuleExports&quot;</span><span class="s2">,</span><span class="s1">&quot;EnumBooleanMemberNotInitialized&quot;</span><span class="s2">,</span><span class="s1">&quot;memberName&quot;</span><span class="s2">,</span><span class="s1">&quot;enumName&quot;</span><span class="s2">,</span><span class="s1">&quot;EnumDuplicateMemberName&quot;</span><span class="s2">,</span><span class="s1">&quot;EnumInconsistentMemberValues&quot;</span><span class="s2">,</span><span class="s1">&quot;EnumInvalidExplicitType&quot;</span><span class="s2">,</span><span class="s1">&quot;invalidEnumType&quot;</span><span class="s2">,</span><span class="s1">&quot;EnumInvalidExplicitTypeUnknownSupplied&quot;</span><span class="s2">,</span><span class="s1">&quot;EnumInvalidMemberInitializerPrimaryType&quot;</span><span class="s2">,</span><span class="s1">&quot;explicitType&quot;</span><span class="s2">,</span><span class="s1">&quot;EnumInvalidMemberInitializerSymbolType&quot;</span><span class="s2">,</span><span class="s1">&quot;EnumInvalidMemberInitializerUnknownType&quot;</span><span class="s2">,</span><span class="s1">&quot;EnumInvalidMemberName&quot;</span><span class="s2">,</span><span class="s1">&quot;suggestion&quot;</span><span class="s2">,</span><span class="s1">&quot;EnumNumberMemberNotInitialized&quot;</span><span class="s2">,</span><span class="s1">&quot;EnumStringMemberInconsistentlyInitailized&quot;</span><span class="s2">,</span><span class="s1">&quot;GetterMayNotHaveThisParam&quot;</span><span class="s2">,</span><span class="s1">&quot;ImportReflectionHasImportType&quot;</span><span class="s2">,</span><span class="s1">&quot;ImportTypeShorthandOnlyInPureImport&quot;</span><span class="s2">,</span><span class="s1">&quot;InexactInsideExact&quot;</span><span class="s2">,</span><span class="s1">&quot;InexactInsideNonObject&quot;</span><span class="s2">,</span><span class="s1">&quot;InexactVariance&quot;</span><span class="s2">,</span><span class="s1">&quot;InvalidNonTypeImportInDeclareModule&quot;</span><span class="s2">,</span><span class="s1">&quot;MissingTypeParamDefault&quot;</span><span class="s2">,</span><span class="s1">&quot;NestedDeclareModule&quot;</span><span class="s2">,</span><span class="s1">&quot;NestedFlowComment&quot;</span><span class="s2">,</span><span class="s1">&quot;PatternIsOptional&quot;</span><span class="s2">,</span><span class="s1">&quot;SetterMayNotHaveThisParam&quot;</span><span class="s2">,</span><span class="s1">&quot;SpreadVariance&quot;</span><span class="s2">,</span><span class="s1">&quot;ThisParamAnnotationRequired&quot;</span><span class="s2">,</span><span class="s1">&quot;ThisParamBannedInConstructor&quot;</span><span class="s2">,</span><span class="s1">&quot;ThisParamMayNotBeOptional&quot;</span><span class="s2">,</span><span class="s1">&quot;ThisParamMustBeFirst&quot;</span><span class="s2">,</span><span class="s1">&quot;ThisParamNoDefault&quot;</span><span class="s2">,</span><span class="s1">&quot;TypeBeforeInitializer&quot;</span><span class="s2">,</span><span class="s1">&quot;TypeCastInPattern&quot;</span><span class="s2">,</span><span class="s1">&quot;UnexpectedExplicitInexactInObject&quot;</span><span class="s2">,</span><span class="s1">&quot;UnexpectedReservedType&quot;</span><span class="s2">,</span><span class="s1">&quot;UnexpectedReservedUnderscore&quot;</span><span class="s2">,</span><span class="s1">&quot;UnexpectedSpaceBetweenModuloChecks&quot;</span><span class="s2">,</span><span class="s1">&quot;UnexpectedSpreadType&quot;</span><span class="s2">,</span><span class="s1">&quot;UnexpectedSubtractionOperand&quot;</span><span class="s2">,</span><span class="s1">&quot;UnexpectedTokenAfterTypeParameter&quot;</span><span class="s2">,</span><span class="s1">&quot;UnexpectedTypeParameterBeforeAsyncArrowFunction&quot;</span><span class="s2">,</span><span class="s1">&quot;UnsupportedDeclareExportKind&quot;</span><span class="s2">,</span><span class="s1">&quot;unsupportedExportKind&quot;</span><span class="s2">,</span><span class="s1">&quot;UnsupportedStatementInDeclareModule&quot;</span><span class="s2">,</span><span class="s1">&quot;UnterminatedFlowComment&quot;</span><span class="s2">,</span><span class="s1">&quot;isEsModuleType&quot;</span><span class="s2">,</span><span class="s1">&quot;bodyElement&quot;</span><span class="s2">,</span><span class="s1">&quot;hasTypeImportKind&quot;</span><span class="s2">,</span><span class="s1">&quot;importKind&quot;</span><span class="s2">,</span><span class="s1">&quot;isMaybeDefaultImport&quot;</span><span class="s2">,</span><span class="s1">&quot;exportSuggestions&quot;</span><span class="s2">,</span><span class="s1">&quot;const&quot;</span><span class="s2">,</span><span class="s1">&quot;let&quot;</span><span class="s2">,</span><span class="s1">&quot;interface&quot;</span><span class="s2">,</span><span class="s1">&quot;partition&quot;</span><span class="s2">,</span><span class="s1">&quot;list&quot;</span><span class="s2">,</span><span class="s1">&quot;list1&quot;</span><span class="s2">,</span><span class="s1">&quot;list2&quot;</span><span class="s2">,</span><span class="s1">&quot;FLOW_PRAGMA_REGEX&quot;</span><span class="s2">,</span><span class="s1">&quot;flow&quot;</span><span class="s2">,</span><span class="s1">&quot;FlowParserMixin&quot;</span><span class="s2">,</span><span class="s1">&quot;flowPragma&quot;</span><span class="s2">,</span><span class="s1">&quot;shouldParseTypes&quot;</span><span class="s2">,</span><span class="s1">&quot;shouldParseEnums&quot;</span><span class="s2">,</span><span class="s1">&quot;matches&quot;</span><span class="s2">,</span><span class="s1">&quot;exec&quot;</span><span class="s2">,</span><span class="s1">&quot;flowParseTypeInitialiser&quot;</span><span class="s2">,</span><span class="s1">&quot;tok&quot;</span><span class="s2">,</span><span class="s1">&quot;oldInType&quot;</span><span class="s2">,</span><span class="s1">&quot;flowParseType&quot;</span><span class="s2">,</span><span class="s1">&quot;flowParsePredicate&quot;</span><span class="s2">,</span><span class="s1">&quot;moduloLoc&quot;</span><span class="s2">,</span><span class="s1">&quot;parseExpression&quot;</span><span class="s2">,</span><span class="s1">&quot;flowParseTypeAndPredicateInitialiser&quot;</span><span class="s2">,</span><span class="s1">&quot;predicate&quot;</span><span class="s2">,</span><span class="s1">&quot;flowParseDeclareClass&quot;</span><span class="s2">,</span><span class="s1">&quot;flowParseInterfaceish&quot;</span><span class="s2">,</span><span class="s1">&quot;flowParseDeclareFunction&quot;</span><span class="s2">,</span><span class="s1">&quot;parseIdentifier&quot;</span><span class="s2">,</span><span class="s1">&quot;typeNode&quot;</span><span class="s2">,</span><span class="s1">&quot;typeContainer&quot;</span><span class="s2">,</span><span class="s1">&quot;flowParseTypeParameterDeclaration&quot;</span><span class="s2">,</span><span class="s1">&quot;tmp&quot;</span><span class="s2">,</span><span class="s1">&quot;flowParseFunctionTypeParams&quot;</span><span class="s2">,</span><span class="s1">&quot;this&quot;</span><span class="s2">,</span><span class="s1">&quot;returnType&quot;</span><span class="s2">,</span><span class="s1">&quot;typeAnnotation&quot;</span><span class="s2">,</span><span class="s1">&quot;flowParseDeclare&quot;</span><span class="s2">,</span><span class="s1">&quot;insideModule&quot;</span><span class="s2">,</span><span class="s1">&quot;flowParseDeclareVariable&quot;</span><span class="s2">,</span><span class="s1">&quot;flowParseDeclareModuleExports&quot;</span><span class="s2">,</span><span class="s1">&quot;flowParseDeclareModule&quot;</span><span class="s2">,</span><span class="s1">&quot;flowParseDeclareTypeAlias&quot;</span><span class="s2">,</span><span class="s1">&quot;flowParseDeclareOpaqueType&quot;</span><span class="s2">,</span><span class="s1">&quot;flowParseDeclareInterface&quot;</span><span class="s2">,</span><span class="s1">&quot;flowParseDeclareExportDeclaration&quot;</span><span class="s2">,</span><span class="s1">&quot;flowParseTypeAnnotatableIdentifier&quot;</span><span class="s2">,</span><span class="s1">&quot;parseExprAtom&quot;</span><span class="s2">,</span><span class="s1">&quot;bodyNode&quot;</span><span class="s2">,</span><span class="s1">&quot;parseImport&quot;</span><span class="s2">,</span><span class="s1">&quot;hasModuleExport&quot;</span><span class="s2">,</span><span class="s1">&quot;default&quot;</span><span class="s2">,</span><span class="s1">&quot;isLet&quot;</span><span class="s2">,</span><span class="s1">&quot;exportKind&quot;</span><span class="s2">,</span><span class="s1">&quot;flowParseTypeAnnotation&quot;</span><span class="s2">,</span><span class="s1">&quot;finished&quot;</span><span class="s2">,</span><span class="s1">&quot;flowParseTypeAlias&quot;</span><span class="s2">,</span><span class="s1">&quot;flowParseOpaqueType&quot;</span><span class="s2">,</span><span class="s1">&quot;isClass&quot;</span><span class="s2">,</span><span class="s1">&quot;flowParseRestrictedIdentifier&quot;</span><span class="s2">,</span><span class="s1">&quot;extends&quot;</span><span class="s2">,</span><span class="s1">&quot;implements&quot;</span><span class="s2">,</span><span class="s1">&quot;mixins&quot;</span><span class="s2">,</span><span class="s1">&quot;flowParseInterfaceExtends&quot;</span><span class="s2">,</span><span class="s1">&quot;flowParseObjectType&quot;</span><span class="s2">,</span><span class="s1">&quot;allowStatic&quot;</span><span class="s2">,</span><span class="s1">&quot;allowExact&quot;</span><span class="s2">,</span><span class="s1">&quot;allowSpread&quot;</span><span class="s2">,</span><span class="s1">&quot;allowProto&quot;</span><span class="s2">,</span><span class="s1">&quot;allowInexact&quot;</span><span class="s2">,</span><span class="s1">&quot;flowParseQualifiedTypeIdentifier&quot;</span><span class="s2">,</span><span class="s1">&quot;flowParseTypeParameterInstantiation&quot;</span><span class="s2">,</span><span class="s1">&quot;flowParseInterface&quot;</span><span class="s2">,</span><span class="s1">&quot;checkNotUnderscore&quot;</span><span class="s2">,</span><span class="s1">&quot;checkReservedType&quot;</span><span class="s2">,</span><span class="s1">&quot;liberal&quot;</span><span class="s2">,</span><span class="s1">&quot;right&quot;</span><span class="s2">,</span><span class="s1">&quot;declare&quot;</span><span class="s2">,</span><span class="s1">&quot;supertype&quot;</span><span class="s2">,</span><span class="s1">&quot;impltype&quot;</span><span class="s2">,</span><span class="s1">&quot;flowParseTypeParameter&quot;</span><span class="s2">,</span><span class="s1">&quot;requireDefault&quot;</span><span class="s2">,</span><span class="s1">&quot;nodeStartLoc&quot;</span><span class="s2">,</span><span class="s1">&quot;variance&quot;</span><span class="s2">,</span><span class="s1">&quot;flowParseVariance&quot;</span><span class="s2">,</span><span class="s1">&quot;ident&quot;</span><span class="s2">,</span><span class="s1">&quot;bound&quot;</span><span class="s2">,</span><span class="s1">&quot;defaultRequired&quot;</span><span class="s2">,</span><span class="s1">&quot;typeParameter&quot;</span><span class="s2">,</span><span class="s1">&quot;oldNoAnonFunctionType&quot;</span><span class="s2">,</span><span class="s1">&quot;flowParseTypeParameterInstantiationCallOrNew&quot;</span><span class="s2">,</span><span class="s1">&quot;flowParseTypeOrImplicitInstantiation&quot;</span><span class="s2">,</span><span class="s1">&quot;flowParseInterfaceType&quot;</span><span class="s2">,</span><span class="s1">&quot;flowParseObjectPropertyKey&quot;</span><span class="s2">,</span><span class="s1">&quot;flowParseObjectTypeIndexer&quot;</span><span class="s2">,</span><span class="s1">&quot;isStatic&quot;</span><span class="s2">,</span><span class="s1">&quot;static&quot;</span><span class="s2">,</span><span class="s1">&quot;flowParseObjectTypeInternalSlot&quot;</span><span class="s2">,</span><span class="s1">&quot;flowParseObjectTypeMethodish&quot;</span><span class="s2">,</span><span class="s1">&quot;flowParseFunctionTypeParam&quot;</span><span class="s2">,</span><span class="s1">&quot;flowParseObjectTypeCallProperty&quot;</span><span class="s2">,</span><span class="s1">&quot;valueNode&quot;</span><span class="s2">,</span><span class="s1">&quot;callProperties&quot;</span><span class="s2">,</span><span class="s1">&quot;indexers&quot;</span><span class="s2">,</span><span class="s1">&quot;internalSlots&quot;</span><span class="s2">,</span><span class="s1">&quot;endDelim&quot;</span><span class="s2">,</span><span class="s1">&quot;exact&quot;</span><span class="s2">,</span><span class="s1">&quot;inexact&quot;</span><span class="s2">,</span><span class="s1">&quot;protoStartLoc&quot;</span><span class="s2">,</span><span class="s1">&quot;inexactStartLoc&quot;</span><span class="s2">,</span><span class="s1">&quot;propOrInexact&quot;</span><span class="s2">,</span><span class="s1">&quot;flowParseObjectTypeProperty&quot;</span><span class="s2">,</span><span class="s1">&quot;flowObjectTypeSemicolon&quot;</span><span class="s2">,</span><span class="s1">&quot;isInexactToken&quot;</span><span class="s2">,</span><span class="s1">&quot;proto&quot;</span><span class="s2">,</span><span class="s1">&quot;flowCheckGetterSetterParams&quot;</span><span class="s2">,</span><span class="s1">&quot;paramCount&quot;</span><span class="s2">,</span><span class="s1">&quot;_startLoc&quot;</span><span class="s2">,</span><span class="s1">&quot;node2&quot;</span><span class="s2">,</span><span class="s1">&quot;qualification&quot;</span><span class="s2">,</span><span class="s1">&quot;flowParseGenericType&quot;</span><span class="s2">,</span><span class="s1">&quot;flowParseTypeofType&quot;</span><span class="s2">,</span><span class="s1">&quot;flowParsePrimaryType&quot;</span><span class="s2">,</span><span class="s1">&quot;flowParseTupleType&quot;</span><span class="s2">,</span><span class="s1">&quot;first&quot;</span><span class="s2">,</span><span class="s1">&quot;lh&quot;</span><span class="s2">,</span><span class="s1">&quot;isThis&quot;</span><span class="s2">,</span><span class="s1">&quot;reinterpretTypeAsFunctionTypeParam&quot;</span><span class="s2">,</span><span class="s1">&quot;flowIdentToTypeAnnotation&quot;</span><span class="s2">,</span><span class="s1">&quot;isGroupedType&quot;</span><span class="s2">,</span><span class="s1">&quot;parseLiteralAtNode&quot;</span><span class="s2">,</span><span class="s1">&quot;createIdentifier&quot;</span><span class="s2">,</span><span class="s1">&quot;flowParsePostfixType&quot;</span><span class="s2">,</span><span class="s1">&quot;seenOptionalIndexedAccess&quot;</span><span class="s2">,</span><span class="s1">&quot;objectType&quot;</span><span class="s2">,</span><span class="s1">&quot;indexType&quot;</span><span class="s2">,</span><span class="s1">&quot;flowParsePrefixType&quot;</span><span class="s2">,</span><span class="s1">&quot;flowParseAnonFunctionWithoutParens&quot;</span><span class="s2">,</span><span class="s1">&quot;param&quot;</span><span class="s2">,</span><span class="s1">&quot;flowParseIntersectionType&quot;</span><span class="s2">,</span><span class="s1">&quot;flowParseUnionType&quot;</span><span class="s2">,</span><span class="s1">&quot;allowPrimitiveOverride&quot;</span><span class="s2">,</span><span class="s1">&quot;typeCastToParameter&quot;</span><span class="s2">,</span><span class="s1">&quot;allowExpressionBody&quot;</span><span class="s2">,</span><span class="s1">&quot;forwardNoArrowParamsConversionAt&quot;</span><span class="s2">,</span><span class="s1">&quot;parseFunctionBodyAndFinish&quot;</span><span class="s2">,</span><span class="s1">&quot;parseStatementLike&quot;</span><span class="s2">,</span><span class="s1">&quot;flowParseEnumDeclaration&quot;</span><span class="s2">,</span><span class="s1">&quot;parseExpressionStatement&quot;</span><span class="s2">,</span><span class="s1">&quot;expr&quot;</span><span class="s2">,</span><span class="s1">&quot;shouldParseExportDeclaration&quot;</span><span class="s2">,</span><span class="s1">&quot;isExportDefaultSpecifier&quot;</span><span class="s2">,</span><span class="s1">&quot;parseExportDefaultExpression&quot;</span><span class="s2">,</span><span class="s1">&quot;parseConditional&quot;</span><span class="s2">,</span><span class="s1">&quot;setOptionalParametersError&quot;</span><span class="s2">,</span><span class="s1">&quot;originalNoArrowAt&quot;</span><span class="s2">,</span><span class="s1">&quot;consequent&quot;</span><span class="s2">,</span><span class="s1">&quot;failed&quot;</span><span class="s2">,</span><span class="s1">&quot;tryParseConditionalConsequent&quot;</span><span class="s2">,</span><span class="s1">&quot;valid&quot;</span><span class="s2">,</span><span class="s1">&quot;getArrowLikeExpressions&quot;</span><span class="s2">,</span><span class="s1">&quot;alternate&quot;</span><span class="s2">,</span><span class="s1">&quot;parseMaybeAssign&quot;</span><span class="s2">,</span><span class="s1">&quot;parseMaybeAssignAllowIn&quot;</span><span class="s2">,</span><span class="s1">&quot;disallowInvalid&quot;</span><span class="s2">,</span><span class="s1">&quot;arrows&quot;</span><span class="s2">,</span><span class="s1">&quot;finishArrowValidation&quot;</span><span class="s2">,</span><span class="s1">&quot;every&quot;</span><span class="s2">,</span><span class="s1">&quot;_node$extra&quot;</span><span class="s2">,</span><span class="s1">&quot;toAssignableList&quot;</span><span class="s2">,</span><span class="s1">&quot;trailingCommaLoc&quot;</span><span class="s2">,</span><span class="s1">&quot;checkParams&quot;</span><span class="s2">,</span><span class="s1">&quot;result&quot;</span><span class="s2">,</span><span class="s1">&quot;parseParenItem&quot;</span><span class="s2">,</span><span class="s1">&quot;typeCastNode&quot;</span><span class="s2">,</span><span class="s1">&quot;assertModuleNodeAllowed&quot;</span><span class="s2">,</span><span class="s1">&quot;decl&quot;</span><span class="s2">,</span><span class="s1">&quot;parseExportDeclaration&quot;</span><span class="s2">,</span><span class="s1">&quot;declarationNode&quot;</span><span class="s2">,</span><span class="s1">&quot;parseExportSpecifiers&quot;</span><span class="s2">,</span><span class="s1">&quot;parseExportFrom&quot;</span><span class="s2">,</span><span class="s1">&quot;eatExportStar&quot;</span><span class="s2">,</span><span class="s1">&quot;maybeParseExportNamespaceSpecifier&quot;</span><span class="s2">,</span><span class="s1">&quot;hasNamespace&quot;</span><span class="s2">,</span><span class="s1">&quot;parseClassId&quot;</span><span class="s2">,</span><span class="s1">&quot;isStatement&quot;</span><span class="s2">,</span><span class="s1">&quot;optionalId&quot;</span><span class="s2">,</span><span class="s1">&quot;parseClassMember&quot;</span><span class="s2">,</span><span class="s1">&quot;member&quot;</span><span class="s2">,</span><span class="s1">&quot;parseClassMemberFromModifier&quot;</span><span class="s2">,</span><span class="s1">&quot;isIterator&quot;</span><span class="s2">,</span><span class="s1">&quot;readIterator&quot;</span><span class="s2">,</span><span class="s1">&quot;fullWord&quot;</span><span class="s2">,</span><span class="s1">&quot;left&quot;</span><span class="s2">,</span><span class="s1">&quot;exprList&quot;</span><span class="s2">,</span><span class="s1">&quot;toReferencedList&quot;</span><span class="s2">,</span><span class="s1">&quot;isParenthesizedExpr&quot;</span><span class="s2">,</span><span class="s1">&quot;_expr$extra&quot;</span><span class="s2">,</span><span class="s1">&quot;parseArrayLike&quot;</span><span class="s2">,</span><span class="s1">&quot;close&quot;</span><span class="s2">,</span><span class="s1">&quot;canBePattern&quot;</span><span class="s2">,</span><span class="s1">&quot;isTuple&quot;</span><span class="s2">,</span><span class="s1">&quot;isParenthesized&quot;</span><span class="s2">,</span><span class="s1">&quot;isClassMethod&quot;</span><span class="s2">,</span><span class="s1">&quot;isClassProperty&quot;</span><span class="s2">,</span><span class="s1">&quot;isNonstaticConstructor&quot;</span><span class="s2">,</span><span class="s1">&quot;isThisParam&quot;</span><span class="s2">,</span><span class="s1">&quot;pushClassPrivateMethod&quot;</span><span class="s2">,</span><span class="s1">&quot;parseClassSuper&quot;</span><span class="s2">,</span><span class="s1">&quot;superTypeParameters&quot;</span><span class="s2">,</span><span class="s1">&quot;implemented&quot;</span><span class="s2">,</span><span class="s1">&quot;checkGetterSetterParams&quot;</span><span class="s2">,</span><span class="s1">&quot;parsePropertyNamePrefixOperator&quot;</span><span class="s2">,</span><span class="s1">&quot;parseObjPropValue&quot;</span><span class="s2">,</span><span class="s1">&quot;parseAssignableListItemTypes&quot;</span><span class="s2">,</span><span class="s1">&quot;parseMaybeDefault&quot;</span><span class="s2">,</span><span class="s1">&quot;shouldParseDefaultImport&quot;</span><span class="s2">,</span><span class="s1">&quot;checkImportReflection&quot;</span><span class="s2">,</span><span class="s1">&quot;module&quot;</span><span class="s2">,</span><span class="s1">&quot;parseImportSpecifierLocal&quot;</span><span class="s2">,</span><span class="s1">&quot;specifier&quot;</span><span class="s2">,</span><span class="s1">&quot;local&quot;</span><span class="s2">,</span><span class="s1">&quot;finishImportSpecifier&quot;</span><span class="s2">,</span><span class="s1">&quot;maybeParseDefaultImportSpecifier&quot;</span><span class="s2">,</span><span class="s1">&quot;parseImportSpecifier&quot;</span><span class="s2">,</span><span class="s1">&quot;importedIsString&quot;</span><span class="s2">,</span><span class="s1">&quot;isInTypeOnlyImport&quot;</span><span class="s2">,</span><span class="s1">&quot;isMaybeTypeOnly&quot;</span><span class="s2">,</span><span class="s1">&quot;firstIdent&quot;</span><span class="s2">,</span><span class="s1">&quot;imported&quot;</span><span class="s2">,</span><span class="s1">&quot;specifierTypeKind&quot;</span><span class="s2">,</span><span class="s1">&quot;as_ident&quot;</span><span class="s2">,</span><span class="s1">&quot;specifierIsTypeImport&quot;</span><span class="s2">,</span><span class="s1">&quot;checkReservedWord&quot;</span><span class="s2">,</span><span class="s1">&quot;parseBindingAtom&quot;</span><span class="s2">,</span><span class="s1">&quot;parseFunctionParams&quot;</span><span class="s2">,</span><span class="s1">&quot;parseVarId&quot;</span><span class="s2">,</span><span class="s1">&quot;parseAsyncArrowFromCallExpression&quot;</span><span class="s2">,</span><span class="s1">&quot;call&quot;</span><span class="s2">,</span><span class="s1">&quot;shouldParseAsyncArrow&quot;</span><span class="s2">,</span><span class="s1">&quot;afterLeftParse&quot;</span><span class="s2">,</span><span class="s1">&quot;_jsx&quot;</span><span class="s2">,</span><span class="s1">&quot;jsx&quot;</span><span class="s2">,</span><span class="s1">&quot;currentContext&quot;</span><span class="s2">,</span><span class="s1">&quot;_jsx2&quot;</span><span class="s2">,</span><span class="s1">&quot;_jsx3&quot;</span><span class="s2">,</span><span class="s1">&quot;abort&quot;</span><span class="s2">,</span><span class="s1">&quot;_arrowExpression$extr&quot;</span><span class="s2">,</span><span class="s1">&quot;arrowExpression&quot;</span><span class="s2">,</span><span class="s1">&quot;maybeUnwrapTypeCastExpression&quot;</span><span class="s2">,</span><span class="s1">&quot;async&quot;</span><span class="s2">,</span><span class="s1">&quot;parseArrow&quot;</span><span class="s2">,</span><span class="s1">&quot;shouldParseArrow&quot;</span><span class="s2">,</span><span class="s1">&quot;setArrowFunctionParameters&quot;</span><span class="s2">,</span><span class="s1">&quot;allowDuplicates&quot;</span><span class="s2">,</span><span class="s1">&quot;isArrowFunction&quot;</span><span class="s2">,</span><span class="s1">&quot;strictModeChanged&quot;</span><span class="s2">,</span><span class="s1">&quot;parseParenAndDistinguishExpression&quot;</span><span class="s2">,</span><span class="s1">&quot;canBeArrow&quot;</span><span class="s2">,</span><span class="s1">&quot;parseSubscripts&quot;</span><span class="s2">,</span><span class="s1">&quot;parseCallExpressionArguments&quot;</span><span class="s2">,</span><span class="s1">&quot;parseAsyncArrowWithTypeParameters&quot;</span><span class="s2">,</span><span class="s1">&quot;subscriptState&quot;</span><span class="s2">,</span><span class="s1">&quot;isLookaheadToken_lt&quot;</span><span class="s2">,</span><span class="s1">&quot;typeArguments&quot;</span><span class="s2">,</span><span class="s1">&quot;parseNewCallee&quot;</span><span class="s2">,</span><span class="s1">&quot;targs&quot;</span><span class="s2">,</span><span class="s1">&quot;parseArrowExpression&quot;</span><span class="s2">,</span><span class="s1">&quot;parseTopLevel&quot;</span><span class="s2">,</span><span class="s1">&quot;program&quot;</span><span class="s2">,</span><span class="s1">&quot;fileNode&quot;</span><span class="s2">,</span><span class="s1">&quot;skipFlowComment&quot;</span><span class="s2">,</span><span class="s1">&quot;hasFlowCommentCompletion&quot;</span><span class="s2">,</span><span class="s1">&quot;commentSkip&quot;</span><span class="s2">,</span><span class="s1">&quot;shiftToFirstNonWhiteSpace&quot;</span><span class="s2">,</span><span class="s1">&quot;ch2&quot;</span><span class="s2">,</span><span class="s1">&quot;ch3&quot;</span><span class="s2">,</span><span class="s1">&quot;flowEnumErrorBooleanMemberNotInitialized&quot;</span><span class="s2">,</span><span class="s1">&quot;flowEnumErrorInvalidMemberInitializer&quot;</span><span class="s2">,</span><span class="s1">&quot;enumContext&quot;</span><span class="s2">,</span><span class="s1">&quot;flowEnumErrorNumberMemberNotInitialized&quot;</span><span class="s2">,</span><span class="s1">&quot;flowEnumErrorStringMemberInconsistentlyInitailized&quot;</span><span class="s2">,</span><span class="s1">&quot;flowEnumMemberInit&quot;</span><span class="s2">,</span><span class="s1">&quot;endOfInit&quot;</span><span class="s2">,</span><span class="s1">&quot;literal&quot;</span><span class="s2">,</span><span class="s1">&quot;flowEnumMemberRaw&quot;</span><span class="s2">,</span><span class="s1">&quot;flowEnumCheckExplicitTypeMismatch&quot;</span><span class="s2">,</span><span class="s1">&quot;expectedType&quot;</span><span class="s2">,</span><span class="s1">&quot;flowEnumMembers&quot;</span><span class="s2">,</span><span class="s1">&quot;seenNames&quot;</span><span class="s2">,</span><span class="s1">&quot;members&quot;</span><span class="s2">,</span><span class="s1">&quot;booleanMembers&quot;</span><span class="s2">,</span><span class="s1">&quot;numberMembers&quot;</span><span class="s2">,</span><span class="s1">&quot;stringMembers&quot;</span><span class="s2">,</span><span class="s1">&quot;defaultedMembers&quot;</span><span class="s2">,</span><span class="s1">&quot;hasUnknownMembers&quot;</span><span class="s2">,</span><span class="s1">&quot;memberNode&quot;</span><span class="s2">,</span><span class="s1">&quot;toUpperCase&quot;</span><span class="s2">,</span><span class="s1">&quot;flowEnumStringMembers&quot;</span><span class="s2">,</span><span class="s1">&quot;initializedMembers&quot;</span><span class="s2">,</span><span class="s1">&quot;flowEnumParseExplicitType&quot;</span><span class="s2">,</span><span class="s1">&quot;flowEnumBody&quot;</span><span class="s2">,</span><span class="s1">&quot;nameLoc&quot;</span><span class="s2">,</span><span class="s1">&quot;empty&quot;</span><span class="s2">,</span><span class="s1">&quot;boolsLen&quot;</span><span class="s2">,</span><span class="s1">&quot;numsLen&quot;</span><span class="s2">,</span><span class="s1">&quot;strsLen&quot;</span><span class="s2">,</span><span class="s1">&quot;defaultedLen&quot;</span><span class="s2">,</span><span class="s1">&quot;afterNext&quot;</span><span class="s2">,</span><span class="s1">&quot;entities&quot;</span><span class="s2">,</span><span class="s1">&quot;__proto__&quot;</span><span class="s2">,</span><span class="s1">&quot;quot&quot;</span><span class="s2">,</span><span class="s1">&quot;amp&quot;</span><span class="s2">,</span><span class="s1">&quot;apos&quot;</span><span class="s2">,</span><span class="s1">&quot;nbsp&quot;</span><span class="s2">,</span><span class="s1">&quot;iexcl&quot;</span><span class="s2">,</span><span class="s1">&quot;cent&quot;</span><span class="s2">,</span><span class="s1">&quot;pound&quot;</span><span class="s2">,</span><span class="s1">&quot;curren&quot;</span><span class="s2">,</span><span class="s1">&quot;yen&quot;</span><span class="s2">,</span><span class="s1">&quot;brvbar&quot;</span><span class="s2">,</span><span class="s1">&quot;sect&quot;</span><span class="s2">,</span><span class="s1">&quot;uml&quot;</span><span class="s2">,</span><span class="s1">&quot;copy&quot;</span><span class="s2">,</span><span class="s1">&quot;ordf&quot;</span><span class="s2">,</span><span class="s1">&quot;laquo&quot;</span><span class="s2">,</span><span class="s1">&quot;not&quot;</span><span class="s2">,</span><span class="s1">&quot;shy&quot;</span><span class="s2">,</span><span class="s1">&quot;reg&quot;</span><span class="s2">,</span><span class="s1">&quot;macr&quot;</span><span class="s2">,</span><span class="s1">&quot;deg&quot;</span><span class="s2">,</span><span class="s1">&quot;plusmn&quot;</span><span class="s2">,</span><span class="s1">&quot;sup2&quot;</span><span class="s2">,</span><span class="s1">&quot;sup3&quot;</span><span class="s2">,</span><span class="s1">&quot;acute&quot;</span><span class="s2">,</span><span class="s1">&quot;micro&quot;</span><span class="s2">,</span><span class="s1">&quot;para&quot;</span><span class="s2">,</span><span class="s1">&quot;middot&quot;</span><span class="s2">,</span><span class="s1">&quot;cedil&quot;</span><span class="s2">,</span><span class="s1">&quot;sup1&quot;</span><span class="s2">,</span><span class="s1">&quot;ordm&quot;</span><span class="s2">,</span><span class="s1">&quot;raquo&quot;</span><span class="s2">,</span><span class="s1">&quot;frac14&quot;</span><span class="s2">,</span><span class="s1">&quot;frac12&quot;</span><span class="s2">,</span><span class="s1">&quot;frac34&quot;</span><span class="s2">,</span><span class="s1">&quot;iquest&quot;</span><span class="s2">,</span><span class="s1">&quot;Agrave&quot;</span><span class="s2">,</span><span class="s1">&quot;Aacute&quot;</span><span class="s2">,</span><span class="s1">&quot;Acirc&quot;</span><span class="s2">,</span><span class="s1">&quot;Atilde&quot;</span><span class="s2">,</span><span class="s1">&quot;Auml&quot;</span><span class="s2">,</span><span class="s1">&quot;Aring&quot;</span><span class="s2">,</span><span class="s1">&quot;AElig&quot;</span><span class="s2">,</span><span class="s1">&quot;Ccedil&quot;</span><span class="s2">,</span><span class="s1">&quot;Egrave&quot;</span><span class="s2">,</span><span class="s1">&quot;Eacute&quot;</span><span class="s2">,</span><span class="s1">&quot;Ecirc&quot;</span><span class="s2">,</span><span class="s1">&quot;Euml&quot;</span><span class="s2">,</span><span class="s1">&quot;Igrave&quot;</span><span class="s2">,</span><span class="s1">&quot;Iacute&quot;</span><span class="s2">,</span><span class="s1">&quot;Icirc&quot;</span><span class="s2">,</span><span class="s1">&quot;Iuml&quot;</span><span class="s2">,</span><span class="s1">&quot;ETH&quot;</span><span class="s2">,</span><span class="s1">&quot;Ntilde&quot;</span><span class="s2">,</span><span class="s1">&quot;Ograve&quot;</span><span class="s2">,</span><span class="s1">&quot;Oacute&quot;</span><span class="s2">,</span><span class="s1">&quot;Ocirc&quot;</span><span class="s2">,</span><span class="s1">&quot;Otilde&quot;</span><span class="s2">,</span><span class="s1">&quot;Ouml&quot;</span><span class="s2">,</span><span class="s1">&quot;times&quot;</span><span class="s2">,</span><span class="s1">&quot;Oslash&quot;</span><span class="s2">,</span><span class="s1">&quot;Ugrave&quot;</span><span class="s2">,</span><span class="s1">&quot;Uacute&quot;</span><span class="s2">,</span><span class="s1">&quot;Ucirc&quot;</span><span class="s2">,</span><span class="s1">&quot;Uuml&quot;</span><span class="s2">,</span><span class="s1">&quot;Yacute&quot;</span><span class="s2">,</span><span class="s1">&quot;THORN&quot;</span><span class="s2">,</span><span class="s1">&quot;szlig&quot;</span><span class="s2">,</span><span class="s1">&quot;agrave&quot;</span><span class="s2">,</span><span class="s1">&quot;aacute&quot;</span><span class="s2">,</span><span class="s1">&quot;acirc&quot;</span><span class="s2">,</span><span class="s1">&quot;atilde&quot;</span><span class="s2">,</span><span class="s1">&quot;auml&quot;</span><span class="s2">,</span><span class="s1">&quot;aring&quot;</span><span class="s2">,</span><span class="s1">&quot;aelig&quot;</span><span class="s2">,</span><span class="s1">&quot;ccedil&quot;</span><span class="s2">,</span><span class="s1">&quot;egrave&quot;</span><span class="s2">,</span><span class="s1">&quot;eacute&quot;</span><span class="s2">,</span><span class="s1">&quot;ecirc&quot;</span><span class="s2">,</span><span class="s1">&quot;euml&quot;</span><span class="s2">,</span><span class="s1">&quot;igrave&quot;</span><span class="s2">,</span><span class="s1">&quot;iacute&quot;</span><span class="s2">,</span><span class="s1">&quot;icirc&quot;</span><span class="s2">,</span><span class="s1">&quot;iuml&quot;</span><span class="s2">,</span><span class="s1">&quot;eth&quot;</span><span class="s2">,</span><span class="s1">&quot;ntilde&quot;</span><span class="s2">,</span><span class="s1">&quot;ograve&quot;</span><span class="s2">,</span><span class="s1">&quot;oacute&quot;</span><span class="s2">,</span><span class="s1">&quot;ocirc&quot;</span><span class="s2">,</span><span class="s1">&quot;otilde&quot;</span><span class="s2">,</span><span class="s1">&quot;ouml&quot;</span><span class="s2">,</span><span class="s1">&quot;divide&quot;</span><span class="s2">,</span><span class="s1">&quot;oslash&quot;</span><span class="s2">,</span><span class="s1">&quot;ugrave&quot;</span><span class="s2">,</span><span class="s1">&quot;uacute&quot;</span><span class="s2">,</span><span class="s1">&quot;ucirc&quot;</span><span class="s2">,</span><span class="s1">&quot;uuml&quot;</span><span class="s2">,</span><span class="s1">&quot;yacute&quot;</span><span class="s2">,</span><span class="s1">&quot;thorn&quot;</span><span class="s2">,</span><span class="s1">&quot;yuml&quot;</span><span class="s2">,</span><span class="s1">&quot;OElig&quot;</span><span class="s2">,</span><span class="s1">&quot;oelig&quot;</span><span class="s2">,</span><span class="s1">&quot;Scaron&quot;</span><span class="s2">,</span><span class="s1">&quot;scaron&quot;</span><span class="s2">,</span><span class="s1">&quot;Yuml&quot;</span><span class="s2">,</span><span class="s1">&quot;fnof&quot;</span><span class="s2">,</span><span class="s1">&quot;circ&quot;</span><span class="s2">,</span><span class="s1">&quot;Alpha&quot;</span><span class="s2">,</span><span class="s1">&quot;Beta&quot;</span><span class="s2">,</span><span class="s1">&quot;Gamma&quot;</span><span class="s2">,</span><span class="s1">&quot;Delta&quot;</span><span class="s2">,</span><span class="s1">&quot;Epsilon&quot;</span><span class="s2">,</span><span class="s1">&quot;Zeta&quot;</span><span class="s2">,</span><span class="s1">&quot;Eta&quot;</span><span class="s2">,</span><span class="s1">&quot;Theta&quot;</span><span class="s2">,</span><span class="s1">&quot;Iota&quot;</span><span class="s2">,</span><span class="s1">&quot;Kappa&quot;</span><span class="s2">,</span><span class="s1">&quot;Lambda&quot;</span><span class="s2">,</span><span class="s1">&quot;Mu&quot;</span><span class="s2">,</span><span class="s1">&quot;Nu&quot;</span><span class="s2">,</span><span class="s1">&quot;Xi&quot;</span><span class="s2">,</span><span class="s1">&quot;Omicron&quot;</span><span class="s2">,</span><span class="s1">&quot;Pi&quot;</span><span class="s2">,</span><span class="s1">&quot;Rho&quot;</span><span class="s2">,</span><span class="s1">&quot;Sigma&quot;</span><span class="s2">,</span><span class="s1">&quot;Tau&quot;</span><span class="s2">,</span><span class="s1">&quot;Upsilon&quot;</span><span class="s2">,</span><span class="s1">&quot;Phi&quot;</span><span class="s2">,</span><span class="s1">&quot;Chi&quot;</span><span class="s2">,</span><span class="s1">&quot;Psi&quot;</span><span class="s2">,</span><span class="s1">&quot;Omega&quot;</span><span class="s2">,</span><span class="s1">&quot;alpha&quot;</span><span class="s2">,</span><span class="s1">&quot;beta&quot;</span><span class="s2">,</span><span class="s1">&quot;gamma&quot;</span><span class="s2">,</span><span class="s1">&quot;delta&quot;</span><span class="s2">,</span><span class="s1">&quot;epsilon&quot;</span><span class="s2">,</span><span class="s1">&quot;zeta&quot;</span><span class="s2">,</span><span class="s1">&quot;eta&quot;</span><span class="s2">,</span><span class="s1">&quot;theta&quot;</span><span class="s2">,</span><span class="s1">&quot;iota&quot;</span><span class="s2">,</span><span class="s1">&quot;kappa&quot;</span><span class="s2">,</span><span class="s1">&quot;lambda&quot;</span><span class="s2">,</span><span class="s1">&quot;mu&quot;</span><span class="s2">,</span><span class="s1">&quot;nu&quot;</span><span class="s2">,</span><span class="s1">&quot;xi&quot;</span><span class="s2">,</span><span class="s1">&quot;omicron&quot;</span><span class="s2">,</span><span class="s1">&quot;pi&quot;</span><span class="s2">,</span><span class="s1">&quot;rho&quot;</span><span class="s2">,</span><span class="s1">&quot;sigmaf&quot;</span><span class="s2">,</span><span class="s1">&quot;sigma&quot;</span><span class="s2">,</span><span class="s1">&quot;tau&quot;</span><span class="s2">,</span><span class="s1">&quot;upsilon&quot;</span><span class="s2">,</span><span class="s1">&quot;phi&quot;</span><span class="s2">,</span><span class="s1">&quot;chi&quot;</span><span class="s2">,</span><span class="s1">&quot;psi&quot;</span><span class="s2">,</span><span class="s1">&quot;omega&quot;</span><span class="s2">,</span><span class="s1">&quot;thetasym&quot;</span><span class="s2">,</span><span class="s1">&quot;upsih&quot;</span><span class="s2">,</span><span class="s1">&quot;piv&quot;</span><span class="s2">,</span><span class="s1">&quot;ensp&quot;</span><span class="s2">,</span><span class="s1">&quot;emsp&quot;</span><span class="s2">,</span><span class="s1">&quot;thinsp&quot;</span><span class="s2">,</span><span class="s1">&quot;zwnj&quot;</span><span class="s2">,</span><span class="s1">&quot;zwj&quot;</span><span class="s2">,</span><span class="s1">&quot;lrm&quot;</span><span class="s2">,</span><span class="s1">&quot;rlm&quot;</span><span class="s2">,</span><span class="s1">&quot;ndash&quot;</span><span class="s2">,</span><span class="s1">&quot;mdash&quot;</span><span class="s2">,</span><span class="s1">&quot;lsquo&quot;</span><span class="s2">,</span><span class="s1">&quot;rsquo&quot;</span><span class="s2">,</span><span class="s1">&quot;sbquo&quot;</span><span class="s2">,</span><span class="s1">&quot;ldquo&quot;</span><span class="s2">,</span><span class="s1">&quot;rdquo&quot;</span><span class="s2">,</span><span class="s1">&quot;bdquo&quot;</span><span class="s2">,</span><span class="s1">&quot;dagger&quot;</span><span class="s2">,</span><span class="s1">&quot;Dagger&quot;</span><span class="s2">,</span><span class="s1">&quot;bull&quot;</span><span class="s2">,</span><span class="s1">&quot;hellip&quot;</span><span class="s2">,</span><span class="s1">&quot;permil&quot;</span><span class="s2">,</span><span class="s1">&quot;prime&quot;</span><span class="s2">,</span><span class="s1">&quot;Prime&quot;</span><span class="s2">,</span><span class="s1">&quot;lsaquo&quot;</span><span class="s2">,</span><span class="s1">&quot;rsaquo&quot;</span><span class="s2">,</span><span class="s1">&quot;oline&quot;</span><span class="s2">,</span><span class="s1">&quot;frasl&quot;</span><span class="s2">,</span><span class="s1">&quot;euro&quot;</span><span class="s2">,</span><span class="s1">&quot;image&quot;</span><span class="s2">,</span><span class="s1">&quot;weierp&quot;</span><span class="s2">,</span><span class="s1">&quot;real&quot;</span><span class="s2">,</span><span class="s1">&quot;trade&quot;</span><span class="s2">,</span><span class="s1">&quot;alefsym&quot;</span><span class="s2">,</span><span class="s1">&quot;larr&quot;</span><span class="s2">,</span><span class="s1">&quot;uarr&quot;</span><span class="s2">,</span><span class="s1">&quot;rarr&quot;</span><span class="s2">,</span><span class="s1">&quot;darr&quot;</span><span class="s2">,</span><span class="s1">&quot;harr&quot;</span><span class="s2">,</span><span class="s1">&quot;crarr&quot;</span><span class="s2">,</span><span class="s1">&quot;lArr&quot;</span><span class="s2">,</span><span class="s1">&quot;uArr&quot;</span><span class="s2">,</span><span class="s1">&quot;rArr&quot;</span><span class="s2">,</span><span class="s1">&quot;dArr&quot;</span><span class="s2">,</span><span class="s1">&quot;hArr&quot;</span><span class="s2">,</span><span class="s1">&quot;forall&quot;</span><span class="s2">,</span><span class="s1">&quot;part&quot;</span><span class="s2">,</span><span class="s1">&quot;exist&quot;</span><span class="s2">,</span><span class="s1">&quot;nabla&quot;</span><span class="s2">,</span><span class="s1">&quot;isin&quot;</span><span class="s2">,</span><span class="s1">&quot;notin&quot;</span><span class="s2">,</span><span class="s1">&quot;ni&quot;</span><span class="s2">,</span><span class="s1">&quot;prod&quot;</span><span class="s2">,</span><span class="s1">&quot;sum&quot;</span><span class="s2">,</span><span class="s1">&quot;minus&quot;</span><span class="s2">,</span><span class="s1">&quot;lowast&quot;</span><span class="s2">,</span><span class="s1">&quot;radic&quot;</span><span class="s2">,</span><span class="s1">&quot;infin&quot;</span><span class="s2">,</span><span class="s1">&quot;ang&quot;</span><span class="s2">,</span><span class="s1">&quot;and&quot;</span><span class="s2">,</span><span class="s1">&quot;or&quot;</span><span class="s2">,</span><span class="s1">&quot;cap&quot;</span><span class="s2">,</span><span class="s1">&quot;cup&quot;</span><span class="s2">,</span><span class="s1">&quot;int&quot;</span><span class="s2">,</span><span class="s1">&quot;there4&quot;</span><span class="s2">,</span><span class="s1">&quot;sim&quot;</span><span class="s2">,</span><span class="s1">&quot;cong&quot;</span><span class="s2">,</span><span class="s1">&quot;asymp&quot;</span><span class="s2">,</span><span class="s1">&quot;ne&quot;</span><span class="s2">,</span><span class="s1">&quot;equiv&quot;</span><span class="s2">,</span><span class="s1">&quot;le&quot;</span><span class="s2">,</span><span class="s1">&quot;ge&quot;</span><span class="s2">,</span><span class="s1">&quot;sub&quot;</span><span class="s2">,</span><span class="s1">&quot;sup&quot;</span><span class="s2">,</span><span class="s1">&quot;nsub&quot;</span><span class="s2">,</span><span class="s1">&quot;sube&quot;</span><span class="s2">,</span><span class="s1">&quot;supe&quot;</span><span class="s2">,</span><span class="s1">&quot;oplus&quot;</span><span class="s2">,</span><span class="s1">&quot;otimes&quot;</span><span class="s2">,</span><span class="s1">&quot;perp&quot;</span><span class="s2">,</span><span class="s1">&quot;sdot&quot;</span><span class="s2">,</span><span class="s1">&quot;lceil&quot;</span><span class="s2">,</span><span class="s1">&quot;rceil&quot;</span><span class="s2">,</span><span class="s1">&quot;lfloor&quot;</span><span class="s2">,</span><span class="s1">&quot;rfloor&quot;</span><span class="s2">,</span><span class="s1">&quot;lang&quot;</span><span class="s2">,</span><span class="s1">&quot;rang&quot;</span><span class="s2">,</span><span class="s1">&quot;loz&quot;</span><span class="s2">,</span><span class="s1">&quot;spades&quot;</span><span class="s2">,</span><span class="s1">&quot;clubs&quot;</span><span class="s2">,</span><span class="s1">&quot;hearts&quot;</span><span class="s2">,</span><span class="s1">&quot;diams&quot;</span><span class="s2">,</span><span class="s1">&quot;JsxErrors&quot;</span><span class="s2">,</span><span class="s1">&quot;AttributeIsEmpty&quot;</span><span class="s2">,</span><span class="s1">&quot;MissingClosingTagElement&quot;</span><span class="s2">,</span><span class="s1">&quot;openingTagName&quot;</span><span class="s2">,</span><span class="s1">&quot;MissingClosingTagFragment&quot;</span><span class="s2">,</span><span class="s1">&quot;UnexpectedSequenceExpression&quot;</span><span class="s2">,</span><span class="s1">&quot;HTMLEntity&quot;</span><span class="s2">,</span><span class="s1">&quot;UnsupportedJsxValue&quot;</span><span class="s2">,</span><span class="s1">&quot;UnterminatedJsxContent&quot;</span><span class="s2">,</span><span class="s1">&quot;UnwrappedAdjacentJSXElements&quot;</span><span class="s2">,</span><span class="s1">&quot;isFragment&quot;</span><span class="s2">,</span><span class="s1">&quot;getQualifiedJSXName&quot;</span><span class="s2">,</span><span class="s1">&quot;namespace&quot;</span><span class="s2">,</span><span class="s1">&quot;JSXParserMixin&quot;</span><span class="s2">,</span><span class="s1">&quot;jsxReadToken&quot;</span><span class="s2">,</span><span class="s1">&quot;jsxReadEntity&quot;</span><span class="s2">,</span><span class="s1">&quot;jsxReadNewLine&quot;</span><span class="s2">,</span><span class="s1">&quot;normalizeCRLF&quot;</span><span class="s2">,</span><span class="s1">&quot;jsxReadString&quot;</span><span class="s2">,</span><span class="s1">&quot;codePoint&quot;</span><span class="s2">,</span><span class="s1">&quot;count&quot;</span><span class="s2">,</span><span class="s1">&quot;desc&quot;</span><span class="s2">,</span><span class="s1">&quot;entity&quot;</span><span class="s2">,</span><span class="s1">&quot;XHTMLEntities&quot;</span><span class="s2">,</span><span class="s1">&quot;jsxReadWord&quot;</span><span class="s2">,</span><span class="s1">&quot;jsxParseIdentifier&quot;</span><span class="s2">,</span><span class="s1">&quot;jsxParseNamespacedName&quot;</span><span class="s2">,</span><span class="s1">&quot;jsxParseElementName&quot;</span><span class="s2">,</span><span class="s1">&quot;jsxParseAttributeValue&quot;</span><span class="s2">,</span><span class="s1">&quot;setContext&quot;</span><span class="s2">,</span><span class="s1">&quot;jsxParseExpressionContainer&quot;</span><span class="s2">,</span><span class="s1">&quot;jsxParseEmptyExpression&quot;</span><span class="s2">,</span><span class="s1">&quot;jsxParseSpreadChild&quot;</span><span class="s2">,</span><span class="s1">&quot;previousContext&quot;</span><span class="s2">,</span><span class="s1">&quot;jsxParseAttribute&quot;</span><span class="s2">,</span><span class="s1">&quot;jsxParseOpeningElementAt&quot;</span><span class="s2">,</span><span class="s1">&quot;jsxParseOpeningElementAfterName&quot;</span><span class="s2">,</span><span class="s1">&quot;selfClosing&quot;</span><span class="s2">,</span><span class="s1">&quot;jsxParseClosingElementAt&quot;</span><span class="s2">,</span><span class="s1">&quot;jsxParseElementAt&quot;</span><span class="s2">,</span><span class="s1">&quot;children&quot;</span><span class="s2">,</span><span class="s1">&quot;openingElement&quot;</span><span class="s2">,</span><span class="s1">&quot;closingElement&quot;</span><span class="s2">,</span><span class="s1">&quot;contents&quot;</span><span class="s2">,</span><span class="s1">&quot;openingFragment&quot;</span><span class="s2">,</span><span class="s1">&quot;closingFragment&quot;</span><span class="s2">,</span><span class="s1">&quot;jsxParseElement&quot;</span><span class="s2">,</span><span class="s1">&quot;newContext&quot;</span><span class="s2">,</span><span class="s1">&quot;TypeScriptScope&quot;</span><span class="s2">,</span><span class="s1">&quot;enums&quot;</span><span class="s2">,</span><span class="s1">&quot;constEnums&quot;</span><span class="s2">,</span><span class="s1">&quot;classes&quot;</span><span class="s2">,</span><span class="s1">&quot;exportOnlyBindings&quot;</span><span class="s2">,</span><span class="s1">&quot;TypeScriptScopeHandler&quot;</span><span class="s2">,</span><span class="s1">&quot;importsStack&quot;</span><span class="s2">,</span><span class="s1">&quot;hasImport&quot;</span><span class="s2">,</span><span class="s1">&quot;allowShadow&quot;</span><span class="s2">,</span><span class="s1">&quot;isConst&quot;</span><span class="s2">,</span><span class="s1">&quot;wasConst&quot;</span><span class="s2">,</span><span class="s1">&quot;getOwn&quot;</span><span class="s2">,</span><span class="s1">&quot;hasOwnProperty&quot;</span><span class="s2">,</span><span class="s1">&quot;unwrapParenthesizedExpression&quot;</span><span class="s2">,</span><span class="s1">&quot;LValParser&quot;</span><span class="s2">,</span><span class="s1">&quot;_node$extra3&quot;</span><span class="s2">,</span><span class="s1">&quot;_node$extra2&quot;</span><span class="s2">,</span><span class="s1">&quot;operator&quot;</span><span class="s2">,</span><span class="s1">&quot;arg&quot;</span><span class="s2">,</span><span class="s1">&quot;checkToRestConversion&quot;</span><span class="s2">,</span><span class="s1">&quot;elt&quot;</span><span class="s2">,</span><span class="s1">&quot;element&quot;</span><span class="s2">,</span><span class="s1">&quot;toReferencedListDeep&quot;</span><span class="s2">,</span><span class="s1">&quot;parseSpread&quot;</span><span class="s2">,</span><span class="s1">&quot;parseRestBinding&quot;</span><span class="s2">,</span><span class="s1">&quot;parseBindingList&quot;</span><span class="s2">,</span><span class="s1">&quot;ParseBindingListFlags&quot;</span><span class="s2">,</span><span class="s1">&quot;parseObjectLike&quot;</span><span class="s2">,</span><span class="s1">&quot;closeCharCode&quot;</span><span class="s2">,</span><span class="s1">&quot;allowEmpty&quot;</span><span class="s2">,</span><span class="s1">&quot;elts&quot;</span><span class="s2">,</span><span class="s1">&quot;checkCommaAfterRest&quot;</span><span class="s2">,</span><span class="s1">&quot;parseDecorator&quot;</span><span class="s2">,</span><span class="s1">&quot;parseAssignableListItem&quot;</span><span class="s2">,</span><span class="s1">&quot;parseBindingRestProperty&quot;</span><span class="s2">,</span><span class="s1">&quot;parseBindingProperty&quot;</span><span class="s2">,</span><span class="s1">&quot;parsePropertyName&quot;</span><span class="s2">,</span><span class="s1">&quot;_left&quot;</span><span class="s2">,</span><span class="s1">&quot;ObjectProperty&quot;</span><span class="s2">,</span><span class="s1">&quot;checkLVal&quot;</span><span class="s2">,</span><span class="s1">&quot;in&quot;</span><span class="s2">,</span><span class="s1">&quot;checkClashes&quot;</span><span class="s2">,</span><span class="s1">&quot;hasParenthesizedAncestor&quot;</span><span class="s2">,</span><span class="s1">&quot;_expression$extra&quot;</span><span class="s2">,</span><span class="s1">&quot;checkIdentifier&quot;</span><span class="s2">,</span><span class="s1">&quot;validity&quot;</span><span class="s2">,</span><span class="s1">&quot;ParseErrorClass&quot;</span><span class="s2">,</span><span class="s1">&quot;isParenthesizedExpression&quot;</span><span class="s2">,</span><span class="s1">&quot;nextAncestor&quot;</span><span class="s2">,</span><span class="s1">&quot;child&quot;</span><span class="s2">,</span><span class="s1">&quot;declareNameFromIdentifier&quot;</span><span class="s2">,</span><span class="s1">&quot;identifier&quot;</span><span class="s2">,</span><span class="s1">&quot;allowPattern&quot;</span><span class="s2">,</span><span class="s1">&quot;nonNull&quot;</span><span class="s2">,</span><span class="s1">&quot;x&quot;</span><span class="s2">,</span><span class="s1">&quot;assert&quot;</span><span class="s2">,</span><span class="s1">&quot;TSErrors&quot;</span><span class="s2">,</span><span class="s1">&quot;AbstractMethodHasImplementation&quot;</span><span class="s2">,</span><span class="s1">&quot;methodName&quot;</span><span class="s2">,</span><span class="s1">&quot;AbstractPropertyHasInitializer&quot;</span><span class="s2">,</span><span class="s1">&quot;propertyName&quot;</span><span class="s2">,</span><span class="s1">&quot;AccesorCannotDeclareThisParameter&quot;</span><span class="s2">,</span><span class="s1">&quot;AccesorCannotHaveTypeParameters&quot;</span><span class="s2">,</span><span class="s1">&quot;AccessorCannotBeOptional&quot;</span><span class="s2">,</span><span class="s1">&quot;ClassMethodHasDeclare&quot;</span><span class="s2">,</span><span class="s1">&quot;ClassMethodHasReadonly&quot;</span><span class="s2">,</span><span class="s1">&quot;ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference&quot;</span><span class="s2">,</span><span class="s1">&quot;ConstructorHasTypeParameters&quot;</span><span class="s2">,</span><span class="s1">&quot;DeclareAccessor&quot;</span><span class="s2">,</span><span class="s1">&quot;DeclareClassFieldHasInitializer&quot;</span><span class="s2">,</span><span class="s1">&quot;DeclareFunctionHasImplementation&quot;</span><span class="s2">,</span><span class="s1">&quot;DuplicateAccessibilityModifier&quot;</span><span class="s2">,</span><span class="s1">&quot;modifier&quot;</span><span class="s2">,</span><span class="s1">&quot;DuplicateModifier&quot;</span><span class="s2">,</span><span class="s1">&quot;EmptyHeritageClauseType&quot;</span><span class="s2">,</span><span class="s1">&quot;EmptyTypeArguments&quot;</span><span class="s2">,</span><span class="s1">&quot;EmptyTypeParameters&quot;</span><span class="s2">,</span><span class="s1">&quot;ExpectedAmbientAfterExportDeclare&quot;</span><span class="s2">,</span><span class="s1">&quot;ImportAliasHasImportType&quot;</span><span class="s2">,</span><span class="s1">&quot;IncompatibleModifiers&quot;</span><span class="s2">,</span><span class="s1">&quot;modifiers&quot;</span><span class="s2">,</span><span class="s1">&quot;IndexSignatureHasAbstract&quot;</span><span class="s2">,</span><span class="s1">&quot;IndexSignatureHasAccessibility&quot;</span><span class="s2">,</span><span class="s1">&quot;IndexSignatureHasDeclare&quot;</span><span class="s2">,</span><span class="s1">&quot;IndexSignatureHasOverride&quot;</span><span class="s2">,</span><span class="s1">&quot;IndexSignatureHasStatic&quot;</span><span class="s2">,</span><span class="s1">&quot;InitializerNotAllowedInAmbientContext&quot;</span><span class="s2">,</span><span class="s1">&quot;InvalidModifierOnTypeMember&quot;</span><span class="s2">,</span><span class="s1">&quot;InvalidModifierOnTypeParameter&quot;</span><span class="s2">,</span><span class="s1">&quot;InvalidModifierOnTypeParameterPositions&quot;</span><span class="s2">,</span><span class="s1">&quot;InvalidModifiersOrder&quot;</span><span class="s2">,</span><span class="s1">&quot;orderedModifiers&quot;</span><span class="s2">,</span><span class="s1">&quot;InvalidPropertyAccessAfterInstantiationExpression&quot;</span><span class="s2">,</span><span class="s1">&quot;InvalidTupleMemberLabel&quot;</span><span class="s2">,</span><span class="s1">&quot;MissingInterfaceName&quot;</span><span class="s2">,</span><span class="s1">&quot;MixedLabeledAndUnlabeledElements&quot;</span><span class="s2">,</span><span class="s1">&quot;NonAbstractClassHasAbstractMethod&quot;</span><span class="s2">,</span><span class="s1">&quot;NonClassMethodPropertyHasAbstractModifer&quot;</span><span class="s2">,</span><span class="s1">&quot;OptionalTypeBeforeRequired&quot;</span><span class="s2">,</span><span class="s1">&quot;OverrideNotInSubClass&quot;</span><span class="s2">,</span><span class="s1">&quot;PrivateElementHasAbstract&quot;</span><span class="s2">,</span><span class="s1">&quot;PrivateElementHasAccessibility&quot;</span><span class="s2">,</span><span class="s1">&quot;ReadonlyForMethodSignature&quot;</span><span class="s2">,</span><span class="s1">&quot;ReservedArrowTypeParam&quot;</span><span class="s2">,</span><span class="s1">&quot;ReservedTypeAssertion&quot;</span><span class="s2">,</span><span class="s1">&quot;SetAccesorCannotHaveOptionalParameter&quot;</span><span class="s2">,</span><span class="s1">&quot;SetAccesorCannotHaveRestParameter&quot;</span><span class="s2">,</span><span class="s1">&quot;SetAccesorCannotHaveReturnType&quot;</span><span class="s2">,</span><span class="s1">&quot;SingleTypeParameterWithoutTrailingComma&quot;</span><span class="s2">,</span><span class="s1">&quot;typeParameterName&quot;</span><span class="s2">,</span><span class="s1">&quot;StaticBlockCannotHaveModifier&quot;</span><span class="s2">,</span><span class="s1">&quot;TupleOptionalAfterType&quot;</span><span class="s2">,</span><span class="s1">&quot;TypeAnnotationAfterAssign&quot;</span><span class="s2">,</span><span class="s1">&quot;TypeImportCannotSpecifyDefaultAndNamed&quot;</span><span class="s2">,</span><span class="s1">&quot;TypeModifierIsUsedInTypeExports&quot;</span><span class="s2">,</span><span class="s1">&quot;TypeModifierIsUsedInTypeImports&quot;</span><span class="s2">,</span><span class="s1">&quot;UnexpectedParameterModifier&quot;</span><span class="s2">,</span><span class="s1">&quot;UnexpectedReadonly&quot;</span><span class="s2">,</span><span class="s1">&quot;UnexpectedTypeAnnotation&quot;</span><span class="s2">,</span><span class="s1">&quot;UnexpectedTypeCastInParameter&quot;</span><span class="s2">,</span><span class="s1">&quot;UnsupportedImportTypeArgument&quot;</span><span class="s2">,</span><span class="s1">&quot;UnsupportedParameterPropertyKind&quot;</span><span class="s2">,</span><span class="s1">&quot;UnsupportedSignatureParameterKind&quot;</span><span class="s2">,</span><span class="s1">&quot;keywordTypeFromName&quot;</span><span class="s2">,</span><span class="s1">&quot;tsIsAccessModifier&quot;</span><span class="s2">,</span><span class="s1">&quot;tsIsVarianceAnnotations&quot;</span><span class="s2">,</span><span class="s1">&quot;typescript&quot;</span><span class="s2">,</span><span class="s1">&quot;TypeScriptParserMixin&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseInOutModifiers&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseModifiers&quot;</span><span class="s2">,</span><span class="s1">&quot;bind&quot;</span><span class="s2">,</span><span class="s1">&quot;allowedModifiers&quot;</span><span class="s2">,</span><span class="s1">&quot;disallowedModifiers&quot;</span><span class="s2">,</span><span class="s1">&quot;errorTemplate&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseConstModifier&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseInOutConstModifiers&quot;</span><span class="s2">,</span><span class="s1">&quot;tsIsIdentifier&quot;</span><span class="s2">,</span><span class="s1">&quot;tsTokenCanFollowModifier&quot;</span><span class="s2">,</span><span class="s1">&quot;tsNextTokenCanFollowModifier&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseModifier&quot;</span><span class="s2">,</span><span class="s1">&quot;stopOnStartOfClassStaticBlock&quot;</span><span class="s2">,</span><span class="s1">&quot;tsIsStartOfStaticBlocks&quot;</span><span class="s2">,</span><span class="s1">&quot;tsTryParse&quot;</span><span class="s2">,</span><span class="s1">&quot;modified&quot;</span><span class="s2">,</span><span class="s1">&quot;enforceOrder&quot;</span><span class="s2">,</span><span class="s1">&quot;before&quot;</span><span class="s2">,</span><span class="s1">&quot;after&quot;</span><span class="s2">,</span><span class="s1">&quot;incompatible&quot;</span><span class="s2">,</span><span class="s1">&quot;mod1&quot;</span><span class="s2">,</span><span class="s1">&quot;mod2&quot;</span><span class="s2">,</span><span class="s1">&quot;accessibility&quot;</span><span class="s2">,</span><span class="s1">&quot;tsIsListTerminator&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseList&quot;</span><span class="s2">,</span><span class="s1">&quot;parseElement&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseDelimitedList&quot;</span><span class="s2">,</span><span class="s1">&quot;refTrailingCommaPos&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseDelimitedListWorker&quot;</span><span class="s2">,</span><span class="s1">&quot;expectSuccess&quot;</span><span class="s2">,</span><span class="s1">&quot;trailingCommaPos&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseBracketedList&quot;</span><span class="s2">,</span><span class="s1">&quot;bracket&quot;</span><span class="s2">,</span><span class="s1">&quot;skipFirstToken&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseImportType&quot;</span><span class="s2">,</span><span class="s1">&quot;qualifier&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseEntityName&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseTypeArguments&quot;</span><span class="s2">,</span><span class="s1">&quot;allowReservedWords&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseTypeReference&quot;</span><span class="s2">,</span><span class="s1">&quot;typeName&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseThisTypePredicate&quot;</span><span class="s2">,</span><span class="s1">&quot;lhs&quot;</span><span class="s2">,</span><span class="s1">&quot;parameterName&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseTypeAnnotation&quot;</span><span class="s2">,</span><span class="s1">&quot;asserts&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseThisTypeNode&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseTypeQuery&quot;</span><span class="s2">,</span><span class="s1">&quot;exprName&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseTypeParameter&quot;</span><span class="s2">,</span><span class="s1">&quot;parseModifiers&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseTypeParameterName&quot;</span><span class="s2">,</span><span class="s1">&quot;constraint&quot;</span><span class="s2">,</span><span class="s1">&quot;tsEatThenParseType&quot;</span><span class="s2">,</span><span class="s1">&quot;tsTryParseTypeParameters&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseTypeParameters&quot;</span><span class="s2">,</span><span class="s1">&quot;tsFillSignature&quot;</span><span class="s2">,</span><span class="s1">&quot;returnToken&quot;</span><span class="s2">,</span><span class="s1">&quot;signature&quot;</span><span class="s2">,</span><span class="s1">&quot;returnTokenRequired&quot;</span><span class="s2">,</span><span class="s1">&quot;paramsKey&quot;</span><span class="s2">,</span><span class="s1">&quot;returnTypeKey&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseBindingListForSignature&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseTypeOrTypePredicateAnnotation&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseTypeMemberSemicolon&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseSignatureMember&quot;</span><span class="s2">,</span><span class="s1">&quot;tsIsUnambiguouslyIndexSignature&quot;</span><span class="s2">,</span><span class="s1">&quot;tsTryParseIndexSignature&quot;</span><span class="s2">,</span><span class="s1">&quot;tsLookAhead&quot;</span><span class="s2">,</span><span class="s1">&quot;parameters&quot;</span><span class="s2">,</span><span class="s1">&quot;tsTryParseTypeAnnotation&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParsePropertyOrMethodSignature&quot;</span><span class="s2">,</span><span class="s1">&quot;readonly&quot;</span><span class="s2">,</span><span class="s1">&quot;nodeAny&quot;</span><span class="s2">,</span><span class="s1">&quot;firstParameter&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseTypeMember&quot;</span><span class="s2">,</span><span class="s1">&quot;idx&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseTypeLiteral&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseObjectTypeMembers&quot;</span><span class="s2">,</span><span class="s1">&quot;tsIsStartOfMappedType&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseMappedTypeParameter&quot;</span><span class="s2">,</span><span class="s1">&quot;tsExpectThenParseType&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseMappedType&quot;</span><span class="s2">,</span><span class="s1">&quot;nameType&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseType&quot;</span><span class="s2">,</span><span class="s1">&quot;tsTryParseType&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseTupleType&quot;</span><span class="s2">,</span><span class="s1">&quot;elementTypes&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseTupleElementType&quot;</span><span class="s2">,</span><span class="s1">&quot;seenOptionalElement&quot;</span><span class="s2">,</span><span class="s1">&quot;labeledElements&quot;</span><span class="s2">,</span><span class="s1">&quot;elementNode&quot;</span><span class="s2">,</span><span class="s1">&quot;_labeledElements&quot;</span><span class="s2">,</span><span class="s1">&quot;checkType&quot;</span><span class="s2">,</span><span class="s1">&quot;isLabeled&quot;</span><span class="s2">,</span><span class="s1">&quot;labeled&quot;</span><span class="s2">,</span><span class="s1">&quot;isWord&quot;</span><span class="s2">,</span><span class="s1">&quot;chAfterWord&quot;</span><span class="s2">,</span><span class="s1">&quot;wordName&quot;</span><span class="s2">,</span><span class="s1">&quot;typeOrLabel&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseNonArrayType&quot;</span><span class="s2">,</span><span class="s1">&quot;labeledNode&quot;</span><span class="s2">,</span><span class="s1">&quot;optionalTypeNode&quot;</span><span class="s2">,</span><span class="s1">&quot;restNode&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseParenthesizedType&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseFunctionOrConstructorType&quot;</span><span class="s2">,</span><span class="s1">&quot;abstract&quot;</span><span class="s2">,</span><span class="s1">&quot;tsInAllowConditionalTypesContext&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseLiteralTypeNode&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseTemplateLiteralType&quot;</span><span class="s2">,</span><span class="s1">&quot;parseTemplate&quot;</span><span class="s2">,</span><span class="s1">&quot;parseTemplateSubstitution&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseThisTypeOrThisTypePredicate&quot;</span><span class="s2">,</span><span class="s1">&quot;thisKeyword&quot;</span><span class="s2">,</span><span class="s1">&quot;parseMaybeUnary&quot;</span><span class="s2">,</span><span class="s1">&quot;nodeType&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseArrayTypeOrHigher&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseTypeOperator&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseTypeOperatorOrHigher&quot;</span><span class="s2">,</span><span class="s1">&quot;tsCheckTypeAnnotationForReadOnly&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseInferType&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseConstraintForInferType&quot;</span><span class="s2">,</span><span class="s1">&quot;tsInDisallowConditionalTypesContext&quot;</span><span class="s2">,</span><span class="s1">&quot;isTypeOperator&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseUnionOrIntersectionType&quot;</span><span class="s2">,</span><span class="s1">&quot;parseConstituentType&quot;</span><span class="s2">,</span><span class="s1">&quot;hasLeadingOperator&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseIntersectionTypeOrHigher&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseUnionTypeOrHigher&quot;</span><span class="s2">,</span><span class="s1">&quot;tsIsStartOfFunctionType&quot;</span><span class="s2">,</span><span class="s1">&quot;tsIsUnambiguouslyStartOfFunctionType&quot;</span><span class="s2">,</span><span class="s1">&quot;tsSkipParameterStart&quot;</span><span class="s2">,</span><span class="s1">&quot;previousErrorCount&quot;</span><span class="s2">,</span><span class="s1">&quot;_unused2&quot;</span><span class="s2">,</span><span class="s1">&quot;tsInType&quot;</span><span class="s2">,</span><span class="s1">&quot;t&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseTypePredicateAsserts&quot;</span><span class="s2">,</span><span class="s1">&quot;thisTypePredicate&quot;</span><span class="s2">,</span><span class="s1">&quot;typePredicateVariable&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseTypePredicatePrefix&quot;</span><span class="s2">,</span><span class="s1">&quot;tsTryParseTypeOrTypePredicateAnnotation&quot;</span><span class="s2">,</span><span class="s1">&quot;eatColon&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseNonConditionalType&quot;</span><span class="s2">,</span><span class="s1">&quot;extendsType&quot;</span><span class="s2">,</span><span class="s1">&quot;trueType&quot;</span><span class="s2">,</span><span class="s1">&quot;falseType&quot;</span><span class="s2">,</span><span class="s1">&quot;isAbstractConstructorSignature&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseTypeAssertion&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseHeritageClause&quot;</span><span class="s2">,</span><span class="s1">&quot;originalStartLoc&quot;</span><span class="s2">,</span><span class="s1">&quot;delimitedList&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseInterfaceDeclaration&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseTypeAliasDeclaration&quot;</span><span class="s2">,</span><span class="s1">&quot;tsInNoContext&quot;</span><span class="s2">,</span><span class="s1">&quot;cb&quot;</span><span class="s2">,</span><span class="s1">&quot;oldContext&quot;</span><span class="s2">,</span><span class="s1">&quot;oldInDisallowConditionalTypesContext&quot;</span><span class="s2">,</span><span class="s1">&quot;tsNextThenParseType&quot;</span><span class="s2">,</span><span class="s1">&quot;tsDoThenParseType&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseEnumMember&quot;</span><span class="s2">,</span><span class="s1">&quot;initializer&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseEnumDeclaration&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseModuleBlock&quot;</span><span class="s2">,</span><span class="s1">&quot;parseBlockOrModuleBlockBody&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseModuleOrNamespaceDeclaration&quot;</span><span class="s2">,</span><span class="s1">&quot;nested&quot;</span><span class="s2">,</span><span class="s1">&quot;inner&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseAmbientExternalModuleDeclaration&quot;</span><span class="s2">,</span><span class="s1">&quot;global&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseImportEqualsDeclaration&quot;</span><span class="s2">,</span><span class="s1">&quot;isExport&quot;</span><span class="s2">,</span><span class="s1">&quot;moduleReference&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseModuleReference&quot;</span><span class="s2">,</span><span class="s1">&quot;tsIsExternalModuleReference&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseExternalModuleReference&quot;</span><span class="s2">,</span><span class="s1">&quot;f&quot;</span><span class="s2">,</span><span class="s1">&quot;tsTryParseAndCatch&quot;</span><span class="s2">,</span><span class="s1">&quot;tsTryParseDeclare&quot;</span><span class="s2">,</span><span class="s1">&quot;nany&quot;</span><span class="s2">,</span><span class="s1">&quot;starttype&quot;</span><span class="s2">,</span><span class="s1">&quot;tsInAmbientContext&quot;</span><span class="s2">,</span><span class="s1">&quot;parseFunctionStatement&quot;</span><span class="s2">,</span><span class="s1">&quot;parseClass&quot;</span><span class="s2">,</span><span class="s1">&quot;parseVarStatement&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseDeclaration&quot;</span><span class="s2">,</span><span class="s1">&quot;tsTryParseExportDeclaration&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseExpressionStatement&quot;</span><span class="s2">,</span><span class="s1">&quot;mod&quot;</span><span class="s2">,</span><span class="s1">&quot;tsCheckLineTerminator&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseAbstractDeclaration&quot;</span><span class="s2">,</span><span class="s1">&quot;tsTryParseGenericAsyncArrowFunction&quot;</span><span class="s2">,</span><span class="s1">&quot;oldMaybeInArrowParameters&quot;</span><span class="s2">,</span><span class="s1">&quot;tsParseTypeArgumentsInExpression&quot;</span><span class="s2">,</span><span class="s1">&quot;reScan_lt&quot;</span><span class="s2">,</span><span class="s1">&quot;tsIsDeclarationStart&quot;</span><span class="s2">,</span><span class="s1">&quot;override&quot;</span><span class="s2">,</span><span class="s1">&quot;pp&quot;</span><span class="s2">,</span><span class="s1">&quot;parameter&quot;</span><span class="s2">,</span><span class="s1">&quot;isSimpleParameter&quot;</span><span class="s2">,</span><span class="s1">&quot;tsDisallowOptionalPattern&quot;</span><span class="s2">,</span><span class="s1">&quot;bodilessType&quot;</span><span class="s2">,</span><span class="s1">&quot;registerFunctionStatementId&quot;</span><span class="s2">,</span><span class="s1">&quot;tsCheckForInvalidTypeCasts&quot;</span><span class="s2">,</span><span class="s1">&quot;items&quot;</span><span class="s2">,</span><span class="s1">&quot;isInParens&quot;</span><span class="s2">,</span><span class="s1">&quot;nonNullExpression&quot;</span><span class="s2">,</span><span class="s1">&quot;isOptionalCall&quot;</span><span class="s2">,</span><span class="s1">&quot;missingParenErrorLoc&quot;</span><span class="s2">,</span><span class="s1">&quot;atPossibleAsyncArrow&quot;</span><span class="s2">,</span><span class="s1">&quot;asyncArrowFn&quot;</span><span class="s2">,</span><span class="s1">&quot;parseTaggedTemplateExpression&quot;</span><span class="s2">,</span><span class="s1">&quot;tokenType&quot;</span><span class="s2">,</span><span class="s1">&quot;_callee$extra&quot;</span><span class="s2">,</span><span class="s1">&quot;parseExprOp&quot;</span><span class="s2">,</span><span class="s1">&quot;leftStartLoc&quot;</span><span class="s2">,</span><span class="s1">&quot;minPrec&quot;</span><span class="s2">,</span><span class="s1">&quot;isSatisfies&quot;</span><span class="s2">,</span><span class="s1">&quot;reScan_lt_gt&quot;</span><span class="s2">,</span><span class="s1">&quot;checkKeywords&quot;</span><span class="s2">,</span><span class="s1">&quot;checkDuplicateExports&quot;</span><span class="s2">,</span><span class="s1">&quot;ahead&quot;</span><span class="s2">,</span><span class="s1">&quot;importNode&quot;</span><span class="s2">,</span><span class="s1">&quot;isAbstractClass&quot;</span><span class="s2">,</span><span class="s1">&quot;cls&quot;</span><span class="s2">,</span><span class="s1">&quot;allowMissingInitializer&quot;</span><span class="s2">,</span><span class="s1">&quot;declarations&quot;</span><span class="s2">,</span><span class="s1">&quot;isValidAmbientConstInitializer&quot;</span><span class="s2">,</span><span class="s1">&quot;parseStatementContent&quot;</span><span class="s2">,</span><span class="s1">&quot;parseAccessModifier&quot;</span><span class="s2">,</span><span class="s1">&quot;tsHasSomeModifiers&quot;</span><span class="s2">,</span><span class="s1">&quot;callParseClassMemberWithIsStatic&quot;</span><span class="s2">,</span><span class="s1">&quot;parseClassStaticBlock&quot;</span><span class="s2">,</span><span class="s1">&quot;parseClassMemberWithIsStatic&quot;</span><span class="s2">,</span><span class="s1">&quot;hadSuperClass&quot;</span><span class="s2">,</span><span class="s1">&quot;parsePostMemberNameModifiers&quot;</span><span class="s2">,</span><span class="s1">&quot;methodOrProp&quot;</span><span class="s2">,</span><span class="s1">&quot;isDeclare&quot;</span><span class="s2">,</span><span class="s1">&quot;isIdentifier&quot;</span><span class="s2">,</span><span class="s1">&quot;parseClassPropertyAnnotation&quot;</span><span class="s2">,</span><span class="s1">&quot;definite&quot;</span><span class="s2">,</span><span class="s1">&quot;parseClassAccessorProperty&quot;</span><span class="s2">,</span><span class="s1">&quot;declareClassPrivateMethodInScope&quot;</span><span class="s2">,</span><span class="s1">&quot;_typeCast&quot;</span><span class="s2">,</span><span class="s1">&quot;_typeCast2&quot;</span><span class="s2">,</span><span class="s1">&quot;_jsx4&quot;</span><span class="s2">,</span><span class="s1">&quot;_typeCast3&quot;</span><span class="s2">,</span><span class="s1">&quot;typeCast&quot;</span><span class="s2">,</span><span class="s1">&quot;_typeParameters&quot;</span><span class="s2">,</span><span class="s1">&quot;reportReservedArrowTypeParam&quot;</span><span class="s2">,</span><span class="s1">&quot;trailingComma&quot;</span><span class="s2">,</span><span class="s1">&quot;sawUnary&quot;</span><span class="s2">,</span><span class="s1">&quot;toAssignableParenthesizedExpression&quot;</span><span class="s2">,</span><span class="s1">&quot;TSTypeCastExpression&quot;</span><span class="s2">,</span><span class="s1">&quot;TSParameterProperty&quot;</span><span class="s2">,</span><span class="s1">&quot;TSNonNullExpression&quot;</span><span class="s2">,</span><span class="s1">&quot;TSAsExpression&quot;</span><span class="s2">,</span><span class="s1">&quot;TSSatisfiesExpression&quot;</span><span class="s2">,</span><span class="s1">&quot;TSTypeAssertion&quot;</span><span class="s2">,</span><span class="s1">&quot;parseMaybeDecoratorArguments&quot;</span><span class="s2">,</span><span class="s1">&quot;canHaveLeadingDecorator&quot;</span><span class="s2">,</span><span class="s1">&quot;getGetterSetterExpectedParamCount&quot;</span><span class="s2">,</span><span class="s1">&quot;baseCount&quot;</span><span class="s2">,</span><span class="s1">&quot;firstParam&quot;</span><span class="s2">,</span><span class="s1">&quot;hasContextParam&quot;</span><span class="s2">,</span><span class="s1">&quot;parseCatchClauseParam&quot;</span><span class="s2">,</span><span class="s1">&quot;oldIsAmbientContext&quot;</span><span class="s2">,</span><span class="s1">&quot;oldInAbstractClass&quot;</span><span class="s2">,</span><span class="s1">&quot;maybeTakeDecorators&quot;</span><span class="s2">,</span><span class="s1">&quot;hasBody&quot;</span><span class="s2">,</span><span class="s1">&quot;shouldParseAsAmbientContext&quot;</span><span class="s2">,</span><span class="s1">&quot;getExpression&quot;</span><span class="s2">,</span><span class="s1">&quot;parseExportSpecifier&quot;</span><span class="s2">,</span><span class="s1">&quot;isString&quot;</span><span class="s2">,</span><span class="s1">&quot;isInTypeExport&quot;</span><span class="s2">,</span><span class="s1">&quot;parseTypeOnlyImportExportSpecifier&quot;</span><span class="s2">,</span><span class="s1">&quot;isImport&quot;</span><span class="s2">,</span><span class="s1">&quot;isInTypeOnlyImportExport&quot;</span><span class="s2">,</span><span class="s1">&quot;leftOfAsKey&quot;</span><span class="s2">,</span><span class="s1">&quot;rightOfAsKey&quot;</span><span class="s2">,</span><span class="s1">&quot;leftOfAs&quot;</span><span class="s2">,</span><span class="s1">&quot;rightOfAs&quot;</span><span class="s2">,</span><span class="s1">&quot;hasTypeSpecifier&quot;</span><span class="s2">,</span><span class="s1">&quot;canParseAsKeyword&quot;</span><span class="s2">,</span><span class="s1">&quot;firstAs&quot;</span><span class="s2">,</span><span class="s1">&quot;secondAs&quot;</span><span class="s2">,</span><span class="s1">&quot;parseModuleExportName&quot;</span><span class="s2">,</span><span class="s1">&quot;kindKey&quot;</span><span class="s2">,</span><span class="s1">&quot;isPossiblyLiteralEnum&quot;</span><span class="s2">,</span><span class="s1">&quot;expressions&quot;</span><span class="s2">,</span><span class="s1">&quot;isUncomputedMemberExpressionChain&quot;</span><span class="s2">,</span><span class="s1">&quot;isNumber&quot;</span><span class="s2">,</span><span class="s1">&quot;isNegativeNumber&quot;</span><span class="s2">,</span><span class="s1">&quot;PlaceholderErrors&quot;</span><span class="s2">,</span><span class="s1">&quot;ClassNameIsRequired&quot;</span><span class="s2">,</span><span class="s1">&quot;UnexpectedSpace&quot;</span><span class="s2">,</span><span class="s1">&quot;placeholders&quot;</span><span class="s2">,</span><span class="s1">&quot;PlaceholdersParserMixin&quot;</span><span class="s2">,</span><span class="s1">&quot;parsePlaceholder&quot;</span><span class="s2">,</span><span class="s1">&quot;assertNoSpace&quot;</span><span class="s2">,</span><span class="s1">&quot;finishPlaceholder&quot;</span><span class="s2">,</span><span class="s1">&quot;isFinished&quot;</span><span class="s2">,</span><span class="s1">&quot;chStartsBindingIdentifier&quot;</span><span class="s2">,</span><span class="s1">&quot;verifyBreakContinue&quot;</span><span class="s2">,</span><span class="s1">&quot;isBreak&quot;</span><span class="s2">,</span><span class="s1">&quot;parseStatementOrSloppyAnnexBFunctionDeclaration&quot;</span><span class="s2">,</span><span class="s1">&quot;parseBlock&quot;</span><span class="s2">,</span><span class="s1">&quot;createNewLexicalScope&quot;</span><span class="s2">,</span><span class="s1">&quot;parseFunctionId&quot;</span><span class="s2">,</span><span class="s1">&quot;requireId&quot;</span><span class="s2">,</span><span class="s1">&quot;oldStrict&quot;</span><span class="s2">,</span><span class="s1">&quot;parseClassBody&quot;</span><span class="s2">,</span><span class="s1">&quot;startsWith&quot;</span><span class="s2">,</span><span class="s1">&quot;maybeParseExportDefaultSpecifier&quot;</span><span class="s2">,</span><span class="s1">&quot;checkExport&quot;</span><span class="s2">,</span><span class="s1">&quot;hasStarImport&quot;</span><span class="s2">,</span><span class="s1">&quot;maybeParseStarImportSpecifier&quot;</span><span class="s2">,</span><span class="s1">&quot;parseNamedImportSpecifiers&quot;</span><span class="s2">,</span><span class="s1">&quot;parseImportSource&quot;</span><span class="s2">,</span><span class="s1">&quot;v8intrinsic&quot;</span><span class="s2">,</span><span class="s1">&quot;V8IntrinsicMixin&quot;</span><span class="s2">,</span><span class="s1">&quot;parseV8Intrinsic&quot;</span><span class="s2">,</span><span class="s1">&quot;v8IntrinsicStartLoc&quot;</span><span class="s2">,</span><span class="s1">&quot;parseIdentifierName&quot;</span><span class="s2">,</span><span class="s1">&quot;expectedConfig&quot;</span><span class="s2">,</span><span class="s1">&quot;expectedName&quot;</span><span class="s2">,</span><span class="s1">&quot;expectedOptions&quot;</span><span class="s2">,</span><span class="s1">&quot;expectedKeys&quot;</span><span class="s2">,</span><span class="s1">&quot;expectedOptionsIsEmpty&quot;</span><span class="s2">,</span><span class="s1">&quot;p&quot;</span><span class="s2">,</span><span class="s1">&quot;option&quot;</span><span class="s2">,</span><span class="s1">&quot;find&quot;</span><span class="s2">,</span><span class="s1">&quot;PIPELINE_PROPOSALS&quot;</span><span class="s2">,</span><span class="s1">&quot;TOPIC_TOKENS&quot;</span><span class="s2">,</span><span class="s1">&quot;RECORD_AND_TUPLE_SYNTAX_TYPES&quot;</span><span class="s2">,</span><span class="s1">&quot;validatePlugins&quot;</span><span class="s2">,</span><span class="s1">&quot;decoratorsBeforeExport&quot;</span><span class="s2">,</span><span class="s1">&quot;allowCallParenthesized&quot;</span><span class="s2">,</span><span class="s1">&quot;proposalList&quot;</span><span class="s2">,</span><span class="s1">&quot;tupleSyntaxIsHash&quot;</span><span class="s2">,</span><span class="s1">&quot;syntaxType&quot;</span><span class="s2">,</span><span class="s1">&quot;tokenList&quot;</span><span class="s2">,</span><span class="s1">&quot;moduleAttributesVersionPluginOption&quot;</span><span class="s2">,</span><span class="s1">&quot;missingPlugins&quot;</span><span class="s2">,</span><span class="s1">&quot;mixinPlugins&quot;</span><span class="s2">,</span><span class="s1">&quot;mixinPluginNames&quot;</span><span class="s2">,</span><span class="s1">&quot;ExpressionParser&quot;</span><span class="s2">,</span><span class="s1">&quot;checkProto&quot;</span><span class="s2">,</span><span class="s1">&quot;isRecord&quot;</span><span class="s2">,</span><span class="s1">&quot;protoRef&quot;</span><span class="s2">,</span><span class="s1">&quot;used&quot;</span><span class="s2">,</span><span class="s1">&quot;shouldExitDescending&quot;</span><span class="s2">,</span><span class="s1">&quot;disallowIn&quot;</span><span class="s2">,</span><span class="s1">&quot;disallowInAnd&quot;</span><span class="s2">,</span><span class="s1">&quot;parseExpressionBase&quot;</span><span class="s2">,</span><span class="s1">&quot;allowInAnd&quot;</span><span class="s2">,</span><span class="s1">&quot;parseMaybeAssignDisallowIn&quot;</span><span class="s2">,</span><span class="s1">&quot;resultError&quot;</span><span class="s2">,</span><span class="s1">&quot;_resultError$loc&quot;</span><span class="s2">,</span><span class="s1">&quot;parseYield&quot;</span><span class="s2">,</span><span class="s1">&quot;ownExpressionErrors&quot;</span><span class="s2">,</span><span class="s1">&quot;parseMaybeConditional&quot;</span><span class="s2">,</span><span class="s1">&quot;startIndex&quot;</span><span class="s2">,</span><span class="s1">&quot;parseExprOps&quot;</span><span class="s2">,</span><span class="s1">&quot;parseMaybeUnaryOrPrivate&quot;</span><span class="s2">,</span><span class="s1">&quot;op&quot;</span><span class="s2">,</span><span class="s1">&quot;prec&quot;</span><span class="s2">,</span><span class="s1">&quot;checkPipelineAtInfixOperator&quot;</span><span class="s2">,</span><span class="s1">&quot;logical&quot;</span><span class="s2">,</span><span class="s1">&quot;coalesce&quot;</span><span class="s2">,</span><span class="s1">&quot;parseExprOpRightExpr&quot;</span><span class="s2">,</span><span class="s1">&quot;finishedNode&quot;</span><span class="s2">,</span><span class="s1">&quot;nextOp&quot;</span><span class="s2">,</span><span class="s1">&quot;withTopicBindingContext&quot;</span><span class="s2">,</span><span class="s1">&quot;parseHackPipeBody&quot;</span><span class="s2">,</span><span class="s1">&quot;parseSmartPipelineBodyInStyle&quot;</span><span class="s2">,</span><span class="s1">&quot;parseExprOpBaseRightExpr&quot;</span><span class="s2">,</span><span class="s1">&quot;withSoloAwaitPermittingContext&quot;</span><span class="s2">,</span><span class="s1">&quot;parseFSharpPipelineBody&quot;</span><span class="s2">,</span><span class="s1">&quot;_body$extra&quot;</span><span class="s2">,</span><span class="s1">&quot;requiredParentheses&quot;</span><span class="s2">,</span><span class="s1">&quot;topicReferenceWasUsedInCurrentContext&quot;</span><span class="s2">,</span><span class="s1">&quot;checkExponentialAfterUnary&quot;</span><span class="s2">,</span><span class="s1">&quot;isAwait&quot;</span><span class="s2">,</span><span class="s1">&quot;isAwaitAllowed&quot;</span><span class="s2">,</span><span class="s1">&quot;parseAwait&quot;</span><span class="s2">,</span><span class="s1">&quot;update&quot;</span><span class="s2">,</span><span class="s1">&quot;isDelete&quot;</span><span class="s2">,</span><span class="s1">&quot;parseUpdate&quot;</span><span class="s2">,</span><span class="s1">&quot;isAmbiguousAwait&quot;</span><span class="s2">,</span><span class="s1">&quot;updateExpressionNode&quot;</span><span class="s2">,</span><span class="s1">&quot;parseExprSubscripts&quot;</span><span class="s2">,</span><span class="s1">&quot;maybeAsyncArrow&quot;</span><span class="s2">,</span><span class="s1">&quot;parseBind&quot;</span><span class="s2">,</span><span class="s1">&quot;parseCoverCallAndAsyncArrowHead&quot;</span><span class="s2">,</span><span class="s1">&quot;parseMember&quot;</span><span class="s2">,</span><span class="s1">&quot;parseNoCallExpr&quot;</span><span class="s2">,</span><span class="s1">&quot;tag&quot;</span><span class="s2">,</span><span class="s1">&quot;quasi&quot;</span><span class="s2">,</span><span class="s1">&quot;dynamicImport&quot;</span><span class="s2">,</span><span class="s1">&quot;allowPlaceholder&quot;</span><span class="s2">,</span><span class="s1">&quot;nodeForExtra&quot;</span><span class="s2">,</span><span class="s1">&quot;oldInFSharpPipelineDirectBody&quot;</span><span class="s2">,</span><span class="s1">&quot;addTrailingCommaExtraToNode&quot;</span><span class="s2">,</span><span class="s1">&quot;parseExprListItem&quot;</span><span class="s2">,</span><span class="s1">&quot;_call$extra&quot;</span><span class="s2">,</span><span class="s1">&quot;parseSuper&quot;</span><span class="s2">,</span><span class="s1">&quot;parseImportMetaProperty&quot;</span><span class="s2">,</span><span class="s1">&quot;parseDo&quot;</span><span class="s2">,</span><span class="s1">&quot;parseFunctionOrFunctionSent&quot;</span><span class="s2">,</span><span class="s1">&quot;parseDecorators&quot;</span><span class="s2">,</span><span class="s1">&quot;parseNewOrNewTarget&quot;</span><span class="s2">,</span><span class="s1">&quot;parseTopicReferenceThenEqualsSign&quot;</span><span class="s2">,</span><span class="s1">&quot;parseTopicReference&quot;</span><span class="s2">,</span><span class="s1">&quot;pipeProposal&quot;</span><span class="s2">,</span><span class="s1">&quot;parseModuleExpression&quot;</span><span class="s2">,</span><span class="s1">&quot;parseAsyncFunctionExpression&quot;</span><span class="s2">,</span><span class="s1">&quot;parseAsyncArrowUnaryFunction&quot;</span><span class="s2">,</span><span class="s1">&quot;topicTokenType&quot;</span><span class="s2">,</span><span class="s1">&quot;topicTokenValue&quot;</span><span class="s2">,</span><span class="s1">&quot;finishTopicReference&quot;</span><span class="s2">,</span><span class="s1">&quot;testTopicReferenceConfiguration&quot;</span><span class="s2">,</span><span class="s1">&quot;topicReferenceIsAllowedInCurrentContext&quot;</span><span class="s2">,</span><span class="s1">&quot;registerTopicReference&quot;</span><span class="s2">,</span><span class="s1">&quot;meta&quot;</span><span class="s2">,</span><span class="s1">&quot;parseMetaProperty&quot;</span><span class="s2">,</span><span class="s1">&quot;parseFunction&quot;</span><span class="s2">,</span><span class="s1">&quot;innerStartLoc&quot;</span><span class="s2">,</span><span class="s1">&quot;spreadStartLoc&quot;</span><span class="s2">,</span><span class="s1">&quot;optionalCommaStartLoc&quot;</span><span class="s2">,</span><span class="s1">&quot;spreadNodeStartLoc&quot;</span><span class="s2">,</span><span class="s1">&quot;innerEndLoc&quot;</span><span class="s2">,</span><span class="s1">&quot;arrowNode&quot;</span><span class="s2">,</span><span class="s1">&quot;wrapParenthesis&quot;</span><span class="s2">,</span><span class="s1">&quot;parenExpression&quot;</span><span class="s2">,</span><span class="s1">&quot;metaProp&quot;</span><span class="s2">,</span><span class="s1">&quot;parseNew&quot;</span><span class="s2">,</span><span class="s1">&quot;parseExprList&quot;</span><span class="s2">,</span><span class="s1">&quot;parseTemplateElement&quot;</span><span class="s2">,</span><span class="s1">&quot;isTagged&quot;</span><span class="s2">,</span><span class="s1">&quot;elemStart&quot;</span><span class="s2">,</span><span class="s1">&quot;elem&quot;</span><span class="s2">,</span><span class="s1">&quot;isTail&quot;</span><span class="s2">,</span><span class="s1">&quot;endOffset&quot;</span><span class="s2">,</span><span class="s1">&quot;elemEnd&quot;</span><span class="s2">,</span><span class="s1">&quot;cooked&quot;</span><span class="s2">,</span><span class="s1">&quot;tail&quot;</span><span class="s2">,</span><span class="s1">&quot;curElt&quot;</span><span class="s2">,</span><span class="s1">&quot;quasis&quot;</span><span class="s2">,</span><span class="s1">&quot;propHash&quot;</span><span class="s2">,</span><span class="s1">&quot;parsePropertyDefinition&quot;</span><span class="s2">,</span><span class="s1">&quot;maybeAsyncOrAccessorProp&quot;</span><span class="s2">,</span><span class="s1">&quot;keyName&quot;</span><span class="s2">,</span><span class="s1">&quot;_params&quot;</span><span class="s2">,</span><span class="s1">&quot;finishedProp&quot;</span><span class="s2">,</span><span class="s1">&quot;generator&quot;</span><span class="s2">,</span><span class="s1">&quot;isExpression&quot;</span><span class="s2">,</span><span class="s1">&quot;hasStrictModeDirective&quot;</span><span class="s2">,</span><span class="s1">&quot;nonSimple&quot;</span><span class="s2">,</span><span class="s1">&quot;isSimpleParamList&quot;</span><span class="s2">,</span><span class="s1">&quot;formalParameters&quot;</span><span class="s2">,</span><span class="s1">&quot;reservedTest&quot;</span><span class="s2">,</span><span class="s1">&quot;delegating&quot;</span><span class="s2">,</span><span class="s1">&quot;delegate&quot;</span><span class="s2">,</span><span class="s1">&quot;childExpr&quot;</span><span class="s2">,</span><span class="s1">&quot;isSimpleReference&quot;</span><span class="s2">,</span><span class="s1">&quot;checkSmartPipeTopicBodyEarlyErrors&quot;</span><span class="s2">,</span><span class="s1">&quot;callback&quot;</span><span class="s2">,</span><span class="s1">&quot;outerContextTopicState&quot;</span><span class="s2">,</span><span class="s1">&quot;withSmartMixTopicForbiddingContext&quot;</span><span class="s2">,</span><span class="s1">&quot;outerContextSoloAwaitState&quot;</span><span class="s2">,</span><span class="s1">&quot;prodParamToSet&quot;</span><span class="s2">,</span><span class="s1">&quot;prodParamToClear&quot;</span><span class="s2">,</span><span class="s1">&quot;ret&quot;</span><span class="s2">,</span><span class="s1">&quot;revertScopes&quot;</span><span class="s2">,</span><span class="s1">&quot;parseProgram&quot;</span><span class="s2">,</span><span class="s1">&quot;loopLabel&quot;</span><span class="s2">,</span><span class="s1">&quot;switchLabel&quot;</span><span class="s2">,</span><span class="s1">&quot;loneSurrogate&quot;</span><span class="s2">,</span><span class="s1">&quot;keywordRelationalOperator&quot;</span><span class="s2">,</span><span class="s1">&quot;babel7CompatTokens&quot;</span><span class="s2">,</span><span class="s1">&quot;hashEndPos&quot;</span><span class="s2">,</span><span class="s1">&quot;hashEndLoc&quot;</span><span class="s2">,</span><span class="s1">&quot;backquoteEnd&quot;</span><span class="s2">,</span><span class="s1">&quot;backquoteEndLoc&quot;</span><span class="s2">,</span><span class="s1">&quot;startToken&quot;</span><span class="s2">,</span><span class="s1">&quot;templateValue&quot;</span><span class="s2">,</span><span class="s1">&quot;templateElementEnd&quot;</span><span class="s2">,</span><span class="s1">&quot;templateElementEndLoc&quot;</span><span class="s2">,</span><span class="s1">&quot;endToken&quot;</span><span class="s2">,</span><span class="s1">&quot;StatementParser&quot;</span><span class="s2">,</span><span class="s1">&quot;interpreter&quot;</span><span class="s2">,</span><span class="s1">&quot;parseInterpreterDirective&quot;</span><span class="s2">,</span><span class="s1">&quot;finishedProgram&quot;</span><span class="s2">,</span><span class="s1">&quot;stmtToDirective&quot;</span><span class="s2">,</span><span class="s1">&quot;directiveLiteral&quot;</span><span class="s2">,</span><span class="s1">&quot;hasFollowingBindingAtom&quot;</span><span class="s2">,</span><span class="s1">&quot;endCh&quot;</span><span class="s2">,</span><span class="s1">&quot;chStartsBindingPattern&quot;</span><span class="s2">,</span><span class="s1">&quot;hasInLineFollowingBindingIdentifier&quot;</span><span class="s2">,</span><span class="s1">&quot;startsUsingForOf&quot;</span><span class="s2">,</span><span class="s1">&quot;parseModuleItem&quot;</span><span class="s2">,</span><span class="s1">&quot;ParseStatementFlag&quot;</span><span class="s2">,</span><span class="s1">&quot;parseStatementListItem&quot;</span><span class="s2">,</span><span class="s1">&quot;allowLabeledFunction&quot;</span><span class="s2">,</span><span class="s1">&quot;parseStatement&quot;</span><span class="s2">,</span><span class="s1">&quot;allowDeclaration&quot;</span><span class="s2">,</span><span class="s1">&quot;allowFunctionDeclaration&quot;</span><span class="s2">,</span><span class="s1">&quot;parseBreakContinueStatement&quot;</span><span class="s2">,</span><span class="s1">&quot;parseDebuggerStatement&quot;</span><span class="s2">,</span><span class="s1">&quot;parseDoWhileStatement&quot;</span><span class="s2">,</span><span class="s1">&quot;parseForStatement&quot;</span><span class="s2">,</span><span class="s1">&quot;parseIfStatement&quot;</span><span class="s2">,</span><span class="s1">&quot;parseReturnStatement&quot;</span><span class="s2">,</span><span class="s1">&quot;parseSwitchStatement&quot;</span><span class="s2">,</span><span class="s1">&quot;parseThrowStatement&quot;</span><span class="s2">,</span><span class="s1">&quot;parseTryStatement&quot;</span><span class="s2">,</span><span class="s1">&quot;parseWhileStatement&quot;</span><span class="s2">,</span><span class="s1">&quot;parseWithStatement&quot;</span><span class="s2">,</span><span class="s1">&quot;parseEmptyStatement&quot;</span><span class="s2">,</span><span class="s1">&quot;nextTokenCharCode&quot;</span><span class="s2">,</span><span class="s1">&quot;isAsyncFunction&quot;</span><span class="s2">,</span><span class="s1">&quot;maybeName&quot;</span><span class="s2">,</span><span class="s1">&quot;parseLabeledStatement&quot;</span><span class="s2">,</span><span class="s1">&quot;decoratorsEnabledBeforeExport&quot;</span><span class="s2">,</span><span class="s1">&quot;maybeDecorators&quot;</span><span class="s2">,</span><span class="s1">&quot;classNode&quot;</span><span class="s2">,</span><span class="s1">&quot;exportNode&quot;</span><span class="s2">,</span><span class="s1">&quot;allowExport&quot;</span><span class="s2">,</span><span class="s1">&quot;paramsStartLoc&quot;</span><span class="s2">,</span><span class="s1">&quot;lab&quot;</span><span class="s2">,</span><span class="s1">&quot;parseHeaderExpression&quot;</span><span class="s2">,</span><span class="s1">&quot;awaitAt&quot;</span><span class="s2">,</span><span class="s1">&quot;parseFor&quot;</span><span class="s2">,</span><span class="s1">&quot;startsWithLet&quot;</span><span class="s2">,</span><span class="s1">&quot;startsWithUsing&quot;</span><span class="s2">,</span><span class="s1">&quot;isLetOrUsing&quot;</span><span class="s2">,</span><span class="s1">&quot;initNode&quot;</span><span class="s2">,</span><span class="s1">&quot;parseVar&quot;</span><span class="s2">,</span><span class="s1">&quot;isForIn&quot;</span><span class="s2">,</span><span class="s1">&quot;parseForIn&quot;</span><span class="s2">,</span><span class="s1">&quot;startsWithAsync&quot;</span><span class="s2">,</span><span class="s1">&quot;isForOf&quot;</span><span class="s2">,</span><span class="s1">&quot;isHangingDeclaration&quot;</span><span class="s2">,</span><span class="s1">&quot;ParseFunctionFlag&quot;</span><span class="s2">,</span><span class="s1">&quot;discriminant&quot;</span><span class="s2">,</span><span class="s1">&quot;cases&quot;</span><span class="s2">,</span><span class="s1">&quot;cur&quot;</span><span class="s2">,</span><span class="s1">&quot;sawDefault&quot;</span><span class="s2">,</span><span class="s1">&quot;isCase&quot;</span><span class="s2">,</span><span class="s1">&quot;block&quot;</span><span class="s2">,</span><span class="s1">&quot;handler&quot;</span><span class="s2">,</span><span class="s1">&quot;clause&quot;</span><span class="s2">,</span><span class="s1">&quot;finalizer&quot;</span><span class="s2">,</span><span class="s1">&quot;statementStart&quot;</span><span class="s2">,</span><span class="s1">&quot;parsedNonDirective&quot;</span><span class="s2">,</span><span class="s1">&quot;await&quot;</span><span class="s2">,</span><span class="s1">&quot;isFor&quot;</span><span class="s2">,</span><span class="s1">&quot;hangingDeclaration&quot;</span><span class="s2">,</span><span class="s1">&quot;isDeclaration&quot;</span><span class="s2">,</span><span class="s1">&quot;hadConstructor&quot;</span><span class="s2">,</span><span class="s1">&quot;publicMethod&quot;</span><span class="s2">,</span><span class="s1">&quot;privateMethod&quot;</span><span class="s2">,</span><span class="s1">&quot;publicProp&quot;</span><span class="s2">,</span><span class="s1">&quot;privateProp&quot;</span><span class="s2">,</span><span class="s1">&quot;accessorProp&quot;</span><span class="s2">,</span><span class="s1">&quot;publicMember&quot;</span><span class="s2">,</span><span class="s1">&quot;parseClassElementName&quot;</span><span class="s2">,</span><span class="s1">&quot;isPrivate&quot;</span><span class="s2">,</span><span class="s1">&quot;maybeQuestionTokenStartLoc&quot;</span><span class="s2">,</span><span class="s1">&quot;pushClassPrivateProperty&quot;</span><span class="s2">,</span><span class="s1">&quot;pushClassProperty&quot;</span><span class="s2">,</span><span class="s1">&quot;pushClassAccessorProperty&quot;</span><span class="s2">,</span><span class="s1">&quot;_member$decorators&quot;</span><span class="s2">,</span><span class="s1">&quot;parseInitializer&quot;</span><span class="s2">,</span><span class="s1">&quot;hasDefault&quot;</span><span class="s2">,</span><span class="s1">&quot;parseAfterDefault&quot;</span><span class="s2">,</span><span class="s1">&quot;hasStar&quot;</span><span class="s2">,</span><span class="s1">&quot;parseAfterNamespace&quot;</span><span class="s2">,</span><span class="s1">&quot;isFromRequired&quot;</span><span class="s2">,</span><span class="s1">&quot;hasSpecifiers&quot;</span><span class="s2">,</span><span class="s1">&quot;maybeParseExportNamedSpecifiers&quot;</span><span class="s2">,</span><span class="s1">&quot;hasDeclaration&quot;</span><span class="s2">,</span><span class="s1">&quot;maybeParseExportDeclaration&quot;</span><span class="s2">,</span><span class="s1">&quot;_node2$declaration&quot;</span><span class="s2">,</span><span class="s1">&quot;isTypeExport&quot;</span><span class="s2">,</span><span class="s1">&quot;assertions&quot;</span><span class="s2">,</span><span class="s1">&quot;nextType&quot;</span><span class="s2">,</span><span class="s1">&quot;hasFrom&quot;</span><span class="s2">,</span><span class="s1">&quot;nextAfterFrom&quot;</span><span class="s2">,</span><span class="s1">&quot;maybeParseImportAssertions&quot;</span><span class="s2">,</span><span class="s1">&quot;checkJSONModuleImport&quot;</span><span class="s2">,</span><span class="s1">&quot;checkNames&quot;</span><span class="s2">,</span><span class="s1">&quot;isDefault&quot;</span><span class="s2">,</span><span class="s1">&quot;isFrom&quot;</span><span class="s2">,</span><span class="s1">&quot;_declaration$extra&quot;</span><span class="s2">,</span><span class="s1">&quot;nodes&quot;</span><span class="s2">,</span><span class="s1">&quot;surrogate&quot;</span><span class="s2">,</span><span class="s1">&quot;isJSONModuleImport&quot;</span><span class="s2">,</span><span class="s1">&quot;_node$assertions&quot;</span><span class="s2">,</span><span class="s1">&quot;nonDefaultNamedSpecifier&quot;</span><span class="s2">,</span><span class="s1">&quot;parseMaybeImportReflection&quot;</span><span class="s2">,</span><span class="s1">&quot;isImportReflection&quot;</span><span class="s2">,</span><span class="s1">&quot;nextNextTokenFirstChar&quot;</span><span class="s2">,</span><span class="s1">&quot;parseNext&quot;</span><span class="s2">,</span><span class="s1">&quot;maybeParseModuleAttributes&quot;</span><span class="s2">,</span><span class="s1">&quot;parseAssertEntries&quot;</span><span class="s2">,</span><span class="s1">&quot;attrs&quot;</span><span class="s2">,</span><span class="s1">&quot;attrNames&quot;</span><span class="s2">,</span><span class="s1">&quot;importSpecifier&quot;</span><span class="s2">,</span><span class="s1">&quot;Parser&quot;</span><span class="s2">,</span><span class="s1">&quot;pluginsMap&quot;</span><span class="s2">,</span><span class="s1">&quot;pluginMap&quot;</span><span class="s2">,</span><span class="s1">&quot;_options&quot;</span><span class="s2">,</span><span class="s1">&quot;getParser&quot;</span><span class="s2">,</span><span class="s1">&quot;ast&quot;</span><span class="s2">,</span><span class="s1">&quot;moduleError&quot;</span><span class="s2">,</span><span class="s1">&quot;generateExportedTokenTypes&quot;</span><span class="s2">,</span><span class="s1">&quot;internalTokenTypes&quot;</span><span class="s2">,</span><span class="s1">&quot;tokTypes&quot;</span><span class="s2">,</span><span class="s1">&quot;getParserClass&quot;</span><span class="s2">,</span><span class="s1">&quot;parserClassCache&quot;</span><span class="s2">,</span><span class="s1">&quot;pluginsFromOptions&quot;</span><span class="s2">,</span><span class="s1">&quot;pluginList&quot;</span><span class="s0">]</span><span class="s2">,</span><span class="s1">&quot;mappings&quot;</span><span class="s2">:</span><span class="s1">&quot;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AAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,GAAG,EAAC,IAAI,EAAC,EAAE,EAAC,EAAE,EAAC,IAAI,EAAC,EAAE,EAAC,CAAC,EAAC,IAAI,EAAC,GAAG,EAAC,IAAI,EAAC,GAAG,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,EAAE,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,IAAI,EAAC,CAAC,EAAC,IAAI,EAAC,EAAE,EAAC,CAAC,EAAC,IAAI,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,GAAG,EAAC,IAAI,EAAC,GAAG,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,IAAI,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,GAAG,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,IAAI,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,EAAE,EAAC,GAAG,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,IAAI,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,IAAI,EAAC,KAAK,EAAC,EAAE,EAAC,IAAI,EAAC,CAAC,EAAC,GAAG,EAAC,CAAC,EAAC,IAAI,EAAC,EAAE,EAAC,IAAI,EAAC,IAAI,EAAC,GAAG,EAAC,IAAI,EAAC,IAAI,EAAC,CAAC,EAAC,IAAI,CAAC;AAEj+C,MAAMC,qBAAqB,GAAG,CAAC,GAAG,EAAC,CAAC,EAAC,GAAG,EAAC,CAAC,EAAC,GAAG,EAAC,CAAC,EAAC,GAAG,EAAC,CAAC,EAAC,IAAI,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,GAAG,EAAC,CAAC,EAAC,GAAG,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,GAAG,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,GAAG,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,GAAG,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,IAAI,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,KAAK,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,IAAI,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,KAAK,EAAC,CAAC,EAAC,IAAI,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,CAAC,EAAC,IAAI,EAAC,EAAE,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,IAAI,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,GAAG,EAAC,CAAC,EAAC,GAAG,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,EAAE,EAAC,GAAG,EAAC,CAAC,EAAC,GAAG,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,IAAI,EAAC,CAAC,EAAC,MAAM,EAAC,GAAG,CAAC;AAKjwB,SAASC,aAAaA,CAAC7X,IAAY,EAAE/N,GAAsB,EAAW;EACpE,IAAIqc,GAAG,GAAG,OAAO;EACjB,KAAK,IAAIrP,CAAC,GAAG,CAAC,EAAExB,MAAM,GAAGxL,GAAG,CAACwL,MAAM,EAAEwB,CAAC,GAAGxB,MAAM,EAAEwB,CAAC,IAAI,CAAC,EAAE;IACvDqP,GAAG,IAAIrc,GAAG,CAACgN,CAAC,CAAC;IACb,IAAIqP,GAAG,GAAGtO,IAAI,EAAE,OAAO,KAAK;IAE5BsO,GAAG,IAAIrc,GAAG,CAACgN,CAAC,GAAG,CAAC,CAAC;IACjB,IAAIqP,GAAG,IAAItO,IAAI,EAAE,OAAO,IAAI;EAC9B;EACA,OAAO,KAAK;AACd;AAIO,SAAS8X,iBAAiBA,CAAC9X,IAAY,EAAW;EACvD,IAAIA,IAAI,GAAA,EAAuB,EAAE,OAAOA,IAAI,KAAyB,EAAA;EACrE,IAAIA,IAAI,IAAA,EAAwB,EAAE,OAAO,IAAI;EAC7C,IAAIA,IAAI,GAAA,EAAuB,EAAE,OAAOA,IAAI,KAAyB,EAAA;EACrE,IAAIA,IAAI,IAAA,GAAwB,EAAE,OAAO,IAAI;EAC7C,IAAIA,IAAI,IAAI,MAAM,EAAE;IAClB,OACEA,IAAI,IAAI,IAAI,IAAIyX,uBAAuB,CAACM,IAAI,CAACpW,MAAM,CAACqW,YAAY,CAAChY,IAAI,CAAC,CAAC;EAE3E;EACA,OAAO6X,aAAa,CAAC7X,IAAI,EAAE2X,0BAA0B,CAAC;AACxD;AAIO,SAASM,gBAAgBA,CAACjY,IAAY,EAAW;EACtD,IAAIA,IAAI,GAAA,EAAmB,EAAE,OAAOA,IAAI,KAAyB,EAAA;EACjE,IAAIA,IAAI,GAAA,EAAkB,EAAE,OAAO,IAAI;EACvC,IAAIA,IAAI,GAAA,EAAuB,EAAE,OAAO,KAAK;EAC7C,IAAIA,IAAI,IAAA,EAAwB,EAAE,OAAO,IAAI;EAC7C,IAAIA,IAAI,GAAA,EAAuB,EAAE,OAAOA,IAAI,KAAyB,EAAA;EACrE,IAAIA,IAAI,IAAA,GAAwB,EAAE,OAAO,IAAI;EAC7C,IAAIA,IAAI,IAAI,MAAM,EAAE;IAClB,OAAOA,IAAI,IAAI,IAAI,IAAI0X,kBAAkB,CAACK,IAAI,CAACpW,MAAM,CAACqW,YAAY,CAAChY,IAAI,CAAC,CAAC;EAC3E;EACA,OACE6X,aAAa,CAAC7X,IAAI,EAAE2X,0BAA0B,CAAC,IAC/CE,aAAa,CAAC7X,IAAI,EAAE4X,qBAAqB,CAAC;AAE9C;AChFA,MAAMM,aAAa,GAAG;EACpB1mB,OAAO,EAAE,CACP,OAAO,EACP,MAAM,EACN,OAAO,EACP,UAAU,EACV,UAAU,EACV,SAAS,EACT,IAAI,EACJ,MAAM,EACN,SAAS,EACT,KAAK,EACL,UAAU,EACV,IAAI,EACJ,QAAQ,EACR,QAAQ,EACR,OAAO,EACP,KAAK,EACL,KAAK,EACL,OAAO,EACP,OAAO,EACP,MAAM,EACN,KAAK,EACL,MAAM,EACN,OAAO,EACP,OAAO,EACP,SAAS,EACT,QAAQ,EACR,QAAQ,EACR,MAAM,EACN,MAAM,EACN,OAAO,EACP,IAAI,EACJ,YAAY,EACZ,QAAQ,EACR,MAAM,EACN,QAAQ,CACT;EACD2mB,MAAM,EAAE,CACN,YAAY,EACZ,WAAW,EACX,KAAK,EACL,SAAS,EACT,SAAS,EACT,WAAW,EACX,QAAQ,EACR,QAAQ,EACR,OAAO,CACR;EACDC,UAAU,EAAE,CAAC,MAAM,EAAE,WAAW;AAClC,CAAC;AACD,MAAMxmB,QAAQ,GAAG,IAAImb,GAAG,CAACmL,aAAa,CAAC1mB,OAAO,CAAC;AAC/C,MAAM6mB,sBAAsB,GAAG,IAAItL,GAAG,CAACmL,aAAa,CAACC,MAAM,CAAC;AAC5D,MAAMG,0BAA0B,GAAG,IAAIvL,GAAG,CAACmL,aAAa,CAACE,UAAU,CAAC;AAK7D,SAASG,cAAcA,CAACC,IAAY,EAAEC,QAAiB,EAAW;EACvE,OAAQA,QAAQ,IAAID,IAAI,KAAK,OAAO,IAAKA,IAAI,KAAK,MAAM;AAC1D;AAOO,SAASE,oBAAoBA,CAACF,IAAY,EAAEC,QAAiB,EAAW;EAC7E,OAAOF,cAAc,CAACC,IAAI,EAAEC,QAAQ,CAAC,IAAIJ,sBAAsB,CAACM,GAAG,CAACH,IAAI,CAAC;AAC3E;AAMO,SAASI,4BAA4BA,CAACJ,IAAY,EAAW;EAClE,OAAOF,0BAA0B,CAACK,GAAG,CAACH,IAAI,CAAC;AAC7C;AAOO,SAASK,wBAAwBA,CACtCL,IAAY,EACZC,QAAiB,EACR;EACT,OACEC,oBAAoB,CAACF,IAAI,EAAEC,QAAQ,CAAC,IAAIG,4BAA4B,CAACJ,IAAI,CAAC;AAE9E;AAEO,SAASM,SAASA,CAACN,IAAY,EAAW;EAC/C,OAAO5mB,QAAQ,CAAC+mB,GAAG,CAACH,IAAI,CAAC;AAC3B;AC5EO,SAASO,eAAeA,CAC7BC,OAAe,EACfC,IAAY,EACZC,KAAa,EACJ;EACT,OACEF,OAAO,OAAqB,IAC5BC,IAAI,OAAqB,IACzBnB,iBAAiB,CAACoB,KAAK,CAAC;AAE5B;AAOA,MAAMC,mBAAmB,GAAG,IAAIpM,GAAG,CAAC,CAClC,OAAO,EACP,MAAM,EACN,OAAO,EACP,UAAU,EACV,UAAU,EACV,SAAS,EACT,IAAI,EACJ,MAAM,EACN,SAAS,EACT,KAAK,EACL,UAAU,EACV,IAAI,EACJ,QAAQ,EACR,QAAQ,EACR,OAAO,EACP,KAAK,EACL,KAAK,EACL,OAAO,EACP,OAAO,EACP,MAAM,EACN,KAAK,EACL,MAAM,EACN,OAAO,EACP,OAAO,EACP,SAAS,EACT,QAAQ,EACR,QAAQ,EACR,MAAM,EACN,MAAM,EACN,OAAO,EACP,IAAI,EACJ,YAAY,EACZ,QAAQ,EACR,MAAM,EACN,QAAQ,EAER,YAAY,EACZ,WAAW,EACX,KAAK,EACL,SAAS,EACT,SAAS,EACT,WAAW,EACX,QAAQ,EACR,QAAQ,EACR,OAAO,EAEP,MAAM,EACN,WAAW,EAEX,MAAM,EACN,OAAO,CACR,CAAC;AAEK,SAASqM,iBAAiBA,CAACZ,IAAY,EAAW;EACvD,OAAOW,mBAAmB,CAACR,GAAG,CAACH,IAAI,CAAC;AACtC;AC1FO,MAAMa,WAAW,GAAU,WAAW;EAChCC,aAAa,GAAQ,WAAW;EAChCC,cAAc,GAAO,WAAW;EAChCC,WAAW,GAAU,WAAW;EAChCC,kBAAkB,GAAG,WAAW;EAChCC,WAAW,GAAU,WAAW;EAChCC,kBAAkB,GAAG,WAAW;EAChCC,WAAW,GAAU,WAAW;EAChCC,kBAAkB,GAAG,WAAW;EAChCC,eAAe,GAAM,WAAW;EAChCC,SAAS,GAAGT,aAAa,GAAGC,cAAc,GAAGM,kBAAkB,GAAGC,eAAe;AAgBvF,MAAME,eAAe,GAAc,eAAiB;EAC9CC,cAAc,GAAe,eAAiB;EAE9CC,cAAc,GAAe,eAAiB;EAC9CC,kBAAkB,GAAW,eAAiB;EAC9CC,mBAAmB,GAAU,eAAiB;EAI9CC,eAAe,GAAc,gBAAkB;EAC/CC,gBAAgB,GAAa,gBAAkB;EAC/CC,kBAAkB,GAAW,gBAAkB;EAC/CC,wBAAwB,GAAK,gBAAkB;EAC/CC,yBAAyB,GAAI,gBAAkB;EAC/CC,0BAA0B,GAAG,gBAAkB;EAC/CC,oBAAoB,GAAS,gBAAkB;EAE/CC,4BAA4B,GAAG,gBAAkB;AAKvD,MAAMC,UAAU,GAAWb,eAAe,GAAGC,cAAc,GAAGE,kBAAkB,GAAIG,gBAAgB,GAACM,4BAA4B;EAC3HE,YAAY,GAASd,eAAe,GAAG,CAAC,GAAgBG,kBAAkB,GAAIS,4BAA4B;EAC1GG,gBAAgB,GAAKf,eAAe,GAAG,CAAC,GAAgBG,kBAAkB,GAAI,CAAC;EAC/Ea,QAAQ,GAAahB,eAAe,GAAG,CAAC,GAAgBE,cAAc,GAAQ,CAAC;EAC/Ee,aAAa,GAAQjB,eAAe,GAAG,CAAC,GAAgBI,mBAAmB,GAAG,CAAC;EAC/Ec,iBAAiB,GAAI,CAAC,GAAiBjB,cAAc,GAAG,CAAC,GAAqBK,gBAAgB;EAC9Fa,YAAY,GAAS,CAAC,GAAiBlB,cAAc,GAAG,CAAC,GAAqB,CAAC;EAC/EmB,YAAY,GAASpB,eAAe,GAAGC,cAAc,GAAGE,kBAAkB,GAAII,kBAAkB,GAACK,4BAA4B;EAC7HS,eAAe,GAAM,CAAC,GAAiB,CAAC,GAAgB,CAAC,GAAcZ,yBAAyB;EAGhGa,SAAS,GAAY,CAAC,GAAiB,CAAC,GAAgB,CAAC,GAAqBjB,eAAe;EAC7FkB,YAAY,GAASvB,eAAe,GAAG,CAAC,GAAgB,CAAC,GAAqBK,eAAe;EAE7FmB,kBAAkB,GAAGJ,YAAY,GAAMZ,wBAAwB;EAC/DiB,iBAAiB,GAAI,CAAC,GAAiB,CAAC,GAAgB,CAAC,GAAqBhB,yBAAyB;EACvGiB,mBAAmB,GAAE,CAAC,GAAiBzB,cAAc,GAAG,CAAC,GAAqBU,oBAAoB;EAElGgB,oBAAoB,GAAGjB,0BAA0B;AAgBvD,MAAMkB,yBAAyB,GAAG,KAAM;EAClCC,yBAAyB,GAAG,KAAM;EAClCC,yBAAyB,GAAG,KAAM;EAClCC,2BAA2B,GAAGF,yBAAyB,GAAGC,yBAAyB;AAGzF,MAAME,2BAA2B,GAAKH,yBAAyB,GAAGD,yBAAyB;EACrFK,2BAA2B,GAAKH,yBAAyB,GAAGF,yBAAyB;EACrFM,6BAA6B,GAAGL,yBAAyB;EACzDM,6BAA6B,GAAGL,yBAAyB;EACzDM,mBAAmB,GAAa,CAAC;ACvEvC,MAAMC,KAAK,CAAC;EASjB/rB,WAAWA,CAACuf,KAAiB,EAAE;IAAA,IAAA,CAN/ByM,GAAG,GAAgB,IAAIvP,GAAG,EAAE;IAAA,IAAA,CAE5BwP,OAAO,GAAgB,IAAIxP,GAAG,EAAE;IAAA,IAAA,CAEhCyP,SAAS,GAAgB,IAAIzP,GAAG,EAAE;IAGhC,IAAI,CAAC8C,KAAK,GAAGA,KAAK;EACpB;AACF;AAIe,MAAM4M,YAAY,CAA+B;EAM9DnsB,WAAWA,CAACosB,MAAiB,EAAEjE,QAAiB,EAAE;IAAA,IAAA,CALlDiE,MAAM,GAAA,KAAA,CAAA;IAAA,IACNC,CAAAA,UAAU,GAAkB,EAAE;IAAA,IAAA,CAC9BlE,QAAQ,GAAA,KAAA,CAAA;IAAA,IAAA,CACRmE,gBAAgB,GAA0B,IAAI/qB,GAAG,EAAE;IAGjD,IAAI,CAAC6qB,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACjE,QAAQ,GAAGA,QAAQ;EAC1B;EAEA,IAAIoE,UAAUA,CAAAA,EAAG;IACf,OAAO,CAAC,IAAI,CAACC,YAAY,EAAE,CAACjN,KAAK,GAAGyJ,aAAa,IAAI,CAAC;EACxD;EACA,IAAIyD,UAAUA,CAAAA,EAAG;IACf,OAAO,CAAC,IAAI,CAACC,oBAAoB,EAAE,GAAGzD,cAAc,IAAI,CAAC;EAC3D;EACA,IAAI0D,UAAUA,CAAAA,EAAG;IACf,OAAO,CAAC,IAAI,CAACC,qBAAqB,EAAE,GAAGxD,WAAW,IAAI,CAAC;EACzD;EACA,IAAInG,gBAAgBA,CAAAA,EAAG;IACrB,OAAO,CAAC,IAAI,CAAC2J,qBAAqB,EAAE,GAAGvD,kBAAkB,IAAI,CAAC;EAChE;EACA,IAAIwD,OAAOA,CAAAA,EAAG;IACZ,OAAO,CAAC,IAAI,CAACD,qBAAqB,EAAE,GAAGtD,WAAW,IAAI,CAAC;EACzD;EACA,IAAIwD,+BAA+BA,CAAAA,EAAG;IACpC,MAAMvN,KAAK,GAAG,IAAI,CAACqN,qBAAqB,EAAE;IAC1C,OAAO,CAACrN,KAAK,GAAG+J,WAAW,IAAI,CAAC,IAAI,CAAC/J,KAAK,GAAG0J,cAAc,MAAM,CAAC;EACpE;EACA,IAAI8D,aAAaA,CAAAA,EAAG;IAClB,KAAK,IAAIpe,CAAC,GAAG,IAAI,CAAC0d,UAAU,CAAClf,MAAM,GAAG,CAAC,GAAIwB,CAAC,EAAE,EAAE;MAC9C,MAAM;QAAE4Q;MAAM,CAAC,GAAG,IAAI,CAAC8M,UAAU,CAAC1d,CAAC,CAAC;MACpC,IAAI4Q,KAAK,GAAGgK,kBAAkB,EAAE;QAC9B,OAAO,IAAI;MACb;MACA,IAAIhK,KAAK,IAAIkK,SAAS,GAAGH,WAAW,CAAC,EAAE;QAErC,OAAO,KAAK;MACd;IACF;EACF;EACA,IAAI0D,kBAAkBA,CAAAA,EAAG;IACvB,OAAO,CAAC,IAAI,CAACJ,qBAAqB,EAAE,GAAG3D,cAAc,IAAI,CAAC;EAC5D;EACA,IAAIgE,mBAAmBA,CAAAA,EAAG;IACxB,OAAO,IAAI,CAACC,0BAA0B,CAAC,IAAI,CAACV,YAAY,EAAE,CAAC;EAC7D;EAEAW,WAAWA,CAAC5N,KAAiB,EAAS;IACpC,OAAO,IAAIwM,KAAK,CAACxM,KAAK,CAAC;EACzB;EAEA6N,KAAKA,CAAC7N,KAAiB,EAAE;IAGvB,IAAI,CAAC8M,UAAU,CAAC7pB,IAAI,CAAC,IAAI,CAAC2qB,WAAW,CAAC5N,KAAK,CAAC,CAAC;EAC/C;EAEA8N,IAAIA,CAAAA,EAAe;IACjB,MAAMC,KAAK,GAAG,IAAI,CAACjB,UAAU,CAACpf,GAAG,EAAE;IACnC,OAAOqgB,KAAK,CAAC/N,KAAK;EACpB;EAKA2N,0BAA0BA,CAACI,KAAa,EAAW;IACjD,OAAO,CAAC,EACNA,KAAK,CAAC/N,KAAK,IAAI0J,cAAc,GAAGM,kBAAkB,CAAC,IAClD,CAAC,IAAI,CAAC6C,MAAM,CAACjE,QAAQ,IAAImF,KAAK,CAAC/N,KAAK,GAAGyJ,aAAc,CACvD;EACH;EAEAuE,WAAWA,CAAC9rB,IAAY,EAAE+rB,WAAyB,EAAE5P,GAAa,EAAE;IAClE,IAAI0P,KAAK,GAAG,IAAI,CAACd,YAAY,EAAE;IAC/B,IAAIgB,WAAW,GAAG3D,kBAAkB,IAAI2D,WAAW,GAAG1D,mBAAmB,EAAE;MACzE,IAAI,CAAC2D,yBAAyB,CAACH,KAAK,EAAE7rB,IAAI,EAAE+rB,WAAW,EAAE5P,GAAG,CAAC;MAE7D,IAAI4P,WAAW,GAAG1D,mBAAmB,EAAE;QACrCwD,KAAK,CAACpB,SAAS,CAACwB,GAAG,CAACjsB,IAAI,CAAC;MAC3B,CAAC,MAAM;QACL6rB,KAAK,CAACrB,OAAO,CAACyB,GAAG,CAACjsB,IAAI,CAAC;MACzB;MAEA,IAAI+rB,WAAW,GAAG3D,kBAAkB,EAAE;QACpC,IAAI,CAAC8D,kBAAkB,CAACL,KAAK,EAAE7rB,IAAI,CAAC;MACtC;IACF,CAAC,MAAM,IAAI+rB,WAAW,GAAG5D,cAAc,EAAE;MACvC,KAAK,IAAIjb,CAAC,GAAG,IAAI,CAAC0d,UAAU,CAAClf,MAAM,GAAG,CAAC,EAAEwB,CAAC,IAAI,CAAC,EAAE,EAAEA,CAAC,EAAE;QACpD2e,KAAK,GAAG,IAAI,CAACjB,UAAU,CAAC1d,CAAC,CAAC;QAC1B,IAAI,CAAC8e,yBAAyB,CAACH,KAAK,EAAE7rB,IAAI,EAAE+rB,WAAW,EAAE5P,GAAG,CAAC;QAC7D0P,KAAK,CAACtB,GAAG,CAAC0B,GAAG,CAACjsB,IAAI,CAAC;QACnB,IAAI,CAACksB,kBAAkB,CAACL,KAAK,EAAE7rB,IAAI,CAAC;QAEpC,IAAI6rB,KAAK,CAAC/N,KAAK,GAAGkK,SAAS,EAAE;MAC/B;IACF;IACA,IAAI,IAAI,CAAC2C,MAAM,CAACjE,QAAQ,IAAImF,KAAK,CAAC/N,KAAK,GAAGyJ,aAAa,EAAE;MACvD,IAAI,CAACsD,gBAAgB,CAACsB,MAAM,CAACnsB,IAAI,CAAC;IACpC;EACF;EAEAksB,kBAAkBA,CAACL,KAAa,EAAE7rB,IAAY,EAAE;IAC9C,IAAI,IAAI,CAAC2qB,MAAM,CAACjE,QAAQ,IAAImF,KAAK,CAAC/N,KAAK,GAAGyJ,aAAa,EAAE;MACvD,IAAI,CAACsD,gBAAgB,CAACsB,MAAM,CAACnsB,IAAI,CAAC;IACpC;EACF;EAEAgsB,yBAAyBA,CACvBH,KAAa,EACb7rB,IAAY,EACZ+rB,WAAyB,EACzB5P,GAAa,EACb;IACA,IAAI,IAAI,CAACiQ,mBAAmB,CAACP,KAAK,EAAE7rB,IAAI,EAAE+rB,WAAW,CAAC,EAAE;MACtD,IAAI,CAACpB,MAAM,CAACtH,KAAK,CAAClG,MAAM,CAAClD,gBAAgB,EAAE;QACzClX,EAAE,EAAEoZ,GAAG;QACP/P,cAAc,EAAEpM;MAClB,CAAC,CAAC;IACJ;EACF;EAEAosB,mBAAmBA,CACjBP,KAAa,EACb7rB,IAAY,EACZ+rB,WAAyB,EAChB;IACT,IAAI,EAAEA,WAAW,GAAG9D,eAAe,CAAC,EAAE,OAAO,KAAK;IAElD,IAAI8D,WAAW,GAAG3D,kBAAkB,EAAE;MACpC,OACEyD,KAAK,CAACrB,OAAO,CAAC5D,GAAG,CAAC5mB,IAAI,CAAC,IACvB6rB,KAAK,CAACpB,SAAS,CAAC7D,GAAG,CAAC5mB,IAAI,CAAC,IACzB6rB,KAAK,CAACtB,GAAG,CAAC3D,GAAG,CAAC5mB,IAAI,CAAC;IAEvB;IAEA,IAAI+rB,WAAW,GAAG1D,mBAAmB,EAAE;MACrC,OACEwD,KAAK,CAACrB,OAAO,CAAC5D,GAAG,CAAC5mB,IAAI,CAAC,IACtB,CAAC,IAAI,CAACyrB,0BAA0B,CAACI,KAAK,CAAC,IAAIA,KAAK,CAACtB,GAAG,CAAC3D,GAAG,CAAC5mB,IAAI,CAAE;IAEpE;IAEA,OACG6rB,KAAK,CAACrB,OAAO,CAAC5D,GAAG,CAAC5mB,IAAI,CAAC,IAGtB,EACE6rB,KAAK,CAAC/N,KAAK,GAAG4J,kBAAkB,IAChCmE,KAAK,CAACrB,OAAO,CAAC6B,MAAM,EAAE,CAACnF,IAAI,EAAE,CAACla,KAAK,KAAKhN,IAAI,CAC7C,IACF,CAAC,IAAI,CAACyrB,0BAA0B,CAACI,KAAK,CAAC,IAAIA,KAAK,CAACpB,SAAS,CAAC7D,GAAG,CAAC5mB,IAAI,CAAE;EAE1E;EAEAssB,gBAAgBA,CAACnL,EAAgB,EAAE;IACjC,MAAM;MAAEnhB;IAAM,CAAA,GAAGmhB,EAAE;IACnB,MAAMoL,aAAa,GAAG,IAAI,CAAC3B,UAAU,CAAC,CAAC,CAAC;IACxC,IACE,CAAC2B,aAAa,CAAC/B,OAAO,CAAC5D,GAAG,CAAC5mB,IAAI,CAAC,IAChC,CAACusB,aAAa,CAAChC,GAAG,CAAC3D,GAAG,CAAC5mB,IAAI,CAAC,IAI5B,CAACusB,aAAa,CAAC9B,SAAS,CAAC7D,GAAG,CAAC5mB,IAAI,CAAC,EAClC;MACA,IAAI,CAAC6qB,gBAAgB,CAAC3qB,GAAG,CAACF,IAAI,EAAEmhB,EAAE,CAAChF,GAAG,CAAClQ,KAAK,CAAC;IAC/C;EACF;EAEA8e,YAAYA,CAAAA,EAAW;IACrB,OAAO,IAAI,CAACH,UAAU,CAAC,IAAI,CAACA,UAAU,CAAClf,MAAM,GAAG,CAAC,CAAC;EACpD;EAEAuf,oBAAoBA,CAAAA,EAAe;IACjC,KAAK,IAAI/d,CAAC,GAAG,IAAI,CAAC0d,UAAU,CAAClf,MAAM,GAAG,CAAC,GAAIwB,CAAC,EAAE,EAAE;MAC9C,MAAM;QAAE4Q;MAAM,CAAC,GAAG,IAAI,CAAC8M,UAAU,CAAC1d,CAAC,CAAC;MACpC,IAAI4Q,KAAK,GAAGkK,SAAS,EAAE;QACrB,OAAOlK,KAAK;MACd;IACF;EACF;EAGAqN,qBAAqBA,CAAAA,EAAe;IAClC,KAAK,IAAIje,CAAC,GAAG,IAAI,CAAC0d,UAAU,CAAClf,MAAM,GAAG,CAAC,GAAIwB,CAAC,EAAE,EAAE;MAC9C,MAAM;QAAE4Q;MAAM,CAAC,GAAG,IAAI,CAAC8M,UAAU,CAAC1d,CAAC,CAAC;MACpC,IAAI4Q,KAAK,IAAIkK,SAAS,GAAGH,WAAW,CAAC,IAAI,EAAE/J,KAAK,GAAG2J,WAAW,CAAC,EAAE;QAC/D,OAAO3J,KAAK;MACd;IACF;EACF;AACF;AC/NA,MAAM0O,SAAS,SAASlC,KAAK,CAAC;EAAA/rB,WAAAA,CAAA,GAAAwjB,IAAA,EAAA;IAAA,KAAA,CAAA,GAAAA,IAAA,CAAA;IAAA,IAAA,CAE5B0K,gBAAgB,GAAgB,IAAIzR,GAAG,EAAE;EAAA;AAC3C;AAEe,MAAM0R,gBAAgB,SAAShC,YAAY,CAAY;EACpEgB,WAAWA,CAAC5N,KAAiB,EAAa;IACxC,OAAO,IAAI0O,SAAS,CAAC1O,KAAK,CAAC;EAC7B;EAEAgO,WAAWA,CAAC9rB,IAAY,EAAE+rB,WAAyB,EAAE5P,GAAa,EAAE;IAClE,MAAM0P,KAAK,GAAG,IAAI,CAACd,YAAY,EAAE;IACjC,IAAIgB,WAAW,GAAGpD,0BAA0B,EAAE;MAC5C,IAAI,CAACqD,yBAAyB,CAACH,KAAK,EAAE7rB,IAAI,EAAE+rB,WAAW,EAAE5P,GAAG,CAAC;MAC7D,IAAI,CAAC+P,kBAAkB,CAACL,KAAK,EAAE7rB,IAAI,CAAC;MACpC6rB,KAAK,CAACY,gBAAgB,CAACR,GAAG,CAACjsB,IAAI,CAAC;MAChC;IACF;IAEA,KAAK,CAAC8rB,WAAW,CAAC9rB,IAAI,EAAE+rB,WAAW,EAAE5P,GAAG,CAAC;EAC3C;EAEAiQ,mBAAmBA,CACjBP,KAAgB,EAChB7rB,IAAY,EACZ+rB,WAAyB,EAChB;IACT,IAAI,KAAK,CAACK,mBAAmB,CAACP,KAAK,EAAE7rB,IAAI,EAAE+rB,WAAW,CAAC,EAAE,OAAO,IAAI;IAEpE,IAAIA,WAAW,GAAGpD,0BAA0B,EAAE;MAC5C,OACE,CAACkD,KAAK,CAACY,gBAAgB,CAAC7F,GAAG,CAAC5mB,IAAI,CAAC,KAChC6rB,KAAK,CAACrB,OAAO,CAAC5D,GAAG,CAAC5mB,IAAI,CAAC,IAAI6rB,KAAK,CAACpB,SAAS,CAAC7D,GAAG,CAAC5mB,IAAI,CAAC,CAAC;IAE1D;IAEA,OAAO,KAAK;EACd;EAEAssB,gBAAgBA,CAACnL,EAAgB,EAAE;IACjC,IAAI,CAAC,IAAI,CAACyJ,UAAU,CAAC,CAAC,CAAC,CAAC6B,gBAAgB,CAAC7F,GAAG,CAACzF,EAAE,CAACnhB,IAAI,CAAC,EAAE;MACrD,KAAK,CAACssB,gBAAgB,CAACnL,EAAE,CAAC;IAC5B;EACF;AACF;ACzCe,MAAMwL,UAAU,CAAC;EAAApuB,WAAAA,CAAA,EAAA;IAAA,IAa9BquB,CAAAA,iBAAiB,GAAY,KAAK;IAAA,IAClCC,CAAAA,2BAA2B,GAAY,KAAK;EAAA;EAa5CjJ,SAASA,CAACkJ,YAA0B,EAAW;IAC7C,IAAI,OAAOA,YAAY,KAAK,QAAQ,EAAE;MACpC,OAAO,IAAI,CAACvvB,OAAO,CAACqpB,GAAG,CAACkG,YAAY,CAAC;IACvC,CAAC,MAAM;MACL,MAAM,CAACC,UAAU,EAAEC,aAAa,CAAC,GAAGF,YAAY;MAChD,IAAI,CAAC,IAAI,CAAClJ,SAAS,CAACmJ,UAAU,CAAC,EAAE;QAC/B,OAAO,KAAK;MACd;MACA,MAAME,aAAa,GAAG,IAAI,CAAC1vB,OAAO,CAACsP,GAAG,CAACkgB,UAAU,CAAC;MAClD,KAAK,MAAM5uB,GAAG,IAAIC,MAAM,CAACC,IAAI,CAC3B2uB,aAAa,CACd,EAAoC;QACnC,IAAI,CAAAC,aAAa,IAAbA,IAAAA,GAAAA,KAAAA,CAAAA,GAAAA,aAAa,CAAG9uB,GAAG,CAAC,MAAK6uB,aAAa,CAAC7uB,GAAG,CAAC,EAAE;UAC/C,OAAO,KAAK;QACd;MACF;MACA,OAAO,IAAI;IACb;EACF;EAEA6iB,eAAeA,CAGbkM,MAAkB,EAAEltB,IAAgB,EAAE;IAAA,IAAAmtB,iBAAA;IACtC,OAAA,CAAAA,iBAAA,GAAQ,IAAI,CAAC5vB,OAAO,CAACsP,GAAG,CAACqgB,MAAM,CAAC,KAAA,IAAA,GAAA,KAAA,CAAA,GAAzBC,iBAAA,CACLntB,IAAI,CACL;EACH;AACF;AC1BA,SAASotB,mBAAmBA,CAAC9P,IAAkB,EAAE+P,QAAwB,EAAE;EACzE,IAAI/P,IAAI,CAACgQ,gBAAgB,KAAKxwB,SAAS,EAAE;IACvCwgB,IAAI,CAACgQ,gBAAgB,GAAGD,QAAQ;EAClC,CAAC,MAAM;IACL/P,IAAI,CAACgQ,gBAAgB,CAACC,OAAO,CAAC,GAAGF,QAAQ,CAAC;EAC5C;AACF;AAOA,SAASG,kBAAkBA,CAAClQ,IAAkB,EAAE+P,QAAwB,EAAE;EACxE,IAAI/P,IAAI,CAACmQ,eAAe,KAAK3wB,SAAS,EAAE;IACtCwgB,IAAI,CAACmQ,eAAe,GAAGJ,QAAQ;EACjC,CAAC,MAAM;IACL/P,IAAI,CAACmQ,eAAe,CAACF,OAAO,CAAC,GAAGF,QAAQ,CAAC;EAC3C;AACF;AAOO,SAASK,gBAAgBA,CAC9BpQ,IAAkB,EAClB+P,QAAyB,EACzB;EACA,IAAI/P,IAAI,CAACqQ,aAAa,KAAK7wB,SAAS,EAAE;IACpCwgB,IAAI,CAACqQ,aAAa,GAAGN,QAAQ;EAC/B,CAAC,MAAM;IACL/P,IAAI,CAACqQ,aAAa,CAACJ,OAAO,CAAC,GAAGF,QAAQ,CAAC;EACzC;AACF;AAOA,SAASO,mBAAmBA,CAC1BtQ,IAAkB,EAClBuQ,QAAqB,EACrBC,SAA4B,EAC5B;EACA,IAAIC,WAAW,GAAG,IAAI;EACtB,IAAI7gB,CAAC,GAAG2gB,QAAQ,CAACniB,MAAM;EACvB,OAAOqiB,WAAW,KAAK,IAAI,IAAI7gB,CAAC,GAAG,CAAC,EAAE;IACpC6gB,WAAW,GAAGF,QAAQ,CAAC,EAAE3gB,CAAC,CAAC;EAC7B;EACA,IAAI6gB,WAAW,KAAK,IAAI,IAAIA,WAAW,CAAC9hB,KAAK,GAAG6hB,SAAS,CAAC7hB,KAAK,EAAE;IAC/DyhB,gBAAgB,CAACpQ,IAAI,EAAEwQ,SAAS,CAACT,QAAQ,CAAC;EAC5C,CAAC,MAAM;IACLD,mBAAmB,CAACW,WAAW,EAAED,SAAS,CAACT,QAAQ,CAAC;EACtD;AACF;AAEe,MAAMW,cAAc,SAASrB,UAAU,CAAC;EACrDsB,UAAUA,CAACC,OAAgB,EAAQ;IACjC,IAAI,IAAI,CAAC/hB,QAAQ,EAAE+hB,OAAO,CAAC/R,GAAG,CAAChQ,QAAQ,GAAG,IAAI,CAACA,QAAQ;IACvD,IAAI,CAACgY,KAAK,CAACkJ,QAAQ,CAACtsB,IAAI,CAACmtB,OAAO,CAAC;EACnC;EAMAC,cAAcA,CAAC7Q,IAAU,EAAQ;IAC/B,MAAM;MAAE8Q;KAAc,GAAG,IAAI,CAACjK,KAAK;IACnC,MAAMkK,kBAAkB,GAAGD,YAAY,CAAC1iB,MAAM;IAC9C,IAAI2iB,kBAAkB,KAAK,CAAC,EAAE;IAC9B,IAAInhB,CAAC,GAAGmhB,kBAAkB,GAAG,CAAC;IAC9B,MAAMC,aAAa,GAAGF,YAAY,CAAClhB,CAAC,CAAC;IAErC,IAAIohB,aAAa,CAACriB,KAAK,KAAKqR,IAAI,CAACpR,GAAG,EAAE;MACpCoiB,aAAa,CAACC,WAAW,GAAGjR,IAAI;MAChCpQ,CAAC,EAAE;IACL;IAEA,MAAM;MAAEjB,KAAK,EAAEuiB;IAAW,CAAA,GAAGlR,IAAI;IAEjC,OAAOpQ,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;MAClB,MAAM4gB,SAAS,GAAGM,YAAY,CAAClhB,CAAC,CAAC;MACjC,MAAMuhB,UAAU,GAAGX,SAAS,CAAC5hB,GAAG;MAChC,IAAIuiB,UAAU,GAAGD,SAAS,EAAE;QAO1BV,SAAS,CAACY,cAAc,GAAGpR,IAAI;QAC/B,IAAI,CAACqR,eAAe,CAACb,SAAS,CAAC;QAC/BM,YAAY,CAACQ,MAAM,CAAC1hB,CAAC,EAAE,CAAC,CAAC;MAC3B,CAAC,MAAM;QACL,IAAIuhB,UAAU,KAAKD,SAAS,EAAE;UAC5BV,SAAS,CAACe,YAAY,GAAGvR,IAAI;QAC/B;QAEA;MACF;IACF;EACF;EAMAqR,eAAeA,CAACb,SAA4B,EAAE;IAC5C,MAAM;MAAET;IAAU,CAAA,GAAGS,SAAS;IAC9B,IAAIA,SAAS,CAACS,WAAW,KAAK,IAAI,IAAIT,SAAS,CAACe,YAAY,KAAK,IAAI,EAAE;MACrE,IAAIf,SAAS,CAACS,WAAW,KAAK,IAAI,EAAE;QAClCnB,mBAAmB,CAACU,SAAS,CAACS,WAAW,EAAElB,QAAQ,CAAC;MACtD;MACA,IAAIS,SAAS,CAACe,YAAY,KAAK,IAAI,EAAE;QACnCrB,kBAAkB,CAACM,SAAS,CAACe,YAAY,EAAExB,QAAQ,CAAC;MACtD;IACF,CAAC,MAAM;MAEL,MAAM;QAAEqB,cAAc,EAAEpR,IAAI;QAAErR,KAAK,EAAE6iB;MAAc,CAAA,GAAGhB,SAAS;MAC/D,IAAI,IAAI,CAACiB,KAAK,CAACC,UAAU,CAACF,YAAY,GAAG,CAAC,CAAC,KAAA,EAAoB,EAAE;QAI/D,QAAQxR,IAAI,CAAC3N,IAAI;UACf,KAAK,kBAAkB;UACvB,KAAK,eAAe;UACpB,KAAK,kBAAkB;YACrBie,mBAAmB,CAACtQ,IAAI,EAAEA,IAAI,CAAClQ,UAAU,EAAE0gB,SAAS,CAAC;YACrD;UACF,KAAK,gBAAgB;UACrB,KAAK,wBAAwB;YAC3BF,mBAAmB,CAACtQ,IAAI,EAAEA,IAAI,CAACqG,SAAS,EAAEmK,SAAS,CAAC;YACpD;UACF,KAAK,qBAAqB;UAC1B,KAAK,oBAAoB;UACzB,KAAK,yBAAyB;UAC9B,KAAK,cAAc;UACnB,KAAK,aAAa;UAClB,KAAK,oBAAoB;YACvBF,mBAAmB,CAACtQ,IAAI,EAAEA,IAAI,CAACqC,MAAM,EAAEmO,SAAS,CAAC;YACjD;UACF,KAAK,iBAAiB;UACtB,KAAK,cAAc;UACnB,KAAK,iBAAiB;YACpBF,mBAAmB,CAACtQ,IAAI,EAAEA,IAAI,CAACuQ,QAAQ,EAAEC,SAAS,CAAC;YACnD;UACF,KAAK,wBAAwB;UAC7B,KAAK,mBAAmB;YACtBF,mBAAmB,CAACtQ,IAAI,EAAEA,IAAI,CAACgH,UAAU,EAAEwJ,SAAS,CAAC;YACrD;UACF;YAAS;cACPJ,gBAAgB,CAACpQ,IAAI,EAAE+P,QAAQ,CAAC;YAClC;QAAA;MAEJ,CAAC,MAAM;QACLK,gBAAgB,CAACpQ,IAAI,EAAE+P,QAAQ,CAAC;MAClC;IACF;EACF;EAQA4B,yBAAyBA,CAAAA,EAAG;IAC1B,MAAM;MAAEb;KAAc,GAAG,IAAI,CAACjK,KAAK;IACnC,KAAK,IAAIjX,CAAC,GAAGkhB,YAAY,CAAC1iB,MAAM,GAAG,CAAC,EAAEwB,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;MACjD,IAAI,CAACyhB,eAAe,CAACP,YAAY,CAAClhB,CAAC,CAAC,CAAC;IACvC;IACA,IAAI,CAACiX,KAAK,CAACiK,YAAY,GAAG,EAAE;EAC9B;EAqBAc,iCAAiCA,CAAC5R,IAAU,EAAE;IAC5C,MAAM;MAAE8Q;KAAc,GAAG,IAAI,CAACjK,KAAK;IACnC,MAAM;MAAEzY;IAAQ,CAAA,GAAG0iB,YAAY;IAC/B,IAAI1iB,MAAM,KAAK,CAAC,EAAE;IAClB,MAAMoiB,SAAS,GAAGM,YAAY,CAAC1iB,MAAM,GAAG,CAAC,CAAC;IAC1C,IAAIoiB,SAAS,CAACS,WAAW,KAAKjR,IAAI,EAAE;MAClCwQ,SAAS,CAACS,WAAW,GAAG,IAAI;IAC9B;EACF;EASAY,uBAAuBA,CAAC7R,IAAU,EAAErR,KAAa,EAAEC,GAAW,EAAE;IAC9D,MAAM;MAAEkiB;KAAc,GAAG,IAAI,CAACjK,KAAK;IACnC,MAAMkK,kBAAkB,GAAGD,YAAY,CAAC1iB,MAAM;IAC9C,IAAI2iB,kBAAkB,KAAK,CAAC,EAAE;IAC9B,IAAInhB,CAAC,GAAGmhB,kBAAkB,GAAG,CAAC;IAE9B,OAAOnhB,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;MAClB,MAAM4gB,SAAS,GAAGM,YAAY,CAAClhB,CAAC,CAAC;MACjC,MAAMuhB,UAAU,GAAGX,SAAS,CAAC5hB,GAAG;MAChC,MAAM4iB,YAAY,GAAGhB,SAAS,CAAC7hB,KAAK;MAEpC,IAAI6iB,YAAY,KAAK5iB,GAAG,EAAE;QACxB4hB,SAAS,CAACS,WAAW,GAAGjR,IAAI;MAC9B,CAAC,MAAM,IAAImR,UAAU,KAAKxiB,KAAK,EAAE;QAC/B6hB,SAAS,CAACe,YAAY,GAAGvR,IAAI;MAC/B,CAAC,MAAM,IAAImR,UAAU,GAAGxiB,KAAK,EAAE;QAC7B;MACF;IACF;EACF;AACF;AC/QO,MAAMmjB,SAAS,GAAG,wBAAwB;AAC1C,MAAMC,UAAU,GAAG,IAAIrR,MAAM,CAACoR,SAAS,CAAC1L,MAAM,EAAE,GAAG,CAAC;AAGpD,SAAS4L,SAASA,CAACrhB,IAAY,EAAW;EAC/C,QAAQA,IAAI;IACV,KAAA,EAAA;IACA,KAAA,EAAA;IACA,KAAA,IAAA;IACA,KAAA,IAAA;MACE,OAAO,IAAI;IAEb;MACE,OAAO,KAAK;EAAA;AAElB;AAEO,MAAMshB,cAAc,GAAG,+BAA+B;AAEtD,MAAMC,oBAAoB,GAC/B,gDAAgD;AAM3C,MAAMC,yBAAyB,GAAG,IAAIzR,MAAM,CAIjD,MAAM,GAGJwR,oBAAoB,CAAC9L,MAAM,GAC3B,OAAO,GAGP,0CAA0C,CAACA,MAAM,EACnD,GAAG,CACJ;AAGM,SAASgM,YAAYA,CAACzhB,IAAY,EAAW;EAClD,QAAQA,IAAI;IACV,KAAK,MAAM;IACX,KAAK,MAAM;IACX,KAAK,MAAM;IACX,KAAA,EAAA;IACA,KAAA,GAAA;IACA,KAAA,IAAA;IACA,KAAK,MAAM;IACX,KAAK,MAAM;IACX,KAAK,MAAM;IACX,KAAK,MAAM;IACX,KAAK,MAAM;IACX,KAAK,MAAM;IACX,KAAK,MAAM;IACX,KAAK,MAAM;IACX,KAAK,MAAM;IACX,KAAK,MAAM;IACX,KAAK,MAAM;IACX,KAAK,MAAM;IACX,KAAK,MAAM;IACX,KAAK,MAAM;IACX,KAAK,MAAM;MACT,OAAO,IAAI;IAEb;MACE,OAAO,KAAK;EAAA;AAElB;AChDe,MAAM0hB,KAAK,CAAC;EAAApxB,WAAAA,CAAA,EAAA;IAAA,IAAA,CACzB6nB,MAAM,GAAA,KAAA,CAAA;IAAA,IAAA,CACNwJ,OAAO,GAAA,KAAA,CAAA;IAAA,IAAA,CACPC,SAAS,GAAA,KAAA,CAAA;IAAA,IAAA,CAITrN,QAAQ,GAAA,KAAA,CAAA;IAAA,IAAA,CACR6C,MAAM,GAAA,KAAA,CAAA;IAAA,IAeNyK,CAAAA,MAAM,GAAsB,EAAE;IAAA,IAG9BC,CAAAA,gBAAgB,GAAW,CAAC,CAAC;IAAA,IAM7BC,CAAAA,SAAS,GAAa,EAAE;IAAA,IAQxBC,CAAAA,yBAAyB,GAAa,EAAE;IAAA,IAGxCC,CAAAA,sBAAsB,GAAY,KAAK;IAAA,IACvCC,CAAAA,MAAM,GAAY,KAAK;IAAA,IACvBC,CAAAA,kBAAkB,GAAY,KAAK;IAAA,IACnCC,CAAAA,cAAc,GAAY,KAAK;IAAA,IAC/BC,CAAAA,gBAAgB,GAAY,KAAK;IAAA,IACjCC,CAAAA,eAAe,GAAY,KAAK;IAAA,IAChCC,CAAAA,iCAAiC,GAAY,KAAK;IAAA,IAAA,CAGlDC,YAAY,GAAsB;MAChCC,wBAAwB,EAAE,CAAC;MAC3BC,aAAa,EAAE;KAChB;IAAA,IAGDC,CAAAA,SAAS,GAAY,KAAK;IAAA,IAC1BC,CAAAA,0BAA0B,GAAY,KAAK;IAAA,IAG3CC,CAAAA,MAAM,GAID,EAAE;IAAA,IAGPzD,CAAAA,QAAQ,GAAqB,EAAE;IAAA,IAG/Be,CAAAA,YAAY,GAA6B,EAAE;IAAA,IAG3C7R,CAAAA,GAAG,GAAW,CAAC;IAAA,IAAA,CAIf5M,IAAI,GAAA,GAAA;IAAA,IAGJ3C,CAAAA,KAAK,GAAQ,IAAI;IAAA,IAGjBf,CAAAA,KAAK,GAAW,CAAC;IAAA,IACjBC,CAAAA,GAAG,GAAW,CAAC;IAAA,IAIfqZ,CAAAA,aAAa,GAAa,IAAI;IAAA,IAE9BnB,CAAAA,eAAe,GAAa,IAAI;IAAA,IAChC2M,CAAAA,YAAY,GAAW,CAAC;IAAA,IAAA,CAIxBxlB,OAAO,GAAsB,CAACylB,KAAE,CAACryB,KAAK,CAAC;IAAA,IAEvCsyB,CAAAA,kBAAkB,GAAY,IAAI;IAAA,IAKlCC,CAAAA,WAAW,GAAY,KAAK;IAAA,IAI5BC,CAAAA,6BAA6B,GAAoB,IAAI;IAAA,IAAA,CAUrDC,YAAY,GAAiD,IAAItxB,GAAG,EAAE;IAAA,IAGtEuxB,CAAAA,YAAY,GAAW,CAAC;EAAA;EA/GxBC,IAAIA,CAAC;IAAE9zB,UAAU;IAAEZ,UAAU;IAAEI,SAAS;IAAED;EAAqB,CAAC,EAAQ;IACtE,IAAI,CAACqpB,MAAM,GACT5oB,UAAU,KAAK,KAAK,GAChB,KAAK,GACLA,UAAU,KAAK,IAAI,GACnB,IAAI,GACJZ,UAAU,KAAK,QAAQ;IAE7B,IAAI,CAACgzB,OAAO,GAAG5yB,SAAS;IACxB,IAAI,CAAC6yB,SAAS,GAAG,CAAC9yB,WAAW;IAC7B,IAAI,CAACylB,QAAQ,GAAG,IAAI,CAAC6C,MAAM,GAAG,IAAI1Z,QAAQ,CAAC3O,SAAS,EAAED,WAAW,EAAE,CAAC,CAAC;EACvE;EAsGAw0B,WAAWA,CAAAA,EAAa;IACtB,OAAO,IAAI5lB,QAAQ,CAAC,IAAI,CAACikB,OAAO,EAAE,IAAI,CAACrT,GAAG,GAAG,IAAI,CAACsT,SAAS,EAAE,IAAI,CAACtT,GAAG,CAAC;EACxE;EAEAF,KAAKA,CAACmV,UAAoB,EAAS;IACjC,MAAMrN,KAAK,GAAG,IAAIwL,KAAK,EAAE;IACzB,MAAMtxB,IAAI,GAAGD,MAAM,CAACC,IAAI,CAAC,IAAI,CAAoB;IACjD,KAAK,IAAI6O,CAAC,GAAG,CAAC,EAAExB,MAAM,GAAGrN,IAAI,CAACqN,MAAM,EAAEwB,CAAC,GAAGxB,MAAM,EAAEwB,CAAC,EAAE,EAAE;MACrD,MAAM/O,GAAG,GAAGE,IAAI,CAAC6O,CAAC,CAAC;MACnB,IAAIukB,GAAG,GAAG,IAAI,CAACtzB,GAAG,CAAC;MAEnB,IAAI,CAACqzB,UAAU,IAAI7U,KAAK,CAACC,OAAO,CAAC6U,GAAG,CAAC,EAAE;QACrCA,GAAG,GAAGA,GAAG,CAACC,KAAK,EAAE;MACnB;MAGAvN,KAAK,CAAChmB,GAAG,CAAC,GAAGszB,GAAG;IAClB;IAEA,OAAOtN,KAAK;EACd;AACF;eC1KA,SAASwN,OAAOA,CAAC1jB,IAAI,EAAE;EACrB,OAAOA,IAAI,IAAA,EAAU,IAAIA,IAAI,IAAU,EAAA;AACzC,CAAC;AAED,MAAM2jB,iCAAiC,GAAG;EACxCC,SAAS,EAAE,IAAI7W,GAAG,CAAS,kCAS1B,CAAC;EACF8W,GAAG,EAAE,IAAI9W,GAAG,CAAS,CAKpB,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,CAAA;AACH,CAAC;AAED,MAAM+W,gCAAgC,GAAG;EAEvCC,GAAG,EAAGC,EAAU,IAAKA,EAAE,KAAqB,EAAA,IAAIA,EAAE,KAAqB,EAAA;EAGvEC,GAAG,EAAGD,EAAU,IAAKA,EAAE,IAAoB,EAAA,IAAIA,EAAE,IAAoB,EAAA;EAGrEE,GAAG,EAAGF,EAAU,IAAKA,EAAE,IAAoB,EAAA,IAAIA,EAAE,IAAoB,EAAA;EAGrEH,GAAG,EAAGG,EAAU,IACbA,EAAE,IAAoB,EAAA,IAAIA,EAAE,IAAoB,EAAA,IAChDA,EAAE,IAAA,EAAwB,IAAIA,EAAE,IAAA,EAAyB,IACzDA,EAAE,IAAA,EAAwB,IAAIA,EAAE,IAAA;AACrC,CAAC;AAUM,SAASG,kBAAkBA,CAChCziB,IAAsC,EACtCof,KAAa,EACbxS,GAAW,EACXsT,SAAiB,EACjBD,OAAe,EACfE,MAAmC,EACnC;EACA,MAAMuC,UAAU,GAAG9V,GAAG;EACtB,MAAM+V,gBAAgB,GAAGzC,SAAS;EAClC,MAAM0C,cAAc,GAAG3C,OAAO;EAE9B,IAAI4C,GAAG,GAAG,EAAE;EACZ,IAAIC,eAAe,GAAG,IAAI;EAC1B,IAAIC,UAAU,GAAGnW,GAAG;EACpB,MAAM;IAAE7Q;EAAQ,CAAA,GAAGqjB,KAAK;EACxB,SAAS;IACP,IAAIxS,GAAG,IAAI7Q,MAAM,EAAE;MACjBokB,MAAM,CAAC6C,YAAY,CAACN,UAAU,EAAEC,gBAAgB,EAAEC,cAAc,CAAC;MACjEC,GAAG,IAAIzD,KAAK,CAAC2C,KAAK,CAACgB,UAAU,EAAEnW,GAAG,CAAC;MACnC;IACF;IACA,MAAM0V,EAAE,GAAGlD,KAAK,CAACC,UAAU,CAACzS,GAAG,CAAC;IAChC,IAAIqW,WAAW,CAACjjB,IAAI,EAAEsiB,EAAE,EAAElD,KAAK,EAAExS,GAAG,CAAC,EAAE;MACrCiW,GAAG,IAAIzD,KAAK,CAAC2C,KAAK,CAACgB,UAAU,EAAEnW,GAAG,CAAC;MACnC;IACF;IACA,IAAI0V,EAAE,OAAwB,EAAE;MAC9BO,GAAG,IAAIzD,KAAK,CAAC2C,KAAK,CAACgB,UAAU,EAAEnW,GAAG,CAAC;MACnC,MAAMsW,GAAG,GAAGC,eAAe,CACzB/D,KAAK,EACLxS,GAAG,EACHsT,SAAS,EACTD,OAAO,EACPjgB,IAAI,KAAK,UAAU,EACnBmgB,MAAM,CACP;MACD,IAAI+C,GAAG,CAACZ,EAAE,KAAK,IAAI,IAAI,CAACQ,eAAe,EAAE;QACvCA,eAAe,GAAG;UAAElW,GAAG;UAAEsT,SAAS;UAAED;SAAS;MAC/C,CAAC,MAAM;QACL4C,GAAG,IAAIK,GAAG,CAACZ,EAAE;MACf;MACA,CAAC;QAAE1V,GAAG;QAAEsT,SAAS;QAAED;MAAS,CAAA,GAAGiD,GAAG;MAClCH,UAAU,GAAGnW,GAAG;IACjB,CAAA,MAAM,IACL0V,EAAE,SAA4B,IAC9BA,EAAE,SAAiC,EACnC;MACA,EAAE1V,GAAG;MACL,EAAEqT,OAAO;MACTC,SAAS,GAAGtT,GAAG;IAChB,CAAA,MAAM,IAAI0V,EAAE,OAAuB,IAAIA,EAAE,OAA6B,EAAE;MACvE,IAAItiB,IAAI,KAAK,UAAU,EAAE;QACvB6iB,GAAG,IAAIzD,KAAK,CAAC2C,KAAK,CAACgB,UAAU,EAAEnW,GAAG,CAAC,GAAG,IAAI;QAC1C,EAAEA,GAAG;QACL,IACE0V,EAAE,KAA6B,EAAA,IAC/BlD,KAAK,CAACC,UAAU,CAACzS,GAAG,CAAC,KAAA,EAAuB,EAC5C;UACA,EAAEA,GAAG;QACP;QACA,EAAEqT,OAAO;QACT8C,UAAU,GAAG7C,SAAS,GAAGtT,GAAG;MAC9B,CAAC,MAAM;QACLuT,MAAM,CAAC6C,YAAY,CAACN,UAAU,EAAEC,gBAAgB,EAAEC,cAAc,CAAC;MACnE;IACF,CAAC,MAAM;MACL,EAAEhW,GAAG;IACP;EACF;EACA,OAAO;IACLA,GAAG;IACHwW,GAAG,EAAEP,GAAG;IACRC,eAAe;IACf5C,SAAS;IACTD,OAAO;IAIPoD,eAAe,EAAE,CAAC,CAACP;GACpB;AACH;AAEA,SAASG,WAAWA,CAClBjjB,IAAsC,EACtCsiB,EAAU,EACVlD,KAAa,EACbxS,GAAW,EACX;EACA,IAAI5M,IAAI,KAAK,UAAU,EAAE;IACvB,OACEsiB,EAAE,KAAA,EAA0B,IAC3BA,EAAE,OAAyB,IAC1BlD,KAAK,CAACC,UAAU,CAACzS,GAAG,GAAG,CAAC,CAAC,KAA8B,GAAA;EAE7D;EACA,OACE0V,EAAE,MAAMtiB,IAAI,KAAK,QAAQ,UAAiD,CAAC;AAE/E;AAOA,SAASmjB,eAAeA,CACtB/D,KAAa,EACbxS,GAAW,EACXsT,SAAiB,EACjBD,OAAe,EACfqD,UAAmB,EACnBnD,MAAgC,EAChC;EACA,MAAMoD,cAAc,GAAG,CAACD,UAAU;EAClC1W,GAAG,EAAE;EAEL,MAAMsW,GAAG,GAAIZ,EAAiB,KAAM;IAAE1V,GAAG;IAAE0V,EAAE;IAAEpC,SAAS;IAAED;EAAQ,CAAC,CAAC;EAEpE,MAAMqC,EAAE,GAAGlD,KAAK,CAACC,UAAU,CAACzS,GAAG,EAAE,CAAC;EAClC,QAAQ0V,EAAE;IACR,KAAA,GAAA;MACE,OAAOY,GAAG,CAAC,IAAI,CAAC;IAClB,KAAA,GAAA;MACE,OAAOA,GAAG,CAAC,IAAI,CAAC;IAClB,KAAA,GAAA;MAA2B;QACzB,IAAI5kB,IAAI;QACR,CAAC;UAAEA,IAAI;UAAEsO;QAAI,CAAC,GAAG4W,WAAW,CAC1BpE,KAAK,EACLxS,GAAG,EACHsT,SAAS,EACTD,OAAO,EACP,CAAC,EACD,KAAK,EACLsD,cAAc,EACdpD,MAAM,CACP;QACD,OAAO+C,GAAG,CAAC5kB,IAAI,KAAK,IAAI,GAAG,IAAI,GAAG2B,MAAM,CAACqW,YAAY,CAAChY,IAAI,CAAC,CAAC;MAC9D;IACA,KAAA,GAAA;MAA2B;QACzB,IAAIA,IAAI;QACR,CAAC;UAAEA,IAAI;UAAEsO;QAAI,CAAC,GAAG6W,aAAa,CAC5BrE,KAAK,EACLxS,GAAG,EACHsT,SAAS,EACTD,OAAO,EACPsD,cAAc,EACdpD,MAAM,CACP;QACD,OAAO+C,GAAG,CAAC5kB,IAAI,KAAK,IAAI,GAAG,IAAI,GAAG2B,MAAM,CAACyjB,aAAa,CAACplB,IAAI,CAAC,CAAC;MAC/D;IACA,KAAA,GAAA;MACE,OAAO4kB,GAAG,CAAC,IAAI,CAAC;IAClB,KAAA,EAAA;MACE,OAAOA,GAAG,CAAC,IAAI,CAAC;IAClB,KAAA,GAAA;MACE,OAAOA,GAAG,CAAC,QAAQ,CAAC;IACtB,KAAA,GAAA;MACE,OAAOA,GAAG,CAAC,IAAI,CAAC;IAClB,KAAA,EAAA;MACE,IAAI9D,KAAK,CAACC,UAAU,CAACzS,GAAG,CAAC,OAAuB,EAAE;QAChD,EAAEA,GAAG;MACP;IAEF,KAAA,EAAA;MACEsT,SAAS,GAAGtT,GAAG;MACf,EAAEqT,OAAO;IAEX,KAAA,IAAA;IACA,KAAA,IAAA;MACE,OAAOiD,GAAG,CAAC,EAAE,CAAC;IAChB,KAAA,EAAA;IACA,KAAA,EAAA;MACE,IAAII,UAAU,EAAE;QACd,OAAOJ,GAAG,CAAC,IAAI,CAAC;MAClB,CAAC,MAAM;QACL/C,MAAM,CAACwD,mBAAmB,CAAC/W,GAAG,GAAG,CAAC,EAAEsT,SAAS,EAAED,OAAO,CAAC;MACzD;IAEF;MACE,IAAIqC,EAAE,IAAA,EAAoB,IAAIA,EAAE,MAAoB,EAAE;QACpD,MAAMsB,QAAQ,GAAGhX,GAAG,GAAG,CAAC;QACxB,MAAMiX,KAAK,GAAGzE,KAAK,CAAC2C,KAAK,CAAC6B,QAAQ,EAAEhX,GAAG,GAAG,CAAC,CAAC,CAACiX,KAAK,CAAC,SAAS,CAAE;QAE9D,IAAIC,QAAQ,GAAGD,KAAK,CAAC,CAAC,CAAC;QAEvB,IAAIE,KAAK,GAAGC,QAAQ,CAACF,QAAQ,EAAE,CAAC,CAAC;QACjC,IAAIC,KAAK,GAAG,GAAG,EAAE;UACfD,QAAQ,GAAGA,QAAQ,CAAC/B,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;UAChCgC,KAAK,GAAGC,QAAQ,CAACF,QAAQ,EAAE,CAAC,CAAC;QAC/B;QACAlX,GAAG,IAAIkX,QAAQ,CAAC/nB,MAAM,GAAG,CAAC;QAC1B,MAAMwb,IAAI,GAAG6H,KAAK,CAACC,UAAU,CAACzS,GAAG,CAAC;QAClC,IACEkX,QAAQ,KAAK,GAAG,IAChBvM,IAAI,KAAqB,EAAA,IACzBA,IAAI,KAAA,EAAqB,EACzB;UACA,IAAI+L,UAAU,EAAE;YACd,OAAOJ,GAAG,CAAC,IAAI,CAAC;UAClB,CAAC,MAAM;YACL/C,MAAM,CAACwD,mBAAmB,CAACC,QAAQ,EAAE1D,SAAS,EAAED,OAAO,CAAC;UAC1D;QACF;QAEA,OAAOiD,GAAG,CAACjjB,MAAM,CAACqW,YAAY,CAACyN,KAAK,CAAC,CAAC;MACxC;MAEA,OAAOb,GAAG,CAACjjB,MAAM,CAACqW,YAAY,CAACgM,EAAE,CAAC,CAAC;EAAA;AAEzC;AAOA,SAASkB,WAAWA,CAClBpE,KAAa,EACbxS,GAAW,EACXsT,SAAiB,EACjBD,OAAe,EACfgE,GAAW,EACXC,QAAiB,EACjBX,cAAuB,EACvBpD,MAA4B,EAC5B;EACA,MAAMuC,UAAU,GAAG9V,GAAG;EACtB,IAAIuX,CAAC;EACL,CAAC;IAAEA,CAAC;IAAEvX;EAAK,CAAA,GAAGwX,OAAO,CACnBhF,KAAK,EACLxS,GAAG,EACHsT,SAAS,EACTD,OAAO,EACP,EAAE,EACFgE,GAAG,EACHC,QAAQ,EACR,KAAK,EACL/D,MAAM,EACY,CAACoD,cAAc,CAClC;EACD,IAAIY,CAAC,KAAK,IAAI,EAAE;IACd,IAAIZ,cAAc,EAAE;MAClBpD,MAAM,CAACkE,qBAAqB,CAAC3B,UAAU,EAAExC,SAAS,EAAED,OAAO,CAAC;IAC9D,CAAC,MAAM;MACLrT,GAAG,GAAG8V,UAAU,GAAG,CAAC;IACtB;EACF;EACA,OAAO;IAAEpkB,IAAI,EAAE6lB,CAAC;IAAEvX;GAAK;AACzB;AAuBO,SAASwX,OAAOA,CACrBhF,KAAa,EACbxS,GAAW,EACXsT,SAAiB,EACjBD,OAAe,EACf/b,KAAa,EACb+f,GAAuB,EACvBC,QAAiB,EACjBI,iBAAmC,EACnCnE,MAAwB,EACxBoE,WAAoB,EACpB;EACA,MAAMjoB,KAAK,GAAGsQ,GAAG;EACjB,MAAM4X,iBAAiB,GACrBtgB,KAAK,KAAK,EAAE,GACR+d,iCAAiC,CAACE,GAAG,GACrCF,iCAAiC,CAACC,SAAS;EACjD,MAAMuC,gBAAgB,GACpBvgB,KAAK,KAAK,EAAE,GACRke,gCAAgC,CAACD,GAAG,GACpCje,KAAK,KAAK,EAAE,GACZke,gCAAgC,CAACI,GAAG,GACpCte,KAAK,KAAK,CAAC,GACXke,gCAAgC,CAACG,GAAG,GACpCH,gCAAgC,CAACC,GAAG;EAE1C,IAAIqC,OAAO,GAAG,KAAK;EACnB,IAAIC,KAAK,GAAG,CAAC;EAEb,KAAK,IAAIpnB,CAAC,GAAG,CAAC,EAAE+Q,CAAC,GAAG2V,GAAG,IAAI,IAAI,GAAGW,QAAQ,GAAGX,GAAG,EAAE1mB,CAAC,GAAG+Q,CAAC,EAAE,EAAE/Q,CAAC,EAAE;IAC5D,MAAMe,IAAI,GAAG8gB,KAAK,CAACC,UAAU,CAACzS,GAAG,CAAC;IAClC,IAAIkV,GAAG;IAEP,IAAIxjB,IAAI,KAAyB,EAAA,IAAIgmB,iBAAiB,KAAK,MAAM,EAAE;MACjE,MAAMO,IAAI,GAAGzF,KAAK,CAACC,UAAU,CAACzS,GAAG,GAAG,CAAC,CAAC;MACtC,MAAM2K,IAAI,GAAG6H,KAAK,CAACC,UAAU,CAACzS,GAAG,GAAG,CAAC,CAAC;MAEtC,IAAI,CAAC0X,iBAAiB,EAAE;QACtB,IAAIC,WAAW,EAAE,OAAO;UAAEJ,CAAC,EAAE,IAAI;UAAEvX;SAAK;QACxCuT,MAAM,CAAC2E,gCAAgC,CAAClY,GAAG,EAAEsT,SAAS,EAAED,OAAO,CAAC;MAClE,CAAC,MAAM,IACL8E,MAAM,CAACC,KAAK,CAACzN,IAAI,CAAC,IAClB,CAACkN,gBAAgB,CAAClN,IAAI,CAAC,IACvBiN,iBAAiB,CAACvN,GAAG,CAAC4N,IAAI,CAAC,IAC3BL,iBAAiB,CAACvN,GAAG,CAACM,IAAI,CAAC,EAC3B;QACA,IAAIgN,WAAW,EAAE,OAAO;UAAEJ,CAAC,EAAE,IAAI;UAAEvX;SAAK;QACxCuT,MAAM,CAAC8E,0BAA0B,CAACrY,GAAG,EAAEsT,SAAS,EAAED,OAAO,CAAC;MAC5D;MAGA,EAAErT,GAAG;MACL;IACF;IAEA,IAAItO,IAAI,MAAwB,EAAE;MAChCwjB,GAAG,GAAGxjB,IAAI,GAAA,EAAuB,GAAqB,EAAA;IACxD,CAAC,MAAM,IAAIA,IAAI,IAAA,EAAwB,EAAE;MACvCwjB,GAAG,GAAGxjB,IAAI,GAAA,EAAuB,GAAqB,EAAA;IACxD,CAAC,MAAM,IAAI4mB,QAAA,CAAkB5mB,IAAI,CAAC,EAAE;MAClCwjB,GAAG,GAAGxjB,IAAI,GAAmB,EAAA;IAC/B,CAAC,MAAM;MACLwjB,GAAG,GAAG8C,QAAQ;IAChB;IACA,IAAI9C,GAAG,IAAI5d,KAAK,EAAE;MAGhB,IAAI4d,GAAG,IAAI,CAAC,IAAIyC,WAAW,EAAE;QAC3B,OAAO;UAAEJ,CAAC,EAAE,IAAI;UAAEvX;SAAK;MACzB,CAAC,MAAM,IACLkV,GAAG,IAAI,CAAC,IACR3B,MAAM,CAACgF,YAAY,CAACvY,GAAG,EAAEsT,SAAS,EAAED,OAAO,EAAE/b,KAAK,CAAC,EACnD;QACA4d,GAAG,GAAG,CAAC;MACR,CAAA,MAAM,IAAIoC,QAAQ,EAAE;QACnBpC,GAAG,GAAG,CAAC;QACP4C,OAAO,GAAG,IAAI;MAChB,CAAC,MAAM;QACL;MACF;IACF;IACA,EAAE9X,GAAG;IACL+X,KAAK,GAAGA,KAAK,GAAGzgB,KAAK,GAAG4d,GAAG;EAC7B;EACA,IAAIlV,GAAG,KAAKtQ,KAAK,IAAK2nB,GAAG,IAAI,IAAI,IAAIrX,GAAG,GAAGtQ,KAAK,KAAK2nB,GAAI,IAAIS,OAAO,EAAE;IACpE,OAAO;MAAEP,CAAC,EAAE,IAAI;MAAEvX;KAAK;EACzB;EAEA,OAAO;IAAEuX,CAAC,EAAEQ,KAAK;IAAE/X;GAAK;AAC1B;AAMO,SAAS6W,aAAaA,CAC3BrE,KAAa,EACbxS,GAAW,EACXsT,SAAiB,EACjBD,OAAe,EACfsD,cAAuB,EACvBpD,MAA8B,EAC9B;EACA,MAAMmC,EAAE,GAAGlD,KAAK,CAACC,UAAU,CAACzS,GAAG,CAAC;EAChC,IAAItO,IAAI;EAER,IAAIgkB,EAAE,QAA6B,EAAE;IACnC,EAAE1V,GAAG;IACL,CAAC;MAAEtO,IAAI;MAAEsO;KAAK,GAAG4W,WAAW,CAC1BpE,KAAK,EACLxS,GAAG,EACHsT,SAAS,EACTD,OAAO,EACPb,KAAK,CAACgG,OAAO,CAAC,GAAG,EAAExY,GAAG,CAAC,GAAGA,GAAG,EAC7B,IAAI,EACJ2W,cAAc,EACdpD,MAAM,CACP;IACD,EAAEvT,GAAG;IACL,IAAItO,IAAI,KAAK,IAAI,IAAIA,IAAI,GAAG,QAAQ,EAAE;MACpC,IAAIilB,cAAc,EAAE;QAClBpD,MAAM,CAACkF,gBAAgB,CAACzY,GAAG,EAAEsT,SAAS,EAAED,OAAO,CAAC;MAClD,CAAC,MAAM;QACL,OAAO;UAAE3hB,IAAI,EAAE,IAAI;UAAEsO;SAAK;MAC5B;IACF;EACF,CAAC,MAAM;IACL,CAAC;MAAEtO,IAAI;MAAEsO;IAAI,CAAC,GAAG4W,WAAW,CAC1BpE,KAAK,EACLxS,GAAG,EACHsT,SAAS,EACTD,OAAO,EACP,CAAC,EACD,KAAK,EACLsD,cAAc,EACdpD,MAAM,CACP;EACH;EACA,OAAO;IAAE7hB,IAAI;IAAEsO;GAAK;AACtB;;;AC5ZA,SAAS0Y,aAAaA,CAAC1Y,GAAW,EAAEsT,SAAiB,EAAED,OAAe,EAAE;EACtE,OAAO,IAAIjkB,QAAQ,CAACikB,OAAO,EAAErT,GAAG,GAAGsT,SAAS,EAAEtT,GAAG,CAAC;AACpD;AAEA,MAAM2Y,iBAAiB,GAAG,IAAIla,GAAG,CAAC,wCAUjC,CAAC;AAMK,MAAMma,KAAK,CAAC;EACjB52B,WAAWA,CAAC4lB,KAAY,EAAE;IACxB,IAAI,CAACxU,IAAI,GAAGwU,KAAK,CAACxU,IAAI;IACtB,IAAI,CAAC3C,KAAK,GAAGmX,KAAK,CAACnX,KAAK;IACxB,IAAI,CAACf,KAAK,GAAGkY,KAAK,CAAClY,KAAK;IACxB,IAAI,CAACC,GAAG,GAAGiY,KAAK,CAACjY,GAAG;IACpB,IAAI,CAACiQ,GAAG,GAAG,IAAInQ,cAAc,CAACmY,KAAK,CAAC3B,QAAQ,EAAE2B,KAAK,CAACkB,MAAM,CAAC;EAC7D;AAOF;AAIe,MAAe+P,SAAS,SAASpH,cAAc,CAAC;EAM7DzvB,WAAWA,CAACL,OAAgB,EAAE6wB,KAAa,EAAE;IAC3C,KAAK,EAAE;IAAC,IAAA,CANVsG,WAAW,GAAA,KAAA,CAAA;IAAA,IAGX33B,CAAAA,MAAM,GAA6B,EAAE;IAAA,IAAA,CAm8CrC43B,qBAAqB,GAAqB;MACxCR,YAAY,EAAEA,CAACvY,GAAG,EAAEsT,SAAS,EAAED,OAAO,EAAE/b,KAAK,KAAK;QAChD,IAAI,CAAC,IAAI,CAAC3V,OAAO,CAACN,aAAa,EAAE,OAAO,KAAK;QAE7C,IAAI,CAACylB,KAAK,CAAClG,MAAM,CAACvJ,YAAY,EAAE;UAC9B7Q,EAAE,EAAEkyB,aAAa,CAAC1Y,GAAG,EAAEsT,SAAS,EAAED,OAAO,CAAC;UAC1C/b;QACF,CAAC,CAAC;QAEF,OAAO,IAAI;MACZ,CAAA;MACD4gB,gCAAgC,EAAE,IAAI,CAACc,YAAY,CACjDpY,MAAM,CAACzG,gCAAgC,CACxC;MACDke,0BAA0B,EAAE,IAAI,CAACW,YAAY,CAC3CpY,MAAM,CAACzE,0BAA0B;KAEpC;IAAA,IAED8c,CAAAA,2BAA2B,GAAAp3B,MAAA,CAAA+E,MAAA,CACtB,CAAA,CAAA,EAAA,IAAI,CAACmyB,qBAAqB,EAAA;MAC7BtB,qBAAqB,EAAE,IAAI,CAACuB,YAAY,CAACpY,MAAM,CAACrJ,qBAAqB,CAAC;MACtEkhB,gBAAgB,EAAE,IAAI,CAACO,YAAY,CAACpY,MAAM,CAAC1J,gBAAgB;IAAC,CAAA,CAAA;IAAA,IAG9DgiB,CAAAA,uCAAuC,GAAAr3B,MAAA,CAAA+E,MAAA,CAClC,CAAA,CAAA,EAAA,IAAI,CAACqyB,2BAA2B,EAAA;MACnClC,mBAAmB,EAAEA,CAAC/W,GAAG,EAAEsT,SAAS,EAAED,OAAO,KAAK;QAChD,IAAI,CAAC8F,sBAAsB,CAACvY,MAAM,CAACvC,mBAAmB,EAAE;UACtD7X,EAAE,EAAEkyB,aAAa,CAAC1Y,GAAG,EAAEsT,SAAS,EAAED,OAAO;QAC3C,CAAC,CAAC;MACH,CAAA;MACD+C,YAAY,EAAEA,CAACpW,GAAG,EAAEsT,SAAS,EAAED,OAAO,KAAK;QACzC,MAAM,IAAI,CAACvM,KAAK,CAAClG,MAAM,CAACrD,kBAAkB,EAAE;UAE1C/W,EAAE,EAAEkyB,aAAa,CAAC1Y,GAAG,GAAG,CAAC,EAAEsT,SAAS,EAAED,OAAO;QAC/C,CAAC,CAAC;MACJ;IAAC,CAAA,CAAA;IAAA,IAGH+F,CAAAA,yCAAyC,GAAAv3B,MAAA,CAAA+E,MAAA,CACpC,CAAA,CAAA,EAAA,IAAI,CAACqyB,2BAA2B,EAAA;MACnClC,mBAAmB,EAAE,IAAI,CAACiC,YAAY,CAACpY,MAAM,CAACvC,mBAAmB,CAAC;MAClE+X,YAAY,EAAEA,CAACpW,GAAG,EAAEsT,SAAS,EAAED,OAAO,KAAK;QACzC,MAAM,IAAI,CAACvM,KAAK,CAAClG,MAAM,CAACpD,oBAAoB,EAAE;UAC5ChX,EAAE,EAAEkyB,aAAa,CAAC1Y,GAAG,EAAEsT,SAAS,EAAED,OAAO;QAC3C,CAAC,CAAC;MACJ;IAAC,CAAA,CAAA;IA9+CD,IAAI,CAACzL,KAAK,GAAG,IAAIwL,KAAK,EAAE;IACxB,IAAI,CAACxL,KAAK,CAACmN,IAAI,CAACpzB,OAAO,CAAC;IACxB,IAAI,CAAC6wB,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACrjB,MAAM,GAAGqjB,KAAK,CAACrjB,MAAM;IAC1B,IAAI,CAAC2pB,WAAW,GAAG,KAAK;EAC1B;EAEAO,SAASA,CAACp3B,KAAwB,EAAE;IAGlC,IAAI,CAACd,MAAM,CAACgO,MAAM,GAAG,IAAI,CAACyY,KAAK,CAACkN,YAAY;IAC5C,IAAI,CAAC3zB,MAAM,CAACqD,IAAI,CAACvC,KAAK,CAAC;IACvB,EAAE,IAAI,CAAC2lB,KAAK,CAACkN,YAAY;EAC3B;EAIAnK,IAAIA,CAAAA,EAAS;IACX,IAAI,CAAC2O,mBAAmB,EAAE;IAC1B,IAAI,IAAI,CAAC33B,OAAO,CAACR,MAAM,EAAE;MACvB,IAAI,CAACk4B,SAAS,CAAC,IAAIT,KAAK,CAAC,IAAI,CAAChR,KAAK,CAAC,CAAC;IACvC;IAEA,IAAI,CAACA,KAAK,CAAC4M,YAAY,GAAG,IAAI,CAAC5M,KAAK,CAAClY,KAAK;IAC1C,IAAI,CAACkY,KAAK,CAACoB,aAAa,GAAG,IAAI,CAACpB,KAAK,CAACkB,MAAM;IAC5C,IAAI,CAAClB,KAAK,CAACC,eAAe,GAAG,IAAI,CAACD,KAAK,CAAC3B,QAAQ;IAChD,IAAI,CAACsT,SAAS,EAAE;EAClB;EAEAC,GAAGA,CAACpmB,IAAe,EAAW;IAC5B,IAAI,IAAI,CAAC6jB,KAAK,CAAC7jB,IAAI,CAAC,EAAE;MACpB,IAAI,CAACuX,IAAI,EAAE;MACX,OAAO,IAAI;IACb,CAAC,MAAM;MACL,OAAO,KAAK;IACd;EACF;EAKAsM,KAAKA,CAAC7jB,IAAe,EAAW;IAC9B,OAAO,IAAI,CAACwU,KAAK,CAACxU,IAAI,KAAKA,IAAI;EACjC;EAKAqmB,oBAAoBA,CAAC7R,KAAY,EAAkB;IACjD,OAAO;MACL5H,GAAG,EAAE4H,KAAK,CAAC5H,GAAG;MACdvP,KAAK,EAAE,IAAI;MACX2C,IAAI,EAAEwU,KAAK,CAACxU,IAAI;MAChB1D,KAAK,EAAEkY,KAAK,CAAClY,KAAK;MAClBC,GAAG,EAAEiY,KAAK,CAACjY,GAAG;MACdX,OAAO,EAAE,CAAC,IAAI,CAAC0qB,UAAU,EAAE,CAAC;MAC5B9F,MAAM,EAAEhM,KAAK,CAACgM,MAAM;MACpB3N,QAAQ,EAAE2B,KAAK,CAAC3B,QAAQ;MACxB+C,aAAa,EAAEpB,KAAK,CAACoB,aAAa;MAClCqK,OAAO,EAAEzL,KAAK,CAACyL,OAAO;MACtBC,SAAS,EAAE1L,KAAK,CAAC0L,SAAS;MAC1B0B,WAAW,EAAEpN,KAAK,CAACoN;KACpB;EACH;EAeA2E,SAASA,CAAAA,EAAmB;IAC1B,MAAMC,GAAG,GAAG,IAAI,CAAChS,KAAK;IAEtB,IAAI,CAACA,KAAK,GAAG,IAAI,CAAC6R,oBAAoB,CAACG,GAAG,CAAC;IAE3C,IAAI,CAACd,WAAW,GAAG,IAAI;IACvB,IAAI,CAACS,SAAS,EAAE;IAChB,IAAI,CAACT,WAAW,GAAG,KAAK;IAExB,MAAMe,IAAI,GAAG,IAAI,CAACjS,KAAK;IACvB,IAAI,CAACA,KAAK,GAAGgS,GAAG;IAChB,OAAOC,IAAI;EACb;EAEAC,cAAcA,CAAAA,EAAW;IACvB,OAAO,IAAI,CAACC,mBAAmB,CAAC,IAAI,CAACnS,KAAK,CAAC5H,GAAG,CAAC;EACjD;EAEA+Z,mBAAmBA,CAAC/Z,GAAW,EAAU;IACvCgT,cAAc,CAACgH,SAAS,GAAGha,GAAG;IAC9B,OAAOgT,cAAc,CAACvJ,IAAI,CAAC,IAAI,CAAC+I,KAAK,CAAC,GAAGQ,cAAc,CAACgH,SAAS,GAAGha,GAAG;EACzE;EAEAia,iBAAiBA,CAAAA,EAAW;IAC1B,OAAO,IAAI,CAACzH,KAAK,CAACC,UAAU,CAAC,IAAI,CAACqH,cAAc,EAAE,CAAC;EACrD;EAQAI,oBAAoBA,CAAAA,EAAW;IAC7B,OAAO,IAAI,CAACC,yBAAyB,CAAC,IAAI,CAACvS,KAAK,CAAC5H,GAAG,CAAC;EACvD;EAEAma,yBAAyBA,CAACna,GAAW,EAAU;IAC7CiT,oBAAoB,CAAC+G,SAAS,GAAGha,GAAG;IACpC,OAAOiT,oBAAoB,CAACxJ,IAAI,CAAC,IAAI,CAAC+I,KAAK,CAAC,GACxCS,oBAAoB,CAAC+G,SAAS,GAC9Bha,GAAG;EACT;EASAoa,uBAAuBA,CAAAA,EAAW;IAChC,OAAO,IAAI,CAAC5H,KAAK,CAACC,UAAU,CAAC,IAAI,CAACyH,oBAAoB,EAAE,CAAC;EAC3D;EAEAG,cAAcA,CAACra,GAAW,EAAU;IAKlC,IAAIsa,EAAE,GAAG,IAAI,CAAC9H,KAAK,CAACC,UAAU,CAACzS,GAAG,CAAC;IACnC,IAAI,CAACsa,EAAE,GAAG,MAAM,MAAM,MAAM,IAAI,EAAEta,GAAG,GAAG,IAAI,CAACwS,KAAK,CAACrjB,MAAM,EAAE;MACzD,MAAMorB,KAAK,GAAG,IAAI,CAAC/H,KAAK,CAACC,UAAU,CAACzS,GAAG,CAAC;MACxC,IAAI,CAACua,KAAK,GAAG,MAAM,MAAM,MAAM,EAAE;QAC/BD,EAAE,GAAG,OAAO,IAAI,CAACA,EAAE,GAAG,KAAK,KAAK,EAAE,CAAC,IAAIC,KAAK,GAAG,KAAK,CAAC;MACvD;IACF;IACA,OAAOD,EAAE;EACX;EAKAE,SAASA,CAAC3Q,MAAe,EAAQ;IAC/B,IAAI,CAACjC,KAAK,CAACiC,MAAM,GAAGA,MAAM;IAC1B,IAAIA,MAAM,EAAE;MAKV,IAAI,CAACjC,KAAK,CAACiN,YAAY,CAAC4F,OAAO,CAAC,CAAC,CAACC,YAAY,EAAEl0B,EAAE,CAAC,KACjD,IAAI,CAACsgB,KAAK,CAAC4T,YAAY,EAAE;QAAEl0B;MAAI,CAAA,CAAC,CACjC;MACD,IAAI,CAACohB,KAAK,CAACiN,YAAY,CAAC8F,KAAK,EAAE;IACjC;EACF;EAEAjB,UAAUA,CAAAA,EAAe;IACvB,OAAO,IAAI,CAAC9R,KAAK,CAAC5Y,OAAO,CAAC,IAAI,CAAC4Y,KAAK,CAAC5Y,OAAO,CAACG,MAAM,GAAG,CAAC,CAAC;EAC1D;EAGAoqB,SAASA,CAAAA,EAAS;IAChB,IAAI,CAACqB,SAAS,EAAE;IAChB,IAAI,CAAChT,KAAK,CAAClY,KAAK,GAAG,IAAI,CAACkY,KAAK,CAAC5H,GAAG;IACjC,IAAI,CAAC,IAAI,CAAC8Y,WAAW,EAAE,IAAI,CAAClR,KAAK,CAAC3B,QAAQ,GAAG,IAAI,CAAC2B,KAAK,CAACoN,WAAW,EAAE;IACrE,IAAI,IAAI,CAACpN,KAAK,CAAC5H,GAAG,IAAI,IAAI,CAAC7Q,MAAM,EAAE;MACjC,IAAI,CAAC0rB,WAAW,CAAQ,GAAA,CAAA;MACxB;IACF;IAEA,IAAI,CAACC,gBAAgB,CAAC,IAAI,CAACT,cAAc,CAAC,IAAI,CAACzS,KAAK,CAAC5H,GAAG,CAAC,CAAC;EAC5D;EAKA+a,gBAAgBA,CAAC7I,UAAwB,EAA8B;IACrE,IAAIjM,QAAQ;IACZ,IAAI,CAAC,IAAI,CAAC6S,WAAW,EAAE7S,QAAQ,GAAG,IAAI,CAAC2B,KAAK,CAACoN,WAAW,EAAE;IAC1D,MAAMtlB,KAAK,GAAG,IAAI,CAACkY,KAAK,CAAC5H,GAAG;IAC5B,MAAMrQ,GAAG,GAAG,IAAI,CAAC6iB,KAAK,CAACgG,OAAO,CAACtG,UAAU,EAAExiB,KAAK,GAAG,CAAC,CAAC;IACrD,IAAIC,GAAG,KAAK,CAAC,CAAC,EAAE;MAId,MAAM,IAAI,CAACmX,KAAK,CAAClG,MAAM,CAACvD,mBAAmB,EAAE;QAC3C7W,EAAE,EAAE,IAAI,CAACohB,KAAK,CAACoN,WAAW;MAC5B,CAAC,CAAC;IACJ;IAEA,IAAI,CAACpN,KAAK,CAAC5H,GAAG,GAAGrQ,GAAG,GAAGuiB,UAAU,CAAC/iB,MAAM;IACxC2jB,UAAU,CAACkH,SAAS,GAAGtqB,KAAK,GAAG,CAAC;IAChC,OAAOojB,UAAU,CAACrJ,IAAI,CAAC,IAAI,CAAC+I,KAAK,CAAC,IAAIM,UAAU,CAACkH,SAAS,IAAIrqB,GAAG,EAAE;MACjE,EAAE,IAAI,CAACiY,KAAK,CAACyL,OAAO;MACpB,IAAI,CAACzL,KAAK,CAAC0L,SAAS,GAAGR,UAAU,CAACkH,SAAS;IAC7C;IAIA,IAAI,IAAI,CAAClB,WAAW,EAAE;IAGtB,MAAMnH,OAAuB,GAAG;MAC9Bve,IAAI,EAAE,cAAc;MACpB3C,KAAK,EAAE,IAAI,CAAC+hB,KAAK,CAAC2C,KAAK,CAACzlB,KAAK,GAAG,CAAC,EAAEC,GAAG,CAAC;MACvCD,KAAK;MACLC,GAAG,EAAEA,GAAG,GAAGuiB,UAAU,CAAC/iB,MAAM;MAC5ByQ,GAAG,EAAE,IAAInQ,cAAc,CAACwW,QAAQ,EAAE,IAAI,CAAC2B,KAAK,CAACoN,WAAW,EAAE;KAC3D;IACD,IAAI,IAAI,CAACrzB,OAAO,CAACR,MAAM,EAAE,IAAI,CAACk4B,SAAS,CAAC1H,OAAO,CAAC;IAChD,OAAOA,OAAO;EAChB;EAEAqJ,eAAeA,CAACC,SAAiB,EAA6B;IAC5D,MAAMvrB,KAAK,GAAG,IAAI,CAACkY,KAAK,CAAC5H,GAAG;IAC5B,IAAIiG,QAAQ;IACZ,IAAI,CAAC,IAAI,CAAC6S,WAAW,EAAE7S,QAAQ,GAAG,IAAI,CAAC2B,KAAK,CAACoN,WAAW,EAAE;IAC1D,IAAIU,EAAE,GAAG,IAAI,CAAClD,KAAK,CAACC,UAAU,CAAE,IAAI,CAAC7K,KAAK,CAAC5H,GAAG,IAAIib,SAAS,CAAE;IAC7D,IAAI,IAAI,CAACrT,KAAK,CAAC5H,GAAG,GAAG,IAAI,CAAC7Q,MAAM,EAAE;MAChC,OAAO,CAAC4jB,SAAS,CAAC2C,EAAE,CAAC,IAAI,EAAE,IAAI,CAAC9N,KAAK,CAAC5H,GAAG,GAAG,IAAI,CAAC7Q,MAAM,EAAE;QACvDumB,EAAE,GAAG,IAAI,CAAClD,KAAK,CAACC,UAAU,CAAC,IAAI,CAAC7K,KAAK,CAAC5H,GAAG,CAAC;MAC5C;IACF;IAIA,IAAI,IAAI,CAAC8Y,WAAW,EAAE;IAGtB,MAAMnpB,GAAG,GAAG,IAAI,CAACiY,KAAK,CAAC5H,GAAG;IAC1B,MAAMvP,KAAK,GAAG,IAAI,CAAC+hB,KAAK,CAAC2C,KAAK,CAACzlB,KAAK,GAAGurB,SAAS,EAAEtrB,GAAG,CAAC;IAEtD,MAAMgiB,OAAsB,GAAG;MAC7Bve,IAAI,EAAE,aAAa;MACnB3C,KAAK;MACLf,KAAK;MACLC,GAAG;MACHiQ,GAAG,EAAE,IAAInQ,cAAc,CAACwW,QAAQ,EAAE,IAAI,CAAC2B,KAAK,CAACoN,WAAW,EAAE;KAC3D;IACD,IAAI,IAAI,CAACrzB,OAAO,CAACR,MAAM,EAAE,IAAI,CAACk4B,SAAS,CAAC1H,OAAO,CAAC;IAChD,OAAOA,OAAO;EAChB;EAKAiJ,SAASA,CAAAA,EAAS;IAChB,MAAMM,UAAU,GAAG,IAAI,CAACtT,KAAK,CAAC5H,GAAG;IACjC,MAAM8Q,QAAQ,GAAG,EAAE;IACnBqK,IAAI,EAAE,OAAO,IAAI,CAACvT,KAAK,CAAC5H,GAAG,GAAG,IAAI,CAAC7Q,MAAM,EAAE;MACzC,MAAMumB,EAAE,GAAG,IAAI,CAAClD,KAAK,CAACC,UAAU,CAAC,IAAI,CAAC7K,KAAK,CAAC5H,GAAG,CAAC;MAChD,QAAQ0V,EAAE;QACR,KAAA,EAAA;QACA,KAAA,GAAA;QACA,KAAA,CAAA;UACE,EAAE,IAAI,CAAC9N,KAAK,CAAC5H,GAAG;UAChB;QACF,KAAA,EAAA;UACE,IACE,IAAI,CAACwS,KAAK,CAACC,UAAU,CAAC,IAAI,CAAC7K,KAAK,CAAC5H,GAAG,GAAG,CAAC,CAAC,OAAuB,EAChE;YACA,EAAE,IAAI,CAAC4H,KAAK,CAAC5H,GAAG;UAClB;QAEF,KAAA,EAAA;QACA,KAAA,IAAA;QACA,KAAA,IAAA;UACE,EAAE,IAAI,CAAC4H,KAAK,CAAC5H,GAAG;UAChB,EAAE,IAAI,CAAC4H,KAAK,CAACyL,OAAO;UACpB,IAAI,CAACzL,KAAK,CAAC0L,SAAS,GAAG,IAAI,CAAC1L,KAAK,CAAC5H,GAAG;UACrC;QAEF,KAAA,EAAA;UACE,QAAQ,IAAI,CAACwS,KAAK,CAACC,UAAU,CAAC,IAAI,CAAC7K,KAAK,CAAC5H,GAAG,GAAG,CAAC,CAAC;YAC/C,KAAA,EAAA;cAAyB;gBACvB,MAAM2R,OAAO,GAAG,IAAI,CAACoJ,gBAAgB,CAAC,IAAI,CAAC;gBAC3C,IAAIpJ,OAAO,KAAKpxB,SAAS,EAAE;kBACzB,IAAI,CAACmxB,UAAU,CAACC,OAAO,CAAC;kBACxB,IAAI,IAAI,CAAChwB,OAAO,CAACL,aAAa,EAAEwvB,QAAQ,CAACtsB,IAAI,CAACmtB,OAAO,CAAC;gBACxD;gBACA;cACF;YAEA,KAAA,EAAA;cAAsB;gBACpB,MAAMA,OAAO,GAAG,IAAI,CAACqJ,eAAe,CAAC,CAAC,CAAC;gBACvC,IAAIrJ,OAAO,KAAKpxB,SAAS,EAAE;kBACzB,IAAI,CAACmxB,UAAU,CAACC,OAAO,CAAC;kBACxB,IAAI,IAAI,CAAChwB,OAAO,CAACL,aAAa,EAAEwvB,QAAQ,CAACtsB,IAAI,CAACmtB,OAAO,CAAC;gBACxD;gBACA;cACF;YAEA;cACE,MAAMwJ,IAAI;UAAA;UAEd;QAEF;UACE,IAAIhI,YAAY,CAACuC,EAAE,CAAC,EAAE;YACpB,EAAE,IAAI,CAAC9N,KAAK,CAAC5H,GAAG;UAClB,CAAC,MAAM,IACL0V,EAAE,KAAA,EAAmB,IACrB,CAAC,IAAI,CAACvL,QAAQ,IACd,IAAI,CAACxoB,OAAO,CAACJ,MAAM,EACnB;YACA,MAAMye,GAAG,GAAG,IAAI,CAAC4H,KAAK,CAAC5H,GAAG;YAC1B,IACE,IAAI,CAACwS,KAAK,CAACC,UAAU,CAACzS,GAAG,GAAG,CAAC,CAAC,OAAmB,IACjD,IAAI,CAACwS,KAAK,CAACC,UAAU,CAACzS,GAAG,GAAG,CAAC,CAAC,KAAA,EAA0B,KACvDkb,UAAU,KAAK,CAAC,IAAI,IAAI,CAACtT,KAAK,CAAC0L,SAAS,GAAG4H,UAAU,CAAC,EACvD;cAEA,MAAMvJ,OAAO,GAAG,IAAI,CAACqJ,eAAe,CAAC,CAAC,CAAC;cACvC,IAAIrJ,OAAO,KAAKpxB,SAAS,EAAE;gBACzB,IAAI,CAACmxB,UAAU,CAACC,OAAO,CAAC;gBACxB,IAAI,IAAI,CAAChwB,OAAO,CAACL,aAAa,EAAEwvB,QAAQ,CAACtsB,IAAI,CAACmtB,OAAO,CAAC;cACxD;YACF,CAAC,MAAM;cACL,MAAMwJ,IAAI;YACZ;UACF,CAAC,MAAM,IACLzF,EAAE,KAAA,EAAuB,IACzB,CAAC,IAAI,CAACvL,QAAQ,IACd,IAAI,CAACxoB,OAAO,CAACJ,MAAM,EACnB;YACA,MAAMye,GAAG,GAAG,IAAI,CAAC4H,KAAK,CAAC5H,GAAG;YAC1B,IACE,IAAI,CAACwS,KAAK,CAACC,UAAU,CAACzS,GAAG,GAAG,CAAC,CAAC,KAA8B,EAAA,IAC5D,IAAI,CAACwS,KAAK,CAACC,UAAU,CAACzS,GAAG,GAAG,CAAC,CAAC,KAAmB,EAAA,IACjD,IAAI,CAACwS,KAAK,CAACC,UAAU,CAACzS,GAAG,GAAG,CAAC,CAAC,OAAmB,EACjD;cAEA,MAAM2R,OAAO,GAAG,IAAI,CAACqJ,eAAe,CAAC,CAAC,CAAC;cACvC,IAAIrJ,OAAO,KAAKpxB,SAAS,EAAE;gBACzB,IAAI,CAACmxB,UAAU,CAACC,OAAO,CAAC;gBACxB,IAAI,IAAI,CAAChwB,OAAO,CAACL,aAAa,EAAEwvB,QAAQ,CAACtsB,IAAI,CAACmtB,OAAO,CAAC;cACxD;YACF,CAAC,MAAM;cACL,MAAMwJ,IAAI;YACZ;UACF,CAAC,MAAM;YACL,MAAMA,IAAI;UACZ;MAAA;IAEN;IAEA,IAAIrK,QAAQ,CAAC3hB,MAAM,GAAG,CAAC,EAAE;MACvB,MAAMQ,GAAG,GAAG,IAAI,CAACiY,KAAK,CAAC5H,GAAG;MAC1B,MAAMob,iBAAoC,GAAG;QAC3C1rB,KAAK,EAAEwrB,UAAU;QACjBvrB,GAAG;QACHmhB,QAAQ;QACRkB,WAAW,EAAE,IAAI;QACjBM,YAAY,EAAE,IAAI;QAClBH,cAAc,EAAE;OACjB;MACD,IAAI,CAACvK,KAAK,CAACiK,YAAY,CAACrtB,IAAI,CAAC42B,iBAAiB,CAAC;IACjD;EACF;EAOAP,WAAWA,CAACznB,IAAe,EAAE8hB,GAAS,EAAQ;IAC5C,IAAI,CAACtN,KAAK,CAACjY,GAAG,GAAG,IAAI,CAACiY,KAAK,CAAC5H,GAAG;IAC/B,IAAI,CAAC4H,KAAK,CAACkB,MAAM,GAAG,IAAI,CAAClB,KAAK,CAACoN,WAAW,EAAE;IAC5C,MAAMqG,QAAQ,GAAG,IAAI,CAACzT,KAAK,CAACxU,IAAI;IAChC,IAAI,CAACwU,KAAK,CAACxU,IAAI,GAAGA,IAAI;IACtB,IAAI,CAACwU,KAAK,CAACnX,KAAK,GAAGykB,GAAG;IAEtB,IAAI,CAAC,IAAI,CAAC4D,WAAW,EAAE;MACrB,IAAI,CAACz1B,aAAa,CAACg4B,QAAQ,CAAC;IAC9B;EACF;EAEAC,YAAYA,CAACloB,IAAe,EAAQ;IAClC,IAAI,CAACwU,KAAK,CAACxU,IAAI,GAAGA,IAAI;IAGtB,IAAI,CAAC/P,aAAa,EAAE;EACtB;EAYAk4B,oBAAoBA,CAAAA,EAAS;IAC3B,IAAI,IAAI,CAAC3T,KAAK,CAAC5H,GAAG,KAAK,CAAC,IAAI,IAAI,CAACwb,qBAAqB,EAAE,EAAE;MACxD;IACF;IAEA,MAAMC,OAAO,GAAG,IAAI,CAAC7T,KAAK,CAAC5H,GAAG,GAAG,CAAC;IAClC,MAAM2K,IAAI,GAAG,IAAI,CAAC0P,cAAc,CAACoB,OAAO,CAAC;IACzC,IAAI9Q,IAAI,IAAA,EAAoB,IAAIA,IAAI,MAAoB,EAAE;MACxD,MAAM,IAAI,CAAC7D,KAAK,CAAClG,MAAM,CAAC/E,wBAAwB,EAAE;QAChDrV,EAAE,EAAE,IAAI,CAACohB,KAAK,CAACoN,WAAW;MAC5B,CAAC,CAAC;IACJ;IAEA,IACErK,IAAI,KAAA,GAA6B,IAChCA,IAAI,KAAgC,EAAA,IAAI,IAAI,CAACtD,SAAS,CAAC,gBAAgB,CAAE,EAC1E;MAKA,IAAI,CAACqU,YAAY,CAAC,gBAAgB,CAAC;MACnC,IAAI,IAAI,CAACjX,eAAe,CAAC,gBAAgB,EAAE,YAAY,CAAC,KAAK,KAAK,EAAE;QAClE,MAAM,IAAI,CAACqC,KAAK,CACd6D,IAAI,KAA6B,GAAA,GAC7B/J,MAAM,CAAC7F,4CAA4C,GACnD6F,MAAM,CAAClF,2CAA2C,EACtD;UAAElV,EAAE,EAAE,IAAI,CAACohB,KAAK,CAACoN,WAAW;QAAG,CAAC,CACjC;MACH;MAEA,IAAI,CAACpN,KAAK,CAAC5H,GAAG,IAAI,CAAC;MACnB,IAAI2K,IAAI,QAA6B,EAAE;QAErC,IAAI,CAACkQ,WAAW,CAAe,CAAA,CAAA;MACjC,CAAC,MAAM;QAEL,IAAI,CAACA,WAAW,CAAiB,CAAA,CAAA;MACnC;IACF,CAAC,MAAM,IAAIrR,iBAAiB,CAACmB,IAAI,CAAC,EAAE;MAClC,EAAE,IAAI,CAAC/C,KAAK,CAAC5H,GAAG;MAChB,IAAI,CAAC6a,WAAW,CAAiB,GAAA,EAAA,IAAI,CAACc,SAAS,CAAChR,IAAI,CAAC,CAAC;IACxD,CAAC,MAAM,IAAIA,IAAI,KAAA,EAAwB,EAAE;MACvC,EAAE,IAAI,CAAC/C,KAAK,CAAC5H,GAAG;MAChB,IAAI,CAAC6a,WAAW,CAAA,GAAA,EAAiB,IAAI,CAACc,SAAS,EAAE,CAAC;IACpD,CAAC,MAAM;MACL,IAAI,CAACC,QAAQ,CAAU,EAAA,EAAA,CAAC,CAAC;IAC3B;EACF;EAEAC,aAAaA,CAAAA,EAAS;IACpB,MAAMlR,IAAI,GAAG,IAAI,CAAC6H,KAAK,CAACC,UAAU,CAAC,IAAI,CAAC7K,KAAK,CAAC5H,GAAG,GAAG,CAAC,CAAC;IACtD,IAAI2K,IAAI,IAAA,EAAoB,IAAIA,IAAI,MAAoB,EAAE;MACxD,IAAI,CAACmR,UAAU,CAAC,IAAI,CAAC;MACrB;IACF;IAEA,IACEnR,IAAI,KAAkB,EAAA,IACtB,IAAI,CAAC6H,KAAK,CAACC,UAAU,CAAC,IAAI,CAAC7K,KAAK,CAAC5H,GAAG,GAAG,CAAC,CAAC,OAAkB,EAC3D;MACA,IAAI,CAAC4H,KAAK,CAAC5H,GAAG,IAAI,CAAC;MACnB,IAAI,CAAC6a,WAAW,CAAa,EAAA,CAAA;IAC/B,CAAC,MAAM;MACL,EAAE,IAAI,CAACjT,KAAK,CAAC5H,GAAG;MAChB,IAAI,CAAC6a,WAAW,CAAQ,EAAA,CAAA;IAC1B;EACF;EAEAkB,eAAeA,CAAAA,EAAS;IACtB,MAAMpR,IAAI,GAAG,IAAI,CAAC6H,KAAK,CAACC,UAAU,CAAC,IAAI,CAAC7K,KAAK,CAAC5H,GAAG,GAAG,CAAC,CAAC;IACtD,IAAI2K,IAAI,OAAuB,EAAE;MAC/B,IAAI,CAACiR,QAAQ,CAAiB,EAAA,EAAA,CAAC,CAAC;IAClC,CAAC,MAAM;MACL,IAAI,CAACA,QAAQ,CAAW,EAAA,EAAA,CAAC,CAAC;IAC5B;EACF;EAEAJ,qBAAqBA,CAAAA,EAAY;IAC/B,IAAI,IAAI,CAAC5T,KAAK,CAAC5H,GAAG,KAAK,CAAC,IAAI,IAAI,CAAC7Q,MAAM,GAAG,CAAC,EAAE,OAAO,KAAK;IAEzD,IAAIumB,EAAE,GAAG,IAAI,CAAClD,KAAK,CAACC,UAAU,CAAC,IAAI,CAAC7K,KAAK,CAAC5H,GAAG,GAAG,CAAC,CAAC;IAClD,IAAI0V,EAAE,KAAA,EAA8B,EAAE,OAAO,KAAK;IAElD,MAAMhmB,KAAK,GAAG,IAAI,CAACkY,KAAK,CAAC5H,GAAG;IAC5B,IAAI,CAAC4H,KAAK,CAAC5H,GAAG,IAAI,CAAC;IAEnB,OAAO,CAAC+S,SAAS,CAAC2C,EAAE,CAAC,IAAI,EAAE,IAAI,CAAC9N,KAAK,CAAC5H,GAAG,GAAG,IAAI,CAAC7Q,MAAM,EAAE;MACvDumB,EAAE,GAAG,IAAI,CAAClD,KAAK,CAACC,UAAU,CAAC,IAAI,CAAC7K,KAAK,CAAC5H,GAAG,CAAC;IAC5C;IAEA,MAAMvP,KAAK,GAAG,IAAI,CAAC+hB,KAAK,CAAC2C,KAAK,CAACzlB,KAAK,GAAG,CAAC,EAAE,IAAI,CAACkY,KAAK,CAAC5H,GAAG,CAAC;IAEzD,IAAI,CAAC6a,WAAW,CAA0BpqB,EAAAA,EAAAA,KAAK,CAAC;IAEhD,OAAO,IAAI;EACb;EAEAurB,qBAAqBA,CAACtqB,IAAY,EAAQ;IAExC,IAAI0B,IAAI,GAAG1B,IAAI,KAAA,EAAuB,GAAsB,EAAA,GAAA,EAAA;IAC5D,IAAIuqB,KAAK,GAAG,CAAC;IACb,IAAItR,IAAI,GAAG,IAAI,CAAC6H,KAAK,CAACC,UAAU,CAAC,IAAI,CAAC7K,KAAK,CAAC5H,GAAG,GAAG,CAAC,CAAC;IAGpD,IAAItO,IAAI,KAAA,EAAuB,IAAIiZ,IAAI,OAAuB,EAAE;MAC9DsR,KAAK,EAAE;MACPtR,IAAI,GAAG,IAAI,CAAC6H,KAAK,CAACC,UAAU,CAAC,IAAI,CAAC7K,KAAK,CAAC5H,GAAG,GAAG,CAAC,CAAC;MAChD5M,IAAI,GAAc,EAAA;IACpB;IAGA,IAAIuX,IAAI,OAAuB,IAAI,CAAC,IAAI,CAAC/C,KAAK,CAACgM,MAAM,EAAE;MACrDqI,KAAK,EAAE;MAIP7oB,IAAI,GAAG1B,IAAI,KAAA,EAA0B,GAA8B,EAAA,GAAA,EAAA;IACrE;IAEA,IAAI,CAACkqB,QAAQ,CAACxoB,IAAI,EAAE6oB,KAAK,CAAC;EAC5B;EAEAC,kBAAkBA,CAACxqB,IAAY,EAAQ;IAErC,MAAMiZ,IAAI,GAAG,IAAI,CAAC6H,KAAK,CAACC,UAAU,CAAC,IAAI,CAAC7K,KAAK,CAAC5H,GAAG,GAAG,CAAC,CAAC;IAEtD,IAAI2K,IAAI,KAAKjZ,IAAI,EAAE;MACjB,IAAI,IAAI,CAAC8gB,KAAK,CAACC,UAAU,CAAC,IAAI,CAAC7K,KAAK,CAAC5H,GAAG,GAAG,CAAC,CAAC,OAAuB,EAAE;QACpE,IAAI,CAAC4b,QAAQ,CAAY,EAAA,EAAA,CAAC,CAAC;MAC7B,CAAC,MAAM;QACL,IAAI,CAACA,QAAQ,CACXlqB,IAAI,QAA0B,GAA+B,EAAA,GAAA,EAAA,EAC7D,CAAC,CACF;MACH;MACA;IACF;IAEA,IAAIA,IAAI,QAA0B,EAAE;MAElC,IAAIiZ,IAAI,OAA0B,EAAE;QAClC,IAAI,CAACiR,QAAQ,CAAc,EAAA,EAAA,CAAC,CAAC;QAC7B;MACF;MAEA,IACE,IAAI,CAACvU,SAAS,CAAC,gBAAgB,CAAC,IAChCsD,IAAI,KAAA,GAA8B,EAClC;QACA,IAAI,IAAI,CAAClG,eAAe,CAAC,gBAAgB,EAAE,YAAY,CAAC,KAAK,KAAK,EAAE;UAClE,MAAM,IAAI,CAACqC,KAAK,CAAClG,MAAM,CAAC/F,yCAAyC,EAAE;YACjErU,EAAE,EAAE,IAAI,CAACohB,KAAK,CAACoN,WAAW;UAC5B,CAAC,CAAC;QACJ;QACA,IAAI,CAACpN,KAAK,CAAC5H,GAAG,IAAI,CAAC;QACnB,IAAI,CAAC6a,WAAW,CAAc,CAAA,CAAA;QAC9B;MACF;MAGA,IACE,IAAI,CAACxT,SAAS,CAAC,gBAAgB,CAAC,IAChCsD,IAAI,KAAA,EAAiC,EACrC;QACA,IAAI,IAAI,CAAClG,eAAe,CAAC,gBAAgB,EAAE,YAAY,CAAC,KAAK,KAAK,EAAE;UAClE,MAAM,IAAI,CAACqC,KAAK,CAAClG,MAAM,CAACpF,wCAAwC,EAAE;YAChEhV,EAAE,EAAE,IAAI,CAACohB,KAAK,CAACoN,WAAW;UAC5B,CAAC,CAAC;QACJ;QACA,IAAI,CAACpN,KAAK,CAAC5H,GAAG,IAAI,CAAC;QACnB,IAAI,CAAC6a,WAAW,CAAgB,CAAA,CAAA;QAChC;MACF;IACF;IAEA,IAAIlQ,IAAI,OAAuB,EAAE;MAC/B,IAAI,CAACiR,QAAQ,CAAY,EAAA,EAAA,CAAC,CAAC;MAC3B;IACF;IAEA,IAAI,CAACA,QAAQ,CACXlqB,IAAI,QAA0B,GAA+B,EAAA,GAAA,EAAA,EAC7D,CAAC,CACF;EACH;EAEAyqB,eAAeA,CAAAA,EAAS;IACtB,MAAMxR,IAAI,GAAG,IAAI,CAAC6H,KAAK,CAACC,UAAU,CAAC,IAAI,CAAC7K,KAAK,CAAC5H,GAAG,GAAG,CAAC,CAAC;IAGtD,IAAI2K,IAAI,OAAuB,IAAI,CAAC,IAAI,CAAC/C,KAAK,CAACgM,MAAM,EAAE;MAIrD,IAAI,CAACgI,QAAQ,CAAe,EAAA,EAAA,CAAC,CAAC;KAC/B,MAEI,IACHjR,IAAI,KAAoB,EAAA,IAGxB,IAAI,CAACtD,SAAS,CAAC,CACb,kBAAkB,EAClB;MAAE+U,QAAQ,EAAE,MAAM;MAAEC,UAAU,EAAE;IAAM,CAAA,CACvC,CAAC,EACF;MACA,IAAI,CAACT,QAAQ,CAAiB,EAAA,EAAA,CAAC,CAAC;MAGhC,MAAMU,WAAW,GAAG,IAAI,CAAC9J,KAAK,CAAC+J,WAAW,CAAC,IAAI,CAAC3U,KAAK,CAAC5H,GAAG,CAAC;MAC1D,IAAIsc,WAAW,OAAoB,EAAE;QACnC,IAAI,CAACpkB,UAAU,EAAE;MACnB;IACF,CAAC,MAEI;MACH,IAAI,CAAC0jB,QAAQ,CAAgB,EAAA,EAAA,CAAC,CAAC;IACjC;EACF;EAEAY,gBAAgBA,CAAAA,EAAS;IACvB,MAAM7R,IAAI,GAAG,IAAI,CAAC6H,KAAK,CAACC,UAAU,CAAC,IAAI,CAAC7K,KAAK,CAAC5H,GAAG,GAAG,CAAC,CAAC;IAGtD,IACE2K,IAAI,OAAqB,IACzB,IAAI,CAACtD,SAAS,CAAC,CACb,kBAAkB,EAClB;MAAE+U,QAAQ,EAAE,MAAM;MAAEC,UAAU,EAAE;IAAM,CAAA,CACvC,CAAC,EACF;MACA,IAAI,CAACT,QAAQ,CAAc,EAAA,EAAA,CAAC,CAAC;IAC/B,CAAC,MAEI;MACH,IAAI,CAACA,QAAQ,CAAQ,EAAA,EAAA,CAAC,CAAC;IACzB;EACF;EAEAa,kBAAkBA,CAAC/qB,IAAY,EAAQ;IAErC,MAAMiZ,IAAI,GAAG,IAAI,CAAC6H,KAAK,CAACC,UAAU,CAAC,IAAI,CAAC7K,KAAK,CAAC5H,GAAG,GAAG,CAAC,CAAC;IAEtD,IAAI2K,IAAI,KAAKjZ,IAAI,EAAE;MACjB,IAAI,CAACkqB,QAAQ,CAAY,EAAA,EAAA,CAAC,CAAC;MAC3B;IACF;IAEA,IAAIjR,IAAI,OAAuB,EAAE;MAC/B,IAAI,CAACiR,QAAQ,CAAY,EAAA,EAAA,CAAC,CAAC;IAC7B,CAAC,MAAM;MACL,IAAI,CAACA,QAAQ,CAAa,EAAA,EAAA,CAAC,CAAC;IAC9B;EACF;EAEAc,YAAYA,CAAAA,EAAS;IAEnB,MAAM;MAAE1c;KAAK,GAAG,IAAI,CAAC4H,KAAK;IAC1B,MAAM+C,IAAI,GAAG,IAAI,CAAC6H,KAAK,CAACC,UAAU,CAACzS,GAAG,GAAG,CAAC,CAAC;IAE3C,IAAI2K,IAAI,OAAuB,EAAE;MAC/B,IAAI,IAAI,CAAC6H,KAAK,CAACC,UAAU,CAACzS,GAAG,GAAG,CAAC,CAAC,KAAA,EAAuB,EAAE;QACzD,IAAI,CAAC4b,QAAQ,CAAY,EAAA,EAAA,CAAC,CAAC;QAC3B;MACF;MACA,IAAI,CAACA,QAAQ,CAAe,EAAA,EAAA,CAAC,CAAC;MAC9B;IACF;IAEA,IAAIjR,IAAI,OAAuB,EAAE;MAE/B,IAAI,CAACiR,QAAQ,CAAgB,EAAA,EAAA,CAAC,CAAC;MAC/B;IACF;IAEA,IAAI,CAACA,QAAQ,CAAQ,EAAA,EAAA,CAAC,CAAC;EACzB;EAEAe,YAAYA,CAAAA,EAAS;IAEnB,MAAM;MAAE3c;KAAK,GAAG,IAAI,CAAC4H,KAAK;IAC1B,MAAM+C,IAAI,GAAG,IAAI,CAAC6H,KAAK,CAACC,UAAU,CAACzS,GAAG,GAAG,CAAC,CAAC;IAE3C,IAAI2K,IAAI,OAA0B,EAAE;MAClC,MAAMiS,IAAI,GACR,IAAI,CAACpK,KAAK,CAACC,UAAU,CAACzS,GAAG,GAAG,CAAC,CAAC,KAAA,EAA0B,GAAG,CAAC,GAAG,CAAC;MAClE,IAAI,IAAI,CAACwS,KAAK,CAACC,UAAU,CAACzS,GAAG,GAAG4c,IAAI,CAAC,KAAA,EAAuB,EAAE;QAC5D,IAAI,CAAChB,QAAQ,CAAA,EAAA,EAAYgB,IAAI,GAAG,CAAC,CAAC;QAClC;MACF;MACA,IAAI,CAAChB,QAAQ,CAAegB,EAAAA,EAAAA,IAAI,CAAC;MACjC;IACF;IAEA,IAAIjS,IAAI,OAAuB,EAAE;MAE/B,IAAI,CAACiR,QAAQ,CAAgB,EAAA,EAAA,CAAC,CAAC;MAC/B;IACF;IAEA,IAAI,CAACA,QAAQ,CAAQ,EAAA,EAAA,CAAC,CAAC;EACzB;EAEAiB,iBAAiBA,CAACnrB,IAAY,EAAQ;IAEpC,MAAMiZ,IAAI,GAAG,IAAI,CAAC6H,KAAK,CAACC,UAAU,CAAC,IAAI,CAAC7K,KAAK,CAAC5H,GAAG,GAAG,CAAC,CAAC;IACtD,IAAI2K,IAAI,OAAuB,EAAE;MAC/B,IAAI,CAACiR,QAAQ,CAEX,EAAA,EAAA,IAAI,CAACpJ,KAAK,CAACC,UAAU,CAAC,IAAI,CAAC7K,KAAK,CAAC5H,GAAG,GAAG,CAAC,CAAC,OAAuB,GAC5D,CAAC,GACD,CAAC,CACN;MACD;IACF;IACA,IAAItO,IAAI,KAAA,EAAuB,IAAIiZ,IAAI,OAA0B,EAAE;MAEjE,IAAI,CAAC/C,KAAK,CAAC5H,GAAG,IAAI,CAAC;MACnB,IAAI,CAAC6a,WAAW,CAAU,EAAA,CAAA;MAC1B;IACF;IACA,IAAI,CAACe,QAAQ,CAAClqB,IAAI,OAAuB,GAAkB,EAAA,GAAA,EAAA,EAAE,CAAC,CAAC;EACjE;EAEAorB,kBAAkBA,CAAAA,EAAS;IAEzB,MAAMnS,IAAI,GAAG,IAAI,CAAC6H,KAAK,CAACC,UAAU,CAAC,IAAI,CAAC7K,KAAK,CAAC5H,GAAG,GAAG,CAAC,CAAC;IACtD,MAAM4K,KAAK,GAAG,IAAI,CAAC4H,KAAK,CAACC,UAAU,CAAC,IAAI,CAAC7K,KAAK,CAAC5H,GAAG,GAAG,CAAC,CAAC;IACvD,IAAI2K,IAAI,OAA2B,EAAE;MACnC,IAAIC,KAAK,OAAuB,EAAE;QAEhC,IAAI,CAACgR,QAAQ,CAAY,EAAA,EAAA,CAAC,CAAC;MAC7B,CAAC,MAAM;QAEL,IAAI,CAACA,QAAQ,CAAuB,EAAA,EAAA,CAAC,CAAC;MACxC;IACF,CAAC,MAAM,IACLjR,IAAI,KAAA,EAAkB,IACtB,EAAEC,KAAK,IAAA,EAAoB,IAAIA,KAAK,IAAoB,EAAA,CAAC,EACzD;MAEA,IAAI,CAAChD,KAAK,CAAC5H,GAAG,IAAI,CAAC;MACnB,IAAI,CAAC6a,WAAW,CAAgB,EAAA,CAAA;IAClC,CAAC,MAAM;MACL,EAAE,IAAI,CAACjT,KAAK,CAAC5H,GAAG;MAChB,IAAI,CAAC6a,WAAW,CAAa,EAAA,CAAA;IAC/B;EACF;EAEAC,gBAAgBA,CAACppB,IAAY,EAAQ;IACnC,QAAQA,IAAI;MAIV,KAAA,EAAA;QACE,IAAI,CAACmqB,aAAa,EAAE;QACpB;MAEF,KAAA,EAAA;QACE,EAAE,IAAI,CAACjU,KAAK,CAAC5H,GAAG;QAChB,IAAI,CAAC6a,WAAW,CAAW,EAAA,CAAA;QAC3B;MACF,KAAA,EAAA;QACE,EAAE,IAAI,CAACjT,KAAK,CAAC5H,GAAG;QAChB,IAAI,CAAC6a,WAAW,CAAW,EAAA,CAAA;QAC3B;MACF,KAAA,EAAA;QACE,EAAE,IAAI,CAACjT,KAAK,CAAC5H,GAAG;QAChB,IAAI,CAAC6a,WAAW,CAAS,EAAA,CAAA;QACzB;MACF,KAAA,EAAA;QACE,EAAE,IAAI,CAACjT,KAAK,CAAC5H,GAAG;QAChB,IAAI,CAAC6a,WAAW,CAAU,EAAA,CAAA;QAC1B;MACF,KAAA,EAAA;QACE,IACE,IAAI,CAACxT,SAAS,CAAC,gBAAgB,CAAC,IAChC,IAAI,CAACmL,KAAK,CAACC,UAAU,CAAC,IAAI,CAAC7K,KAAK,CAAC5H,GAAG,GAAG,CAAC,CAAC,KAAA,GAA0B,EACnE;UACA,IAAI,IAAI,CAACyE,eAAe,CAAC,gBAAgB,EAAE,YAAY,CAAC,KAAK,KAAK,EAAE;YAClE,MAAM,IAAI,CAACqC,KAAK,CACdlG,MAAM,CAACnF,0CAA0C,EACjD;cAAEjV,EAAE,EAAE,IAAI,CAACohB,KAAK,CAACoN,WAAW;YAAG,CAAC,CACjC;UACH;UAGA,IAAI,CAACpN,KAAK,CAAC5H,GAAG,IAAI,CAAC;UACnB,IAAI,CAAC6a,WAAW,CAAgB,CAAA,CAAA;QAClC,CAAC,MAAM;UACL,EAAE,IAAI,CAACjT,KAAK,CAAC5H,GAAG;UAChB,IAAI,CAAC6a,WAAW,CAAa,CAAA,CAAA;QAC/B;QACA;MACF,KAAA,EAAA;QACE,EAAE,IAAI,CAACjT,KAAK,CAAC5H,GAAG;QAChB,IAAI,CAAC6a,WAAW,CAAa,CAAA,CAAA;QAC7B;MACF,KAAA,GAAA;QACE,IACE,IAAI,CAACxT,SAAS,CAAC,gBAAgB,CAAC,IAChC,IAAI,CAACmL,KAAK,CAACC,UAAU,CAAC,IAAI,CAAC7K,KAAK,CAAC5H,GAAG,GAAG,CAAC,CAAC,KAAA,GAA0B,EACnE;UACA,IAAI,IAAI,CAACyE,eAAe,CAAC,gBAAgB,EAAE,YAAY,CAAC,KAAK,KAAK,EAAE;YAClE,MAAM,IAAI,CAACqC,KAAK,CACdlG,MAAM,CAAC9F,2CAA2C,EAClD;cAAEtU,EAAE,EAAE,IAAI,CAACohB,KAAK,CAACoN,WAAW;YAAG,CAAC,CACjC;UACH;UAGA,IAAI,CAACpN,KAAK,CAAC5H,GAAG,IAAI,CAAC;UACnB,IAAI,CAAC6a,WAAW,CAAc,CAAA,CAAA;QAChC,CAAC,MAAM;UACL,EAAE,IAAI,CAACjT,KAAK,CAAC5H,GAAG;UAChB,IAAI,CAAC6a,WAAW,CAAW,CAAA,CAAA;QAC7B;QACA;MACF,KAAA,GAAA;QACE,EAAE,IAAI,CAACjT,KAAK,CAAC5H,GAAG;QAChB,IAAI,CAAC6a,WAAW,CAAW,CAAA,CAAA;QAC3B;MAEF,KAAA,EAAA;QACE,IACE,IAAI,CAACxT,SAAS,CAAC,cAAc,CAAC,IAC9B,IAAI,CAACmL,KAAK,CAACC,UAAU,CAAC,IAAI,CAAC7K,KAAK,CAAC5H,GAAG,GAAG,CAAC,CAAC,KAAA,EAAoB,EAC7D;UACA,IAAI,CAAC4b,QAAQ,CAAiB,EAAA,EAAA,CAAC,CAAC;QAClC,CAAC,MAAM;UACL,EAAE,IAAI,CAAChU,KAAK,CAAC5H,GAAG;UAChB,IAAI,CAAC6a,WAAW,CAAU,EAAA,CAAA;QAC5B;QACA;MAEF,KAAA,EAAA;QACE,IAAI,CAACiC,kBAAkB,EAAE;QACzB;MAEF,KAAA,EAAA;QACE,IAAI,CAACC,iBAAiB,EAAE;QACxB;MAEF,KAAA,EAAA;QAAuB;UACrB,MAAMpS,IAAI,GAAG,IAAI,CAAC6H,KAAK,CAACC,UAAU,CAAC,IAAI,CAAC7K,KAAK,CAAC5H,GAAG,GAAG,CAAC,CAAC;UAEtD,IAAI2K,IAAI,KAAA,GAAyB,IAAIA,IAAI,OAAyB,EAAE;YAClE,IAAI,CAACqS,eAAe,CAAC,EAAE,CAAC;YACxB;UACF;UAEA,IAAIrS,IAAI,KAAA,GAAyB,IAAIA,IAAI,OAAyB,EAAE;YAClE,IAAI,CAACqS,eAAe,CAAC,CAAC,CAAC;YACvB;UACF;UAEA,IAAIrS,IAAI,KAAA,EAAyB,IAAIA,IAAI,OAAyB,EAAE;YAClE,IAAI,CAACqS,eAAe,CAAC,CAAC,CAAC;YACvB;UACF;QACF;MAGA,KAAA,EAAA;MACA,KAAA,EAAA;MACA,KAAA,EAAA;MACA,KAAA,EAAA;MACA,KAAA,EAAA;MACA,KAAA,EAAA;MACA,KAAA,EAAA;MACA,KAAA,EAAA;MACA,KAAA,EAAA;QACE,IAAI,CAAClB,UAAU,CAAC,KAAK,CAAC;QACtB;MAGF,KAAA,EAAA;MACA,KAAA,EAAA;QACE,IAAI,CAACmB,UAAU,CAACvrB,IAAI,CAAC;QACrB;MAOF,KAAA,EAAA;QACE,IAAI,CAACqqB,eAAe,EAAE;QACtB;MAEF,KAAA,EAAA;MACA,KAAA,EAAA;QACE,IAAI,CAACC,qBAAqB,CAACtqB,IAAI,CAAC;QAChC;MAEF,KAAA,GAAA;MACA,KAAA,EAAA;QACE,IAAI,CAACwqB,kBAAkB,CAACxqB,IAAI,CAAC;QAC7B;MAEF,KAAA,EAAA;QACE,IAAI,CAACyqB,eAAe,EAAE;QACtB;MAEF,KAAA,EAAA;MACA,KAAA,EAAA;QACE,IAAI,CAACM,kBAAkB,CAAC/qB,IAAI,CAAC;QAC7B;MAEF,KAAA,EAAA;QACE,IAAI,CAACgrB,YAAY,EAAE;QACnB;MAEF,KAAA,EAAA;QACE,IAAI,CAACC,YAAY,EAAE;QACnB;MAEF,KAAA,EAAA;MACA,KAAA,EAAA;QACE,IAAI,CAACE,iBAAiB,CAACnrB,IAAI,CAAC;QAC5B;MAEF,KAAA,GAAA;QACE,IAAI,CAACkqB,QAAQ,CAAW,EAAA,EAAA,CAAC,CAAC;QAC1B;MAEF,KAAA,EAAA;QACE,IAAI,CAACY,gBAAgB,EAAE;QACvB;MAEF,KAAA,EAAA;QACE,IAAI,CAACjB,oBAAoB,EAAE;QAC3B;MAEF,KAAA,EAAA;QACE,IAAI,CAAC2B,QAAQ,EAAE;QACf;MAEF;QACE,IAAI1T,iBAAiB,CAAC9X,IAAI,CAAC,EAAE;UAC3B,IAAI,CAACwrB,QAAQ,CAACxrB,IAAI,CAAC;UACnB;QACF;IAAA;IAGJ,MAAM,IAAI,CAACoV,KAAK,CAAClG,MAAM,CAAC3I,wBAAwB,EAAE;MAChDzR,EAAE,EAAE,IAAI,CAACohB,KAAK,CAACoN,WAAW,EAAE;MAC5B9c,UAAU,EAAE7E,MAAM,CAACyjB,aAAa,CAACplB,IAAI;IACvC,CAAC,CAAC;EACJ;EAEAkqB,QAAQA,CAACxoB,IAAe,EAAEwpB,IAAY,EAAQ;IAC5C,MAAMpG,GAAG,GAAG,IAAI,CAAChE,KAAK,CAAC2C,KAAK,CAAC,IAAI,CAACvN,KAAK,CAAC5H,GAAG,EAAE,IAAI,CAAC4H,KAAK,CAAC5H,GAAG,GAAG4c,IAAI,CAAC;IACnE,IAAI,CAAChV,KAAK,CAAC5H,GAAG,IAAI4c,IAAI;IACtB,IAAI,CAAC/B,WAAW,CAACznB,IAAI,EAAEojB,GAAG,CAAC;EAC7B;EAEA2G,UAAUA,CAAAA,EAAS;IACjB,MAAMlX,QAAQ,GAAG,IAAI,CAAC2B,KAAK,CAAC3B,QAAQ;IACpC,MAAMvW,KAAK,GAAG,IAAI,CAACkY,KAAK,CAAClY,KAAK,GAAG,CAAC;IAClC,IAAI0tB,OAAO,EAAEvO,OAAO;IACpB,IAAI;MAAE7O;KAAK,GAAG,IAAI,CAAC4H,KAAK;IACxB,QAAS,EAAE5H,GAAG,EAAE;MACd,IAAIA,GAAG,IAAI,IAAI,CAAC7Q,MAAM,EAAE;QAEtB,MAAM,IAAI,CAAC2X,KAAK,CAAClG,MAAM,CAACtD,kBAAkB,EAAE;UAC1C9W,EAAE,EAAEsJ,8BAA8B,CAACmW,QAAQ,EAAE,CAAC;QAChD,CAAC,CAAC;MACJ;MACA,MAAMyP,EAAE,GAAG,IAAI,CAAClD,KAAK,CAACC,UAAU,CAACzS,GAAG,CAAC;MACrC,IAAI+S,SAAS,CAAC2C,EAAE,CAAC,EAAE;QACjB,MAAM,IAAI,CAAC5O,KAAK,CAAClG,MAAM,CAACtD,kBAAkB,EAAE;UAC1C9W,EAAE,EAAEsJ,8BAA8B,CAACmW,QAAQ,EAAE,CAAC;QAChD,CAAC,CAAC;MACJ;MACA,IAAImX,OAAO,EAAE;QACXA,OAAO,GAAG,KAAK;MACjB,CAAC,MAAM;QACL,IAAI1H,EAAE,OAAgC,EAAE;UACtC7G,OAAO,GAAG,IAAI;QAChB,CAAC,MAAM,IAAI6G,EAAE,KAAiC,EAAA,IAAI7G,OAAO,EAAE;UACzDA,OAAO,GAAG,KAAK;QAChB,CAAA,MAAM,IAAI6G,EAAE,OAAoB,IAAI,CAAC7G,OAAO,EAAE;UAC7C;QACF;QACAuO,OAAO,GAAG1H,EAAE,KAAwB,EAAA;MACtC;IACF;IACA,MAAM2H,OAAO,GAAG,IAAI,CAAC7K,KAAK,CAAC2C,KAAK,CAACzlB,KAAK,EAAEsQ,GAAG,CAAC;IAC5C,EAAEA,GAAG;IAEL,IAAIsd,IAAI,GAAG,EAAE;IAEb,MAAM7B,OAAO,GAAGA,CAAAA,KAEd3rB,8BAA8B,CAACmW,QAAQ,EAAEjG,GAAG,GAAG,CAAC,GAAGtQ,KAAK,CAAC;IAE3D,OAAOsQ,GAAG,GAAG,IAAI,CAAC7Q,MAAM,EAAE;MACxB,MAAMmrB,EAAE,GAAG,IAAI,CAACD,cAAc,CAACra,GAAG,CAAC;MAEnC,MAAMud,IAAI,GAAGlqB,MAAM,CAACqW,YAAY,CAAC4Q,EAAE,CAAC;MAGpC,IAAI3B,iBAAiB,CAACtO,GAAG,CAACiQ,EAAE,CAAC,EAAE;QAC7B,IAAIA,EAAE,QAAyB,EAAE;UAC/B,IAAI,CAACoB,YAAY,CAAC,mBAAmB,EAAED,OAAO,EAAE,CAAC;UAEjD,IAAI6B,IAAI,CAACE,QAAQ,CAAC,GAAG,CAAC,EAAE;YACtB,IAAI,CAAC1W,KAAK,CAAClG,MAAM,CAAC5J,yBAAyB,EAAE;cAAExQ,EAAE,EAAEi1B,OAAO;YAAG,CAAC,CAAC;UACjE;QACF,CAAC,MAAM,IAAInB,EAAE,KAAA,GAAyB,EAAE;UACtC,IAAIgD,IAAI,CAACE,QAAQ,CAAC,GAAG,CAAC,EAAE;YACtB,IAAI,CAAC1W,KAAK,CAAClG,MAAM,CAAC5J,yBAAyB,EAAE;cAAExQ,EAAE,EAAEi1B,OAAO;YAAG,CAAC,CAAC;UACjE;QACF;QACA,IAAI6B,IAAI,CAACE,QAAQ,CAACD,IAAI,CAAC,EAAE;UACvB,IAAI,CAACzW,KAAK,CAAClG,MAAM,CAACpL,oBAAoB,EAAE;YAAEhP,EAAE,EAAEi1B,OAAO;UAAG,CAAC,CAAC;QAC5D;MACD,CAAA,MAAM,IAAI9R,gBAAgB,CAAC2Q,EAAE,CAAC,IAAIA,EAAE,KAAA,EAAwB,EAAE;QAC7D,IAAI,CAACxT,KAAK,CAAClG,MAAM,CAAChI,oBAAoB,EAAE;UAAEpS,EAAE,EAAEi1B,OAAO;QAAG,CAAC,CAAC;MAC5D,CAAC,MAAM;QACL;MACF;MAEA,EAAEzb,GAAG;MACLsd,IAAI,IAAIC,IAAI;IACd;IACA,IAAI,CAAC3V,KAAK,CAAC5H,GAAG,GAAGA,GAAG;IAEpB,IAAI,CAAC6a,WAAW,CAAY,GAAA,EAAA;MAC1BvZ,OAAO,EAAE+b,OAAO;MAChB9b,KAAK,EAAE+b;IACT,CAAC,CAAC;EACJ;EAWA9F,OAAOA,CACLlgB,KAAa,EACb+f,GAAY,EACZC,QAAiB,GAAG,KAAK,EACzBI,iBAAmC,GAAG,IAAI,EAC3B;IACf,MAAM;MAAEH,CAAC;MAAEvX;IAAI,CAAC,GAAGwX,OAAO,CACxB,IAAI,CAAChF,KAAK,EACV,IAAI,CAAC5K,KAAK,CAAC5H,GAAG,EACd,IAAI,CAAC4H,KAAK,CAAC0L,SAAS,EACpB,IAAI,CAAC1L,KAAK,CAACyL,OAAO,EAClB/b,KAAK,EACL+f,GAAG,EACHC,QAAQ,EACRI,iBAAiB,EACjB,IAAI,CAACqB,qBAAqB,EACR,KAAK,CACxB;IACD,IAAI,CAACnR,KAAK,CAAC5H,GAAG,GAAGA,GAAG;IACpB,OAAOuX,CAAC;EACV;EAEAyF,eAAeA,CAAC1lB,KAAa,EAAQ;IACnC,MAAM2O,QAAQ,GAAG,IAAI,CAAC2B,KAAK,CAACoN,WAAW,EAAE;IACzC,IAAIyI,QAAQ,GAAG,KAAK;IAEpB,IAAI,CAAC7V,KAAK,CAAC5H,GAAG,IAAI,CAAC;IACnB,MAAMkV,GAAG,GAAG,IAAI,CAACsC,OAAO,CAAClgB,KAAK,CAAC;IAC/B,IAAI4d,GAAG,IAAI,IAAI,EAAE;MACf,IAAI,CAACpO,KAAK,CAAClG,MAAM,CAACvJ,YAAY,EAAE;QAE9B7Q,EAAE,EAAEsJ,8BAA8B,CAACmW,QAAQ,EAAE,CAAC,CAAC;QAC/C3O;MACF,CAAC,CAAC;IACJ;IACA,MAAMqT,IAAI,GAAG,IAAI,CAAC6H,KAAK,CAACC,UAAU,CAAC,IAAI,CAAC7K,KAAK,CAAC5H,GAAG,CAAC;IAElD,IAAI2K,IAAI,QAAyB,EAAE;MACjC,EAAE,IAAI,CAAC/C,KAAK,CAAC5H,GAAG;MAChByd,QAAQ,GAAG,IAAI;IACjB,CAAC,MAAM,IAAI9S,IAAI,KAAA,GAAyB,EAAE;MACxC,MAAM,IAAI,CAAC7D,KAAK,CAAClG,MAAM,CAACxJ,cAAc,EAAE;QAAE5Q,EAAE,EAAEyf;MAAS,CAAC,CAAC;IAC3D;IAEA,IAAIuD,iBAAiB,CAAC,IAAI,CAAC6Q,cAAc,CAAC,IAAI,CAACzS,KAAK,CAAC5H,GAAG,CAAC,CAAC,EAAE;MAC1D,MAAM,IAAI,CAAC8G,KAAK,CAAClG,MAAM,CAAC1G,gBAAgB,EAAE;QACxC1T,EAAE,EAAE,IAAI,CAACohB,KAAK,CAACoN,WAAW;MAC5B,CAAC,CAAC;IACJ;IAEA,IAAIyI,QAAQ,EAAE;MACZ,MAAMjH,GAAG,GAAG,IAAI,CAAChE,KAAK,CACnB2C,KAAK,CAAClP,QAAQ,CAAC1W,KAAK,EAAE,IAAI,CAACqY,KAAK,CAAC5H,GAAG,CAAC,CACrC0d,OAAO,CAAC,OAAO,EAAE,EAAE,CAAC;MACvB,IAAI,CAAC7C,WAAW,CAAYrE,GAAAA,EAAAA,GAAG,CAAC;MAChC;IACF;IAEA,IAAI,CAACqE,WAAW,CAAS3F,GAAAA,EAAAA,GAAG,CAAC;EAC/B;EAIA4G,UAAUA,CAAC6B,aAAsB,EAAQ;IACvC,MAAMjuB,KAAK,GAAG,IAAI,CAACkY,KAAK,CAAC5H,GAAG;IAC5B,MAAMiG,QAAQ,GAAG,IAAI,CAAC2B,KAAK,CAACoN,WAAW,EAAE;IACzC,IAAI4I,OAAO,GAAG,KAAK;IACnB,IAAIH,QAAQ,GAAG,KAAK;IACpB,IAAII,SAAS,GAAG,KAAK;IACrB,IAAIC,WAAW,GAAG,KAAK;IACvB,IAAIC,OAAO,GAAG,KAAK;IAEnB,IAAI,CAACJ,aAAa,IAAI,IAAI,CAACnG,OAAO,CAAC,EAAE,CAAC,KAAK,IAAI,EAAE;MAC/C,IAAI,CAAC1Q,KAAK,CAAClG,MAAM,CAAC7I,aAAa,EAAE;QAAEvR,EAAE,EAAE,IAAI,CAACohB,KAAK,CAACoN,WAAW;MAAG,CAAC,CAAC;IACpE;IACA,MAAMgJ,cAAc,GAClB,IAAI,CAACpW,KAAK,CAAC5H,GAAG,GAAGtQ,KAAK,IAAI,CAAC,IAC3B,IAAI,CAAC8iB,KAAK,CAACC,UAAU,CAAC/iB,KAAK,CAAC,KAAqB,EAAA;IAEnD,IAAIsuB,cAAc,EAAE;MAClB,MAAMC,OAAO,GAAG,IAAI,CAACzL,KAAK,CAAC2C,KAAK,CAACzlB,KAAK,EAAE,IAAI,CAACkY,KAAK,CAAC5H,GAAG,CAAC;MACvD,IAAI,CAACmZ,sBAAsB,CAACvY,MAAM,CAACtC,kBAAkB,EAAE;QAAE9X,EAAE,EAAEyf;MAAS,CAAC,CAAC;MACxE,IAAI,CAAC,IAAI,CAAC2B,KAAK,CAACiC,MAAM,EAAE;QAEtB,MAAMqU,aAAa,GAAGD,OAAO,CAACzF,OAAO,CAAC,GAAG,CAAC;QAC1C,IAAI0F,aAAa,GAAG,CAAC,EAAE;UAErB,IAAI,CAACpX,KAAK,CAAClG,MAAM,CAAC/C,yBAAyB,EAAE;YAC3CrX,EAAE,EAAEsJ,8BAA8B,CAACmW,QAAQ,EAAEiY,aAAa;UAC5D,CAAC,CAAC;QACJ;MACF;MACAH,OAAO,GAAGC,cAAc,IAAI,CAAC,MAAM,CAACvU,IAAI,CAACwU,OAAO,CAAC;IACnD;IAEA,IAAItT,IAAI,GAAG,IAAI,CAAC6H,KAAK,CAACC,UAAU,CAAC,IAAI,CAAC7K,KAAK,CAAC5H,GAAG,CAAC;IAChD,IAAI2K,IAAI,KAAA,EAAkB,IAAI,CAACoT,OAAO,EAAE;MACtC,EAAE,IAAI,CAACnW,KAAK,CAAC5H,GAAG;MAChB,IAAI,CAACwX,OAAO,CAAC,EAAE,CAAC;MAChBoG,OAAO,GAAG,IAAI;MACdjT,IAAI,GAAG,IAAI,CAAC6H,KAAK,CAACC,UAAU,CAAC,IAAI,CAAC7K,KAAK,CAAC5H,GAAG,CAAC;IAC9C;IAEA,IACE,CAAC2K,IAAI,KAAyB,EAAA,IAAIA,IAAI,KAAyB,GAAA,KAC/D,CAACoT,OAAO,EACR;MACApT,IAAI,GAAG,IAAI,CAAC6H,KAAK,CAACC,UAAU,CAAC,EAAE,IAAI,CAAC7K,KAAK,CAAC5H,GAAG,CAAC;MAC9C,IAAI2K,IAAI,KAAA,EAAuB,IAAIA,IAAI,OAAmB,EAAE;QAC1D,EAAE,IAAI,CAAC/C,KAAK,CAAC5H,GAAG;MAClB;MACA,IAAI,IAAI,CAACwX,OAAO,CAAC,EAAE,CAAC,KAAK,IAAI,EAAE;QAC7B,IAAI,CAAC1Q,KAAK,CAAClG,MAAM,CAAC5I,wBAAwB,EAAE;UAAExR,EAAE,EAAEyf;QAAS,CAAC,CAAC;MAC/D;MACA2X,OAAO,GAAG,IAAI;MACdE,WAAW,GAAG,IAAI;MAClBnT,IAAI,GAAG,IAAI,CAAC6H,KAAK,CAACC,UAAU,CAAC,IAAI,CAAC7K,KAAK,CAAC5H,GAAG,CAAC;IAC9C;IAEA,IAAI2K,IAAI,QAAyB,EAAE;MAGjC,IAAIiT,OAAO,IAAII,cAAc,EAAE;QAC7B,IAAI,CAAClX,KAAK,CAAClG,MAAM,CAAC3J,oBAAoB,EAAE;UAAEzQ,EAAE,EAAEyf;QAAS,CAAC,CAAC;MAC3D;MACA,EAAE,IAAI,CAAC2B,KAAK,CAAC5H,GAAG;MAChByd,QAAQ,GAAG,IAAI;IACjB;IAEA,IAAI9S,IAAI,QAAyB,EAAE;MACjC,IAAI,CAAC+Q,YAAY,CAAC,SAAS,EAAE,IAAI,CAAC9T,KAAK,CAACoN,WAAW,EAAE,CAAC;MACtD,IAAI8I,WAAW,IAAIE,cAAc,EAAE;QACjC,IAAI,CAAClX,KAAK,CAAClG,MAAM,CAACxJ,cAAc,EAAE;UAAE5Q,EAAE,EAAEyf;QAAS,CAAC,CAAC;MACrD;MACA,EAAE,IAAI,CAAC2B,KAAK,CAAC5H,GAAG;MAChB6d,SAAS,GAAG,IAAI;IAClB;IAEA,IAAIrU,iBAAiB,CAAC,IAAI,CAAC6Q,cAAc,CAAC,IAAI,CAACzS,KAAK,CAAC5H,GAAG,CAAC,CAAC,EAAE;MAC1D,MAAM,IAAI,CAAC8G,KAAK,CAAClG,MAAM,CAAC1G,gBAAgB,EAAE;QACxC1T,EAAE,EAAE,IAAI,CAACohB,KAAK,CAACoN,WAAW;MAC5B,CAAC,CAAC;IACJ;IAGA,MAAMwB,GAAG,GAAG,IAAI,CAAChE,KAAK,CAAC2C,KAAK,CAACzlB,KAAK,EAAE,IAAI,CAACkY,KAAK,CAAC5H,GAAG,CAAC,CAAC0d,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC;IAEzE,IAAID,QAAQ,EAAE;MACZ,IAAI,CAAC5C,WAAW,CAAYrE,GAAAA,EAAAA,GAAG,CAAC;MAChC;IACF;IAEA,IAAIqH,SAAS,EAAE;MACb,IAAI,CAAChD,WAAW,CAAarE,GAAAA,EAAAA,GAAG,CAAC;MACjC;IACF;IAEA,MAAMtB,GAAG,GAAG6I,OAAO,GAAG3G,QAAQ,CAACZ,GAAG,EAAE,CAAC,CAAC,GAAG2H,UAAU,CAAC3H,GAAG,CAAC;IACxD,IAAI,CAACqE,WAAW,CAAS3F,GAAAA,EAAAA,GAAG,CAAC;EAC/B;EAIA2B,aAAaA,CAACF,cAAuB,EAAiB;IACpD,MAAM;MAAEjlB,IAAI;MAAEsO;IAAI,CAAC,GAAG6W,aAAa,CACjC,IAAI,CAACrE,KAAK,EACV,IAAI,CAAC5K,KAAK,CAAC5H,GAAG,EACd,IAAI,CAAC4H,KAAK,CAAC0L,SAAS,EACpB,IAAI,CAAC1L,KAAK,CAACyL,OAAO,EAClBsD,cAAc,EACd,IAAI,CAACsC,2BAA2B,CACjC;IACD,IAAI,CAACrR,KAAK,CAAC5H,GAAG,GAAGA,GAAG;IACpB,OAAOtO,IAAI;EACb;EAEAurB,UAAUA,CAACmB,KAAa,EAAQ;IAC9B,MAAM;MAAE5H,GAAG;MAAExW,GAAG;MAAEqT,OAAO;MAAEC;IAAU,CAAC,GAAGuC,kBAAkB,CACzDuI,KAAK,KAAA,EAA4B,GAAG,QAAQ,GAAG,QAAQ,EACvD,IAAI,CAAC5L,KAAK,EACV,IAAI,CAAC5K,KAAK,CAAC5H,GAAG,GAAG,CAAC,EAClB,IAAI,CAAC4H,KAAK,CAAC0L,SAAS,EACpB,IAAI,CAAC1L,KAAK,CAACyL,OAAO,EAClB,IAAI,CAAC6F,uCAAuC,CAC7C;IACD,IAAI,CAACtR,KAAK,CAAC5H,GAAG,GAAGA,GAAG,GAAG,CAAC;IACxB,IAAI,CAAC4H,KAAK,CAAC0L,SAAS,GAAGA,SAAS;IAChC,IAAI,CAAC1L,KAAK,CAACyL,OAAO,GAAGA,OAAO;IAC5B,IAAI,CAACwH,WAAW,CAAYrE,GAAAA,EAAAA,GAAG,CAAC;EAClC;EAGA6H,wBAAwBA,CAAAA,EAAS;IAC/B,IAAI,CAAC,IAAI,CAACpH,KAAK,GAAW,EAAE;MAC1B,IAAI,CAAC/e,UAAU,CAAC,IAAI,EAAY,CAAA,CAAA;IAClC;IAEA,IAAI,CAAC0P,KAAK,CAAC5H,GAAG,EAAE;IAChB,IAAI,CAAC+c,iBAAiB,EAAE;EAC1B;EAGAA,iBAAiBA,CAAAA,EAAS;IACxB,MAAMuB,OAAO,GAAG,IAAI,CAAC9L,KAAK,CAAC,IAAI,CAAC5K,KAAK,CAAC5H,GAAG,CAAC;IAC1C,MAAM;MAAEwW,GAAG;MAAEN,eAAe;MAAElW,GAAG;MAAEqT,OAAO;MAAEC;IAAU,CAAC,GACrDuC,kBAAkB,CAChB,UAAU,EACV,IAAI,CAACrD,KAAK,EACV,IAAI,CAAC5K,KAAK,CAAC5H,GAAG,GAAG,CAAC,EAClB,IAAI,CAAC4H,KAAK,CAAC0L,SAAS,EACpB,IAAI,CAAC1L,KAAK,CAACyL,OAAO,EAClB,IAAI,CAAC+F,yCAAyC,CAC/C;IACH,IAAI,CAACxR,KAAK,CAAC5H,GAAG,GAAGA,GAAG,GAAG,CAAC;IACxB,IAAI,CAAC4H,KAAK,CAAC0L,SAAS,GAAGA,SAAS;IAChC,IAAI,CAAC1L,KAAK,CAACyL,OAAO,GAAGA,OAAO;IAE5B,IAAI6C,eAAe,EAAE;MACnB,IAAI,CAACtO,KAAK,CAACgN,6BAA6B,GAAG,IAAIxlB,QAAQ,CACrD8mB,eAAe,CAAC7C,OAAO,EACvB6C,eAAe,CAAClW,GAAG,GAAGkW,eAAe,CAAC5C,SAAS,EAC/C4C,eAAe,CAAClW,GAAG,CACpB;IACH;IAEA,IAAI,IAAI,CAACwS,KAAK,CAAC+J,WAAW,CAACvc,GAAG,CAAC,KAAA,EAA0B,EAAE;MACzD,IAAI,CAAC6a,WAAW,CAEd3E,EAAAA,EAAAA,eAAe,GAAG,IAAI,GAAGoI,OAAO,GAAG9H,GAAG,GAAG,GAAG,CAC7C;IACH,CAAC,MAAM;MACL,IAAI,CAAC5O,KAAK,CAAC5H,GAAG,EAAE;MAChB,IAAI,CAAC6a,WAAW,CAEd3E,EAAAA,EAAAA,eAAe,GAAG,IAAI,GAAGoI,OAAO,GAAG9H,GAAG,GAAG,IAAI,CAC9C;IACH;EACF;EAEA2C,sBAAsBA,CACpBuB,YAAiC,EACjC;IAAEl0B;EAAqB,CAAC,EACxB;IACA,MAAM+I,KAAK,GAAG/I,EAAE,CAAC+I,KAAK;IAEtB,IAAI,IAAI,CAACqY,KAAK,CAACiC,MAAM,IAAI,CAAC,IAAI,CAACjC,KAAK,CAACiN,YAAY,CAACxK,GAAG,CAAC9a,KAAK,CAAC,EAAE;MAC5D,IAAI,CAACuX,KAAK,CAAC4T,YAAY,EAAE;QAAEl0B;MAAG,CAAC,CAAC;IAClC,CAAC,MAAM;MACL,IAAI,CAACohB,KAAK,CAACiN,YAAY,CAAClxB,GAAG,CAAC4L,KAAK,EAAE,CAACmrB,YAAY,EAAEl0B,EAAE,CAAC,CAAC;IACxD;EACF;EAWAm1B,SAASA,CAAC4C,SAAkB,EAAU;IACpC,IAAI,CAAC3W,KAAK,CAAC+M,WAAW,GAAG,KAAK;IAC9B,IAAIzK,IAAI,GAAG,EAAE;IACb,MAAMxa,KAAK,GAAG,IAAI,CAACkY,KAAK,CAAC5H,GAAG;IAC5B,IAAImW,UAAU,GAAG,IAAI,CAACvO,KAAK,CAAC5H,GAAG;IAC/B,IAAIue,SAAS,KAAKh+B,SAAS,EAAE;MAC3B,IAAI,CAACqnB,KAAK,CAAC5H,GAAG,IAAIue,SAAS,IAAI,MAAM,GAAG,CAAC,GAAG,CAAC;IAC/C;IAEA,OAAO,IAAI,CAAC3W,KAAK,CAAC5H,GAAG,GAAG,IAAI,CAAC7Q,MAAM,EAAE;MACnC,MAAMumB,EAAE,GAAG,IAAI,CAAC2E,cAAc,CAAC,IAAI,CAACzS,KAAK,CAAC5H,GAAG,CAAC;MAC9C,IAAI2J,gBAAgB,CAAC+L,EAAE,CAAC,EAAE;QACxB,IAAI,CAAC9N,KAAK,CAAC5H,GAAG,IAAI0V,EAAE,IAAI,MAAM,GAAG,CAAC,GAAG,CAAC;MACxC,CAAC,MAAM,IAAIA,EAAE,KAAA,EAAwB,EAAE;QACrC,IAAI,CAAC9N,KAAK,CAAC+M,WAAW,GAAG,IAAI;QAE7BzK,IAAI,IAAI,IAAI,CAACsI,KAAK,CAAC2C,KAAK,CAACgB,UAAU,EAAE,IAAI,CAACvO,KAAK,CAAC5H,GAAG,CAAC;QACpD,MAAMwe,QAAQ,GAAG,IAAI,CAAC5W,KAAK,CAACoN,WAAW,EAAE;QACzC,MAAMyJ,eAAe,GACnB,IAAI,CAAC7W,KAAK,CAAC5H,GAAG,KAAKtQ,KAAK,GAAG8Z,iBAAiB,GAAGG,gBAAgB;QAEjE,IAAI,IAAI,CAAC6I,KAAK,CAACC,UAAU,CAAC,EAAE,IAAI,CAAC7K,KAAK,CAAC5H,GAAG,CAAC,QAAyB,EAAE;UACpE,IAAI,CAAC8G,KAAK,CAAClG,MAAM,CAACtH,oBAAoB,EAAE;YACtC9S,EAAE,EAAE,IAAI,CAACohB,KAAK,CAACoN,WAAW;UAC5B,CAAC,CAAC;UACFmB,UAAU,GAAG,IAAI,CAACvO,KAAK,CAAC5H,GAAG,GAAG,CAAC;UAC/B;QACF;QAEA,EAAE,IAAI,CAAC4H,KAAK,CAAC5H,GAAG;QAChB,MAAM0e,GAAG,GAAG,IAAI,CAAC7H,aAAa,CAAC,IAAI,CAAC;QACpC,IAAI6H,GAAG,KAAK,IAAI,EAAE;UAChB,IAAI,CAACD,eAAe,CAACC,GAAG,CAAC,EAAE;YACzB,IAAI,CAAC5X,KAAK,CAAClG,MAAM,CAAClL,0BAA0B,EAAE;cAAElP,EAAE,EAAEg4B;YAAS,CAAC,CAAC;UACjE;UAEAtU,IAAI,IAAI7W,MAAM,CAACyjB,aAAa,CAAC4H,GAAG,CAAC;QACnC;QACAvI,UAAU,GAAG,IAAI,CAACvO,KAAK,CAAC5H,GAAG;MAC7B,CAAC,MAAM;QACL;MACF;IACF;IACA,OAAOkK,IAAI,GAAG,IAAI,CAACsI,KAAK,CAAC2C,KAAK,CAACgB,UAAU,EAAE,IAAI,CAACvO,KAAK,CAAC5H,GAAG,CAAC;EAC5D;EAKAkd,QAAQA,CAACqB,SAAkB,EAAQ;IACjC,MAAMrU,IAAI,GAAG,IAAI,CAACyR,SAAS,CAAC4C,SAAS,CAAC;IACtC,MAAMnrB,IAAI,GAAGurB,UAAY,CAACruB,GAAG,CAAC4Z,IAAI,CAAC;IACnC,IAAI9W,IAAI,KAAK7S,SAAS,EAAE;MAGtB,IAAI,CAACs6B,WAAW,CAACznB,IAAI,EAAEzE,cAAc,CAACyE,IAAI,CAAC,CAAC;IAC9C,CAAC,MAAM;MACL,IAAI,CAACynB,WAAW,CAAU3Q,GAAAA,EAAAA,IAAI,CAAC;IACjC;EACF;EAEAoP,mBAAmBA,CAAAA,EAAS;IAC1B,MAAM;MAAElmB;KAAM,GAAG,IAAI,CAACwU,KAAK;IAC3B,IAAIvZ,cAAc,CAAC+E,IAAI,CAAC,IAAI,IAAI,CAACwU,KAAK,CAAC+M,WAAW,EAAE;MAClD,IAAI,CAAC7N,KAAK,CAAClG,MAAM,CAACnJ,0BAA0B,EAAE;QAC5CjR,EAAE,EAAE,IAAI,CAACohB,KAAK,CAAC3B,QAAQ;QACvBvO,YAAY,EAAE/I,cAAc,CAACyE,IAAI;MACnC,CAAC,CAAC;IACJ;EACF;EAWA0T,KAAKA,CACH4T,YAAiD,EACjDkE,eAA8C,EACpB;IAC1B,MAAM;QAAEp4B;MAAe,CAAC,GAAGo4B,eAAe;MAA3B/e,OAAO,GAAAH,6BAAA,CAAKkf,eAAe,EAAAjf,SAAA,CAAA;IAC1C,MAAMC,GAAG,GAAGpZ,EAAE,YAAY4I,QAAQ,GAAG5I,EAAE,GAAGA,EAAE,CAACoZ,GAAG,CAAClQ,KAAK;IAEtD,MAAMmvB,KAAK,GAAGnE,YAAY,CAAC;MAAE9a,GAAG;MAAEC;IAAQ,CAAC,CAAC;IAE5C,IAAI,CAAC,IAAI,CAACle,OAAO,CAACN,aAAa,EAAE,MAAMw9B,KAAK;IAC5C,IAAI,CAAC,IAAI,CAAC/F,WAAW,EAAE,IAAI,CAAClR,KAAK,CAAC2L,MAAM,CAAC/uB,IAAI,CAACq6B,KAAK,CAAC;IAEpD,OAAOA,KAAK;EACd;EAQAC,cAAcA,CACZpE,YAAiD,EACjDkE,eAA8C,EACZ;IAClC,MAAM;QAAEp4B;MAAe,CAAC,GAAGo4B,eAAe;MAA3B/e,OAAO,GAAAH,6BAAA,CAAKkf,eAAe,EAAAje,UAAA,CAAA;IAC1C,MAAMf,GAAG,GAAGpZ,EAAE,YAAY4I,QAAQ,GAAG5I,EAAE,GAAGA,EAAE,CAACoZ,GAAG,CAAClQ,KAAK;IACtD,MAAMsQ,GAAG,GAAGJ,GAAG,CAACrQ,KAAK;IACrB,MAAMgkB,MAAM,GAAG,IAAI,CAAC3L,KAAK,CAAC2L,MAAM;IAEhC,KAAK,IAAI5iB,CAAC,GAAG4iB,MAAM,CAACpkB,MAAM,GAAG,CAAC,EAAEwB,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;MAC3C,MAAMkuB,KAAK,GAAGtL,MAAM,CAAC5iB,CAAC,CAAC;MACvB,IAAIkuB,KAAK,CAACjf,GAAG,CAACrQ,KAAK,KAAKyQ,GAAG,EAAE;QAE3B,OAAQuT,MAAM,CAAC5iB,CAAC,CAAC,GAAG+pB,YAAY,CAAC;UAAE9a,GAAG;UAAEC;QAAQ,CAAC,CAAC;MACpD;MACA,IAAIgf,KAAK,CAACjf,GAAG,CAACrQ,KAAK,GAAGyQ,GAAG,EAAE;IAC7B;IAEA,OAAO,IAAI,CAAC8G,KAAK,CAAC4T,YAAY,EAAEkE,eAAe,CAAC;EAClD;EAIAv7B,aAAaA,CAACg4B,QAAmB,EAAQ,CAAC;EAG1CnjB,UAAUA,CAAC0H,GAAqB,EAAExM,IAAgB,EAAQ;IACxD,MAAM,IAAI,CAAC0T,KAAK,CAAClG,MAAM,CAACrE,eAAe,EAAE;MACvCC,QAAQ,EAAEpJ,IAAI,GAAGzE,cAAc,CAACyE,IAAI,CAAC,GAAG,IAAI;MAC5C5M,EAAE,EAAEoZ,GAAG,IAAI,IAAI,GAAGA,GAAG,GAAG,IAAI,CAACgI,KAAK,CAAC3B;IACrC,CAAC,CAAC;EACJ;EAEAyV,YAAYA,CAAClL,UAAkB,EAAE5Q,GAAc,EAAQ;IACrD,IAAI,IAAI,CAACyH,SAAS,CAACmJ,UAAU,CAAC,EAAE;MAC9B,OAAO,IAAI;IACb;IAEA,MAAM,IAAI,CAAC1J,KAAK,CAAClG,MAAM,CAAC5H,aAAa,EAAE;MACrCxS,EAAE,EAAEoZ,GAAG,IAAI,IAAI,GAAGA,GAAG,GAAG,IAAI,CAACgI,KAAK,CAAC3B,QAAQ;MAC3ChN,aAAa,EAAE,CAACuX,UAAU;IAC5B,CAAC,CAAC;EACJ;EAEAuO,eAAeA,CAACC,WAAqB,EAAQ;IAC3C,IAAI,CAACA,WAAW,CAACC,IAAI,CAACx7B,IAAI,IAAI,IAAI,CAAC4jB,SAAS,CAAC5jB,IAAI,CAAC,CAAC,EAAE;MACnD,MAAM,IAAI,CAACqjB,KAAK,CAAClG,MAAM,CAACvH,mBAAmB,EAAE;QAC3C7S,EAAE,EAAE,IAAI,CAACohB,KAAK,CAAC3B,QAAQ;QACvBhN,aAAa,EAAE+lB;MACjB,CAAC,CAAC;IACJ;EACF;EAEAhG,YAAYA,CAAC6F,KAAgC,EAAE;IAC7C,OAAO,CAAC7e,GAAW,EAAEsT,SAAiB,EAAED,OAAe,KAAK;MAC1D,IAAI,CAACvM,KAAK,CAAC+X,KAAK,EAAE;QAChBr4B,EAAE,EAAEkyB,aAAa,CAAC1Y,GAAG,EAAEsT,SAAS,EAAED,OAAO;MAC3C,CAAC,CAAC;KACH;EACH;AAmDF;ACpkDO,MAAM6L,UAAU,CAAC;EAAAl9B,WAAAA,CAAA,EAAA;IAAA,IAAA,CAEtBm9B,YAAY,GAAgB,IAAI1gB,GAAG,EAAE;IAAA,IAAA,CAGrC2gB,aAAa,GAAmC,IAAI77B,GAAG,EAAE;IAAA,IAAA,CAIzD87B,qBAAqB,GAA0B,IAAI97B,GAAG,EAAE;EAAA;AAC1D;AAEe,MAAM+7B,iBAAiB,CAAC;EAKrCt9B,WAAWA,CAACosB,MAAiB,EAAE;IAAA,IAAA,CAJ/BA,MAAM,GAAA,KAAA,CAAA;IAAA,IACNmR,CAAAA,KAAK,GAAsB,EAAE;IAAA,IAAA,CAC7BF,qBAAqB,GAA0B,IAAI97B,GAAG,EAAE;IAGtD,IAAI,CAAC6qB,MAAM,GAAGA,MAAM;EACtB;EAEA1D,OAAOA,CAAAA,EAAe;IACpB,OAAO,IAAI,CAAC6U,KAAK,CAAC,IAAI,CAACA,KAAK,CAACpwB,MAAM,GAAG,CAAC,CAAC;EAC1C;EAEAigB,KAAKA,CAAAA,EAAG;IACN,IAAI,CAACmQ,KAAK,CAAC/6B,IAAI,CAAC,IAAI06B,UAAU,EAAE,CAAC;EACnC;EAEA7P,IAAIA,CAAAA,EAAG;IACL,MAAMmQ,aAAa,GAAG,IAAI,CAACD,KAAK,CAACtwB,GAAG,EAAE;IAKtC,MAAMyb,OAAO,GAAG,IAAI,CAACA,OAAO,EAAE;IAG9B,KAAK,MAAM,CAACjnB,IAAI,EAAEmc,GAAG,CAAC,IAAIQ,KAAK,CAACqf,IAAI,CAACD,aAAa,CAACH,qBAAqB,CAAC,EAAE;MACzE,IAAI3U,OAAO,EAAE;QACX,IAAI,CAACA,OAAO,CAAC2U,qBAAqB,CAAChV,GAAG,CAAC5mB,IAAI,CAAC,EAAE;UAC5CinB,OAAO,CAAC2U,qBAAqB,CAAC17B,GAAG,CAACF,IAAI,EAAEmc,GAAG,CAAC;QAC9C;MACF,CAAC,MAAM;QACL,IAAI,CAACwO,MAAM,CAACtH,KAAK,CAAClG,MAAM,CAACxI,6BAA6B,EAAE;UACtD5R,EAAE,EAAEoZ,GAAG;UACP/P,cAAc,EAAEpM;QAClB,CAAC,CAAC;MACJ;IACF;EACF;EAEAi8B,kBAAkBA,CAChBj8B,IAAY,EACZk8B,WAA8B,EAC9B/f,GAAa,EACb;IACA,MAAM;MAAEuf,YAAY;MAAEC,aAAa;MAAEC;IAAsB,CAAC,GAC1D,IAAI,CAAC3U,OAAO,EAAE;IAChB,IAAIkV,SAAS,GAAGT,YAAY,CAAC9U,GAAG,CAAC5mB,IAAI,CAAC;IAEtC,IAAIk8B,WAAW,GAAGlS,2BAA2B,EAAE;MAC7C,MAAMoS,QAAQ,GAAGD,SAAS,IAAIR,aAAa,CAAC9uB,GAAG,CAAC7M,IAAI,CAAC;MACrD,IAAIo8B,QAAQ,EAAE;QACZ,MAAMC,SAAS,GAAGD,QAAQ,GAAGvS,yBAAyB;QACtD,MAAMyS,SAAS,GAAGJ,WAAW,GAAGrS,yBAAyB;QAEzD,MAAM0S,OAAO,GAAGH,QAAQ,GAAGpS,2BAA2B;QACtD,MAAMwS,OAAO,GAAGN,WAAW,GAAGlS,2BAA2B;QAKzDmS,SAAS,GAAGI,OAAO,KAAKC,OAAO,IAAIH,SAAS,KAAKC,SAAS;QAE1D,IAAI,CAACH,SAAS,EAAER,aAAa,CAACxP,MAAM,CAACnsB,IAAI,CAAC;MAC5C,CAAC,MAAM,IAAI,CAACm8B,SAAS,EAAE;QACrBR,aAAa,CAACz7B,GAAG,CAACF,IAAI,EAAEk8B,WAAW,CAAC;MACtC;IACF;IAEA,IAAIC,SAAS,EAAE;MACb,IAAI,CAACxR,MAAM,CAACtH,KAAK,CAAClG,MAAM,CAAChG,wBAAwB,EAAE;QACjDpU,EAAE,EAAEoZ,GAAG;QACP/P,cAAc,EAAEpM;MAClB,CAAC,CAAC;IACJ;IAEA07B,YAAY,CAACzP,GAAG,CAACjsB,IAAI,CAAC;IACtB47B,qBAAqB,CAACzP,MAAM,CAACnsB,IAAI,CAAC;EACpC;EAEAkjB,cAAcA,CAACljB,IAAY,EAAEmc,GAAa,EAAE;IAC1C,IAAI8G,UAAU;IACd,KAAKA,UAAU,IAAI,IAAI,CAAC6Y,KAAK,EAAE;MAC7B,IAAI7Y,UAAU,CAACyY,YAAY,CAAC9U,GAAG,CAAC5mB,IAAI,CAAC,EAAE;IACzC;IAEA,IAAIijB,UAAU,EAAE;MACdA,UAAU,CAAC2Y,qBAAqB,CAAC17B,GAAG,CAACF,IAAI,EAAEmc,GAAG,CAAC;IACjD,CAAC,MAAM;MAEL,IAAI,CAACwO,MAAM,CAACtH,KAAK,CAAClG,MAAM,CAACxI,6BAA6B,EAAE;QACtD5R,EAAE,EAAEoZ,GAAG;QACP/P,cAAc,EAAEpM;MAClB,CAAC,CAAC;IACJ;EACF;AACF;ACpEA,MAAMy8B,WAAW,GAAG,CAAC;EACnBC,+BAA+B,GAAG,CAAC;EACnCC,oCAAoC,GAAG,CAAC;EACxCC,qBAAqB,GAAG,CAAC;AAI3B,MAAMC,eAAe,CAAC;EAGpBt+B,WAAWA,CAACoR,IAAyB,GAAG8sB,WAAW,EAAE;IAAA,IAAA,CAFrD9sB,IAAI,GAAA,KAAA,CAAA;IAGF,IAAI,CAACA,IAAI,GAAGA,IAAI;EAClB;EAEAmtB,8BAA8BA,CAAAA,EAAkC;IAC9D,OACE,IAAI,CAACntB,IAAI,KAAKgtB,oCAAoC,IAClD,IAAI,CAAChtB,IAAI,KAAK+sB,+BAA+B;EAEjD;EAEAK,+BAA+BA,CAAAA,EAAG;IAChC,OAAO,IAAI,CAACptB,IAAI,KAAKitB,qBAAqB;EAC5C;AACF;AAUA,MAAMI,qBAAqB,SAASH,eAAe,CAAC;EAGlDt+B,WAAWA,CAACoR,IAAW,EAAE;IACvB,KAAK,CAACA,IAAI,CAAC;IAAC,IAAA,CAHdstB,iBAAiB,GACf,IAAIn9B,GAAG,EAAE;EAGX;EACAo9B,sBAAsBA,CACpBC,iBAA4C,EAC5C;IACEp6B;EAGF,CAAC,EACD;IACA,MAAM+I,KAAK,GAAG/I,EAAE,CAAC+I,KAAK;IAEtB,IAAI,CAACmxB,iBAAiB,CAAC/8B,GAAG,CAAC4L,KAAK,EAAE,CAACqxB,iBAAiB,EAAEp6B,EAAE,CAAC,CAAC;EAC5D;EACAq6B,qBAAqBA,CAACtxB,KAAa,EAAE;IACnC,IAAI,CAACmxB,iBAAiB,CAAC9Q,MAAM,CAACrgB,KAAK,CAAC;EACtC;EACAuxB,aAAaA,CACXC,QAAmE,EACnE;IACA,IAAI,CAACL,iBAAiB,CAACjG,OAAO,CAACsG,QAAQ,CAAC;EAC1C;AACF;AAEe,MAAMC,sBAAsB,CAAC;EAI1Ch/B,WAAWA,CAACosB,MAAiB,EAAE;IAAA,IAAA,CAH/BA,MAAM,GAAA,KAAA,CAAA;IAAA,IAAA,CACNmR,KAAK,GAA2B,CAAC,IAAIe,eAAe,EAAE,CAAC;IAGrD,IAAI,CAAClS,MAAM,GAAGA,MAAM;EACtB;EACAgB,KAAKA,CAACE,KAAsB,EAAE;IAC5B,IAAI,CAACiQ,KAAK,CAAC/6B,IAAI,CAAC8qB,KAAK,CAAC;EACxB;EAEAD,IAAIA,CAAAA,EAAG;IACL,IAAI,CAACkQ,KAAK,CAACtwB,GAAG,EAAE;EAClB;EASAgyB,+BAA+BA,CAC7BvG,YAAuD,EACvD;IACEl0B,EAAE,EAAEua;EAGN,CAAC,EACK;IACN,MAAMmgB,MAAM,GAAG;MAAE16B,EAAE,EAAEua,IAAI,CAACnB,GAAG,CAAClQ;KAAO;IACrC,MAAM;MAAE6vB;IAAO,CAAA,GAAG,IAAI;IACtB,IAAI5uB,CAAC,GAAG4uB,KAAK,CAACpwB,MAAM,GAAG,CAAC;IACxB,IAAImgB,KAAsB,GAAGiQ,KAAK,CAAC5uB,CAAC,CAAC;IACrC,OAAO,CAAC2e,KAAK,CAACkR,+BAA+B,EAAE,EAAE;MAC/C,IAAIlR,KAAK,CAACiR,8BAA8B,EAAE,EAAE;QAC1CjR,KAAK,CAACqR,sBAAsB,CAACjG,YAAY,EAAEwG,MAAM,CAAC;MACpD,CAAC,MAAM;QAGL;MACF;MACA5R,KAAK,GAAGiQ,KAAK,CAAC,EAAE5uB,CAAC,CAAC;IACpB;IACA,IAAI,CAACyd,MAAM,CAACtH,KAAK,CAAC4T,YAAY,EAAEwG,MAAM,CAAC;EACzC;EAqBAC,gCAAgCA,CAC9BtC,KAAgC,EAChC;IACEr4B,EAAE,EAAEua;EAGN,CAAC,EACK;IACN,MAAM;MAAEwe;IAAO,CAAA,GAAG,IAAI;IACtB,MAAMjQ,KAAsB,GAAGiQ,KAAK,CAACA,KAAK,CAACpwB,MAAM,GAAG,CAAC,CAAC;IACtD,MAAM+xB,MAAM,GAAG;MAAE16B,EAAE,EAAEua,IAAI,CAACnB,GAAG,CAAClQ;KAAO;IACrC,IAAI4f,KAAK,CAACkR,+BAA+B,EAAE,EAAE;MAC3C,IAAI,CAACpS,MAAM,CAACtH,KAAK,CAAC+X,KAAK,EAAEqC,MAAM,CAAC;IAClC,CAAC,MAAM,IAAI5R,KAAK,CAACiR,8BAA8B,EAAE,EAAE;MACjDjR,KAAK,CAACqR,sBAAsB,CAAC9B,KAAK,EAAEqC,MAAM,CAAC;IAC7C,CAAC,MAAM;MACL;IACF;EACF;EAQAE,+BAA+BA,CAAC;IAAE56B;EAAqB,CAAC,EAAQ;IAC9D,MAAM;MAAE+4B;IAAO,CAAA,GAAG,IAAI;IACtB,IAAI5uB,CAAC,GAAG4uB,KAAK,CAACpwB,MAAM,GAAG,CAAC;IACxB,IAAImgB,KAAsB,GAAGiQ,KAAK,CAAC5uB,CAAC,CAAC;IACrC,OAAO2e,KAAK,CAACiR,8BAA8B,EAAE,EAAE;MAC7C,IAAIjR,KAAK,CAAClc,IAAI,KAAKgtB,oCAAoC,EAAE;QACvD9Q,KAAK,CAACqR,sBAAsB,CAAC/f,MAAM,CAACjN,sBAAsB,EAAE;UAAEnN;QAAG,CAAC,CAAC;MACrE;MACA8oB,KAAK,GAAGiQ,KAAK,CAAC,EAAE5uB,CAAC,CAAC;IACpB;EACF;EAEA0wB,iBAAiBA,CAAAA,EAAS;IACxB,MAAM;MAAE9B;IAAO,CAAA,GAAG,IAAI;IACtB,MAAM/Q,YAAY,GAAG+Q,KAAK,CAACA,KAAK,CAACpwB,MAAM,GAAG,CAAC,CAAC;IAC5C,IAAI,CAACqf,YAAY,CAAC+R,8BAA8B,EAAE,EAAE;IACpD/R,YAAY,CAACsS,aAAa,CAAC,CAAC,CAACpG,YAAY,EAAE9a,GAAG,CAAC,KAAK;MAClD,IAAI,CAACwO,MAAM,CAACtH,KAAK,CAAC4T,YAAY,EAAE;QAAEl0B,EAAE,EAAEoZ;MAAI,CAAC,CAAC;MAE5C,IAAIjP,CAAC,GAAG4uB,KAAK,CAACpwB,MAAM,GAAG,CAAC;MACxB,IAAImgB,KAAK,GAAGiQ,KAAK,CAAC5uB,CAAC,CAAC;MACpB,OAAO2e,KAAK,CAACiR,8BAA8B,EAAE,EAAE;QAC7CjR,KAAK,CAACuR,qBAAqB,CAACjhB,GAAG,CAACrQ,KAAK,CAAC;QACtC+f,KAAK,GAAGiQ,KAAK,CAAC,EAAE5uB,CAAC,CAAC;MACpB;IACF,CAAC,CAAC;EACJ;AACF;AAEO,SAAS2wB,4BAA4BA,CAAAA,EAAG;EAC7C,OAAO,IAAIhB,eAAe,CAACD,qBAAqB,CAAC;AACnD;AAEO,SAASkB,iBAAiBA,CAAAA,EAAG;EAClC,OAAO,IAAId,qBAAqB,CAACN,+BAA+B,CAAC;AACnE;AAEO,SAASqB,kBAAkBA,CAAAA,EAAG;EACnC,OAAO,IAAIf,qBAAqB,CAACL,oCAAoC,CAAC;AACxE;AAEO,SAASqB,kBAAkBA,CAAAA,EAAG;EACnC,OAAO,IAAInB,eAAe,EAAE;AAC9B;ACtPO,MACLoB,KAAK,GAAG,MAAM;EAEdC,WAAW,GAAG,MAAM;EAEpBC,WAAW,GAAG,MAAM;EAEpBC,YAAY,GAAG,MAAM;EACrBC,QAAQ,GAAG,MAAM;AAkCJ,MAAMC,0BAA0B,CAAC;EAAA//B,WAAAA,CAAA,EAAA;IAAA,IAC9CggC,CAAAA,MAAM,GAAkB,EAAE;EAAA;EAC1B5S,KAAKA,CAAC7N,KAAa,EAAE;IACnB,IAAI,CAACygB,MAAM,CAACx9B,IAAI,CAAC+c,KAAK,CAAC;EACzB;EAEA8N,IAAIA,CAAAA,EAAG;IACL,IAAI,CAAC2S,MAAM,CAAC/yB,GAAG,EAAE;EACnB;EAEAgzB,YAAYA,CAAAA,EAAW;IACrB,OAAO,IAAI,CAACD,MAAM,CAAC,IAAI,CAACA,MAAM,CAAC7yB,MAAM,GAAG,CAAC,CAAC;EAC5C;EAEA,IAAI+yB,QAAQA,CAAAA,EAAY;IACtB,OAAO,CAAC,IAAI,CAACD,YAAY,EAAE,GAAGL,WAAW,IAAI,CAAC;EAChD;EAEA,IAAIO,QAAQA,CAAAA,EAAY;IACtB,OAAO,CAAC,IAAI,CAACF,YAAY,EAAE,GAAGN,WAAW,IAAI,CAAC;EAChD;EAEA,IAAIS,SAASA,CAAAA,EAAY;IACvB,OAAO,CAAC,IAAI,CAACH,YAAY,EAAE,GAAGJ,YAAY,IAAI,CAAC;EACjD;EAEA,IAAIQ,KAAKA,CAAAA,EAAY;IACnB,OAAO,CAAC,IAAI,CAACJ,YAAY,EAAE,GAAGH,QAAQ,IAAI,CAAC;EAC7C;AACF;AAEO,SAASQ,aAAaA,CAC3Bvf,OAAgB,EAChBoB,WAAoB,EACT;EACX,OAAO,CAACpB,OAAO,GAAG6e,WAAW,GAAG,CAAC,KAAKzd,WAAW,GAAGwd,WAAW,GAAG,CAAC,CAAC;AACtE;ACzCe,MAAeY,UAAU,SAAS1J,SAAS,CAAC;EAIzD2J,QAAQA,CACNzhB,IAAmB,EACnBnf,GAAW,EACX6O,KAAU,EACVS,UAAmB,GAAG,IAAI,EACpB;IACN,IAAI,CAAC6P,IAAI,EAAE;IAEX,MAAM2B,KAAK,GAAI3B,IAAI,CAAC2B,KAAK,GAAG3B,IAAI,CAAC2B,KAAK,IAAI,CAAA,CAAG;IAC7C,IAAIxR,UAAU,EAAE;MACdwR,KAAK,CAAC9gB,GAAG,CAAC,GAAG6O,KAAK;IACpB,CAAC,MAAM;MACL5O,MAAM,CAACwP,cAAc,CAACqR,KAAK,EAAE9gB,GAAG,EAAE;QAAEsP,UAAU;QAAET;MAAM,CAAC,CAAC;IAC1D;EACF;EAIAgyB,YAAYA,CAACxgC,KAAgB,EAAW;IACtC,OAAO,IAAI,CAAC2lB,KAAK,CAACxU,IAAI,KAAKnR,KAAK,IAAI,CAAC,IAAI,CAAC2lB,KAAK,CAAC+M,WAAW;EAC7D;EAEA+N,oBAAoBA,CAACC,SAAiB,EAAEl/B,IAAY,EAAW;IAC7D,MAAMm/B,OAAO,GAAGD,SAAS,GAAGl/B,IAAI,CAAC0L,MAAM;IACvC,IAAI,IAAI,CAACqjB,KAAK,CAAC2C,KAAK,CAACwN,SAAS,EAAEC,OAAO,CAAC,KAAKn/B,IAAI,EAAE;MACjD,MAAMo/B,MAAM,GAAG,IAAI,CAACrQ,KAAK,CAACC,UAAU,CAACmQ,OAAO,CAAC;MAC7C,OAAO,EACLjZ,gBAAgB,CAACkZ,MAAM,CAAC,IAIxB,CAACA,MAAM,GAAG,MAAM,MAAM,MAAM,CAC7B;IACH;IACA,OAAO,KAAK;EACd;EAEAC,qBAAqBA,CAACr/B,IAAY,EAAW;IAC3C,MAAMknB,IAAI,GAAG,IAAI,CAACmP,cAAc,EAAE;IAClC,OAAO,IAAI,CAAC4I,oBAAoB,CAAC/X,IAAI,EAAElnB,IAAI,CAAC;EAC9C;EAIAs/B,aAAaA,CAAC9gC,KAAgB,EAAW;IACvC,IAAI,IAAI,CAACwgC,YAAY,CAACxgC,KAAK,CAAC,EAAE;MAC5B,IAAI,CAAC0oB,IAAI,EAAE;MACX,OAAO,IAAI;IACb;IACA,OAAO,KAAK;EACd;EAIAqY,gBAAgBA,CACd/gC,KAAgB,EAChBy4B,YAAyC,EACnC;IACN,IAAI,CAAC,IAAI,CAACqI,aAAa,CAAC9gC,KAAK,CAAC,EAAE;MAC9B,IAAIy4B,YAAY,IAAI,IAAI,EAAE;QACxB,MAAM,IAAI,CAAC5T,KAAK,CAAC4T,YAAY,EAAE;UAAEl0B,EAAE,EAAE,IAAI,CAACohB,KAAK,CAAC3B;QAAS,CAAC,CAAC;MAC7D;MACA,IAAI,CAAC/N,UAAU,CAAC,IAAI,EAAEjW,KAAK,CAAC;IAC9B;EACF;EAIAghC,kBAAkBA,CAAAA,EAAY;IAC5B,OACE,IAAI,CAAChM,KAAK,CAAA,GAAA,CAAQ,IAClB,IAAI,CAACA,KAAK,CAAW,CAAA,CAAA,IACrB,IAAI,CAACiM,qBAAqB,EAAE;EAEhC;EAEAA,qBAAqBA,CAAAA,EAAY;IAC/B,OAAOrQ,SAAS,CAACpJ,IAAI,CACnB,IAAI,CAAC+I,KAAK,CAAC2C,KAAK,CAAC,IAAI,CAACvN,KAAK,CAACoB,aAAa,CAACzZ,KAAK,EAAE,IAAI,CAACqY,KAAK,CAAClY,KAAK,CAAC,CACnE;EACH;EAEAyzB,qBAAqBA,CAAAA,EAAY;IAC/BjQ,yBAAyB,CAAC8G,SAAS,GAAG,IAAI,CAACpS,KAAK,CAACjY,GAAG;IACpD,OAAOujB,yBAAyB,CAACzJ,IAAI,CAAC,IAAI,CAAC+I,KAAK,CAAC;EACnD;EAEA4Q,gBAAgBA,CAAAA,EAAY;IAC1B,OAAO,IAAI,CAAC5J,GAAG,CAAA,EAAA,CAAS,IAAI,IAAI,CAACyJ,kBAAkB,EAAE;EACvD;EAKAI,SAASA,CAACC,QAAiB,GAAG,IAAI,EAAQ;IACxC,IAAIA,QAAQ,GAAG,IAAI,CAACF,gBAAgB,EAAE,GAAG,IAAI,CAAC5J,GAAG,CAAA,EAAA,CAAS,EAAE;IAC5D,IAAI,CAAC1S,KAAK,CAAClG,MAAM,CAAC7H,gBAAgB,EAAE;MAAEvS,EAAE,EAAE,IAAI,CAACohB,KAAK,CAACoB;IAAc,CAAC,CAAC;EACvE;EAKAua,MAAMA,CAACnwB,IAAe,EAAEwM,GAAqB,EAAQ;IACnD,IAAI,CAAC4Z,GAAG,CAACpmB,IAAI,CAAC,IAAI,IAAI,CAAC8E,UAAU,CAAC0H,GAAG,EAAExM,IAAI,CAAC;EAC9C;EAIAowB,QAAQA,CACNC,EAAqC,EACrCC,QAAe,GAAG,IAAI,CAAC9b,KAAK,CAAC9H,KAAK,EAAE,EAIW;IAC/C,MAAM6jB,WAEL,GAAG;MAAE5iB,IAAI,EAAE;KAAM;IAClB,IAAI;MACF,MAAMA,IAAI,GAAG0iB,EAAE,CAAC,CAAC1iB,IAAI,GAAG,IAAI,KAAK;QAC/B4iB,WAAW,CAAC5iB,IAAI,GAAGA,IAAI;QACvB,MAAM4iB,WAAW;MACnB,CAAC,CAAC;MACF,IAAI,IAAI,CAAC/b,KAAK,CAAC2L,MAAM,CAACpkB,MAAM,GAAGu0B,QAAQ,CAACnQ,MAAM,CAACpkB,MAAM,EAAE;QACrD,MAAMy0B,SAAS,GAAG,IAAI,CAAChc,KAAK;QAC5B,IAAI,CAACA,KAAK,GAAG8b,QAAQ;QAIrB,IAAI,CAAC9b,KAAK,CAACkN,YAAY,GAAG8O,SAAS,CAAC9O,YAAY;QAChD,OAAO;UACL/T,IAAI;UACJ8d,KAAK,EAAE+E,SAAS,CAACrQ,MAAM,CAACmQ,QAAQ,CAACnQ,MAAM,CAACpkB,MAAM,CAAC;UAC/C00B,MAAM,EAAE,KAAK;UACbC,OAAO,EAAE,KAAK;UACdF;SACD;MACH;MAEA,OAAO;QACL7iB,IAAI;QACJ8d,KAAK,EAAE,IAAI;QACXgF,MAAM,EAAE,KAAK;QACbC,OAAO,EAAE,KAAK;QACdF,SAAS,EAAE;OACZ;IACF,CAAA,CAAC,OAAO/E,KAAK,EAAE;MACd,MAAM+E,SAAS,GAAG,IAAI,CAAChc,KAAK;MAC5B,IAAI,CAACA,KAAK,GAAG8b,QAAQ;MACrB,IAAI7E,KAAK,YAAY3uB,WAAW,EAAE;QAEhC,OAAO;UAAE6Q,IAAI,EAAE,IAAI;UAAE8d,KAAK;UAAEgF,MAAM,EAAE,IAAI;UAAEC,OAAO,EAAE,KAAK;UAAEF;SAAW;MACvE;MACA,IAAI/E,KAAK,KAAK8E,WAAW,EAAE;QACzB,OAAO;UACL5iB,IAAI,EAAE4iB,WAAW,CAAC5iB,IAAI;UACtB8d,KAAK,EAAE,IAAI;UACXgF,MAAM,EAAE,KAAK;UACbC,OAAO,EAAE,IAAI;UACbF;SACD;MACH;MAEA,MAAM/E,KAAK;IACb;EACF;EAEAkF,qBAAqBA,CACnB7d,mBAAwD,EACxD8d,QAAiB,EACjB;IACA,IAAI,CAAC9d,mBAAmB,EAAE,OAAO,KAAK;IACtC,MAAM;MACJ+d,kBAAkB;MAClBC,cAAc;MACdC,aAAa;MACbC;IACD,CAAA,GAAGle,mBAAmB;IAEvB,MAAMme,SAAS,GACb,CAAC,CAACJ,kBAAkB,IACpB,CAAC,CAACC,cAAc,IAChB,CAAC,CAACE,qBAAqB,IACvB,CAAC,CAACD,aAAa;IAEjB,IAAI,CAACH,QAAQ,EAAE;MACb,OAAOK,SAAS;IAClB;IAEA,IAAIJ,kBAAkB,IAAI,IAAI,EAAE;MAC9B,IAAI,CAACnd,KAAK,CAAClG,MAAM,CAACzJ,2BAA2B,EAAE;QAC7C3Q,EAAE,EAAEy9B;MACN,CAAC,CAAC;IACJ;IAEA,IAAIC,cAAc,IAAI,IAAI,EAAE;MAC1B,IAAI,CAACpd,KAAK,CAAClG,MAAM,CAACrL,cAAc,EAAE;QAAE/O,EAAE,EAAE09B;MAAe,CAAC,CAAC;IAC3D;IAEA,IAAIC,aAAa,IAAI,IAAI,EAAE;MACzB,IAAI,CAACrd,KAAK,CAAClG,MAAM,CAACxE,sBAAsB,EAAE;QAAE5V,EAAE,EAAE29B;MAAc,CAAC,CAAC;IAClE;IAEA,IAAIC,qBAAqB,IAAI,IAAI,EAAE;MACjC,IAAI,CAAClsB,UAAU,CAACksB,qBAAqB,CAAC;IACxC;EACF;EAWAE,qBAAqBA,CAAAA,EAAY;IAC/B,OAAOv2B,0BAA0B,CAAC,IAAI,CAAC6Z,KAAK,CAACxU,IAAI,CAAC;EACpD;EAMAyR,aAAaA,CAAC9D,IAAU,EAAW;IACjC,OAAOA,IAAI,CAAC3N,IAAI,KAAK,aAAa;EACpC;EAOAuR,gBAAgBA,CAAC5D,IAAU,EAAU;IACnC,OAAOA,IAAI,CAAC6D,EAAE,CAACnhB,IAAI;EACrB;EAOAklB,wBAAwBA,CAAC5H,IAAU,EAAW;IAC5C,OACE,CAACA,IAAI,CAAC3N,IAAI,KAAK,kBAAkB,IAC/B2N,IAAI,CAAC3N,IAAI,KAAK,0BAA0B,KAC1C,IAAI,CAACyR,aAAa,CAAC9D,IAAI,CAACwjB,QAAQ,CAAC;EAErC;EAEAthB,gBAAgBA,CACdlC,IAAU,EACyC;IACnD,OAAOA,IAAI,CAAC3N,IAAI,KAAK,gBAAgB;EACvC;EAEAwV,cAAcA,CAAC7H,IAAU,EAAW;IAClC,OAAOA,IAAI,CAAC3N,IAAI,KAAK,cAAc;EACrC;EAEAoxB,gBAAgBA,CAEdra,QAAiB,GAAG,IAAI,CAACxoB,OAAO,CAACtB,UAAU,KAAK,QAAQ,EAC5C;IAEZ,MAAMokC,SAAS,GAAG,IAAI,CAAC7c,KAAK,CAAC2M,MAAM;IACnC,IAAI,CAAC3M,KAAK,CAAC2M,MAAM,GAAG,EAAE;IAEtB,MAAMmQ,sBAAsB,GAAG,IAAI,CAACC,mBAAmB;IACvD,IAAI,CAACA,mBAAmB,GAAG,IAAIlmB,GAAG,EAAE;IAGpC,MAAMmmB,WAAW,GAAG,IAAI,CAACza,QAAQ;IACjC,IAAI,CAACA,QAAQ,GAAGA,QAAQ;IAExB,MAAM0a,QAAQ,GAAG,IAAI,CAACvV,KAAK;IAC3B,MAAMnB,YAAY,GAAG,IAAI,CAAC2W,eAAe,EAAE;IAC3C,IAAI,CAACxV,KAAK,GAAG,IAAInB,YAAY,CAAC,IAAI,EAAEhE,QAAQ,CAAC;IAE7C,MAAM4a,YAAY,GAAG,IAAI,CAACC,SAAS;IACnC,IAAI,CAACA,SAAS,GAAG,IAAIjD,0BAA0B,EAAE;IAEjD,MAAMvC,aAAa,GAAG,IAAI,CAAC9Y,UAAU;IACrC,IAAI,CAACA,UAAU,GAAG,IAAI4Y,iBAAiB,CAAC,IAAI,CAAC;IAE7C,MAAM2F,kBAAkB,GAAG,IAAI,CAACC,eAAe;IAC/C,IAAI,CAACA,eAAe,GAAG,IAAIlE,sBAAsB,CAAC,IAAI,CAAC;IAEvD,OAAO,MAAM;MAEX,IAAI,CAACpZ,KAAK,CAAC2M,MAAM,GAAGkQ,SAAS;MAC7B,IAAI,CAACE,mBAAmB,GAAGD,sBAAsB;MAGjD,IAAI,CAACva,QAAQ,GAAGya,WAAW;MAC3B,IAAI,CAACtV,KAAK,GAAGuV,QAAQ;MACrB,IAAI,CAACG,SAAS,GAAGD,YAAY;MAC7B,IAAI,CAACre,UAAU,GAAG8Y,aAAa;MAC/B,IAAI,CAAC0F,eAAe,GAAGD,kBAAkB;KAC1C;EACH;EAEAE,kBAAkBA,CAAAA,EAAG;IACnB,IAAIC,UAAU,GAAG1D,KAAK;IACtB,IAAI,IAAI,CAACvX,QAAQ,EAAE;MACjBib,UAAU,IAAIxD,WAAW;IAC3B;IACA,IAAI,CAACtS,KAAK,CAACF,KAAK,CAACpE,aAAa,CAAC;IAC/B,IAAI,CAACga,SAAS,CAAC5V,KAAK,CAACgW,UAAU,CAAC;EAClC;EAEAC,yBAAyBA,CAACnf,mBAAqC,EAAE;IAC/D,MAAM;MAAEie;IAAe,CAAA,GAAGje,mBAAmB;IAC7C,IAAIie,aAAa,KAAK,IAAI,EAAE;MAC1B,IAAI,CAACzI,YAAY,CAAC,sBAAsB,EAAEyI,aAAa,CAAC;IAC1D;EACF;AACF;AAeO,MAAMmB,gBAAgB,CAAC;EAAAtjC,WAAAA,CAAA,EAAA;IAAA,IAC5BiiC,CAAAA,kBAAkB,GAAgC,IAAI;IAAA,IACtDC,CAAAA,cAAc,GAAgC,IAAI;IAAA,IAClDC,CAAAA,aAAa,GAAgC,IAAI;IAAA,IACjDC,CAAAA,qBAAqB,GAAgC,IAAI;EAAA;AAC3D;ACpXA,MAAMmB,IAAI,CAAqB;EAC7BvjC,WAAWA,CAACosB,MAAc,EAAEpO,GAAW,EAAEJ,GAAa,EAAE;IAAA,IAQxDxM,CAAAA,IAAI,GAAW,EAAE;IAPf,IAAI,CAAC1D,KAAK,GAAGsQ,GAAG;IAChB,IAAI,CAACrQ,GAAG,GAAG,CAAC;IACZ,IAAI,CAACiQ,GAAG,GAAG,IAAInQ,cAAc,CAACmQ,GAAG,CAAC;IAClC,IAAIwO,MAAM,IAANA,IAAAA,IAAAA,MAAM,CAAEzsB,OAAO,CAACT,MAAM,EAAE,IAAI,CAACskC,KAAK,GAAG,CAACxlB,GAAG,EAAE,CAAC,CAAC;IACjD,IAAIoO,MAAM,IAAA,IAAA,IAANA,MAAM,CAAExe,QAAQ,EAAE,IAAI,CAACgQ,GAAG,CAAChQ,QAAQ,GAAGwe,MAAM,CAACxe,QAAQ;EAC3D;AAaF;AACA,MAAM61B,aAAa,GAAGF,IAAI,CAACG,SAAS;AAED;EAEjCD,aAAa,CAACE,OAAO,GAAG,YAAkB;IACxC,MAAMC,OAAO,GAAG,IAAIL,IAAI,CAAChlC,SAAS,EAAE,IAAI,CAACmP,KAAK,EAAE,IAAI,CAACkQ,GAAG,CAAClQ,KAAK,CAAC;IAC/D,MAAM5N,IAAI,GAAGD,MAAM,CAACC,IAAI,CAAC,IAAI,CAAmB;IAChD,KAAK,IAAI6O,CAAC,GAAG,CAAC,EAAExB,MAAM,GAAGrN,IAAI,CAACqN,MAAM,EAAEwB,CAAC,GAAGxB,MAAM,EAAEwB,CAAC,EAAE,EAAE;MACrD,MAAM/O,GAAG,GAAGE,IAAI,CAAC6O,CAAC,CAAC;MAEnB,IACE/O,GAAG,KAAK,iBAAiB,IACzBA,GAAG,KAAK,kBAAkB,IAC1BA,GAAG,KAAK,eAAe,EACvB;QAEAgkC,OAAO,CAAChkC,GAAG,CAAC,GAAG,IAAI,CAACA,GAAG,CAAC;MAC1B;IACF;IAEA,OAAOgkC,OAAO;GACf;AACH;AAEA,SAASC,gBAAgBA,CAAC9kB,IAAS,EAAO;EACxC,OAAO+kB,eAAe,CAAC/kB,IAAI,CAAC;AAC9B;AAEO,SAAS+kB,eAAeA,CAAC/kB,IAAS,EAAO;EAI9C,MAAM;IAAE3N,IAAI;IAAE1D,KAAK;IAAEC,GAAG;IAAEiQ,GAAG;IAAE4lB,KAAK;IAAE9iB,KAAK;IAAEjf;EAAM,CAAA,GAAGsd,IAAI;EAC1D,MAAMglB,MAAM,GAAGlkC,MAAM,CAACmkC,MAAM,CAACP,aAAa,CAAC;EAC3CM,MAAM,CAAC3yB,IAAI,GAAGA,IAAI;EAClB2yB,MAAM,CAACr2B,KAAK,GAAGA,KAAK;EACpBq2B,MAAM,CAACp2B,GAAG,GAAGA,GAAG;EAChBo2B,MAAM,CAACnmB,GAAG,GAAGA,GAAG;EAChBmmB,MAAM,CAACP,KAAK,GAAGA,KAAK;EACpBO,MAAM,CAACrjB,KAAK,GAAGA,KAAK;EACpBqjB,MAAM,CAACtiC,IAAI,GAAGA,IAAI;EAClB,IAAI2P,IAAI,KAAK,aAAa,EAAE;IAC1B2yB,MAAM,CAACE,YAAY,GAAGllB,IAAI,CAACklB,YAAY;EACzC;EACA,OAAOF,MAAM;AACf;AAEO,SAASG,kBAAkBA,CAACnlB,IAAS,EAAO;EACjD,MAAM;IAAE3N,IAAI;IAAE1D,KAAK;IAAEC,GAAG;IAAEiQ,GAAG;IAAE4lB,KAAK;IAAE9iB;EAAO,CAAA,GAAG3B,IAAI;EACpD,IAAI3N,IAAI,KAAK,aAAa,EAAE;IAC1B,OAAOyyB,gBAAgB,CAAC9kB,IAAI,CAAC;EAC/B;EACA,MAAMglB,MAAM,GAAGlkC,MAAM,CAACmkC,MAAM,CAACP,aAAa,CAAC;EAC3CM,MAAM,CAAC3yB,IAAI,GAAGA,IAAI;EAClB2yB,MAAM,CAACr2B,KAAK,GAAGA,KAAK;EACpBq2B,MAAM,CAACp2B,GAAG,GAAGA,GAAG;EAChBo2B,MAAM,CAACnmB,GAAG,GAAGA,GAAG;EAChBmmB,MAAM,CAACP,KAAK,GAAGA,KAAK;EACpB,IAAIzkB,IAAI,CAAC0B,GAAG,KAAKliB,SAAS,EAAE;IAE1BwlC,MAAM,CAACtjB,GAAG,GAAG1B,IAAI,CAAC0B,GAAG;EACvB,CAAC,MAAM;IACLsjB,MAAM,CAACrjB,KAAK,GAAGA,KAAK;EACtB;EACAqjB,MAAM,CAACt1B,KAAK,GAAGsQ,IAAI,CAACtQ,KAAK;EACzB,OAAOs1B,MAAM;AACf;AAIO,MAAeI,SAAS,SAAS5D,UAAU,CAAC;EACjDnd,SAASA,CAAAA,EAAkC;IAEzC,OAAO,IAAImgB,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC3d,KAAK,CAAClY,KAAK,EAAE,IAAI,CAACkY,KAAK,CAAC3B,QAAQ,CAAC;EAC9D;EAEAmgB,WAAWA,CAAqBxmB,GAAa,EAAa;IAExD,OAAO,IAAI2lB,IAAI,CAAC,IAAI,EAAE3lB,GAAG,CAACrQ,KAAK,EAAEqQ,GAAG,CAAC;EACvC;EAGA8I,eAAeA,CAAqBtV,IAAsB,EAAa;IACrE,OAAO,IAAI,CAACgzB,WAAW,CAAChzB,IAAI,CAACwM,GAAG,CAAClQ,KAAK,CAAC;EACzC;EAIA4V,UAAUA,CAAqBvE,IAAe,EAAE3N,IAAe,EAAK;IAClE,OAAO,IAAI,CAACyV,YAAY,CAAC9H,IAAI,EAAE3N,IAAI,EAAE,IAAI,CAACwU,KAAK,CAACoB,aAAa,CAAC;EAChE;EAIAH,YAAYA,CACV9H,IAAqB,EACrB3N,IAAe,EACf0V,MAAgB,EACb;IAQH/H,IAAI,CAAC3N,IAAI,GAAGA,IAAI;IAEhB2N,IAAI,CAACpR,GAAG,GAAGmZ,MAAM,CAACvZ,KAAK;IACvBwR,IAAI,CAACnB,GAAG,CAACjQ,GAAG,GAAGmZ,MAAM;IACrB,IAAI,IAAI,CAACnnB,OAAO,CAACT,MAAM,EAAE6f,IAAI,CAACykB,KAAK,CAAC,CAAC,CAAC,GAAG1c,MAAM,CAACvZ,KAAK;IACrD,IAAI,IAAI,CAAC5N,OAAO,CAACL,aAAa,EAAE,IAAI,CAACswB,cAAc,CAAC7Q,IAAI,CAAM;IAC9D,OAAOA,IAAI;EACb;EAEAmH,kBAAkBA,CAACnH,IAAc,EAAEkF,QAAkB,EAAQ;IAC3DlF,IAAI,CAACrR,KAAK,GAAGuW,QAAQ,CAAC1W,KAAK;IAC3BwR,IAAI,CAACnB,GAAG,CAAClQ,KAAK,GAAGuW,QAAQ;IACzB,IAAI,IAAI,CAACtkB,OAAO,CAACT,MAAM,EAAE6f,IAAI,CAACykB,KAAK,CAAC,CAAC,CAAC,GAAGvf,QAAQ,CAAC1W,KAAK;EACzD;EAEAwZ,gBAAgBA,CACdhI,IAAc,EACd+H,MAAgB,GAAG,IAAI,CAAClB,KAAK,CAACoB,aAAa,EACrC;IACNjI,IAAI,CAACpR,GAAG,GAAGmZ,MAAM,CAACvZ,KAAK;IACvBwR,IAAI,CAACnB,GAAG,CAACjQ,GAAG,GAAGmZ,MAAM;IACrB,IAAI,IAAI,CAACnnB,OAAO,CAACT,MAAM,EAAE6f,IAAI,CAACykB,KAAK,CAAC,CAAC,CAAC,GAAG1c,MAAM,CAACvZ,KAAK;EACvD;EAKA82B,0BAA0BA,CAACtlB,IAAc,EAAEulB,YAAsB,EAAQ;IACvE,IAAI,CAACpe,kBAAkB,CAACnH,IAAI,EAAEulB,YAAY,CAAC1mB,GAAG,CAAClQ,KAAK,CAAC;EACvD;AACF;AClIA,MAAM62B,aAAa,GAAG,IAAI9nB,GAAG,CAAC,CAC5B,GAAG,EACH,KAAK,EACL,MAAM,EACN,SAAS,EACT,OAAO,EACP,SAAS,EACT,OAAO,EACP,WAAW,EACX,OAAO,EACP,MAAM,EACN,QAAQ,EACR,QAAQ,EACR,QAAQ,EACR,MAAM,EACN,QAAQ,EACR,MAAM,CACP,CAAC;AAIF,MAAM+nB,UAAU,GAAGvmB,cAAe,MAAK,CAAC;EACtCwmB,yBAAyB,EACvB,gFAAgF;EAClFC,0BAA0B,EACxB,wKAAwK;EAG1KC,kBAAkB,EAAEA,CAAC;IAAEC;GAAwC,KAC3BA,kCAAAA,YAAe,GAAA;EACnDC,mBAAmB,EACjB,yDAAyD;EAC3DC,4BAA4B,EAC1B,qEAAqE;EACvEC,6BAA6B,EAC3B,+CAA+C;EACjDC,+BAA+B,EAAEA,CAAC;IAChCC,UAAU;IACVC;EAIF,CAAC,KAC8DD,6DAAAA,6BAA6BA,UAAW,yBAAwBC,QAAa,KAAA;EAC5IC,uBAAuB,EAAEA,CAAC;IACxBF,UAAU;IACVC;EAID,CAAA,KACE,uDAAsDD,UAAW,6CAA4CC,QAAa,KAAA;EAC7HE,4BAA4B,EAAEA,CAAC;IAAEF;GAAgC,KACrDA,UAAAA,QAA+K,uKAAA;EAC3LG,uBAAuB,EAAEA,CAAC;IACxBC,eAAe;IACfJ;EAID,CAAA,KACE,eAAcI,eAAgB,4FAA2FJ,QAAa,KAAA;EACzIK,sCAAsC,EAAEA,CAAC;IACvCL;GAGD,KAC6GA,4GAAAA,QAAa,KAAA;EAa3HM,uCAAuC,EAAEA,CAAC;IACxCN,QAAQ;IACRD,UAAU;IACVQ;GAKD,eACWP,QAAS,iBAAgBO,YAA2CR,+BAAAA,UAA8BQ,oBAAAA,YAAuB,WAAA;EACrIC,sCAAsC,EAAEA,CAAC;IACvCR,QAAQ;IACRD;EAKD,CAAA,KACE,oDAAmDA,UAAW,iBAAgBC,QAAa,KAAA;EAC9FS,uCAAuC,EAAEA,CAAC;IACxCT,QAAQ;IACRD;EAKD,CAAA,KACE,qCAAoCA,UAAW,4EAA2EC,QAAa,KAAA;EAC1IU,qBAAqB,EAAEA,CAAC;IACtBV,QAAQ;IACRD,UAAU;IACVY;EAKF,CAAC,KACsFZ,qFAAAA,kCAAkCY,UAAW,iBAAgBX,QAAa,KAAA;EACjKY,8BAA8B,EAAEA,CAAC;IAC/BZ,QAAQ;IACRD;EAID,CAAA,KACE,sDAAqDA,UAAW,oBAAmBC,QAAa,KAAA;EACnGa,yCAAyC,EAAEA,CAAC;IAC1Cb;GAGD,KAC4GA,2GAAAA,QAAa,KAAA;EAC1Hc,yBAAyB,EAAE,0CAA0C;EACrEC,6BAA6B,EAC3B,wEAAwE;EAC1EC,mCAAmC,EACjC,wKAAwK;EAC1KC,kBAAkB,EAChB,6EAA6E;EAC/EC,sBAAsB,EACpB,0EAA0E;EAC5EC,eAAe,EAAE,+CAA+C;EAChEC,mCAAmC,EACjC,yFAAyF;EAC3FC,uBAAuB,EACrB,yGAAyG;EAC3GC,mBAAmB,EACjB,kEAAkE;EACpEC,iBAAiB,EAAE,yDAAyD;EAC5EC,iBAAiB,EAAA7mC,MAAA,CAAA+E,MAAA,CAAA;IACf6K,OAAO,EACL;GAGE,EAAA;IAAE+O,UAAU,EAAE;EAAyB,CAAC,CAE7C;EACDmoB,yBAAyB,EAAE,0CAA0C;EACrEC,cAAc,EAAE,yCAAyC;EACzDC,2BAA2B,EACzB,yDAAyD;EAC3DC,4BAA4B,EAC1B,mGAAmG;EACrGC,yBAAyB,EAAE,0CAA0C;EACrEC,oBAAoB,EAClB,4DAA4D;EAC9DC,kBAAkB,EAAE,oDAAoD;EACxEC,qBAAqB,EACnB,mHAAmH;EACrHC,iBAAiB,EACf,sEAAsE;EACxEC,iCAAiC,EAC/B,sEAAsE;EACxEC,sBAAsB,EAAEA,CAAC;IAAEzC;GAAwC,KACrCA,4BAAAA,YAAe,GAAA;EAC7C0C,4BAA4B,EAC1B,wDAAwD;EAC1DC,kCAAkC,EAChC,uDAAuD;EACzDC,oBAAoB,EAClB,kEAAkE;EACpEC,4BAA4B,EAC1B,kDAAkD;EACpDC,iCAAiC,EAC/B,mEAAmE;EACrEC,+CAA+C,EAC7C,mHAAmH;EACrHC,4BAA4B,EAAEA,CAAC;IAC7BC,qBAAqB;IACrBhC;EAID,CAAA,KACE,oBAAmBgC,qBAAsB,8BAA6BhC,UAAuB,aAAA;EAChGiC,mCAAmC,EACjC,mEAAmE;EACrEC,uBAAuB,EAAE;AAC3B,CAAC,CAAC;AAGF,SAASC,cAAcA,CAACC,WAAmB,EAAW;EACpD,OACEA,WAAW,CAAC72B,IAAI,KAAK,6BAA6B,IACjD62B,WAAW,CAAC72B,IAAI,KAAK,0BAA0B,KAC7C,CAAC62B,WAAW,CAAChiB,WAAW,IACtBgiB,WAAW,CAAChiB,WAAW,CAAC7U,IAAI,KAAK,WAAW,IAC3C62B,WAAW,CAAChiB,WAAW,CAAC7U,IAAI,KAAK,sBAAuB,CAAE;AAEpE;AAEA,SAAS82B,iBAAiBA,CAACnpB,IAAY,EAAW;EAChD,OAAOA,IAAI,CAACopB,UAAU,KAAK,MAAM,IAAIppB,IAAI,CAACopB,UAAU,KAAK,QAAQ;AACnE;AAEA,SAASC,oBAAoBA,CAACh3B,IAAe,EAAW;EACtD,OAAOtF,0BAA0B,CAACsF,IAAI,CAAC,IAAIA,IAAI,KAAa,EAAA;AAC9D;AAEA,MAAMi3B,iBAAiB,GAAG;EACxBC,KAAK,EAAE,oBAAoB;EAC3BC,GAAG,EAAE,oBAAoB;EACzBn3B,IAAI,EAAE,aAAa;EACnBo3B,SAAS,EAAE;AACb,CAAC;AAGD,SAASC,SAASA,CAChBC,IAAS,EACTjhB,IAA6D,EACjD;EACZ,MAAMkhB,KAAU,GAAG,EAAE;EACrB,MAAMC,KAAU,GAAG,EAAE;EACrB,KAAK,IAAIj6B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG+5B,IAAI,CAACv7B,MAAM,EAAEwB,CAAC,EAAE,EAAE;IACpC,CAAC8Y,IAAI,CAACihB,IAAI,CAAC/5B,CAAC,CAAC,EAAEA,CAAC,EAAE+5B,IAAI,CAAC,GAAGC,KAAK,GAAGC,KAAK,EAAEpmC,IAAI,CAACkmC,IAAI,CAAC/5B,CAAC,CAAC,CAAC;EACxD;EACA,OAAO,CAACg6B,KAAK,EAAEC,KAAK,CAAC;AACvB;AAEA,MAAMC,iBAAiB,GAAG,wBAAwB;AAoClD,IAAAC,IAAA,GAAgB7pB,UAAyB,IACvC,MAAM8pB,eAAe,SAAS9pB,UAAU,CAAmB;EAAAjf,WAAAA,CAAA,GAAAwjB,IAAA,EAAA;IAAA,KAAA,CAAA,GAAAA,IAAA,CAAA;IAAA,IAIzDwlB,CAAAA,UAAU,GAAoCzqC,SAAS;EAAA;EAEvDukC,eAAeA,CAAAA,EAEb;IACA,OAAO3U,gBAAgB;EACzB;EAEA8a,gBAAgBA,CAAAA,EAAY;IAC1B,OAAO,IAAI,CAACxmB,eAAe,CAAC,MAAM,EAAE,KAAK,CAAC,IAAI,IAAI,CAACumB,UAAU,KAAK,MAAM;EAC1E;EAEAE,gBAAgBA,CAAAA,EAAY;IAC1B,OAAO,CAAC,CAAC,IAAI,CAACzmB,eAAe,CAAC,MAAM,EAAE,OAAO,CAAC;EAChD;EAEAoW,WAAWA,CAACznB,IAAe,EAAE8hB,GAAQ,EAAQ;IAC3C,IACE9hB,IAAI,QAAc,IAClBA,IAAI,OAAY,IAChBA,IAAI,OAA4B,EAChC;MACA,IAAI,IAAI,CAAC43B,UAAU,KAAKzqC,SAAS,EAAE;QACjC,IAAI,CAACyqC,UAAU,GAAG,IAAI;MACxB;IACF;IACA,KAAK,CAACnQ,WAAW,CAACznB,IAAI,EAAE8hB,GAAG,CAAC;EAC9B;EAEAxD,UAAUA,CAACC,OAAkB,EAAQ;IACnC,IAAI,IAAI,CAACqZ,UAAU,KAAKzqC,SAAS,EAAE;MAEjC,MAAM4qC,OAAO,GAAGN,iBAAiB,CAACO,IAAI,CAACzZ,OAAO,CAAClhB,KAAK,CAAC;MACrD,IAAI,CAAC06B,OAAO,EAAE,CAEb,KAAM,IAAIA,OAAO,CAAC,CAAC,CAAC,KAAK,MAAM,EAAE;QAChC,IAAI,CAACH,UAAU,GAAG,MAAM;MACzB,CAAA,MAAM,IAAIG,OAAO,CAAC,CAAC,CAAC,KAAK,QAAQ,EAAE;QAClC,IAAI,CAACH,UAAU,GAAG,QAAQ;MAC5B,CAAC,MAAM;QACL,MAAM,IAAItpC,KAAK,CAAC,wBAAwB,CAAC;MAC3C;IACF;IACA,KAAK,CAACgwB,UAAU,CAACC,OAAO,CAAC;EAC3B;EAEA0Z,wBAAwBA,CAACC,GAAe,EAAc;IACpD,MAAMC,SAAS,GAAG,IAAI,CAAC3jB,KAAK,CAACgM,MAAM;IACnC,IAAI,CAAChM,KAAK,CAACgM,MAAM,GAAG,IAAI;IACxB,IAAI,CAAC2P,MAAM,CAAC+H,GAAG,MAAY,CAAC;IAE5B,MAAMl4B,IAAI,GAAG,IAAI,CAACo4B,aAAa,EAAE;IACjC,IAAI,CAAC5jB,KAAK,CAACgM,MAAM,GAAG2X,SAAS;IAC7B,OAAOn4B,IAAI;EACb;EAEAq4B,kBAAkBA,CAAAA,EAAoB;IACpC,MAAM1qB,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAE;IAC7B,MAAMsmB,SAAS,GAAG,IAAI,CAAC9jB,KAAK,CAAC3B,QAAQ;IACrC,IAAI,CAAC0E,IAAI,EAAE;IACX,IAAI,CAACqY,gBAAgB,CAAY,GAAA,CAAA;IAEjC,IAAI,IAAI,CAACpb,KAAK,CAAC4M,YAAY,GAAGkX,SAAS,CAACn8B,KAAK,GAAG,CAAC,EAAE;MACjD,IAAI,CAACuX,KAAK,CAAC0f,UAAU,CAAC+C,kCAAkC,EAAE;QACxD/iC,EAAE,EAAEklC;MACN,CAAC,CAAC;IACJ;IACA,IAAI,IAAI,CAAClS,GAAG,CAAA,EAAA,CAAW,EAAE;MACvBzY,IAAI,CAACtQ,KAAK,GAAG,KAAK,CAACk7B,eAAe,EAAE;MACpC,IAAI,CAACpI,MAAM,CAAW,EAAA,CAAA;MACtB,OAAO,IAAI,CAACje,UAAU,CAACvE,IAAI,EAAE,mBAAmB,CAAC;IACnD,CAAC,MAAM;MACL,OAAO,IAAI,CAACuE,UAAU,CAACvE,IAAI,EAAE,mBAAmB,CAAC;IACnD;EACF;EAEA6qB,oCAAoCA,CAAAA,EAGlC;IACA,MAAML,SAAS,GAAG,IAAI,CAAC3jB,KAAK,CAACgM,MAAM;IACnC,IAAI,CAAChM,KAAK,CAACgM,MAAM,GAAG,IAAI;IACxB,IAAI,CAAC2P,MAAM,CAAU,EAAA,CAAA;IACrB,IAAInwB,IAAI,GAAG,IAAI;IACf,IAAIy4B,SAAS,GAAG,IAAI;IACpB,IAAI,IAAI,CAAC5U,KAAK,CAAA,EAAA,CAAW,EAAE;MACzB,IAAI,CAACrP,KAAK,CAACgM,MAAM,GAAG2X,SAAS;MAC7BM,SAAS,GAAG,IAAI,CAACJ,kBAAkB,EAAE;IACvC,CAAC,MAAM;MACLr4B,IAAI,GAAG,IAAI,CAACo4B,aAAa,EAAE;MAC3B,IAAI,CAAC5jB,KAAK,CAACgM,MAAM,GAAG2X,SAAS;MAC7B,IAAI,IAAI,CAACtU,KAAK,CAAA,EAAA,CAAW,EAAE;QACzB4U,SAAS,GAAG,IAAI,CAACJ,kBAAkB,EAAE;MACvC;IACF;IACA,OAAO,CAACr4B,IAAI,EAAEy4B,SAAS,CAAC;EAC1B;EAEAC,qBAAqBA,CACnB/qB,IAAgC,EACZ;IACpB,IAAI,CAAC4J,IAAI,EAAE;IACX,IAAI,CAACohB,qBAAqB,CAAChrB,IAAI,EAAc,IAAI,CAAC;IAClD,OAAO,IAAI,CAACuE,UAAU,CAACvE,IAAI,EAAE,cAAc,CAAC;EAC9C;EAEAirB,wBAAwBA,CACtBjrB,IAAmC,EACZ;IACvB,IAAI,CAAC4J,IAAI,EAAE;IAEX,MAAM/F,EAAE,GAAI7D,IAAI,CAAC6D,EAAE,GAAG,IAAI,CAACqnB,eAAe,EAAG;IAE7C,MAAMC,QAAQ,GAAG,IAAI,CAAC9mB,SAAS,EAAE;IACjC,MAAM+mB,aAAa,GAAG,IAAI,CAAC/mB,SAAS,EAAoB;IAExD,IAAI,IAAI,CAAC6R,KAAK,CAAA,EAAA,CAAO,EAAE;MACrBiV,QAAQ,CAAC3nB,cAAc,GAAG,IAAI,CAAC6nB,iCAAiC,EAAE;IACpE,CAAC,MAAM;MACLF,QAAQ,CAAC3nB,cAAc,GAAG,IAAI;IAChC;IAEA,IAAI,CAACgf,MAAM,CAAW,EAAA,CAAA;IACtB,MAAM8I,GAAG,GAAG,IAAI,CAACC,2BAA2B,EAAE;IAC9CJ,QAAQ,CAAC9oB,MAAM,GAAGipB,GAAG,CAACjpB,MAAM;IAC5B8oB,QAAQ,CAACxrB,IAAI,GAAG2rB,GAAG,CAAC3rB,IAAI;IACxBwrB,QAAQ,CAACK,IAAI,GAAGF,GAAG,CAACziC,KAAK;IACzB,IAAI,CAAC25B,MAAM,CAAW,EAAA,CAAA;IAEtB,CAAC2I,QAAQ,CAACM,UAAU,EAAEzrB,IAAI,CAAC8qB,SAAS,CAAC,GACnC,IAAI,CAACD,oCAAoC,EAAE;IAE7CO,aAAa,CAACM,cAAc,GAAG,IAAI,CAACnnB,UAAU,CAC5C4mB,QAAQ,EACR,wBAAwB,CACzB;IAEDtnB,EAAE,CAAC6nB,cAAc,GAAG,IAAI,CAACnnB,UAAU,CAAC6mB,aAAa,EAAE,gBAAgB,CAAC;IAEpE,IAAI,CAACpjB,gBAAgB,CAACnE,EAAE,CAAC;IACzB,IAAI,CAACye,SAAS,EAAE;IAEhB,IAAI,CAAC/T,KAAK,CAACC,WAAW,CACpBxO,IAAI,CAAC6D,EAAE,CAACnhB,IAAI,EACZ4pB,oBAAoB,EACpBtM,IAAI,CAAC6D,EAAE,CAAChF,GAAG,CAAClQ,KAAK,CAClB;IAED,OAAO,IAAI,CAAC4V,UAAU,CAACvE,IAAI,EAAE,iBAAiB,CAAC;EACjD;EAEA2rB,gBAAgBA,CACd3rB,IAA2B,EAC3B4rB,YAAsB,EACP;IACf,IAAI,IAAI,CAAC1V,KAAK,CAAA,EAAA,CAAW,EAAE;MACzB,OAAO,IAAI,CAAC6U,qBAAqB,CAAC/qB,IAAI,CAAC;IACxC,CAAA,MAAM,IAAI,IAAI,CAACkW,KAAK,IAAc,EAAE;MACnC,OAAO,IAAI,CAAC+U,wBAAwB,CAACjrB,IAAI,CAAC;IAC3C,CAAA,MAAM,IAAI,IAAI,CAACkW,KAAK,IAAS,EAAE;MAC9B,OAAO,IAAI,CAAC2V,wBAAwB,CAAC7rB,IAAI,CAAC;IAC3C,CAAA,MAAM,IAAI,IAAI,CAACgiB,aAAa,KAAY,EAAE;MACzC,IAAI,IAAI,CAAC9L,KAAK,CAAA,EAAA,CAAQ,EAAE;QACtB,OAAO,IAAI,CAAC4V,6BAA6B,CAAC9rB,IAAI,CAAC;MACjD,CAAC,MAAM;QACL,IAAI4rB,YAAY,EAAE;UAChB,IAAI,CAAC7lB,KAAK,CAAC0f,UAAU,CAACgC,mBAAmB,EAAE;YACzChiC,EAAE,EAAE,IAAI,CAACohB,KAAK,CAACC;UACjB,CAAC,CAAC;QACJ;QACA,OAAO,IAAI,CAACilB,sBAAsB,CAAC/rB,IAAI,CAAC;MAC1C;IACD,CAAA,MAAM,IAAI,IAAI,CAAC0hB,YAAY,KAAU,EAAE;MACtC,OAAO,IAAI,CAACsK,yBAAyB,CAAChsB,IAAI,CAAC;IAC5C,CAAA,MAAM,IAAI,IAAI,CAAC0hB,YAAY,KAAY,EAAE;MACxC,OAAO,IAAI,CAACuK,0BAA0B,CAACjsB,IAAI,CAAC;IAC7C,CAAA,MAAM,IAAI,IAAI,CAAC0hB,YAAY,KAAe,EAAE;MAC3C,OAAO,IAAI,CAACwK,yBAAyB,CAAClsB,IAAI,CAAC;IAC5C,CAAA,MAAM,IAAI,IAAI,CAACkW,KAAK,IAAY,EAAE;MACjC,OAAO,IAAI,CAACiW,iCAAiC,CAACnsB,IAAI,EAAE4rB,YAAY,CAAC;IACnE,CAAC,MAAM;MACL,IAAI,CAACz0B,UAAU,EAAE;IACnB;EACF;EAEA00B,wBAAwBA,CACtB7rB,IAAmC,EACZ;IACvB,IAAI,CAAC4J,IAAI,EAAE;IACX5J,IAAI,CAAC6D,EAAE,GAAG,IAAI,CAACuoB,kCAAkC,CACpB,IAAI,CAChC;IACD,IAAI,CAAC7d,KAAK,CAACC,WAAW,CAACxO,IAAI,CAAC6D,EAAE,CAACnhB,IAAI,EAAEipB,QAAQ,EAAE3L,IAAI,CAAC6D,EAAE,CAAChF,GAAG,CAAClQ,KAAK,CAAC;IACjE,IAAI,CAAC2zB,SAAS,EAAE;IAChB,OAAO,IAAI,CAAC/d,UAAU,CAACvE,IAAI,EAAE,iBAAiB,CAAC;EACjD;EAEA+rB,sBAAsBA,CACpB/rB,IAAiC,EACZ;IACrB,IAAI,CAACuO,KAAK,CAACF,KAAK,CAACrE,WAAW,CAAC;IAE7B,IAAI,IAAI,CAACkM,KAAK,CAAA,GAAA,CAAW,EAAE;MACzBlW,IAAI,CAAC6D,EAAE,GAAG,KAAK,CAACwoB,aAAa,EAAE;IACjC,CAAC,MAAM;MACLrsB,IAAI,CAAC6D,EAAE,GAAG,IAAI,CAACqnB,eAAe,EAAE;IAClC;IAEA,MAAMoB,QAAQ,GAAItsB,IAAI,CAACgD,IAAI,GAAG,IAAI,CAACqB,SAAS,EAAG;IAE/C,MAAMrB,IAAI,GAAIspB,QAAQ,CAACtpB,IAAI,GAAG,EAAG;IACjC,IAAI,CAACwf,MAAM,CAAW,CAAA,CAAA;IACtB,OAAO,CAAC,IAAI,CAACtM,KAAK,GAAW,EAAE;MAC7B,IAAIoW,QAAQ,GAAG,IAAI,CAACjoB,SAAS,EAAuB;MAEpD,IAAI,IAAI,CAAC6R,KAAK,CAAA,EAAA,CAAY,EAAE;QAC1B,IAAI,CAACtM,IAAI,EAAE;QACX,IAAI,CAAC,IAAI,CAAC8X,YAAY,CAAA,GAAA,CAAU,IAAI,CAAC,IAAI,CAACxL,KAAK,CAAA,EAAA,CAAY,EAAE;UAC3D,IAAI,CAACnQ,KAAK,CAAC0f,UAAU,CAAC8B,mCAAmC,EAAE;YACzD9hC,EAAE,EAAE,IAAI,CAACohB,KAAK,CAACC;UACjB,CAAC,CAAC;QACJ;QACA,KAAK,CAACylB,WAAW,CAACD,QAAQ,CAAC;MAC7B,CAAC,MAAM;QACL,IAAI,CAACrK,gBAAgB,CAAA,GAAA,EAEnBwD,UAAU,CAACsD,mCAAmC,CAC/C;QAEDuD,QAAQ,GAAG,IAAI,CAACX,gBAAgB,CAACW,QAAQ,EAAE,IAAI,CAAC;MAClD;MAEAtpB,IAAI,CAACvf,IAAI,CAAC6oC,QAAQ,CAAC;IACrB;IAEA,IAAI,CAAC/d,KAAK,CAACD,IAAI,EAAE;IAEjB,IAAI,CAACkU,MAAM,CAAW,CAAA,CAAA;IAEtB,IAAI,CAACje,UAAU,CAAC+nB,QAAQ,EAAE,gBAAgB,CAAC;IAE3C,IAAI75B,IAA8B,GAAG,IAAI;IACzC,IAAI+5B,eAAe,GAAG,KAAK;IAC3BxpB,IAAI,CAAC0W,OAAO,CAACwP,WAAW,IAAI;MAC1B,IAAID,cAAc,CAACC,WAAW,CAAC,EAAE;QAC/B,IAAIz2B,IAAI,KAAK,UAAU,EAAE;UACvB,IAAI,CAACsT,KAAK,CAAC0f,UAAU,CAACE,0BAA0B,EAAE;YAChDlgC,EAAE,EAAEyjC;UACN,CAAC,CAAC;QACJ;QACAz2B,IAAI,GAAG,IAAI;MACb,CAAC,MAAM,IAAIy2B,WAAW,CAAC72B,IAAI,KAAK,sBAAsB,EAAE;QACtD,IAAIm6B,eAAe,EAAE;UACnB,IAAI,CAACzmB,KAAK,CAAC0f,UAAU,CAACO,6BAA6B,EAAE;YACnDvgC,EAAE,EAAEyjC;UACN,CAAC,CAAC;QACJ;QACA,IAAIz2B,IAAI,KAAK,IAAI,EAAE;UACjB,IAAI,CAACsT,KAAK,CAAC0f,UAAU,CAACE,0BAA0B,EAAE;YAChDlgC,EAAE,EAAEyjC;UACN,CAAC,CAAC;QACJ;QACAz2B,IAAI,GAAG,UAAU;QACjB+5B,eAAe,GAAG,IAAI;MACxB;IACF,CAAC,CAAC;IAEFxsB,IAAI,CAACvN,IAAI,GAAGA,IAAI,IAAI,UAAU;IAC9B,OAAO,IAAI,CAAC8R,UAAU,CAACvE,IAAI,EAAE,eAAe,CAAC;EAC/C;EAEAmsB,iCAAiCA,CAC/BnsB,IAA4C,EAC5C4rB,YAA6B,EACG;IAChC,IAAI,CAACpJ,MAAM,CAAY,EAAA,CAAA;IAEvB,IAAI,IAAI,CAAC/J,GAAG,CAAA,EAAA,CAAa,EAAE;MACzB,IAAI,IAAI,CAACvC,KAAK,CAAA,EAAA,CAAc,IAAI,IAAI,CAACA,KAAK,CAAA,EAAA,CAAW,EAAE;QAGrDlW,IAAI,CAACkH,WAAW,GAAG,IAAI,CAACykB,gBAAgB,CAAC,IAAI,CAACtnB,SAAS,EAAE,CAAC;MAC5D,CAAC,MAAM;QAELrE,IAAI,CAACkH,WAAW,GAAG,IAAI,CAACujB,aAAa,EAAE;QACvC,IAAI,CAACnI,SAAS,EAAE;MAClB;MACAtiB,IAAI,CAACysB,OAAO,GAAG,IAAI;MAEnB,OAAO,IAAI,CAACloB,UAAU,CAACvE,IAAI,EAAE,0BAA0B,CAAC;IAC1D,CAAC,MAAM;MACL,IACE,IAAI,CAACkW,KAAK,CAAA,EAAA,CAAW,IACrB,IAAI,CAACwW,KAAK,EAAE,IACX,CAAC,IAAI,CAAChL,YAAY,CAAU,GAAA,CAAA,IAAI,IAAI,CAACA,YAAY,CAAe,GAAA,CAAA,KAC/D,CAACkK,YAAa,EAChB;QACA,MAAM3pC,KAAK,GAAG,IAAI,CAAC4kB,KAAK,CAACnX,KAIV;QACf,MAAM,IAAI,CAACqW,KAAK,CAAC0f,UAAU,CAACoD,4BAA4B,EAAE;UACxDpjC,EAAE,EAAE,IAAI,CAACohB,KAAK,CAAC3B,QAAQ;UACvB4jB,qBAAqB,EAAE7mC,KAAK;UAC5B6kC,UAAU,EAAEwC,iBAAiB,CAACrnC,KAAK;QACrC,CAAC,CAAC;MACJ;MAEA,IACE,IAAI,CAACi0B,KAAK,IAAS,IACnB,IAAI,CAACA,KAAK,CAAA,EAAA,CAAc,IACxB,IAAI,CAACA,KAAK,CAAW,EAAA,CAAA,IACrB,IAAI,CAACwL,YAAY,KAAY,EAC7B;QACA1hB,IAAI,CAACkH,WAAW,GAAG,IAAI,CAACykB,gBAAgB,CAAC,IAAI,CAACtnB,SAAS,EAAE,CAAC;QAC1DrE,IAAI,CAACysB,OAAO,GAAG,KAAK;QAEpB,OAAO,IAAI,CAACloB,UAAU,CAACvE,IAAI,EAAE,0BAA0B,CAAC;OACzD,MAAM,IACL,IAAI,CAACkW,KAAK,CAAS,EAAA,CAAA,IACnB,IAAI,CAACA,KAAK,CAAA,CAAA,CAAW,IACrB,IAAI,CAACwL,YAAY,CAAA,GAAA,CAAe,IAChC,IAAI,CAACA,YAAY,CAAU,GAAA,CAAA,IAC3B,IAAI,CAACA,YAAY,CAAA,GAAA,CAAY,EAC7B;QACA1hB,IAAI,GAAG,IAAI,CAAC0G,WAAW,CACrB1G,IAAI,EACa,IAAI,CACtB;QACD,IAAIA,IAAI,CAAC3N,IAAI,KAAK,wBAAwB,EAAE;UAC1C2N,IAAI,CAAC3N,IAAI,GAAG,mBAAmB;UAC/B2N,IAAI,CAACysB,OAAO,GAAG,KAAK;UACpB,OAAOzsB,IAAI,CAAC2sB,UAAU;QACxB;QAEA3sB,IAAI,CAAC3N,IAAI,GAAG,SAAS,GAAG2N,IAAI,CAAC3N,IAAI;QAEjC,OAAO2N,IAAI;MACb;IACF;IAEA,IAAI,CAAC7I,UAAU,EAAE;EACnB;EAEA20B,6BAA6BA,CAC3B9rB,IAAwC,EACZ;IAC5B,IAAI,CAAC4J,IAAI,EAAE;IACX,IAAI,CAACqY,gBAAgB,CAAa,GAAA,CAAA;IAClCjiB,IAAI,CAAC0rB,cAAc,GAAG,IAAI,CAACkB,uBAAuB,EAAE;IACpD,IAAI,CAACtK,SAAS,EAAE;IAEhB,OAAO,IAAI,CAAC/d,UAAU,CAACvE,IAAI,EAAE,sBAAsB,CAAC;EACtD;EAEAgsB,yBAAyBA,CACvBhsB,IAAoC,EACZ;IACxB,IAAI,CAAC4J,IAAI,EAAE;IACX,MAAMijB,QAAQ,GAAG,IAAI,CAACC,kBAAkB,CAAC9sB,IAAI,CAAC;IAE9C6sB,QAAQ,CAACx6B,IAAI,GAAG,kBAAkB;IAClC,OAAOw6B,QAAQ;EACjB;EAEAZ,0BAA0BA,CACxBjsB,IAAqC,EACZ;IACzB,IAAI,CAAC4J,IAAI,EAAE;IACX,MAAMijB,QAAQ,GAAG,IAAI,CAACE,mBAAmB,CAAC/sB,IAAI,EAAE,IAAI,CAAC;IAErD6sB,QAAQ,CAACx6B,IAAI,GAAG,mBAAmB;IACnC,OAAOw6B,QAAQ;EACjB;EAEAX,yBAAyBA,CACvBlsB,IAAoC,EACZ;IACxB,IAAI,CAAC4J,IAAI,EAAE;IACX,IAAI,CAACohB,qBAAqB,CAAChrB,IAAI,EAAgB,KAAK,CAAC;IACrD,OAAO,IAAI,CAACuE,UAAU,CAACvE,IAAI,EAAE,kBAAkB,CAAC;EAClD;EAIAgrB,qBAAqBA,CAAChrB,IAA2B,EAAEgtB,OAAgB,EAAQ;IACzEhtB,IAAI,CAAC6D,EAAE,GAAG,IAAI,CAACopB,6BAA6B,CAC5B,CAACD,OAAO,EACJ,IAAI,CACvB;IAED,IAAI,CAACze,KAAK,CAACC,WAAW,CACpBxO,IAAI,CAAC6D,EAAE,CAACnhB,IAAI,EACZsqC,OAAO,GAAGphB,aAAa,GAAGH,YAAY,EACtCzL,IAAI,CAAC6D,EAAE,CAAChF,GAAG,CAAClQ,KAAK,CAClB;IAED,IAAI,IAAI,CAACunB,KAAK,CAAA,EAAA,CAAO,EAAE;MACrBlW,IAAI,CAACwD,cAAc,GAAG,IAAI,CAAC6nB,iCAAiC,EAAE;IAChE,CAAC,MAAM;MACLrrB,IAAI,CAACwD,cAAc,GAAG,IAAI;IAC5B;IAEAxD,IAAI,CAACktB,OAAO,GAAG,EAAE;IACjBltB,IAAI,CAACmtB,UAAU,GAAG,EAAE;IACpBntB,IAAI,CAACotB,MAAM,GAAG,EAAE;IAEhB,IAAI,IAAI,CAAC3U,GAAG,CAAA,EAAA,CAAa,EAAE;MACzB,GAAG;QACDzY,IAAI,CAACktB,OAAO,CAACzpC,IAAI,CAAC,IAAI,CAAC4pC,yBAAyB,EAAE,CAAC;MACpD,CAAA,QAAQ,CAACL,OAAO,IAAI,IAAI,CAACvU,GAAG,CAAU,EAAA,CAAA;IACzC;IAEA,IAAIuU,OAAO,EAAE;MACX,IAAI,IAAI,CAAChL,aAAa,CAAA,GAAA,CAAY,EAAE;QAClC,GAAG;UACDhiB,IAAI,CAACotB,MAAM,CAAC3pC,IAAI,CAAC,IAAI,CAAC4pC,yBAAyB,EAAE,CAAC;QACpD,CAAC,QAAQ,IAAI,CAAC5U,GAAG,CAAU,EAAA,CAAA;MAC7B;MAEA,IAAI,IAAI,CAACuJ,aAAa,CAAA,GAAA,CAAgB,EAAE;QACtC,GAAG;UACDhiB,IAAI,CAACmtB,UAAU,CAAC1pC,IAAI,CAAC,IAAI,CAAC4pC,yBAAyB,EAAE,CAAC;QACxD,CAAC,QAAQ,IAAI,CAAC5U,GAAG,CAAU,EAAA,CAAA;MAC7B;IACF;IAEAzY,IAAI,CAACgD,IAAI,GAAG,IAAI,CAACsqB,mBAAmB,CAAC;MACnCC,WAAW,EAAEP,OAAO;MACpBQ,UAAU,EAAE,KAAK;MACjBC,WAAW,EAAE,KAAK;MAClBC,UAAU,EAAEV,OAAO;MACnBW,YAAY,EAAE;IAChB,CAAC,CAAC;EACJ;EAEAN,yBAAyBA,CAAAA,EAA2B;IAClD,MAAMrtB,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAE;IAE7BrE,IAAI,CAAC6D,EAAE,GAAG,IAAI,CAAC+pB,gCAAgC,EAAE;IACjD,IAAI,IAAI,CAAC1X,KAAK,CAAA,EAAA,CAAO,EAAE;MACrBlW,IAAI,CAACwD,cAAc,GAAG,IAAI,CAACqqB,mCAAmC,EAAE;IAClE,CAAC,MAAM;MACL7tB,IAAI,CAACwD,cAAc,GAAG,IAAI;IAC5B;IAEA,OAAO,IAAI,CAACe,UAAU,CAACvE,IAAI,EAAE,kBAAkB,CAAC;EAClD;EAEA8tB,kBAAkBA,CAAC9tB,IAA6B,EAAmB;IACjE,IAAI,CAACgrB,qBAAqB,CAAChrB,IAAI,EAAgB,KAAK,CAAC;IACrD,OAAO,IAAI,CAACuE,UAAU,CAACvE,IAAI,EAAE,sBAAsB,CAAC;EACtD;EAEA+tB,kBAAkBA,CAAC5kB,IAAY,EAAE;IAC/B,IAAIA,IAAI,KAAK,GAAG,EAAE;MAChB,IAAI,CAACpD,KAAK,CAAC0f,UAAU,CAAC8C,4BAA4B,EAAE;QAClD9iC,EAAE,EAAE,IAAI,CAACohB,KAAK,CAAC3B;MACjB,CAAC,CAAC;IACJ;EACF;EAEA8oB,iBAAiBA,CAAC7kB,IAAY,EAAEjE,QAAkB,EAAEgC,WAAqB,EAAE;IACzE,IAAI,CAACse,aAAa,CAAClc,GAAG,CAACH,IAAI,CAAC,EAAE;IAE9B,IAAI,CAACpD,KAAK,CACRmB,WAAW,GACPue,UAAU,CAACG,kBAAkB,GAC7BH,UAAU,CAAC6C,sBAAsB,EACrC;MACE7iC,EAAE,EAAEyf,QAAQ;MACZ2gB,YAAY,EAAE1c;IAChB,CAAC,CACF;EACH;EAEA8jB,6BAA6BA,CAC3BgB,OAAiB,EACjB/mB,WAAqB,EACP;IACd,IAAI,CAAC8mB,iBAAiB,CACpB,IAAI,CAACnnB,KAAK,CAACnX,KAAK,EAChB,IAAI,CAACmX,KAAK,CAAC3B,QAAQ,EACnBgC,WAAW,CACZ;IACD,OAAO,IAAI,CAACgkB,eAAe,CAAC+C,OAAO,CAAC;EACtC;EAIAnB,kBAAkBA,CAAC9sB,IAA6B,EAAmB;IACjEA,IAAI,CAAC6D,EAAE,GAAG,IAAI,CAACopB,6BAA6B,CAC5B,KAAK,EACD,IAAI,CACvB;IACD,IAAI,CAAC1e,KAAK,CAACC,WAAW,CAACxO,IAAI,CAAC6D,EAAE,CAACnhB,IAAI,EAAE+oB,YAAY,EAAEzL,IAAI,CAAC6D,EAAE,CAAChF,GAAG,CAAClQ,KAAK,CAAC;IAErE,IAAI,IAAI,CAACunB,KAAK,CAAA,EAAA,CAAO,EAAE;MACrBlW,IAAI,CAACwD,cAAc,GAAG,IAAI,CAAC6nB,iCAAiC,EAAE;IAChE,CAAC,MAAM;MACLrrB,IAAI,CAACwD,cAAc,GAAG,IAAI;IAC5B;IAEAxD,IAAI,CAACkuB,KAAK,GAAG,IAAI,CAAC5D,wBAAwB,CAAO,EAAA,CAAA;IACjD,IAAI,CAAChI,SAAS,EAAE;IAEhB,OAAO,IAAI,CAAC/d,UAAU,CAACvE,IAAI,EAAE,WAAW,CAAC;EAC3C;EAEA+sB,mBAAmBA,CACjB/sB,IAA8B,EAC9BmuB,OAAgB,EACE;IAClB,IAAI,CAAClM,gBAAgB,CAAU,GAAA,CAAA;IAC/BjiB,IAAI,CAAC6D,EAAE,GAAG,IAAI,CAACopB,6BAA6B,CAC5B,IAAI,EACA,IAAI,CACvB;IACD,IAAI,CAAC1e,KAAK,CAACC,WAAW,CAACxO,IAAI,CAAC6D,EAAE,CAACnhB,IAAI,EAAE+oB,YAAY,EAAEzL,IAAI,CAAC6D,EAAE,CAAChF,GAAG,CAAClQ,KAAK,CAAC;IAErE,IAAI,IAAI,CAACunB,KAAK,CAAA,EAAA,CAAO,EAAE;MACrBlW,IAAI,CAACwD,cAAc,GAAG,IAAI,CAAC6nB,iCAAiC,EAAE;IAChE,CAAC,MAAM;MACLrrB,IAAI,CAACwD,cAAc,GAAG,IAAI;IAC5B;IAGAxD,IAAI,CAACouB,SAAS,GAAG,IAAI;IACrB,IAAI,IAAI,CAAClY,KAAK,CAAA,EAAA,CAAU,EAAE;MACxBlW,IAAI,CAACouB,SAAS,GAAG,IAAI,CAAC9D,wBAAwB,CAAU,EAAA,CAAA;IAC1D;IAEAtqB,IAAI,CAACquB,QAAQ,GAAG,IAAI;IACpB,IAAI,CAACF,OAAO,EAAE;MACZnuB,IAAI,CAACquB,QAAQ,GAAG,IAAI,CAAC/D,wBAAwB,CAAO,EAAA,CAAA;IACtD;IACA,IAAI,CAAChI,SAAS,EAAE;IAEhB,OAAO,IAAI,CAAC/d,UAAU,CAACvE,IAAI,EAAE,YAAY,CAAC;EAC5C;EAIAsuB,sBAAsBA,CAACC,cAAuB,GAAG,KAAK,EAAmB;IACvE,MAAMC,YAAY,GAAG,IAAI,CAAC3nB,KAAK,CAAC3B,QAAQ;IAExC,MAAMlF,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAmB;IAE9C,MAAMoqB,QAAQ,GAAG,IAAI,CAACC,iBAAiB,EAAE;IAEzC,MAAMC,KAAK,GAAG,IAAI,CAACvC,kCAAkC,EAAE;IACvDpsB,IAAI,CAACtd,IAAI,GAAGisC,KAAK,CAACjsC,IAAI;IAEtBsd,IAAI,CAACyuB,QAAQ,GAAGA,QAAQ;IAExBzuB,IAAI,CAAC4uB,KAAK,GAAGD,KAAK,CAACjD,cAAc;IAEjC,IAAI,IAAI,CAACxV,KAAK,CAAA,EAAA,CAAO,EAAE;MACrB,IAAI,CAACuC,GAAG,CAAO,EAAA,CAAA;MAEfzY,IAAI,CAACysB,OAAO,GAAG,IAAI,CAAChC,aAAa,EAAE;IACrC,CAAC,MAAM;MACL,IAAI8D,cAAc,EAAE;QAClB,IAAI,CAACxoB,KAAK,CAAC0f,UAAU,CAAC+B,uBAAuB,EAAE;UAAE/hC,EAAE,EAAE+oC;QAAa,CAAC,CAAC;MACtE;IACF;IAEA,OAAO,IAAI,CAACjqB,UAAU,CAACvE,IAAI,EAAE,eAAe,CAAC;EAC/C;EAEAqrB,iCAAiCA,CAAAA,EAA+B;IAC9D,MAAMb,SAAS,GAAG,IAAI,CAAC3jB,KAAK,CAACgM,MAAM;IACnC,MAAM7S,IAAI,GAAG,IAAI,CAACqE,SAAS,EAA8B;IACzDrE,IAAI,CAACqC,MAAM,GAAG,EAAE;IAEhB,IAAI,CAACwE,KAAK,CAACgM,MAAM,GAAG,IAAI;IAGxB,IAAI,IAAI,CAACqD,KAAK,CAAA,EAAA,CAAO,IAAI,IAAI,CAACA,KAAK,CAAA,GAAA,CAAgB,EAAE;MACnD,IAAI,CAACtM,IAAI,EAAE;IACb,CAAC,MAAM;MACL,IAAI,CAACzS,UAAU,EAAE;IACnB;IAEA,IAAI03B,eAAe,GAAG,KAAK;IAE3B,GAAG;MACD,MAAMC,aAAa,GAAG,IAAI,CAACR,sBAAsB,CAACO,eAAe,CAAC;MAElE7uB,IAAI,CAACqC,MAAM,CAAC5e,IAAI,CAACqrC,aAAa,CAAC;MAE/B,IAAIA,aAAa,CAACrC,OAAO,EAAE;QACzBoC,eAAe,GAAG,IAAI;MACxB;MAEA,IAAI,CAAC,IAAI,CAAC3Y,KAAK,IAAO,EAAE;QACtB,IAAI,CAACsM,MAAM,CAAU,EAAA,CAAA;MACvB;IACD,CAAA,QAAQ,CAAC,IAAI,CAACtM,KAAK,CAAO,EAAA,CAAA;IAC3B,IAAI,CAACsM,MAAM,CAAO,EAAA,CAAA;IAElB,IAAI,CAAC3b,KAAK,CAACgM,MAAM,GAAG2X,SAAS;IAE7B,OAAO,IAAI,CAACjmB,UAAU,CAACvE,IAAI,EAAE,0BAA0B,CAAC;EAC1D;EAEA6tB,mCAAmCA,CAAAA,EAAiC;IAClE,MAAM7tB,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAgC;IAC3D,MAAMmmB,SAAS,GAAG,IAAI,CAAC3jB,KAAK,CAACgM,MAAM;IACnC7S,IAAI,CAACqC,MAAM,GAAG,EAAE;IAEhB,IAAI,CAACwE,KAAK,CAACgM,MAAM,GAAG,IAAI;IAExB,IAAI,CAAC2P,MAAM,CAAO,EAAA,CAAA;IAClB,MAAMuM,qBAAqB,GAAG,IAAI,CAACloB,KAAK,CAACiM,kBAAkB;IAC3D,IAAI,CAACjM,KAAK,CAACiM,kBAAkB,GAAG,KAAK;IACrC,OAAO,CAAC,IAAI,CAACoD,KAAK,IAAO,EAAE;MACzBlW,IAAI,CAACqC,MAAM,CAAC5e,IAAI,CAAC,IAAI,CAACgnC,aAAa,EAAE,CAAC;MACtC,IAAI,CAAC,IAAI,CAACvU,KAAK,IAAO,EAAE;QACtB,IAAI,CAACsM,MAAM,CAAU,EAAA,CAAA;MACvB;IACF;IACA,IAAI,CAAC3b,KAAK,CAACiM,kBAAkB,GAAGic,qBAAqB;IACrD,IAAI,CAACvM,MAAM,CAAO,EAAA,CAAA;IAElB,IAAI,CAAC3b,KAAK,CAACgM,MAAM,GAAG2X,SAAS;IAE7B,OAAO,IAAI,CAACjmB,UAAU,CAACvE,IAAI,EAAE,4BAA4B,CAAC;EAC5D;EAEAgvB,4CAA4CA,CAAAA,EAAiC;IAC3E,MAAMhvB,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAgC;IAC3D,MAAMmmB,SAAS,GAAG,IAAI,CAAC3jB,KAAK,CAACgM,MAAM;IACnC7S,IAAI,CAACqC,MAAM,GAAG,EAAE;IAEhB,IAAI,CAACwE,KAAK,CAACgM,MAAM,GAAG,IAAI;IAExB,IAAI,CAAC2P,MAAM,CAAO,EAAA,CAAA;IAClB,OAAO,CAAC,IAAI,CAACtM,KAAK,IAAO,EAAE;MACzBlW,IAAI,CAACqC,MAAM,CAAC5e,IAAI,CAAC,IAAI,CAACwrC,oCAAoC,EAAE,CAAC;MAC7D,IAAI,CAAC,IAAI,CAAC/Y,KAAK,IAAO,EAAE;QACtB,IAAI,CAACsM,MAAM,CAAU,EAAA,CAAA;MACvB;IACF;IACA,IAAI,CAACA,MAAM,CAAO,EAAA,CAAA;IAElB,IAAI,CAAC3b,KAAK,CAACgM,MAAM,GAAG2X,SAAS;IAE7B,OAAO,IAAI,CAACjmB,UAAU,CAACvE,IAAI,EAAE,4BAA4B,CAAC;EAC5D;EAEAkvB,sBAAsBA,CAAAA,EAAwB;IAC5C,MAAMlvB,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAuB;IAClD,IAAI,CAAC4d,gBAAgB,CAAe,GAAA,CAAA;IAEpCjiB,IAAI,CAACktB,OAAO,GAAG,EAAE;IACjB,IAAI,IAAI,CAACzU,GAAG,CAAA,EAAA,CAAa,EAAE;MACzB,GAAG;QACDzY,IAAI,CAACktB,OAAO,CAACzpC,IAAI,CAAC,IAAI,CAAC4pC,yBAAyB,EAAE,CAAC;MACrD,CAAC,QAAQ,IAAI,CAAC5U,GAAG,CAAU,EAAA,CAAA;IAC7B;IAEAzY,IAAI,CAACgD,IAAI,GAAG,IAAI,CAACsqB,mBAAmB,CAAC;MACnCC,WAAW,EAAE,KAAK;MAClBC,UAAU,EAAE,KAAK;MACjBC,WAAW,EAAE,KAAK;MAClBC,UAAU,EAAE,KAAK;MACjBC,YAAY,EAAE;IAChB,CAAC,CAAC;IAEF,OAAO,IAAI,CAACppB,UAAU,CAACvE,IAAI,EAAE,yBAAyB,CAAC;EACzD;EAEAmvB,0BAA0BA,CAAAA,EAAiB;IACzC,OAAO,IAAI,CAACjZ,KAAK,CAAA,GAAA,CAAQ,IAAI,IAAI,CAACA,KAAK,CAAW,GAAA,CAAA,GAC9C,KAAK,CAACmW,aAAa,EAAE,GACrB,IAAI,CAACnB,eAAe,CAAC,IAAI,CAAC;EAChC;EAEAkE,0BAA0BA,CACxBpvB,IAAqC,EACrCqvB,QAAiB,EACjBZ,QAAgC,EACP;IACzBzuB,IAAI,CAACsvB,MAAM,GAAGD,QAAQ;IAGtB,IAAI,IAAI,CAACzW,SAAS,EAAE,CAACvmB,IAAI,OAAa,EAAE;MACtC2N,IAAI,CAAC6D,EAAE,GAAG,IAAI,CAACsrB,0BAA0B,EAAE;MAC3CnvB,IAAI,CAACnf,GAAG,GAAG,IAAI,CAACypC,wBAAwB,EAAE;IAC5C,CAAC,MAAM;MACLtqB,IAAI,CAAC6D,EAAE,GAAG,IAAI;MACd7D,IAAI,CAACnf,GAAG,GAAG,IAAI,CAAC4pC,aAAa,EAAE;IACjC;IACA,IAAI,CAACjI,MAAM,CAAa,CAAA,CAAA;IACxBxiB,IAAI,CAACtQ,KAAK,GAAG,IAAI,CAAC46B,wBAAwB,EAAE;IAC5CtqB,IAAI,CAACyuB,QAAQ,GAAGA,QAAQ;IAExB,OAAO,IAAI,CAAClqB,UAAU,CAACvE,IAAI,EAAE,mBAAmB,CAAC;EACnD;EAEAuvB,+BAA+BA,CAC7BvvB,IAA0C,EAC1CqvB,QAAiB,EACa;IAC9BrvB,IAAI,CAACsvB,MAAM,GAAGD,QAAQ;IAEtBrvB,IAAI,CAAC6D,EAAE,GAAG,IAAI,CAACsrB,0BAA0B,EAAE;IAC3C,IAAI,CAAC3M,MAAM,CAAa,CAAA,CAAA;IACxB,IAAI,CAACA,MAAM,CAAa,CAAA,CAAA;IACxB,IAAI,IAAI,CAACtM,KAAK,CAAA,EAAA,CAAO,IAAI,IAAI,CAACA,KAAK,CAAA,EAAA,CAAW,EAAE;MAC9ClW,IAAI,CAACoC,MAAM,GAAG,IAAI;MAClBpC,IAAI,CAACkG,QAAQ,GAAG,KAAK;MACrBlG,IAAI,CAACtQ,KAAK,GAAG,IAAI,CAAC8/B,4BAA4B,CAC5C,IAAI,CAACnK,WAAW,CAACrlB,IAAI,CAACnB,GAAG,CAAClQ,KAAK,CAAC,CACjC;IACH,CAAC,MAAM;MACLqR,IAAI,CAACoC,MAAM,GAAG,KAAK;MACnB,IAAI,IAAI,CAACqW,GAAG,CAAA,EAAA,CAAa,EAAE;QACzBzY,IAAI,CAACkG,QAAQ,GAAG,IAAI;MACtB;MACAlG,IAAI,CAACtQ,KAAK,GAAG,IAAI,CAAC46B,wBAAwB,EAAE;IAC9C;IACA,OAAO,IAAI,CAAC/lB,UAAU,CAACvE,IAAI,EAAE,wBAAwB,CAAC;EACxD;EAEAwvB,4BAA4BA,CAC1BxvB,IAA0C,EACZ;IAC9BA,IAAI,CAACqC,MAAM,GAAG,EAAE;IAChBrC,IAAI,CAACL,IAAI,GAAG,IAAI;IAChBK,IAAI,CAACwD,cAAc,GAAG,IAAI;IAC1BxD,IAAI,CAACwrB,IAAI,GAAG,IAAI;IAEhB,IAAI,IAAI,CAACtV,KAAK,CAAA,EAAA,CAAO,EAAE;MACrBlW,IAAI,CAACwD,cAAc,GAAG,IAAI,CAAC6nB,iCAAiC,EAAE;IAChE;IAEA,IAAI,CAAC7I,MAAM,CAAW,EAAA,CAAA;IACtB,IAAI,IAAI,CAACtM,KAAK,CAAA,EAAA,CAAU,EAAE;MACxBlW,IAAI,CAACwrB,IAAI,GAAG,IAAI,CAACiE,0BAA0B,CAAa,IAAI,CAAC;MAE7DzvB,IAAI,CAACwrB,IAAI,CAAC9oC,IAAI,GAAG,IAAI;MACrB,IAAI,CAAC,IAAI,CAACwzB,KAAK,IAAW,EAAE;QAC1B,IAAI,CAACsM,MAAM,CAAU,EAAA,CAAA;MACvB;IACF;IACA,OAAO,CAAC,IAAI,CAACtM,KAAK,CAAA,EAAA,CAAW,IAAI,CAAC,IAAI,CAACA,KAAK,CAAA,EAAA,CAAa,EAAE;MACzDlW,IAAI,CAACqC,MAAM,CAAC5e,IAAI,CAAC,IAAI,CAACgsC,0BAA0B,CAAC,KAAK,CAAC,CAAC;MACxD,IAAI,CAAC,IAAI,CAACvZ,KAAK,IAAW,EAAE;QAC1B,IAAI,CAACsM,MAAM,CAAU,EAAA,CAAA;MACvB;IACF;IAEA,IAAI,IAAI,CAAC/J,GAAG,CAAA,EAAA,CAAa,EAAE;MACzBzY,IAAI,CAACL,IAAI,GAAG,IAAI,CAAC8vB,0BAA0B,CAAC,KAAK,CAAC;IACpD;IACA,IAAI,CAACjN,MAAM,CAAW,EAAA,CAAA;IACtBxiB,IAAI,CAACyrB,UAAU,GAAG,IAAI,CAACnB,wBAAwB,EAAE;IAEjD,OAAO,IAAI,CAAC/lB,UAAU,CAACvE,IAAI,EAAE,wBAAwB,CAAC;EACxD;EAEA0vB,+BAA+BA,CAC7B1vB,IAA0C,EAC1CqvB,QAAiB,EACa;IAC9B,MAAMM,SAAS,GAAG,IAAI,CAACtrB,SAAS,EAAE;IAClCrE,IAAI,CAACsvB,MAAM,GAAGD,QAAQ;IACtBrvB,IAAI,CAACtQ,KAAK,GAAG,IAAI,CAAC8/B,4BAA4B,CAACG,SAAS,CAAC;IACzD,OAAO,IAAI,CAACprB,UAAU,CAACvE,IAAI,EAAE,wBAAwB,CAAC;EACxD;EAEAstB,mBAAmBA,CAAC;IAClBC,WAAW;IACXC,UAAU;IACVC,WAAW;IACXC,UAAU;IACVC;EAOF,CAAC,EAA8B;IAC7B,MAAMnD,SAAS,GAAG,IAAI,CAAC3jB,KAAK,CAACgM,MAAM;IACnC,IAAI,CAAChM,KAAK,CAACgM,MAAM,GAAG,IAAI;IAExB,MAAM3B,SAAS,GAAG,IAAI,CAAC7M,SAAS,EAAE;IAElC6M,SAAS,CAAC0e,cAAc,GAAG,EAAE;IAC7B1e,SAAS,CAACphB,UAAU,GAAG,EAAE;IACzBohB,SAAS,CAAC2e,QAAQ,GAAG,EAAE;IACvB3e,SAAS,CAAC4e,aAAa,GAAG,EAAE;IAE5B,IAAIC,QAAQ;IACZ,IAAIC,KAAK;IACT,IAAIC,OAAO,GAAG,KAAK;IACnB,IAAIzC,UAAU,IAAI,IAAI,CAACtX,KAAK,GAAc,EAAE;MAC1C,IAAI,CAACsM,MAAM,CAAc,CAAA,CAAA;MACzBuN,QAAQ,GAAe,CAAA;MACvBC,KAAK,GAAG,IAAI;IACd,CAAC,MAAM;MACL,IAAI,CAACxN,MAAM,CAAW,CAAA,CAAA;MACtBuN,QAAQ,GAAY,CAAA;MACpBC,KAAK,GAAG,KAAK;IACf;IAEA9e,SAAS,CAAC8e,KAAK,GAAGA,KAAK;IAEvB,OAAO,CAAC,IAAI,CAAC9Z,KAAK,CAAC6Z,QAAQ,CAAC,EAAE;MAC5B,IAAIV,QAAQ,GAAG,KAAK;MACpB,IAAIa,aAA0C,GAAG,IAAI;MACrD,IAAIC,eAA4C,GAAG,IAAI;MACvD,MAAMnwB,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAE;MAE7B,IAAIqpB,UAAU,IAAI,IAAI,CAAChM,YAAY,KAAW,EAAE;QAC9C,MAAM9I,SAAS,GAAG,IAAI,CAACA,SAAS,EAAE;QAElC,IAAIA,SAAS,CAACvmB,IAAI,KAAA,EAAa,IAAIumB,SAAS,CAACvmB,IAAI,KAAA,EAAgB,EAAE;UACjE,IAAI,CAACuX,IAAI,EAAE;UACXsmB,aAAa,GAAG,IAAI,CAACrpB,KAAK,CAAC3B,QAAQ;UACnCqoB,WAAW,GAAG,KAAK;QACrB;MACF;MAEA,IAAIA,WAAW,IAAI,IAAI,CAAC7L,YAAY,KAAY,EAAE;QAChD,MAAM9I,SAAS,GAAG,IAAI,CAACA,SAAS,EAAE;QAGlC,IAAIA,SAAS,CAACvmB,IAAI,KAAA,EAAa,IAAIumB,SAAS,CAACvmB,IAAI,KAAA,EAAgB,EAAE;UACjE,IAAI,CAACuX,IAAI,EAAE;UACXylB,QAAQ,GAAG,IAAI;QACjB;MACF;MAEA,MAAMZ,QAAQ,GAAG,IAAI,CAACC,iBAAiB,EAAE;MAEzC,IAAI,IAAI,CAACjW,GAAG,CAAA,CAAA,CAAa,EAAE;QACzB,IAAIyX,aAAa,IAAI,IAAI,EAAE;UACzB,IAAI,CAAC/4B,UAAU,CAAC+4B,aAAa,CAAC;QAChC;QACA,IAAI,IAAI,CAACzX,GAAG,CAAA,CAAA,CAAa,EAAE;UACzB,IAAIgW,QAAQ,EAAE;YACZ,IAAI,CAACt3B,UAAU,CAACs3B,QAAQ,CAAC5vB,GAAG,CAAClQ,KAAK,CAAC;UACrC;UACAuiB,SAAS,CAAC4e,aAAa,CAACrsC,IAAI,CAC1B,IAAI,CAAC8rC,+BAA+B,CAACvvB,IAAI,EAAEqvB,QAAQ,CAAC,CACrD;QACH,CAAC,MAAM;UACLne,SAAS,CAAC2e,QAAQ,CAACpsC,IAAI,CACrB,IAAI,CAAC2rC,0BAA0B,CAACpvB,IAAI,EAAEqvB,QAAQ,EAAEZ,QAAQ,CAAC,CAC1D;QACH;OACD,MAAM,IAAI,IAAI,CAACvY,KAAK,CAAW,EAAA,CAAA,IAAI,IAAI,CAACA,KAAK,CAAA,EAAA,CAAO,EAAE;QACrD,IAAIga,aAAa,IAAI,IAAI,EAAE;UACzB,IAAI,CAAC/4B,UAAU,CAAC+4B,aAAa,CAAC;QAChC;QACA,IAAIzB,QAAQ,EAAE;UACZ,IAAI,CAACt3B,UAAU,CAACs3B,QAAQ,CAAC5vB,GAAG,CAAClQ,KAAK,CAAC;QACrC;QACAuiB,SAAS,CAAC0e,cAAc,CAACnsC,IAAI,CAC3B,IAAI,CAACisC,+BAA+B,CAAC1vB,IAAI,EAAEqvB,QAAQ,CAAC,CACrD;MACH,CAAC,MAAM;QACL,IAAI58B,IAAI,GAAG,MAAM;QAEjB,IAAI,IAAI,CAACivB,YAAY,CAAA,EAAA,CAAS,IAAI,IAAI,CAACA,YAAY,CAAA,GAAA,CAAS,EAAE;UAC5D,MAAM9I,SAAS,GAAG,IAAI,CAACA,SAAS,EAAE;UAClC,IAAI5rB,0BAA0B,CAAC4rB,SAAS,CAACvmB,IAAI,CAAC,EAAE;YAC9CI,IAAI,GAAG,IAAI,CAACoU,KAAK,CAACnX,KAAK;YACvB,IAAI,CAACka,IAAI,EAAE;UACb;QACF;QAEA,MAAMwmB,aAAa,GAAG,IAAI,CAACC,2BAA2B,CACpDrwB,IAAI,EACJqvB,QAAQ,EACRa,aAAa,EACbzB,QAAQ,EACRh8B,IAAI,EACJg7B,WAAW,EACXE,YAAY,WAAZA,YAAY,GAAI,CAACqC,KAAK,CACvB;QAED,IAAII,aAAa,KAAK,IAAI,EAAE;UAC1BH,OAAO,GAAG,IAAI;UACdE,eAAe,GAAG,IAAI,CAACtpB,KAAK,CAACC,eAAe;QAC9C,CAAC,MAAM;UACLoK,SAAS,CAACphB,UAAU,CAACrM,IAAI,CAAC2sC,aAAa,CAAC;QAC1C;MACF;MAEA,IAAI,CAACE,uBAAuB,EAAE;MAE9B,IACEH,eAAe,IACf,CAAC,IAAI,CAACja,KAAK,CAAW,CAAA,CAAA,IACtB,CAAC,IAAI,CAACA,KAAK,GAAc,EACzB;QACA,IAAI,CAACnQ,KAAK,CAAC0f,UAAU,CAAC4C,iCAAiC,EAAE;UACvD5iC,EAAE,EAAE0qC;QACN,CAAC,CAAC;MACJ;IACF;IAEA,IAAI,CAAC3N,MAAM,CAACuN,QAAQ,CAAC;IAOrB,IAAItC,WAAW,EAAE;MACfvc,SAAS,CAAC+e,OAAO,GAAGA,OAAO;IAC7B;IAEA,MAAM/a,GAAG,GAAG,IAAI,CAAC3Q,UAAU,CAAC2M,SAAS,EAAE,sBAAsB,CAAC;IAE9D,IAAI,CAACrK,KAAK,CAACgM,MAAM,GAAG2X,SAAS;IAE7B,OAAOtV,GAAG;EACZ;EAEAmb,2BAA2BA,CACzBrwB,IAAuE,EACvEqvB,QAAiB,EACjBa,aAA0C,EAC1CzB,QAA2C,EAC3Ch8B,IAAY,EACZg7B,WAAoB,EACpBE,YAAqB,EAC6C;IAClE,IAAI,IAAI,CAAClV,GAAG,CAAA,EAAA,CAAa,EAAE;MACzB,MAAM8X,cAAc,GAClB,IAAI,CAACra,KAAK,CAAU,EAAA,CAAA,IACpB,IAAI,CAACA,KAAK,IAAS,IACnB,IAAI,CAACA,KAAK,CAAA,CAAA,CAAW,IACrB,IAAI,CAACA,KAAK,CAAc,CAAA,CAAA;MAE1B,IAAIqa,cAAc,EAAE;QAClB,IAAI,CAAC9C,WAAW,EAAE;UAChB,IAAI,CAAC1nB,KAAK,CAAC0f,UAAU,CAAC4B,sBAAsB,EAAE;YAC5C5hC,EAAE,EAAE,IAAI,CAACohB,KAAK,CAACC;UACjB,CAAC,CAAC;QACJ,CAAC,MAAM,IAAI,CAAC6mB,YAAY,EAAE;UACxB,IAAI,CAAC5nB,KAAK,CAAC0f,UAAU,CAAC2B,kBAAkB,EAAE;YACxC3hC,EAAE,EAAE,IAAI,CAACohB,KAAK,CAACC;UACjB,CAAC,CAAC;QACJ;QACA,IAAI2nB,QAAQ,EAAE;UACZ,IAAI,CAAC1oB,KAAK,CAAC0f,UAAU,CAAC6B,eAAe,EAAE;YAAE7hC,EAAE,EAAEgpC;UAAS,CAAC,CAAC;QAC1D;QAEA,OAAO,IAAI;MACb;MAEA,IAAI,CAAChB,WAAW,EAAE;QAChB,IAAI,CAAC1nB,KAAK,CAAC0f,UAAU,CAACgD,oBAAoB,EAAE;UAC1ChjC,EAAE,EAAE,IAAI,CAACohB,KAAK,CAACC;QACjB,CAAC,CAAC;MACJ;MACA,IAAIopB,aAAa,IAAI,IAAI,EAAE;QACzB,IAAI,CAAC/4B,UAAU,CAAC+4B,aAAa,CAAC;MAChC;MACA,IAAIzB,QAAQ,EAAE;QACZ,IAAI,CAAC1oB,KAAK,CAAC0f,UAAU,CAACoC,cAAc,EAAE;UAAEpiC,EAAE,EAAEgpC;QAAS,CAAC,CAAC;MACzD;MAEAzuB,IAAI,CAACb,QAAQ,GAAG,IAAI,CAACsrB,aAAa,EAAE;MACpC,OAAO,IAAI,CAAClmB,UAAU,CAACvE,IAAI,EAAE,0BAA0B,CAAC;IAC1D,CAAC,MAAM;MACLA,IAAI,CAACnf,GAAG,GAAG,IAAI,CAACsuC,0BAA0B,EAAE;MAC5CnvB,IAAI,CAACsvB,MAAM,GAAGD,QAAQ;MACtBrvB,IAAI,CAACwwB,KAAK,GAAGN,aAAa,IAAI,IAAI;MAClClwB,IAAI,CAACvN,IAAI,GAAGA,IAAI;MAEhB,IAAIyT,QAAQ,GAAG,KAAK;MACpB,IAAI,IAAI,CAACgQ,KAAK,CAAA,EAAA,CAAO,IAAI,IAAI,CAACA,KAAK,CAAA,EAAA,CAAW,EAAE;QAE9ClW,IAAI,CAACoC,MAAM,GAAG,IAAI;QAElB,IAAI8tB,aAAa,IAAI,IAAI,EAAE;UACzB,IAAI,CAAC/4B,UAAU,CAAC+4B,aAAa,CAAC;QAChC;QACA,IAAIzB,QAAQ,EAAE;UACZ,IAAI,CAACt3B,UAAU,CAACs3B,QAAQ,CAAC5vB,GAAG,CAAClQ,KAAK,CAAC;QACrC;QAEAqR,IAAI,CAACtQ,KAAK,GAAG,IAAI,CAAC8/B,4BAA4B,CAC5C,IAAI,CAACnK,WAAW,CAACrlB,IAAI,CAACnB,GAAG,CAAClQ,KAAK,CAAC,CACjC;QACD,IAAI8D,IAAI,KAAK,KAAK,IAAIA,IAAI,KAAK,KAAK,EAAE;UACpC,IAAI,CAACg+B,2BAA2B,CAACzwB,IAAI,CAAC;QACxC;QAEA,IACE,CAACytB,WAAW,IACZztB,IAAI,CAACnf,GAAG,CAAC6B,IAAI,KAAK,aAAa,IAC/Bsd,IAAI,CAACtQ,KAAK,CAAC87B,IAAI,EACf;UACA,IAAI,CAACzlB,KAAK,CAAC0f,UAAU,CAACsC,4BAA4B,EAAE;YAClDtiC,EAAE,EAAEua,IAAI,CAACtQ,KAAK,CAAC87B;UACjB,CAAC,CAAC;QACJ;MACF,CAAC,MAAM;QACL,IAAI/4B,IAAI,KAAK,MAAM,EAAE,IAAI,CAAC0E,UAAU,EAAE;QAEtC6I,IAAI,CAACoC,MAAM,GAAG,KAAK;QAEnB,IAAI,IAAI,CAACqW,GAAG,CAAA,EAAA,CAAa,EAAE;UACzBvS,QAAQ,GAAG,IAAI;QACjB;QACAlG,IAAI,CAACtQ,KAAK,GAAG,IAAI,CAAC46B,wBAAwB,EAAE;QAC5CtqB,IAAI,CAACyuB,QAAQ,GAAGA,QAAQ;MAC1B;MAEAzuB,IAAI,CAACkG,QAAQ,GAAGA,QAAQ;MAExB,OAAO,IAAI,CAAC3B,UAAU,CAACvE,IAAI,EAAE,oBAAoB,CAAC;IACpD;EACF;EAIAywB,2BAA2BA,CACzBjN,QAEC,EACK;IACN,MAAMkN,UAAU,GAAGlN,QAAQ,CAAC/wB,IAAI,KAAK,KAAK,GAAG,CAAC,GAAG,CAAC;IAClD,MAAMrE,MAAM,GACVo1B,QAAQ,CAAC9zB,KAAK,CAAC2S,MAAM,CAACjU,MAAM,IAAIo1B,QAAQ,CAAC9zB,KAAK,CAACiQ,IAAI,GAAG,CAAC,GAAG,CAAC,CAAC;IAE9D,IAAI6jB,QAAQ,CAAC9zB,KAAK,CAAC87B,IAAI,EAAE;MACvB,IAAI,CAACzlB,KAAK,CACRyd,QAAQ,CAAC/wB,IAAI,KAAK,KAAK,GACnBgzB,UAAU,CAACwB,yBAAyB,GACpCxB,UAAU,CAACmC,yBAAyB,EACxC;QAAEniC,EAAE,EAAE+9B,QAAQ,CAAC9zB,KAAK,CAAC87B;MAAK,CAAC,CAC5B;IACH;IAEA,IAAIp9B,MAAM,KAAKsiC,UAAU,EAAE;MACzB,IAAI,CAAC3qB,KAAK,CACRyd,QAAQ,CAAC/wB,IAAI,KAAK,KAAK,GACnBoN,MAAM,CAAC3M,cAAc,GACrB2M,MAAM,CAAC1M,cAAc,EACzB;QAAE1N,EAAE,EAAE+9B;MAAS,CAAC,CACjB;IACH;IAEA,IAAIA,QAAQ,CAAC/wB,IAAI,KAAK,KAAK,IAAI+wB,QAAQ,CAAC9zB,KAAK,CAACiQ,IAAI,EAAE;MAClD,IAAI,CAACoG,KAAK,CAAClG,MAAM,CAACzM,sBAAsB,EAAE;QAAE3N,EAAE,EAAE+9B;MAAS,CAAC,CAAC;IAC7D;EACF;EAEA8M,uBAAuBA,CAAAA,EAAS;IAC9B,IACE,CAAC,IAAI,CAAC7X,GAAG,IAAS,IAClB,CAAC,IAAI,CAACA,GAAG,CAAA,EAAA,CAAU,IACnB,CAAC,IAAI,CAACvC,KAAK,CAAW,CAAA,CAAA,IACtB,CAAC,IAAI,CAACA,KAAK,CAAA,CAAA,CAAc,EACzB;MACA,IAAI,CAAC/e,UAAU,EAAE;IACnB;EACF;EAEAy2B,gCAAgCA,CAC9B1oB,QAAmB,EACnBrB,EAAiB,EACc;IAAA,IAAA8sB,SAAA;IAC/B,CAAAA,SAAA,GAAAzrB,QAAQ,KAAA,IAAA,GAAAyrB,SAAA,GAARzrB,QAAQ,GAAK,IAAI,CAAC2B,KAAK,CAAC3B,QAAQ;IAChC,IAAIlF,IAAkD,GACpD6D,EAAE,IAAI,IAAI,CAACopB,6BAA6B,CAAC,IAAI,CAAC;IAEhD,OAAO,IAAI,CAACxU,GAAG,CAAA,EAAA,CAAQ,EAAE;MACvB,MAAMmY,KAAK,GAAG,IAAI,CAACvL,WAAW,CAAgCngB,QAAQ,CAAC;MACvE0rB,KAAK,CAACC,aAAa,GAAG7wB,IAAI;MAC1B4wB,KAAK,CAAC/sB,EAAE,GAAG,IAAI,CAACopB,6BAA6B,CAAC,IAAI,CAAC;MACnDjtB,IAAI,GAAG,IAAI,CAACuE,UAAU,CAACqsB,KAAK,EAAE,yBAAyB,CAAC;IAC1D;IAEA,OAAO5wB,IAAI;EACb;EAEA8wB,oBAAoBA,CAClB5rB,QAAkB,EAClBrB,EAAgB,EACa;IAC7B,MAAM7D,IAAI,GAAG,IAAI,CAACqlB,WAAW,CAACngB,QAAQ,CAAC;IAEvClF,IAAI,CAACwD,cAAc,GAAG,IAAI;IAC1BxD,IAAI,CAAC6D,EAAE,GAAG,IAAI,CAAC+pB,gCAAgC,CAAC1oB,QAAQ,EAAErB,EAAE,CAAC;IAE7D,IAAI,IAAI,CAACqS,KAAK,CAAA,EAAA,CAAO,EAAE;MACrBlW,IAAI,CAACwD,cAAc,GAAG,IAAI,CAACqqB,mCAAmC,EAAE;IAClE;IAEA,OAAO,IAAI,CAACtpB,UAAU,CAACvE,IAAI,EAAE,uBAAuB,CAAC;EACvD;EAEA+wB,mBAAmBA,CAAAA,EAA+B;IAChD,MAAM/wB,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAE;IAC7B,IAAI,CAACme,MAAM,CAAY,EAAA,CAAA;IACvBxiB,IAAI,CAACb,QAAQ,GAAG,IAAI,CAAC6xB,oBAAoB,EAAE;IAC3C,OAAO,IAAI,CAACzsB,UAAU,CAACvE,IAAI,EAAE,sBAAsB,CAAC;EACtD;EAEAixB,kBAAkBA,CAAAA,EAA8B;IAC9C,MAAMjxB,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAE;IAC7BrE,IAAI,CAAC5e,KAAK,GAAG,EAAE;IACf,IAAI,CAACohC,MAAM,CAAa,CAAA,CAAA;IAExB,OAAO,IAAI,CAAC3b,KAAK,CAAC5H,GAAG,GAAG,IAAI,CAAC7Q,MAAM,IAAI,CAAC,IAAI,CAAC8nB,KAAK,GAAa,EAAE;MAC/DlW,IAAI,CAAC5e,KAAK,CAACqC,IAAI,CAAC,IAAI,CAACgnC,aAAa,EAAE,CAAC;MACrC,IAAI,IAAI,CAACvU,KAAK,CAAA,CAAA,CAAa,EAAE;MAC7B,IAAI,CAACsM,MAAM,CAAU,EAAA,CAAA;IACvB;IACA,IAAI,CAACA,MAAM,CAAa,CAAA,CAAA;IACxB,OAAO,IAAI,CAACje,UAAU,CAACvE,IAAI,EAAE,qBAAqB,CAAC;EACrD;EAEAyvB,0BAA0BA,CAACyB,KAAc,EAA2B;IAClE,IAAIxuC,IAAI,GAAG,IAAI;IACf,IAAIwjB,QAAQ,GAAG,KAAK;IACpB,IAAIwlB,cAAc,GAAG,IAAI;IACzB,MAAM1rB,IAAI,GAAG,IAAI,CAACqE,SAAS,EAA2B;IACtD,MAAM8sB,EAAE,GAAG,IAAI,CAACvY,SAAS,EAAE;IAC3B,MAAMwY,MAAM,GAAG,IAAI,CAACvqB,KAAK,CAACxU,IAAI,KAAa,EAAA;IAE3C,IAAI8+B,EAAE,CAAC9+B,IAAI,KAAA,EAAa,IAAI8+B,EAAE,CAAC9+B,IAAI,KAAA,EAAgB,EAAE;MACnD,IAAI++B,MAAM,IAAI,CAACF,KAAK,EAAE;QACpB,IAAI,CAACnrB,KAAK,CAAC0f,UAAU,CAACwC,oBAAoB,EAAE;UAAExiC,EAAE,EAAEua;QAAK,CAAC,CAAC;MAC3D;MACAtd,IAAI,GAAG,IAAI,CAACwoC,eAAe,CAACkG,MAAM,CAAC;MACnC,IAAI,IAAI,CAAC3Y,GAAG,CAAA,EAAA,CAAa,EAAE;QACzBvS,QAAQ,GAAG,IAAI;QACf,IAAIkrB,MAAM,EAAE;UACV,IAAI,CAACrrB,KAAK,CAAC0f,UAAU,CAACuC,yBAAyB,EAAE;YAAEviC,EAAE,EAAEua;UAAK,CAAC,CAAC;QAChE;MACF;MACA0rB,cAAc,GAAG,IAAI,CAACpB,wBAAwB,EAAE;IAClD,CAAC,MAAM;MACLoB,cAAc,GAAG,IAAI,CAACjB,aAAa,EAAE;IACvC;IACAzqB,IAAI,CAACtd,IAAI,GAAGA,IAAI;IAChBsd,IAAI,CAACkG,QAAQ,GAAGA,QAAQ;IACxBlG,IAAI,CAAC0rB,cAAc,GAAGA,cAAc;IACpC,OAAO,IAAI,CAACnnB,UAAU,CAACvE,IAAI,EAAE,mBAAmB,CAAC;EACnD;EAEAqxB,kCAAkCA,CAChCh/B,IAAgB,EACS;IACzB,MAAM2N,IAAI,GAAG,IAAI,CAACqlB,WAAW,CAAChzB,IAAI,CAACwM,GAAG,CAAClQ,KAAK,CAAC;IAC7CqR,IAAI,CAACtd,IAAI,GAAG,IAAI;IAChBsd,IAAI,CAACkG,QAAQ,GAAG,KAAK;IACrBlG,IAAI,CAAC0rB,cAAc,GAAGr5B,IAAI;IAC1B,OAAO,IAAI,CAACkS,UAAU,CAACvE,IAAI,EAAE,mBAAmB,CAAC;EACnD;EAEAurB,2BAA2BA,CAAClpB,MAAiC,GAAG,EAAE,EAIhE;IACA,IAAI1C,IAAgD,GAAG,IAAI;IAC3D,IAAI9W,KAAiD,GAAG,IAAI;IAC5D,IAAI,IAAI,CAACqtB,KAAK,CAAA,EAAA,CAAU,EAAE;MACxBrtB,KAAK,GAAG,IAAI,CAAC4mC,0BAA0B,CAAa,IAAI,CAAC;MAEzD5mC,KAAK,CAACnG,IAAI,GAAG,IAAI;MACjB,IAAI,CAAC,IAAI,CAACwzB,KAAK,IAAW,EAAE;QAC1B,IAAI,CAACsM,MAAM,CAAU,EAAA,CAAA;MACvB;IACF;IACA,OAAO,CAAC,IAAI,CAACtM,KAAK,CAAA,EAAA,CAAW,IAAI,CAAC,IAAI,CAACA,KAAK,CAAA,EAAA,CAAa,EAAE;MACzD7T,MAAM,CAAC5e,IAAI,CAAC,IAAI,CAACgsC,0BAA0B,CAAC,KAAK,CAAC,CAAC;MACnD,IAAI,CAAC,IAAI,CAACvZ,KAAK,IAAW,EAAE;QAC1B,IAAI,CAACsM,MAAM,CAAU,EAAA,CAAA;MACvB;IACF;IACA,IAAI,IAAI,CAAC/J,GAAG,CAAA,EAAA,CAAa,EAAE;MACzB9Y,IAAI,GAAG,IAAI,CAAC8vB,0BAA0B,CAAC,KAAK,CAAC;IAC/C;IACA,OAAO;MAAEptB,MAAM;MAAE1C,IAAI;MAAE9W;KAAO;EAChC;EAEAyoC,yBAAyBA,CACvBpsB,QAAkB,EAClBlF,IAAkC,EAClC6D,EAAgB,EACM;IACtB,QAAQA,EAAE,CAACnhB,IAAI;MACb,KAAK,KAAK;QACR,OAAO,IAAI,CAAC6hB,UAAU,CAACvE,IAAI,EAAE,mBAAmB,CAAC;MAEnD,KAAK,MAAM;MACX,KAAK,SAAS;QACZ,OAAO,IAAI,CAACuE,UAAU,CAACvE,IAAI,EAAE,uBAAuB,CAAC;MAEvD,KAAK,OAAO;QACV,OAAO,IAAI,CAACuE,UAAU,CAACvE,IAAI,EAAE,qBAAqB,CAAC;MAErD,KAAK,OAAO;QACV,OAAO,IAAI,CAACuE,UAAU,CAACvE,IAAI,EAAE,qBAAqB,CAAC;MAErD,KAAK,QAAQ;QACX,OAAO,IAAI,CAACuE,UAAU,CAACvE,IAAI,EAAE,sBAAsB,CAAC;MAEtD,KAAK,QAAQ;QACX,OAAO,IAAI,CAACuE,UAAU,CAACvE,IAAI,EAAE,sBAAsB,CAAC;MAEtD,KAAK,QAAQ;QACX,OAAO,IAAI,CAACuE,UAAU,CAACvE,IAAI,EAAE,sBAAsB,CAAC;MAEtD;QACE,IAAI,CAAC+tB,kBAAkB,CAAClqB,EAAE,CAACnhB,IAAI,CAAC;QAChC,OAAO,IAAI,CAACouC,oBAAoB,CAAC5rB,QAAQ,EAAErB,EAAE,CAAC;IAAA;EAEpD;EAKAmtB,oBAAoBA,CAAAA,EAAyB;IAC3C,MAAM9rB,QAAQ,GAAG,IAAI,CAAC2B,KAAK,CAAC3B,QAAQ;IACpC,MAAMlF,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAE;IAC7B,IAAIinB,GAAG;IACP,IAAIj5B,IAAI;IACR,IAAIk/B,aAAa,GAAG,KAAK;IACzB,MAAMxC,qBAAqB,GAAG,IAAI,CAACloB,KAAK,CAACiM,kBAAkB;IAE3D,QAAQ,IAAI,CAACjM,KAAK,CAACxU,IAAI;MACrB,KAAA,CAAA;QACE,OAAO,IAAI,CAACi7B,mBAAmB,CAAC;UAC9BC,WAAW,EAAE,KAAK;UAClBC,UAAU,EAAE,KAAK;UACjBC,WAAW,EAAE,IAAI;UACjBC,UAAU,EAAE,KAAK;UACjBC,YAAY,EAAE;QAChB,CAAC,CAAC;MAEJ,KAAA,CAAA;QACE,OAAO,IAAI,CAACL,mBAAmB,CAAC;UAC9BC,WAAW,EAAE,KAAK;UAClBC,UAAU,EAAE,IAAI;UAChBC,WAAW,EAAE,IAAI;UACjBC,UAAU,EAAE,KAAK;UACjBC,YAAY,EAAE;QAChB,CAAC,CAAC;MAEJ,KAAA,CAAA;QACE,IAAI,CAAC9mB,KAAK,CAACiM,kBAAkB,GAAG,KAAK;QACrCzgB,IAAI,GAAG,IAAI,CAAC4+B,kBAAkB,EAAE;QAChC,IAAI,CAACpqB,KAAK,CAACiM,kBAAkB,GAAGic,qBAAqB;QACrD,OAAO18B,IAAI;MAEb,KAAA,EAAA;QACE2N,IAAI,CAACwD,cAAc,GAAG,IAAI,CAAC6nB,iCAAiC,EAAE;QAC9D,IAAI,CAAC7I,MAAM,CAAW,EAAA,CAAA;QACtB8I,GAAG,GAAG,IAAI,CAACC,2BAA2B,EAAE;QACxCvrB,IAAI,CAACqC,MAAM,GAAGipB,GAAG,CAACjpB,MAAM;QACxBrC,IAAI,CAACL,IAAI,GAAG2rB,GAAG,CAAC3rB,IAAI;QACpBK,IAAI,CAACwrB,IAAI,GAAGF,GAAG,CAACziC,KAAK;QACrB,IAAI,CAAC25B,MAAM,CAAW,EAAA,CAAA;QAEtB,IAAI,CAACA,MAAM,CAAU,EAAA,CAAA;QAErBxiB,IAAI,CAACyrB,UAAU,GAAG,IAAI,CAAChB,aAAa,EAAE;QAEtC,OAAO,IAAI,CAAClmB,UAAU,CAACvE,IAAI,EAAE,wBAAwB,CAAC;MAExD,KAAA,EAAA;QACE,IAAI,CAAC4J,IAAI,EAAE;QAGX,IAAI,CAAC,IAAI,CAACsM,KAAK,CAAA,EAAA,CAAW,IAAI,CAAC,IAAI,CAACA,KAAK,CAAA,EAAA,CAAa,EAAE;UACtD,IAAIrpB,iBAAiB,CAAC,IAAI,CAACga,KAAK,CAACxU,IAAI,CAAC,IAAI,IAAI,CAAC6jB,KAAK,IAAU,EAAE;YAC9D,MAAMh1B,KAAK,GAAG,IAAI,CAAC03B,SAAS,EAAE,CAACvmB,IAAI;YACnCk/B,aAAa,GAAGrwC,KAAK,KAAgB,EAAA,IAAIA,KAAK,KAAa,EAAA;UAC7D,CAAC,MAAM;YACLqwC,aAAa,GAAG,IAAI;UACtB;QACF;QAEA,IAAIA,aAAa,EAAE;UACjB,IAAI,CAAC1qB,KAAK,CAACiM,kBAAkB,GAAG,KAAK;UACrCzgB,IAAI,GAAG,IAAI,CAACo4B,aAAa,EAAE;UAC3B,IAAI,CAAC5jB,KAAK,CAACiM,kBAAkB,GAAGic,qBAAqB;UAGrD,IACE,IAAI,CAACloB,KAAK,CAACiM,kBAAkB,IAC7B,EACE,IAAI,CAACoD,KAAK,CAAU,EAAA,CAAA,IACnB,IAAI,CAACA,KAAK,CAAW,EAAA,CAAA,IAAI,IAAI,CAAC0C,SAAS,EAAE,CAACvmB,IAAI,KAAc,EAAA,CAC9D,EACD;YACA,IAAI,CAACmwB,MAAM,CAAW,EAAA,CAAA;YACtB,OAAOnwB,IAAI;UACb,CAAC,MAAM;YAEL,IAAI,CAAComB,GAAG,CAAU,EAAA,CAAA;UACpB;QACF;QAEA,IAAIpmB,IAAI,EAAE;UACRi5B,GAAG,GAAG,IAAI,CAACC,2BAA2B,CAAC,CACrC,IAAI,CAAC8F,kCAAkC,CAACh/B,IAAI,CAAC,CAC9C,CAAC;QACJ,CAAC,MAAM;UACLi5B,GAAG,GAAG,IAAI,CAACC,2BAA2B,EAAE;QAC1C;QAEAvrB,IAAI,CAACqC,MAAM,GAAGipB,GAAG,CAACjpB,MAAM;QACxBrC,IAAI,CAACL,IAAI,GAAG2rB,GAAG,CAAC3rB,IAAI;QACpBK,IAAI,CAACwrB,IAAI,GAAGF,GAAG,CAACziC,KAAK;QAErB,IAAI,CAAC25B,MAAM,CAAW,EAAA,CAAA;QAEtB,IAAI,CAACA,MAAM,CAAU,EAAA,CAAA;QAErBxiB,IAAI,CAACyrB,UAAU,GAAG,IAAI,CAAChB,aAAa,EAAE;QAEtCzqB,IAAI,CAACwD,cAAc,GAAG,IAAI;QAE1B,OAAO,IAAI,CAACe,UAAU,CAACvE,IAAI,EAAE,wBAAwB,CAAC;MAExD,KAAA,GAAA;QACE,OAAO,IAAI,CAACkB,YAAY,CACtB,IAAI,CAAC2F,KAAK,CAACnX,KAAK,EAChB,6BAA6B,CAC9B;MAEH,KAAA,EAAA;MACA,KAAA,EAAA;QACEsQ,IAAI,CAACtQ,KAAK,GAAG,IAAI,CAACwmB,KAAK,CAAU,EAAA,CAAA;QACjC,IAAI,CAACtM,IAAI,EAAE;QACX,OAAO,IAAI,CAACrF,UAAU,CACpBvE,IAAI,EACJ,8BAA8B,CAC/B;MAEH,KAAA,EAAA;QACE,IAAI,IAAI,CAAC6G,KAAK,CAACnX,KAAK,KAAK,GAAG,EAAE;UAC5B,IAAI,CAACka,IAAI,EAAE;UACX,IAAI,IAAI,CAACsM,KAAK,CAAA,GAAA,CAAQ,EAAE;YACtB,OAAO,IAAI,CAACsb,kBAAkB,CAC5B,CAAC,IAAI,CAAC3qB,KAAK,CAACnX,KAAK,EACjB,6BAA6B,EAC7BsQ,IAAI,CACL;UACH;UAEA,IAAI,IAAI,CAACkW,KAAK,CAAA,GAAA,CAAW,EAAE;YACzB,OAAO,IAAI,CAACsb,kBAAkB,CAC5B,CAAC,IAAI,CAAC3qB,KAAK,CAACnX,KAAK,EACjB,6BAA6B,EAC7BsQ,IAAI,CACL;UACH;UAEA,MAAM,IAAI,CAAC+F,KAAK,CAAC0f,UAAU,CAACiD,4BAA4B,EAAE;YACxDjjC,EAAE,EAAE,IAAI,CAACohB,KAAK,CAAC3B;UACjB,CAAC,CAAC;QACJ;QACA,IAAI,CAAC/N,UAAU,EAAE;QACjB;MACF,KAAA,GAAA;QACE,OAAO,IAAI,CAAC+J,YAAY,CACtB,IAAI,CAAC2F,KAAK,CAACnX,KAAK,EAChB,6BAA6B,CAC9B;MAEH,KAAA,GAAA;QACE,OAAO,IAAI,CAACwR,YAAY,CACtB,IAAI,CAAC2F,KAAK,CAACnX,KAAK,EAChB,6BAA6B,CAC9B;MAEH,KAAA,EAAA;QACE,IAAI,CAACka,IAAI,EAAE;QACX,OAAO,IAAI,CAACrF,UAAU,CAACvE,IAAI,EAAE,oBAAoB,CAAC;MAEpD,KAAA,EAAA;QACE,IAAI,CAAC4J,IAAI,EAAE;QACX,OAAO,IAAI,CAACrF,UAAU,CAACvE,IAAI,EAAE,2BAA2B,CAAC;MAE3D,KAAA,EAAA;QACE,IAAI,CAAC4J,IAAI,EAAE;QACX,OAAO,IAAI,CAACrF,UAAU,CAACvE,IAAI,EAAE,oBAAoB,CAAC;MAEpD,KAAA,EAAA;QACE,IAAI,CAAC4J,IAAI,EAAE;QACX,OAAO,IAAI,CAACrF,UAAU,CAACvE,IAAI,EAAE,sBAAsB,CAAC;MAEtD,KAAA,EAAA;QACE,OAAO,IAAI,CAAC+wB,mBAAmB,EAAE;MAEnC;QACE,IAAIzjC,cAAc,CAAC,IAAI,CAACuZ,KAAK,CAACxU,IAAI,CAAC,EAAE;UACnC,MAAMpQ,KAAK,GAAG2L,cAAc,CAAC,IAAI,CAACiZ,KAAK,CAACxU,IAAI,CAAC;UAC7C,IAAI,CAACuX,IAAI,EAAE;UACX,OAAO,KAAK,CAAC6nB,gBAAgB,CAACzxB,IAAI,EAA0B/d,KAAK,CAAC;QACnE,CAAA,MAAM,IAAI4K,iBAAiB,CAAC,IAAI,CAACga,KAAK,CAACxU,IAAI,CAAC,EAAE;UAC7C,IAAI,IAAI,CAACqvB,YAAY,CAAA,GAAA,CAAe,EAAE;YACpC,OAAO,IAAI,CAACwN,sBAAsB,EAAE;UACtC;UAEA,OAAO,IAAI,CAACoC,yBAAyB,CACnCpsB,QAAQ,EACRlF,IAAI,EACJ,IAAI,CAACkrB,eAAe,EAAE,CACvB;QACH;IAAA;IAGJ,IAAI,CAAC/zB,UAAU,EAAE;EACnB;EAEAu6B,oBAAoBA,CAAAA,EAAyB;IAC3C,MAAMxsB,QAAQ,GAAG,IAAI,CAAC2B,KAAK,CAAC3B,QAAQ;IACpC,IAAI7S,IAAI,GAAG,IAAI,CAAC2+B,oBAAoB,EAAE;IACtC,IAAIW,yBAAyB,GAAG,KAAK;IACrC,OACE,CAAC,IAAI,CAACzb,KAAK,CAAA,CAAA,CAAa,IAAI,IAAI,CAACA,KAAK,CAAA,EAAA,CAAgB,KACtD,CAAC,IAAI,CAACgM,kBAAkB,EAAE,EAC1B;MACA,MAAMliB,IAAI,GAAG,IAAI,CAACqlB,WAAW,CAACngB,QAAQ,CAAC;MACvC,MAAMgB,QAAQ,GAAG,IAAI,CAACuS,GAAG,CAAgB,EAAA,CAAA;MACzCkZ,yBAAyB,GAAGA,yBAAyB,IAAIzrB,QAAQ;MACjE,IAAI,CAACsc,MAAM,CAAa,CAAA,CAAA;MACxB,IAAI,CAACtc,QAAQ,IAAI,IAAI,CAACgQ,KAAK,GAAa,EAAE;QACxClW,IAAI,CAAC4e,WAAW,GAAGvsB,IAAI;QACvB,IAAI,CAACuX,IAAI,EAAE;QACXvX,IAAI,GAAG,IAAI,CAACkS,UAAU,CAACvE,IAAI,EAAE,qBAAqB,CAAC;MACrD,CAAC,MAAM;QACLA,IAAI,CAAC4xB,UAAU,GAAGv/B,IAAI;QACtB2N,IAAI,CAAC6xB,SAAS,GAAG,IAAI,CAACpH,aAAa,EAAE;QACrC,IAAI,CAACjI,MAAM,CAAa,CAAA,CAAA;QACxB,IAAImP,yBAAyB,EAAE;UAC7B3xB,IAAI,CAACkG,QAAQ,GAAGA,QAAQ;UACxB7T,IAAI,GAAG,IAAI,CAACkS,UAAU,CAEpBvE,IAAI,EACJ,2BAA2B,CAC5B;QACH,CAAC,MAAM;UACL3N,IAAI,GAAG,IAAI,CAACkS,UAAU,CAEpBvE,IAAI,EACJ,mBAAmB,CACpB;QACH;MACF;IACF;IACA,OAAO3N,IAAI;EACb;EAEAy/B,mBAAmBA,CAAAA,EAAyB;IAC1C,MAAM9xB,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAE;IAC7B,IAAI,IAAI,CAACoU,GAAG,CAAA,EAAA,CAAa,EAAE;MACzBzY,IAAI,CAAC0rB,cAAc,GAAG,IAAI,CAACoG,mBAAmB,EAAE;MAChD,OAAO,IAAI,CAACvtB,UAAU,CAACvE,IAAI,EAAE,wBAAwB,CAAC;IACxD,CAAC,MAAM;MACL,OAAO,IAAI,CAAC0xB,oBAAoB,EAAE;IACpC;EACF;EAEAK,kCAAkCA,CAAAA,EAAyB;IACzD,MAAMC,KAAK,GAAG,IAAI,CAACF,mBAAmB,EAAE;IACxC,IAAI,CAAC,IAAI,CAACjrB,KAAK,CAACiM,kBAAkB,IAAI,IAAI,CAAC2F,GAAG,CAAA,EAAA,CAAU,EAAE;MAExD,MAAMzY,IAAI,GAAG,IAAI,CAACqlB,WAAW,CAAC2M,KAAK,CAACnzB,GAAG,CAAClQ,KAAK,CAAC;MAC9CqR,IAAI,CAACqC,MAAM,GAAG,CAAC,IAAI,CAACgvB,kCAAkC,CAACW,KAAK,CAAC,CAAC;MAC9DhyB,IAAI,CAACL,IAAI,GAAG,IAAI;MAChBK,IAAI,CAACwrB,IAAI,GAAG,IAAI;MAChBxrB,IAAI,CAACyrB,UAAU,GAAG,IAAI,CAAChB,aAAa,EAAE;MACtCzqB,IAAI,CAACwD,cAAc,GAAG,IAAI;MAC1B,OAAO,IAAI,CAACe,UAAU,CAACvE,IAAI,EAAE,wBAAwB,CAAC;IACxD;IACA,OAAOgyB,KAAK;EACd;EAEAC,yBAAyBA,CAAAA,EAAyB;IAChD,MAAMjyB,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAE;IAC7B,IAAI,CAACoU,GAAG,CAAe,EAAA,CAAA;IACvB,MAAMpmB,IAAI,GAAG,IAAI,CAAC0/B,kCAAkC,EAAE;IACtD/xB,IAAI,CAAC5e,KAAK,GAAG,CAACiR,IAAI,CAAC;IACnB,OAAO,IAAI,CAAComB,GAAG,CAAA,EAAA,CAAe,EAAE;MAC9BzY,IAAI,CAAC5e,KAAK,CAACqC,IAAI,CAAC,IAAI,CAACsuC,kCAAkC,EAAE,CAAC;IAC5D;IACA,OAAO/xB,IAAI,CAAC5e,KAAK,CAACgN,MAAM,KAAK,CAAC,GAC1BiE,IAAI,GACJ,IAAI,CAACkS,UAAU,CAACvE,IAAI,EAAE,4BAA4B,CAAC;EACzD;EAEAkyB,kBAAkBA,CAAAA,EAAyB;IACzC,MAAMlyB,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAE;IAC7B,IAAI,CAACoU,GAAG,CAAc,EAAA,CAAA;IACtB,MAAMpmB,IAAI,GAAG,IAAI,CAAC4/B,yBAAyB,EAAE;IAC7CjyB,IAAI,CAAC5e,KAAK,GAAG,CAACiR,IAAI,CAAC;IACnB,OAAO,IAAI,CAAComB,GAAG,CAAA,EAAA,CAAc,EAAE;MAC7BzY,IAAI,CAAC5e,KAAK,CAACqC,IAAI,CAAC,IAAI,CAACwuC,yBAAyB,EAAE,CAAC;IACnD;IACA,OAAOjyB,IAAI,CAAC5e,KAAK,CAACgN,MAAM,KAAK,CAAC,GAC1BiE,IAAI,GACJ,IAAI,CAACkS,UAAU,CAACvE,IAAI,EAAE,qBAAqB,CAAC;EAClD;EAEAyqB,aAAaA,CAAAA,EAAyB;IACpC,MAAMD,SAAS,GAAG,IAAI,CAAC3jB,KAAK,CAACgM,MAAM;IACnC,IAAI,CAAChM,KAAK,CAACgM,MAAM,GAAG,IAAI;IACxB,MAAMxgB,IAAI,GAAG,IAAI,CAAC6/B,kBAAkB,EAAE;IACtC,IAAI,CAACrrB,KAAK,CAACgM,MAAM,GAAG2X,SAAS;IAC7B,OAAOn4B,IAAI;EACb;EAEA48B,oCAAoCA,CAAAA,EAAyB;IAC3D,IAAI,IAAI,CAACpoB,KAAK,CAACxU,IAAI,KAAY,GAAA,IAAI,IAAI,CAACwU,KAAK,CAACnX,KAAK,KAAK,GAAG,EAAE;MAC3D,MAAMwV,QAAQ,GAAG,IAAI,CAAC2B,KAAK,CAAC3B,QAAQ;MACpC,MAAMlF,IAAI,GAAG,IAAI,CAACkrB,eAAe,EAAE;MACnC,OAAO,IAAI,CAAC4F,oBAAoB,CAAC5rB,QAAQ,EAAElF,IAAI,CAAC;IAClD,CAAC,MAAM;MACL,OAAO,IAAI,CAACyqB,aAAa,EAAE;IAC7B;EACF;EAEAmC,uBAAuBA,CAAAA,EAAyB;IAC9C,MAAM5sB,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAwB;IACnDrE,IAAI,CAAC0rB,cAAc,GAAG,IAAI,CAACpB,wBAAwB,EAAE;IACrD,OAAO,IAAI,CAAC/lB,UAAU,CAACvE,IAAI,EAAE,gBAAgB,CAAC;EAChD;EAEAosB,kCAAkCA,CAChC+F,sBAAgC,EAClB;IACd,MAAMxD,KAAK,GAAGwD,sBAAsB,GAChC,IAAI,CAACjH,eAAe,EAAE,GACtB,IAAI,CAAC+B,6BAA6B,EAAE;IACxC,IAAI,IAAI,CAAC/W,KAAK,CAAA,EAAA,CAAU,EAAE;MAExByY,KAAK,CAACjD,cAAc,GAAG,IAAI,CAACkB,uBAAuB,EAAE;MACrD,IAAI,CAAC5kB,gBAAgB,CAAC2mB,KAAK,CAAC;IAC9B;IACA,OAAOA,KAAK;EACd;EAEAyD,mBAAmBA,CAACpyB,IAAY,EAAU;IACxCA,IAAI,CAACyB,UAAU,CAACiqB,cAAc,GAAG1rB,IAAI,CAAC0rB,cAAc;IAEpD,IAAI,CAAC1jB,gBAAgB,CAAChI,IAAI,CAACyB,UAAU,EAAEzB,IAAI,CAAC0rB,cAAc,CAAC7sB,GAAG,CAACjQ,GAAG,CAAC;IAEnE,OAAOoR,IAAI,CAACyB,UAAU;EACxB;EAEAitB,iBAAiBA,CAAAA,EAAsC;IACrD,IAAID,QAAQ,GAAG,IAAI;IACnB,IAAI,IAAI,CAACvY,KAAK,CAAA,EAAA,CAAY,EAAE;MAC1BuY,QAAQ,GAAG,IAAI,CAACpqB,SAAS,EAAkB;MAC3C,IAAI,IAAI,CAACwC,KAAK,CAACnX,KAAK,KAAK,GAAG,EAAE;QAC5B++B,QAAQ,CAACh8B,IAAI,GAAG,MAAM;MACxB,CAAC,MAAM;QACLg8B,QAAQ,CAACh8B,IAAI,GAAG,OAAO;MACzB;MACA,IAAI,CAACmX,IAAI,EAAE;MACX,OAAO,IAAI,CAACrF,UAAU,CAACkqB,QAAQ,EAAE,UAAU,CAAC;IAC9C;IACA,OAAOA,QAAQ;EACjB;EAMA1qB,iBAAiBA,CACf/D,IAAgB,EAChBqyB,mBAAoC,EACpCpuB,QAAiB,GAAG,KAAK,EACnB;IACN,IAAIouB,mBAAmB,EAAE;MACvB,IAAI,CAACC,gCAAgC,CAACtyB,IAAI,EAAE,MAC1C,KAAK,CAAC+D,iBAAiB,CAAC/D,IAAI,EAAE,IAAI,EAAEiE,QAAQ,CAAC,CAC9C;MACD;IACF;IAEA,KAAK,CAACF,iBAAiB,CAAC/D,IAAI,EAAE,KAAK,EAAEiE,QAAQ,CAAC;EAChD;EAEAsuB,0BAA0BA,CAMxBvyB,IAAe,EAAE3N,IAAe,EAAE4R,QAAiB,GAAG,KAAK,EAAK;IAChE,IAAI,IAAI,CAACiS,KAAK,CAAA,EAAA,CAAU,EAAE;MACxB,MAAMiV,QAAQ,GAAG,IAAI,CAAC9mB,SAAS,EAAoB;MAEnD,CACE8mB,QAAQ,CAACO,cAAc,EAEvB1rB,IAAI,CAAC8qB,SAAS,CACf,GAAG,IAAI,CAACD,oCAAoC,EAAE;MAE/C7qB,IAAI,CAACyrB,UAAU,GAAGN,QAAQ,CAACO,cAAc,GACrC,IAAI,CAACnnB,UAAU,CAAC4mB,QAAQ,EAAE,gBAAgB,CAAC,GAC3C,IAAI;IACV;IAEA,OAAO,KAAK,CAACoH,0BAA0B,CAACvyB,IAAI,EAAE3N,IAAI,EAAE4R,QAAQ,CAAC;EAC/D;EAGAuuB,kBAAkBA,CAAChyB,KAAyB,EAAe;IAEzD,IAAI,IAAI,CAACqG,KAAK,CAACiC,MAAM,IAAI,IAAI,CAAC4Y,YAAY,CAAA,GAAA,CAAe,EAAE;MACzD,MAAM9I,SAAS,GAAG,IAAI,CAACA,SAAS,EAAE;MAClC,IAAI7rB,0BAA0B,CAAC6rB,SAAS,CAACvmB,IAAI,CAAC,EAAE;QAC9C,MAAM2N,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAmB;QAC9C,IAAI,CAACuF,IAAI,EAAE;QACX,OAAO,IAAI,CAACkkB,kBAAkB,CAAC9tB,IAAI,CAAC;MACtC;KACD,MAAM,IAAI,IAAI,CAACmqB,gBAAgB,EAAE,IAAI,IAAI,CAACzI,YAAY,CAAA,GAAA,CAAU,EAAE;MACjE,MAAM1hB,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAE;MAC7B,IAAI,CAACuF,IAAI,EAAE;MACX,OAAO,IAAI,CAAC6oB,wBAAwB,CAACzyB,IAAI,CAAC;IAC5C;IACA,MAAM6B,IAAI,GAAG,KAAK,CAAC2wB,kBAAkB,CAAChyB,KAAK,CAAC;IAE5C,IAAI,IAAI,CAACypB,UAAU,KAAKzqC,SAAS,IAAI,CAAC,IAAI,CAAC8iB,gBAAgB,CAACT,IAAI,CAAC,EAAE;MACjE,IAAI,CAACooB,UAAU,GAAG,IAAI;IACxB;IACA,OAAOpoB,IAAI;EACb;EAGA6wB,wBAAwBA,CACtB1yB,IAA2B,EAC3B2yB,IAAkB,EAClBhsB,UAAgC,EACT;IACvB,IAAIgsB,IAAI,CAACtgC,IAAI,KAAK,YAAY,EAAE;MAC9B,IAAIsgC,IAAI,CAACjwC,IAAI,KAAK,SAAS,EAAE;QAC3B,IACE,IAAI,CAACwzB,KAAK,CAAA,EAAA,CAAW,IACrBrpB,iBAAiB,CAAC,IAAI,CAACga,KAAK,CAACxU,IAAI,CAAC,IAClC,IAAI,CAAC6jB,KAAK,CAAA,EAAA,CAAc,IACxB,IAAI,CAACA,KAAK,CAAS,EAAA,CAAA,IACnB,IAAI,CAACA,KAAK,CAAA,EAAA,CAAY,EACtB;UAEA,OAAO,IAAI,CAACyV,gBAAgB,CAAC3rB,IAAI,CAAC;QACpC;MACD,CAAA,MAAM,IAAInT,iBAAiB,CAAC,IAAI,CAACga,KAAK,CAACxU,IAAI,CAAC,EAAE;QAC7C,IAAIsgC,IAAI,CAACjwC,IAAI,KAAK,WAAW,EAAE;UAE7B,OAAO,IAAI,CAACorC,kBAAkB,CAAC9tB,IAAI,CAAC;QACtC,CAAC,MAAM,IAAI2yB,IAAI,CAACjwC,IAAI,KAAK,MAAM,EAAE;UAE/B,OAAO,IAAI,CAACoqC,kBAAkB,CAAC9sB,IAAI,CAAC;QACtC,CAAC,MAAM,IAAI2yB,IAAI,CAACjwC,IAAI,KAAK,QAAQ,EAAE;UAEjC,OAAO,IAAI,CAACqqC,mBAAmB,CAAC/sB,IAAI,EAAE,KAAK,CAAC;QAC9C;MACF;IACF;IAEA,OAAO,KAAK,CAAC0yB,wBAAwB,CAAC1yB,IAAI,EAAE2yB,IAAI,EAAEhsB,UAAU,CAAC;EAC/D;EAGAisB,4BAA4BA,CAAAA,EAAY;IACtC,MAAM;MAAEvgC;KAAM,GAAG,IAAI,CAACwU,KAAK;IAC3B,IACEzZ,kCAAkC,CAACiF,IAAI,CAAC,IACvC,IAAI,CAAC83B,gBAAgB,EAAE,IAAI93B,IAAI,KAAA,GAAc,EAC9C;MACA,OAAO,CAAC,IAAI,CAACwU,KAAK,CAAC+M,WAAW;IAChC;IACA,OAAO,KAAK,CAACgf,4BAA4B,EAAE;EAC7C;EAEAC,wBAAwBA,CAAAA,EAAY;IAClC,MAAM;MAAExgC;KAAM,GAAG,IAAI,CAACwU,KAAK;IAC3B,IACEzZ,kCAAkC,CAACiF,IAAI,CAAC,IACvC,IAAI,CAAC83B,gBAAgB,EAAE,IAAI93B,IAAI,KAAA,GAAc,EAC9C;MACA,OAAO,IAAI,CAACwU,KAAK,CAAC+M,WAAW;IAC/B;IAEA,OAAO,KAAK,CAACif,wBAAwB,EAAE;EACzC;EAEAC,4BAA4BA,CAAAA,EAAiC;IAC3D,IAAI,IAAI,CAAC3I,gBAAgB,EAAE,IAAI,IAAI,CAACzI,YAAY,CAAA,GAAA,CAAU,EAAE;MAC1D,MAAM1hB,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAE;MAC7B,IAAI,CAACuF,IAAI,EAAE;MACX,OAAO,IAAI,CAAC6oB,wBAAwB,CAACzyB,IAAI,CAAC;IAC5C;IACA,OAAO,KAAK,CAAC8yB,4BAA4B,EAAE;EAC7C;EAEAC,gBAAgBA,CACdJ,IAAkB,EAElBztB,QAAkB,EAClBC,mBAA6C,EAC/B;IACd,IAAI,CAAC,IAAI,CAAC+Q,KAAK,CAAa,EAAA,CAAA,EAAE,OAAOyc,IAAI;IAEzC,IAAI,IAAI,CAAC9rB,KAAK,CAAC+L,sBAAsB,EAAE;MACrC,MAAMkP,MAAM,GAAG,IAAI,CAAC5I,iBAAiB,EAAE;MAIvC,IACE4I,MAAM,KAAoB,EAAA,IAC1BA,MAAM,KAAA,EAAuB,IAC7BA,MAAM,KAAoB,EAAA,IAC1BA,MAAM,KAAA,EAA+B,EACrC;QAEA,IAAI,CAACkR,0BAA0B,CAAC7tB,mBAAmB,CAAC;QACpD,OAAOwtB,IAAI;MACb;IACF;IAEA,IAAI,CAACnQ,MAAM,CAAa,EAAA,CAAA;IACxB,MAAM3b,KAAK,GAAG,IAAI,CAACA,KAAK,CAAC9H,KAAK,EAAE;IAChC,MAAMk0B,iBAAiB,GAAG,IAAI,CAACpsB,KAAK,CAAC6L,SAAS;IAC9C,MAAM1S,IAAI,GAAG,IAAI,CAACqlB,WAAW,CAACngB,QAAQ,CAAC;IACvC,IAAI;MAAEguB,UAAU;MAAEC;IAAO,CAAC,GAAG,IAAI,CAACC,6BAA6B,EAAE;IACjE,IAAI,CAACC,KAAK,EAAEtc,OAAO,CAAC,GAAG,IAAI,CAACuc,uBAAuB,CAACJ,UAAU,CAAC;IAE/D,IAAIC,MAAM,IAAIpc,OAAO,CAAC3oB,MAAM,GAAG,CAAC,EAAE;MAChC,MAAMskB,SAAS,GAAG,CAAC,GAAGugB,iBAAiB,CAAC;MAExC,IAAIlc,OAAO,CAAC3oB,MAAM,GAAG,CAAC,EAAE;QACtB,IAAI,CAACyY,KAAK,GAAGA,KAAK;QAClB,IAAI,CAACA,KAAK,CAAC6L,SAAS,GAAGA,SAAS;QAEhC,KAAK,IAAI9iB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGmnB,OAAO,CAAC3oB,MAAM,EAAEwB,CAAC,EAAE,EAAE;UACvC8iB,SAAS,CAACjvB,IAAI,CAACszB,OAAO,CAACnnB,CAAC,CAAC,CAACjB,KAAK,CAAC;QAClC;QAEA,CAAC;UAAEukC,UAAU;UAAEC;QAAO,CAAC,GAAG,IAAI,CAACC,6BAA6B,EAAE;QAC9D,CAACC,KAAK,EAAEtc,OAAO,CAAC,GAAG,IAAI,CAACuc,uBAAuB,CAACJ,UAAU,CAAC;MAC7D;MAEA,IAAIC,MAAM,IAAIE,KAAK,CAACjlC,MAAM,GAAG,CAAC,EAAE;QAM9B,IAAI,CAAC2X,KAAK,CAAC0f,UAAU,CAACC,yBAAyB,EAAE;UAC/CjgC,EAAE,EAAEohB,KAAK,CAAC3B;QACZ,CAAC,CAAC;MACJ;MAEA,IAAIiuB,MAAM,IAAIE,KAAK,CAACjlC,MAAM,KAAK,CAAC,EAAE;QAChC,IAAI,CAACyY,KAAK,GAAGA,KAAK;QAClB6L,SAAS,CAACjvB,IAAI,CAAC4vC,KAAK,CAAC,CAAC,CAAC,CAAC1kC,KAAK,CAAC;QAC9B,IAAI,CAACkY,KAAK,CAAC6L,SAAS,GAAGA,SAAS;QAChC,CAAC;UAAEwgB,UAAU;UAAEC;QAAO,CAAC,GAAG,IAAI,CAACC,6BAA6B,EAAE;MAChE;IACF;IAEA,IAAI,CAACE,uBAAuB,CAACJ,UAAU,EAAE,IAAI,CAAC;IAE9C,IAAI,CAACrsB,KAAK,CAAC6L,SAAS,GAAGugB,iBAAiB;IACxC,IAAI,CAACzQ,MAAM,CAAU,EAAA,CAAA;IAErBxiB,IAAI,CAAC0I,IAAI,GAAGiqB,IAAI;IAChB3yB,IAAI,CAACkzB,UAAU,GAAGA,UAAU;IAC5BlzB,IAAI,CAACuzB,SAAS,GAAG,IAAI,CAACjB,gCAAgC,CAACtyB,IAAI,EAAE,MAC3D,IAAI,CAACwzB,gBAAgB,CAACh0C,SAAS,EAAEA,SAAS,CAAC,CAC5C;IAED,OAAO,IAAI,CAAC+kB,UAAU,CAACvE,IAAI,EAAE,uBAAuB,CAAC;EACvD;EAEAozB,6BAA6BA,CAAAA,EAG3B;IACA,IAAI,CAACvsB,KAAK,CAAC8L,yBAAyB,CAAClvB,IAAI,CAAC,IAAI,CAACojB,KAAK,CAAClY,KAAK,CAAC;IAE3D,MAAMukC,UAAU,GAAG,IAAI,CAACO,uBAAuB,EAAE;IACjD,MAAMN,MAAM,GAAG,CAAC,IAAI,CAACjd,KAAK,CAAU,EAAA,CAAA;IAEpC,IAAI,CAACrP,KAAK,CAAC8L,yBAAyB,CAACzkB,GAAG,EAAE;IAE1C,OAAO;MAAEglC,UAAU;MAAEC;KAAQ;EAC/B;EASAG,uBAAuBA,CACrBtzB,IAAkB,EAClB0zB,eAAyB,EACmC;IAC5D,MAAMlV,KAAK,GAAG,CAACxe,IAAI,CAAC;IACpB,MAAM2zB,MAAmC,GAAG,EAAE;IAE9C,OAAOnV,KAAK,CAACpwB,MAAM,KAAK,CAAC,EAAE;MACzB,MAAM4R,IAAI,GAAGwe,KAAK,CAACtwB,GAAG,EAAE;MACxB,IAAI8R,IAAI,CAAC3N,IAAI,KAAK,yBAAyB,EAAE;QAC3C,IAAI2N,IAAI,CAACwD,cAAc,IAAI,CAACxD,IAAI,CAACyrB,UAAU,EAAE;UAG3C,IAAI,CAACmI,qBAAqB,CAAC5zB,IAAI,CAAC;QAClC,CAAC,MAAM;UAEL2zB,MAAM,CAAClwC,IAAI,CAACuc,IAAI,CAAC;QACnB;QACAwe,KAAK,CAAC/6B,IAAI,CAACuc,IAAI,CAACgD,IAAI,CAAC;MACvB,CAAC,MAAM,IAAIhD,IAAI,CAAC3N,IAAI,KAAK,uBAAuB,EAAE;QAChDmsB,KAAK,CAAC/6B,IAAI,CAACuc,IAAI,CAACkzB,UAAU,CAAC;QAC3B1U,KAAK,CAAC/6B,IAAI,CAACuc,IAAI,CAACuzB,SAAS,CAAC;MAC5B;IACF;IAEA,IAAIG,eAAe,EAAE;MACnBC,MAAM,CAACja,OAAO,CAAC1Z,IAAI,IAAI,IAAI,CAAC4zB,qBAAqB,CAAC5zB,IAAI,CAAC,CAAC;MACxD,OAAO,CAAC2zB,MAAM,EAAE,EAAE,CAAC;IACrB;IAEA,OAAOjK,SAAS,CAACiK,MAAM,EAAE3zB,IAAI,IAC3BA,IAAI,CAACqC,MAAM,CAACwxB,KAAK,CAAC7B,KAAK,IAAI,IAAI,CAACzsB,YAAY,CAACysB,KAAK,EAAE,IAAI,CAAC,CAAC,CAC3D;EACH;EAEA4B,qBAAqBA,CAAC5zB,IAA+B,EAAE;IAAA,IAAA8zB,WAAA;IACrD,IAAI,CAACC,gBAAgB,CAGnB/zB,IAAI,CAACqC,MAAM,GAAAyxB,WAAA,GACX9zB,IAAI,CAAC2B,KAAK,KAAVmyB,IAAAA,GAAAA,KAAAA,CAAAA,GAAAA,WAAA,CAAYE,gBAAgB,EAChB,KAAK,CAClB;IAED,IAAI,CAACzlB,KAAK,CAACF,KAAK,CAACnE,cAAc,GAAGC,WAAW,CAAC;IAE9C,KAAK,CAAC8pB,WAAW,CAACj0B,IAAI,EAAE,KAAK,EAAE,IAAI,CAAC;IACpC,IAAI,CAACuO,KAAK,CAACD,IAAI,EAAE;EACnB;EAEAgkB,gCAAgCA,CAC9BtyB,IAAoB,EACpBI,KAAc,EACX;IACH,IAAI8zB,MAAS;IACb,IAAI,IAAI,CAACrtB,KAAK,CAAC8L,yBAAyB,CAAC8E,OAAO,CAACzX,IAAI,CAACrR,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE;MACnE,IAAI,CAACkY,KAAK,CAAC8L,yBAAyB,CAAClvB,IAAI,CAAC,IAAI,CAACojB,KAAK,CAAClY,KAAK,CAAC;MAC3DulC,MAAM,GAAG9zB,KAAK,EAAE;MAChB,IAAI,CAACyG,KAAK,CAAC8L,yBAAyB,CAACzkB,GAAG,EAAE;IAC5C,CAAC,MAAM;MACLgmC,MAAM,GAAG9zB,KAAK,EAAE;IAClB;IAEA,OAAO8zB,MAAM;EACf;EAEAC,cAAcA,CACZn0B,IAAkB,EAElBkF,QAAkB,EACJ;IACdlF,IAAI,GAAG,KAAK,CAACm0B,cAAc,CAACn0B,IAAI,EAAEkF,QAAQ,CAAC;IAC3C,IAAI,IAAI,CAACuT,GAAG,CAAA,EAAA,CAAa,EAAE;MACzBzY,IAAI,CAACkG,QAAQ,GAAG,IAAI;MAIpB,IAAI,CAAC8B,gBAAgB,CAAChI,IAAI,CAAC;IAC7B;IAEA,IAAI,IAAI,CAACkW,KAAK,CAAA,EAAA,CAAU,EAAE;MACxB,MAAMke,YAAY,GAAG,IAAI,CAAC/O,WAAW,CAACngB,QAAQ,CAAC;MAC/CkvB,YAAY,CAAC3yB,UAAU,GAAGzB,IAAI;MAC9Bo0B,YAAY,CAAC1I,cAAc,GAAG,IAAI,CAACkB,uBAAuB,EAAE;MAE5D,OAAO,IAAI,CAACroB,UAAU,CAAC6vB,YAAY,EAAE,oBAAoB,CAAC;IAC5D;IAEA,OAAOp0B,IAAI;EACb;EAEAq0B,uBAAuBA,CAACr0B,IAAY,EAAE;IACpC,IACGA,IAAI,CAAC3N,IAAI,KAAK,mBAAmB,KAC/B2N,IAAI,CAACopB,UAAU,KAAK,MAAM,IAAIppB,IAAI,CAACopB,UAAU,KAAK,QAAQ,CAAC,IAC7DppB,IAAI,CAAC3N,IAAI,KAAK,wBAAwB,IACrC2N,IAAI,CAAC2sB,UAAU,KAAK,MAAO,IAC5B3sB,IAAI,CAAC3N,IAAI,KAAK,sBAAsB,IAAI2N,IAAI,CAAC2sB,UAAU,KAAK,MAAO,EACpE;MAGA;IACF;IAEA,KAAK,CAAC0H,uBAAuB,CAACr0B,IAAI,CAAC;EACrC;EAEA0G,WAAWA,CACT1G,IAA+D,EAC/D2G,UAAgC,EACnB;IACb,MAAM2tB,IAAI,GAAG,KAAK,CAAC5tB,WAAW,CAAC1G,IAAI,EAAE2G,UAAU,CAAC;IAChD,IACE2tB,IAAI,CAACjiC,IAAI,KAAK,wBAAwB,IACtCiiC,IAAI,CAACjiC,IAAI,KAAK,sBAAsB,EACpC;MACAiiC,IAAI,CAAC3H,UAAU,GAAG2H,IAAI,CAAC3H,UAAU,IAAI,OAAO;IAC9C;IACA,OAAO2H,IAAI;EACb;EAEAC,sBAAsBA,CACpBv0B,IAA8B,EACI;IAClC,IAAI,IAAI,CAAC0hB,YAAY,CAAA,GAAA,CAAU,EAAE;MAC/B1hB,IAAI,CAAC2sB,UAAU,GAAG,MAAM;MAExB,MAAM6H,eAAe,GAAG,IAAI,CAACnwB,SAAS,EAAE;MACxC,IAAI,CAACuF,IAAI,EAAE;MAEX,IAAI,IAAI,CAACsM,KAAK,CAAA,CAAA,CAAW,EAAE;QAEzBlW,IAAI,CAACgH,UAAU,GAAG,IAAI,CAACytB,qBAAqB,CACrB,IAAI,CAC1B;QACD,KAAK,CAACC,eAAe,CAAC10B,IAAI,CAAC;QAC3B,OAAO,IAAI;MACb,CAAC,MAAM;QAGL,OAAO,IAAI,CAAC8sB,kBAAkB,CAAC0H,eAAe,CAAC;MACjD;IACD,CAAA,MAAM,IAAI,IAAI,CAAC9S,YAAY,KAAY,EAAE;MACxC1hB,IAAI,CAAC2sB,UAAU,GAAG,MAAM;MAExB,MAAM6H,eAAe,GAAG,IAAI,CAACnwB,SAAS,EAAE;MACxC,IAAI,CAACuF,IAAI,EAAE;MAGX,OAAO,IAAI,CAACmjB,mBAAmB,CAACyH,eAAe,EAAE,KAAK,CAAC;IACxD,CAAA,MAAM,IAAI,IAAI,CAAC9S,YAAY,KAAe,EAAE;MAC3C1hB,IAAI,CAAC2sB,UAAU,GAAG,MAAM;MACxB,MAAM6H,eAAe,GAAG,IAAI,CAACnwB,SAAS,EAAE;MACxC,IAAI,CAACuF,IAAI,EAAE;MAEX,OAAO,IAAI,CAACkkB,kBAAkB,CAAC0G,eAAe,CAAC;KAChD,MAAM,IAAI,IAAI,CAACrK,gBAAgB,EAAE,IAAI,IAAI,CAACzI,YAAY,CAAA,GAAA,CAAU,EAAE;MACjE1hB,IAAI,CAAC2sB,UAAU,GAAG,OAAO;MACzB,MAAM6H,eAAe,GAAG,IAAI,CAACnwB,SAAS,EAAE;MACxC,IAAI,CAACuF,IAAI,EAAE;MAEX,OAAO,IAAI,CAAC6oB,wBAAwB,CAAC+B,eAAe,CAAC;IACvD,CAAC,MAAM;MACL,OAAO,KAAK,CAACD,sBAAsB,CAACv0B,IAAI,CAAC;IAC3C;EACF;EAEA20B,aAAaA,CAAC30B,IAAY,EAAW;IACnC,IAAI,KAAK,CAAC20B,aAAa,CAAC30B,IAAI,CAAC,EAAE,OAAO,IAAI;IAE1C,IAAI,IAAI,CAAC0hB,YAAY,CAAA,GAAA,CAAU,IAAI,IAAI,CAAC9I,SAAS,EAAE,CAACvmB,IAAI,KAAA,EAAY,EAAE;MACpE2N,IAAI,CAAC2sB,UAAU,GAAG,MAAM;MACxB,IAAI,CAAC/iB,IAAI,EAAE;MACX,IAAI,CAACA,IAAI,EAAE;MACX,OAAO,IAAI;IACb;IAEA,OAAO,KAAK;EACd;EAEAgrB,kCAAkCA,CAAC50B,IAAY,EAAW;IACxD,MAAM;MAAEkF;KAAU,GAAG,IAAI,CAAC2B,KAAK;IAC/B,MAAMguB,YAAY,GAAG,KAAK,CAACD,kCAAkC,CAAC50B,IAAI,CAAC;IACnE,IAAI60B,YAAY,IAAI70B,IAAI,CAAC2sB,UAAU,KAAK,MAAM,EAAE;MAC9C,IAAI,CAACx1B,UAAU,CAAC+N,QAAQ,CAAC;IAC3B;IACA,OAAO2vB,YAAY;EACrB;EAEAC,YAAYA,CACV90B,IAAa,EACb+0B,WAAoB,EACpBC,UAA2B,EAC3B;IACA,KAAK,CAACF,YAAY,CAAC90B,IAAI,EAAE+0B,WAAW,EAAEC,UAAU,CAAC;IACjD,IAAI,IAAI,CAAC9e,KAAK,CAAA,EAAA,CAAO,EAAE;MACrBlW,IAAI,CAACwD,cAAc,GAAG,IAAI,CAAC6nB,iCAAiC,EAAE;IAChE;EACF;EAEA4J,gBAAgBA,CACd9xB,SAAsB,EACtB+xB,MAAW,EACXruB,KAA8B,EACxB;IACN,MAAM;MAAE3B;KAAU,GAAG,IAAI,CAAC2B,KAAK;IAC/B,IAAI,IAAI,CAAC6a,YAAY,CAAA,GAAA,CAAa,EAAE;MAClC,IAAI,KAAK,CAACyT,4BAA4B,CAAChyB,SAAS,EAAE+xB,MAAM,CAAC,EAAE;QAEzD;MACF;MAEAA,MAAM,CAAC/G,OAAO,GAAG,IAAI;IACvB;IAEA,KAAK,CAAC8G,gBAAgB,CAAC9xB,SAAS,EAAE+xB,MAAM,EAAEruB,KAAK,CAAC;IAEhD,IAAIquB,MAAM,CAAC/G,OAAO,EAAE;MAClB,IACE+G,MAAM,CAAC7iC,IAAI,KAAK,eAAe,IAC/B6iC,MAAM,CAAC7iC,IAAI,KAAK,sBAAsB,IACtC6iC,MAAM,CAAC7iC,IAAI,KAAK,oBAAoB,EACpC;QACA,IAAI,CAAC0T,KAAK,CAAC0f,UAAU,CAACK,mBAAmB,EAAE;UAAErgC,EAAE,EAAEyf;QAAS,CAAC,CAAC;MAC9D,CAAC,MAAM,IAAIgwB,MAAM,CAACxlC,KAAK,EAAE;QACvB,IAAI,CAACqW,KAAK,CAAC0f,UAAU,CAACM,4BAA4B,EAAE;UAClDtgC,EAAE,EAAEyvC,MAAM,CAACxlC;QACb,CAAC,CAAC;MACJ;IACF;EACF;EAEA0lC,UAAUA,CAACjsB,IAAY,EAAW;IAChC,OAAOA,IAAI,KAAK,UAAU,IAAIA,IAAI,KAAK,eAAe;EACxD;EAEAksB,YAAYA,CAAAA,EAAS;IACnB,MAAMlsB,IAAI,GAAG,KAAK,CAACyR,SAAS,EAAE;IAC9B,MAAM0a,QAAQ,GAAG,IAAI,GAAGnsB,IAAI;IAG5B,IAAI,CAAC,IAAI,CAACisB,UAAU,CAACjsB,IAAI,CAAC,IAAI,CAAC,IAAI,CAACtC,KAAK,CAACgM,MAAM,EAAE;MAChD,IAAI,CAAC9M,KAAK,CAAClG,MAAM,CAACjJ,iBAAiB,EAAE;QACnCnR,EAAE,EAAE,IAAI,CAACohB,KAAK,CAACoN,WAAW,EAAE;QAC5BnlB,cAAc,EAAEwmC;MAClB,CAAC,CAAC;IACJ;IAEA,IAAI,CAACxb,WAAW,CAAUwb,GAAAA,EAAAA,QAAQ,CAAC;EACrC;EAGAvb,gBAAgBA,CAACppB,IAAY,EAAQ;IACnC,MAAMiZ,IAAI,GAAG,IAAI,CAAC6H,KAAK,CAACC,UAAU,CAAC,IAAI,CAAC7K,KAAK,CAAC5H,GAAG,GAAG,CAAC,CAAC;IACtD,IAAItO,IAAI,KAAA,GAA6B,IAAIiZ,IAAI,QAA0B,EAAE;MACvE,IAAI,CAACiR,QAAQ,CAAe,CAAA,EAAA,CAAC,CAAC;IAChC,CAAC,MAAM,IACL,IAAI,CAAChU,KAAK,CAACgM,MAAM,KAChBliB,IAAI,KAA0B,EAAA,IAAIA,IAAI,KAAA,EAAuB,CAAC,EAC/D;MACA,IAAI,CAACkqB,QAAQ,CAAClqB,IAAI,OAA0B,GAAgB,EAAA,GAAA,EAAA,EAAE,CAAC,CAAC;IACjE,CAAA,MAAM,IAAI,IAAI,CAACkW,KAAK,CAACgM,MAAM,IAAIliB,IAAI,KAAA,EAA2B,EAAE;MAC/D,IAAIiZ,IAAI,OAAkB,EAAE;QAC1B,IAAI,CAACiR,QAAQ,CAAiB,EAAA,EAAA,CAAC,CAAC;MAClC,CAAC,MAAM;QAEL,IAAI,CAACA,QAAQ,CAAc,EAAA,EAAA,CAAC,CAAC;MAC/B;IACD,CAAA,MAAM,IACLnR,eAAe,CAAC/Y,IAAI,EAAEiZ,IAAI,EAAE,IAAI,CAAC6H,KAAK,CAACC,UAAU,CAAC,IAAI,CAAC7K,KAAK,CAAC5H,GAAG,GAAG,CAAC,CAAC,CAAC,EACtE;MACA,IAAI,CAAC4H,KAAK,CAAC5H,GAAG,IAAI,CAAC;MACnB,IAAI,CAACo2B,YAAY,EAAE;IACrB,CAAC,MAAM;MACL,KAAK,CAACtb,gBAAgB,CAACppB,IAAI,CAAC;IAC9B;EACF;EAEA4U,YAAYA,CAACvF,IAAY,EAAEwF,SAAmB,EAAW;IACvD,IAAIxF,IAAI,CAAC3N,IAAI,KAAK,oBAAoB,EAAE;MACtC,OAAO,IAAI,CAACkT,YAAY,CAACvF,IAAI,CAACyB,UAAU,EAAE+D,SAAS,CAAC;IACtD,CAAC,MAAM;MACL,OAAO,KAAK,CAACD,YAAY,CAACvF,IAAI,EAAEwF,SAAS,CAAC;IAC5C;EACF;EAEAC,YAAYA,CAACzF,IAAY,EAAE0F,KAAc,GAAG,KAAK,EAAQ;IACvD,IACE,CAACA,KAAK,IACN1F,IAAI,CAAC3N,IAAI,KAAK,sBAAsB,IACpC2N,IAAI,CAACu1B,IAAI,CAACljC,IAAI,KAAK,oBAAoB,EACvC;MACA2N,IAAI,CAACu1B,IAAI,GAAG,IAAI,CAACnD,mBAAmB,CAACpyB,IAAI,CAACu1B,IAAI,CAAC;IACjD;IACA,KAAK,CAAC9vB,YAAY,CAACzF,IAAI,EAAE0F,KAAK,CAAC;EACjC;EAGAquB,gBAAgBA,CACdyB,QAAwB,EACxBxB,gBAA6C,EAC7CtuB,KAAc,EACR;IACN,KAAK,IAAI9V,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG4lC,QAAQ,CAACpnC,MAAM,EAAEwB,CAAC,EAAE,EAAE;MACxC,MAAM+iC,IAAI,GAAG6C,QAAQ,CAAC5lC,CAAC,CAAC;MACxB,IAAI,CAAA+iC,IAAI,IAAJA,IAAAA,GAAAA,KAAAA,CAAAA,GAAAA,IAAI,CAAEtgC,IAAI,MAAK,oBAAoB,EAAE;QACvCmjC,QAAQ,CAAC5lC,CAAC,CAAC,GAAG,IAAI,CAACwiC,mBAAmB,CAACO,IAAI,CAAC;MAC9C;IACF;IACA,KAAK,CAACoB,gBAAgB,CAACyB,QAAQ,EAAExB,gBAAgB,EAAEtuB,KAAK,CAAC;EAC3D;EAIA+vB,gBAAgBA,CACdD,QAAwD,EACxDE,mBAA6B,EACmB;IAChD,KAAK,IAAI9lC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG4lC,QAAQ,CAACpnC,MAAM,EAAEwB,CAAC,EAAE,EAAE;MAAA,IAAA+lC,WAAA;MACxC,MAAMhD,IAAI,GAAG6C,QAAQ,CAAC5lC,CAAC,CAAC;MACxB,IACE+iC,IAAI,IACJA,IAAI,CAACtgC,IAAI,KAAK,oBAAoB,IAClC,EAAAsjC,CAAAA,WAAA,GAAChD,IAAI,CAAChxB,KAAK,KAAVg0B,IAAAA,IAAAA,WAAA,CAAYnzB,aAAa,CACzBgzB,KAAAA,QAAQ,CAACpnC,MAAM,GAAG,CAAC,IAAI,CAACsnC,mBAAmB,CAAC,EAC7C;QACA,IAAI,CAAC3vB,KAAK,CAAC0f,UAAU,CAAC2C,iBAAiB,EAAE;UACvC3iC,EAAE,EAAEktC,IAAI,CAACjH;QACX,CAAC,CAAC;MACJ;IACF;IAEA,OAAO8J,QAAQ;EACjB;EAEAI,cAAcA,CACZC,KAAgB,EAChBC,YAAqB,EACrBC,OAAgB,EAChB5wB,mBAA6C,EACN;IACvC,MAAMnF,IAAI,GAAG,KAAK,CAAC41B,cAAc,CAC/BC,KAAK,EACLC,YAAY,EACZC,OAAO,EACP5wB,mBAAmB,CACpB;IAOD,IAAI2wB,YAAY,IAAI,CAAC,IAAI,CAACjvB,KAAK,CAAC+L,sBAAsB,EAAE;MACtD,IAAI,CAAC6iB,gBAAgB,CAACz1B,IAAI,CAACuQ,QAAQ,CAAC;IACtC;IAEA,OAAOvQ,IAAI;EACb;EAEAoF,WAAWA,CAAC/S,IAAY,EAAE2jC,eAAwB,EAAE1wB,OAAqB,EAAE;IACzE,OACEjT,IAAI,KAAK,oBAAoB,IAC7B,KAAK,CAAC+S,WAAW,CAAC/S,IAAI,EAAE2jC,eAAe,EAAE1wB,OAAO,CAAC;EAErD;EAGAd,kBAAkBA,CAACxE,IAAqB,EAAmB;IACzD,IAAI,IAAI,CAACkW,KAAK,CAAA,EAAA,CAAU,EAAE;MAExBlW,IAAI,CAAC0rB,cAAc,GAAG,IAAI,CAACkB,uBAAuB,EAAE;IACtD;IACA,OAAO,KAAK,CAACpoB,kBAAkB,CAACxE,IAAI,CAAC;EACvC;EAEA2E,yBAAyBA,CACvB3E,IAA4B,EACJ;IACxB,IAAI,IAAI,CAACkW,KAAK,CAAA,EAAA,CAAU,EAAE;MAExBlW,IAAI,CAAC0rB,cAAc,GAAG,IAAI,CAACkB,uBAAuB,EAAE;IACtD;IACA,OAAO,KAAK,CAACjoB,yBAAyB,CAAC3E,IAAI,CAAC;EAC9C;EAGAi2B,aAAaA,CAAAA,EAAY;IACvB,OAAO,IAAI,CAAC/f,KAAK,CAAA,EAAA,CAAO,IAAI,KAAK,CAAC+f,aAAa,EAAE;EACnD;EAGAC,eAAeA,CAAAA,EAAY;IACzB,OAAO,IAAI,CAAChgB,KAAK,CAAA,EAAA,CAAU,IAAI,KAAK,CAACggB,eAAe,EAAE;EACxD;EAEAC,sBAAsBA,CAAC/zB,MAAuC,EAAW;IACvE,OAAO,CAAC,IAAI,CAAC8T,KAAK,CAAA,EAAA,CAAU,IAAI,KAAK,CAACigB,sBAAsB,CAAC/zB,MAAM,CAAC;EACtE;EAGAc,eAAeA,CACbC,SAAsB,EACtBf,MAAqB,EACrBgB,WAAoB,EACpBpB,OAAgB,EAChBqB,aAAsB,EACtBC,iBAA0B,EACpB;IACN,IAAKlB,MAAM,CAASqsB,QAAQ,EAAE;MAC5B,IAAI,CAACt3B,UAAU,CAAEiL,MAAM,CAASqsB,QAAQ,CAAC5vB,GAAG,CAAClQ,KAAK,CAAC;IACrD;IACA,OAAQyT,MAAM,CAASqsB,QAAQ;IAC/B,IAAI,IAAI,CAACvY,KAAK,CAAA,EAAA,CAAO,EAAE;MACrB9T,MAAM,CAACoB,cAAc,GAAG,IAAI,CAAC6nB,iCAAiC,EAAE;IAClE;IAEA,KAAK,CAACnoB,eAAe,CACnBC,SAAS,EACTf,MAAM,EACNgB,WAAW,EACXpB,OAAO,EACPqB,aAAa,EACbC,iBAAiB,CAClB;IAED,IAAIlB,MAAM,CAACC,MAAM,IAAIgB,aAAa,EAAE;MAClC,MAAMhB,MAAM,GAAGD,MAAM,CAACC,MAAM;MAC5B,IAAIA,MAAM,CAACjU,MAAM,GAAG,CAAC,IAAI,IAAI,CAACgoC,WAAW,CAAC/zB,MAAM,CAAC,CAAC,CAAC,CAAC,EAAE;QACpD,IAAI,CAAC0D,KAAK,CAAC0f,UAAU,CAACsC,4BAA4B,EAAE;UAAEtiC,EAAE,EAAE2c;QAAO,CAAC,CAAC;MACrE;IAEF,CAAC,MAAM,IAELA,MAAM,CAAC/P,IAAI,KAAK,kBAAkB,IAClCgR,aAAa,IAEbjB,MAAM,CAAC1S,KAAK,CAAC2S,MAAM,EACnB;MAEA,MAAMA,MAAM,GAAGD,MAAM,CAAC1S,KAAK,CAAC2S,MAAM;MAClC,IAAIA,MAAM,CAACjU,MAAM,GAAG,CAAC,IAAI,IAAI,CAACgoC,WAAW,CAAC/zB,MAAM,CAAC,CAAC,CAAC,CAAC,EAAE;QACpD,IAAI,CAAC0D,KAAK,CAAC0f,UAAU,CAACsC,4BAA4B,EAAE;UAAEtiC,EAAE,EAAE2c;QAAO,CAAC,CAAC;MACrE;IACF;EACF;EAEAi0B,sBAAsBA,CACpBlzB,SAAsB,EACtBf,MAA4B,EAC5BgB,WAAoB,EACpBpB,OAAgB,EACV;IACN,IAAKI,MAAM,CAASqsB,QAAQ,EAAE;MAC5B,IAAI,CAACt3B,UAAU,CAAEiL,MAAM,CAASqsB,QAAQ,CAAC5vB,GAAG,CAAClQ,KAAK,CAAC;IACrD;IACA,OAAQyT,MAAM,CAASqsB,QAAQ;IAC/B,IAAI,IAAI,CAACvY,KAAK,CAAA,EAAA,CAAO,EAAE;MACrB9T,MAAM,CAACoB,cAAc,GAAG,IAAI,CAAC6nB,iCAAiC,EAAE;IAClE;IAEA,KAAK,CAACgL,sBAAsB,CAAClzB,SAAS,EAAEf,MAAM,EAAEgB,WAAW,EAAEpB,OAAO,CAAC;EACvE;EAGAs0B,eAAeA,CAACt2B,IAAa,EAAQ;IACnC,KAAK,CAACs2B,eAAe,CAACt2B,IAAI,CAAC;IAC3B,IAAIA,IAAI,CAACE,UAAU,IAAI,IAAI,CAACgW,KAAK,IAAO,EAAE;MACxClW,IAAI,CAACu2B,mBAAmB,GAAG,IAAI,CAAC1I,mCAAmC,EAAE;IACvE;IACA,IAAI,IAAI,CAACnM,YAAY,CAAA,GAAA,CAAgB,EAAE;MACrC,IAAI,CAAC9X,IAAI,EAAE;MACX,MAAM4sB,WAAoC,GAAIx2B,IAAI,CAACmtB,UAAU,GAAG,EAAG;MACnE,GAAG;QACD,MAAMntB,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAE;QAC7BrE,IAAI,CAAC6D,EAAE,GAAG,IAAI,CAACopB,6BAA6B,CAAa,IAAI,CAAC;QAC9D,IAAI,IAAI,CAAC/W,KAAK,CAAA,EAAA,CAAO,EAAE;UACrBlW,IAAI,CAACwD,cAAc,GAAG,IAAI,CAACqqB,mCAAmC,EAAE;QAClE,CAAC,MAAM;UACL7tB,IAAI,CAACwD,cAAc,GAAG,IAAI;QAC5B;QACAgzB,WAAW,CAAC/yC,IAAI,CAAC,IAAI,CAAC8gB,UAAU,CAACvE,IAAI,EAAE,iBAAiB,CAAC,CAAC;MAC5D,CAAC,QAAQ,IAAI,CAACyY,GAAG,CAAU,EAAA,CAAA;IAC7B;EACF;EAEAge,uBAAuBA,CAACr0B,MAAsC,EAAQ;IACpE,KAAK,CAACq0B,uBAAuB,CAACr0B,MAAM,CAAC;IACrC,MAAMC,MAAM,GAAG,IAAI,CAACF,4BAA4B,CAACC,MAAM,CAAC;IACxD,IAAIC,MAAM,CAACjU,MAAM,GAAG,CAAC,EAAE;MACrB,MAAM4jC,KAAK,GAAG3vB,MAAM,CAAC,CAAC,CAAC;MACvB,IAAI,IAAI,CAAC+zB,WAAW,CAACpE,KAAK,CAAC,IAAI5vB,MAAM,CAAC3P,IAAI,KAAK,KAAK,EAAE;QACpD,IAAI,CAACsT,KAAK,CAAC0f,UAAU,CAACwB,yBAAyB,EAAE;UAAExhC,EAAE,EAAEusC;QAAM,CAAC,CAAC;MAChE,CAAA,MAAM,IAAI,IAAI,CAACoE,WAAW,CAACpE,KAAK,CAAC,EAAE;QAClC,IAAI,CAACjsB,KAAK,CAAC0f,UAAU,CAACmC,yBAAyB,EAAE;UAAEniC,EAAE,EAAEusC;QAAM,CAAC,CAAC;MACjE;IACF;EACF;EAEA0E,+BAA+BA,CAC7B12B,IAA2C,EACrC;IACNA,IAAI,CAACyuB,QAAQ,GAAG,IAAI,CAACC,iBAAiB,EAAE;EAC1C;EAGAiI,iBAAiBA,CACf9xB,IAA+C,EAC/CK,QAAqC,EACrC9B,WAAoB,EACpBpB,OAAgB,EAChB8C,SAAkB,EAClBC,UAAmB,EACnBI,mBAA6C,EACV;IACnC,IAAKN,IAAI,CAAS4pB,QAAQ,EAAE;MAC1B,IAAI,CAACt3B,UAAU,CAAE0N,IAAI,CAAS4pB,QAAQ,CAAC5vB,GAAG,CAAClQ,KAAK,CAAC;IACnD;IACA,OAAQkW,IAAI,CAAS4pB,QAAQ;IAE7B,IAAIjrB,cAAc;IAGlB,IAAI,IAAI,CAAC0S,KAAK,IAAO,IAAI,CAACnR,UAAU,EAAE;MACpCvB,cAAc,GAAG,IAAI,CAAC6nB,iCAAiC,EAAE;MACzD,IAAI,CAAC,IAAI,CAACnV,KAAK,IAAW,EAAE,IAAI,CAAC/e,UAAU,EAAE;IAC/C;IAEA,MAAM+8B,MAAM,GAAG,KAAK,CAACyC,iBAAiB,CACpC9xB,IAAI,EACJK,QAAQ,EACR9B,WAAW,EACXpB,OAAO,EACP8C,SAAS,EACTC,UAAU,EACVI,mBAAmB,CACpB;IAGD,IAAI3B,cAAc,EAAE;MAClB,CAAC0wB,MAAM,CAACxkC,KAAK,IAAIwkC,MAAM,EAAE1wB,cAAc,GAAGA,cAAc;IAC1D;IACA,OAAO0wB,MAAM;EACf;EAEA0C,4BAA4BA,CAAC5E,KAAgB,EAAa;IACxD,IAAI,IAAI,CAACvZ,GAAG,CAAA,EAAA,CAAa,EAAE;MACzB,IAAIuZ,KAAK,CAAC3/B,IAAI,KAAK,YAAY,EAAE;QAC/B,IAAI,CAAC0T,KAAK,CAAC0f,UAAU,CAACkC,iBAAiB,EAAE;UAAEliC,EAAE,EAAEusC;QAAM,CAAC,CAAC;MACzD;MACA,IAAI,IAAI,CAACoE,WAAW,CAACpE,KAAK,CAAC,EAAE;QAC3B,IAAI,CAACjsB,KAAK,CAAC0f,UAAU,CAACuC,yBAAyB,EAAE;UAAEviC,EAAE,EAAEusC;QAAM,CAAC,CAAC;MACjE;MAECA,KAAK,CAAyB9rB,QAAQ,GAAG,IAAI;IAChD;IACA,IAAI,IAAI,CAACgQ,KAAK,CAAA,EAAA,CAAU,EAAE;MAExB8b,KAAK,CAACtG,cAAc,GAAG,IAAI,CAACkB,uBAAuB,EAAE;IACtD,CAAA,MAAM,IAAI,IAAI,CAACwJ,WAAW,CAACpE,KAAK,CAAC,EAAE;MAClC,IAAI,CAACjsB,KAAK,CAAC0f,UAAU,CAACqC,2BAA2B,EAAE;QAAEriC,EAAE,EAAEusC;MAAM,CAAC,CAAC;IACnE;IAEA,IAAI,IAAI,CAAC9b,KAAK,CAAO,EAAA,CAAA,IAAI,IAAI,CAACkgB,WAAW,CAACpE,KAAK,CAAC,EAAE;MAChD,IAAI,CAACjsB,KAAK,CAAC0f,UAAU,CAACyC,kBAAkB,EAAE;QAAEziC,EAAE,EAAEusC;MAAM,CAAC,CAAC;IAC1D;IAEA,IAAI,CAAChqB,gBAAgB,CAACgqB,KAAK,CAAC;IAC5B,OAAOA,KAAK;EACd;EAEA6E,iBAAiBA,CACf3xB,QAA0B,EAC1BqwB,IAAuB,EACZ;IACX,MAAMv1B,IAAI,GAAG,KAAK,CAAC62B,iBAAiB,CAAC3xB,QAAQ,EAAEqwB,IAAI,CAAC;IAEpD,IACEv1B,IAAI,CAAC3N,IAAI,KAAK,mBAAmB,IACjC2N,IAAI,CAAC0rB,cAAc,IACnB1rB,IAAI,CAACkuB,KAAK,CAACv/B,KAAK,GAAGqR,IAAI,CAAC0rB,cAAc,CAAC/8B,KAAK,EAC5C;MACA,IAAI,CAACoX,KAAK,CAAC0f,UAAU,CAAC0C,qBAAqB,EAAE;QAC3C1iC,EAAE,EAAEua,IAAI,CAAC0rB;MACX,CAAC,CAAC;IACJ;IAEA,OAAO1rB,IAAI;EACb;EAEA82B,wBAAwBA,CAAC92B,IAAyB,EAAW;IAC3D,IAAI,CAACmpB,iBAAiB,CAACnpB,IAAI,CAAC,EAAE;MAC5B,OAAO,KAAK,CAAC82B,wBAAwB,CAAC92B,IAAI,CAAC;IAC7C;IAEA,OAAOqpB,oBAAoB,CAAC,IAAI,CAACxiB,KAAK,CAACxU,IAAI,CAAC;EAC9C;EAEA0kC,qBAAqBA,CAAC/2B,IAAiC,EAAE;IACvD,KAAK,CAAC+2B,qBAAqB,CAAC/2B,IAAI,CAAC;IACjC,IAAIA,IAAI,CAACg3B,MAAM,IAAIh3B,IAAI,CAACopB,UAAU,KAAK,OAAO,EAAE;MAC9C,IAAI,CAACrjB,KAAK,CAAC0f,UAAU,CAACyB,6BAA6B,EAAE;QACnDzhC,EAAE,EAAEua,IAAI,CAACgH,UAAU,CAAC,CAAC,CAAC,CAACnI,GAAG,CAAClQ;MAC7B,CAAC,CAAC;IACJ;EACF;EAEAsoC,yBAAyBA,CAKvBj3B,IAAyB,EAAEk3B,SAAoB,EAAE7kC,IAAe,EAAQ;IACxE6kC,SAAS,CAACC,KAAK,GAAGhO,iBAAiB,CAACnpB,IAAI,CAAC,GACrC,IAAI,CAACitB,6BAA6B,CAClB,IAAI,EACA,IAAI,CACvB,GACD,IAAI,CAAC/B,eAAe,EAAE;IAE1BlrB,IAAI,CAACgH,UAAU,CAACvjB,IAAI,CAAC,IAAI,CAAC2zC,qBAAqB,CAACF,SAAS,EAAE7kC,IAAI,CAAC,CAAC;EACnE;EAGAglC,gCAAgCA,CAACr3B,IAAyB,EAAW;IACnEA,IAAI,CAACopB,UAAU,GAAG,OAAO;IAEzB,IAAI32B,IAAI,GAAG,IAAI;IACf,IAAI,IAAI,CAACyjB,KAAK,CAAA,EAAA,CAAY,EAAE;MAC1BzjB,IAAI,GAAG,QAAiB;IACzB,CAAA,MAAM,IAAI,IAAI,CAACivB,YAAY,KAAU,EAAE;MACtCjvB,IAAI,GAAG,MAAe;IACxB;IACA,IAAIA,IAAI,EAAE;MACR,MAAM0+B,EAAE,GAAG,IAAI,CAACvY,SAAS,EAAE;MAC3B,MAAM;QAAEvmB;MAAM,CAAA,GAAG8+B,EAAE;MAGnB,IAAI1+B,IAAI,KAAK,MAAM,IAAIJ,IAAI,OAAY,EAAE;QAEvC,IAAI,CAAC8E,UAAU,CAAC,IAAI,EAAEg6B,EAAE,CAAC9+B,IAAI,CAAC;MAChC;MAEA,IACEg3B,oBAAoB,CAACh3B,IAAI,CAAC,IAC1BA,IAAI,KAAc,CAAA,IAClBA,IAAI,KAAA,EAAY,EAChB;QACA,IAAI,CAACuX,IAAI,EAAE;QACX5J,IAAI,CAACopB,UAAU,GAAG32B,IAAI;MACxB;IACF;IAEA,OAAO,KAAK,CAAC4kC,gCAAgC,CAACr3B,IAAI,CAAC;EACrD;EAGAs3B,oBAAoBA,CAClBJ,SAAc,EACdK,gBAAyB,EACzBC,kBAA2B,EAE3BC,eAAwB,EAExBhpB,WAAqC,EAClB;IACnB,MAAMipB,UAAU,GAAGR,SAAS,CAACS,QAAQ;IAErC,IAAIC,iBAAiB,GAAG,IAAI;IAC5B,IAAIF,UAAU,CAACrlC,IAAI,KAAK,YAAY,EAAE;MACpC,IAAIqlC,UAAU,CAACh1C,IAAI,KAAK,MAAM,EAAE;QAC9Bk1C,iBAAiB,GAAG,MAAM;MAC5B,CAAC,MAAM,IAAIF,UAAU,CAACh1C,IAAI,KAAK,QAAQ,EAAE;QACvCk1C,iBAAiB,GAAG,QAAQ;MAC9B;IACF;IAEA,IAAIpyB,SAAS,GAAG,KAAK;IACrB,IAAI,IAAI,CAACkc,YAAY,CAAA,EAAA,CAAQ,IAAI,CAAC,IAAI,CAACK,qBAAqB,CAAC,IAAI,CAAC,EAAE;MAClE,MAAM8V,QAAQ,GAAG,IAAI,CAAC3M,eAAe,CAAC,IAAI,CAAC;MAC3C,IACE0M,iBAAiB,KAAK,IAAI,IAC1B,CAAC7qC,0BAA0B,CAAC,IAAI,CAAC8Z,KAAK,CAACxU,IAAI,CAAC,EAC5C;QAEA6kC,SAAS,CAACS,QAAQ,GAAGE,QAAQ;QAC7BX,SAAS,CAAC9N,UAAU,GAAGwO,iBAAiB;QACxCV,SAAS,CAACC,KAAK,GAAGpS,eAAe,CAAC8S,QAAQ,CAAC;MAC7C,CAAC,MAAM;QAELX,SAAS,CAACS,QAAQ,GAAGD,UAAU;QAC/BR,SAAS,CAAC9N,UAAU,GAAG,IAAI;QAC3B8N,SAAS,CAACC,KAAK,GAAG,IAAI,CAACjM,eAAe,EAAE;MAC1C;IACF,CAAC,MAAM;MACL,IACE0M,iBAAiB,KAAK,IAAI,IAC1B7qC,0BAA0B,CAAC,IAAI,CAAC8Z,KAAK,CAACxU,IAAI,CAAC,EAC3C;QAEA6kC,SAAS,CAACS,QAAQ,GAAG,IAAI,CAACzM,eAAe,CAAC,IAAI,CAAC;QAC/CgM,SAAS,CAAC9N,UAAU,GAAGwO,iBAAiB;MAC1C,CAAC,MAAM;QACL,IAAIL,gBAAgB,EAAE;UAEpB,MAAM,IAAI,CAACxxB,KAAK,CAAClG,MAAM,CAACtK,qBAAqB,EAAE;YAC7C9P,EAAE,EAAEyxC,SAAS;YACb1hC,UAAU,EAAEkiC,UAAU,CAAChoC;UACzB,CAAC,CAAC;QACJ;QAEAwnC,SAAS,CAACS,QAAQ,GAAGD,UAAU;QAC/BR,SAAS,CAAC9N,UAAU,GAAG,IAAI;MAC7B;MAEA,IAAI,IAAI,CAACpH,aAAa,CAAA,EAAA,CAAQ,EAAE;QAC9BkV,SAAS,CAACC,KAAK,GAAG,IAAI,CAACjM,eAAe,EAAE;MAC1C,CAAC,MAAM;QACL1lB,SAAS,GAAG,IAAI;QAChB0xB,SAAS,CAACC,KAAK,GAAGpS,eAAe,CAACmS,SAAS,CAACS,QAAQ,CAAC;MACvD;IACF;IAEA,MAAMG,qBAAqB,GAAG3O,iBAAiB,CAAC+N,SAAS,CAAC;IAE1D,IAAIM,kBAAkB,IAAIM,qBAAqB,EAAE;MAC/C,IAAI,CAAC/xB,KAAK,CAAC0f,UAAU,CAAC0B,mCAAmC,EAAE;QACzD1hC,EAAE,EAAEyxC;MACN,CAAC,CAAC;IACJ;IAEA,IAAIM,kBAAkB,IAAIM,qBAAqB,EAAE;MAC/C,IAAI,CAAC9J,iBAAiB,CACpBkJ,SAAS,CAACC,KAAK,CAACz0C,IAAI,EACpBw0C,SAAS,CAACC,KAAK,CAACt4B,GAAG,CAAClQ,KAAK,EACP,IAAI,CACvB;IACH;IAEA,IAAI6W,SAAS,IAAI,CAACgyB,kBAAkB,IAAI,CAACM,qBAAqB,EAAE;MAC9D,IAAI,CAACC,iBAAiB,CACpBb,SAAS,CAACC,KAAK,CAACz0C,IAAI,EACpBw0C,SAAS,CAACr4B,GAAG,CAAClQ,KAAK,EACnB,IAAI,EACJ,IAAI,CACL;IACH;IAEA,OAAO,IAAI,CAACyoC,qBAAqB,CAACF,SAAS,EAAE,iBAAiB,CAAC;EACjE;EAEAc,gBAAgBA,CAAAA,EAAc;IAC5B,QAAQ,IAAI,CAACnxB,KAAK,CAACxU,IAAI;MACrB,KAAA,EAAA;QAEE,OAAO,IAAI,CAAC64B,eAAe,CAAe,IAAI,CAAC;MACjD;QACE,OAAO,KAAK,CAAC8M,gBAAgB,EAAE;IAAA;EAErC;EAGAC,mBAAmBA,CACjBj4B,IAAwB,EACxBqD,aAAsB,EAChB;IAEN,MAAM5Q,IAAI,GAAGuN,IAAI,CAACvN,IAAI;IACtB,IAAIA,IAAI,KAAK,KAAK,IAAIA,IAAI,KAAK,KAAK,IAAI,IAAI,CAACyjB,KAAK,CAAA,EAAA,CAAO,EAAE;MACzDlW,IAAI,CAACwD,cAAc,GAAG,IAAI,CAAC6nB,iCAAiC,EAAE;IAChE;IACA,KAAK,CAAC4M,mBAAmB,CAACj4B,IAAI,EAAEqD,aAAa,CAAC;EAChD;EAGA60B,UAAUA,CACR5D,IAA0B,EAC1B7hC,IAA6B,EACvB;IACN,KAAK,CAACylC,UAAU,CAAC5D,IAAI,EAAE7hC,IAAI,CAAC;IAC5B,IAAI,IAAI,CAACyjB,KAAK,CAAA,EAAA,CAAU,EAAE;MAExBoe,IAAI,CAACzwB,EAAE,CAAC6nB,cAAc,GAAG,IAAI,CAACkB,uBAAuB,EAAE;MACvD,IAAI,CAAC5kB,gBAAgB,CAACssB,IAAI,CAACzwB,EAAE,CAAC;IAChC;EACF;EAGAs0B,iCAAiCA,CAC/Bn4B,IAA+B,EAC/Bo4B,IAAsB,EACK;IAC3B,IAAI,IAAI,CAACliB,KAAK,CAAA,EAAA,CAAU,EAAE;MACxB,MAAM6Y,qBAAqB,GAAG,IAAI,CAACloB,KAAK,CAACiM,kBAAkB;MAC3D,IAAI,CAACjM,KAAK,CAACiM,kBAAkB,GAAG,IAAI;MAEpC9S,IAAI,CAACyrB,UAAU,GAAG,IAAI,CAACmB,uBAAuB,EAAE;MAChD,IAAI,CAAC/lB,KAAK,CAACiM,kBAAkB,GAAGic,qBAAqB;IACvD;IAEA,OAAO,KAAK,CAACoJ,iCAAiC,CAACn4B,IAAI,EAAEo4B,IAAI,CAAC;EAC5D;EAGAC,qBAAqBA,CAAAA,EAAY;IAC/B,OAAO,IAAI,CAACniB,KAAK,CAAA,EAAA,CAAU,IAAI,KAAK,CAACmiB,qBAAqB,EAAE;EAC9D;EAYA7E,gBAAgBA,CACdruB,mBAA6C,EAC7CmzB,cAAyB,EACX;IAAA,IAAAC,IAAA;IACd,IAAI1xB,KAAK,GAAG,IAAI;IAEhB,IAAI2xB,GAAG;IAEP,IACE,IAAI,CAAClyB,SAAS,CAAC,KAAK,CAAC,KACpB,IAAI,CAAC4P,KAAK,KAAgB,IAAI,IAAI,CAACA,KAAK,CAAA,EAAA,CAAO,CAAC,EACjD;MACArP,KAAK,GAAG,IAAI,CAACA,KAAK,CAAC9H,KAAK,EAAE;MAE1By5B,GAAG,GAAG,IAAI,CAAC/V,QAAQ,CACjB,MAAM,KAAK,CAAC+Q,gBAAgB,CAACruB,mBAAmB,EAAEmzB,cAAc,CAAC,EACjEzxB,KAAK,CACN;MAID,IAAI,CAAC2xB,GAAG,CAAC1a,KAAK,EAAE,OAAO0a,GAAG,CAACx4B,IAAI;MAK/B,MAAM;QAAE/R;OAAS,GAAG,IAAI,CAAC4Y,KAAK;MAC9B,MAAM4xB,cAAc,GAAGxqC,OAAO,CAACA,OAAO,CAACG,MAAM,GAAG,CAAC,CAAC;MAClD,IAAIqqC,cAAc,KAAKtqC,KAAE,CAAC7M,MAAM,IAAIm3C,cAAc,KAAKtqC,KAAE,CAAC3M,MAAM,EAAE;QAChEyM,OAAO,CAACC,GAAG,EAAE;MACf;IACF;IAEA,IAAI,CAAAqqC,IAAA,GAAAC,GAAG,KAAHD,IAAAA,IAAAA,IAAA,CAAKza,KAAK,IAAI,IAAI,CAAC5H,KAAK,IAAO,EAAE;MAAA,IAAAwiB,KAAA,EAAAC,KAAA;MACnC9xB,KAAK,GAAGA,KAAK,IAAI,IAAI,CAACA,KAAK,CAAC9H,KAAK,EAAE;MAEnC,IAAIyE,cAA0C;MAE9C,MAAMre,KAAK,GAAG,IAAI,CAACs9B,QAAQ,CAACmW,KAAK,IAAI;QAAA,IAAAC,qBAAA;QACnCr1B,cAAc,GAAG,IAAI,CAAC6nB,iCAAiC,EAAE;QAEzD,MAAMyN,eAAe,GAAG,IAAI,CAACxG,gCAAgC,CAC3D9uB,cAAc,EACd,MAAM;UACJ,MAAM0wB,MAAM,GAAG,KAAK,CAACV,gBAAgB,CACnCruB,mBAAmB,EACnBmzB,cAAc,CACf;UAED,IAAI,CAAChT,0BAA0B,CAAC4O,MAAM,EAAE1wB,cAAc,CAAC;UAEvD,OAAO0wB,MAAM;QACf,CAAC,CACF;QAID,IAAA2E,CAAAA,qBAAA,GAAIC,eAAe,CAACn3B,KAAK,KAArBk3B,IAAAA,IAAAA,qBAAA,CAAuBr2B,aAAa,EAAEo2B,KAAK,EAAE;QAKjD,MAAMjG,IAAI,GAAG,IAAI,CAACoG,6BAA6B,CAACD,eAAe,CAAC;QAEhE,IAAInG,IAAI,CAACtgC,IAAI,KAAK,yBAAyB,EAAEumC,KAAK,EAAE;QAEpDjG,IAAI,CAACnvB,cAAc,GAAGA,cAAc;QACpC,IAAI,CAAC8hB,0BAA0B,CAACqN,IAAI,EAAEnvB,cAAc,CAAC;QAErD,OAAOs1B,eAAe;MACvB,CAAA,EAAEjyB,KAAK,CAAC;MAET,IAAIiyB,eAII,GAAG,IAAI;MAEf,IACE3zC,KAAK,CAAC6a,IAAI,IAEV,IAAI,CAAC+4B,6BAA6B,CAAC5zC,KAAK,CAAC6a,IAAI,CAAC,CAAC3N,IAAI,KACjD,yBAAyB,EAC3B;QACA,IAAI,CAAClN,KAAK,CAAC24B,KAAK,IAAI,CAAC34B,KAAK,CAAC49B,OAAO,EAAE;UAGlC,IAAI59B,KAAK,CAAC6a,IAAI,CAACg5B,KAAK,EAAE;YAEpB,IAAI,CAACjzB,KAAK,CACR0f,UAAU,CAACmD,+CAA+C,EAC1D;cAAEnjC,EAAE,EAAE+d;YAAe,CAAC,CACvB;UACH;UAEA,OAAOre,KAAK,CAAC6a,IAAI;QACnB;QAGA84B,eAAe,GAAG3zC,KAAK,CAAC6a,IAAI;MAC9B;MAQA,IAAA,CAAA04B,KAAA,GAAIF,GAAG,aAAHE,KAAA,CAAK14B,IAAI,EAAE;QAEb,IAAI,CAAC6G,KAAK,GAAG2xB,GAAG,CAAC3V,SAAS;QAC1B,OAAO2V,GAAG,CAACx4B,IAAI;MACjB;MAEA,IAAI84B,eAAe,EAAE;QAEnB,IAAI,CAACjyB,KAAK,GAAG1hB,KAAK,CAAC09B,SAAS;QAC5B,OAAOiW,eAAe;MACxB;MAEA,IAAAH,CAAAA,KAAA,GAAIH,GAAG,KAAHG,IAAAA,IAAAA,KAAA,CAAK7V,MAAM,EAAE,MAAM0V,GAAG,CAAC1a,KAAK;MAChC,IAAI34B,KAAK,CAAC29B,MAAM,EAAE,MAAM39B,KAAK,CAAC24B,KAAK;MAGnC,MAAM,IAAI,CAAC/X,KAAK,CAAC0f,UAAU,CAACkD,iCAAiC,EAAE;QAC7DljC,EAAE,EAAE+d;MACN,CAAC,CAAC;IACJ;IAEA,OAAO,KAAK,CAACgwB,gBAAgB,CAACruB,mBAAmB,EAAEmzB,cAAc,CAAC;EACpE;EAGAW,UAAUA,CACRj5B,IAAuC,EACe;IACtD,IAAI,IAAI,CAACkW,KAAK,CAAA,EAAA,CAAU,EAAE;MAExB,MAAMge,MAAM,GAAG,IAAI,CAACzR,QAAQ,CAAC,MAAM;QACjC,MAAMsM,qBAAqB,GAAG,IAAI,CAACloB,KAAK,CAACiM,kBAAkB;QAC3D,IAAI,CAACjM,KAAK,CAACiM,kBAAkB,GAAG,IAAI;QAEpC,MAAMqY,QAAQ,GAAG,IAAI,CAAC9mB,SAAS,EAAoB;QAEnD,CACE8mB,QAAQ,CAACO,cAAc,EAEvB1rB,IAAI,CAAC8qB,SAAS,CACf,GAAG,IAAI,CAACD,oCAAoC,EAAE;QAE/C,IAAI,CAAChkB,KAAK,CAACiM,kBAAkB,GAAGic,qBAAqB;QAErD,IAAI,IAAI,CAAC7M,kBAAkB,EAAE,EAAE,IAAI,CAAC/qB,UAAU,EAAE;QAChD,IAAI,CAAC,IAAI,CAAC+e,KAAK,IAAU,EAAE,IAAI,CAAC/e,UAAU,EAAE;QAE5C,OAAOg0B,QAAQ;MACjB,CAAC,CAAC;MAEF,IAAI+I,MAAM,CAACpR,MAAM,EAAE,OAAO,IAAI;MAG9B,IAAIoR,MAAM,CAACpW,KAAK,EAAE,IAAI,CAACjX,KAAK,GAAGqtB,MAAM,CAACrR,SAAS;MAI/C7iB,IAAI,CAACyrB,UAAU,GAAGyI,MAAM,CAACl0B,IAAI,CAAC0rB,cAAc,GACxC,IAAI,CAACnnB,UAAU,CAAC2vB,MAAM,CAACl0B,IAAI,EAAE,gBAAgB,CAAC,GAC9C,IAAI;IACV;IAEA,OAAO,KAAK,CAACi5B,UAAU,CAACj5B,IAAI,CAAC;EAC/B;EAEAk5B,gBAAgBA,CAAC72B,MAAqB,EAAW;IAC/C,OAAO,IAAI,CAAC6T,KAAK,CAAU,EAAA,CAAA,IAAI,KAAK,CAACgjB,gBAAgB,CAAC72B,MAAM,CAAC;EAC/D;EAEA82B,0BAA0BA,CACxBn5B,IAA+B,EAC/BqC,MAAmB,EACb;IACN,IAAI,IAAI,CAACwE,KAAK,CAAC8L,yBAAyB,CAAC8E,OAAO,CAACzX,IAAI,CAACrR,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE;MACnEqR,IAAI,CAACqC,MAAM,GAAGA,MAAM;IACtB,CAAC,MAAM;MACL,KAAK,CAAC82B,0BAA0B,CAACn5B,IAAI,EAAEqC,MAAM,CAAC;IAChD;EACF;EAEA4xB,WAAWA,CACTj0B,IAAgB,EAChBo5B,eAAwB,EACxBC,eAAgC,EAChCC,iBAA0B,GAAG,IAAI,EAC3B;IACN,IACED,eAAe,IACf,IAAI,CAACxyB,KAAK,CAAC8L,yBAAyB,CAAC8E,OAAO,CAACzX,IAAI,CAACrR,KAAK,CAAC,KAAK,CAAC,CAAC,EAC/D;MACA;IACF;IAGA,KAAK,IAAIiB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGoQ,IAAI,CAACqC,MAAM,CAACjU,MAAM,EAAEwB,CAAC,EAAE,EAAE;MAC3C,IAAI,IAAI,CAACwmC,WAAW,CAACp2B,IAAI,CAACqC,MAAM,CAACzS,CAAC,CAAC,CAAC,IAAIA,CAAC,GAAG,CAAC,EAAE;QAC7C,IAAI,CAACmW,KAAK,CAAC0f,UAAU,CAACwC,oBAAoB,EAAE;UAAExiC,EAAE,EAAEua,IAAI,CAACqC,MAAM,CAACzS,CAAC;QAAE,CAAC,CAAC;MACrE;IACF;IAEA,KAAK,CAACqkC,WAAW,CACfj0B,IAAI,EACJo5B,eAAe,EACfC,eAAe,EACfC,iBAAiB,CAClB;EACH;EAEAC,kCAAkCA,CAACC,UAAmB,EAAgB;IACpE,OAAO,KAAK,CAACD,kCAAkC,CAC7CC,UAAU,IAAI,IAAI,CAAC3yB,KAAK,CAAC6L,SAAS,CAAC+E,OAAO,CAAC,IAAI,CAAC5Q,KAAK,CAAClY,KAAK,CAAC,KAAK,CAAC,CAAC,CACpE;EACH;EAEA8qC,eAAeA,CACbpyB,IAAkB,EAElBnC,QAAkB,EAClBoC,OAAwB,EACV;IACd,IACED,IAAI,CAAChV,IAAI,KAAK,YAAY,IAC1BgV,IAAI,CAAC3kB,IAAI,KAAK,OAAO,IACrB,IAAI,CAACmkB,KAAK,CAAC6L,SAAS,CAAC+E,OAAO,CAACvS,QAAQ,CAAC1W,KAAK,CAAC,KAAK,CAAC,CAAC,EACnD;MACA,IAAI,CAACob,IAAI,EAAE;MAEX,MAAM5J,IAAI,GAAG,IAAI,CAACqlB,WAAW,CAACngB,QAAQ,CAAC;MACvClF,IAAI,CAACmG,MAAM,GAAGkB,IAAI;MAClBrH,IAAI,CAACqG,SAAS,GAAG,KAAK,CAACqzB,4BAA4B,CAAA,EAAA,EAAY,KAAK,CAAC;MACrEryB,IAAI,GAAG,IAAI,CAAC9C,UAAU,CAACvE,IAAI,EAAE,gBAAgB,CAAC;IAC/C,CAAA,MAAM,IACLqH,IAAI,CAAChV,IAAI,KAAK,YAAY,IAC1BgV,IAAI,CAAC3kB,IAAI,KAAK,OAAO,IACrB,IAAI,CAACwzB,KAAK,IAAO,EACjB;MACA,MAAMrP,KAAK,GAAG,IAAI,CAACA,KAAK,CAAC9H,KAAK,EAAE;MAChC,MAAM5Z,KAAK,GAAG,IAAI,CAACs9B,QAAQ,CACzBmW,KAAK,IAAI,IAAI,CAACe,iCAAiC,CAACz0B,QAAQ,CAAC,IAAI0zB,KAAK,EAAE,EACpE/xB,KAAK,CACN;MAID,IAAI,CAAC1hB,KAAK,CAAC24B,KAAK,IAAI,CAAC34B,KAAK,CAAC49B,OAAO,EAAE,OAAO59B,KAAK,CAAC6a,IAAI;MAErD,MAAMk0B,MAAM,GAAG,IAAI,CAACzR,QAAQ,CAC1B,MAAM,KAAK,CAACgX,eAAe,CAACpyB,IAAI,EAAEnC,QAAQ,EAAEoC,OAAO,CAAC,EACpDT,KAAK,CACN;MAED,IAAIqtB,MAAM,CAACl0B,IAAI,IAAI,CAACk0B,MAAM,CAACpW,KAAK,EAAE,OAAOoW,MAAM,CAACl0B,IAAI;MAEpD,IAAI7a,KAAK,CAAC6a,IAAI,EAAE;QACd,IAAI,CAAC6G,KAAK,GAAG1hB,KAAK,CAAC09B,SAAS;QAE5B,OAAO19B,KAAK,CAAC6a,IAAI;MACnB;MAEA,IAAIk0B,MAAM,CAACl0B,IAAI,EAAE;QACf,IAAI,CAAC6G,KAAK,GAAGqtB,MAAM,CAACrR,SAAS;QAC7B,OAAOqR,MAAM,CAACl0B,IAAI;MACpB;MAEA,MAAM7a,KAAK,CAAC24B,KAAK,IAAIoW,MAAM,CAACpW,KAAK;IACnC;IAEA,OAAO,KAAK,CAAC2b,eAAe,CAACpyB,IAAI,EAAEnC,QAAQ,EAAEoC,OAAO,CAAC;EACvD;EAEAF,cAAcA,CACZC,IAAkB,EAElBnC,QAAkB,EAClBoC,OAAmC,EACnCsyB,cAAqC,EACvB;IACd,IAAI,IAAI,CAAC1jB,KAAK,CAAA,EAAA,CAAgB,IAAI,IAAI,CAAC2jB,mBAAmB,EAAE,EAAE;MAC5DD,cAAc,CAACryB,mBAAmB,GAAG,IAAI;MACzC,IAAID,OAAO,EAAE;QACXsyB,cAAc,CAACnyB,IAAI,GAAG,IAAI;QAC1B,OAAOJ,IAAI;MACb;MACA,IAAI,CAACuC,IAAI,EAAE;MACX,MAAM5J,IAAI,GAAG,IAAI,CAACqlB,WAAW,CAA2BngB,QAAQ,CAAC;MACjElF,IAAI,CAACmG,MAAM,GAAGkB,IAAI;MAClBrH,IAAI,CAAC85B,aAAa,GAAG,IAAI,CAACjM,mCAAmC,EAAE;MAC/D,IAAI,CAACrL,MAAM,CAAW,EAAA,CAAA;MACtBxiB,IAAI,CAACqG,SAAS,GAAG,IAAI,CAACqzB,4BAA4B,CAAA,EAAA,EAAY,KAAK,CAAC;MACpE15B,IAAI,CAACkG,QAAQ,GAAG,IAAI;MACpB,OAAO,IAAI,CAACF,oBAAoB,CAAChG,IAAI,EAAiB,IAAI,CAAC;IAC7D,CAAC,MAAM,IAAI,CAACsH,OAAO,IAAI,IAAI,CAAC4iB,gBAAgB,EAAE,IAAI,IAAI,CAAChU,KAAK,IAAO,EAAE;MACnE,MAAMlW,IAAI,GAAG,IAAI,CAACqlB,WAAW,CAE3BngB,QAAQ,CAAC;MACXlF,IAAI,CAACmG,MAAM,GAAGkB,IAAI;MAElB,MAAM6sB,MAAM,GAAG,IAAI,CAACzR,QAAQ,CAAC,MAAM;QACjCziB,IAAI,CAAC85B,aAAa,GAChB,IAAI,CAAC9K,4CAA4C,EAAE;QACrD,IAAI,CAACxM,MAAM,CAAW,EAAA,CAAA;QACtBxiB,IAAI,CAACqG,SAAS,GAAG,KAAK,CAACqzB,4BAA4B,CAAA,EAAA,EAAY,KAAK,CAAC;QACrE,IAAIE,cAAc,CAACryB,mBAAmB,EAAE;UACrCvH,IAAI,CAAsCkG,QAAQ,GAAG,KAAK;QAC7D;QACA,OAAO,IAAI,CAACF,oBAAoB,CAC9BhG,IAAI,EACJ45B,cAAc,CAACryB,mBAAmB,CACnC;MACH,CAAC,CAAC;MAEF,IAAI2sB,MAAM,CAACl0B,IAAI,EAAE;QACf,IAAIk0B,MAAM,CAACpW,KAAK,EAAE,IAAI,CAACjX,KAAK,GAAGqtB,MAAM,CAACrR,SAAS;QAC/C,OAAOqR,MAAM,CAACl0B,IAAI;MACpB;IACF;IAEA,OAAO,KAAK,CAACoH,cAAc,CACzBC,IAAI,EAEJnC,QAAQ,EACRoC,OAAO,EACPsyB,cAAc,CACf;EACH;EAEAG,cAAcA,CAAC/5B,IAAqB,EAAQ;IAC1C,KAAK,CAAC+5B,cAAc,CAAC/5B,IAAI,CAAC;IAE1B,IAAIg6B,KAAK,GAAG,IAAI;IAChB,IAAI,IAAI,CAAC9P,gBAAgB,EAAE,IAAI,IAAI,CAAChU,KAAK,CAAA,EAAA,CAAO,EAAE;MAChD8jB,KAAK,GAAG,IAAI,CAACvX,QAAQ,CAAC,MACpB,IAAI,CAACuM,4CAA4C,EAAE,CACpD,CAAChvB,IAAI;IACR;IACAA,IAAI,CAAC85B,aAAa,GAAGE,KAAK;EAC5B;EAEAL,iCAAiCA,CAC/Bz0B,QAAkB,EAC4B;IAC9C,MAAMlF,IAAI,GAAG,IAAI,CAACqlB,WAAW,CAA4BngB,QAAQ,CAAC;IAClE,IAAI,CAAC+yB,mBAAmB,CAACj4B,IAAI,EAAE,KAAK,CAAC;IACrC,IAAI,CAAC,IAAI,CAACi5B,UAAU,CAACj5B,IAAI,CAAC,EAAE;IAC5B,OAAO,KAAK,CAACi6B,oBAAoB,CAC/Bj6B,IAAI,EACSxgB,SAAS,EACR,IAAI,CACnB;EACH;EAEAy7B,qBAAqBA,CAACtqB,IAAY,EAAQ;IACxC,MAAMiZ,IAAI,GAAG,IAAI,CAAC6H,KAAK,CAACC,UAAU,CAAC,IAAI,CAAC7K,KAAK,CAAC5H,GAAG,GAAG,CAAC,CAAC;IACtD,IACEtO,IAAI,KAAuB,EAAA,IAC3BiZ,IAAI,KAAA,EAAoB,IACxB,IAAI,CAAC/C,KAAK,CAACkM,cAAc,EACzB;MACA,IAAI,CAAClM,KAAK,CAACkM,cAAc,GAAG,KAAK;MACjC,IAAI,CAAClM,KAAK,CAAC5H,GAAG,IAAI,CAAC;MACnB,IAAI,CAACuZ,SAAS,EAAE;MAChB;IACF;IAEA,KAAK,CAACyC,qBAAqB,CAACtqB,IAAI,CAAC;EACnC;EAEAwqB,kBAAkBA,CAACxqB,IAAY,EAAQ;IACrC,MAAMiZ,IAAI,GAAG,IAAI,CAAC6H,KAAK,CAACC,UAAU,CAAC,IAAI,CAAC7K,KAAK,CAAC5H,GAAG,GAAG,CAAC,CAAC;IACtD,IACEtO,IAAI,KAAA,GAA0B,IAC9BiZ,IAAI,QAA8B,EAClC;MAEA,IAAI,CAACiR,QAAQ,CAAe,CAAA,EAAA,CAAC,CAAC;MAC9B;IACF;IAEA,KAAK,CAACM,kBAAkB,CAACxqB,IAAI,CAAC;EAChC;EAEAupC,aAAaA,CAAC75B,IAAY,EAAE85B,OAAkB,EAAU;IACtD,MAAMC,QAAQ,GAAG,KAAK,CAACF,aAAa,CAAC75B,IAAI,EAAE85B,OAAO,CAAC;IACnD,IAAI,IAAI,CAACtzB,KAAK,CAACkM,cAAc,EAAE;MAC7B,IAAI,CAAChN,KAAK,CAAC0f,UAAU,CAACuD,uBAAuB,EAAE;QAC7CvjC,EAAE,EAAE,IAAI,CAACohB,KAAK,CAACoN,WAAW;MAC5B,CAAC,CAAC;IACJ;IACA,OAAOmmB,QAAQ;EACjB;EAEApgB,gBAAgBA,CAAAA,EAA+B;IAC7C,IAAI,IAAI,CAAC1T,SAAS,CAAC,cAAc,CAAC,IAAI,IAAI,CAAC+zB,eAAe,EAAE,EAAE;MAC5D,IAAI,IAAI,CAACxzB,KAAK,CAACkM,cAAc,EAAE;QAC7B,MAAM,IAAI,CAAChN,KAAK,CAAC0f,UAAU,CAACiC,iBAAiB,EAAE;UAC7CjiC,EAAE,EAAE,IAAI,CAACohB,KAAK,CAAC3B;QACjB,CAAC,CAAC;MACJ;MACA,IAAI,CAACo1B,wBAAwB,EAAE;MAC/B,MAAMC,WAAW,GAAG,IAAI,CAACF,eAAe,EAAE;MAC1C,IAAIE,WAAW,EAAE;QACf,IAAI,CAAC1zB,KAAK,CAAC5H,GAAG,IAAIs7B,WAAW;QAC7B,IAAI,CAAC1zB,KAAK,CAACkM,cAAc,GAAG,IAAI;MAClC;MACA;IACF;IAEA,OAAO,KAAK,CAACiH,gBAAgB,CAAC,IAAI,CAACnT,KAAK,CAACkM,cAAc,GAAG,KAAK,GAAG,IAAI,CAAC;EACzE;EAEAsnB,eAAeA,CAAAA,EAAmB;IAChC,MAAM;MAAEp7B;KAAK,GAAG,IAAI,CAAC4H,KAAK;IAC1B,IAAI2zB,yBAAyB,GAAG,CAAC;IACjC,OACE,CAAgC,EAAA,EAAA,CAAA,CAAA,CAAC/d,QAAQ,CAEvC,IAAI,CAAChL,KAAK,CAACC,UAAU,CAACzS,GAAG,GAAGu7B,yBAAyB,CAAC,CACvD,EACD;MACAA,yBAAyB,EAAE;IAC7B;IAEA,MAAMC,GAAG,GAAG,IAAI,CAAChpB,KAAK,CAACC,UAAU,CAAC8oB,yBAAyB,GAAGv7B,GAAG,CAAC;IAClE,MAAMy7B,GAAG,GAAG,IAAI,CAACjpB,KAAK,CAACC,UAAU,CAAC8oB,yBAAyB,GAAGv7B,GAAG,GAAG,CAAC,CAAC;IAEtE,IAAIw7B,GAAG,KAAA,EAAoB,IAAIC,GAAG,OAAoB,EAAE;MACtD,OAAOF,yBAAyB,GAAG,CAAC;IACtC;IACA,IACE,IAAI,CAAC/oB,KAAK,CAAC2C,KAAK,CACdomB,yBAAyB,GAAGv7B,GAAG,EAC/Bu7B,yBAAyB,GAAGv7B,GAAG,GAAG,EAAE,CACrC,KAAK,cAAc,EACpB;MACA,OAAOu7B,yBAAyB,GAAG,EAAE;IACvC;IACA,IAAIC,GAAG,KAAA,EAAoB,IAAIC,GAAG,OAAoB,EAAE;MACtD,OAAOF,yBAAyB;IAClC;IACA,OAAO,KAAK;EACd;EAEAF,wBAAwBA,CAAAA,EAAS;IAC/B,MAAM1rC,GAAG,GAAG,IAAI,CAAC6iB,KAAK,CAACgG,OAAO,CAAC,IAAI,EAAE,IAAI,CAAC5Q,KAAK,CAAC5H,GAAG,CAAC;IACpD,IAAIrQ,GAAG,KAAK,CAAC,CAAC,EAAE;MACd,MAAM,IAAI,CAACmX,KAAK,CAAClG,MAAM,CAACvD,mBAAmB,EAAE;QAC3C7W,EAAE,EAAE,IAAI,CAACohB,KAAK,CAACoN,WAAW;MAC5B,CAAC,CAAC;IACJ;EACF;EAIA0mB,wCAAwCA,CACtC97B,GAAa,EACb;IACEsnB,QAAQ;IACRD;EAIF,CAAC,EACK;IACN,IAAI,CAACngB,KAAK,CAAC0f,UAAU,CAACQ,+BAA+B,EAAE;MACrDxgC,EAAE,EAAEoZ,GAAG;MACPqnB,UAAU;MACVC;IACF,CAAC,CAAC;EACJ;EAEAyU,qCAAqCA,CACnC/7B,GAAa,EACbg8B,WAAwB,EACxB;IACA,OAAO,IAAI,CAAC90B,KAAK,CACf,CAAC80B,WAAW,CAACnU,YAAY,GACrBjB,UAAU,CAACmB,uCAAuC,GAClDiU,WAAW,CAACnU,YAAY,KAAK,QAAQ,GACrCjB,UAAU,CAACkB,sCAAsC,GACjDlB,UAAU,CAACgB,uCAAuC,EAAA3lC,MAAA,CAAA+E,MAAA,CAAA;MAEpDJ,EAAE,EAAEoZ;IAAG,CAAA,EACJg8B,WAAW,CAEjB,CAAA;EACH;EAEAC,uCAAuCA,CACrCj8B,GAAa,EACb;IACEsnB,QAAQ;IACRD;EAIF,CAAC,EACK;IACN,IAAI,CAACngB,KAAK,CAAC0f,UAAU,CAACsB,8BAA8B,EAAE;MACpDthC,EAAE,EAAEoZ,GAAG;MACPsnB,QAAQ;MACRD;IACF,CAAC,CAAC;EACJ;EAEA6U,kDAAkDA,CAChD/6B,IAAY,EACZ;IACEmmB;EAGF,CAAC,EACK;IACN,IAAI,CAACpgB,KAAK,CAAC0f,UAAU,CAACuB,yCAAyC,EAAE;MAC/DvhC,EAAE,EAAEua,IAAI;MACRmmB;IACF,CAAC,CAAC;EACJ;EAEA6U,kBAAkBA,CAAAA,EAAmB;IACnC,MAAM91B,QAAQ,GAAG,IAAI,CAAC2B,KAAK,CAAC3B,QAAQ;IACpC,MAAM+1B,SAAS,GAAGA,CAAAA,KAAM,IAAI,CAAC/kB,KAAK,CAAA,EAAA,CAAU,IAAI,IAAI,CAACA,KAAK,CAAW,CAAA,CAAA;IACrE,QAAQ,IAAI,CAACrP,KAAK,CAACxU,IAAI;MACrB,KAAA,GAAA;QAAa;UACX,MAAM6oC,OAAO,GAAG,IAAI,CAAC95B,mBAAmB,CAAC,IAAI,CAACyF,KAAK,CAACnX,KAAK,CAAC;UAC1D,IAAIurC,SAAS,EAAE,EAAE;YACf,OAAO;cAAE5oC,IAAI,EAAE,QAAQ;cAAEwM,GAAG,EAAEq8B,OAAO,CAACr8B,GAAG,CAAClQ,KAAK;cAAEe,KAAK,EAAEwrC;aAAS;UACnE;UACA,OAAO;YAAE7oC,IAAI,EAAE,SAAS;YAAEwM,GAAG,EAAEqG;WAAU;QAC3C;MACA,KAAA,GAAA;QAAgB;UACd,MAAMg2B,OAAO,GAAG,IAAI,CAAC/5B,kBAAkB,CAAC,IAAI,CAAC0F,KAAK,CAACnX,KAAK,CAAC;UACzD,IAAIurC,SAAS,EAAE,EAAE;YACf,OAAO;cAAE5oC,IAAI,EAAE,QAAQ;cAAEwM,GAAG,EAAEq8B,OAAO,CAACr8B,GAAG,CAAClQ,KAAK;cAAEe,KAAK,EAAEwrC;aAAS;UACnE;UACA,OAAO;YAAE7oC,IAAI,EAAE,SAAS;YAAEwM,GAAG,EAAEqG;WAAU;QAC3C;MACA,KAAA,EAAA;MACA,KAAA,EAAA;QAAgB;UACd,MAAMg2B,OAAO,GAAG,IAAI,CAAC55B,mBAAmB,CAAC,IAAI,CAAC4U,KAAK,CAAA,EAAA,CAAU,CAAC;UAC9D,IAAI+kB,SAAS,EAAE,EAAE;YACf,OAAO;cACL5oC,IAAI,EAAE,SAAS;cACfwM,GAAG,EAAEq8B,OAAO,CAACr8B,GAAG,CAAClQ,KAAK;cACtBe,KAAK,EAAEwrC;aACR;UACH;UACA,OAAO;YAAE7oC,IAAI,EAAE,SAAS;YAAEwM,GAAG,EAAEqG;WAAU;QAC3C;MACA;QACE,OAAO;UAAE7S,IAAI,EAAE,SAAS;UAAEwM,GAAG,EAAEqG;SAAU;IAAA;EAE/C;EAEAi2B,iBAAiBA,CAAAA,EAGf;IACA,MAAMt8B,GAAG,GAAG,IAAI,CAACgI,KAAK,CAAC3B,QAAQ;IAC/B,MAAMrB,EAAE,GAAG,IAAI,CAACqnB,eAAe,CAAC,IAAI,CAAC;IACrC,MAAMlX,IAAI,GAAG,IAAI,CAACyE,GAAG,CAAO,EAAA,CAAA,GACxB,IAAI,CAACuiB,kBAAkB,EAAE,GACzB;MAAE3oC,IAAI,EAAE,MAAe;MAAEwM;KAAK;IAClC,OAAO;MAAEgF,EAAE;MAAEmQ;KAAM;EACrB;EAEAonB,iCAAiCA,CAC/Bv8B,GAAa,EACb5Q,OAAoB,EACpBotC,YAA8B,EACxB;IACN,MAAM;MAAE3U;IAAc,CAAA,GAAGz4B,OAAO;IAChC,IAAIy4B,YAAY,KAAK,IAAI,EAAE;MACzB;IACF;IACA,IAAIA,YAAY,KAAK2U,YAAY,EAAE;MACjC,IAAI,CAACT,qCAAqC,CAAC/7B,GAAG,EAAE5Q,OAAO,CAAC;IAC1D;EACF;EAEAqtC,eAAeA,CAAC;IACdnV,QAAQ;IACRO;EAIF,CAAC,EAQC;IACA,MAAM6U,SAAS,GAAG,IAAI79B,GAAG,EAAE;IAC3B,MAAM89B,OAAO,GAAG;MAEdC,cAAc,EAAE,EAAE;MAElBC,aAAa,EAAE,EAAE;MAEjBC,aAAa,EAAE,EAAE;MAEjBC,gBAAgB,EAAE;KACnB;IACD,IAAIC,iBAAiB,GAAG,KAAK;IAC7B,OAAO,CAAC,IAAI,CAAC3lB,KAAK,GAAW,EAAE;MAC7B,IAAI,IAAI,CAACuC,GAAG,CAAA,EAAA,CAAa,EAAE;QACzBojB,iBAAiB,GAAG,IAAI;QACxB;MACF;MACA,MAAMC,UAAU,GAAG,IAAI,CAACz3B,SAAS,EAAE;MACnC,MAAM;QAAER,EAAE;QAAEmQ;MAAK,CAAC,GAAG,IAAI,CAACmnB,iBAAiB,EAAE;MAC7C,MAAMjV,UAAU,GAAGriB,EAAE,CAACnhB,IAAI;MAC1B,IAAIwjC,UAAU,KAAK,EAAE,EAAE;QACrB;MACF;MACA,IAAI,QAAQ,CAACxd,IAAI,CAACwd,UAAU,CAAC,EAAE;QAC7B,IAAI,CAACngB,KAAK,CAAC0f,UAAU,CAACoB,qBAAqB,EAAE;UAC3CphC,EAAE,EAAEoe,EAAE;UACNqiB,UAAU;UACVY,UAAU,EAAEZ,UAAU,CAAC,CAAC,CAAC,CAAC6V,WAAW,EAAE,GAAG7V,UAAU,CAAC9R,KAAK,CAAC,CAAC,CAAC;UAC7D+R;QACF,CAAC,CAAC;MACJ;MACA,IAAIoV,SAAS,CAACjyB,GAAG,CAAC4c,UAAU,CAAC,EAAE;QAC7B,IAAI,CAACngB,KAAK,CAAC0f,UAAU,CAACW,uBAAuB,EAAE;UAC7C3gC,EAAE,EAAEoe,EAAE;UACNqiB,UAAU;UACVC;QACF,CAAC,CAAC;MACJ;MACAoV,SAAS,CAAC5sB,GAAG,CAACuX,UAAU,CAAC;MACzB,MAAMj4B,OAAO,GAAG;QAAEk4B,QAAQ;QAAEO,YAAY;QAAER;OAAY;MACtD4V,UAAU,CAACj4B,EAAE,GAAGA,EAAE;MAClB,QAAQmQ,IAAI,CAAC3hB,IAAI;QACf,KAAK,SAAS;UAAE;YACd,IAAI,CAAC+oC,iCAAiC,CACpCpnB,IAAI,CAACnV,GAAG,EACR5Q,OAAO,EACP,SAAS,CACV;YACD6tC,UAAU,CAAC9nB,IAAI,GAAGA,IAAI,CAACtkB,KAAK;YAC5B8rC,OAAO,CAACC,cAAc,CAACh4C,IAAI,CACzB,IAAI,CAAC8gB,UAAU,CAACu3B,UAAU,EAAE,mBAAmB,CAAC,CACjD;YACD;UACF;QACA,KAAK,QAAQ;UAAE;YACb,IAAI,CAACV,iCAAiC,CAACpnB,IAAI,CAACnV,GAAG,EAAE5Q,OAAO,EAAE,QAAQ,CAAC;YACnE6tC,UAAU,CAAC9nB,IAAI,GAAGA,IAAI,CAACtkB,KAAK;YAC5B8rC,OAAO,CAACE,aAAa,CAACj4C,IAAI,CACxB,IAAI,CAAC8gB,UAAU,CAACu3B,UAAU,EAAE,kBAAkB,CAAC,CAChD;YACD;UACF;QACA,KAAK,QAAQ;UAAE;YACb,IAAI,CAACV,iCAAiC,CAACpnB,IAAI,CAACnV,GAAG,EAAE5Q,OAAO,EAAE,QAAQ,CAAC;YACnE6tC,UAAU,CAAC9nB,IAAI,GAAGA,IAAI,CAACtkB,KAAK;YAC5B8rC,OAAO,CAACG,aAAa,CAACl4C,IAAI,CACxB,IAAI,CAAC8gB,UAAU,CAACu3B,UAAU,EAAE,kBAAkB,CAAC,CAChD;YACD;UACF;QACA,KAAK,SAAS;UAAE;YACd,MAAM,IAAI,CAAClB,qCAAqC,CAAC5mB,IAAI,CAACnV,GAAG,EAAE5Q,OAAO,CAAC;UACrE;QACA,KAAK,MAAM;UAAE;YACX,QAAQy4B,YAAY;cAClB,KAAK,SAAS;gBACZ,IAAI,CAACiU,wCAAwC,CAC3C3mB,IAAI,CAACnV,GAAG,EACR5Q,OAAO,CACR;gBACD;cACF,KAAK,QAAQ;gBACX,IAAI,CAAC6sC,uCAAuC,CAAC9mB,IAAI,CAACnV,GAAG,EAAE5Q,OAAO,CAAC;gBAC/D;cACF;gBACEutC,OAAO,CAACI,gBAAgB,CAACn4C,IAAI,CAC3B,IAAI,CAAC8gB,UAAU,CAACu3B,UAAU,EAAE,qBAAqB,CAAC,CACnD;YAAA;UAEP;MAAA;MAGF,IAAI,CAAC,IAAI,CAAC5lB,KAAK,GAAW,EAAE;QAC1B,IAAI,CAACsM,MAAM,CAAU,EAAA,CAAA;MACvB;IACF;IACA,OAAO;MAAEgZ,OAAO;MAAEK;KAAmB;EACvC;EAEAG,qBAAqBA,CACnBC,kBAAiC,EACjCL,gBAA+B,EAC/B;IACEzV;EAGF,CAAC,EACc;IACf,IAAI8V,kBAAkB,CAAC7tC,MAAM,KAAK,CAAC,EAAE;MACnC,OAAOwtC,gBAAgB;IACzB,CAAC,MAAM,IAAIA,gBAAgB,CAACxtC,MAAM,KAAK,CAAC,EAAE;MACxC,OAAO6tC,kBAAkB;IAC1B,CAAA,MAAM,IAAIL,gBAAgB,CAACxtC,MAAM,GAAG6tC,kBAAkB,CAAC7tC,MAAM,EAAE;MAC9D,KAAK,MAAM8mC,MAAM,IAAI+G,kBAAkB,EAAE;QACvC,IAAI,CAAClB,kDAAkD,CAAC7F,MAAM,EAAE;UAC9D/O;QACF,CAAC,CAAC;MACJ;MACA,OAAOyV,gBAAgB;IACzB,CAAC,MAAM;MACL,KAAK,MAAM1G,MAAM,IAAI0G,gBAAgB,EAAE;QACrC,IAAI,CAACb,kDAAkD,CAAC7F,MAAM,EAAE;UAC9D/O;QACF,CAAC,CAAC;MACJ;MACA,OAAO8V,kBAAkB;IAC3B;EACF;EAEAC,yBAAyBA,CAAC;IACxB/V;EAGF,CAAC,EAAoB;IACnB,IAAI,CAAC,IAAI,CAACnE,aAAa,CAAQ,GAAA,CAAA,EAAE,OAAO,IAAI;IAE5C,IAAI,CAACn1B,iBAAiB,CAAC,IAAI,CAACga,KAAK,CAACxU,IAAI,CAAC,EAAE;MACvC,MAAM,IAAI,CAAC0T,KAAK,CAAC0f,UAAU,CAACe,sCAAsC,EAAE;QAClE/gC,EAAE,EAAE,IAAI,CAACohB,KAAK,CAAC3B,QAAQ;QACvBihB;MACF,CAAC,CAAC;IACJ;IAEA,MAAM;MAAEz2B;KAAO,GAAG,IAAI,CAACmX,KAAK;IAC5B,IAAI,CAAC+C,IAAI,EAAE;IAEX,IACEla,KAAK,KAAK,SAAS,IACnBA,KAAK,KAAK,QAAQ,IAClBA,KAAK,KAAK,QAAQ,IAClBA,KAAK,KAAK,QAAQ,EAClB;MACA,IAAI,CAACqW,KAAK,CAAC0f,UAAU,CAACa,uBAAuB,EAAE;QAC7C7gC,EAAE,EAAE,IAAI,CAACohB,KAAK,CAAC3B,QAAQ;QACvBihB,QAAQ;QACRI,eAAe,EAAE72B;MACnB,CAAC,CAAC;IACJ;IAEA,OAAOA,KAAK;EACd;EAEAysC,YAAYA,CAACn8B,IAAoB,EAAE6D,EAAU,EAAU;IACrD,MAAMsiB,QAAQ,GAAGtiB,EAAE,CAACnhB,IAAI;IACxB,MAAM05C,OAAO,GAAGv4B,EAAE,CAAChF,GAAG,CAAClQ,KAAK;IAC5B,MAAM+3B,YAAY,GAAG,IAAI,CAACwV,yBAAyB,CAAC;MAAE/V;IAAS,CAAC,CAAC;IACjE,IAAI,CAAC3D,MAAM,CAAW,CAAA,CAAA;IACtB,MAAM;MAAEgZ,OAAO;MAAEK;IAAkB,CAAC,GAAG,IAAI,CAACP,eAAe,CAAC;MAC1DnV,QAAQ;MACRO;IACF,CAAC,CAAC;IACF1mB,IAAI,CAAC67B,iBAAiB,GAAGA,iBAAiB;IAE1C,QAAQnV,YAAY;MAClB,KAAK,SAAS;QACZ1mB,IAAI,CAAC0mB,YAAY,GAAG,IAAI;QACxB1mB,IAAI,CAACw7B,OAAO,GAAGA,OAAO,CAACC,cAAc;QACrC,IAAI,CAACjZ,MAAM,CAAW,CAAA,CAAA;QACtB,OAAO,IAAI,CAACje,UAAU,CAACvE,IAAI,EAAE,iBAAiB,CAAC;MACjD,KAAK,QAAQ;QACXA,IAAI,CAAC0mB,YAAY,GAAG,IAAI;QACxB1mB,IAAI,CAACw7B,OAAO,GAAGA,OAAO,CAACE,aAAa;QACpC,IAAI,CAAClZ,MAAM,CAAW,CAAA,CAAA;QACtB,OAAO,IAAI,CAACje,UAAU,CAACvE,IAAI,EAAE,gBAAgB,CAAC;MAChD,KAAK,QAAQ;QACXA,IAAI,CAAC0mB,YAAY,GAAG,IAAI;QACxB1mB,IAAI,CAACw7B,OAAO,GAAG,IAAI,CAACQ,qBAAqB,CACvCR,OAAO,CAACG,aAAa,EACrBH,OAAO,CAACI,gBAAgB,EACxB;UAAEzV;QAAS,CAAC,CACb;QACD,IAAI,CAAC3D,MAAM,CAAW,CAAA,CAAA;QACtB,OAAO,IAAI,CAACje,UAAU,CAACvE,IAAI,EAAE,gBAAgB,CAAC;MAChD,KAAK,QAAQ;QACXA,IAAI,CAACw7B,OAAO,GAAGA,OAAO,CAACI,gBAAgB;QACvC,IAAI,CAACpZ,MAAM,CAAW,CAAA,CAAA;QACtB,OAAO,IAAI,CAACje,UAAU,CAACvE,IAAI,EAAE,gBAAgB,CAAC;MAChD;QAAS;UAEP,MAAMq8B,KAAK,GAAGA,CAAAA,KAAM;YAClBr8B,IAAI,CAACw7B,OAAO,GAAG,EAAE;YACjB,IAAI,CAAChZ,MAAM,CAAW,CAAA,CAAA;YACtB,OAAO,IAAI,CAACje,UAAU,CAACvE,IAAI,EAAE,gBAAgB,CAAC;WAC/C;UACDA,IAAI,CAAC0mB,YAAY,GAAG,KAAK;UAEzB,MAAM4V,QAAQ,GAAGd,OAAO,CAACC,cAAc,CAACrtC,MAAM;UAC9C,MAAMmuC,OAAO,GAAGf,OAAO,CAACE,aAAa,CAACttC,MAAM;UAC5C,MAAMouC,OAAO,GAAGhB,OAAO,CAACG,aAAa,CAACvtC,MAAM;UAC5C,MAAMquC,YAAY,GAAGjB,OAAO,CAACI,gBAAgB,CAACxtC,MAAM;UAEpD,IAAI,CAACkuC,QAAQ,IAAI,CAACC,OAAO,IAAI,CAACC,OAAO,IAAI,CAACC,YAAY,EAAE;YACtD,OAAOJ,KAAK,EAAE;UAChB,CAAC,MAAM,IAAI,CAACC,QAAQ,IAAI,CAACC,OAAO,EAAE;YAChCv8B,IAAI,CAACw7B,OAAO,GAAG,IAAI,CAACQ,qBAAqB,CACvCR,OAAO,CAACG,aAAa,EACrBH,OAAO,CAACI,gBAAgB,EACxB;cAAEzV;YAAS,CAAC,CACb;YACD,IAAI,CAAC3D,MAAM,CAAW,CAAA,CAAA;YACtB,OAAO,IAAI,CAACje,UAAU,CAACvE,IAAI,EAAE,gBAAgB,CAAC;UAC/C,CAAA,MAAM,IAAI,CAACu8B,OAAO,IAAI,CAACC,OAAO,IAAIF,QAAQ,IAAIG,YAAY,EAAE;YAC3D,KAAK,MAAMvH,MAAM,IAAIsG,OAAO,CAACI,gBAAgB,EAAE;cAC7C,IAAI,CAACjB,wCAAwC,CAACzF,MAAM,CAACr2B,GAAG,CAAClQ,KAAK,EAAE;gBAC9Dw3B,QAAQ;gBACRD,UAAU,EAAEgP,MAAM,CAACrxB,EAAE,CAACnhB;cACxB,CAAC,CAAC;YACJ;YACAsd,IAAI,CAACw7B,OAAO,GAAGA,OAAO,CAACC,cAAc;YACrC,IAAI,CAACjZ,MAAM,CAAW,CAAA,CAAA;YACtB,OAAO,IAAI,CAACje,UAAU,CAACvE,IAAI,EAAE,iBAAiB,CAAC;UAChD,CAAA,MAAM,IAAI,CAACs8B,QAAQ,IAAI,CAACE,OAAO,IAAID,OAAO,IAAIE,YAAY,EAAE;YAC3D,KAAK,MAAMvH,MAAM,IAAIsG,OAAO,CAACI,gBAAgB,EAAE;cAC7C,IAAI,CAACd,uCAAuC,CAAC5F,MAAM,CAACr2B,GAAG,CAAClQ,KAAK,EAAE;gBAC7Dw3B,QAAQ;gBACRD,UAAU,EAAEgP,MAAM,CAACrxB,EAAE,CAACnhB;cACxB,CAAC,CAAC;YACJ;YACAsd,IAAI,CAACw7B,OAAO,GAAGA,OAAO,CAACE,aAAa;YACpC,IAAI,CAAClZ,MAAM,CAAW,CAAA,CAAA;YACtB,OAAO,IAAI,CAACje,UAAU,CAACvE,IAAI,EAAE,gBAAgB,CAAC;UAChD,CAAC,MAAM;YACL,IAAI,CAAC+F,KAAK,CAAC0f,UAAU,CAACY,4BAA4B,EAAE;cAClD5gC,EAAE,EAAE22C,OAAO;cACXjW;YACF,CAAC,CAAC;YACF,OAAOkW,KAAK,EAAE;UAChB;QACF;IAAA;EAEJ;EAEA5J,wBAAwBA,CAACzyB,IAAoB,EAAU;IACrD,MAAM6D,EAAE,GAAG,IAAI,CAACqnB,eAAe,EAAE;IACjClrB,IAAI,CAAC6D,EAAE,GAAGA,EAAE;IACZ7D,IAAI,CAACgD,IAAI,GAAG,IAAI,CAACm5B,YAAY,CAAC,IAAI,CAAC93B,SAAS,EAAE,EAAER,EAAE,CAAC;IACnD,OAAO,IAAI,CAACU,UAAU,CAACvE,IAAI,EAAE,iBAAiB,CAAC;EACjD;EAGA65B,mBAAmBA,CAAAA,EAAY;IAC7B,MAAMjwB,IAAI,GAAG,IAAI,CAACmP,cAAc,EAAE;IAClC,IAAI,IAAI,CAACtH,KAAK,CAACC,UAAU,CAAC9H,IAAI,CAAC,KAAA,EAAuB,EAAE;MACtD,MAAM8yB,SAAS,GAAG,IAAI,CAACjrB,KAAK,CAACC,UAAU,CAAC9H,IAAI,GAAG,CAAC,CAAC;MACjD,OACE8yB,SAAS,KAAA,EAAuB,IAAIA,SAAS,KAAuB,EAAA;IAExE;IACA,OAAO,KAAK;EACd;EAEA3D,6BAA6BA,CAAC/4B,IAAY,EAAE;IAC1C,OAAOA,IAAI,CAAC3N,IAAI,KAAK,oBAAoB,GAAG2N,IAAI,CAACyB,UAAU,GAAGzB,IAAI;EACpE;AACF,CAAC;AC1uHH,MAAM28B,QAGL,GAAG;EACFC,SAAS,EAAE,IAAI;EACfC,IAAI,EAAE,QAAQ;EACdC,GAAG,EAAE,GAAG;EACRC,IAAI,EAAE,QAAQ;EACdj2C,EAAE,EAAE,GAAG;EACPC,EAAE,EAAE,GAAG;EACPi2C,IAAI,EAAE,QAAQ;EACdC,KAAK,EAAE,QAAQ;EACfC,IAAI,EAAE,QAAQ;EACdC,KAAK,EAAE,QAAQ;EACfC,MAAM,EAAE,QAAQ;EAChBC,GAAG,EAAE,QAAQ;EACbC,MAAM,EAAE,QAAQ;EAChBC,IAAI,EAAE,QAAQ;EACdC,GAAG,EAAE,QAAQ;EACbC,IAAI,EAAE,QAAQ;EACdC,IAAI,EAAE,QAAQ;EACdC,KAAK,EAAE,QAAQ;EACfC,GAAG,EAAE,QAAQ;EACbC,GAAG,EAAE,QAAQ;EACbC,GAAG,EAAE,QAAQ;EACbC,IAAI,EAAE,QAAQ;EACdC,GAAG,EAAE,QAAQ;EACbC,MAAM,EAAE,QAAQ;EAChBC,IAAI,EAAE,QAAQ;EACdC,IAAI,EAAE,QAAQ;EACdC,KAAK,EAAE,QAAQ;EACfC,KAAK,EAAE,QAAQ;EACfC,IAAI,EAAE,QAAQ;EACdC,MAAM,EAAE,QAAQ;EAChBC,KAAK,EAAE,QAAQ;EACfC,IAAI,EAAE,QAAQ;EACdC,IAAI,EAAE,QAAQ;EACdC,KAAK,EAAE,QAAQ;EACfC,MAAM,EAAE,QAAQ;EAChBC,MAAM,EAAE,QAAQ;EAChBC,MAAM,EAAE,QAAQ;EAChBC,MAAM,EAAE,QAAQ;EAChBC,MAAM,EAAE,QAAQ;EAChBC,MAAM,EAAE,QAAQ;EAChBC,KAAK,EAAE,QAAQ;EACfC,MAAM,EAAE,QAAQ;EAChBC,IAAI,EAAE,QAAQ;EACdC,KAAK,EAAE,QAAQ;EACfC,KAAK,EAAE,QAAQ;EACfC,MAAM,EAAE,QAAQ;EAChBC,MAAM,EAAE,QAAQ;EAChBC,MAAM,EAAE,QAAQ;EAChBC,KAAK,EAAE,QAAQ;EACfC,IAAI,EAAE,QAAQ;EACdC,MAAM,EAAE,QAAQ;EAChBC,MAAM,EAAE,QAAQ;EAChBC,KAAK,EAAE,QAAQ;EACfC,IAAI,EAAE,QAAQ;EACdC,GAAG,EAAE,QAAQ;EACbC,MAAM,EAAE,QAAQ;EAChBC,MAAM,EAAE,QAAQ;EAChBC,MAAM,EAAE,QAAQ;EAChBC,KAAK,EAAE,QAAQ;EACfC,MAAM,EAAE,QAAQ;EAChBC,IAAI,EAAE,QAAQ;EACdC,KAAK,EAAE,QAAQ;EACfC,MAAM,EAAE,QAAQ;EAChBC,MAAM,EAAE,QAAQ;EAChBC,MAAM,EAAE,QAAQ;EAChBC,KAAK,EAAE,QAAQ;EACfC,IAAI,EAAE,QAAQ;EACdC,MAAM,EAAE,QAAQ;EAChBC,KAAK,EAAE,QAAQ;EACfC,KAAK,EAAE,QAAQ;EACfC,MAAM,EAAE,QAAQ;EAChBC,MAAM,EAAE,QAAQ;EAChBC,KAAK,EAAE,QAAQ;EACfC,MAAM,EAAE,QAAQ;EAChBC,IAAI,EAAE,QAAQ;EACdC,KAAK,EAAE,QAAQ;EACfC,KAAK,EAAE,QAAQ;EACfC,MAAM,EAAE,QAAQ;EAChBC,MAAM,EAAE,QAAQ;EAChBC,MAAM,EAAE,QAAQ;EAChBC,KAAK,EAAE,QAAQ;EACfC,IAAI,EAAE,QAAQ;EACdC,MAAM,EAAE,QAAQ;EAChBC,MAAM,EAAE,QAAQ;EAChBC,KAAK,EAAE,QAAQ;EACfC,IAAI,EAAE,QAAQ;EACdC,GAAG,EAAE,QAAQ;EACbC,MAAM,EAAE,QAAQ;EAChBC,MAAM,EAAE,QAAQ;EAChBC,MAAM,EAAE,QAAQ;EAChBC,KAAK,EAAE,QAAQ;EACfC,MAAM,EAAE,QAAQ;EAChBC,IAAI,EAAE,QAAQ;EACdC,MAAM,EAAE,QAAQ;EAChBC,MAAM,EAAE,QAAQ;EAChBC,MAAM,EAAE,QAAQ;EAChBC,MAAM,EAAE,QAAQ;EAChBC,KAAK,EAAE,QAAQ;EACfC,IAAI,EAAE,QAAQ;EACdC,MAAM,EAAE,QAAQ;EAChBC,KAAK,EAAE,QAAQ;EACfC,IAAI,EAAE,QAAQ;EACdC,KAAK,EAAE,QAAQ;EACfC,KAAK,EAAE,QAAQ;EACfC,MAAM,EAAE,QAAQ;EAChBC,MAAM,EAAE,QAAQ;EAChBC,IAAI,EAAE,QAAQ;EACdC,IAAI,EAAE,QAAQ;EACdC,IAAI,EAAE,QAAQ;EACdn9C,KAAK,EAAE,QAAQ;EACfo9C,KAAK,EAAE,QAAQ;EACfC,IAAI,EAAE,QAAQ;EACdC,KAAK,EAAE,QAAQ;EACfC,KAAK,EAAE,QAAQ;EACfC,OAAO,EAAE,QAAQ;EACjBC,IAAI,EAAE,QAAQ;EACdC,GAAG,EAAE,QAAQ;EACbC,KAAK,EAAE,QAAQ;EACfC,IAAI,EAAE,QAAQ;EACdC,KAAK,EAAE,QAAQ;EACfC,MAAM,EAAE,QAAQ;EAChBC,EAAE,EAAE,QAAQ;EACZC,EAAE,EAAE,QAAQ;EACZC,EAAE,EAAE,QAAQ;EACZC,OAAO,EAAE,QAAQ;EACjBC,EAAE,EAAE,QAAQ;EACZC,GAAG,EAAE,QAAQ;EACbC,KAAK,EAAE,QAAQ;EACfC,GAAG,EAAE,QAAQ;EACbC,OAAO,EAAE,QAAQ;EACjBC,GAAG,EAAE,QAAQ;EACbC,GAAG,EAAE,QAAQ;EACbC,GAAG,EAAE,QAAQ;EACbC,KAAK,EAAE,QAAQ;EACfC,KAAK,EAAE,QAAQ;EACfC,IAAI,EAAE,QAAQ;EACdC,KAAK,EAAE,QAAQ;EACfC,KAAK,EAAE,QAAQ;EACfC,OAAO,EAAE,QAAQ;EACjBC,IAAI,EAAE,QAAQ;EACdC,GAAG,EAAE,QAAQ;EACbC,KAAK,EAAE,QAAQ;EACfC,IAAI,EAAE,QAAQ;EACdC,KAAK,EAAE,QAAQ;EACfC,MAAM,EAAE,QAAQ;EAChBC,EAAE,EAAE,QAAQ;EACZC,EAAE,EAAE,QAAQ;EACZC,EAAE,EAAE,QAAQ;EACZC,OAAO,EAAE,QAAQ;EACjBC,EAAE,EAAE,QAAQ;EACZC,GAAG,EAAE,QAAQ;EACbC,MAAM,EAAE,QAAQ;EAChBC,KAAK,EAAE,QAAQ;EACfC,GAAG,EAAE,QAAQ;EACbC,OAAO,EAAE,QAAQ;EACjBC,GAAG,EAAE,QAAQ;EACbC,GAAG,EAAE,QAAQ;EACbC,GAAG,EAAE,QAAQ;EACbC,KAAK,EAAE,QAAQ;EACfC,QAAQ,EAAE,QAAQ;EAClBC,KAAK,EAAE,QAAQ;EACfC,GAAG,EAAE,QAAQ;EACbC,IAAI,EAAE,QAAQ;EACdC,IAAI,EAAE,QAAQ;EACdC,MAAM,EAAE,QAAQ;EAChBC,IAAI,EAAE,QAAQ;EACdC,GAAG,EAAE,QAAQ;EACbC,GAAG,EAAE,QAAQ;EACbC,GAAG,EAAE,QAAQ;EACbC,KAAK,EAAE,QAAQ;EACfC,KAAK,EAAE,QAAQ;EACfC,KAAK,EAAE,QAAQ;EACfC,KAAK,EAAE,QAAQ;EACfC,KAAK,EAAE,QAAQ;EACfC,KAAK,EAAE,QAAQ;EACfC,KAAK,EAAE,QAAQ;EACfC,KAAK,EAAE,QAAQ;EACfC,MAAM,EAAE,QAAQ;EAChBC,MAAM,EAAE,QAAQ;EAChBC,IAAI,EAAE,QAAQ;EACdC,MAAM,EAAE,QAAQ;EAChBC,MAAM,EAAE,QAAQ;EAChBC,KAAK,EAAE,QAAQ;EACfC,KAAK,EAAE,QAAQ;EACfC,MAAM,EAAE,QAAQ;EAChBC,MAAM,EAAE,QAAQ;EAChBC,KAAK,EAAE,QAAQ;EACfC,KAAK,EAAE,QAAQ;EACfC,IAAI,EAAE,QAAQ;EACdC,KAAK,EAAE,QAAQ;EACfC,MAAM,EAAE,QAAQ;EAChBC,IAAI,EAAE,QAAQ;EACdC,KAAK,EAAE,QAAQ;EACfC,OAAO,EAAE,QAAQ;EACjBC,IAAI,EAAE,QAAQ;EACdC,IAAI,EAAE,QAAQ;EACdC,IAAI,EAAE,QAAQ;EACdC,IAAI,EAAE,QAAQ;EACdC,IAAI,EAAE,QAAQ;EACdC,KAAK,EAAE,QAAQ;EACfC,IAAI,EAAE,QAAQ;EACdC,IAAI,EAAE,QAAQ;EACdC,IAAI,EAAE,QAAQ;EACdC,IAAI,EAAE,QAAQ;EACdC,IAAI,EAAE,QAAQ;EACdC,MAAM,EAAE,QAAQ;EAChBC,IAAI,EAAE,QAAQ;EACdC,KAAK,EAAE,QAAQ;EACfnN,KAAK,EAAE,QAAQ;EACfoN,KAAK,EAAE,QAAQ;EACfC,IAAI,EAAE,QAAQ;EACdC,KAAK,EAAE,QAAQ;EACfC,EAAE,EAAE,QAAQ;EACZC,IAAI,EAAE,QAAQ;EACdC,GAAG,EAAE,QAAQ;EACbC,KAAK,EAAE,QAAQ;EACfC,MAAM,EAAE,QAAQ;EAChBC,KAAK,EAAE,QAAQ;EACfplC,IAAI,EAAE,QAAQ;EACdqlC,KAAK,EAAE,QAAQ;EACfC,GAAG,EAAE,QAAQ;EACbC,GAAG,EAAE,QAAQ;EACbC,EAAE,EAAE,QAAQ;EACZC,GAAG,EAAE,QAAQ;EACbC,GAAG,EAAE,QAAQ;EACbC,GAAG,EAAE,QAAQ;EACbC,MAAM,EAAE,QAAQ;EAChBC,GAAG,EAAE,QAAQ;EACbC,IAAI,EAAE,QAAQ;EACdC,KAAK,EAAE,QAAQ;EACfC,EAAE,EAAE,QAAQ;EACZC,KAAK,EAAE,QAAQ;EACfC,EAAE,EAAE,QAAQ;EACZC,EAAE,EAAE,QAAQ;EACZC,GAAG,EAAE,QAAQ;EACbC,GAAG,EAAE,QAAQ;EACbC,IAAI,EAAE,QAAQ;EACdC,IAAI,EAAE,QAAQ;EACdC,IAAI,EAAE,QAAQ;EACdC,KAAK,EAAE,QAAQ;EACfC,MAAM,EAAE,QAAQ;EAChBC,IAAI,EAAE,QAAQ;EACdC,IAAI,EAAE,QAAQ;EACdC,KAAK,EAAE,QAAQ;EACfC,KAAK,EAAE,QAAQ;EACfC,MAAM,EAAE,QAAQ;EAChBC,MAAM,EAAE,QAAQ;EAChBC,IAAI,EAAE,QAAQ;EACdC,IAAI,EAAE,QAAQ;EACdC,GAAG,EAAE,QAAQ;EACbC,MAAM,EAAE,QAAQ;EAChBC,KAAK,EAAE,QAAQ;EACfC,MAAM,EAAE,QAAQ;EAChBC,KAAK,EAAE;AACT,CAAU;AC5OV,MAAMC,SAAS,GAAGntC,cAAe,KAAI,CAAC;EACpCotC,gBAAgB,EACd,8DAA8D;EAChEC,wBAAwB,EAAEA,CAAC;IAAEC;GAA4C,KACxBA,+CAAAA,cAAkB,IAAA;EACnEC,yBAAyB,EAAE,gDAAgD;EAC3EC,4BAA4B,EAC1B,0GAA0G;EAE5GlxC,eAAe,EAAEA,CAAC;IAChBrE,UAAU;IACVw1C;EAIF,CAAC,KACuBx1C,sBAAAA,gCAAgCw1C,UAAW,aAAYx1C,UAAiB,OAAA;EAChGy1C,mBAAmB,EACjB,gEAAgE;EAClEC,sBAAsB,EAAE,4BAA4B;EACpDC,4BAA4B,EAC1B;AACJ,CAAC,CAAC;AAIF,SAASC,UAAUA,CAACt9C,MAA4B,EAAW;EACzD,OAAOA,MAAM,GACTA,MAAM,CAAC4C,IAAI,KAAK,oBAAoB,IAClC5C,MAAM,CAAC4C,IAAI,KAAK,oBAAoB,GACtC,KAAK;AACX;AAIA,SAAS26C,mBAAmBA,CAC1Bv9C,MAAqE,EAC7D;EACR,IAAIA,MAAM,CAAC4C,IAAI,KAAK,eAAe,EAAE;IACnC,OAAO5C,MAAM,CAAC/M,IAAI;EACpB;EAEA,IAAI+M,MAAM,CAAC4C,IAAI,KAAK,mBAAmB,EAAE;IACvC,OAAO5C,MAAM,CAACw9C,SAAS,CAACvqD,IAAI,GAAG,GAAG,GAAG+M,MAAM,CAAC/M,IAAI,CAACA,IAAI;EACvD;EAEA,IAAI+M,MAAM,CAAC4C,IAAI,KAAK,qBAAqB,EAAE;IACzC,OACE26C,mBAAmB,CAACv9C,MAAM,CAACA,MAAM,CAAC,GAClC,GAAG,GACHu9C,mBAAmB,CAACv9C,MAAM,CAAC+zB,QAAQ,CAAC;EAExC;EAGA,MAAM,IAAI7iC,KAAK,CAAC,4BAA4B,GAAG8O,MAAM,CAAC4C,IAAI,CAAC;AAC7D;AAQA,IAAAmmC,GAAA,GAAgBt4B,UAAyB,IACvC,MAAMgtC,cAAc,SAAShtC,UAAU,CAAoC;EAGzEitC,YAAYA,CAAAA,EAAS;IACnB,IAAIj4B,GAAG,GAAG,EAAE;IACZ,IAAIE,UAAU,GAAG,IAAI,CAACvO,KAAK,CAAC5H,GAAG;IAC/B,SAAS;MACP,IAAI,IAAI,CAAC4H,KAAK,CAAC5H,GAAG,IAAI,IAAI,CAAC7Q,MAAM,EAAE;QACjC,MAAM,IAAI,CAAC2X,KAAK,CAACsmC,SAAS,CAACQ,sBAAsB,EAAE;UACjDpnD,EAAE,EAAE,IAAI,CAACohB,KAAK,CAAC3B;QACjB,CAAC,CAAC;MACJ;MAEA,MAAMyP,EAAE,GAAG,IAAI,CAAClD,KAAK,CAACC,UAAU,CAAC,IAAI,CAAC7K,KAAK,CAAC5H,GAAG,CAAC;MAEhD,QAAQ0V,EAAE;QACR,KAAA,EAAA;QACA,KAAA,GAAA;UACE,IAAI,IAAI,CAAC9N,KAAK,CAAC5H,GAAG,KAAK,IAAI,CAAC4H,KAAK,CAAClY,KAAK,EAAE;YACvC,IAAIgmB,EAAE,OAAuB,IAAI,IAAI,CAAC9N,KAAK,CAAC8M,kBAAkB,EAAE;cAC9D,EAAE,IAAI,CAAC9M,KAAK,CAAC5H,GAAG;cAChB,IAAI,CAAC6a,WAAW,CAAgB,GAAA,CAAA;YAClC,CAAC,MAAM;cACL,KAAK,CAACC,gBAAgB,CAACpF,EAAE,CAAC;YAC5B;YACA;UACF;UACAO,GAAG,IAAI,IAAI,CAACzD,KAAK,CAAC2C,KAAK,CAACgB,UAAU,EAAE,IAAI,CAACvO,KAAK,CAAC5H,GAAG,CAAC;UACnD,IAAI,CAAC6a,WAAW,CAAa5E,GAAAA,EAAAA,GAAG,CAAC;UACjC;QAEF,KAAA,EAAA;UACEA,GAAG,IAAI,IAAI,CAACzD,KAAK,CAAC2C,KAAK,CAACgB,UAAU,EAAE,IAAI,CAACvO,KAAK,CAAC5H,GAAG,CAAC;UACnDiW,GAAG,IAAI,IAAI,CAACk4B,aAAa,EAAE;UAC3Bh4B,UAAU,GAAG,IAAI,CAACvO,KAAK,CAAC5H,GAAG;UAC3B;QAEF,KAAA,EAAA;QACA,KAAA,GAAA;QAWA;UACE,IAAI+S,SAAS,CAAC2C,EAAE,CAAC,EAAE;YACjBO,GAAG,IAAI,IAAI,CAACzD,KAAK,CAAC2C,KAAK,CAACgB,UAAU,EAAE,IAAI,CAACvO,KAAK,CAAC5H,GAAG,CAAC;YACnDiW,GAAG,IAAI,IAAI,CAACm4B,cAAc,CAAC,IAAI,CAAC;YAChCj4B,UAAU,GAAG,IAAI,CAACvO,KAAK,CAAC5H,GAAG;UAC7B,CAAC,MAAM;YACL,EAAE,IAAI,CAAC4H,KAAK,CAAC5H,GAAG;UAClB;MAAA;IAEN;EACF;EAEAouC,cAAcA,CAACC,aAAsB,EAAU;IAC7C,MAAM34B,EAAE,GAAG,IAAI,CAAClD,KAAK,CAACC,UAAU,CAAC,IAAI,CAAC7K,KAAK,CAAC5H,GAAG,CAAC;IAChD,IAAIiW,GAAG;IACP,EAAE,IAAI,CAACrO,KAAK,CAAC5H,GAAG;IAChB,IACE0V,EAAE,KAA6B,EAAA,IAC/B,IAAI,CAAClD,KAAK,CAACC,UAAU,CAAC,IAAI,CAAC7K,KAAK,CAAC5H,GAAG,CAAC,OAAuB,EAC5D;MACA,EAAE,IAAI,CAAC4H,KAAK,CAAC5H,GAAG;MAChBiW,GAAG,GAAGo4B,aAAa,GAAG,IAAI,GAAG,MAAM;IACrC,CAAC,MAAM;MACLp4B,GAAG,GAAG5iB,MAAM,CAACqW,YAAY,CAACgM,EAAE,CAAC;IAC/B;IACA,EAAE,IAAI,CAAC9N,KAAK,CAACyL,OAAO;IACpB,IAAI,CAACzL,KAAK,CAAC0L,SAAS,GAAG,IAAI,CAAC1L,KAAK,CAAC5H,GAAG;IAErC,OAAOiW,GAAG;EACZ;EAEAq4B,aAAaA,CAAClwB,KAAa,EAAQ;IACjC,IAAInI,GAAG,GAAG,EAAE;IACZ,IAAIE,UAAU,GAAG,EAAE,IAAI,CAACvO,KAAK,CAAC5H,GAAG;IACjC,SAAS;MACP,IAAI,IAAI,CAAC4H,KAAK,CAAC5H,GAAG,IAAI,IAAI,CAAC7Q,MAAM,EAAE;QACjC,MAAM,IAAI,CAAC2X,KAAK,CAAClG,MAAM,CAACrD,kBAAkB,EAAE;UAC1C/W,EAAE,EAAE,IAAI,CAACohB,KAAK,CAAC3B;QACjB,CAAC,CAAC;MACJ;MAEA,MAAMyP,EAAE,GAAG,IAAI,CAAClD,KAAK,CAACC,UAAU,CAAC,IAAI,CAAC7K,KAAK,CAAC5H,GAAG,CAAC;MAChD,IAAI0V,EAAE,KAAK0I,KAAK,EAAE;MAClB,IAAI1I,EAAE,OAAwB,EAAE;QAC9BO,GAAG,IAAI,IAAI,CAACzD,KAAK,CAAC2C,KAAK,CAACgB,UAAU,EAAE,IAAI,CAACvO,KAAK,CAAC5H,GAAG,CAAC;QACnDiW,GAAG,IAAI,IAAI,CAACk4B,aAAa,EAAE;QAC3Bh4B,UAAU,GAAG,IAAI,CAACvO,KAAK,CAAC5H,GAAG;MAC7B,CAAC,MAAM,IAAI+S,SAAS,CAAC2C,EAAE,CAAC,EAAE;QACxBO,GAAG,IAAI,IAAI,CAACzD,KAAK,CAAC2C,KAAK,CAACgB,UAAU,EAAE,IAAI,CAACvO,KAAK,CAAC5H,GAAG,CAAC;QACnDiW,GAAG,IAAI,IAAI,CAACm4B,cAAc,CAAC,KAAK,CAAC;QACjCj4B,UAAU,GAAG,IAAI,CAACvO,KAAK,CAAC5H,GAAG;MAC7B,CAAC,MAAM;QACL,EAAE,IAAI,CAAC4H,KAAK,CAAC5H,GAAG;MAClB;IACF;IACAiW,GAAG,IAAI,IAAI,CAACzD,KAAK,CAAC2C,KAAK,CAACgB,UAAU,EAAE,IAAI,CAACvO,KAAK,CAAC5H,GAAG,EAAE,CAAC;IACrD,IAAI,CAAC6a,WAAW,CAAY5E,GAAAA,EAAAA,GAAG,CAAC;EAClC;EAEAk4B,aAAaA,CAAAA,EAAW;IACtB,MAAMn3B,QAAQ,GAAG,EAAE,IAAI,CAACpP,KAAK,CAAC5H,GAAG;IACjC,IAAI,IAAI,CAACqa,cAAc,CAAC,IAAI,CAACzS,KAAK,CAAC5H,GAAG,CAAC,KAAA,EAAyB,EAAE;MAChE,EAAE,IAAI,CAAC4H,KAAK,CAAC5H,GAAG;MAEhB,IAAI1I,KAAK,GAAG,EAAE;MACd,IAAI,IAAI,CAAC+iB,cAAc,CAAC,IAAI,CAACzS,KAAK,CAAC5H,GAAG,CAAC,KAAA,GAAyB,EAAE;QAChE1I,KAAK,GAAG,EAAE;QACV,EAAE,IAAI,CAACsQ,KAAK,CAAC5H,GAAG;MAClB;MAEA,MAAMuuC,SAAS,GAAG,IAAI,CAAC/2B,OAAO,CAC5BlgB,KAAK,EACK/W,SAAS,EACJ,KAAK,EACI,MAAM,CAC/B;MACD,IACEguD,SAAS,KAAK,IAAI,IAClB,IAAI,CAACl0B,cAAc,CAAC,IAAI,CAACzS,KAAK,CAAC5H,GAAG,CAAC,OAAwB,EAC3D;QACA,EAAE,IAAI,CAAC4H,KAAK,CAAC5H,GAAG;QAChB,OAAO3M,MAAM,CAACyjB,aAAa,CAACy3B,SAAS,CAAC;MACxC;IACF,CAAC,MAAM;MACL,IAAIC,KAAK,GAAG,CAAC;MACb,IAAI5oD,IAAI,GAAG,KAAK;MAChB,OACE4oD,KAAK,EAAE,GAAG,EAAE,IACZ,IAAI,CAAC5mC,KAAK,CAAC5H,GAAG,GAAG,IAAI,CAAC7Q,MAAM,IAC5B,EAAEvJ,IAAI,GAAG,IAAI,CAACy0B,cAAc,CAAC,IAAI,CAACzS,KAAK,CAAC5H,GAAG,CAAC,IAAA,EAAuB,CAAC,EACpE;QACA,EAAE,IAAI,CAAC4H,KAAK,CAAC5H,GAAG;MAClB;MAEA,IAAIpa,IAAI,EAAE;QACR,MAAM6oD,IAAI,GAAG,IAAI,CAACj8B,KAAK,CAAC2C,KAAK,CAAC6B,QAAQ,EAAE,IAAI,CAACpP,KAAK,CAAC5H,GAAG,CAAC;QACvD,MAAM0uC,MAAM,GAAGC,QAAa,CAACF,IAAI,CAAC;QAClC,EAAE,IAAI,CAAC7mC,KAAK,CAAC5H,GAAG;QAEhB,IAAI0uC,MAAM,EAAE;UACV,OAAOA,MAAM;QACf;MACF;IACF;IAGA,IAAI,CAAC9mC,KAAK,CAAC5H,GAAG,GAAGgX,QAAQ;IACzB,OAAO,GAAG;EACZ;EASA43B,WAAWA,CAAAA,EAAS;IAClB,IAAIl5B,EAAE;IACN,MAAMhmB,KAAK,GAAG,IAAI,CAACkY,KAAK,CAAC5H,GAAG;IAC5B,GAAG;MACD0V,EAAE,GAAG,IAAI,CAAClD,KAAK,CAACC,UAAU,CAAC,EAAE,IAAI,CAAC7K,KAAK,CAAC5H,GAAG,CAAC;IAC7C,CAAA,QAAQ2J,gBAAgB,CAAC+L,EAAE,CAAC,IAAIA,EAAE,KAAmB,EAAA;IACtD,IAAI,CAACmF,WAAW,CAAA,GAAA,EAAa,IAAI,CAACrI,KAAK,CAAC2C,KAAK,CAACzlB,KAAK,EAAE,IAAI,CAACkY,KAAK,CAAC5H,GAAG,CAAC,CAAC;EACvE;EAIA6uC,kBAAkBA,CAAAA,EAAoB;IACpC,MAAM9tC,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAE;IAC7B,IAAI,IAAI,CAAC6R,KAAK,CAAA,GAAA,CAAY,EAAE;MAC1BlW,IAAI,CAACtd,IAAI,GAAG,IAAI,CAACmkB,KAAK,CAACnX,KAAK;IAC7B,CAAA,MAAM,IAAIpC,cAAc,CAAC,IAAI,CAACuZ,KAAK,CAACxU,IAAI,CAAC,EAAE;MAC1C2N,IAAI,CAACtd,IAAI,GAAGkL,cAAc,CAAC,IAAI,CAACiZ,KAAK,CAACxU,IAAI,CAAC;IAC7C,CAAC,MAAM;MACL,IAAI,CAAC8E,UAAU,EAAE;IACnB;IACA,IAAI,CAACyS,IAAI,EAAE;IACX,OAAO,IAAI,CAACrF,UAAU,CAACvE,IAAI,EAAE,eAAe,CAAC;EAC/C;EAIA+tC,sBAAsBA,CAAAA,EAAwB;IAC5C,MAAM7oC,QAAQ,GAAG,IAAI,CAAC2B,KAAK,CAAC3B,QAAQ;IACpC,MAAMxiB,IAAI,GAAG,IAAI,CAACorD,kBAAkB,EAAE;IACtC,IAAI,CAAC,IAAI,CAACr1B,GAAG,CAAU,EAAA,CAAA,EAAE,OAAO/1B,IAAI;IAEpC,MAAMsd,IAAI,GAAG,IAAI,CAACqlB,WAAW,CAACngB,QAAQ,CAAC;IACvClF,IAAI,CAACitC,SAAS,GAAGvqD,IAAI;IACrBsd,IAAI,CAACtd,IAAI,GAAG,IAAI,CAACorD,kBAAkB,EAAE;IACrC,OAAO,IAAI,CAACvpC,UAAU,CAACvE,IAAI,EAAE,mBAAmB,CAAC;EACnD;EAKAguC,mBAAmBA,CAAAA,EAGO;IACxB,MAAM9oC,QAAQ,GAAG,IAAI,CAAC2B,KAAK,CAAC3B,QAAQ;IACpC,IAAIlF,IAAI,GAAG,IAAI,CAAC+tC,sBAAsB,EAAE;IACxC,IAAI/tC,IAAI,CAAC3N,IAAI,KAAK,mBAAmB,EAAE;MACrC,OAAO2N,IAAI;IACb;IACA,OAAO,IAAI,CAACyY,GAAG,CAAA,EAAA,CAAQ,EAAE;MACvB,MAAMoM,OAAO,GAAG,IAAI,CAACQ,WAAW,CAACngB,QAAQ,CAAC;MAC1C2f,OAAO,CAACp1B,MAAM,GAAGuQ,IAAI;MACrB6kB,OAAO,CAACrB,QAAQ,GAAG,IAAI,CAACsqB,kBAAkB,EAAE;MAC5C9tC,IAAI,GAAG,IAAI,CAACuE,UAAU,CAACsgB,OAAO,EAAE,qBAAqB,CAAC;IACxD;IACA,OAAO7kB,IAAI;EACb;EAIAiuC,sBAAsBA,CAAAA,EAAiB;IACrC,IAAIjuC,IAAI;IACR,QAAQ,IAAI,CAAC6G,KAAK,CAACxU,IAAI;MACrB,KAAA,CAAA;QACE2N,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAE;QACvB,IAAI,CAAC6pC,UAAU,CAAC//C,KAAE,CAAC9M,KAAK,CAAC;QACzB,IAAI,CAACuoB,IAAI,EAAE;QACX5J,IAAI,GAAG,IAAI,CAACmuC,2BAA2B,CAACnuC,IAAI,EAAE7R,KAAE,CAAC7M,MAAM,CAAC;QACxD,IAAI0e,IAAI,CAACyB,UAAU,CAACpP,IAAI,KAAK,oBAAoB,EAAE;UACjD,IAAI,CAAC0T,KAAK,CAACsmC,SAAS,CAACC,gBAAgB,EAAE;YAAE7mD,EAAE,EAAEua;UAAK,CAAC,CAAC;QACtD;QACA,OAAOA,IAAI;MAEb,KAAA,GAAA;MACA,KAAA,GAAA;QACE,OAAO,IAAI,CAACqsB,aAAa,EAAE;MAE7B;QACE,MAAM,IAAI,CAACtmB,KAAK,CAACsmC,SAAS,CAACO,mBAAmB,EAAE;UAC9CnnD,EAAE,EAAE,IAAI,CAACohB,KAAK,CAAC3B;QACjB,CAAC,CAAC;IAAA;EAER;EAMAkpC,uBAAuBA,CAAAA,EAAyB;IAC9C,MAAMpuC,IAAI,GAAG,IAAI,CAACqlB,WAAW,CAAC,IAAI,CAACxe,KAAK,CAACoB,aAAa,CAAC;IACvD,OAAO,IAAI,CAACH,YAAY,CAAC9H,IAAI,EAAE,oBAAoB,EAAE,IAAI,CAAC6G,KAAK,CAAC3B,QAAQ,CAAC;EAC3E;EAIAmpC,mBAAmBA,CAACruC,IAA8B,EAAoB;IACpE,IAAI,CAAC4J,IAAI,EAAE;IACX5J,IAAI,CAACyB,UAAU,GAAG,IAAI,CAACmpB,eAAe,EAAE;IACxC,IAAI,CAACsjB,UAAU,CAAC//C,KAAE,CAAC3M,MAAM,CAAC;IAC1B,IAAI,CAACqlB,KAAK,CAAC8M,kBAAkB,GAAG,IAAI;IACpC,IAAI,CAAC6O,MAAM,CAAW,CAAA,CAAA;IAEtB,OAAO,IAAI,CAACje,UAAU,CAACvE,IAAI,EAAE,gBAAgB,CAAC;EAChD;EAIAmuC,2BAA2BA,CACzBnuC,IAAsC,EACtCsuC,eAA2B,EACD;IAC1B,IAAI,IAAI,CAACp4B,KAAK,CAAA,CAAA,CAAW,EAAE;MACzBlW,IAAI,CAACyB,UAAU,GAAG,IAAI,CAAC2sC,uBAAuB,EAAE;IAClD,CAAC,MAAM;MACL,MAAM3sC,UAAU,GAAG,IAAI,CAACmpB,eAAe,EAAE;MAazC5qB,IAAI,CAACyB,UAAU,GAAGA,UAAU;IAC9B;IACA,IAAI,CAACysC,UAAU,CAACI,eAAe,CAAC;IAChC,IAAI,CAACznC,KAAK,CAAC8M,kBAAkB,GAAG,IAAI;IACpC,IAAI,CAAC6O,MAAM,CAAW,CAAA,CAAA;IAEtB,OAAO,IAAI,CAACje,UAAU,CAACvE,IAAI,EAAE,wBAAwB,CAAC;EACxD;EAIAuuC,iBAAiBA,CAAAA,EAAmB;IAClC,MAAMvuC,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAE;IAC7B,IAAI,IAAI,CAAC6R,KAAK,CAAA,CAAA,CAAW,EAAE;MACzB,IAAI,CAACg4B,UAAU,CAAC//C,KAAE,CAAC9M,KAAK,CAAC;MACzB,IAAI,CAACuoB,IAAI,EAAE;MACX,IAAI,CAAC4Y,MAAM,CAAa,EAAA,CAAA;MACxBxiB,IAAI,CAACb,QAAQ,GAAG,IAAI,CAACs0B,uBAAuB,EAAE;MAC9C,IAAI,CAACya,UAAU,CAAC//C,KAAE,CAAC7M,MAAM,CAAC;MAC1B,IAAI,CAACulB,KAAK,CAAC8M,kBAAkB,GAAG,IAAI;MACpC,IAAI,CAAC6O,MAAM,CAAW,CAAA,CAAA;MACtB,OAAO,IAAI,CAACje,UAAU,CAACvE,IAAI,EAAE,oBAAoB,CAAC;IACpD;IACAA,IAAI,CAACtd,IAAI,GAAG,IAAI,CAACqrD,sBAAsB,EAAE;IACzC/tC,IAAI,CAACtQ,KAAK,GAAG,IAAI,CAAC+oB,GAAG,CAAO,EAAA,CAAA,GAAG,IAAI,CAACw1B,sBAAsB,EAAE,GAAG,IAAI;IACnE,OAAO,IAAI,CAAC1pC,UAAU,CAACvE,IAAI,EAAE,cAAc,CAAC;EAC9C;EAIAwuC,wBAAwBA,CAACtpC,QAAkB,EAAuB;IAChE,MAAMlF,IAAI,GAAG,IAAI,CAACqlB,WAAW,CAC3BngB,QAAQ,CACT;IACD,IAAI,IAAI,CAACuT,GAAG,CAAA,GAAA,CAAc,EAAE;MAE1B,OAAO,IAAI,CAAClU,UAAU,CAACvE,IAAI,EAAE,oBAAoB,CAAC;IACpD;IACAA,IAAI,CAACtd,IAAI,GAAG,IAAI,CAACsrD,mBAAmB,EAAE;IACtC,OAAO,IAAI,CAACS,+BAA+B,CACzCzuC,IAAI,CACL;EACH;EAEAyuC,+BAA+BA,CAC7BzuC,IAAiC,EACZ;IACrB,MAAMwG,UAA4B,GAAG,EAAE;IACvC,OAAO,CAAC,IAAI,CAAC0P,KAAK,CAAA,EAAA,CAAU,IAAI,CAAC,IAAI,CAACA,KAAK,CAAA,GAAA,CAAc,EAAE;MACzD1P,UAAU,CAAC/iB,IAAI,CAAC,IAAI,CAAC8qD,iBAAiB,EAAE,CAAC;IAC3C;IACAvuC,IAAI,CAACwG,UAAU,GAAGA,UAAU;IAC5BxG,IAAI,CAAC0uC,WAAW,GAAG,IAAI,CAACj2B,GAAG,CAAU,EAAA,CAAA;IACrC,IAAI,CAAC+J,MAAM,CAAc,GAAA,CAAA;IACzB,OAAO,IAAI,CAACje,UAAU,CAACvE,IAAI,EAAE,mBAAmB,CAAC;EACnD;EAIA2uC,wBAAwBA,CAACzpC,QAAkB,EAAuB;IAChE,MAAMlF,IAAI,GAAG,IAAI,CAACqlB,WAAW,CAACngB,QAAQ,CAAC;IACvC,IAAI,IAAI,CAACuT,GAAG,CAAA,GAAA,CAAc,EAAE;MAC1B,OAAO,IAAI,CAAClU,UAAU,CAACvE,IAAI,EAAE,oBAAoB,CAAC;IACpD;IACAA,IAAI,CAACtd,IAAI,GAAG,IAAI,CAACsrD,mBAAmB,EAAE;IACtC,IAAI,CAACxrB,MAAM,CAAc,GAAA,CAAA;IACzB,OAAO,IAAI,CAACje,UAAU,CAACvE,IAAI,EAAE,mBAAmB,CAAC;EACnD;EAKA4uC,iBAAiBA,CAAC1pC,QAAkB,EAAgB;IAClD,MAAMlF,IAAI,GAAG,IAAI,CAACqlB,WAAW,CAACngB,QAAQ,CAAC;IACvC,MAAM2pC,QAAQ,GAAG,EAAE;IACnB,MAAMC,cAAc,GAAG,IAAI,CAACN,wBAAwB,CAACtpC,QAAQ,CAAC;IAC9D,IAAI6pC,cAAc,GAAG,IAAI;IAEzB,IAAI,CAACD,cAAc,CAACJ,WAAW,EAAE;MAC/BM,QAAQ,EAAE,SAAS;QACjB,QAAQ,IAAI,CAACnoC,KAAK,CAACxU,IAAI;UACrB,KAAA,GAAA;YACE6S,QAAQ,GAAG,IAAI,CAAC2B,KAAK,CAAC3B,QAAQ;YAC9B,IAAI,CAAC0E,IAAI,EAAE;YACX,IAAI,IAAI,CAAC6O,GAAG,CAAA,EAAA,CAAU,EAAE;cACtBs2B,cAAc,GAAG,IAAI,CAACJ,wBAAwB,CAACzpC,QAAQ,CAAC;cACxD,MAAM8pC,QAAQ;YAChB;YACAH,QAAQ,CAACprD,IAAI,CAAC,IAAI,CAACmrD,iBAAiB,CAAC1pC,QAAQ,CAAC,CAAC;YAC/C;UAEF,KAAA,GAAA;YACE2pC,QAAQ,CAACprD,IAAI,CAAC,IAAI,CAAC4oC,aAAa,EAAE,CAAC;YACnC;UAEF,KAAA,CAAA;YAAgB;cACd,MAAMrsB,IAAI,GAAG,IAAI,CAACqE,SAAS,EAExB;cACH,IAAI,CAAC6pC,UAAU,CAAC//C,KAAE,CAAC9M,KAAK,CAAC;cACzB,IAAI,CAACuoB,IAAI,EAAE;cACX,IAAI,IAAI,CAACsM,KAAK,CAAA,EAAA,CAAa,EAAE;gBAC3B24B,QAAQ,CAACprD,IAAI,CAAC,IAAI,CAAC4qD,mBAAmB,CAACruC,IAAI,CAAC,CAAC;cAC/C,CAAC,MAAM;gBACL6uC,QAAQ,CAACprD,IAAI,CACX,IAAI,CAAC0qD,2BAA2B,CAACnuC,IAAI,EAAE7R,KAAE,CAAC3M,MAAM,CAAC,CAClD;cACH;cAEA;YACF;UAEA;YACE,IAAI,CAAC2V,UAAU,EAAE;QAAA;MAEvB;MAEA,IACE41C,UAAU,CAAC+B,cAAc,CAAC,IAC1B,CAAC/B,UAAU,CAACgC,cAAc,CAAC,IAC3BA,cAAc,KAAK,IAAI,EACvB;QACA,IAAI,CAAChpC,KAAK,CAACsmC,SAAS,CAACI,yBAAyB,EAAE;UAC9ChnD,EAAE,EAAEspD;QACN,CAAC,CAAC;MACJ,CAAC,MAAM,IAAI,CAAChC,UAAU,CAAC+B,cAAc,CAAC,IAAI/B,UAAU,CAACgC,cAAc,CAAC,EAAE;QACpE,IAAI,CAAChpC,KAAK,CAACsmC,SAAS,CAACE,wBAAwB,EAAE;UAC7C9mD,EAAE,EAAEspD,cAAc;UAClBvC,cAAc,EAAEQ,mBAAmB,CAAC8B,cAAc,CAACpsD,IAAI;QACzD,CAAC,CAAC;MACJ,CAAC,MAAM,IAAI,CAACqqD,UAAU,CAAC+B,cAAc,CAAC,IAAI,CAAC/B,UAAU,CAACgC,cAAc,CAAC,EAAE;QACrE,IACE/B,mBAAmB,CAAC+B,cAAc,CAACrsD,IAAI,CAAC,KACxCsqD,mBAAmB,CAAC8B,cAAc,CAACpsD,IAAI,CAAC,EACxC;UACA,IAAI,CAACqjB,KAAK,CAACsmC,SAAS,CAACE,wBAAwB,EAAE;YAC7C9mD,EAAE,EAAEspD,cAAc;YAClBvC,cAAc,EAAEQ,mBAAmB,CAAC8B,cAAc,CAACpsD,IAAI;UACzD,CAAC,CAAC;QACJ;MACF;IACF;IAEA,IAAIqqD,UAAU,CAAC+B,cAAc,CAAC,EAAE;MAC9B9uC,IAAI,CAACivC,eAAe,GAAGH,cAAc;MACrC9uC,IAAI,CAACkvC,eAAe,GAAGH,cAAc;IACvC,CAAC,MAAM;MACL/uC,IAAI,CAAC8uC,cAAc,GAAGA,cAAc;MACpC9uC,IAAI,CAAC+uC,cAAc,GAAGA,cAAc;IACtC;IACA/uC,IAAI,CAAC6uC,QAAQ,GAAGA,QAAQ;IACxB,IAAI,IAAI,CAAC34B,KAAK,CAAA,EAAA,CAAO,EAAE;MACrB,MAAM,IAAI,CAACnQ,KAAK,CAACsmC,SAAS,CAACS,4BAA4B,EAAE;QACvDrnD,EAAE,EAAE,IAAI,CAACohB,KAAK,CAAC3B;MACjB,CAAC,CAAC;IACJ;IAEA,OAAO6nC,UAAU,CAAC+B,cAAc,CAAC,GAC7B,IAAI,CAACvqC,UAAU,CAACvE,IAAI,EAAE,aAAa,CAAC,GACpC,IAAI,CAACuE,UAAU,CAACvE,IAAI,EAAE,YAAY,CAAC;EACzC;EAIAmvC,eAAeA,CAAAA,EAAiB;IAC9B,MAAMjqC,QAAQ,GAAG,IAAI,CAAC2B,KAAK,CAAC3B,QAAQ;IACpC,IAAI,CAAC0E,IAAI,EAAE;IACX,OAAO,IAAI,CAACglC,iBAAiB,CAAC1pC,QAAQ,CAAC;EACzC;EAEAgpC,UAAUA,CAACkB,UAAsB,EAAE;IACjC,MAAM;MAAEnhD;KAAS,GAAG,IAAI,CAAC4Y,KAAK;IAC9B5Y,OAAO,CAACA,OAAO,CAACG,MAAM,GAAG,CAAC,CAAC,GAAGghD,UAAU;EAC1C;EAMA/iB,aAAaA,CAAClnB,mBAA6C,EAAgB;IACzE,IAAI,IAAI,CAAC+Q,KAAK,CAAA,GAAA,CAAY,EAAE;MAC1B,OAAO,IAAI,CAAChV,YAAY,CAAC,IAAI,CAAC2F,KAAK,CAACnX,KAAK,EAAE,SAAS,CAAC;IACtD,CAAA,MAAM,IAAI,IAAI,CAACwmB,KAAK,KAAgB,EAAE;MACrC,OAAO,IAAI,CAACi5B,eAAe,EAAE;IAC9B,CAAA,MAAM,IACL,IAAI,CAACj5B,KAAK,CAAO,EAAA,CAAA,IACjB,IAAI,CAACzE,KAAK,CAACC,UAAU,CAAC,IAAI,CAAC7K,KAAK,CAAC5H,GAAG,CAAC,OAA8B,EACnE;MAGA,IAAI,CAACsb,YAAY,CAAgB,GAAA,CAAA;MACjC,OAAO,IAAI,CAAC40B,eAAe,EAAE;IAC/B,CAAC,MAAM;MACL,OAAO,KAAK,CAAC9iB,aAAa,CAAClnB,mBAAmB,CAAC;IACjD;EACF;EAEA0U,SAASA,CAAAA,EAAG;IACV,MAAMlB,UAAU,GAAG,IAAI,CAACA,UAAU,EAAE;IACpC,IAAI,CAACA,UAAU,CAACx3B,aAAa,EAAE,KAAK,CAAC04B,SAAS,EAAE;EAClD;EAEAE,gBAAgBA,CAACppB,IAAY,EAAQ;IACnC,MAAM1C,OAAO,GAAG,IAAI,CAAC0qB,UAAU,EAAE;IAEjC,IAAI1qB,OAAO,KAAKE,KAAE,CAAC3M,MAAM,EAAE;MACzB,IAAI,CAAC2rD,YAAY,EAAE;MACnB;IACF;IAEA,IAAIl/C,OAAO,KAAKE,KAAE,CAAC7M,MAAM,IAAI2M,OAAO,KAAKE,KAAE,CAAC5M,MAAM,EAAE;MAClD,IAAIknB,iBAAiB,CAAC9X,IAAI,CAAC,EAAE;QAC3B,IAAI,CAACk9C,WAAW,EAAE;QAClB;MACF;MAEA,IAAIl9C,IAAI,OAA0B,EAAE;QAClC,EAAE,IAAI,CAACkW,KAAK,CAAC5H,GAAG;QAChB,IAAI,CAAC6a,WAAW,CAAc,GAAA,CAAA;QAC9B;MACF;MAEA,IACE,CAACnpB,IAAI,KAA4B,EAAA,IAAIA,IAAI,KAAA,EAAyB,KAClE1C,OAAO,KAAKE,KAAE,CAAC7M,MAAM,EACrB;QACA,IAAI,CAACisD,aAAa,CAAC58C,IAAI,CAAC;QACxB;MACF;IACF;IAEA,IACEA,IAAI,KAAuB,EAAA,IAC3B,IAAI,CAACkW,KAAK,CAAC8M,kBAAkB,IAC7B,IAAI,CAAClC,KAAK,CAACC,UAAU,CAAC,IAAI,CAAC7K,KAAK,CAAC5H,GAAG,GAAG,CAAC,CAAC,KAAA,EAA8B,EACvE;MACA,EAAE,IAAI,CAAC4H,KAAK,CAAC5H,GAAG;MAChB,IAAI,CAAC6a,WAAW,CAAgB,GAAA,CAAA;MAChC;IACF;IAEA,KAAK,CAACC,gBAAgB,CAACppB,IAAI,CAAC;EAC9B;EAEArO,aAAaA,CAACg4B,QAAmB,EAAQ;IACvC,MAAM;MAAErsB,OAAO;MAAEoE;KAAM,GAAG,IAAI,CAACwU,KAAK;IACpC,IAAIxU,IAAI,KAAA,EAAa,IAAIioB,QAAQ,QAAmB,EAAE;MAGpDrsB,OAAO,CAACqjB,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,EAAEnjB,KAAE,CAAC5M,MAAM,CAAC;MAChC,IAAI,CAACslB,KAAK,CAAC8M,kBAAkB,GAAG,KAAK;IACvC,CAAC,MAAM,IAAIthB,IAAI,KAAA,GAAmB,EAAE;MAElCpE,OAAO,CAACxK,IAAI,CAAC0K,KAAE,CAAC7M,MAAM,CAAC;IACzB,CAAC,MAAM,IAAI+Q,IAAI,KAAA,GAAiB,EAAE;MAChC,MAAM6iB,GAAG,GAAGjnB,OAAO,CAACA,OAAO,CAACG,MAAM,GAAG,CAAC,CAAC;MACvC,IAAK8mB,GAAG,KAAK/mB,KAAE,CAAC7M,MAAM,IAAIg5B,QAAQ,KAAa,EAAA,IAAKpF,GAAG,KAAK/mB,KAAE,CAAC5M,MAAM,EAAE;QACrE0M,OAAO,CAACC,GAAG,EAAE;QACb,IAAI,CAAC2Y,KAAK,CAAC8M,kBAAkB,GAC3B1lB,OAAO,CAACA,OAAO,CAACG,MAAM,GAAG,CAAC,CAAC,KAAKD,KAAE,CAAC3M,MAAM;MAC7C,CAAC,MAAM;QACL,IAAI,CAAC0sD,UAAU,CAAC//C,KAAE,CAAC3M,MAAM,CAAC;QAC1B,IAAI,CAACqlB,KAAK,CAAC8M,kBAAkB,GAAG,IAAI;MACtC;IACF,CAAC,MAAM;MACL,IAAI,CAAC9M,KAAK,CAAC8M,kBAAkB,GAAG1mB,0BAA0B,CAACoF,IAAI,CAAC;IAClE;EACF;AACF,CAAC;ACvnBH,MAAMg9C,eAAe,SAASriC,KAAK,CAAC;EAAA/rB,WAAAA,CAAA,GAAAwjB,IAAA,EAAA;IAAA,KAAA,CAAA,GAAAA,IAAA,CAAA;IAAA,IAAA,CAClCrjB,KAAK,GAAgB,IAAIsc,GAAG,EAAE;IAAA,IAAA,CAG9B4xC,KAAK,GAAgB,IAAI5xC,GAAG,EAAE;IAAA,IAAA,CAG9B6xC,UAAU,GAAgB,IAAI7xC,GAAG,EAAE;IAAA,IAAA,CAGnC8xC,OAAO,GAAgB,IAAI9xC,GAAG,EAAE;IAAA,IAAA,CAMhC+xC,kBAAkB,GAAgB,IAAI/xC,GAAG,EAAE;EAAA;AAC7C;AAKe,MAAMgyC,sBAAsB,SAAStiC,YAAY,CAAkB;EAAAnsB,WAAAA,CAAA,GAAAwjB,IAAA,EAAA;IAAA,KAAA,CAAA,GAAAA,IAAA,CAAA;IAAA,IAChFkrC,CAAAA,YAAY,GAAkB,EAAE;EAAA;EAEhCvhC,WAAWA,CAAC5N,KAAiB,EAAmB;IAC9C,IAAI,CAACmvC,YAAY,CAAClsD,IAAI,CAAC,IAAIia,GAAG,EAAE,CAAC;IAEjC,OAAO,IAAI2xC,eAAe,CAAC7uC,KAAK,CAAC;EACnC;EAEA6N,KAAKA,CAAC7N,KAAa,EAAQ;IACzB,IAAIA,KAAK,IAAIiK,eAAe,EAAE;MAC5B,IAAI,CAACklC,YAAY,CAAClsD,IAAI,CAAC,IAAIia,GAAG,EAAE,CAAC;IACnC;IAEA,KAAK,CAAC2Q,KAAK,CAAC7N,KAAK,CAAC;EACpB;EAEA8N,IAAIA,CAAAA,EAAG;IACL,MAAM9N,KAAK,GAAG,KAAK,CAAC8N,IAAI,EAAE;IAE1B,IAAI9N,KAAK,IAAIiK,eAAe,EAAE;MAC5B,IAAI,CAACklC,YAAY,CAACzhD,GAAG,EAAE;IACzB;IAEA,OAAOsS,KAAK;EACd;EAEAovC,SAASA,CAACltD,IAAY,EAAEmtD,WAAqB,EAAE;IAC7C,MAAMv5B,GAAG,GAAG,IAAI,CAACq5B,YAAY,CAACvhD,MAAM;IACpC,IAAI,IAAI,CAACuhD,YAAY,CAACr5B,GAAG,GAAG,CAAC,CAAC,CAAChN,GAAG,CAAC5mB,IAAI,CAAC,EAAE;MACxC,OAAO,IAAI;IACb;IACA,IAAI,CAACmtD,WAAW,IAAIv5B,GAAG,GAAG,CAAC,EAAE;MAC3B,KAAK,IAAI1mB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG0mB,GAAG,GAAG,CAAC,EAAE1mB,CAAC,EAAE,EAAE;QAChC,IAAI,IAAI,CAAC+/C,YAAY,CAAC//C,CAAC,CAAC,CAAC0Z,GAAG,CAAC5mB,IAAI,CAAC,EAAE,OAAO,IAAI;MACjD;IACF;IACA,OAAO,KAAK;EACd;EAEA8rB,WAAWA,CAAC9rB,IAAY,EAAE+rB,WAAyB,EAAE5P,GAAa,EAAE;IAClE,IAAI4P,WAAW,GAAGnD,oBAAoB,EAAE;MACtC,IAAI,IAAI,CAACskC,SAAS,CAACltD,IAAI,EAAE,IAAI,CAAC,EAAE;QAC9B,IAAI,CAAC2qB,MAAM,CAACtH,KAAK,CAAClG,MAAM,CAAClD,gBAAgB,EAAE;UACzClX,EAAE,EAAEoZ,GAAG;UACP/P,cAAc,EAAEpM;QAClB,CAAC,CAAC;MACJ;MACA,IAAI,CAACitD,YAAY,CAAC,IAAI,CAACA,YAAY,CAACvhD,MAAM,GAAG,CAAC,CAAC,CAACugB,GAAG,CAACjsB,IAAI,CAAC;MACzD;IACF;IAEA,MAAM6rB,KAAK,GAAG,IAAI,CAACd,YAAY,EAAE;IACjC,IAAIgB,WAAW,GAAGrD,yBAAyB,EAAE;MAC3C,IAAI,CAACwD,kBAAkB,CAACL,KAAK,EAAE7rB,IAAI,CAAC;MACpC6rB,KAAK,CAACkhC,kBAAkB,CAAC9gC,GAAG,CAACjsB,IAAI,CAAC;MAClC;IACF;IAEA,KAAK,CAAC8rB,WAAW,CAAC9rB,IAAI,EAAE+rB,WAAW,EAAE5P,GAAG,CAAC;IAEzC,IAAI4P,WAAW,GAAG7D,cAAc,EAAE;MAChC,IAAI,EAAE6D,WAAW,GAAG9D,eAAe,CAAC,EAAE;QAEpC,IAAI,CAAC+D,yBAAyB,CAACH,KAAK,EAAE7rB,IAAI,EAAE+rB,WAAW,EAAE5P,GAAG,CAAC;QAC7D,IAAI,CAAC+P,kBAAkB,CAACL,KAAK,EAAE7rB,IAAI,CAAC;MACtC;MACA6rB,KAAK,CAACntB,KAAK,CAACutB,GAAG,CAACjsB,IAAI,CAAC;IACvB;IACA,IAAI+rB,WAAW,GAAGvD,kBAAkB,EAAEqD,KAAK,CAAC+gC,KAAK,CAAC3gC,GAAG,CAACjsB,IAAI,CAAC;IAC3D,IAAI+rB,WAAW,GAAGtD,wBAAwB,EAAEoD,KAAK,CAACghC,UAAU,CAAC5gC,GAAG,CAACjsB,IAAI,CAAC;IACtE,IAAI+rB,WAAW,GAAGxD,gBAAgB,EAAEsD,KAAK,CAACihC,OAAO,CAAC7gC,GAAG,CAACjsB,IAAI,CAAC;EAC7D;EAEAosB,mBAAmBA,CACjBP,KAAsB,EACtB7rB,IAAY,EACZ+rB,WAAyB,EAChB;IACT,IAAIF,KAAK,CAAC+gC,KAAK,CAAChmC,GAAG,CAAC5mB,IAAI,CAAC,EAAE;MACzB,IAAI+rB,WAAW,GAAGvD,kBAAkB,EAAE;QAGpC,MAAM4kC,OAAO,GAAG,CAAC,EAAErhC,WAAW,GAAGtD,wBAAwB,CAAC;QAC1D,MAAM4kC,QAAQ,GAAGxhC,KAAK,CAACghC,UAAU,CAACjmC,GAAG,CAAC5mB,IAAI,CAAC;QAC3C,OAAOotD,OAAO,KAAKC,QAAQ;MAC7B;MACA,OAAO,IAAI;IACb;IACA,IAAIthC,WAAW,GAAGxD,gBAAgB,IAAIsD,KAAK,CAACihC,OAAO,CAAClmC,GAAG,CAAC5mB,IAAI,CAAC,EAAE;MAC7D,IAAI6rB,KAAK,CAACrB,OAAO,CAAC5D,GAAG,CAAC5mB,IAAI,CAAC,EAAE;QAE3B,OAAO,CAAC,EAAE+rB,WAAW,GAAG9D,eAAe,CAAC;MAC1C,CAAC,MAAM;QAEL,OAAO,KAAK;MACd;IACF;IACA,IAAI8D,WAAW,GAAG7D,cAAc,IAAI2D,KAAK,CAACntB,KAAK,CAACkoB,GAAG,CAAC5mB,IAAI,CAAC,EAAE;MACzD,OAAO,IAAI;IACb;IAEA,OAAO,KAAK,CAACosB,mBAAmB,CAACP,KAAK,EAAE7rB,IAAI,EAAE+rB,WAAW,CAAC;EAC5D;EAEAO,gBAAgBA,CAACnL,EAAgB,EAAE;IACjC,MAAM;MAAEnhB;IAAM,CAAA,GAAGmhB,EAAE;IAEnB,IAAI,IAAI,CAAC+rC,SAAS,CAACltD,IAAI,CAAC,EAAE;IAE1B,MAAM4zB,GAAG,GAAG,IAAI,CAAChJ,UAAU,CAAClf,MAAM;IAClC,KAAK,IAAIwB,CAAC,GAAG0mB,GAAG,GAAG,CAAC,EAAE1mB,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;MACjC,MAAM2e,KAAK,GAAG,IAAI,CAACjB,UAAU,CAAC1d,CAAC,CAAC;MAChC,IAAI2e,KAAK,CAACntB,KAAK,CAACkoB,GAAG,CAAC5mB,IAAI,CAAC,IAAI6rB,KAAK,CAACkhC,kBAAkB,CAACnmC,GAAG,CAAC5mB,IAAI,CAAC,EAAE;IACnE;IAEA,KAAK,CAACssB,gBAAgB,CAACnL,EAAE,CAAC;EAC5B;AACF;ACxHA,MAAMmsC,QAAM,GAAGA,CAAevgD,MAAS,EAAE5O,GAAY,KACnDC,MAAM,CAACmvD,cAAc,CAAC7X,IAAI,CAAC3oC,MAAM,EAAE5O,GAAG,CAAC,IAAI4O,MAAM,CAAC5O,GAAG,CAAC;AAExD,MAAMqvD,6BAA6B,GAAIlwC,IAAU,IAAW;EAC1D,OAAOA,IAAI,CAAC3N,IAAI,KAAK,yBAAyB,GAC1C69C,6BAA6B,CAAClwC,IAAI,CAACyB,UAAU,CAAC,GAC9CzB,IAAI;AACV,CAAC;AAQc,MAAemwC,UAAU,SAAS/qB,SAAS,CAAC;EAqDzD3f,YAAYA,CAACzF,IAAU,EAAE0F,KAAc,GAAG,KAAK,EAAQ;IAAA,IAAAouB,WAAA,EAAAsc,YAAA;IACrD,IAAI5tC,aAAa,GAAGhjB,SAAS;IAC7B,IAAIwgB,IAAI,CAAC3N,IAAI,KAAK,yBAAyB,IAAAyhC,CAAAA,WAAA,GAAI9zB,IAAI,CAAC2B,KAAK,KAAA,IAAA,IAAVmyB,WAAA,CAAYtxB,aAAa,EAAE;MACxEA,aAAa,GAAG0tC,6BAA6B,CAAClwC,IAAI,CAAC;MACnD,IAAI0F,KAAK,EAAE;QAKT,IAAIlD,aAAa,CAACnQ,IAAI,KAAK,YAAY,EAAE;UACvC,IAAI,CAAC8xB,eAAe,CAAC/D,gCAAgC,CACnDvgB,MAAM,CAACzI,8BAA8B,EACrC;YAAE3R,EAAE,EAAEua;UAAK,CAAC,CACb;QACH,CAAC,MAAM,IAAIwC,aAAa,CAACnQ,IAAI,KAAK,kBAAkB,EAAE;UAIpD,IAAI,CAAC0T,KAAK,CAAClG,MAAM,CAACzI,8BAA8B,EAAE;YAAE3R,EAAE,EAAEua;UAAK,CAAC,CAAC;QACjE;MACF,CAAC,MAAM;QACL,IAAI,CAAC+F,KAAK,CAAClG,MAAM,CAACzI,8BAA8B,EAAE;UAAE3R,EAAE,EAAEua;QAAK,CAAC,CAAC;MACjE;IACF;IAEA,QAAQA,IAAI,CAAC3N,IAAI;MACf,KAAK,YAAY;MACjB,KAAK,eAAe;MACpB,KAAK,cAAc;MACnB,KAAK,mBAAmB;MACxB,KAAK,aAAa;QAChB;MAEF,KAAK,kBAAkB;QACrB2N,IAAI,CAAC3N,IAAI,GAAG,eAAe;QAC3B,KACE,IAAIzC,CAAC,GAAG,CAAC,EAAExB,MAAM,GAAG4R,IAAI,CAAClQ,UAAU,CAAC1B,MAAM,EAAEkB,IAAI,GAAGlB,MAAM,GAAG,CAAC,EAC7DwB,CAAC,GAAGxB,MAAM,EACVwB,CAAC,EAAE,EACH;UAAA,IAAAygD,YAAA;UACA,MAAMxrC,IAAI,GAAG7E,IAAI,CAAClQ,UAAU,CAACF,CAAC,CAAC;UAC/B,MAAMkW,MAAM,GAAGlW,CAAC,KAAKN,IAAI;UACzB,IAAI,CAACuW,gCAAgC,CAAChB,IAAI,EAAEiB,MAAM,EAAEJ,KAAK,CAAC;UAE1D,IACEI,MAAM,IACNjB,IAAI,CAACxS,IAAI,KAAK,aAAa,IAAA,CAAAg+C,YAAA,GAC3BrwC,IAAI,CAAC2B,KAAK,aAAV0uC,YAAA,CAAYrc,gBAAgB,EAC5B;YACA,IAAI,CAACjuB,KAAK,CAAClG,MAAM,CAAC3F,iBAAiB,EAAE;cACnCzU,EAAE,EAAEua,IAAI,CAAC2B,KAAK,CAACqyB;YACjB,CAAC,CAAC;UACJ;QACF;QACA;MAEF,KAAK,gBAAgB;QAAE;UACrB,MAAM;YAAEnzC,GAAG;YAAE6O;UAAO,CAAA,GAAGsQ,IAAI;UAC3B,IAAI,IAAI,CAAC8D,aAAa,CAACjjB,GAAG,CAAC,EAAE;YAC3B,IAAI,CAAC8kB,UAAU,CAACC,cAAc,CAC5B,IAAI,CAAChC,gBAAgB,CAAC/iB,GAAG,CAAC,EAC1BA,GAAG,CAACge,GAAG,CAAClQ,KAAK,CACd;UACH;UACA,IAAI,CAAC8W,YAAY,CAAC/V,KAAK,EAAEgW,KAAK,CAAC;UAC/B;QACF;MAEA,KAAK,eAAe;QAAE;UACpB,MAAM,IAAI/kB,KAAK,CACb,iEAAiE,GAC/D,+DAA+D,CAClE;QACH;MAEA,KAAK,iBAAiB;QACpBqf,IAAI,CAAC3N,IAAI,GAAG,cAAc;QAC1B,IAAI,CAAC0hC,gBAAgB,CACnB/zB,IAAI,CAACuQ,QAAQ,GAAA6/B,YAAA,GACbpwC,IAAI,CAAC2B,KAAK,KAAVyuC,IAAAA,GAAAA,KAAAA,CAAAA,GAAAA,YAAA,CAAYpc,gBAAgB,EAC5BtuB,KAAK,CACN;QACD;MAEF,KAAK,sBAAsB;QACzB,IAAI1F,IAAI,CAACswC,QAAQ,KAAK,GAAG,EAAE;UACzB,IAAI,CAACvqC,KAAK,CAAClG,MAAM,CAAC9H,qBAAqB,EAAE;YAAEtS,EAAE,EAAEua,IAAI,CAACu1B,IAAI,CAAC12B,GAAG,CAACjQ;UAAI,CAAC,CAAC;QACrE;QAEAoR,IAAI,CAAC3N,IAAI,GAAG,mBAAmB;QAC/B,OAAO2N,IAAI,CAACswC,QAAQ;QACpB,IAAI,CAAC7qC,YAAY,CAACzF,IAAI,CAACu1B,IAAI,EAAE7vB,KAAK,CAAC;QACnC;MAEF,KAAK,yBAAyB;QAE5B,IAAI,CAACD,YAAY,CAACjD,aAAa,EAAEkD,KAAK,CAAC;QACvC;IAAA;EAMN;EAEAG,gCAAgCA,CAC9BhB,IAAU,EACViB,MAAe,EACfJ,KAAc,EACd;IACA,IAAIb,IAAI,CAACxS,IAAI,KAAK,cAAc,EAAE;MAChC,IAAI,CAAC0T,KAAK,CACRlB,IAAI,CAACpS,IAAI,KAAK,KAAK,IAAIoS,IAAI,CAACpS,IAAI,KAAK,KAAK,GACtCoN,MAAM,CAACnG,kBAAkB,GACzBmG,MAAM,CAAClG,gBAAgB,EAC3B;QAAElU,EAAE,EAAEof,IAAI,CAAChkB;MAAI,CAAC,CACjB;IACH,CAAC,MAAM,IAAIgkB,IAAI,CAACxS,IAAI,KAAK,eAAe,EAAE;MACxCwS,IAAI,CAACxS,IAAI,GAAG,aAAa;MACzB,MAAMk+C,GAAG,GAAG1rC,IAAI,CAAC1F,QAAQ;MACzB,IAAI,CAACqxC,qBAAqB,CAACD,GAAG,EAAqB,KAAK,CAAC;MACzD,IAAI,CAAC9qC,YAAY,CAAC8qC,GAAG,EAAE7qC,KAAK,CAAC;MAE7B,IAAI,CAACI,MAAM,EAAE;QACX,IAAI,CAACC,KAAK,CAAClG,MAAM,CAAC3F,iBAAiB,EAAE;UAAEzU,EAAE,EAAEof;QAAK,CAAC,CAAC;MACpD;IACF,CAAC,MAAM;MACL,IAAI,CAACY,YAAY,CAACZ,IAAI,EAAEa,KAAK,CAAC;IAChC;EACF;EAIAquB,gBAAgBA,CACdyB,QAAsB,EACtBxB,gBAA6C,EAC7CtuB,KAAc,EACR;IACN,MAAM9W,GAAG,GAAG4mC,QAAQ,CAACpnC,MAAM,GAAG,CAAC;IAE/B,KAAK,IAAIwB,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAIhB,GAAG,EAAEgB,CAAC,EAAE,EAAE;MAC7B,MAAM6gD,GAAG,GAAGjb,QAAQ,CAAC5lC,CAAC,CAAC;MACvB,IAAI,CAAC6gD,GAAG,EAAE;MAEV,IAAIA,GAAG,CAACp+C,IAAI,KAAK,eAAe,EAAE;QAChCo+C,GAAG,CAACp+C,IAAI,GAAG,aAAa;QACxB,MAAMk+C,GAAG,GAAGE,GAAG,CAACtxC,QAAQ;QACxB,IAAI,CAACqxC,qBAAqB,CAACD,GAAG,EAAqB,IAAI,CAAC;QACxD,IAAI,CAAC9qC,YAAY,CAAC8qC,GAAG,EAAE7qC,KAAK,CAAC;MAC/B,CAAC,MAAM;QACL,IAAI,CAACD,YAAY,CAACgrC,GAAG,EAAE/qC,KAAK,CAAC;MAC/B;MAEA,IAAI+qC,GAAG,CAACp+C,IAAI,KAAK,aAAa,EAAE;QAC9B,IAAIzC,CAAC,GAAGhB,GAAG,EAAE;UACX,IAAI,CAACmX,KAAK,CAAClG,MAAM,CAAC3F,iBAAiB,EAAE;YAAEzU,EAAE,EAAEgrD;UAAI,CAAC,CAAC;QAClD,CAAA,MAAM,IAAIzc,gBAAgB,EAAE;UAC3B,IAAI,CAACjuB,KAAK,CAAClG,MAAM,CAAC3F,iBAAiB,EAAE;YAAEzU,EAAE,EAAEuuC;UAAiB,CAAC,CAAC;QAChE;MACF;IACF;EACF;EAEAzuB,YAAYA,CAACvF,IAAU,EAAEwF,SAAmB,EAAW;IACrD,QAAQxF,IAAI,CAAC3N,IAAI;MACf,KAAK,YAAY;MACjB,KAAK,eAAe;MACpB,KAAK,cAAc;MACnB,KAAK,mBAAmB;MACxB,KAAK,aAAa;QAChB,OAAO,IAAI;MAEb,KAAK,kBAAkB;QAAE;UACvB,MAAM/C,IAAI,GAAG0Q,IAAI,CAAClQ,UAAU,CAAC1B,MAAM,GAAG,CAAC;UACvC,OAAQ4R,IAAI,CAAClQ,UAAU,CAAoC+jC,KAAK,CAC9D,CAAChvB,IAAI,EAAEjV,CAAC,KAAK;YACX,OACEiV,IAAI,CAACxS,IAAI,KAAK,cAAc,KAC3BzC,CAAC,KAAKN,IAAI,IAAIuV,IAAI,CAACxS,IAAI,KAAK,eAAe,CAAC,IAC7C,IAAI,CAACkT,YAAY,CAACV,IAAI,CAAC;UAE3B,CAAC,CACF;QACH;MAEA,KAAK,gBAAgB;QACnB,OAAO,IAAI,CAACU,YAAY,CAACvF,IAAI,CAACtQ,KAAK,CAAC;MAEtC,KAAK,eAAe;QAClB,OAAO,IAAI,CAAC6V,YAAY,CAACvF,IAAI,CAACb,QAAQ,CAAC;MAEzC,KAAK,iBAAiB;QACpB,OAAQa,IAAI,CAAqBuQ,QAAQ,CAACsjB,KAAK,CAC7C6c,OAAO,IAAIA,OAAO,KAAK,IAAI,IAAI,IAAI,CAACnrC,YAAY,CAACmrC,OAAO,CAAC,CAC1D;MAEH,KAAK,sBAAsB;QACzB,OAAO1wC,IAAI,CAACswC,QAAQ,KAAK,GAAG;MAE9B,KAAK,yBAAyB;QAC5B,OAAO,IAAI,CAAC/qC,YAAY,CAACvF,IAAI,CAACyB,UAAU,CAAC;MAE3C,KAAK,kBAAkB;MACvB,KAAK,0BAA0B;QAC7B,OAAO,CAAC+D,SAAS;MAEnB;QACE,OAAO,KAAK;IAAA;EAElB;EAIAiwB,gBAAgBA,CACdD,QAAsD,EAEtDE,mBAA6B,EACiB;IAC9C,OAAOF,QAAQ;EACjB;EAEAmb,oBAAoBA,CAClBnb,QAAsD,EACtDE,mBAA6B,EACvB;IACN,IAAI,CAACD,gBAAgB,CAACD,QAAQ,EAAEE,mBAAmB,CAAC;IAEpD,KAAK,MAAM/C,IAAI,IAAI6C,QAAQ,EAAE;MAC3B,IAAI,CAAA7C,IAAI,IAAJA,IAAAA,GAAAA,KAAAA,CAAAA,GAAAA,IAAI,CAAEtgC,IAAI,MAAK,iBAAiB,EAAE;QACpC,IAAI,CAACs+C,oBAAoB,CAAChe,IAAI,CAACpiB,QAAQ,CAAC;MAC1C;IACF;EACF;EAIAqgC,WAAWA,CAETzrC,mBAA6C,EAC9B;IACf,MAAMnF,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAiB;IAC5C,IAAI,CAACuF,IAAI,EAAE;IACX5J,IAAI,CAACb,QAAQ,GAAG,IAAI,CAACs0B,uBAAuB,CAC1CtuB,mBAAmB,EACnB3lB,SAAS,CACV;IACD,OAAO,IAAI,CAAC+kB,UAAU,CAACvE,IAAI,EAAE,eAAe,CAAC;EAC/C;EAIA6wC,gBAAgBA,CAAAA,EAA4B;IAC1C,MAAM7wC,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAe;IAC1C,IAAI,CAACuF,IAAI,EAAE;IACX5J,IAAI,CAACb,QAAQ,GAAG,IAAI,CAAC64B,gBAAgB,EAAE;IACvC,OAAO,IAAI,CAACzzB,UAAU,CAACvE,IAAI,EAAE,aAAa,CAAC;EAC7C;EAGAg4B,gBAAgBA,CAAAA,EAAwB;IAEtC,QAAQ,IAAI,CAACnxB,KAAK,CAACxU,IAAI;MACrB,KAAA,CAAA;QAAkB;UAChB,MAAM2N,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAgB;UAC3C,IAAI,CAACuF,IAAI,EAAE;UAEX5J,IAAI,CAACuQ,QAAQ,GAAG,IAAI,CAACugC,gBAAgB,CAGnCC,CAAAA,EAAAA,EAAAA,IACD;UACD,OAAO,IAAI,CAACxsC,UAAU,CAACvE,IAAI,EAAE,cAAc,CAAC;QAC9C;MAEA,KAAA,CAAA;QACE,OAAO,IAAI,CAACgxC,eAAe,CAAA,CAAA,EAAY,IAAI,CAAC;IAAA;IAIhD,OAAO,IAAI,CAAC9lB,eAAe,EAAE;EAC/B;EAGA4lB,gBAAgBA,CAEdjb,KAAgB,EAChBob,aAAyD,EACzDzwC,KAA4B,EACU;IACtC,MAAM0wC,UAAU,GAAG1wC,KAAK,IAAoC;IAE5D,MAAM2wC,IAA0C,GAAG,EAAE;IACrD,IAAIjgB,KAAK,GAAG,IAAI;IAChB,OAAO,CAAC,IAAI,CAACzY,GAAG,CAACod,KAAK,CAAC,EAAE;MACvB,IAAI3E,KAAK,EAAE;QACTA,KAAK,GAAG,KAAK;MACf,CAAC,MAAM;QACL,IAAI,CAAC1O,MAAM,CAAU,EAAA,CAAA;MACvB;MACA,IAAI0uB,UAAU,IAAI,IAAI,CAACh7B,KAAK,IAAU,EAAE;QACtCi7B,IAAI,CAAC1tD,IAAI,CAAC,IAAI,CAAC;MAChB,CAAA,MAAM,IAAI,IAAI,CAACg1B,GAAG,CAACod,KAAK,CAAC,EAAE;QAC1B;MACD,CAAA,MAAM,IAAI,IAAI,CAAC3f,KAAK,IAAa,EAAE;QAClCi7B,IAAI,CAAC1tD,IAAI,CACP,IAAI,CAACmzC,4BAA4B,CAAC,IAAI,CAACia,gBAAgB,EAAE,EAAErwC,KAAK,CAAC,CAClE;QACD,IAAI,CAAC,IAAI,CAAC4wC,mBAAmB,CAACH,aAAa,CAAC,EAAE;UAC5C,IAAI,CAACzuB,MAAM,CAACqT,KAAK,CAAC;UAClB;QACF;MACF,CAAC,MAAM;QACL,MAAMlvB,UAAU,GAAG,EAAE;QACrB,IAAI,IAAI,CAACuP,KAAK,CAAO,EAAA,CAAA,IAAI,IAAI,CAAC5P,SAAS,CAAC,YAAY,CAAC,EAAE;UACrD,IAAI,CAACP,KAAK,CAAClG,MAAM,CAAC1D,6BAA6B,EAAE;YAC/C1W,EAAE,EAAE,IAAI,CAACohB,KAAK,CAAC3B;UACjB,CAAC,CAAC;QACJ;QAEA,OAAO,IAAI,CAACgR,KAAK,CAAA,EAAA,CAAO,EAAE;UACxBvP,UAAU,CAACljB,IAAI,CAAC,IAAI,CAAC4tD,cAAc,EAAE,CAAC;QACxC;QACAF,IAAI,CAAC1tD,IAAI,CAAC,IAAI,CAAC6tD,uBAAuB,CAAC9wC,KAAK,EAAEmG,UAAU,CAAC,CAAC;MAC5D;IACF;IACA,OAAOwqC,IAAI;EACb;EAGAI,wBAAwBA,CAEtB1sC,IAAyB,EACZ;IACb,IAAI,CAAC+E,IAAI,EAAE;IAEX/E,IAAI,CAAC1F,QAAQ,GAAG,IAAI,CAAC+rB,eAAe,EAAE;IACtC,IAAI,CAACkmB,mBAAmB,CAA2B,GAAA,CAAA;IACnD,OAAO,IAAI,CAAC7sC,UAAU,CAACM,IAAI,EAAE,aAAa,CAAC;EAC7C;EAGA2sC,oBAAoBA,CAAAA,EAA2C;IAC7D,MAAM3sC,IAAI,GAAG,IAAI,CAACR,SAAS,EAA8B;IACzD,MAAM;MAAEhS,IAAI;MAAE6S;KAAU,GAAG,IAAI,CAAC2B,KAAK;IACrC,IAAIxU,IAAI,OAAgB,EAAE;MACxB,OAAO,IAAI,CAACk/C,wBAAwB,CAAC1sC,IAAI,CAAwB;IACnE,CAAC,MAAM,IAAIxS,IAAI,KAAA,GAAmB,EAAE;MAClC,IAAI,CAACsoB,YAAY,CAAC,sBAAsB,EAAEzV,QAAQ,CAAC;MACnD,IAAI,CAACS,UAAU,CAACC,cAAc,CAAC,IAAI,CAACiB,KAAK,CAACnX,KAAK,EAAEwV,QAAQ,CAAC;MACzDL,IAAI,CAA0BhkB,GAAG,GAAG,IAAI,CAAC4iB,gBAAgB,EAAE;IAC9D,CAAC,MAAM;MACL,IAAI,CAACguC,iBAAiB,CAAC5sC,IAAI,CAAyB;IACtD;IACCA,IAAI,CAA0BzC,MAAM,GAAG,KAAK;IAC7C,OAAO,IAAI,CAACu0B,iBAAiB,CAC3B9xB,IAAI,EACJK,QAAQ,EACR,KAAK,EACL,KAAK,EACL,IAAI,EACJ,KAAK,CACN;EACH;EAEAosC,uBAAuBA,CAErB9wC,KAA4B,EAC5BmG,UAAuB,EACQ;IAC/B,MAAM4uB,IAAI,GAAG,IAAI,CAACsB,iBAAiB,EAAE;IACrC,IAAI,CAACD,4BAA4B,CAACrB,IAAI,EAAE/0B,KAAK,CAAC;IAC9C,MAAMiwC,GAAG,GAAG,IAAI,CAAC5Z,iBAAiB,CAACtB,IAAI,CAAC12B,GAAG,CAAClQ,KAAK,EAAE4mC,IAAI,CAAC;IACxD,IAAI5uB,UAAU,CAACvY,MAAM,EAAE;MACrBmnC,IAAI,CAAC5uB,UAAU,GAAGA,UAAU;IAC9B;IACA,OAAO8pC,GAAG;EACZ;EAGA7Z,4BAA4BA,CAC1B5E,KAAc,EAEdxxB,KAA4B,EACnB;IACT,OAAOwxB,KAAK;EACd;EAIA6E,iBAAiBA,CAEf3xB,QAA0B,EAC1BqwB,IAAqB,EACZ;IAAA,IAAA5E,SAAA,EAAA+gB,KAAA;IACT,CAAA/gB,SAAA,GAAAzrB,QAAQ,KAAA,IAAA,GAAAyrB,SAAA,GAARzrB,QAAQ,GAAK,IAAI,CAAC2B,KAAK,CAAC3B,QAAQ;IAChCqwB,IAAI,GAAA,CAAAmc,KAAA,GAAGnc,IAAI,KAAA,IAAA,GAAAmc,KAAA,GAAI,IAAI,CAAC1Z,gBAAgB,EAAE;IACtC,IAAI,CAAC,IAAI,CAACvf,GAAG,CAAO,EAAA,CAAA,EAAE,OAAO8c,IAAI;IAEjC,MAAMv1B,IAAI,GAAG,IAAI,CAACqlB,WAAW,CAAoBngB,QAAQ,CAAC;IAC1DlF,IAAI,CAACu1B,IAAI,GAAGA,IAAI;IAChBv1B,IAAI,CAACkuB,KAAK,GAAG,IAAI,CAACuF,uBAAuB,EAAE;IAC3C,OAAO,IAAI,CAAClvB,UAAU,CAACvE,IAAI,EAAE,mBAAmB,CAAC;EACnD;EA8BAoF,WAAWA,CACT/S,IAAY,EAEZgT,yBAAkC,EAElCC,OAAqB,EACH;IAClB,OAAO0qC,QAAM,CACX;MACEh/C,iBAAiB,EAAE,MAAM;MACzBc,WAAW,EAAE,UAAU;MACvB6/C,cAAc,EAAE,OAAO;MACvB9/C,uBAAuB,EAAE,YAAY;MACrCf,YAAY,EAAE,UAAU;MACxBc,aAAa,EAAE;IAChB,CAAA,EAEDS,IAAI,CACL;EACH;EA2BAu/C,SAASA,CACPnwC,UAAmD,EACnD;IACEowC,EAAE,EAAE/6C,QAAQ;IACZwO,OAAO,GAAG2G,SAAS;IACnB6lC,YAAY,GAAG,KAAK;IACpBxY,iBAAiB,GAAG,KAAK;IACzByY,wBAAwB,GAAG;EAO7B,CAAC,EACK;IAAA,IAAAC,iBAAA;IACN,MAAM3/C,IAAI,GAAGoP,UAAU,CAACpP,IAAI;IAK5B,IAAI,IAAI,CAACwV,cAAc,CAACpG,UAAU,CAAC,EAAE;IAErC,IAAIpP,IAAI,KAAK,kBAAkB,EAAE;MAC/B,IAAIiT,OAAO,KAAK2G,SAAS,EAAE;QACzB,IAAI,CAAClG,KAAK,CAAClG,MAAM,CAACvI,6BAA6B,EAAE;UAAE7R,EAAE,EAAEgc;QAAW,CAAC,CAAC;MACtE;MACA;IACF;IAEA,IAAIpP,IAAI,KAAK,YAAY,EAAE;MACzB,IAAI,CAAC4/C,eAAe,CAClBxwC,UAAU,EACV6D,OAAO,EACPg0B,iBAAiB,CAClB;MAED,MAAM;QAAE52C;MAAM,CAAA,GAAG+e,UAAwB;MAEzC,IAAIqwC,YAAY,EAAE;QAChB,IAAIA,YAAY,CAACxoC,GAAG,CAAC5mB,IAAI,CAAC,EAAE;UAC1B,IAAI,CAACqjB,KAAK,CAAClG,MAAM,CAACpG,SAAS,EAAE;YAAEhU,EAAE,EAAEgc;UAAW,CAAC,CAAC;QAClD,CAAC,MAAM;UACLqwC,YAAY,CAACnjC,GAAG,CAACjsB,IAAI,CAAC;QACxB;MACF;MAEA;IACF;IAEA,MAAMwvD,QAAQ,GAAG,IAAI,CAAC9sC,WAAW,CAC/B/S,IAAI,EACJ,EAAE0/C,wBAAwB,IAAAC,CAAAA,iBAAA,GAAIvwC,UAAU,CAACE,KAAK,KAAhBqwC,IAAAA,IAAAA,iBAAA,CAAkBxvC,aAAa,CAAC,IAC5D1L,QAAQ,CAACzE,IAAI,KAAK,sBAAsB,EAC1CiT,OAAO,CACR;IAED,IAAI4sC,QAAQ,KAAK,IAAI,EAAE;IACvB,IAAIA,QAAQ,KAAK,KAAK,EAAE;MACtB,MAAMC,eAAe,GACnB7sC,OAAO,KAAK2G,SAAS,GAAGpM,MAAM,CAAChJ,UAAU,GAAGgJ,MAAM,CAAC9I,iBAAiB;MAEtE,IAAI,CAACgP,KAAK,CAACosC,eAAe,EAAE;QAAE1sD,EAAE,EAAEgc,UAAU;QAAE3K;MAAS,CAAC,CAAC;MACzD;IACF;IAEA,MAAM,CAACjW,GAAG,EAAEuxD,yBAAyB,CAAC,GAAG/yC,KAAK,CAACC,OAAO,CAAC4yC,QAAQ,CAAC,GAC5DA,QAAQ,GACR,CAACA,QAAQ,EAAE7/C,IAAI,KAAK,yBAAyB,CAAC;IAClD,MAAMggD,YAAY,GAChBhgD,IAAI,KAAK,cAAc,IACvBA,IAAI,KAAK,eAAe,IACxBA,IAAI,KAAK,yBAAyB,GAC7B;MAAEA;IAAM,CAAA,GACTyE,QAAQ;IAGd,KAAK,MAAMw7C,KAAK,IAAI,EAAE,CAACrvC,MAAM,CAACxB,UAAU,CAAC5gB,GAAG,CAAC,CAAC,EAAE;MAC9C,IAAIyxD,KAAK,EAAE;QACT,IAAI,CAACV,SAAS,CAACU,KAAK,EAAE;UACpBT,EAAE,EAAEQ,YAAY;UAChB/sC,OAAO;UACPwsC,YAAY;UACZxY,iBAAiB;UACjByY,wBAAwB,EAAEK;QAC5B,CAAC,CAAC;MACJ;IACF;EACF;EAEAH,eAAeA,CACbxsD,EAAc,EACdgpB,WAAyB,EACzB6qB,iBAA0B,GAAG,KAAK,EAClC;IACA,IACE,IAAI,CAACzyB,KAAK,CAACiC,MAAM,KAChBwwB,iBAAiB,GACd9vB,wBAAwB,CAAC/jB,EAAE,CAAC/C,IAAI,EAAE,IAAI,CAAC0mB,QAAQ,CAAC,GAChDG,4BAA4B,CAAC9jB,EAAE,CAAC/C,IAAI,CAAC,CAAC,EAC1C;MACA,IAAI+rB,WAAW,KAAKxC,SAAS,EAAE;QAC7B,IAAI,CAAClG,KAAK,CAAClG,MAAM,CAAC5C,mBAAmB,EAAE;UAAExX,EAAE;UAAEyX,aAAa,EAAEzX,EAAE,CAAC/C;QAAK,CAAC,CAAC;MACxE,CAAC,MAAM;QACL,IAAI,CAACqjB,KAAK,CAAClG,MAAM,CAAC1C,0BAA0B,EAAE;UAC5C1X,EAAE;UACF2X,WAAW,EAAE3X,EAAE,CAAC/C;QAClB,CAAC,CAAC;MACJ;IACF;IAEA,IAAI+rB,WAAW,GAAGlD,4BAA4B,IAAI9lB,EAAE,CAAC/C,IAAI,KAAK,KAAK,EAAE;MACnE,IAAI,CAACqjB,KAAK,CAAClG,MAAM,CAAClI,mBAAmB,EAAE;QAAElS;MAAG,CAAC,CAAC;IAChD;IAEA,IAAI,EAAEgpB,WAAW,GAAGxC,SAAS,CAAC,EAAE;MAC9B,IAAI,CAACsmC,yBAAyB,CAAC9sD,EAAE,EAAEgpB,WAAW,CAAC;IACjD;EACF;EAEA8jC,yBAAyBA,CAACC,UAAsB,EAAEltC,OAAqB,EAAE;IACvE,IAAI,CAACiJ,KAAK,CAACC,WAAW,CAACgkC,UAAU,CAAC9vD,IAAI,EAAE4iB,OAAO,EAAEktC,UAAU,CAAC3zC,GAAG,CAAClQ,KAAK,CAAC;EACxE;EAEA6hD,qBAAqBA,CAACxwC,IAAU,EAAEyyC,YAAqB,EAAQ;IAC7D,QAAQzyC,IAAI,CAAC3N,IAAI;MACf,KAAK,yBAAyB;QAC5B,IAAI,CAACm+C,qBAAqB,CAACxwC,IAAI,CAACyB,UAAU,EAAEgxC,YAAY,CAAC;QACzD;MACF,KAAK,YAAY;MACjB,KAAK,kBAAkB;QACrB;MACF,KAAK,iBAAiB;MACtB,KAAK,kBAAkB;QACrB,IAAIA,YAAY,EAAE;MAEpB;QACE,IAAI,CAAC1sC,KAAK,CAAClG,MAAM,CAACrI,4BAA4B,EAAE;UAAE/R,EAAE,EAAEua;QAAK,CAAC,CAAC;IAAA;EAEnE;EAEAoxC,mBAAmBA,CACjBvb,KAAiD,EACxC;IACT,IAAI,CAAC,IAAI,CAAC3f,KAAK,IAAU,EAAE;MACzB,OAAO,KAAK;IACd;IAEA,IAAI,CAACnQ,KAAK,CACR,IAAI,CAACmT,iBAAiB,EAAE,KAAK2c,KAAK,GAC9Bh2B,MAAM,CAAC3F,iBAAiB,GACxB2F,MAAM,CAACnL,gBAAgB,EAC3B;MAAEjP,EAAE,EAAE,IAAI,CAACohB,KAAK,CAAC3B;IAAS,CAAC,CAC5B;IAED,OAAO,IAAI;EACb;AACF;ACtrBA,MAAM8qC,MAAM,GAAGA,CAAevgD,MAAS,EAAE5O,GAAY,KACnDC,MAAM,CAACmvD,cAAc,CAAC7X,IAAI,CAAC3oC,MAAM,EAAE5O,GAAG,CAAC,IAAI4O,MAAM,CAAC5O,GAAG,CAAC;AAYxD,SAAS6xD,OAAOA,CAAIC,CAAY,EAAK;EACnC,IAAIA,CAAC,IAAI,IAAI,EAAE;IACb,MAAM,IAAIhyD,KAAK,CAAegyD,cAAAA,UAAU,CAAC;EAC3C;EACA,OAAOA,CAAC;AACV;AAEA,SAASC,MAAMA,CAACD,CAAU,EAAQ;EAChC,IAAI,CAACA,CAAC,EAAE;IACN,MAAM,IAAIhyD,KAAK,CAAC,aAAa,CAAC;EAChC;AACF;AAgBA,MAAMkyD,QAAQ,GAAG3zC,cAAe,YAAW,CAAC;EAC1C4zC,+BAA+B,EAAEA,CAAC;IAAEC;GAAoC,KAC3DA,WAAAA,UAA0E,gEAAA;EACvFC,8BAA8B,EAAEA,CAAC;IAC/BC;GAGD,KACcA,aAAAA,YAAyE,6DAAA;EACxFC,iCAAiC,EAC/B,6DAA6D;EAC/DC,+BAA+B,EAAE,0CAA0C;EAC3EC,wBAAwB,EACtB,qDAAqD;EACvDC,qBAAqB,EAAE,mDAAmD;EAC1EC,sBAAsB,EAAE,oDAAoD;EAC5EC,mEAAmE,EACjE,4GAA4G;EAC9GC,4BAA4B,EAC1B,6DAA6D;EAC/DC,eAAe,EAAEA,CAAC;IAAEhhD;GAA+B,KAClBA,+BAAAA,IAAW,OAAA;EAC5CihD,+BAA+B,EAC7B,mDAAmD;EACrDC,gCAAgC,EAC9B,2DAA2D;EAC7DC,8BAA8B,EAG5BA,CAAC;IAAEC;EAAyC,CAAA,KACJ,sCAAA;EAC1CC,iBAAiB,EAAEA,CAAC;IAAED;GAAoC,KAChCA,wBAAAA,QAAY,IAAA;EAGtCE,uBAAuB,EAAEA,CAAC;IAAE7yD;GAA4C,KAClEA,IAAAA,KAA8B,yBAAA;EACpC8yD,kBAAkB,EAAE,qCAAqC;EACzDC,mBAAmB,EAAE,sCAAsC;EAC3DC,iCAAiC,EAC/B,8DAA8D;EAChEC,wBAAwB,EAAE,4CAA4C;EACtEjtB,6BAA6B,EAC3B,4DAA4D;EAC9DktB,qBAAqB,EAAEA,CAAC;IACtBC;GAGD,KACKA,IAAAA,SAAS,CAAC,CAAC,CAAE,mCAAkCA,SAAS,CAAC,CAAC,CAAc,aAAA;EAC9EC,yBAAyB,EACvB,uDAAuD;EACzDC,8BAA8B,EAAEA,CAAC;IAC/BV;GAGD,KAC6DA,4DAAAA,QAAa,KAAA;EAC3EW,wBAAwB,EACtB,sDAAsD;EACxDC,yBAAyB,EACvB,0DAA0D;EAC5DC,uBAAuB,EACrB,qDAAqD;EACvDC,qCAAqC,EACnC,mDAAmD;EACrDC,2BAA2B,EAAEA,CAAC;IAAEf;GAAoC,KAC9DA,IAAAA,QAAoD,4CAAA;EAC1DgB,8BAA8B,EAAEA,CAAC;IAAEhB;GAAoC,KACjEA,IAAAA,QAAuD,+CAAA;EAC7DiB,uCAAuC,EAAEA,CAAC;IACxCjB;GAGD,KACKA,IAAAA,QAA6F,qFAAA;EACnGkB,qBAAqB,EAAEA,CAAC;IACtBC;GAGD,KACKA,IAAAA,gBAAgB,CAAC,CAAC,CAAE,4BAA2BA,gBAAgB,CAAC,CAAC,CAAc,aAAA;EACrFC,iDAAiD,EAC/C,6DAA6D,GAC7D,gGAAgG;EAClGC,uBAAuB,EACrB,yDAAyD;EAC3DC,oBAAoB,EAClB,6DAA6D;EAC/DC,gCAAgC,EAC9B,0DAA0D;EAC5DC,iCAAiC,EAC/B,4DAA4D;EAC9DC,wCAAwC,EACtC,kFAAkF;EACpFC,0BAA0B,EACxB,uDAAuD;EACzDC,qBAAqB,EACnB,4GAA4G;EAC9G7tB,iBAAiB,EACf,gFAAgF;EAClF8tB,yBAAyB,EACvB,uDAAuD;EACzDC,8BAA8B,EAAEA,CAAC;IAC/B7B;GAGD,KAC6DA,4DAAAA,QAAa,KAAA;EAC3E8B,0BAA0B,EACxB,mFAAmF;EACrFC,sBAAsB,EACpB,gHAAgH;EAClHC,qBAAqB,EACnB,mGAAmG;EAErGC,qCAAqC,EACnC,qDAAqD;EACvDC,iCAAiC,EAC/B,8CAA8C;EAChDC,8BAA8B,EAC5B,wDAAwD;EAC1DC,uCAAuC,EAAEA,CAAC;IACxCC;EAGD,CAAA,KACE,yBAAwBA,iBAAkB,kDAAiDA,iBAAsB,KAAA;EACpHC,6BAA6B,EAC3B,+CAA+C;EACjDC,sBAAsB,EACpB,0KAA0K;EAC5KC,yBAAyB,EACvB,mHAAmH;EACrHC,sCAAsC,EACpC,kFAAkF;EACpFC,+BAA+B,EAC7B,0GAA0G;EAC5GC,+BAA+B,EAC7B,0GAA0G;EAC5GC,2BAA2B,EACzB,uEAAuE;EACzEC,kBAAkB,EAChB,8EAA8E;EAChFC,wBAAwB,EAAE,wCAAwC;EAClEC,6BAA6B,EAAE,6CAA6C;EAC5EC,6BAA6B,EAC3B,qDAAqD;EACvDC,gCAAgC,EAC9B,mEAAmE;EACrEC,iCAAiC,EAAEA,CAAC;IAAE1kD;GAAwB,8FAC6BA,IAAK;AAClG,CAAC,CAAC;AAMF,SAAS2kD,mBAAmBA,CAACtnD,KAAa,EAAmC;EAC3E,QAAQA,KAAK;IACX,KAAK,KAAK;MACR,OAAO,cAAc;IACvB,KAAK,SAAS;MACZ,OAAO,kBAAkB;IAC3B,KAAK,QAAQ;MACX,OAAO,iBAAiB;IAC1B,KAAK,OAAO;MACV,OAAO,gBAAgB;IACzB,KAAK,QAAQ;MACX,OAAO,iBAAiB;IAC1B,KAAK,QAAQ;MACX,OAAO,iBAAiB;IAC1B,KAAK,QAAQ;MACX,OAAO,iBAAiB;IAC1B,KAAK,QAAQ;MACX,OAAO,iBAAiB;IAC1B,KAAK,WAAW;MACd,OAAO,oBAAoB;IAC7B,KAAK,SAAS;MACZ,OAAO,kBAAkB;IAC3B;MACE,OAAOlQ,SAAS;EAAA;AAEtB;AAEA,SAASy3D,kBAAkBA,CAACpD,QAAgB,EAA+B;EACzE,OACEA,QAAQ,KAAK,SAAS,IAAIA,QAAQ,KAAK,QAAQ,IAAIA,QAAQ,KAAK,WAAW;AAE/E;AAEA,SAASqD,uBAAuBA,CAC9BrD,QAAgB,EACmB;EACnC,OAAOA,QAAQ,KAAK,IAAI,IAAIA,QAAQ,KAAK,KAAK;AAChD;AASA,IAAAsD,UAAA,GAAgBj3C,UAA0D,IACxE,MAAMk3C,qBAAqB,SAASl3C,UAAU,CAAmB;EAAAjf,WAAAA,CAAA,GAAAwjB,IAAA,EAAA;IAAA,KAAA,CAAA,GAAAA,IAAA,CAAA;IAAA,IAyW/D4yC,CAAAA,qBAAqB,GAAG,IAAI,CAACC,gBAAgB,CAACC,IAAI,CAAC,IAAI,EAAE;MACvDC,gBAAgB,EAAE,CAAC,IAAI,EAAE,KAAK,CAAC;MAC/BC,mBAAmB,EAAE,CACnB,OAAO,EACP,QAAQ,EACR,SAAS,EACT,WAAW,EACX,UAAU,EACV,SAAS,EACT,UAAU,EACV,UAAU,CACX;MACDC,aAAa,EAAE7E,QAAQ,CAACgC;IAC1B,CAAC,CAAC;IAAA,IAEF8C,CAAAA,oBAAoB,GAAG,IAAI,CAACL,gBAAgB,CAACC,IAAI,CAAC,IAAI,EAAE;MACtDC,gBAAgB,EAAE,CAAC,OAAO,CAAC;MAE3BC,mBAAmB,EAAE,CAAC,IAAI,EAAE,KAAK,CAAC;MAClCC,aAAa,EAAE7E,QAAQ,CAACiC;IAC1B,CAAC,CAAC;IAAA,IAEF8C,CAAAA,0BAA0B,GAAG,IAAI,CAACN,gBAAgB,CAACC,IAAI,CAAC,IAAI,EAAE;MAC5DC,gBAAgB,EAAE,CAAC,IAAI,EAAE,KAAK,EAAE,OAAO,CAAC;MACxCC,mBAAmB,EAAE,CACnB,QAAQ,EACR,SAAS,EACT,WAAW,EACX,UAAU,EACV,SAAS,EACT,UAAU,EACV,UAAU,CACX;MACDC,aAAa,EAAE7E,QAAQ,CAACgC;IAC1B,CAAC,CAAC;EAAA;EA1YF9wB,eAAeA,CAAAA,EAEb;IACA,OAAO2rB,sBAAsB;EAC/B;EAEAmI,cAAcA,CAAAA,EAAY;IAGxB,OAAOhrD,iBAAiB,CAAC,IAAI,CAACga,KAAK,CAACxU,IAAI,CAAC;EAC3C;EAEAylD,wBAAwBA,CAAAA,EAAG;IACzB,OACE,CAAC,IAAI,CAAC5hC,KAAK,GAAa,IACtB,IAAI,CAACA,KAAK,GAAW,IACrB,IAAI,CAACA,KAAK,IAAS,IACnB,IAAI,CAACA,KAAK,IAAa,IACvB,IAAI,CAACA,KAAK,KAAgB,IAC1B,IAAI,CAACqN,qBAAqB,EAAE,KAC9B,CAAC,IAAI,CAACpB,qBAAqB,EAAE;EAEjC;EAEA41B,4BAA4BA,CAAAA,EAAG;IAK7B,IAAI,CAACnuC,IAAI,EAAE;IACX,OAAO,IAAI,CAACkuC,wBAAwB,EAAE;EACxC;EAGAE,eAAeA,CACbR,gBAAqB,EACrBS,6BAAuC,EACjB;IACtB,IACE,CAACprD,iBAAiB,CAAC,IAAI,CAACga,KAAK,CAACxU,IAAI,CAAC,IACnC,IAAI,CAACwU,KAAK,CAACxU,IAAI,KAAA,EAAW,IAC1B,IAAI,CAACwU,KAAK,CAACxU,IAAI,KAAA,EAAc,EAC7B;MACA,OAAO7S,SAAS;IAClB;IAEA,MAAMq0D,QAAQ,GAAG,IAAI,CAAChtC,KAAK,CAACnX,KAAK;IACjC,IAAI8nD,gBAAgB,CAAC//B,OAAO,CAACo8B,QAAQ,CAAC,KAAK,CAAC,CAAC,EAAE;MAC7C,IAAIoE,6BAA6B,IAAI,IAAI,CAACC,uBAAuB,EAAE,EAAE;QACnE,OAAO14D,SAAS;MAClB;MACA,IAAI,IAAI,CAAC24D,UAAU,CAAC,IAAI,CAACJ,4BAA4B,CAACR,IAAI,CAAC,IAAI,CAAC,CAAC,EAAE;QACjE,OAAO1D,QAAQ;MACjB;IACF;IACA,OAAOr0D,SAAS;EAClB;EAOA83D,gBAAgBA,CACd;IACEE,gBAAgB;IAChBC,mBAAmB;IACnBQ,6BAA6B;IAC7BP,aAAa,GAAG7E,QAAQ,CAAC+B;EAM1B,CAAA,EACDwD,QAAW,EACL;IACN,MAAMC,YAAY,GAAGA,CACnBx5C,GAAa,EACbg1C,QAAoB,EACpByE,MAAkB,EAClBC,KAAiB,KACd;MACH,IAAI1E,QAAQ,KAAKyE,MAAM,IAAIF,QAAQ,CAACG,KAAK,CAAC,EAAE;QAC1C,IAAI,CAACxyC,KAAK,CAAC8sC,QAAQ,CAACkC,qBAAqB,EAAE;UACzCtvD,EAAE,EAAEoZ,GAAG;UACPm2C,gBAAgB,EAAE,CAACsD,MAAM,EAAEC,KAAK;QAClC,CAAC,CAAC;MACJ;KACD;IACD,MAAMC,YAAY,GAAGA,CACnB35C,GAAa,EACbg1C,QAAoB,EACpB4E,IAAgB,EAChBC,IAAgB,KACb;MACH,IACGN,QAAQ,CAACK,IAAI,CAAC,IAAI5E,QAAQ,KAAK6E,IAAI,IACnCN,QAAQ,CAACM,IAAI,CAAC,IAAI7E,QAAQ,KAAK4E,IAAK,EACrC;QACA,IAAI,CAAC1yC,KAAK,CAAC8sC,QAAQ,CAACuB,qBAAqB,EAAE;UACzC3uD,EAAE,EAAEoZ,GAAG;UACPw1C,SAAS,EAAE,CAACoE,IAAI,EAAEC,IAAI;QACxB,CAAC,CAAC;MACJ;KACD;IAED,SAAS;MACP,MAAM;QAAExzC;OAAU,GAAG,IAAI,CAAC2B,KAAK;MAC/B,MAAMgtC,QAAuC,GAAG,IAAI,CAACmE,eAAe,CAClER,gBAAgB,CAACv0C,MAAM,CAACw0C,mBAAmB,WAAnBA,mBAAmB,GAAI,EAAE,CAAC,EAClDQ,6BAA6B,CAC9B;MAED,IAAI,CAACpE,QAAQ,EAAE;MAEf,IAAIoD,kBAAkB,CAACpD,QAAQ,CAAC,EAAE;QAChC,IAAIuE,QAAQ,CAACO,aAAa,EAAE;UAC1B,IAAI,CAAC5yC,KAAK,CAAC8sC,QAAQ,CAACe,8BAA8B,EAAE;YAClDnuD,EAAE,EAAEyf,QAAQ;YACZ2uC;UACF,CAAC,CAAC;QACJ,CAAC,MAAM;UACLwE,YAAY,CAACnzC,QAAQ,EAAE2uC,QAAQ,EAAEA,QAAQ,EAAE,UAAU,CAAC;UACtDwE,YAAY,CAACnzC,QAAQ,EAAE2uC,QAAQ,EAAEA,QAAQ,EAAE,QAAQ,CAAC;UACpDwE,YAAY,CAACnzC,QAAQ,EAAE2uC,QAAQ,EAAEA,QAAQ,EAAE,UAAU,CAAC;UAEtDuE,QAAQ,CAACO,aAAa,GAAG9E,QAAQ;QACnC;MACF,CAAC,MAAM,IAAIqD,uBAAuB,CAACrD,QAAQ,CAAC,EAAE;QAC5C,IAAIuE,QAAQ,CAACvE,QAAQ,CAAC,EAAE;UACtB,IAAI,CAAC9tC,KAAK,CAAC8sC,QAAQ,CAACiB,iBAAiB,EAAE;YAAEruD,EAAE,EAAEyf,QAAQ;YAAE2uC;UAAS,CAAC,CAAC;QACpE;QACAuE,QAAQ,CAACvE,QAAQ,CAAC,GAAG,IAAI;QAEzBwE,YAAY,CAACnzC,QAAQ,EAAE2uC,QAAQ,EAAE,IAAI,EAAE,KAAK,CAAC;MAC/C,CAAC,MAAM;QACL,IAAI/yD,MAAM,CAACmvD,cAAc,CAAC7X,IAAI,CAACggB,QAAQ,EAAEvE,QAAQ,CAAC,EAAE;UAClD,IAAI,CAAC9tC,KAAK,CAAC8sC,QAAQ,CAACiB,iBAAiB,EAAE;YAAEruD,EAAE,EAAEyf,QAAQ;YAAE2uC;UAAS,CAAC,CAAC;QACpE,CAAC,MAAM;UACLwE,YAAY,CAACnzC,QAAQ,EAAE2uC,QAAQ,EAAE,QAAQ,EAAE,UAAU,CAAC;UACtDwE,YAAY,CAACnzC,QAAQ,EAAE2uC,QAAQ,EAAE,QAAQ,EAAE,UAAU,CAAC;UACtDwE,YAAY,CAACnzC,QAAQ,EAAE2uC,QAAQ,EAAE,UAAU,EAAE,UAAU,CAAC;UACxDwE,YAAY,CAACnzC,QAAQ,EAAE2uC,QAAQ,EAAE,UAAU,EAAE,UAAU,CAAC;UAExD2E,YAAY,CAACtzC,QAAQ,EAAE2uC,QAAQ,EAAE,SAAS,EAAE,UAAU,CAAC;UACvD2E,YAAY,CAACtzC,QAAQ,EAAE2uC,QAAQ,EAAE,QAAQ,EAAE,UAAU,CAAC;QACxD;QACAuE,QAAQ,CAACvE,QAAQ,CAAC,GAAG,IAAI;MAC3B;MAEA,IAAI4D,mBAAmB,YAAnBA,mBAAmB,CAAEh7B,QAAQ,CAACo3B,QAAQ,CAAC,EAAE;QAC3C,IAAI,CAAC9tC,KAAK,CAAC2xC,aAAa,EAAE;UACxBjyD,EAAE,EAAEyf,QAAQ;UACZ2uC;QACF,CAAC,CAAC;MACJ;IACF;EACF;EAEA+E,kBAAkBA,CAACnmD,IAAoB,EAAW;IAChD,QAAQA,IAAI;MACV,KAAK,aAAa;MAClB,KAAK,aAAa;QAChB,OAAO,IAAI,CAACyjB,KAAK,CAAW,CAAA,CAAA;MAC9B,KAAK,uBAAuB;QAC1B,OAAO,IAAI,CAACA,KAAK,CAAW,CAAA,CAAA;MAC9B,KAAK,mBAAmB;QACtB,OAAO,IAAI,CAACA,KAAK,CAAa,CAAA,CAAA;MAChC,KAAK,2BAA2B;QAC9B,OAAO,IAAI,CAACA,KAAK,CAAO,EAAA,CAAA;IAAA;EAE9B;EAEA2iC,WAAWA,CACTpmD,IAAoB,EACpBqmD,YAAqB,EAChB;IACL,MAAM5kB,MAAW,GAAG,EAAE;IACtB,OAAO,CAAC,IAAI,CAAC0kB,kBAAkB,CAACnmD,IAAI,CAAC,EAAE;MAErCyhC,MAAM,CAACzwC,IAAI,CAACq1D,YAAY,EAAE,CAAC;IAC7B;IACA,OAAO5kB,MAAM;EACf;EAEA6kB,oBAAoBA,CAClBtmD,IAAoB,EACpBqmD,YAAqB,EACrBE,mBAEC,EACI;IACL,OAAOtG,OAAO,CACZ,IAAI,CAACuG,0BAA0B,CAC7BxmD,IAAI,EACJqmD,YAAY,EACQ,IAAI,EACxBE,mBAAmB,CACpB,CACF;EACH;EAMAC,0BAA0BA,CACxBxmD,IAAoB,EACpBqmD,YAAwC,EACxCI,aAAsB,EACtBF,mBAEC,EACuB;IACxB,MAAM9kB,MAAM,GAAG,EAAE;IACjB,IAAIilB,gBAAgB,GAAG,CAAC,CAAC;IAEzB,SAAS;MACP,IAAI,IAAI,CAACP,kBAAkB,CAACnmD,IAAI,CAAC,EAAE;QACjC;MACF;MACA0mD,gBAAgB,GAAG,CAAC,CAAC;MAErB,MAAMzI,OAAO,GAAGoI,YAAY,EAAE;MAC9B,IAAIpI,OAAO,IAAI,IAAI,EAAE;QACnB,OAAOlxD,SAAS;MAClB;MACA00C,MAAM,CAACzwC,IAAI,CAACitD,OAAO,CAAC;MAEpB,IAAI,IAAI,CAACj4B,GAAG,CAAA,EAAA,CAAU,EAAE;QACtB0gC,gBAAgB,GAAG,IAAI,CAACtyC,KAAK,CAAC4M,YAAY;QAC1C;MACF;MAEA,IAAI,IAAI,CAACmlC,kBAAkB,CAACnmD,IAAI,CAAC,EAAE;QACjC;MACF;MAEA,IAAIymD,aAAa,EAAE;QAEjB,IAAI,CAAC12B,MAAM,CAAU,EAAA,CAAA;MACvB;MACA,OAAOhjC,SAAS;IAClB;IAEA,IAAIw5D,mBAAmB,EAAE;MACvBA,mBAAmB,CAACtpD,KAAK,GAAGypD,gBAAgB;IAC9C;IAEA,OAAOjlB,MAAM;EACf;EAEAklB,oBAAoBA,CAClB3mD,IAAoB,EACpBqmD,YAAqB,EACrBO,OAAgB,EAChBC,cAAuB,EACvBN,mBAEC,EACI;IACL,IAAI,CAACM,cAAc,EAAE;MACnB,IAAID,OAAO,EAAE;QACX,IAAI,CAAC72B,MAAM,CAAa,CAAA,CAAA;MAC1B,CAAC,MAAM;QACL,IAAI,CAACA,MAAM,CAAO,EAAA,CAAA;MACpB;IACF;IAEA,MAAM0R,MAAM,GAAG,IAAI,CAAC6kB,oBAAoB,CACtCtmD,IAAI,EACJqmD,YAAY,EACZE,mBAAmB,CACpB;IAED,IAAIK,OAAO,EAAE;MACX,IAAI,CAAC72B,MAAM,CAAa,CAAA,CAAA;IAC1B,CAAC,MAAM;MACL,IAAI,CAACA,MAAM,CAAO,EAAA,CAAA;IACpB;IAEA,OAAO0R,MAAM;EACf;EAEAqlB,iBAAiBA,CAAAA,EAAmB;IAClC,MAAMv5C,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAkB;IAC7C,IAAI,CAACme,MAAM,CAAY,EAAA,CAAA;IACvB,IAAI,CAACA,MAAM,CAAW,EAAA,CAAA;IACtB,IAAI,CAAC,IAAI,CAACtM,KAAK,KAAW,EAAE;MAC1B,IAAI,CAACnQ,KAAK,CAAC8sC,QAAQ,CAACgE,6BAA6B,EAAE;QACjDpxD,EAAE,EAAE,IAAI,CAACohB,KAAK,CAAC3B;MACjB,CAAC,CAAC;IACJ;IAGAlF,IAAI,CAACb,QAAQ,GAAG,KAAK,CAACktB,aAAa,EAAqB;IACxD,IAAI,CAAC7J,MAAM,CAAW,EAAA,CAAA;IAEtB,IAAI,IAAI,CAAC/J,GAAG,CAAA,EAAA,CAAQ,EAAE;MAGpBzY,IAAI,CAACw5C,SAAS,GAAG,IAAI,CAACC,iBAAiB,EAAE;IAC3C;IACA,IAAI,IAAI,CAACvjC,KAAK,CAAA,EAAA,CAAO,EAAE;MACrBlW,IAAI,CAACwD,cAAc,GAAG,IAAI,CAACk2C,oBAAoB,EAAE;IACnD;IACA,OAAO,IAAI,CAACn1C,UAAU,CAACvE,IAAI,EAAE,cAAc,CAAC;EAC9C;EAEAy5C,iBAAiBA,CAACE,kBAA2B,GAAG,IAAI,EAAkB;IACpE,IAAIhM,MAAsB,GAAG,IAAI,CAACziB,eAAe,CAACyuB,kBAAkB,CAAC;IACrE,OAAO,IAAI,CAAClhC,GAAG,CAAA,EAAA,CAAQ,EAAE;MACvB,MAAMzY,IAA+B,GACnC,IAAI,CAAC2H,eAAe,CAAoBgmC,MAAM,CAAC;MACjD3tC,IAAI,CAACu1B,IAAI,GAAGoY,MAAM;MAClB3tC,IAAI,CAACkuB,KAAK,GAAG,IAAI,CAAChD,eAAe,CAACyuB,kBAAkB,CAAC;MACrDhM,MAAM,GAAG,IAAI,CAACppC,UAAU,CAACvE,IAAI,EAAE,iBAAiB,CAAC;IACnD;IACA,OAAO2tC,MAAM;EACf;EAEAiM,oBAAoBA,CAAAA,EAAsB;IACxC,MAAM55C,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAqB;IAChDrE,IAAI,CAAC65C,QAAQ,GAAG,IAAI,CAACJ,iBAAiB,EAAE;IACxC,IAAI,CAAC,IAAI,CAACt3B,qBAAqB,EAAE,IAAI,IAAI,CAACjM,KAAK,CAAA,EAAA,CAAO,EAAE;MACtDlW,IAAI,CAACwD,cAAc,GAAG,IAAI,CAACk2C,oBAAoB,EAAE;IACnD;IACA,OAAO,IAAI,CAACn1C,UAAU,CAACvE,IAAI,EAAE,iBAAiB,CAAC;EACjD;EAEA85C,wBAAwBA,CAACC,GAAiB,EAAqB;IAC7D,IAAI,CAACnwC,IAAI,EAAE;IACX,MAAM5J,IAAI,GAAG,IAAI,CAAC2H,eAAe,CAAoBoyC,GAAG,CAAC;IACzD/5C,IAAI,CAACg6C,aAAa,GAAGD,GAAG;IACxB/5C,IAAI,CAAC0rB,cAAc,GAAG,IAAI,CAACuuB,qBAAqB,CAAgB,KAAK,CAAC;IACtEj6C,IAAI,CAACk6C,OAAO,GAAG,KAAK;IACpB,OAAO,IAAI,CAAC31C,UAAU,CAACvE,IAAI,EAAE,iBAAiB,CAAC;EACjD;EAEAm6C,mBAAmBA,CAAAA,EAAiB;IAClC,MAAMn6C,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAgB;IAC3C,IAAI,CAACuF,IAAI,EAAE;IACX,OAAO,IAAI,CAACrF,UAAU,CAACvE,IAAI,EAAE,YAAY,CAAC;EAC5C;EAEAo6C,gBAAgBA,CAAAA,EAAkB;IAChC,MAAMp6C,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAiB;IAC5C,IAAI,CAACme,MAAM,CAAY,EAAA,CAAA;IACvB,IAAI,IAAI,CAACtM,KAAK,CAAA,EAAA,CAAY,EAAE;MAC1BlW,IAAI,CAACq6C,QAAQ,GAAG,IAAI,CAACd,iBAAiB,EAAE;IAC1C,CAAC,MAAM;MACLv5C,IAAI,CAACq6C,QAAQ,GAAG,IAAI,CAACZ,iBAAiB,EAAE;IAC1C;IACA,IAAI,CAAC,IAAI,CAACt3B,qBAAqB,EAAE,IAAI,IAAI,CAACjM,KAAK,CAAA,EAAA,CAAO,EAAE;MACtDlW,IAAI,CAACwD,cAAc,GAAG,IAAI,CAACk2C,oBAAoB,EAAE;IACnD;IACA,OAAO,IAAI,CAACn1C,UAAU,CAACvE,IAAI,EAAE,aAAa,CAAC;EAC7C;EAsCAs6C,oBAAoBA,CAClBC,cAAyD,EACtC;IACnB,MAAMv6C,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAqB;IAEhDk2C,cAAc,CAACv6C,IAAI,CAAC;IAEpBA,IAAI,CAACtd,IAAI,GAAG,IAAI,CAAC83D,wBAAwB,EAAE;IAC3Cx6C,IAAI,CAACy6C,UAAU,GAAG,IAAI,CAACC,kBAAkB,CAAa,EAAA,CAAA;IACtD16C,IAAI,CAACysB,OAAO,GAAG,IAAI,CAACiuB,kBAAkB,CAAO,EAAA,CAAA;IAC7C,OAAO,IAAI,CAACn2C,UAAU,CAACvE,IAAI,EAAE,iBAAiB,CAAC;EACjD;EAEA26C,wBAAwBA,CACtBJ,cAAiD,EACA;IACjD,IAAI,IAAI,CAACrkC,KAAK,CAAA,EAAA,CAAO,EAAE;MACrB,OAAO,IAAI,CAAC0kC,qBAAqB,CAACL,cAAc,CAAC;IACnD;EACF;EAEAK,qBAAqBA,CAACL,cAAiD,EAAE;IACvE,MAAMv6C,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAgC;IAE3D,IAAI,IAAI,CAAC6R,KAAK,CAAA,EAAA,CAAO,IAAI,IAAI,CAACA,KAAK,CAAA,GAAA,CAAgB,EAAE;MACnD,IAAI,CAACtM,IAAI,EAAE;IACb,CAAC,MAAM;MACL,IAAI,CAACzS,UAAU,EAAE;IACnB;IAEA,MAAM6hD,mBAAmB,GAAG;MAAEtpD,KAAK,EAAE,CAAC;KAAG;IAEzCsQ,IAAI,CAACqC,MAAM,GAAG,IAAI,CAAC+2C,oBAAoB,CACrC,2BAA2B,EAE3B,IAAI,CAACkB,oBAAoB,CAAC/C,IAAI,CAAC,IAAI,EAAEgD,cAAc,CAAC,EACtC,KAAK,EACE,IAAI,EACzBvB,mBAAmB,CACpB;IACD,IAAIh5C,IAAI,CAACqC,MAAM,CAACjU,MAAM,KAAK,CAAC,EAAE;MAC5B,IAAI,CAAC2X,KAAK,CAAC8sC,QAAQ,CAACoB,mBAAmB,EAAE;QAAExuD,EAAE,EAAEua;MAAK,CAAC,CAAC;IACxD;IACA,IAAIg5C,mBAAmB,CAACtpD,KAAK,KAAK,CAAC,CAAC,EAAE;MACpC,IAAI,CAAC+xB,QAAQ,CAACzhB,IAAI,EAAE,eAAe,EAAEg5C,mBAAmB,CAACtpD,KAAK,CAAC;IACjE;IACA,OAAO,IAAI,CAAC6U,UAAU,CAACvE,IAAI,EAAE,4BAA4B,CAAC;EAC5D;EAIA66C,eAAeA,CACbC,WAAsB,EACtBC,SAA2C,EACrC;IAEN,MAAMC,mBAAmB,GAAGF,WAAW,KAAa,EAAA;IAGpD,MAAMG,SAAS,GAA6C,YAAY;IACxE,MAAMC,aAAa,GAEf,gBAAgB;IAEpBH,SAAS,CAACv3C,cAAc,GAAG,IAAI,CAACm3C,wBAAwB,CACtD,IAAI,CAAChD,oBAAoB,CAC1B;IACD,IAAI,CAACn1B,MAAM,CAAW,EAAA,CAAA;IACtBu4B,SAAS,CAACE,SAAS,CAAC,GAAG,IAAI,CAACE,8BAA8B,EAAE;IAC5D,IAAIH,mBAAmB,EAAE;MACvBD,SAAS,CAACG,aAAa,CAAC,GACtB,IAAI,CAACE,oCAAoC,CAACN,WAAW,CAAC;IACzD,CAAA,MAAM,IAAI,IAAI,CAAC5kC,KAAK,CAAC4kC,WAAW,CAAC,EAAE;MAClCC,SAAS,CAACG,aAAa,CAAC,GACtB,IAAI,CAACE,oCAAoC,CAACN,WAAW,CAAC;IAC1D;EACF;EAEAK,8BAA8BA,CAAAA,EAE5B;IACA,OAAO,KAAK,CACTrK,gBAAgB,CAAA,EAAA,EAAA,EAAA,IAIhB,CACA9gD,GAAG,CAACuQ,OAAO,IAAI;MACd,IACEA,OAAO,CAAClO,IAAI,KAAK,YAAY,IAC7BkO,OAAO,CAAClO,IAAI,KAAK,aAAa,IAC9BkO,OAAO,CAAClO,IAAI,KAAK,eAAe,IAChCkO,OAAO,CAAClO,IAAI,KAAK,cAAc,EAC/B;QACA,IAAI,CAAC0T,KAAK,CAAC8sC,QAAQ,CAACkE,iCAAiC,EAAE;UACrDtxD,EAAE,EAAE8a,OAAO;UACXlO,IAAI,EAAEkO,OAAO,CAAClO;QAChB,CAAC,CAAC;MACJ;MACA,OAAOkO,OAAO;IAChB,CAAC,CAAC;EACN;EAEA86C,0BAA0BA,CAAAA,EAAS;IACjC,IAAI,CAAC,IAAI,CAAC5iC,GAAG,CAAA,EAAA,CAAU,IAAI,CAAC,IAAI,CAAC4J,gBAAgB,EAAE,EAAE;MACnD,IAAI,CAACG,MAAM,CAAS,EAAA,CAAA;IACtB;EACF;EAEA84B,sBAAsBA,CACpB7oD,IAAsE,EACtEuN,IAEC,EACiE;IAClE,IAAI,CAAC66C,eAAe,CAAW76C,EAAAA,EAAAA,IAAI,CAAC;IACpC,IAAI,CAACq7C,0BAA0B,EAAE;IACjC,OAAO,IAAI,CAAC92C,UAAU,CAACvE,IAAI,EAAEvN,IAAI,CAAC;EACpC;EAEA8oD,+BAA+BA,CAAAA,EAAG;IAChC,IAAI,CAAC3xC,IAAI,EAAE;IACX,IAAI/c,iBAAiB,CAAC,IAAI,CAACga,KAAK,CAACxU,IAAI,CAAC,EAAE;MACtC,IAAI,CAACuX,IAAI,EAAE;MACX,OAAO,IAAI,CAACsM,KAAK,CAAU,EAAA,CAAA;IAC7B;IACA,OAAO,KAAK;EACd;EAEAslC,wBAAwBA,CACtBx7C,IAAgC,EACO;IACvC,IACE,EACE,IAAI,CAACkW,KAAK,GAAa,IACvB,IAAI,CAACulC,WAAW,CAAC,IAAI,CAACF,+BAA+B,CAAChE,IAAI,CAAC,IAAI,CAAC,CAAC,CAClE,EACD;MACA,OAAO/3D,SAAS;IAClB;IAEA,IAAI,CAACgjC,MAAM,CAAa,CAAA,CAAA;IACxB,MAAM3e,EAAE,GAAG,IAAI,CAACqnB,eAAe,EAAE;IACjCrnB,EAAE,CAAC6nB,cAAc,GAAG,IAAI,CAACuuB,qBAAqB,EAAE;IAChD,IAAI,CAACjyC,gBAAgB,CAACnE,EAAE,CAAC;IAEzB,IAAI,CAAC2e,MAAM,CAAa,CAAA,CAAA;IACxBxiB,IAAI,CAAC07C,UAAU,GAAG,CAAC73C,EAAE,CAAC;IAEtB,MAAMxR,IAAI,GAAG,IAAI,CAACspD,wBAAwB,EAAE;IAC5C,IAAItpD,IAAI,EAAE2N,IAAI,CAAC0rB,cAAc,GAAGr5B,IAAI;IACpC,IAAI,CAACgpD,0BAA0B,EAAE;IACjC,OAAO,IAAI,CAAC92C,UAAU,CAACvE,IAAI,EAAE,kBAAkB,CAAC;EAClD;EAEA47C,gCAAgCA,CAC9B57C,IAAiD,EACjD67C,QAAiB,EAC4B;IAC7C,IAAI,IAAI,CAACpjC,GAAG,CAAA,EAAA,CAAa,EAAEzY,IAAI,CAACkG,QAAQ,GAAG,IAAI;IAC/C,MAAM41C,OAAY,GAAG97C,IAAI;IAEzB,IAAI,IAAI,CAACkW,KAAK,CAAA,EAAA,CAAW,IAAI,IAAI,CAACA,KAAK,CAAA,EAAA,CAAO,EAAE;MAC9C,IAAI2lC,QAAQ,EAAE;QACZ,IAAI,CAAC91C,KAAK,CAAC8sC,QAAQ,CAAC8C,0BAA0B,EAAE;UAAElwD,EAAE,EAAEua;QAAK,CAAC,CAAC;MAC/D;MACA,MAAMoC,MAA2B,GAAG05C,OAAO;MAC3C,IAAI15C,MAAM,CAAC3P,IAAI,IAAI,IAAI,CAACyjB,KAAK,IAAO,EAAE;QACpC,IAAI,CAACnQ,KAAK,CAAC8sC,QAAQ,CAACM,+BAA+B,EAAE;UACnD1tD,EAAE,EAAE,IAAI,CAACohB,KAAK,CAACoN,WAAW;QAC5B,CAAC,CAAC;MACJ;MACA,IAAI,CAAC4mC,eAAe,CAAWz4C,EAAAA,EAAAA,MAAM,CAAC;MACtC,IAAI,CAACi5C,0BAA0B,EAAE;MACjC,MAAMJ,SAAS,GAEX,YAAY;MAChB,MAAMC,aAAa,GAEf,gBAAgB;MACpB,IAAI94C,MAAM,CAAC3P,IAAI,KAAK,KAAK,EAAE;QACzB,IAAI2P,MAAM,CAAC64C,SAAS,CAAC,CAAC7sD,MAAM,GAAG,CAAC,EAAE;UAChC,IAAI,CAAC2X,KAAK,CAAClG,MAAM,CAAC3M,cAAc,EAAE;YAAEzN,EAAE,EAAE,IAAI,CAACohB,KAAK,CAACoN,WAAW;UAAG,CAAC,CAAC;UACnE,IAAI,IAAI,CAACmiB,WAAW,CAACh0B,MAAM,CAAC64C,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE;YAC1C,IAAI,CAACl1C,KAAK,CAAC8sC,QAAQ,CAACK,iCAAiC,EAAE;cACrDztD,EAAE,EAAE,IAAI,CAACohB,KAAK,CAACoN,WAAW;YAC5B,CAAC,CAAC;UACJ;QACF;MACF,CAAC,MAAM,IAAI7R,MAAM,CAAC3P,IAAI,KAAK,KAAK,EAAE;QAChC,IAAI2P,MAAM,CAAC64C,SAAS,CAAC,CAAC7sD,MAAM,KAAK,CAAC,EAAE;UAClC,IAAI,CAAC2X,KAAK,CAAClG,MAAM,CAAC1M,cAAc,EAAE;YAAE1N,EAAE,EAAE,IAAI,CAACohB,KAAK,CAACoN,WAAW;UAAG,CAAC,CAAC;QACrE,CAAC,MAAM;UACL,MAAM8nC,cAAc,GAAG35C,MAAM,CAAC64C,SAAS,CAAC,CAAC,CAAC,CAAC;UAC3C,IAAI,IAAI,CAAC7kB,WAAW,CAAC2lB,cAAc,CAAC,EAAE;YACpC,IAAI,CAACh2C,KAAK,CAAC8sC,QAAQ,CAACK,iCAAiC,EAAE;cACrDztD,EAAE,EAAE,IAAI,CAACohB,KAAK,CAACoN,WAAW;YAC5B,CAAC,CAAC;UACJ;UACA,IACE8nC,cAAc,CAAC1pD,IAAI,KAAK,YAAY,IACpC0pD,cAAc,CAAC71C,QAAQ,EACvB;YACA,IAAI,CAACH,KAAK,CAAC8sC,QAAQ,CAACiD,qCAAqC,EAAE;cACzDrwD,EAAE,EAAE,IAAI,CAACohB,KAAK,CAACoN,WAAW;YAC5B,CAAC,CAAC;UACJ;UACA,IAAI8nC,cAAc,CAAC1pD,IAAI,KAAK,aAAa,EAAE;YACzC,IAAI,CAAC0T,KAAK,CAAC8sC,QAAQ,CAACkD,iCAAiC,EAAE;cACrDtwD,EAAE,EAAE,IAAI,CAACohB,KAAK,CAACoN,WAAW;YAC5B,CAAC,CAAC;UACJ;QACF;QACA,IAAI7R,MAAM,CAAC84C,aAAa,CAAC,EAAE;UACzB,IAAI,CAACn1C,KAAK,CAAC8sC,QAAQ,CAACmD,8BAA8B,EAAE;YAClDvwD,EAAE,EAAE2c,MAAM,CAAC84C,aAAa;UAC1B,CAAC,CAAC;QACJ;MACF,CAAC,MAAM;QACL94C,MAAM,CAAC3P,IAAI,GAAG,QAAQ;MACxB;MACA,OAAO,IAAI,CAAC8R,UAAU,CAACnC,MAAM,EAAE,mBAAmB,CAAC;IACrD,CAAC,MAAM;MACL,MAAMohB,QAA+B,GAAGs4B,OAAO;MAC/C,IAAID,QAAQ,EAAEr4B,QAAQ,CAACq4B,QAAQ,GAAG,IAAI;MACtC,MAAMxpD,IAAI,GAAG,IAAI,CAACspD,wBAAwB,EAAE;MAC5C,IAAItpD,IAAI,EAAEmxB,QAAQ,CAACkI,cAAc,GAAGr5B,IAAI;MACxC,IAAI,CAACgpD,0BAA0B,EAAE;MACjC,OAAO,IAAI,CAAC92C,UAAU,CAACif,QAAQ,EAAE,qBAAqB,CAAC;IACzD;EACF;EAEAw4B,iBAAiBA,CAAAA,EAAoB;IACnC,MAAMh8C,IAAS,GAAG,IAAI,CAACqE,SAAS,EAAE;IAElC,IAAI,IAAI,CAAC6R,KAAK,CAAA,EAAA,CAAW,IAAI,IAAI,CAACA,KAAK,CAAA,EAAA,CAAO,EAAE;MAC9C,OAAO,IAAI,CAAColC,sBAAsB,CAAC,4BAA4B,EAAEt7C,IAAI,CAAC;IACxE;IAEA,IAAI,IAAI,CAACkW,KAAK,CAAA,EAAA,CAAS,EAAE;MACvB,MAAMrS,EAAE,GAAG,IAAI,CAACQ,SAAS,EAAgB;MACzC,IAAI,CAACuF,IAAI,EAAE;MACX,IAAI,IAAI,CAACsM,KAAK,CAAA,EAAA,CAAW,IAAI,IAAI,CAACA,KAAK,CAAA,EAAA,CAAO,EAAE;QAC9C,OAAO,IAAI,CAAColC,sBAAsB,CAChC,iCAAiC,EACjCt7C,IAAI,CACL;MACH,CAAC,MAAM;QACLA,IAAI,CAACnf,GAAG,GAAG,IAAI,CAAC4wC,gBAAgB,CAAC5tB,EAAE,EAAE,KAAK,CAAC;QAC3C,OAAO,IAAI,CAAC+3C,gCAAgC,CAAC57C,IAAI,EAAE,KAAK,CAAC;MAC3D;IACF;IAEA,IAAI,CAACs3C,gBAAgB,CACnB;MACEE,gBAAgB,EAAE,CAAC,UAAU,CAAC;MAC9BC,mBAAmB,EAAE,CACnB,SAAS,EACT,UAAU,EACV,SAAS,EACT,WAAW,EACX,QAAQ,EACR,QAAQ,EACR,UAAU;IAEb,CAAA,EACDz3C,IAAI,CACL;IAED,MAAMi8C,GAAG,GAAG,IAAI,CAACT,wBAAwB,CAACx7C,IAAI,CAAC;IAC/C,IAAIi8C,GAAG,EAAE;MACP,OAAOA,GAAG;IACZ;IAEA,KAAK,CAACxK,iBAAiB,CAACzxC,IAAI,CAAC;IAC7B,IACE,CAACA,IAAI,CAACsE,QAAQ,IACdtE,IAAI,CAACnf,GAAG,CAACwR,IAAI,KAAK,YAAY,KAC7B2N,IAAI,CAACnf,GAAG,CAAC6B,IAAI,KAAK,KAAK,IAAIsd,IAAI,CAACnf,GAAG,CAAC6B,IAAI,KAAK,KAAK,CAAC,IACpD,IAAI,CAACo1D,wBAAwB,EAAE,EAC/B;MACA93C,IAAI,CAACvN,IAAI,GAAGuN,IAAI,CAACnf,GAAG,CAAC6B,IAAI;MACzB,KAAK,CAAC+uD,iBAAiB,CAACzxC,IAAI,CAAC;IAC/B;IACA,OAAO,IAAI,CAAC47C,gCAAgC,CAAC57C,IAAI,EAAE,CAAC,CAACA,IAAI,CAAC67C,QAAQ,CAAC;EACrE;EAEAK,kBAAkBA,CAAAA,EAAoB;IACpC,MAAMl8C,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAmB;IAC9CrE,IAAI,CAACw7B,OAAO,GAAG,IAAI,CAAC2gB,wBAAwB,EAAE;IAC9C,OAAO,IAAI,CAAC53C,UAAU,CAACvE,IAAI,EAAE,eAAe,CAAC;EAC/C;EAEAm8C,wBAAwBA,CAAAA,EAA2B;IACjD,IAAI,CAAC35B,MAAM,CAAW,CAAA,CAAA;IACtB,MAAMgZ,OAAO,GAAG,IAAI,CAACqd,WAAW,CAC9B,aAAa,EACb,IAAI,CAACmD,iBAAiB,CAACzE,IAAI,CAAC,IAAI,CAAC,CAClC;IACD,IAAI,CAAC/0B,MAAM,CAAW,CAAA,CAAA;IACtB,OAAOgZ,OAAO;EAChB;EAEA4gB,qBAAqBA,CAAAA,EAAY;IAC/B,IAAI,CAACxyC,IAAI,EAAE;IACX,IAAI,IAAI,CAAC6O,GAAG,CAAA,EAAA,CAAY,EAAE;MACxB,OAAO,IAAI,CAACiJ,YAAY,CAAc,GAAA,CAAA;IACxC;IACA,IAAI,IAAI,CAACA,YAAY,CAAA,GAAA,CAAc,EAAE;MACnC,IAAI,CAAC9X,IAAI,EAAE;IACb;IACA,IAAI,CAAC,IAAI,CAACsM,KAAK,GAAa,EAAE;MAC5B,OAAO,KAAK;IACd;IACA,IAAI,CAACtM,IAAI,EAAE;IACX,IAAI,CAAC,IAAI,CAACiuC,cAAc,EAAE,EAAE;MAC1B,OAAO,KAAK;IACd;IACA,IAAI,CAACjuC,IAAI,EAAE;IACX,OAAO,IAAI,CAACsM,KAAK,CAAQ,EAAA,CAAA;EAC3B;EAEAmmC,0BAA0BA,CAAAA,EAAsB;IAC9C,MAAMr8C,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAqB;IAChDrE,IAAI,CAACtd,IAAI,GAAG,IAAI,CAAC83D,wBAAwB,EAAE;IAC3Cx6C,IAAI,CAACy6C,UAAU,GAAG,IAAI,CAAC6B,qBAAqB,CAAQ,EAAA,CAAA;IACpD,OAAO,IAAI,CAAC/3C,UAAU,CAACvE,IAAI,EAAE,iBAAiB,CAAC;EACjD;EAEAu8C,iBAAiBA,CAAAA,EAAmB;IAClC,MAAMv8C,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAkB;IAE7C,IAAI,CAACme,MAAM,CAAW,CAAA,CAAA;IAEtB,IAAI,IAAI,CAACtM,KAAK,CAAA,EAAA,CAAY,EAAE;MAC1BlW,IAAI,CAAC67C,QAAQ,GAAG,IAAI,CAACh1C,KAAK,CAACnX,KAAK;MAChC,IAAI,CAACka,IAAI,EAAE;MACX,IAAI,CAACqY,gBAAgB,CAAc,GAAA,CAAA;IACpC,CAAA,MAAM,IAAI,IAAI,CAACD,aAAa,KAAc,EAAE;MAC3ChiB,IAAI,CAAC67C,QAAQ,GAAG,IAAI;IACtB;IAEA,IAAI,CAACr5B,MAAM,CAAa,CAAA,CAAA;IACxBxiB,IAAI,CAAC8uB,aAAa,GAAG,IAAI,CAACutB,0BAA0B,EAAE;IACtDr8C,IAAI,CAACw8C,QAAQ,GAAG,IAAI,CAACx6B,aAAa,CAAQ,EAAA,CAAA,GAAG,IAAI,CAACy6B,WAAW,EAAE,GAAG,IAAI;IAEtE,IAAI,CAACj6B,MAAM,CAAa,CAAA,CAAA;IAExB,IAAI,IAAI,CAACtM,KAAK,CAAA,EAAA,CAAY,EAAE;MAC1BlW,IAAI,CAACkG,QAAQ,GAAG,IAAI,CAACW,KAAK,CAACnX,KAAK;MAChC,IAAI,CAACka,IAAI,EAAE;MACX,IAAI,CAAC4Y,MAAM,CAAa,EAAA,CAAA;IACzB,CAAA,MAAM,IAAI,IAAI,CAAC/J,GAAG,IAAa,EAAE;MAChCzY,IAAI,CAACkG,QAAQ,GAAG,IAAI;IACtB;IAEAlG,IAAI,CAAC0rB,cAAc,GAAG,IAAI,CAACgxB,cAAc,EAAE;IAC3C,IAAI,CAACp6B,SAAS,EAAE;IAChB,IAAI,CAACE,MAAM,CAAW,CAAA,CAAA;IAEtB,OAAO,IAAI,CAACje,UAAU,CAACvE,IAAI,EAAE,cAAc,CAAC;EAC9C;EAEA28C,gBAAgBA,CAAAA,EAAkB;IAChC,MAAM38C,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAiB;IAC5CrE,IAAI,CAAC48C,YAAY,GAAG,IAAI,CAACxD,oBAAoB,CAC3C,mBAAmB,EACnB,IAAI,CAACyD,uBAAuB,CAACtF,IAAI,CAAC,IAAI,CAAC,EACzB,IAAI,EACG,KAAK,CAC3B;IAID,IAAIuF,mBAAmB,GAAG,KAAK;IAC/B,IAAIC,eAA+B,GAAG,IAAI;IAC1C/8C,IAAI,CAAC48C,YAAY,CAACljC,OAAO,CAACsjC,WAAW,IAAI;MAAA,IAAAC,gBAAA;MACvC,MAAM;QAAE5qD;MAAM,CAAA,GAAG2qD,WAAW;MAE5B,IACEF,mBAAmB,IACnBzqD,IAAI,KAAK,YAAY,IACrBA,IAAI,KAAK,gBAAgB,IACzB,EAAEA,IAAI,KAAK,oBAAoB,IAAI2qD,WAAW,CAAC92C,QAAQ,CAAC,EACxD;QACA,IAAI,CAACH,KAAK,CAAC8sC,QAAQ,CAAC0C,0BAA0B,EAAE;UAC9C9vD,EAAE,EAAEu3D;QACN,CAAC,CAAC;MACJ;MAEAF,mBAAmB,KAAnBA,mBAAmB,GAChBzqD,IAAI,KAAK,oBAAoB,IAAI2qD,WAAW,CAAC92C,QAAQ,IACtD7T,IAAI,KAAK,gBAAgB,CAAA;MAG3B,IAAI6qD,SAAS,GAAG7qD,IAAI;MACpB,IAAIA,IAAI,KAAK,YAAY,EAAE;QACzB2qD,WAAW,GAAGA,WAAW,CAACtxB,cAAc;QACxCwxB,SAAS,GAAGF,WAAW,CAAC3qD,IAAI;MAC9B;MAEA,MAAM8qD,SAAS,GAAGD,SAAS,KAAK,oBAAoB;MACpD,CAAAD,gBAAA,GAAAF,eAAe,KAAA,IAAA,GAAAE,gBAAA,GAAfF,eAAe,GAAKI,SAAS;MAC7B,IAAIJ,eAAe,KAAKI,SAAS,EAAE;QACjC,IAAI,CAACp3C,KAAK,CAAC8sC,QAAQ,CAACuC,gCAAgC,EAAE;UACpD3vD,EAAE,EAAEu3D;QACN,CAAC,CAAC;MACJ;IACF,CAAC,CAAC;IAEF,OAAO,IAAI,CAACz4C,UAAU,CAACvE,IAAI,EAAE,aAAa,CAAC;EAC7C;EAEA68C,uBAAuBA,CAAAA,EAAoC;IAGzD,MAAM;MAAE33C;KAAU,GAAG,IAAI,CAAC2B,KAAK;IAE/B,MAAMlH,IAAI,GAAG,IAAI,CAAC8Y,GAAG,CAAa,EAAA,CAAA;IAElC,IAAI2kC,OAAgB;IACpB,IAAIn7D,KAAmB;IACvB,IAAIikB,QAAiB;IACrB,IAAI7T,IAAqC;IAEzC,MAAMgrD,MAAM,GAAGtwD,0BAA0B,CAAC,IAAI,CAAC8Z,KAAK,CAACxU,IAAI,CAAC;IAC1D,MAAMirD,WAAW,GAAGD,MAAM,GAAG,IAAI,CAACnkC,iBAAiB,EAAE,GAAG,IAAI;IAC5D,IAAIokC,WAAW,OAAoB,EAAE;MACnCF,OAAO,GAAG,IAAI;MACdl3C,QAAQ,GAAG,KAAK;MAChBjkB,KAAK,GAAG,IAAI,CAACipC,eAAe,CAAC,IAAI,CAAC;MAClC,IAAI,CAAC1I,MAAM,CAAU,EAAA,CAAA;MACrBnwB,IAAI,GAAG,IAAI,CAACoqD,WAAW,EAAE;IAC3B,CAAC,MAAM,IAAIa,WAAW,KAAA,EAA2B,EAAE;MACjDp3C,QAAQ,GAAG,IAAI;MACf,MAAMhB,QAAQ,GAAG,IAAI,CAAC2B,KAAK,CAAC3B,QAAQ;MACpC,MAAMq4C,QAAQ,GAAG,IAAI,CAAC12C,KAAK,CAACnX,KAAK;MACjC,MAAM8tD,WAAW,GAAG,IAAI,CAACC,mBAAmB,EAAE;MAE9C,IAAI,IAAI,CAACvkC,iBAAiB,EAAE,OAAoB,EAAE;QAChDkkC,OAAO,GAAG,IAAI;QACdn7D,KAAK,GAAG,IAAI,CAACwvC,gBAAgB,CAC3B,IAAI,CAACpM,WAAW,CAAengB,QAAQ,CAAC,EACxCq4C,QAAQ,CACT;QACD,IAAI,CAAC/6B,MAAM,CAAa,EAAA,CAAA;QACxB,IAAI,CAACA,MAAM,CAAU,EAAA,CAAA;QACrBnwB,IAAI,GAAG,IAAI,CAACoqD,WAAW,EAAE;MAC3B,CAAC,MAAM;QACLW,OAAO,GAAG,KAAK;QACf/qD,IAAI,GAAGmrD,WAAW;QAClB,IAAI,CAACh7B,MAAM,CAAa,EAAA,CAAA;MAC1B;IACF,CAAC,MAAM;MACLnwB,IAAI,GAAG,IAAI,CAACoqD,WAAW,EAAE;MACzBv2C,QAAQ,GAAG,IAAI,CAACuS,GAAG,CAAa,EAAA,CAAA;MAIhC2kC,OAAO,GAAG,IAAI,CAAC3kC,GAAG,CAAU,EAAA,CAAA;IAC9B;IAEA,IAAI2kC,OAAO,EAAE;MACX,IAAIM,WAAyC;MAC7C,IAAIz7D,KAAK,EAAE;QACTy7D,WAAW,GAAG,IAAI,CAAC/1C,eAAe,CAAuB1lB,KAAK,CAAC;QAC/Dy7D,WAAW,CAACx3C,QAAQ,GAAGA,QAAQ;QAC/Bw3C,WAAW,CAACz7D,KAAK,GAAGA,KAAK;QACzBy7D,WAAW,CAAC9+B,WAAW,GAAGvsB,IAAI;QAE9B,IAAI,IAAI,CAAComB,GAAG,CAAA,EAAA,CAAa,EAAE;UACzBilC,WAAW,CAACx3C,QAAQ,GAAG,IAAI;UAC3B,IAAI,CAACH,KAAK,CAAC8sC,QAAQ,CAACuD,sBAAsB,EAAE;YAC1C3wD,EAAE,EAAE,IAAI,CAACohB,KAAK,CAACC;UACjB,CAAC,CAAC;QACJ;MACF,CAAC,MAAM;QACL42C,WAAW,GAAG,IAAI,CAAC/1C,eAAe,CAAuBtV,IAAI,CAAC;QAC9DqrD,WAAW,CAACx3C,QAAQ,GAAGA,QAAQ;QAC/B,IAAI,CAACH,KAAK,CAAC8sC,QAAQ,CAACqC,uBAAuB,EAAE;UAAEzvD,EAAE,EAAE4M;QAAK,CAAC,CAAC;QAG1DqrD,WAAW,CAACz7D,KAAK,GAAGoQ,IAAI;QACxBqrD,WAAW,CAAC9+B,WAAW,GAAG,IAAI,CAAC69B,WAAW,EAAE;MAC9C;MACApqD,IAAI,GAAG,IAAI,CAACkS,UAAU,CAACm5C,WAAW,EAAE,oBAAoB,CAAC;IAC1D,CAAA,MAAM,IAAIx3C,QAAQ,EAAE;MACnB,MAAMy3C,gBAAgB,GAAG,IAAI,CAACh2C,eAAe,CAAmBtV,IAAI,CAAC;MACrEsrD,gBAAgB,CAACjyB,cAAc,GAAGr5B,IAAI;MACtCA,IAAI,GAAG,IAAI,CAACkS,UAAU,CAACo5C,gBAAgB,EAAE,gBAAgB,CAAC;IAC5D;IAEA,IAAIh+C,IAAI,EAAE;MACR,MAAMi+C,QAAQ,GAAG,IAAI,CAACv4B,WAAW,CAAengB,QAAQ,CAAC;MACzD04C,QAAQ,CAAClyB,cAAc,GAAGr5B,IAAI;MAC9BA,IAAI,GAAG,IAAI,CAACkS,UAAU,CAACq5C,QAAQ,EAAE,YAAY,CAAC;IAChD;IAEA,OAAOvrD,IAAI;EACb;EAEAwrD,wBAAwBA,CAAAA,EAA0B;IAChD,MAAM79C,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAyB;IACpD,IAAI,CAACme,MAAM,CAAW,EAAA,CAAA;IACtBxiB,IAAI,CAAC0rB,cAAc,GAAG,IAAI,CAAC+wB,WAAW,EAAE;IACxC,IAAI,CAACj6B,MAAM,CAAW,EAAA,CAAA;IACtB,OAAO,IAAI,CAACje,UAAU,CAACvE,IAAI,EAAE,qBAAqB,CAAC;EACrD;EAEA89C,gCAAgCA,CAC9BzrD,IAA4C,EAC5C0rD,QAAkB,EACa;IAC/B,MAAM/9C,IAAI,GAAG,IAAI,CAACqE,SAAS,EAExB;IACH,IAAIhS,IAAI,KAAK,mBAAmB,EAAE;MAC/B2N,IAAI,CAAiC+9C,QAAQ,GAAG,CAAC,CAACA,QAAQ;MAC3D,IAAIA,QAAQ,EAAE,IAAI,CAACn0C,IAAI,EAAE;MACzB,IAAI,CAACA,IAAI,EAAE;IACb;IACA,IAAI,CAACo0C,gCAAgC,CAAC,MACpC,IAAI,CAACnD,eAAe,CAAA,EAAA,EAAW76C,IAAI,CAAC,CACrC;IACD,OAAO,IAAI,CAACuE,UAAU,CAACvE,IAAI,EAAE3N,IAAI,CAAC;EACpC;EAEA4rD,sBAAsBA,CAAAA,EAAoB;IACxC,MAAMj+C,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAmB;IAE9CrE,IAAI,CAACk7B,OAAO,GAAG,CAAC,MAAM;MACpB,QAAQ,IAAI,CAACr0B,KAAK,CAACxU,IAAI;QACrB,KAAA,GAAA;QACA,KAAA,GAAA;QACA,KAAA,GAAA;QACA,KAAA,EAAA;QACA,KAAA,EAAA;UAEE,OAAO,KAAK,CAACg6B,aAAa,EAAE;QAC9B;UACE,IAAI,CAACl1B,UAAU,EAAE;MAAA;IAEvB,CAAC,GAAG;IACJ,OAAO,IAAI,CAACoN,UAAU,CAACvE,IAAI,EAAE,eAAe,CAAC;EAC/C;EAEAk+C,0BAA0BA,CAAAA,EAAa;IACrC,MAAMl+C,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAmB;IAC9CrE,IAAI,CAACk7B,OAAO,GAAG,KAAK,CAACijB,aAAa,CAAC,KAAK,CAAC;IACzC,OAAO,IAAI,CAAC55C,UAAU,CAACvE,IAAI,EAAE,eAAe,CAAC;EAC/C;EAEAo+C,yBAAyBA,CAAAA,EAAsB;IAC7C,IAAI,IAAI,CAACv3C,KAAK,CAACgM,MAAM,EAAE,OAAO,IAAI,CAAC4pC,WAAW,EAAE;IAChD,OAAO,KAAK,CAAC2B,yBAAyB,EAAE;EAC1C;EAEAC,kCAAkCA,CAAAA,EAAqC;IACrE,MAAMC,WAAW,GAAG,IAAI,CAACnE,mBAAmB,EAAE;IAC9C,IAAI,IAAI,CAACz4B,YAAY,CAAQ,GAAA,CAAA,IAAI,CAAC,IAAI,CAACS,qBAAqB,EAAE,EAAE;MAC9D,OAAO,IAAI,CAAC23B,wBAAwB,CAACwE,WAAW,CAAC;IACnD,CAAC,MAAM;MACL,OAAOA,WAAW;IACpB;EACF;EAEAb,mBAAmBA,CAAAA,EAAa;IAC9B,QAAQ,IAAI,CAAC52C,KAAK,CAACxU,IAAI;MACrB,KAAA,GAAA;MACA,KAAA,GAAA;MACA,KAAA,GAAA;MACA,KAAA,EAAA;MACA,KAAA,EAAA;QACE,OAAO,IAAI,CAAC4rD,sBAAsB,EAAE;MACtC,KAAA,EAAA;QACE,IAAI,IAAI,CAACp3C,KAAK,CAACnX,KAAK,KAAK,GAAG,EAAE;UAC5B,MAAMsQ,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAmB;UAC9C,MAAMmU,SAAS,GAAG,IAAI,CAACI,SAAS,EAAE;UAClC,IAAIJ,SAAS,CAACnmB,IAAI,KAAA,GAAW,IAAImmB,SAAS,CAACnmB,IAAI,KAAA,GAAc,EAAE;YAC7D,IAAI,CAAC8E,UAAU,EAAE;UACnB;UAEA6I,IAAI,CAACk7B,OAAO,GAAG,IAAI,CAACqjB,eAAe,EAAE;UACrC,OAAO,IAAI,CAACh6C,UAAU,CAACvE,IAAI,EAAE,eAAe,CAAC;QAC/C;QACA;MACF,KAAA,EAAA;QACE,OAAO,IAAI,CAACq+C,kCAAkC,EAAE;MAClD,KAAA,EAAA;QACE,OAAO,IAAI,CAACjE,gBAAgB,EAAE;MAChC,KAAA,EAAA;QACE,OAAO,IAAI,CAACb,iBAAiB,EAAE;MACjC,KAAA,CAAA;QACE,OAAO,IAAI,CAACkC,WAAW,CAAC,IAAI,CAACW,qBAAqB,CAAC7E,IAAI,CAAC,IAAI,CAAC,CAAC,GAC1D,IAAI,CAACgF,iBAAiB,EAAE,GACxB,IAAI,CAACL,kBAAkB,EAAE;MAC/B,KAAA,CAAA;QACE,OAAO,IAAI,CAACS,gBAAgB,EAAE;MAChC,KAAA,EAAA;QAaE,OAAO,IAAI,CAACkB,wBAAwB,EAAE;MACxC,KAAA,EAAA;MACA,KAAA,EAAA;QACE,OAAO,IAAI,CAACK,0BAA0B,EAAE;MAC1C;QAAS;UACP,MAAM;YAAE7rD;WAAM,GAAG,IAAI,CAACwU,KAAK;UAC3B,IACEha,iBAAiB,CAACwF,IAAI,CAAC,IACvBA,IAAI,KAAa,EAAA,IACjBA,IAAI,KAAA,EAAa,EACjB;YACA,MAAMmsD,QAAQ,GACZnsD,IAAI,OAAa,GACb,eAAe,GACfA,IAAI,KAAA,EAAa,GACjB,eAAe,GACf2kD,mBAAmB,CAAC,IAAI,CAACnwC,KAAK,CAACnX,KAAK,CAAC;YAC3C,IACE8uD,QAAQ,KAAKh/D,SAAS,IACtB,IAAI,CAAC05B,iBAAiB,EAAE,KAAA,EAAkB,EAC1C;cACA,MAAMlZ,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAmB;cAC9C,IAAI,CAACuF,IAAI,EAAE;cACX,OAAO,IAAI,CAACrF,UAAU,CAACvE,IAAI,EAAEw+C,QAAQ,CAAC;YACxC;YACA,OAAO,IAAI,CAAC5E,oBAAoB,EAAE;UACpC;QACF;IAAA;IAGF,IAAI,CAACziD,UAAU,EAAE;EACnB;EAEAsnD,wBAAwBA,CAAAA,EAAa;IACnC,IAAIpsD,IAAI,GAAG,IAAI,CAACorD,mBAAmB,EAAE;IACrC,OAAO,CAAC,IAAI,CAACt7B,qBAAqB,EAAE,IAAI,IAAI,CAAC1J,GAAG,CAAA,CAAA,CAAa,EAAE;MAC7D,IAAI,IAAI,CAACvC,KAAK,CAAA,CAAA,CAAa,EAAE;QAC3B,MAAMlW,IAAI,GAAG,IAAI,CAAC2H,eAAe,CAAgBtV,IAAI,CAAC;QACtD2N,IAAI,CAAC4e,WAAW,GAAGvsB,IAAI;QACvB,IAAI,CAACmwB,MAAM,CAAa,CAAA,CAAA;QACxBnwB,IAAI,GAAG,IAAI,CAACkS,UAAU,CAACvE,IAAI,EAAE,aAAa,CAAC;MAC7C,CAAC,MAAM;QACL,MAAMA,IAAI,GAAG,IAAI,CAAC2H,eAAe,CAAwBtV,IAAI,CAAC;QAC9D2N,IAAI,CAAC4xB,UAAU,GAAGv/B,IAAI;QACtB2N,IAAI,CAAC6xB,SAAS,GAAG,IAAI,CAAC4qB,WAAW,EAAE;QACnC,IAAI,CAACj6B,MAAM,CAAa,CAAA,CAAA;QACxBnwB,IAAI,GAAG,IAAI,CAACkS,UAAU,CAACvE,IAAI,EAAE,qBAAqB,CAAC;MACrD;IACF;IACA,OAAO3N,IAAI;EACb;EAEAqsD,mBAAmBA,CAAAA,EAAqB;IACtC,MAAM1+C,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAoB;IAC/C,MAAMisC,QAAQ,GAAG,IAAI,CAACzpC,KAAK,CAACnX,KAAK;IACjC,IAAI,CAACka,IAAI,EAAE;IACX5J,IAAI,CAACswC,QAAQ,GAAGA,QAAQ;IACxBtwC,IAAI,CAAC0rB,cAAc,GAAG,IAAI,CAACizB,2BAA2B,EAAE;IAExD,IAAIrO,QAAQ,KAAK,UAAU,EAAE;MAC3B,IAAI,CAACsO,gCAAgC,CAEnC5+C,IAAI,CACL;IACH;IAEA,OAAO,IAAI,CAACuE,UAAU,CAACvE,IAAI,EAAE,gBAAgB,CAAC;EAChD;EAEA4+C,gCAAgCA,CAAC5+C,IAAY,EAAE;IAC7C,QAAQA,IAAI,CAAC0rB,cAAc,CAACr5B,IAAI;MAC9B,KAAK,aAAa;MAClB,KAAK,aAAa;QAChB;MACF;QACE,IAAI,CAAC0T,KAAK,CAAC8sC,QAAQ,CAAC6D,kBAAkB,EAAE;UAAEjxD,EAAE,EAAEua;QAAK,CAAC,CAAC;IAAA;EAE3D;EAEA6+C,gBAAgBA,CAAAA,EAAkB;IAChC,MAAM7+C,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAiB;IAC5C,IAAI,CAAC4d,gBAAgB,CAAW,GAAA,CAAA;IAChC,MAAM6M,aAAa,GAAG,IAAI,CAACzqB,SAAS,EAAqB;IACzDyqB,aAAa,CAACpsC,IAAI,GAAG,IAAI,CAAC83D,wBAAwB,EAAE;IACpD1rB,aAAa,CAAC2rB,UAAU,GAAG,IAAI,CAACtC,UAAU,CAAC,MACzC,IAAI,CAAC2G,6BAA6B,EAAE,CACrC;IACD9+C,IAAI,CAAC8uB,aAAa,GAAG,IAAI,CAACvqB,UAAU,CAACuqB,aAAa,EAAE,iBAAiB,CAAC;IACtE,OAAO,IAAI,CAACvqB,UAAU,CAACvE,IAAI,EAAE,aAAa,CAAC;EAC7C;EAEA8+C,6BAA6BA,CAAAA,EAAG;IAC9B,IAAI,IAAI,CAACrmC,GAAG,CAAA,EAAA,CAAa,EAAE;MACzB,MAAMgiC,UAAU,GAAG,IAAI,CAACsE,mCAAmC,CAAC,MAC1D,IAAI,CAACtC,WAAW,EAAE,CACnB;MACD,IACE,IAAI,CAAC51C,KAAK,CAACqM,iCAAiC,IAC5C,CAAC,IAAI,CAACgD,KAAK,CAAA,EAAA,CAAa,EACxB;QACA,OAAOukC,UAAU;MACnB;IACF;EACF;EAEAkE,2BAA2BA,CAAAA,EAAa;IACtC,MAAMK,cAAc,GAClBtxD,qBAAqB,CAAC,IAAI,CAACmZ,KAAK,CAACxU,IAAI,CAAC,IAAI,CAAC,IAAI,CAACwU,KAAK,CAAC+M,WAAW;IACnE,OAAOorC,cAAc,GACjB,IAAI,CAACN,mBAAmB,EAAE,GAC1B,IAAI,CAACh9B,YAAY,CAAA,GAAA,CAAW,GAC5B,IAAI,CAACm9B,gBAAgB,EAAE,GACvB,IAAI,CAACb,gCAAgC,CAAC,MACpC,IAAI,CAACS,wBAAwB,EAAE,CAChC;EACP;EAEAQ,8BAA8BA,CAC5BxsD,IAA0C,EAC1CysD,oBAAoC,EACpC5O,QAAmB,EACT;IACV,MAAMtwC,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAwC;IACnE,MAAM86C,kBAAkB,GAAG,IAAI,CAAC1mC,GAAG,CAAC63B,QAAQ,CAAC;IAC7C,MAAMlvD,KAAK,GAAG,EAAE;IAChB,GAAG;MACDA,KAAK,CAACqC,IAAI,CAACy7D,oBAAoB,EAAE,CAAC;IACpC,CAAC,QAAQ,IAAI,CAACzmC,GAAG,CAAC63B,QAAQ,CAAC;IAC3B,IAAIlvD,KAAK,CAACgN,MAAM,KAAK,CAAC,IAAI,CAAC+wD,kBAAkB,EAAE;MAC7C,OAAO/9D,KAAK,CAAC,CAAC,CAAC;IACjB;IACA4e,IAAI,CAAC5e,KAAK,GAAGA,KAAK;IAClB,OAAO,IAAI,CAACmjB,UAAU,CAACvE,IAAI,EAAEvN,IAAI,CAAC;EACpC;EAEA2sD,+BAA+BA,CAAAA,EAAa;IAC1C,OAAO,IAAI,CAACH,8BAA8B,CACxC,oBAAoB,EACpB,IAAI,CAACN,2BAA2B,CAACpH,IAAI,CAAC,IAAI,CAAC,EAE5C,EAAA,CAAA;EACH;EAEA8H,wBAAwBA,CAAAA,EAAG;IACzB,OAAO,IAAI,CAACJ,8BAA8B,CACxC,aAAa,EACb,IAAI,CAACG,+BAA+B,CAAC7H,IAAI,CAAC,IAAI,CAAC,EAEhD,EAAA,CAAA;EACH;EAEA+H,uBAAuBA,CAAAA,EAAG;IACxB,IAAI,IAAI,CAACppC,KAAK,CAAA,EAAA,CAAO,EAAE;MACrB,OAAO,IAAI;IACb;IACA,OACE,IAAI,CAACA,KAAK,CAAW,EAAA,CAAA,IACrB,IAAI,CAACulC,WAAW,CAAC,IAAI,CAAC8D,oCAAoC,CAAChI,IAAI,CAAC,IAAI,CAAC,CAAC;EAE1E;EAEAiI,oBAAoBA,CAAAA,EAAY;IAC9B,IAAI3yD,iBAAiB,CAAC,IAAI,CAACga,KAAK,CAACxU,IAAI,CAAC,IAAI,IAAI,CAAC6jB,KAAK,IAAU,EAAE;MAC9D,IAAI,CAACtM,IAAI,EAAE;MACX,OAAO,IAAI;IACb;IAEA,IAAI,IAAI,CAACsM,KAAK,CAAA,CAAA,CAAW,EAAE;MAEzB,MAAM;QAAE1D;OAAQ,GAAG,IAAI,CAAC3L,KAAK;MAC7B,MAAM44C,kBAAkB,GAAGjtC,MAAM,CAACpkB,MAAM;MACxC,IAAI;QACF,IAAI,CAAC4iD,eAAe,CAAY,CAAA,EAAA,IAAI,CAAC;QACrC,OAAOx+B,MAAM,CAACpkB,MAAM,KAAKqxD,kBAAkB;MAC5C,CAAA,CAAC,OAAAz+C,OAAA,EAAM;QACN,OAAO,KAAK;MACd;IACF;IAEA,IAAI,IAAI,CAACkV,KAAK,CAAA,CAAA,CAAa,EAAE;MAC3B,IAAI,CAACtM,IAAI,EAAE;MAEX,MAAM;QAAE4I;OAAQ,GAAG,IAAI,CAAC3L,KAAK;MAC7B,MAAM44C,kBAAkB,GAAGjtC,MAAM,CAACpkB,MAAM;MACxC,IAAI;QACF,KAAK,CAAC0iD,gBAAgB,CAAA,CAAA,EAAA,EAAA,IAIrB;QACD,OAAOt+B,MAAM,CAACpkB,MAAM,KAAKqxD,kBAAkB;MAC5C,CAAA,CAAC,OAAAC,QAAA,EAAM;QACN,OAAO,KAAK;MACd;IACF;IAEA,OAAO,KAAK;EACd;EAEAH,oCAAoCA,CAAAA,EAAY;IAC9C,IAAI,CAAC31C,IAAI,EAAE;IACX,IAAI,IAAI,CAACsM,KAAK,CAAA,EAAA,CAAW,IAAI,IAAI,CAACA,KAAK,CAAA,EAAA,CAAa,EAAE;MAGpD,OAAO,IAAI;IACb;IACA,IAAI,IAAI,CAACspC,oBAAoB,EAAE,EAAE;MAC/B,IACE,IAAI,CAACtpC,KAAK,IAAU,IACpB,IAAI,CAACA,KAAK,CAAA,EAAA,CAAU,IACpB,IAAI,CAACA,KAAK,CAAa,EAAA,CAAA,IACvB,IAAI,CAACA,KAAK,IAAO,EACjB;QAKA,OAAO,IAAI;MACb;MACA,IAAI,IAAI,CAACA,KAAK,CAAA,EAAA,CAAW,EAAE;QACzB,IAAI,CAACtM,IAAI,EAAE;QACX,IAAI,IAAI,CAACsM,KAAK,CAAA,EAAA,CAAU,EAAE;UAExB,OAAO,IAAI;QACb;MACF;IACF;IACA,OAAO,KAAK;EACd;EAEAklC,oCAAoCA,CAClCN,WAAsB,EACF;IACpB,OAAO,IAAI,CAAC6E,QAAQ,CAAC,MAAM;MACzB,MAAMC,CAAC,GAAG,IAAI,CAACv7C,SAAS,EAAsB;MAC9C,IAAI,CAACme,MAAM,CAACs4B,WAAW,CAAC;MAExB,MAAM96C,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAqB;MAEhD,MAAM61C,OAAO,GAAG,CAAC,CAAC,IAAI,CAAC/B,UAAU,CAC/B,IAAI,CAAC0H,2BAA2B,CAACtI,IAAI,CAAC,IAAI,CAAC,CAC5C;MAED,IAAI2C,OAAO,IAAI,IAAI,CAAChkC,KAAK,IAAU,EAAE;QAGnC,IAAI4pC,iBAAiB,GAAG,IAAI,CAACzB,kCAAkC,EAAE;QAGjE,IAAIyB,iBAAiB,CAACztD,IAAI,KAAK,YAAY,EAAE;UAC3C2N,IAAI,CAACg6C,aAAa,GAAG8F,iBAAiB;UACtC9/C,IAAI,CAACk6C,OAAO,GAAG,IAAI;UAClBl6C,IAAI,CAAuB0rB,cAAc,GAAG,IAAI;UACjDo0B,iBAAiB,GAAG,IAAI,CAACv7C,UAAU,CAACvE,IAAI,EAAE,iBAAiB,CAAC;QAC9D,CAAC,MAAM;UACL,IAAI,CAACslB,0BAA0B,CAACw6B,iBAAiB,EAAE9/C,IAAI,CAAC;UACxD8/C,iBAAiB,CAAC5F,OAAO,GAAG,IAAI;QAClC;QACA0F,CAAC,CAACl0B,cAAc,GAAGo0B,iBAAiB;QACpC,OAAO,IAAI,CAACv7C,UAAU,CAACq7C,CAAC,EAAE,kBAAkB,CAAC;MAC/C;MAEA,MAAMG,qBAAqB,GACzB,IAAI,CAAClI,cAAc,EAAE,IACrB,IAAI,CAACM,UAAU,CAAC,IAAI,CAAC6H,0BAA0B,CAACzI,IAAI,CAAC,IAAI,CAAC,CAAC;MAE7D,IAAI,CAACwI,qBAAqB,EAAE;QAC1B,IAAI,CAAC7F,OAAO,EAAE;UAEZ,OAAO,IAAI,CAACD,qBAAqB,CAAgB,KAAK,EAAE2F,CAAC,CAAC;QAC5D;QAGA5/C,IAAI,CAACg6C,aAAa,GAAG,IAAI,CAAC9uB,eAAe,EAAE;QAC3ClrB,IAAI,CAACk6C,OAAO,GAAGA,OAAO;QACrBl6C,IAAI,CAAuB0rB,cAAc,GAAG,IAAI;QACjDk0B,CAAC,CAACl0B,cAAc,GAAG,IAAI,CAACnnB,UAAU,CAACvE,IAAI,EAAE,iBAAiB,CAAC;QAC3D,OAAO,IAAI,CAACuE,UAAU,CAACq7C,CAAC,EAAE,kBAAkB,CAAC;MAC/C;MAGA,MAAMvtD,IAAI,GAAG,IAAI,CAAC4nD,qBAAqB,CAAgB,KAAK,CAAC;MAC7Dj6C,IAAI,CAACg6C,aAAa,GAAG+F,qBAAqB;MAC1C//C,IAAI,CAAC0rB,cAAc,GAAGr5B,IAAI;MAC1B2N,IAAI,CAACk6C,OAAO,GAAGA,OAAO;MACtB0F,CAAC,CAACl0B,cAAc,GAAG,IAAI,CAACnnB,UAAU,CAACvE,IAAI,EAAE,iBAAiB,CAAC;MAC3D,OAAO,IAAI,CAACuE,UAAU,CAACq7C,CAAC,EAAE,kBAAkB,CAAC;IAC/C,CAAC,CAAC;EACJ;EAEAK,uCAAuCA,CAAAA,EAG9B;IACP,OAAO,IAAI,CAAC/pC,KAAK,CAAU,EAAA,CAAA,GACvB,IAAI,CAACklC,oCAAoC,CAAU,EAAA,CAAA,GACnD57D,SAAS;EACf;EAEAm8D,wBAAwBA,CAAAA,EAA0C;IAChE,OAAO,IAAI,CAACzlC,KAAK,CAAU,EAAA,CAAA,GAAG,IAAI,CAAC+jC,qBAAqB,EAAE,GAAGz6D,SAAS;EACxE;EAEAk9D,cAAcA,CAAAA,EAAgC;IAC5C,OAAO,IAAI,CAAChC,kBAAkB,CAAU,EAAA,CAAA;EAC1C;EAEAsF,0BAA0BA,CAAAA,EAAoC;IAC5D,MAAMn8C,EAAE,GAAG,IAAI,CAACqnB,eAAe,EAAE;IACjC,IAAI,IAAI,CAACxJ,YAAY,CAAQ,GAAA,CAAA,IAAI,CAAC,IAAI,CAACS,qBAAqB,EAAE,EAAE;MAC9D,IAAI,CAACvY,IAAI,EAAE;MACX,OAAO/F,EAAE;IACX;EACF;EAEAg8C,2BAA2BA,CAAAA,EAAY;IACrC,IAAI,IAAI,CAACh5C,KAAK,CAACxU,IAAI,QAAgB,EAAE;MACnC,OAAO,KAAK;IACd;IACA,MAAMuhB,WAAW,GAAG,IAAI,CAAC/M,KAAK,CAAC+M,WAAW;IAC1C,IAAI,CAAChK,IAAI,EAAE;IACX,IAAI,CAAC/c,iBAAiB,CAAC,IAAI,CAACga,KAAK,CAACxU,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC6jB,KAAK,IAAU,EAAE;MAChE,OAAO,KAAK;IACd;IAEA,IAAItC,WAAW,EAAE;MACf,IAAI,CAAC7N,KAAK,CAAClG,MAAM,CAACnJ,0BAA0B,EAAE;QAC5CjR,EAAE,EAAE,IAAI,CAACohB,KAAK,CAACC,eAAe;QAC9BnQ,YAAY,EAAE;MAChB,CAAC,CAAC;IACJ;IAEA,OAAO,IAAI;EACb;EAEAsjD,qBAAqBA,CACnBiG,QAAQ,GAAG,IAAI,EACfN,CAA6B,GAAG,IAAI,CAACv7C,SAAS,EAAsB,EAChD;IACpB,IAAI,CAACs7C,QAAQ,CAAC,MAAM;MAClB,IAAIO,QAAQ,EAAE,IAAI,CAAC19B,MAAM,CAAU,EAAA,CAAA;MACnCo9B,CAAC,CAACl0B,cAAc,GAAG,IAAI,CAAC+wB,WAAW,EAAE;IACvC,CAAC,CAAC;IACF,OAAO,IAAI,CAACl4C,UAAU,CAACq7C,CAAC,EAAE,kBAAkB,CAAC;EAC/C;EAGAnD,WAAWA,CAAAA,EAAa;IAEtB7J,MAAM,CAAC,IAAI,CAAC/rC,KAAK,CAACgM,MAAM,CAAC;IACzB,MAAMxgB,IAAI,GAAG,IAAI,CAAC8tD,yBAAyB,EAAE;IAE7C,IACE,IAAI,CAACt5C,KAAK,CAACqM,iCAAiC,IAC5C,IAAI,CAACiP,qBAAqB,EAAE,IAC5B,CAAC,IAAI,CAAC1J,GAAG,IAAa,EACtB;MACA,OAAOpmB,IAAI;IACb;IACA,MAAM2N,IAAI,GAAG,IAAI,CAAC2H,eAAe,CAAsBtV,IAAI,CAAC;IAC5D2N,IAAI,CAACk9C,SAAS,GAAG7qD,IAAI;IAErB2N,IAAI,CAACogD,WAAW,GAAG,IAAI,CAACrB,mCAAmC,CAAC,MAC1D,IAAI,CAACoB,yBAAyB,EAAE,CACjC;IAED,IAAI,CAAC39B,MAAM,CAAa,EAAA,CAAA;IACxBxiB,IAAI,CAACqgD,QAAQ,GAAG,IAAI,CAACrC,gCAAgC,CAAC,MACpD,IAAI,CAACvB,WAAW,EAAE,CACnB;IAED,IAAI,CAACj6B,MAAM,CAAU,EAAA,CAAA;IACrBxiB,IAAI,CAACsgD,SAAS,GAAG,IAAI,CAACtC,gCAAgC,CAAC,MACrD,IAAI,CAACvB,WAAW,EAAE,CACnB;IAED,OAAO,IAAI,CAACl4C,UAAU,CAACvE,IAAI,EAAE,mBAAmB,CAAC;EACnD;EAEAugD,8BAA8BA,CAAAA,EAAY;IACxC,OACE,IAAI,CAAC7+B,YAAY,CAAc,GAAA,CAAA,IAAI,IAAI,CAAC9I,SAAS,EAAE,CAACvmB,IAAI,KAAY,EAAA;EAExE;EAEA8tD,yBAAyBA,CAAAA,EAAa;IACpC,IAAI,IAAI,CAACb,uBAAuB,EAAE,EAAE;MAClC,OAAO,IAAI,CAACxB,gCAAgC,CAAC,gBAAgB,CAAC;IAChE;IACA,IAAI,IAAI,CAAC5nC,KAAK,CAAA,EAAA,CAAS,EAAE;MAEvB,OAAO,IAAI,CAAC4nC,gCAAgC,CAAC,mBAAmB,CAAC;IACnE,CAAC,MAAM,IAAI,IAAI,CAACyC,8BAA8B,EAAE,EAAE;MAEhD,OAAO,IAAI,CAACzC,gCAAgC,CAC1C,mBAAmB,EACJ,IAAI,CACpB;IACH;IACA,OAAO,IAAI,CAACuB,wBAAwB,EAAE;EACxC;EAEAmB,oBAAoBA,CAAAA,EAAsB;IACxC,IAAI,IAAI,CAAC98C,eAAe,CAAC,YAAY,EAAE,0BAA0B,CAAC,EAAE;MAClE,IAAI,CAACqC,KAAK,CAAC8sC,QAAQ,CAACgD,qBAAqB,EAAE;QAAEpwD,EAAE,EAAE,IAAI,CAACohB,KAAK,CAAC3B;MAAS,CAAC,CAAC;IACzE;IAEA,MAAMlF,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAqB;IAChDrE,IAAI,CAAC0rB,cAAc,GAAG,IAAI,CAACi0B,QAAQ,CAAC,MAAM;MACxC,IAAI,CAAC/1C,IAAI,EAAE;MACX,OAAO,IAAI,CAACsM,KAAK,CAAA,EAAA,CAAW,GACxB,IAAI,CAAC0jC,oBAAoB,EAAE,GAC3B,IAAI,CAAC6C,WAAW,EAAE;IACxB,CAAC,CAAC;IACF,IAAI,CAACj6B,MAAM,CAAO,EAAA,CAAA;IAClBxiB,IAAI,CAACyB,UAAU,GAAG,IAAI,CAAC88C,eAAe,EAAE;IACxC,OAAO,IAAI,CAACh6C,UAAU,CAACvE,IAAI,EAAE,iBAAiB,CAAC;EACjD;EAEAygD,qBAAqBA,CACnBv/D,KAA+B,EACS;IACxC,MAAMw/D,gBAAgB,GAAG,IAAI,CAAC75C,KAAK,CAAC3B,QAAQ;IAE5C,MAAMy7C,aAAa,GAAG,IAAI,CAAC5H,oBAAoB,CAC7C,uBAAuB,EACvB,MAAM;MACJ,MAAM/4C,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAmC;MAC9DrE,IAAI,CAACyB,UAAU,GAAG,IAAI,CAACg4C,iBAAiB,EAAE;MAC1C,IAAI,IAAI,CAACvjC,KAAK,CAAA,EAAA,CAAO,EAAE;QACrBlW,IAAI,CAACwD,cAAc,GAAG,IAAI,CAACk2C,oBAAoB,EAAE;MACnD;MAEA,OAAO,IAAI,CAACn1C,UAAU,CAACvE,IAAI,EAAE,+BAA+B,CAAC;IAC/D,CAAC,CACF;IAED,IAAI,CAAC2gD,aAAa,CAACvyD,MAAM,EAAE;MACzB,IAAI,CAAC2X,KAAK,CAAC8sC,QAAQ,CAACkB,uBAAuB,EAAE;QAC3CtuD,EAAE,EAAEi7D,gBAAgB;QACpBx/D;MACF,CAAC,CAAC;IACJ;IAEA,OAAOy/D,aAAa;EACtB;EAEAC,2BAA2BA,CACzB5gD,IAAsC,EACtClQ,UAEC,GAAG,EAAE,EACuC;IAC7C,IAAI,IAAI,CAACsyB,qBAAqB,EAAE,EAAE,OAAO,IAAI;IAC7C,IAAI,CAACH,gBAAgB,CAAe,GAAA,CAAA;IACpC,IAAInyB,UAAU,CAACq+B,OAAO,EAAEnuB,IAAI,CAACmuB,OAAO,GAAG,IAAI;IAC3C,IAAIthC,iBAAiB,CAAC,IAAI,CAACga,KAAK,CAACxU,IAAI,CAAC,EAAE;MACtC2N,IAAI,CAAC6D,EAAE,GAAG,IAAI,CAACqnB,eAAe,EAAE;MAChC,IAAI,CAAC+mB,eAAe,CAACjyC,IAAI,CAAC6D,EAAE,EAAEgI,iBAAiB,CAAC;IAClD,CAAC,MAAM;MACL7L,IAAI,CAAC6D,EAAE,GAAG,IAAI;MACd,IAAI,CAACkC,KAAK,CAAC8sC,QAAQ,CAACsC,oBAAoB,EAAE;QAAE1vD,EAAE,EAAE,IAAI,CAACohB,KAAK,CAAC3B;MAAS,CAAC,CAAC;IACxE;IAEAlF,IAAI,CAACwD,cAAc,GAAG,IAAI,CAACm3C,wBAAwB,CACjD,IAAI,CAAC/C,0BAA0B,CAChC;IACD,IAAI,IAAI,CAACn/B,GAAG,CAAA,EAAA,CAAa,EAAE;MACzBzY,IAAI,CAACktB,OAAO,GAAG,IAAI,CAACuzB,qBAAqB,CAAC,SAAS,CAAC;IACtD;IACA,MAAMz9C,IAAI,GAAG,IAAI,CAACqB,SAAS,EAAqB;IAChDrB,IAAI,CAACA,IAAI,GAAG,IAAI,CAAC28C,QAAQ,CAAC,IAAI,CAACxD,wBAAwB,CAAC5E,IAAI,CAAC,IAAI,CAAC,CAAC;IACnEv3C,IAAI,CAACgD,IAAI,GAAG,IAAI,CAACuB,UAAU,CAACvB,IAAI,EAAE,iBAAiB,CAAC;IACpD,OAAO,IAAI,CAACuB,UAAU,CAACvE,IAAI,EAAE,wBAAwB,CAAC;EACxD;EAEA6gD,2BAA2BA,CACzB7gD,IAA8B,EACJ;IAC1BA,IAAI,CAAC6D,EAAE,GAAG,IAAI,CAACqnB,eAAe,EAAE;IAChC,IAAI,CAAC+mB,eAAe,CAACjyC,IAAI,CAAC6D,EAAE,EAAEiI,YAAY,CAAC;IAE3C9L,IAAI,CAAC0rB,cAAc,GAAG,IAAI,CAACi0B,QAAQ,CAAC,MAAM;MACxC3/C,IAAI,CAACwD,cAAc,GAAG,IAAI,CAACm3C,wBAAwB,CACjD,IAAI,CAACtD,qBAAqB,CAC3B;MAED,IAAI,CAAC70B,MAAM,CAAO,EAAA,CAAA;MAElB,IACE,IAAI,CAACd,YAAY,CAAA,GAAA,CAAe,IAChC,IAAI,CAAC9I,SAAS,EAAE,CAACvmB,IAAI,KAAA,EAAW,EAChC;QACA,MAAM2N,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAmB;QAC9C,IAAI,CAACuF,IAAI,EAAE;QACX,OAAO,IAAI,CAACrF,UAAU,CAACvE,IAAI,EAAE,oBAAoB,CAAC;MACpD;MAEA,OAAO,IAAI,CAACy8C,WAAW,EAAE;IAC3B,CAAC,CAAC;IAEF,IAAI,CAACn6B,SAAS,EAAE;IAChB,OAAO,IAAI,CAAC/d,UAAU,CAACvE,IAAI,EAAE,wBAAwB,CAAC;EACxD;EAEA8gD,aAAaA,CAAIC,EAAW,EAAK;IAC/B,MAAMC,UAAU,GAAG,IAAI,CAACn6C,KAAK,CAAC5Y,OAAO;IACrC,IAAI,CAAC4Y,KAAK,CAAC5Y,OAAO,GAAG,CAAC+yD,UAAU,CAAC,CAAC,CAAC,CAAC;IACpC,IAAI;MACF,OAAOD,EAAE,EAAE;IACb,CAAC,SAAS;MACR,IAAI,CAACl6C,KAAK,CAAC5Y,OAAO,GAAG+yD,UAAU;IACjC;EACF;EAOArB,QAAQA,CAAIoB,EAAW,EAAK;IAC1B,MAAMv2B,SAAS,GAAG,IAAI,CAAC3jB,KAAK,CAACgM,MAAM;IACnC,IAAI,CAAChM,KAAK,CAACgM,MAAM,GAAG,IAAI;IACxB,IAAI;MACF,OAAOkuC,EAAE,EAAE;IACb,CAAC,SAAS;MACR,IAAI,CAACl6C,KAAK,CAACgM,MAAM,GAAG2X,SAAS;IAC/B;EACF;EAEAu0B,mCAAmCA,CAAIgC,EAAW,EAAK;IACrD,MAAME,oCAAoC,GACxC,IAAI,CAACp6C,KAAK,CAACqM,iCAAiC;IAC9C,IAAI,CAACrM,KAAK,CAACqM,iCAAiC,GAAG,IAAI;IACnD,IAAI;MACF,OAAO6tC,EAAE,EAAE;IACb,CAAC,SAAS;MACR,IAAI,CAACl6C,KAAK,CAACqM,iCAAiC,GAC1C+tC,oCAAoC;IACxC;EACF;EAEAjD,gCAAgCA,CAAI+C,EAAW,EAAK;IAClD,MAAME,oCAAoC,GACxC,IAAI,CAACp6C,KAAK,CAACqM,iCAAiC;IAC9C,IAAI,CAACrM,KAAK,CAACqM,iCAAiC,GAAG,KAAK;IACpD,IAAI;MACF,OAAO6tC,EAAE,EAAE;IACb,CAAC,SAAS;MACR,IAAI,CAACl6C,KAAK,CAACqM,iCAAiC,GAC1C+tC,oCAAoC;IACxC;EACF;EAEAvG,kBAAkBA,CAACx5D,KAAgB,EAAwB;IACzD,OAAO,CAAC,IAAI,CAACg1B,KAAK,CAACh1B,KAAK,CAAC,GAAG1B,SAAS,GAAG,IAAI,CAAC0hE,mBAAmB,EAAE;EACpE;EAEA5E,qBAAqBA,CAACp7D,KAAgB,EAAY;IAChD,OAAO,IAAI,CAACigE,iBAAiB,CAAC,MAAM,IAAI,CAAC3+B,MAAM,CAACthC,KAAK,CAAC,CAAC;EACzD;EAEAggE,mBAAmBA,CAAAA,EAAa;IAC9B,OAAO,IAAI,CAACC,iBAAiB,CAAC,MAAM,IAAI,CAACv3C,IAAI,EAAE,CAAC;EAClD;EAEAu3C,iBAAiBA,CAACJ,EAAc,EAAY;IAC1C,OAAO,IAAI,CAACpB,QAAQ,CAAC,MAAM;MACzBoB,EAAE,EAAE;MACJ,OAAO,IAAI,CAACtE,WAAW,EAAE;IAC3B,CAAC,CAAC;EACJ;EAEA2E,iBAAiBA,CAAAA,EAAmB;IAClC,MAAMphD,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAkB;IAE7CrE,IAAI,CAAC6D,EAAE,GAAG,IAAI,CAACqS,KAAK,CAAW,GAAA,CAAA,GAC3B,KAAK,CAAC/U,kBAAkB,CAAC,IAAI,CAAC0F,KAAK,CAACnX,KAAK,CAAC,GAC1C,IAAI,CAACw7B,eAAe,CAAe,IAAI,CAAC;IAC5C,IAAI,IAAI,CAACzS,GAAG,CAAA,EAAA,CAAO,EAAE;MACnBzY,IAAI,CAACqhD,WAAW,GAAG,KAAK,CAAC5tB,uBAAuB,EAAE;IACpD;IACA,OAAO,IAAI,CAAClvB,UAAU,CAACvE,IAAI,EAAE,cAAc,CAAC;EAC9C;EAEAshD,sBAAsBA,CACpBthD,IAAiC,EACjClQ,UAGC,GAAG,EAAE,EACe;IACrB,IAAIA,UAAU,CAACy5B,KAAK,EAAEvpB,IAAI,CAACupB,KAAK,GAAG,IAAI;IACvC,IAAIz5B,UAAU,CAACq+B,OAAO,EAAEnuB,IAAI,CAACmuB,OAAO,GAAG,IAAI;IAC3C,IAAI,CAAClM,gBAAgB,CAAU,GAAA,CAAA;IAC/BjiB,IAAI,CAAC6D,EAAE,GAAG,IAAI,CAACqnB,eAAe,EAAE;IAChC,IAAI,CAAC+mB,eAAe,CAClBjyC,IAAI,CAAC6D,EAAE,EACP7D,IAAI,CAACupB,KAAK,GAAGpd,kBAAkB,GAAGJ,YAAY,CAC/C;IAED,IAAI,CAACyW,MAAM,CAAW,CAAA,CAAA;IACtBxiB,IAAI,CAACw7B,OAAO,GAAG,IAAI,CAACud,oBAAoB,CACtC,aAAa,EACb,IAAI,CAACqI,iBAAiB,CAAC7J,IAAI,CAAC,IAAI,CAAC,CAClC;IACD,IAAI,CAAC/0B,MAAM,CAAW,CAAA,CAAA;IACtB,OAAO,IAAI,CAACje,UAAU,CAACvE,IAAI,EAAE,mBAAmB,CAAC;EACnD;EAEAuhD,kBAAkBA,CAAAA,EAAoB;IACpC,MAAMvhD,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAmB;IAC9C,IAAI,CAACkK,KAAK,CAACF,KAAK,CAACrE,WAAW,CAAC;IAE7B,IAAI,CAACwY,MAAM,CAAW,CAAA,CAAA;IAEtB,KAAK,CAACg/B,2BAA2B,CAC9BxhD,IAAI,CAACgD,IAAI,GAAG,EAAE,EACExjB,SAAS,EACX,IAAI,EAEpB,CAAA,CAAA;IACD,IAAI,CAAC+uB,KAAK,CAACD,IAAI,EAAE;IACjB,OAAO,IAAI,CAAC/J,UAAU,CAACvE,IAAI,EAAE,eAAe,CAAC;EAC/C;EAEAyhD,mCAAmCA,CACjCzhD,IAAmC,EACnC0hD,MAAe,GAAG,KAAK,EACA;IACvB1hD,IAAI,CAAC6D,EAAE,GAAG,IAAI,CAACqnB,eAAe,EAAE;IAEhC,IAAI,CAACw2B,MAAM,EAAE;MACX,IAAI,CAACzP,eAAe,CAACjyC,IAAI,CAAC6D,EAAE,EAAEuI,iBAAiB,CAAC;IAClD;IAEA,IAAI,IAAI,CAACqM,GAAG,CAAA,EAAA,CAAQ,EAAE;MACpB,MAAMkpC,KAAK,GAAG,IAAI,CAACt9C,SAAS,EAAyB;MACrD,IAAI,CAACo9C,mCAAmC,CAACE,KAAK,EAAE,IAAI,CAAC;MAErD3hD,IAAI,CAACgD,IAAI,GAAG2+C,KAAK;IACnB,CAAC,MAAM;MACL,IAAI,CAACpzC,KAAK,CAACF,KAAK,CAAC5D,eAAe,CAAC;MACjC,IAAI,CAACwZ,SAAS,CAAC5V,KAAK,CAACsS,KAAK,CAAC;MAC3B3gB,IAAI,CAACgD,IAAI,GAAG,IAAI,CAACu+C,kBAAkB,EAAE;MACrC,IAAI,CAACt9B,SAAS,CAAC3V,IAAI,EAAE;MACrB,IAAI,CAACC,KAAK,CAACD,IAAI,EAAE;IACnB;IACA,OAAO,IAAI,CAAC/J,UAAU,CAACvE,IAAI,EAAE,qBAAqB,CAAC;EACrD;EAEA4hD,uCAAuCA,CACrC5hD,IAA2B,EACJ;IACvB,IAAI,IAAI,CAAC0hB,YAAY,CAAA,GAAA,CAAY,EAAE;MACjC1hB,IAAI,CAAC6hD,MAAM,GAAG,IAAI;MAClB7hD,IAAI,CAAC6D,EAAE,GAAG,IAAI,CAACqnB,eAAe,EAAE;IACjC,CAAA,MAAM,IAAI,IAAI,CAAChV,KAAK,KAAW,EAAE;MAChClW,IAAI,CAAC6D,EAAE,GAAG,KAAK,CAAC1C,kBAAkB,CAAC,IAAI,CAAC0F,KAAK,CAACnX,KAAK,CAAC;IACtD,CAAC,MAAM;MACL,IAAI,CAACyH,UAAU,EAAE;IACnB;IACA,IAAI,IAAI,CAAC+e,KAAK,CAAA,CAAA,CAAW,EAAE;MACzB,IAAI,CAAC3H,KAAK,CAACF,KAAK,CAAC5D,eAAe,CAAC;MACjC,IAAI,CAACwZ,SAAS,CAAC5V,KAAK,CAACsS,KAAK,CAAC;MAC3B3gB,IAAI,CAACgD,IAAI,GAAG,IAAI,CAACu+C,kBAAkB,EAAE;MACrC,IAAI,CAACt9B,SAAS,CAAC3V,IAAI,EAAE;MACrB,IAAI,CAACC,KAAK,CAACD,IAAI,EAAE;IACnB,CAAC,MAAM;MACL,IAAI,CAACgU,SAAS,EAAE;IAClB;IAEA,OAAO,IAAI,CAAC/d,UAAU,CAACvE,IAAI,EAAE,qBAAqB,CAAC;EACrD;EAEA8hD,8BAA8BA,CAC5B9hD,IAAyC,EACzC+hD,QAAkB,EACW;IAC7B/hD,IAAI,CAAC+hD,QAAQ,GAAGA,QAAQ,IAAI,KAAK;IACjC/hD,IAAI,CAAC6D,EAAE,GAAG,IAAI,CAACqnB,eAAe,EAAE;IAChC,IAAI,CAAC+mB,eAAe,CAACjyC,IAAI,CAAC6D,EAAE,EAAEyH,oBAAoB,CAAC;IACnD,IAAI,CAACkX,MAAM,CAAO,EAAA,CAAA;IAClB,MAAMw/B,eAAe,GAAG,IAAI,CAACC,sBAAsB,EAAE;IACrD,IACEjiD,IAAI,CAACopB,UAAU,KAAK,MAAM,IAC1B44B,eAAe,CAAC3vD,IAAI,KAAK,2BAA2B,EACpD;MACA,IAAI,CAAC0T,KAAK,CAAC8sC,QAAQ,CAACsB,wBAAwB,EAAE;QAC5C1uD,EAAE,EAAEu8D;MACN,CAAC,CAAC;IACJ;IACAhiD,IAAI,CAACgiD,eAAe,GAAGA,eAAe;IACtC,IAAI,CAAC1/B,SAAS,EAAE;IAChB,OAAO,IAAI,CAAC/d,UAAU,CAACvE,IAAI,EAAE,2BAA2B,CAAC;EAC3D;EAEAkiD,2BAA2BA,CAAAA,EAAY;IACrC,OACE,IAAI,CAACxgC,YAAY,CAAA,GAAA,CAAa,IAC9B,IAAI,CAACxI,iBAAiB,EAAE,KAA8B,EAAA;EAE1D;EAEA+oC,sBAAsBA,CAAAA,EAAwB;IAC5C,OAAO,IAAI,CAACC,2BAA2B,EAAE,GACrC,IAAI,CAACC,8BAA8B,EAAE,GACrC,IAAI,CAAC1I,iBAAiB,CAA0B,KAAK,CAAC;EAC5D;EAEA0I,8BAA8BA,CAAAA,EAAgC;IAC5D,MAAMniD,IAAI,GAAG,IAAI,CAACqE,SAAS,EAA+B;IAC1D,IAAI,CAAC4d,gBAAgB,CAAa,GAAA,CAAA;IAClC,IAAI,CAACO,MAAM,CAAW,EAAA,CAAA;IACtB,IAAI,CAAC,IAAI,CAACtM,KAAK,KAAW,EAAE;MAC1B,IAAI,CAAC/e,UAAU,EAAE;IACnB;IAEA6I,IAAI,CAACyB,UAAU,GAAG,KAAK,CAAC4qB,aAAa,EAAqB;IAC1D,IAAI,CAAC7J,MAAM,CAAW,EAAA,CAAA;IACtB,OAAO,IAAI,CAACje,UAAU,CAACvE,IAAI,EAAE,2BAA2B,CAAC;EAC3D;EAIAy7C,WAAWA,CAAI2G,CAAU,EAAK;IAC5B,MAAMv7C,KAAK,GAAG,IAAI,CAACA,KAAK,CAAC9H,KAAK,EAAE;IAChC,MAAMwW,GAAG,GAAG6sC,CAAC,EAAE;IACf,IAAI,CAACv7C,KAAK,GAAGA,KAAK;IAClB,OAAO0O,GAAG;EACZ;EAEA8sC,kBAAkBA,CAChBD,CAAU,EACY;IACtB,MAAMluB,MAAM,GAAG,IAAI,CAACzR,QAAQ,CAC1BmW,KAAK,IAEHwpB,CAAC,EAAE,IAAIxpB,KAAK,EAAE,CACjB;IAED,IAAI1E,MAAM,CAACnR,OAAO,IAAI,CAACmR,MAAM,CAACl0B,IAAI,EAAE,OAAOxgB,SAAS;IACpD,IAAI00C,MAAM,CAACpW,KAAK,EAAE,IAAI,CAACjX,KAAK,GAAGqtB,MAAM,CAACrR,SAAS;IAE/C,OAAOqR,MAAM,CAACl0B,IAAI;EACpB;EAEAm4C,UAAUA,CAAIiK,CAA8B,EAAiB;IAC3D,MAAMv7C,KAAK,GAAG,IAAI,CAACA,KAAK,CAAC9H,KAAK,EAAE;IAChC,MAAMm1B,MAAM,GAAGkuB,CAAC,EAAE;IAClB,IAAIluB,MAAM,KAAK10C,SAAS,IAAI00C,MAAM,KAAK,KAAK,EAAE;MAC5C,OAAOA,MAAM;IACf,CAAC,MAAM;MACL,IAAI,CAACrtB,KAAK,GAAGA,KAAK;MAClB,OAAOrnB,SAAS;IAClB;EACF;EAEA8iE,iBAAiBA,CAACC,IAAS,EAAoC;IAC7D,IAAI,IAAI,CAAClgC,gBAAgB,EAAE,EAAE;MAC3B;IACF;IACA,IAAImgC,SAAS,GAAG,IAAI,CAAC37C,KAAK,CAACxU,IAAI;IAC/B,IAAII,IAAkB;IAEtB,IAAI,IAAI,CAACivB,YAAY,CAAA,EAAA,CAAS,EAAE;MAC9B8gC,SAAS,GAAU,EAAA;MACnB/vD,IAAI,GAAG,KAAc;IACvB;IAGA,OAAO,IAAI,CAACgwD,kBAAkB,CAAC,MAAM;MACnC,IAAID,SAAS,OAAiB,EAAE;QAC9BD,IAAI,CAACp0B,OAAO,GAAG,IAAI;QACnB,OAAO,KAAK,CAACu0B,sBAAsB,CACjCH,IAAI,EACQ,KAAK,EACU,KAAK,CACjC;MACH;MAEA,IAAIC,SAAS,OAAc,EAAE;QAG3BD,IAAI,CAACp0B,OAAO,GAAG,IAAI;QACnB,OAAO,IAAI,CAACw0B,UAAU,CACpBJ,IAAI,EACc,IAAI,EACL,KAAK,CACvB;MACH;MAEA,IAAIC,SAAS,QAAa,EAAE;QAC1B,OAAO,IAAI,CAAClB,sBAAsB,CAACiB,IAAI,EAAE;UAAEp0B,OAAO,EAAE;QAAK,CAAC,CAAC;MAC7D;MAEA,IAAIq0B,SAAS,QAAe,EAAE;QAC5B,OAAO,IAAI,CAACZ,uCAAuC,CAACW,IAAI,CAAC;MAC3D;MAEA,IAAIC,SAAS,KAAA,EAAc,IAAIA,SAAS,OAAY,EAAE;QACpD,IAAI,CAAC,IAAI,CAACtsC,KAAK,CAAW,EAAA,CAAA,IAAI,CAAC,IAAI,CAAC6L,qBAAqB,CAAC,MAAM,CAAC,EAAE;UACjEwgC,IAAI,CAACp0B,OAAO,GAAG,IAAI;UACnB,OAAO,IAAI,CAACy0B,iBAAiB,CAACL,IAAI,EAAE9vD,IAAI,IAAI,IAAI,CAACoU,KAAK,CAACnX,KAAK,EAAE,IAAI,CAAC;QACrE;QAGA,IAAI,CAAC8yB,MAAM,CAAW,EAAA,CAAA;QACtB,OAAO,IAAI,CAAC8+B,sBAAsB,CAACiB,IAAI,EAAE;UACvCh5B,KAAK,EAAE,IAAI;UACX4E,OAAO,EAAE;QACX,CAAC,CAAC;MACJ;MAEA,IAAIq0B,SAAS,QAAkB,EAAE;QAC/B,MAAMtuB,MAAM,GAAG,IAAI,CAAC0sB,2BAA2B,CAAC2B,IAAI,EAAE;UACpDp0B,OAAO,EAAE;QACX,CAAC,CAAC;QACF,IAAI+F,MAAM,EAAE,OAAOA,MAAM;MAC3B;MAEA,IAAIrnC,iBAAiB,CAAC21D,SAAS,CAAC,EAAE;QAChC,OAAO,IAAI,CAACK,kBAAkB,CAC5BN,IAAI,EACJ,IAAI,CAAC17C,KAAK,CAACnX,KAAK,EACL,IAAI,EACE,IAAI,CACtB;MACH;IACF,CAAC,CAAC;EACJ;EAGAozD,2BAA2BA,CAAAA,EAAqC;IAC9D,OAAO,IAAI,CAACD,kBAAkB,CAC5B,IAAI,CAACx+C,SAAS,EAAE,EAChB,IAAI,CAACwC,KAAK,CAACnX,KAAK,EACL,IAAI,EACE,IAAI,CACtB;EACH;EAEAqzD,0BAA0BA,CACxB/iD,IAAmC,EACnC2yB,IAAkB,EAClBhsB,UAAgC,EACE;IAClC,QAAQgsB,IAAI,CAACjwC,IAAI;MACf,KAAK,SAAS;QAAE;UACd,MAAMwkB,WAAW,GAAG,IAAI,CAACo7C,iBAAiB,CAACtiD,IAAI,CAAC;UAChD,IAAIkH,WAAW,EAAE;YACfA,WAAW,CAACinB,OAAO,GAAG,IAAI;YAC1B,OAAOjnB,WAAW;UACpB;UACA;QACF;MACA,KAAK,QAAQ;QAGX,IAAI,IAAI,CAACgP,KAAK,CAAA,CAAA,CAAW,EAAE;UACzB,IAAI,CAAC3H,KAAK,CAACF,KAAK,CAAC5D,eAAe,CAAC;UACjC,IAAI,CAACwZ,SAAS,CAAC5V,KAAK,CAACsS,KAAK,CAAC;UAC3B,MAAMqiC,GAAG,GAAGhjD,IAAI;UAChBgjD,GAAG,CAACnB,MAAM,GAAG,IAAI;UACjBmB,GAAG,CAACn/C,EAAE,GAAG8uB,IAAI;UACbqwB,GAAG,CAAChgD,IAAI,GAAG,IAAI,CAACu+C,kBAAkB,EAAE;UACpC,IAAI,CAAChzC,KAAK,CAACD,IAAI,EAAE;UACjB,IAAI,CAAC2V,SAAS,CAAC3V,IAAI,EAAE;UACrB,OAAO,IAAI,CAAC/J,UAAU,CAACy+C,GAAG,EAAE,qBAAqB,CAAC;QACpD;QACA;MAEF;QACE,OAAO,IAAI,CAACH,kBAAkB,CAC5B7iD,IAAI,EACJ2yB,IAAI,CAACjwC,IAAI,EACE,KAAK,EAChBikB,UAAU,CACX;IAAA;EAEP;EAGAk8C,kBAAkBA,CAChB7iD,IAAS,EACTtQ,KAAa,EACbka,IAAa,EACbjD,UAAgC,EACE;IAElC,QAAQjX,KAAK;MACX,KAAK,UAAU;QACb,IACE,IAAI,CAACuzD,qBAAqB,CAACr5C,IAAI,CAAC,KAC/B,IAAI,CAACsM,KAAK,IAAW,IAAIrpB,iBAAiB,CAAC,IAAI,CAACga,KAAK,CAACxU,IAAI,CAAC,CAAC,EAC7D;UACA,OAAO,IAAI,CAAC6wD,0BAA0B,CAACljD,IAAI,EAAE2G,UAAU,CAAC;QAC1D;QACA;MAEF,KAAK,QAAQ;QACX,IAAI,IAAI,CAACs8C,qBAAqB,CAACr5C,IAAI,CAAC,EAAE;UACpC,IAAI,IAAI,CAACsM,KAAK,CAAA,GAAA,CAAW,EAAE;YACzB,OAAO,IAAI,CAAC0rC,uCAAuC,CAAC5hD,IAAI,CAAC;UAC1D,CAAA,MAAM,IAAInT,iBAAiB,CAAC,IAAI,CAACga,KAAK,CAACxU,IAAI,CAAC,EAAE;YAC7C,OAAO,IAAI,CAACovD,mCAAmC,CAACzhD,IAAI,CAAC;UACvD;QACF;QACA;MAEF,KAAK,WAAW;QACd,IACE,IAAI,CAACijD,qBAAqB,CAACr5C,IAAI,CAAC,IAChC/c,iBAAiB,CAAC,IAAI,CAACga,KAAK,CAACxU,IAAI,CAAC,EAClC;UACA,OAAO,IAAI,CAACovD,mCAAmC,CAACzhD,IAAI,CAAC;QACvD;QACA;MAEF,KAAK,MAAM;QACT,IACE,IAAI,CAACijD,qBAAqB,CAACr5C,IAAI,CAAC,IAChC/c,iBAAiB,CAAC,IAAI,CAACga,KAAK,CAACxU,IAAI,CAAC,EAClC;UACA,OAAO,IAAI,CAACwuD,2BAA2B,CAAC7gD,IAAI,CAAC;QAC/C;QACA;IAAA;EAEN;EAEAijD,qBAAqBA,CAACr5C,IAAa,EAAE;IACnC,IAAIA,IAAI,EAAE;MACR,IAAI,IAAI,CAACwY,qBAAqB,EAAE,EAAE,OAAO,KAAK;MAC9C,IAAI,CAACxY,IAAI,EAAE;MACX,OAAO,IAAI;IACb;IACA,OAAO,CAAC,IAAI,CAACyY,gBAAgB,EAAE;EACjC;EAEA8gC,mCAAmCA,CACjCj+C,QAAkB,EAC4B;IAC9C,IAAI,CAAC,IAAI,CAACgR,KAAK,IAAO,EAAE;MACtB,OAAO12B,SAAS;IAClB;IAEA,MAAM4jE,yBAAyB,GAAG,IAAI,CAACv8C,KAAK,CAAC+L,sBAAsB;IACnE,IAAI,CAAC/L,KAAK,CAAC+L,sBAAsB,GAAG,IAAI;IAExC,MAAM2C,GAAyD,GAC7D,IAAI,CAAC8sC,kBAAkB,CAAC,MAAM;MAC5B,MAAMriD,IAAI,GAAG,IAAI,CAACqlB,WAAW,CAA4BngB,QAAQ,CAAC;MAClElF,IAAI,CAACwD,cAAc,GAAG,IAAI,CAACo3C,qBAAqB,CAC9C,IAAI,CAACjD,oBAAoB,CAC1B;MAED,KAAK,CAAC1f,mBAAmB,CAACj4B,IAAI,CAAC;MAC/BA,IAAI,CAACyrB,UAAU,GAAG,IAAI,CAACw0B,uCAAuC,EAAE;MAChE,IAAI,CAACz9B,MAAM,CAAU,EAAA,CAAA;MACrB,OAAOxiB,IAAI;IACb,CAAC,CAAC;IAEJ,IAAI,CAAC6G,KAAK,CAAC+L,sBAAsB,GAAGwwC,yBAAyB;IAE7D,IAAI,CAAC7tC,GAAG,EAAE;MACR,OAAO/1B,SAAS;IAClB;IAEA,OAAO,KAAK,CAACy6C,oBAAoB,CAC/B1kB,GAAG,EAC0B,IAAI,EACrB,IAAI,CACjB;EACH;EAIA8tC,gCAAgCA,CAAAA,EAA0C;IACxE,IAAI,IAAI,CAACC,SAAS,EAAE,OAAU,EAAE;MAC9B,OAAO9jE,SAAS;IAClB;IACA,OAAO,IAAI,CAACk6D,oBAAoB,EAAE;EACpC;EAEAA,oBAAoBA,CAAAA,EAAmC;IACrD,MAAM15C,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAkC;IAC7DrE,IAAI,CAACqC,MAAM,GAAG,IAAI,CAACs9C,QAAQ,CAAC,MAE1B,IAAI,CAACmB,aAAa,CAAC,MAAM;MACvB,IAAI,CAACt+B,MAAM,CAAO,EAAA,CAAA;MAClB,OAAO,IAAI,CAACu2B,oBAAoB,CAC9B,2BAA2B,EAC3B,IAAI,CAAC0D,WAAW,CAAClF,IAAI,CAAC,IAAI,CAAC,CAC5B;IACF,CAAA,CAAC,CACH;IACD,IAAIv3C,IAAI,CAACqC,MAAM,CAACjU,MAAM,KAAK,CAAC,EAAE;MAC5B,IAAI,CAAC2X,KAAK,CAAC8sC,QAAQ,CAACmB,kBAAkB,EAAE;QAAEvuD,EAAE,EAAEua;MAAK,CAAC,CAAC;IACvD;IACA,IAAI,CAACwiB,MAAM,CAAO,EAAA,CAAA;IAClB,OAAO,IAAI,CAACje,UAAU,CAACvE,IAAI,EAAE,8BAA8B,CAAC;EAC9D;EAEAujD,oBAAoBA,CAAAA,EAAY;IAC9B,OAAO51D,yBAAyB,CAAC,IAAI,CAACkZ,KAAK,CAACxU,IAAI,CAAC;EACnD;EAMAwgC,wBAAwBA,CAAAA,EAAY;IAClC,IAAI,IAAI,CAAC0wB,oBAAoB,EAAE,EAAE,OAAO,KAAK;IAC7C,OAAO,KAAK,CAAC1wB,wBAAwB,EAAE;EACzC;EAEAye,uBAAuBA,CACrB9wC,KAA4B,EAC5BmG,UAAyB,EACU;IAEnC,MAAMzB,QAAQ,GAAG,IAAI,CAAC2B,KAAK,CAAC3B,QAAQ;IAEpC,MAAMkzC,QAAsB,GAAG,CAAA,CAAE;IACjC,IAAI,CAACd,gBAAgB,CACnB;MACEE,gBAAgB,EAAE,CAChB,QAAQ,EACR,SAAS,EACT,WAAW,EACX,UAAU,EACV,UAAU;IAEb,CAAA,EACDY,QAAQ,CACT;IACD,MAAMO,aAAa,GAAGP,QAAQ,CAACO,aAAa;IAC5C,MAAM6K,QAAQ,GAAGpL,QAAQ,CAACoL,QAAQ;IAClC,MAAM3H,QAAQ,GAAGzD,QAAQ,CAACyD,QAAQ;IAClC,IACE,EAAEr7C,KAAK,IAA8C,CAAC,KACrDm4C,aAAa,IAAIkD,QAAQ,IAAI2H,QAAQ,CAAC,EACvC;MACA,IAAI,CAACz9C,KAAK,CAAC8sC,QAAQ,CAAC4D,2BAA2B,EAAE;QAAEhxD,EAAE,EAAEyf;MAAS,CAAC,CAAC;IACpE;IAEA,MAAMqwB,IAAI,GAAG,IAAI,CAACsB,iBAAiB,EAAE;IACrC,IAAI,CAACD,4BAA4B,CAACrB,IAAI,EAAE/0B,KAAK,CAAC;IAC9C,MAAMiwC,GAAG,GAAG,IAAI,CAAC5Z,iBAAiB,CAACtB,IAAI,CAAC12B,GAAG,CAAClQ,KAAK,EAAE4mC,IAAI,CAAC;IACxD,IAAIojB,aAAa,IAAIkD,QAAQ,IAAI2H,QAAQ,EAAE;MACzC,MAAMC,EAAE,GAAG,IAAI,CAACp+B,WAAW,CAAwBngB,QAAQ,CAAC;MAC5D,IAAIyB,UAAU,CAACvY,MAAM,EAAE;QACrBq1D,EAAE,CAAC98C,UAAU,GAAGA,UAAU;MAC5B;MACA,IAAIgyC,aAAa,EAAE8K,EAAE,CAAC9K,aAAa,GAAGA,aAAa;MACnD,IAAIkD,QAAQ,EAAE4H,EAAE,CAAC5H,QAAQ,GAAGA,QAAQ;MACpC,IAAI2H,QAAQ,EAAEC,EAAE,CAACD,QAAQ,GAAGA,QAAQ;MACpC,IAAI/S,GAAG,CAACp+C,IAAI,KAAK,YAAY,IAAIo+C,GAAG,CAACp+C,IAAI,KAAK,mBAAmB,EAAE;QACjE,IAAI,CAAC0T,KAAK,CAAC8sC,QAAQ,CAACiE,gCAAgC,EAAE;UAAErxD,EAAE,EAAEg+D;QAAG,CAAC,CAAC;MACnE;MACAA,EAAE,CAACC,SAAS,GAAGjT,GAAgD;MAC/D,OAAO,IAAI,CAAClsC,UAAU,CAACk/C,EAAE,EAAE,qBAAqB,CAAC;IACnD;IAEA,IAAI98C,UAAU,CAACvY,MAAM,EAAE;MACrBmnC,IAAI,CAAC5uB,UAAU,GAAGA,UAAU;IAC9B;IAEA,OAAO8pC,GAAG;EACZ;EAEAkT,iBAAiBA,CAAC3jD,IAAuC,EAAE;IACzD,OACGA,IAAI,CAAC3N,IAAI,KAAK,qBAAqB,IAClC,KAAK,CAACsxD,iBAAiB,CAAC3jD,IAAI,CAAC0jD,SAAS,CAAC,IACzC,KAAK,CAACC,iBAAiB,CAAC3jD,IAAI,CAAC;EAEjC;EAEA4jD,yBAAyBA,CAAC5jD,IAAwB,EAAE;IAClD,KAAK,MAAMgyB,KAAK,IAAIhyB,IAAI,CAACqC,MAAM,EAAE;MAC/B,IACE2vB,KAAK,CAAC3/B,IAAI,KAAK,YAAY,IAC1B2/B,KAAK,CAAS9rB,QAAQ,IACvB,CAAC,IAAI,CAACW,KAAK,CAACmM,gBAAgB,EAC5B;QACA,IAAI,CAACjN,KAAK,CAAC8sC,QAAQ,CAAClrB,iBAAiB,EAAE;UAAEliC,EAAE,EAAEusC;QAAM,CAAC,CAAC;MACvD;IACF;EACF;EAEAmH,0BAA0BA,CACxBn5B,IAAuC,EACvCqC,MAAsB,EACtB2xB,gBAAkC,EAC5B;IACN,KAAK,CAACmF,0BAA0B,CAACn5B,IAAI,EAAEqC,MAAM,EAAE2xB,gBAAgB,CAAC;IAChE,IAAI,CAAC4vB,yBAAyB,CAAC5jD,IAAI,CAAC;EACtC;EAEAuyB,0BAA0BA,CAMxBvyB,IAAe,EAAE3N,IAAe,EAAE4R,QAAiB,GAAG,KAAK,EAAK;IAChE,IAAI,IAAI,CAACiS,KAAK,CAAA,EAAA,CAAU,EAAE;MACxBlW,IAAI,CAACyrB,UAAU,GAAG,IAAI,CAAC2vB,oCAAoC,CAAU,EAAA,CAAA;IACvE;IAEA,MAAMyI,YAAY,GAChBxxD,IAAI,KAAK,qBAAqB,GAC1B,mBAAmB,GACnBA,IAAI,KAAK,aAAa,IAAIA,IAAI,KAAK,oBAAoB,GACvD,iBAAiB,GACjB7S,SAAS;IACf,IAAIqkE,YAAY,IAAI,CAAC,IAAI,CAAC3tC,KAAK,CAAW,CAAA,CAAA,IAAI,IAAI,CAACmM,gBAAgB,EAAE,EAAE;MACrE,OAAO,IAAI,CAAC9d,UAAU,CAACvE,IAAI,EAAE6jD,YAAY,CAAC;IAC5C;IACA,IAAIA,YAAY,KAAK,mBAAmB,IAAI,IAAI,CAACh9C,KAAK,CAACmM,gBAAgB,EAAE;MACvE,IAAI,CAACjN,KAAK,CAAC8sC,QAAQ,CAACc,gCAAgC,EAAE;QAAEluD,EAAE,EAAEua;MAAK,CAAC,CAAC;MACnE,IAAKA,IAAI,CAAmCmuB,OAAO,EAAE;QACnD,OAAO,KAAK,CAACoE,0BAA0B,CAACvyB,IAAI,EAAE6jD,YAAY,EAAE5/C,QAAQ,CAAC;MACvE;IACF;IACA,IAAI,CAAC2/C,yBAAyB,CAAC5jD,IAAI,CAAC;IAEpC,OAAO,KAAK,CAACuyB,0BAA0B,CAACvyB,IAAI,EAAE3N,IAAI,EAAE4R,QAAQ,CAAC;EAC/D;EAEA6/C,2BAA2BA,CAAC9jD,IAAgB,EAAQ;IAClD,IAAI,CAACA,IAAI,CAACgD,IAAI,IAAIhD,IAAI,CAAC6D,EAAE,EAAE;MAGzB,IAAI,CAACouC,eAAe,CAACjyC,IAAI,CAAC6D,EAAE,EAAEmI,eAAe,CAAC;IAChD,CAAC,MAAM;MACL,KAAK,CAAC83C,2BAA2B,CAAC9jD,IAAI,CAAC;IACzC;EACF;EAEA+jD,0BAA0BA,CAACC,KAA6C,EAAE;IACxEA,KAAK,CAACtqC,OAAO,CAAC1Z,IAAI,IAAI;MACpB,IAAI,CAAAA,IAAI,IAAJA,IAAAA,GAAAA,KAAAA,CAAAA,GAAAA,IAAI,CAAE3N,IAAI,MAAK,sBAAsB,EAAE;QACzC,IAAI,CAAC0T,KAAK,CAAC8sC,QAAQ,CAAC8D,wBAAwB,EAAE;UAC5ClxD,EAAE,EAAEua,IAAI,CAAC0rB;QACX,CAAC,CAAC;MACJ;IACF,CAAC,CAAC;EACJ;EAEA+J,gBAAgBA,CACdD,QAAgD,EAEhDyuB,UAAoB,EACoB;IAKxC,IAAI,CAACF,0BAA0B,CAACvuB,QAAQ,CAAC;IACzC,OAAOA,QAAQ;EACjB;EAEAI,cAAcA,CACZC,KAAgB,EAChBC,YAAqB,EACrBC,OAAgB,EAChB5wB,mBAA6C,EACN;IACvC,MAAMnF,IAAI,GAAG,KAAK,CAAC41B,cAAc,CAC/BC,KAAK,EACLC,YAAY,EACZC,OAAO,EACP5wB,mBAAmB,CACpB;IAED,IAAInF,IAAI,CAAC3N,IAAI,KAAK,iBAAiB,EAAE;MACnC,IAAI,CAAC0xD,0BAA0B,CAAC/jD,IAAI,CAACuQ,QAAQ,CAAC;IAChD;IAEA,OAAOvQ,IAAI;EACb;EAEAoH,cAAcA,CACZC,IAAkB,EAElBnC,QAAkB,EAClBoC,OAAmC,EACnCT,KAA4B,EACd;IACd,IAAI,CAAC,IAAI,CAACsb,qBAAqB,EAAE,IAAI,IAAI,CAACjM,KAAK,CAAA,EAAA,CAAS,EAAE;MAIxD,IAAI,CAACrP,KAAK,CAAC8M,kBAAkB,GAAG,KAAK;MACrC,IAAI,CAAC/J,IAAI,EAAE;MAEX,MAAMs6C,iBAAiB,GACrB,IAAI,CAAC7+B,WAAW,CAAwBngB,QAAQ,CAAC;MACnDg/C,iBAAiB,CAACziD,UAAU,GAAG4F,IAAI;MACnC,OAAO,IAAI,CAAC9C,UAAU,CAAC2/C,iBAAiB,EAAE,qBAAqB,CAAC;IAClE;IAEA,IAAIC,cAAc,GAAG,KAAK;IAC1B,IACE,IAAI,CAACjuC,KAAK,CAAgB,EAAA,CAAA,IAC1B,IAAI,CAACgD,iBAAiB,EAAE,KAAA,EAAuB,EAC/C;MACA,IAAI5R,OAAO,EAAE;QACXT,KAAK,CAACY,IAAI,GAAG,IAAI;QACjB,OAAOJ,IAAI;MACb;MACAR,KAAK,CAACU,mBAAmB,GAAG48C,cAAc,GAAG,IAAI;MACjD,IAAI,CAACv6C,IAAI,EAAE;IACb;IAGA,IAAI,IAAI,CAACsM,KAAK,CAAA,EAAA,CAAO,IAAI,IAAI,CAACA,KAAK,CAAA,EAAA,CAAc,EAAE;MACjD,IAAIkuC,oBAAoB;MAIxB,MAAMlwB,MAAM,GAAG,IAAI,CAACmuB,kBAAkB,CAAC,MAAM;QAC3C,IAAI,CAAC/6C,OAAO,IAAI,IAAI,CAAC+8C,oBAAoB,CAACh9C,IAAI,CAAC,EAAE;UAG/C,MAAMi9C,YAAY,GAChB,IAAI,CAACnB,mCAAmC,CAACj+C,QAAQ,CAAC;UACpD,IAAIo/C,YAAY,EAAE;YAChB,OAAOA,YAAY;UACrB;QACF;QAEA,MAAMxqB,aAAa,GAAG,IAAI,CAACupB,gCAAgC,EAAE;QAC7D,IAAI,CAACvpB,aAAa,EAAE;QAEpB,IAAIqqB,cAAc,IAAI,CAAC,IAAI,CAACjuC,KAAK,IAAW,EAAE;UAC5CkuC,oBAAoB,GAAG,IAAI,CAACv9C,KAAK,CAACoN,WAAW,EAAE;UAC/C;QACF;QAEA,IAAIlmB,eAAe,CAAC,IAAI,CAAC8Y,KAAK,CAACxU,IAAI,CAAC,EAAE;UACpC,MAAM6hC,MAAM,GAAG,KAAK,CAACqwB,6BAA6B,CAChDl9C,IAAI,EAEJnC,QAAQ,EACR2B,KAAK,CACN;UACDqtB,MAAM,CAAC1wB,cAAc,GAAGs2B,aAAa;UACrC,OAAO5F,MAAM;QACf;QAEA,IAAI,CAAC5sB,OAAO,IAAI,IAAI,CAACmR,GAAG,IAAW,EAAE;UACnC,MAAMzY,IAAI,GAAG,IAAI,CAACqlB,WAAW,CAE3BngB,QAAQ,CAAC;UACXlF,IAAI,CAACmG,MAAM,GAAGkB,IAAI;UAGlBrH,IAAI,CAACqG,SAAS,GAAG,IAAI,CAACqzB,4BAA4B,CAAA,EAAA,EAE5B,KAAK,CAC1B;UAGD,IAAI,CAACqqB,0BAA0B,CAAC/jD,IAAI,CAACqG,SAAS,CAAC;UAE/CrG,IAAI,CAACwD,cAAc,GAAGs2B,aAAa;UACnC,IAAIjzB,KAAK,CAACU,mBAAmB,EAAE;YAC5BvH,IAAI,CAAsCkG,QAAQ,GACjDi+C,cAAc;UAClB;UAEA,OAAO,IAAI,CAACn+C,oBAAoB,CAAChG,IAAI,EAAE6G,KAAK,CAACU,mBAAmB,CAAC;QACnE;QAEA,MAAMi9C,SAAS,GAAG,IAAI,CAAC39C,KAAK,CAACxU,IAAI;QACjC,IAEEmyD,SAAS,KAAU,EAAA,IAEnBA,SAAS,KAAiB,EAAA,IAEzBA,SAAS,KAAc,EAAA,IACtBt3D,uBAAuB,CAACs3D,SAAS,CAAC,IAClC,CAAC,IAAI,CAACriC,qBAAqB,EAAG,EAChC;UAEA;QACF;QAEA,MAAMniB,IAAI,GAAG,IAAI,CAACqlB,WAAW,CAA8BngB,QAAQ,CAAC;QACpElF,IAAI,CAACyB,UAAU,GAAG4F,IAAI;QACtBrH,IAAI,CAACwD,cAAc,GAAGs2B,aAAa;QACnC,OAAO,IAAI,CAACv1B,UAAU,CAACvE,IAAI,EAAE,2BAA2B,CAAC;MAC3D,CAAC,CAAC;MAEF,IAAIokD,oBAAoB,EAAE;QACxB,IAAI,CAACjtD,UAAU,CAACitD,oBAAoB,EAAY,EAAA,CAAA;MAClD;MAEA,IAAIlwB,MAAM,EAAE;QACV,IACEA,MAAM,CAAC7hC,IAAI,KAAK,2BAA2B,KAC1C,IAAI,CAAC6jB,KAAK,CAAQ,EAAA,CAAA,IAChB,IAAI,CAACA,KAAK,IAAgB,IACzB,IAAI,CAACgD,iBAAiB,EAAE,KAA+B,EAAA,CAAC,EAC5D;UACA,IAAI,CAACnT,KAAK,CACR8sC,QAAQ,CAACoC,iDAAiD,EAC1D;YAAExvD,EAAE,EAAE,IAAI,CAACohB,KAAK,CAAC3B;UAAS,CAAC,CAC5B;QACH;QACA,OAAOgvB,MAAM;MACf;IACF;IAEA,OAAO,KAAK,CAAC9sB,cAAc,CAACC,IAAI,EAAEnC,QAAQ,EAAEoC,OAAO,EAAET,KAAK,CAAC;EAC7D;EAEAkzB,cAAcA,CAAC/5B,IAAqB,EAAQ;IAAA,IAAAykD,aAAA;IAC1C,KAAK,CAAC1qB,cAAc,CAAC/5B,IAAI,CAAC;IAE1B,MAAM;MAAEmG;IAAQ,CAAA,GAAGnG,IAAI;IACvB,IACEmG,MAAM,CAAC9T,IAAI,KAAK,2BAA2B,IAC3C,EAAAoyD,CAAAA,aAAA,GAACt+C,MAAM,CAACxE,KAAK,KAAA,IAAA,IAAZ8iD,aAAA,CAAcjiD,aAAa,CAC5B,EAAA;MACAxC,IAAI,CAACwD,cAAc,GAAG2C,MAAM,CAAC3C,cAAc;MAC3CxD,IAAI,CAACmG,MAAM,GAAGA,MAAM,CAAC1E,UAAU;IACjC;EACF;EAEAijD,WAAWA,CACTnvB,IAAkB,EAClBovB,YAAsB,EACtBC,OAAe,EACD;IACd,IAAIC,WAAoB;IACxB,IACEh3D,uBAAuB,CAAQ,EAAA,CAAA,GAAG+2D,OAAO,IACzC,CAAC,IAAI,CAACziC,qBAAqB,EAAE,KAC5B,IAAI,CAACT,YAAY,CAAA,EAAA,CAAQ,KACvBmjC,WAAW,GAAG,IAAI,CAACnjC,YAAY,CAAA,GAAA,CAAe,CAAC,CAAC,EACnD;MACA,MAAM1hB,IAAI,GAAG,IAAI,CAACqlB,WAAW,CAE3Bs/B,YAAY,CAAC;MACf3kD,IAAI,CAACyB,UAAU,GAAG8zB,IAAI;MACtBv1B,IAAI,CAAC0rB,cAAc,GAAG,IAAI,CAACi0B,QAAQ,CAAC,MAAM;QACxC,IAAI,CAAC/1C,IAAI,EAAE;QACX,IAAI,IAAI,CAACsM,KAAK,CAAA,EAAA,CAAW,EAAE;UACzB,IAAI2uC,WAAW,EAAE;YACf,IAAI,CAAC9+C,KAAK,CAAClG,MAAM,CAAC7E,iBAAiB,EAAE;cACnCvV,EAAE,EAAE,IAAI,CAACohB,KAAK,CAAC3B,QAAQ;cACvB/iB,OAAO,EAAE;YACX,CAAC,CAAC;UACJ;UACA,OAAO,IAAI,CAACy3D,oBAAoB,EAAE;QACpC;QAEA,OAAO,IAAI,CAAC6C,WAAW,EAAE;MAC3B,CAAC,CAAC;MACF,IAAI,CAACl4C,UAAU,CACbvE,IAAI,EACJ6kD,WAAW,GAAG,uBAAuB,GAAG,gBAAgB,CACzD;MAED,IAAI,CAACC,YAAY,EAAE;MACnB,OAAO,IAAI,CAACJ,WAAW,CAErB1kD,IAAI,EACJ2kD,YAAY,EACZC,OAAO,CACR;IACH;IAEA,OAAO,KAAK,CAACF,WAAW,CAACnvB,IAAI,EAAEovB,YAAY,EAAEC,OAAO,CAAC;EACvD;EAEA7sB,iBAAiBA,CACf5uB,IAAY,EACZjE,QAAkB,EAClB6/C,aAAsB,EACtBv/C,SAAkB,EACZ;IAGN,IAAI,CAAC,IAAI,CAACqB,KAAK,CAACmM,gBAAgB,EAAE;MAChC,KAAK,CAAC+kB,iBAAiB,CAAC5uB,IAAI,EAAEjE,QAAQ,EAAE6/C,aAAa,EAAEv/C,SAAS,CAAC;IACnE;EACF;EAEAuxB,qBAAqBA,CAAC/2B,IAAiC,EAAE;IACvD,KAAK,CAAC+2B,qBAAqB,CAAC/2B,IAAI,CAAC;IACjC,IAAIA,IAAI,CAACg3B,MAAM,IAAIh3B,IAAI,CAACopB,UAAU,KAAK,OAAO,EAAE;MAC9C,IAAI,CAACrjB,KAAK,CAAC8sC,QAAQ,CAAC3rB,6BAA6B,EAAE;QACjDzhC,EAAE,EAAEua,IAAI,CAACgH,UAAU,CAAC,CAAC,CAAC,CAACnI,GAAG,CAAClQ;MAC7B,CAAC,CAAC;IACJ;EACF;EAWAq2D,qBAAqBA,CAAAA,EAAG,CAAC;EAEzBz4B,WAAWA,CACTvsB,IAA+D,EAClD;IACbA,IAAI,CAACopB,UAAU,GAAG,OAAO;IACzB,IACEv8B,iBAAiB,CAAC,IAAI,CAACga,KAAK,CAACxU,IAAI,CAAC,IAClC,IAAI,CAAC6jB,KAAK,CAAS,EAAA,CAAA,IACnB,IAAI,CAACA,KAAK,GAAW,EACrB;MACA,IAAI+uC,KAAK,GAAG,IAAI,CAACrsC,SAAS,EAAE;MAE5B,IACE,IAAI,CAAC8I,YAAY,KAAU,IAE3BujC,KAAK,CAAC5yD,IAAI,KAAA,EAAa,IAEvB4yD,KAAK,CAAC5yD,IAAI,KAAa,EAAA,IAEvB4yD,KAAK,CAAC5yD,IAAI,OAAU,EACpB;QACA2N,IAAI,CAACopB,UAAU,GAAG,MAAM;QACxB,IAAI,CAACxf,IAAI,EAAE;QACXq7C,KAAK,GAAG,IAAI,CAACrsC,SAAS,EAAE;MAC1B;MAEA,IAAI/rB,iBAAiB,CAAC,IAAI,CAACga,KAAK,CAACxU,IAAI,CAAC,IAAI4yD,KAAK,CAAC5yD,IAAI,OAAU,EAAE;QAC9D,OAAO,IAAI,CAACyvD,8BAA8B,CACxC9hD,IAAI,CACL;MACH;IACF;IAEA,MAAMklD,UAAU,GAAG,KAAK,CAAC34B,WAAW,CAACvsB,IAAI,CAAgC;IAKzE,IACEklD,UAAU,CAAC97B,UAAU,KAAK,MAAM,IAEhC87B,UAAU,CAACl+C,UAAU,CAAC5Y,MAAM,GAAG,CAAC,IAEhC82D,UAAU,CAACl+C,UAAU,CAAC,CAAC,CAAC,CAAC3U,IAAI,KAAK,wBAAwB,EAC1D;MACA,IAAI,CAAC0T,KAAK,CAAC8sC,QAAQ,CAACyD,sCAAsC,EAAE;QAC1D7wD,EAAE,EAAEy/D;MACN,CAAC,CAAC;IACJ;IAEA,OAAOA,UAAU;EACnB;EAEAx+C,WAAWA,CACT1G,IAAoB,EACpB2G,UAAgC,EACnB;IACb,IAAI,IAAI,CAACuP,KAAK,CAAA,EAAA,CAAY,EAAE;MAE1B,IAAI,CAACtM,IAAI,EAAE;MACX,IACE,IAAI,CAAC8X,YAAY,CAAU,GAAA,CAAA,IAC3B,IAAI,CAACxI,iBAAiB,EAAE,KAAA,EAAuB,EAC/C;QACAlZ,IAAI,CAACopB,UAAU,GAAG,MAAM;QACxB,IAAI,CAACxf,IAAI,EAAE;MACb,CAAC,MAAM;QACL5J,IAAI,CAACopB,UAAU,GAAG,OAAO;MAC3B;MACA,OAAO,IAAI,CAAC04B,8BAA8B,CACxC9hD,IAAI,EACW,IAAI,CACpB;IACF,CAAA,MAAM,IAAI,IAAI,CAACyY,GAAG,IAAO,EAAE;MAE1B,MAAM5yB,MAAM,GAAGma,IAAoC;MACnDna,MAAM,CAAC4b,UAAU,GAAG,KAAK,CAACmpB,eAAe,EAAE;MAC3C,IAAI,CAACtI,SAAS,EAAE;MAChB,OAAO,IAAI,CAAC/d,UAAU,CAAC1e,MAAM,EAAE,oBAAoB,CAAC;IACrD,CAAA,MAAM,IAAI,IAAI,CAACm8B,aAAa,IAAQ,EAAE;MAErC,MAAMsS,IAAI,GAAGt0B,IAA8C;MAE3D,IAAI,CAACiiB,gBAAgB,CAAe,GAAA,CAAA;MACpCqS,IAAI,CAACzwB,EAAE,GAAG,IAAI,CAACqnB,eAAe,EAAE;MAChC,IAAI,CAAC5I,SAAS,EAAE;MAChB,OAAO,IAAI,CAAC/d,UAAU,CAAC+vB,IAAI,EAAE,8BAA8B,CAAC;IAC9D,CAAC,MAAM;MACLt0B,IAAI,CAAC2sB,UAAU,GAAG,OAAO;MAEzB,IAAI,IAAI,CAACjL,YAAY,CAAA,GAAA,CAAU,EAAE;QAC/B,MAAM/M,EAAE,GAAG,IAAI,CAACuE,iBAAiB,EAAE;QACnC,IAAIvE,EAAE,KAAA,GAA6B,IAAIA,EAAE,OAAuB,EAAE;UAChE,IAAI,CAAC/K,IAAI,EAAE;UACX5J,IAAI,CAAC2sB,UAAU,GAAG,MAAM;QAC1B;MACF;MAEA,OAAO,KAAK,CAACjmB,WAAW,CACtB1G,IAAI,EACJ2G,UAAU,CACX;IACH;EACF;EAEAw+C,eAAeA,CAAAA,EAAY;IACzB,OACE,IAAI,CAACzjC,YAAY,CAAc,GAAA,CAAA,IAAI,IAAI,CAAC9I,SAAS,EAAE,CAACvmB,IAAI,KAAc,EAAA;EAE1E;EAEAygC,4BAA4BA,CAAAA,EAAiC;IAC3D,IAAI,IAAI,CAACqyB,eAAe,EAAE,EAAE;MAC1B,MAAMC,GAAG,GAAG,IAAI,CAAC/gD,SAAS,EAAW;MACrC,IAAI,CAACuF,IAAI,EAAE;MACXw7C,GAAG,CAACrH,QAAQ,GAAG,IAAI;MACnB,OAAO,IAAI,CAAC4E,UAAU,CAACyC,GAAG,EAAE,IAAI,EAAE,IAAI,CAAC;IACzC;IAIA,IAAI,IAAI,CAAClvC,KAAK,CAAA,GAAA,CAAe,EAAE;MAC7B,MAAMge,MAAM,GAAG,IAAI,CAAC0sB,2BAA2B,CAC7C,IAAI,CAACv8C,SAAS,EAA4B,CAC3C;MACD,IAAI6vB,MAAM,EAAE,OAAOA,MAAM;IAC3B;IAEA,OAAO,KAAK,CAACpB,4BAA4B,EAAE;EAC7C;EAEA8vB,iBAAiBA,CACf5iD,IAA2B,EAC3BvN,IAAuC,EACvC4yD,uBAAgC,GAAG,KAAK,EACxC;IACA,MAAM;MAAEryC;KAAkB,GAAG,IAAI,CAACnM,KAAK;IACvC,MAAMK,WAAW,GAAG,KAAK,CAAC07C,iBAAiB,CACzC5iD,IAAI,EACJvN,IAAI,EACJ4yD,uBAAuB,IAAIryC,gBAAgB,CAC5C;IAED,IAAI,CAACA,gBAAgB,EAAE,OAAO9L,WAAW;IAEzC,KAAK,MAAM;MAAErD,EAAE;MAAEmQ;IAAK,CAAC,IAAI9M,WAAW,CAACo+C,YAAY,EAAE;MAEnD,IAAI,CAACtxC,IAAI,EAAE;MAGX,IAAIvhB,IAAI,KAAK,OAAO,IAAI,CAAC,CAACoR,EAAE,CAAC6nB,cAAc,EAAE;QAC3C,IAAI,CAAC3lB,KAAK,CAAC8sC,QAAQ,CAAC8B,qCAAqC,EAAE;UACzDlvD,EAAE,EAAEuuB;QACN,CAAC,CAAC;MACJ,CAAC,MAAM,IACL,CAACuxC,8BAA8B,CAACvxC,IAAI,EAAE,IAAI,CAAC1N,SAAS,CAAC,QAAQ,CAAC,CAAC,EAC/D;QACA,IAAI,CAACP,KAAK,CACR8sC,QAAQ,CAACU,mEAAmE,EAC5E;UAAE9tD,EAAE,EAAEuuB;QAAK,CAAC,CACb;MACH;IACF;IAEA,OAAO9M,WAAW;EACpB;EAEAs+C,qBAAqBA,CACnBhlD,KAAyB,EACzBmG,UAAiC,EACpB;IACb,IAAI,IAAI,CAACuP,KAAK,CAAW,EAAA,CAAA,IAAI,IAAI,CAAC6L,qBAAqB,CAAC,MAAM,CAAC,EAAE;MAC/D,MAAM/hB,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAuB;MAClD,IAAI,CAACme,MAAM,CAAW,EAAA,CAAA;MACtB,OAAO,IAAI,CAAC8+B,sBAAsB,CAACthD,IAAI,EAAE;QAAEupB,KAAK,EAAE;MAAK,CAAC,CAAC;IAC3D;IAEA,IAAI,IAAI,CAAC7H,YAAY,CAAA,GAAA,CAAU,EAAE;MAC/B,OAAO,IAAI,CAAC4/B,sBAAsB,CAChC,IAAI,CAACj9C,SAAS,EAAuB,CACtC;IACH;IAEA,IAAI,IAAI,CAACqd,YAAY,CAAA,GAAA,CAAe,EAAE;MACpC,MAAMwS,MAAM,GAAG,IAAI,CAAC0sB,2BAA2B,CAAC,IAAI,CAACv8C,SAAS,EAAE,CAAC;MACjE,IAAI6vB,MAAM,EAAE,OAAOA,MAAM;IAC3B;IAEA,OAAO,KAAK,CAACsxB,qBAAqB,CAAChlD,KAAK,EAAEmG,UAAU,CAAC;EACvD;EAEA8+C,mBAAmBA,CAAAA,EAAuC;IACxD,OAAO,IAAI,CAACzN,eAAe,CAAC,CAAC,QAAQ,EAAE,WAAW,EAAE,SAAS,CAAC,CAAC;EACjE;EAEA0N,kBAAkBA,CAACxwB,MAAW,EAAEmf,SAAgC,EAAW;IACzE,OAAOA,SAAS,CAACn2B,IAAI,CAAC21B,QAAQ,IAAI;MAChC,IAAIoD,kBAAkB,CAACpD,QAAQ,CAAC,EAAE;QAChC,OAAO3e,MAAM,CAACyjB,aAAa,KAAK9E,QAAQ;MAC1C;MACA,OAAO,CAAC,CAAC3e,MAAM,CAAC2e,QAAQ,CAAC;IAC3B,CAAC,CAAC;EACJ;EAEAqE,uBAAuBA,CAAAA,EAAG;IACxB,OACE,IAAI,CAACx2B,YAAY,CAAA,GAAA,CAAY,IAC7B,IAAI,CAACxI,iBAAiB,EAAE,KAA6B,GAAA;EAEzD;EAEA+b,gBAAgBA,CACd9xB,SAAsB,EACtB+xB,MAAW,EACXruB,KAA8B,EACxB;IACN,MAAMwtC,SAAS,GAAG,CAChB,SAAS,EACT,SAAS,EACT,QAAQ,EACR,WAAW,EACX,UAAU,EACV,UAAU,EACV,UAAU,EACV,QAAQ,CACA;IACV,IAAI,CAACiD,gBAAgB,CACnB;MACEE,gBAAgB,EAAEnD,SAAS;MAC3BoD,mBAAmB,EAAE,CAAC,IAAI,EAAE,KAAK,CAAC;MAClCQ,6BAA6B,EAAE,IAAI;MACnCP,aAAa,EAAE7E,QAAQ,CAACiC;IACzB,CAAA,EACD5f,MAAM,CACP;IAED,MAAMywB,gCAAgC,GAAGA,CAAAA,KAAM;MAC7C,IAAI,IAAI,CAACzN,uBAAuB,EAAE,EAAE;QAClC,IAAI,CAACtuC,IAAI,EAAE;QACX,IAAI,CAACA,IAAI,EAAE;QACX,IAAI,IAAI,CAAC87C,kBAAkB,CAACxwB,MAAM,EAAEmf,SAAS,CAAC,EAAE;UAC9C,IAAI,CAACtuC,KAAK,CAAC8sC,QAAQ,CAACsD,6BAA6B,EAAE;YACjD1wD,EAAE,EAAE,IAAI,CAACohB,KAAK,CAACoN,WAAW;UAC5B,CAAC,CAAC;QACJ;QACA,KAAK,CAAC2xC,qBAAqB,CAACziD,SAAS,EAAE+xB,MAAM,CAAkB;MACjE,CAAC,MAAM;QACL,IAAI,CAAC2wB,4BAA4B,CAC/B1iD,SAAS,EACT+xB,MAAM,EACNruB,KAAK,EACL,CAAC,CAACquB,MAAM,CAAC5F,MAAM,CAChB;MACH;KACD;IACD,IAAI4F,MAAM,CAAC/G,OAAO,EAAE;MAClB,IAAI,CAACs0B,kBAAkB,CAACkD,gCAAgC,CAAC;IAC3D,CAAC,MAAM;MACLA,gCAAgC,EAAE;IACpC;EACF;EAEAE,4BAA4BA,CAC1B1iD,SAAsB,EACtB+xB,MAAkD,EAClDruB,KAA8B,EAC9BwoB,QAAiB,EACX;IACN,MAAM4sB,GAAG,GAAG,IAAI,CAACT,wBAAwB,CACvCtmB,MAAM,CACP;IACD,IAAI+mB,GAAG,EAAE;MACP94C,SAAS,CAACH,IAAI,CAACvf,IAAI,CAACw4D,GAAG,CAAC;MAExB,IAAK/mB,MAAM,CAAS6oB,QAAQ,EAAE;QAC5B,IAAI,CAACh4C,KAAK,CAAC8sC,QAAQ,CAACyB,yBAAyB,EAAE;UAAE7uD,EAAE,EAAEyvC;QAAO,CAAC,CAAC;MAChE;MACA,IAAKA,MAAM,CAASyjB,aAAa,EAAE;QACjC,IAAI,CAAC5yC,KAAK,CAAC8sC,QAAQ,CAAC0B,8BAA8B,EAAE;UAClD9uD,EAAE,EAAEyvC,MAAM;UACV2e,QAAQ,EAAG3e,MAAM,CAASyjB;QAC5B,CAAC,CAAC;MACJ;MACA,IAAKzjB,MAAM,CAAS/G,OAAO,EAAE;QAC3B,IAAI,CAACpoB,KAAK,CAAC8sC,QAAQ,CAAC2B,wBAAwB,EAAE;UAAE/uD,EAAE,EAAEyvC;QAAO,CAAC,CAAC;MAC/D;MACA,IAAKA,MAAM,CAASsuB,QAAQ,EAAE;QAC5B,IAAI,CAACz9C,KAAK,CAAC8sC,QAAQ,CAAC4B,yBAAyB,EAAE;UAAEhvD,EAAE,EAAEyvC;QAAO,CAAC,CAAC;MAChE;MAEA;IACF;IAEA,IAAI,CAAC,IAAI,CAACruB,KAAK,CAACoM,eAAe,IAAKiiB,MAAM,CAAS6oB,QAAQ,EAAE;MAC3D,IAAI,CAACh4C,KAAK,CAAC8sC,QAAQ,CAACwC,iCAAiC,EAAE;QACrD5vD,EAAE,EAAEyvC;MACN,CAAC,CAAC;IACJ;IAEA,IAAKA,MAAM,CAASsuB,QAAQ,EAAE;MAC5B,IAAI,CAAC38C,KAAK,CAACi/C,aAAa,EAAE;QACxB,IAAI,CAAC//C,KAAK,CAAC8sC,QAAQ,CAAC2C,qBAAqB,EAAE;UAAE/vD,EAAE,EAAEyvC;QAAO,CAAC,CAAC;MAC5D;IACF;IAIA,KAAK,CAAC2wB,4BAA4B,CAChC1iD,SAAS,EACT+xB,MAAM,EACNruB,KAAK,EACLwoB,QAAQ,CACT;EACH;EAEA02B,4BAA4BA,CAC1BC,YAAsE,EAChE;IACN,MAAM9/C,QAAQ,GAAG,IAAI,CAACuS,GAAG,CAAa,EAAA,CAAA;IACtC,IAAIvS,QAAQ,EAAE8/C,YAAY,CAAC9/C,QAAQ,GAAG,IAAI;IAE1C,IAAK8/C,YAAY,CAASnK,QAAQ,IAAI,IAAI,CAAC3lC,KAAK,IAAW,EAAE;MAC3D,IAAI,CAACnQ,KAAK,CAAC8sC,QAAQ,CAACS,sBAAsB,EAAE;QAAE7tD,EAAE,EAAEugE;MAAa,CAAC,CAAC;IACnE;IAEA,IAAKA,YAAY,CAAS73B,OAAO,IAAI,IAAI,CAACjY,KAAK,IAAW,EAAE;MAC1D,IAAI,CAACnQ,KAAK,CAAC8sC,QAAQ,CAACQ,qBAAqB,EAAE;QAAE5tD,EAAE,EAAEugE;MAAa,CAAC,CAAC;IAClE;EACF;EAOAtzB,wBAAwBA,CACtB1yB,IAAmC,EACnC2yB,IAAkB,EAClBhsB,UAAgC,EACnB;IACb,MAAM2tB,IAAI,GACR3B,IAAI,CAACtgC,IAAI,KAAK,YAAY,GAEtB,IAAI,CAAC0wD,0BAA0B,CAAC/iD,IAAI,EAAE2yB,IAAI,EAAEhsB,UAAU,CAAC,GACvDnnB,SAAS;IACf,OAAO80C,IAAI,IAAI,KAAK,CAAC5B,wBAAwB,CAAC1yB,IAAI,EAAE2yB,IAAI,EAAEhsB,UAAU,CAAC;EACvE;EAIAisB,4BAA4BA,CAAAA,EAAY;IACtC,IAAI,IAAI,CAAC2wB,oBAAoB,EAAE,EAAE,OAAO,IAAI;IAC5C,OAAO,KAAK,CAAC3wB,4BAA4B,EAAE;EAC7C;EAGAG,gBAAgBA,CACdJ,IAAkB,EAElBztB,QAAkB,EAClBC,mBAA6C,EAC/B;IAGd,IAAI,CAAC,IAAI,CAAC0B,KAAK,CAAC+L,sBAAsB,IAAI,CAAC,IAAI,CAACsD,KAAK,CAAA,EAAA,CAAa,EAAE;MAClE,OAAO,KAAK,CAAC6c,gBAAgB,CAC3BJ,IAAI,EAEJztB,QAAQ,EACRC,mBAAmB,CACpB;IACH;IAEA,MAAM+uB,MAAM,GAAG,IAAI,CAACzR,QAAQ,CAAC,MAC3B,KAAK,CAACsQ,gBAAgB,CAACJ,IAAI,EAAEztB,QAAQ,CAAC,CACvC;IAED,IAAI,CAACgvB,MAAM,CAACl0B,IAAI,EAAE;MAChB,IAAIk0B,MAAM,CAACpW,KAAK,EAAE;QAEhB,KAAK,CAACkV,0BAA0B,CAAC7tB,mBAAmB,EAAE+uB,MAAM,CAACpW,KAAK,CAAC;MACrE;MAEA,OAAO6U,IAAI;IACb;IACA,IAAIuB,MAAM,CAACpW,KAAK,EAAE,IAAI,CAACjX,KAAK,GAAGqtB,MAAM,CAACrR,SAAS;IAC/C,OAAOqR,MAAM,CAACl0B,IAAI;EACpB;EAIAm0B,cAAcA,CACZn0B,IAAkB,EAElBkF,QAAkB,EACJ;IACdlF,IAAI,GAAG,KAAK,CAACm0B,cAAc,CAACn0B,IAAI,EAAEkF,QAAQ,CAAC;IAC3C,IAAI,IAAI,CAACuT,GAAG,CAAA,EAAA,CAAa,EAAE;MACzBzY,IAAI,CAACkG,QAAQ,GAAG,IAAI;MAIpB,IAAI,CAAC8B,gBAAgB,CAAChI,IAAI,CAAC;IAC7B;IAEA,IAAI,IAAI,CAACkW,KAAK,CAAA,EAAA,CAAU,EAAE;MACxB,MAAMke,YAAY,GAAG,IAAI,CAAC/O,WAAW,CAAyBngB,QAAQ,CAAC;MACvEkvB,YAAY,CAAC3yB,UAAU,GAAGzB,IAAI;MAC9Bo0B,YAAY,CAAC1I,cAAc,GAAG,IAAI,CAACuuB,qBAAqB,EAAE;MAE1D,OAAO,IAAI,CAAC11C,UAAU,CAAC6vB,YAAY,EAAE,sBAAsB,CAAC;IAC9D;IAEA,OAAOp0B,IAAI;EACb;EAEAu0B,sBAAsBA,CACpBv0B,IAA8B,EACI;IAClC,IAAI,CAAC,IAAI,CAAC6G,KAAK,CAACmM,gBAAgB,IAAI,IAAI,CAAC0O,YAAY,CAAA,GAAA,CAAa,EAAE;MAClE,OAAO,IAAI,CAAC+gC,kBAAkB,CAAC,MAAM,IAAI,CAACluB,sBAAsB,CAACv0B,IAAI,CAAC,CAAC;IACzE;IAGA,MAAMkF,QAAQ,GAAG,IAAI,CAAC2B,KAAK,CAAC3B,QAAQ;IAEpC,MAAM+gD,SAAS,GAAG,IAAI,CAACjkC,aAAa,CAAa,GAAA,CAAA;IAEjD,IACEikC,SAAS,KACR,IAAI,CAACvkC,YAAY,CAAA,GAAA,CAAa,IAAI,CAAC,IAAI,CAACkR,4BAA4B,EAAE,CAAC,EACxE;MACA,MAAM,IAAI,CAAC7sB,KAAK,CAAC8sC,QAAQ,CAACqB,iCAAiC,EAAE;QAC3DzuD,EAAE,EAAE,IAAI,CAACohB,KAAK,CAAC3B;MACjB,CAAC,CAAC;IACJ;IAEA,MAAMghD,YAAY,GAAGr5D,iBAAiB,CAAC,IAAI,CAACga,KAAK,CAACxU,IAAI,CAAC;IACvD,MAAM6U,WAA6C,GAChDg/C,YAAY,IAAI,IAAI,CAACpD,2BAA2B,EAAE,IACnD,KAAK,CAACvuB,sBAAsB,CAACv0B,IAAI,CAAC;IAEpC,IAAI,CAACkH,WAAW,EAAE,OAAO,IAAI;IAE7B,IACEA,WAAW,CAAC7U,IAAI,KAAK,wBAAwB,IAC7C6U,WAAW,CAAC7U,IAAI,KAAK,wBAAwB,IAC7C4zD,SAAS,EACT;MACAjmD,IAAI,CAAC2sB,UAAU,GAAG,MAAM;IAC1B;IAEA,IAAIs5B,SAAS,EAAE;MAEb,IAAI,CAAC9+C,kBAAkB,CAACD,WAAW,EAAEhC,QAAQ,CAAC;MAE9CgC,WAAW,CAACinB,OAAO,GAAG,IAAI;IAC5B;IAEA,OAAOjnB,WAAW;EACpB;EAEA4tB,YAAYA,CACV90B,IAAa,EACb+0B,WAAoB,EACpBC,UAA2B,EAE3BvmB,WAA0B,EACpB;IACN,IAAI,CAAC,CAACsmB,WAAW,IAAIC,UAAU,KAAK,IAAI,CAACtT,YAAY,CAAA,GAAA,CAAgB,EAAE;MACrE;IACF;IAEA,KAAK,CAACoT,YAAY,CAChB90B,IAAI,EACJ+0B,WAAW,EACXC,UAAU,EACTh1B,IAAI,CAASmuB,OAAO,GAAGniB,eAAe,GAAGR,UAAU,CACrD;IACD,MAAMhI,cAAc,GAAG,IAAI,CAACm3C,wBAAwB,CAClD,IAAI,CAAC/C,0BAA0B,CAChC;IACD,IAAIp0C,cAAc,EAAExD,IAAI,CAACwD,cAAc,GAAGA,cAAc;EAC1D;EAEA2iD,4BAA4BA,CAC1BnmD,IAAwE,EAClE;IACN,IAAI,CAACA,IAAI,CAACkG,QAAQ,EAAE;MAClB,IAAI,IAAI,CAACuS,GAAG,CAAA,EAAA,CAAS,EAAE;QACrBzY,IAAI,CAAComD,QAAQ,GAAG,IAAI;MACrB,CAAA,MAAM,IAAI,IAAI,CAAC3tC,GAAG,IAAa,EAAE;QAChCzY,IAAI,CAACkG,QAAQ,GAAG,IAAI;MACtB;IACF;IAEA,MAAM7T,IAAI,GAAG,IAAI,CAACspD,wBAAwB,EAAE;IAC5C,IAAItpD,IAAI,EAAE2N,IAAI,CAAC0rB,cAAc,GAAGr5B,IAAI;EACtC;EAEAmS,kBAAkBA,CAACxE,IAAqB,EAAmB;IACzD,IAAI,CAACmmD,4BAA4B,CAACnmD,IAAI,CAAC;IAEvC,IACE,IAAI,CAAC6G,KAAK,CAACmM,gBAAgB,IAC3B,EAAEhT,IAAI,CAAC67C,QAAQ,IAAI,CAAC77C,IAAI,CAAC0rB,cAAc,CAAC,IACxC,IAAI,CAACxV,KAAK,CAAA,EAAA,CAAO,EACjB;MACA,IAAI,CAACnQ,KAAK,CAAC8sC,QAAQ,CAACa,+BAA+B,EAAE;QACnDjuD,EAAE,EAAE,IAAI,CAACohB,KAAK,CAAC3B;MACjB,CAAC,CAAC;IACJ;IACA,IAAIlF,IAAI,CAAC+9C,QAAQ,IAAI,IAAI,CAAC7nC,KAAK,IAAO,EAAE;MACtC,MAAM;QAAEr1B;MAAK,CAAA,GAAGmf,IAAI;MACpB,IAAI,CAAC+F,KAAK,CAAC8sC,QAAQ,CAACG,8BAA8B,EAAE;QAClDvtD,EAAE,EAAE,IAAI,CAACohB,KAAK,CAAC3B,QAAQ;QACvB+tC,YAAY,EACVpyD,GAAG,CAACwR,IAAI,KAAK,YAAY,IAAI,CAAC2N,IAAI,CAACsE,QAAQ,GACvCzjB,GAAG,CAAC6B,IAAI,GACP,IAAG,IAAI,CAAC+uB,KAAK,CAAC2C,KAAK,CAACvzB,GAAG,CAAC8N,KAAK,EAAE9N,GAAG,CAAC+N,GAAG,CAAE;MACjD,CAAC,CAAC;IACJ;IAEA,OAAO,KAAK,CAAC4V,kBAAkB,CAACxE,IAAI,CAAC;EACvC;EAEA2E,yBAAyBA,CACvB3E,IAA4B,EACJ;IAExB,IAAIA,IAAI,CAAC+9C,QAAQ,EAAE;MACjB,IAAI,CAACh4C,KAAK,CAAC8sC,QAAQ,CAAC4C,yBAAyB,EAAE;QAAEhwD,EAAE,EAAEua;MAAK,CAAC,CAAC;IAC9D;IAGA,IAAIA,IAAI,CAAC24C,aAAa,EAAE;MACtB,IAAI,CAAC5yC,KAAK,CAAC8sC,QAAQ,CAAC6C,8BAA8B,EAAE;QAClDjwD,EAAE,EAAEua,IAAI;QAER6zC,QAAQ,EAAE7zC,IAAI,CAAC24C;MACjB,CAAC,CAAC;IACJ;IAEA,IAAI,CAACwN,4BAA4B,CAACnmD,IAAI,CAAC;IACvC,OAAO,KAAK,CAAC2E,yBAAyB,CAAC3E,IAAI,CAAC;EAC9C;EAEAqmD,0BAA0BA,CACxBrmD,IAA6B,EACJ;IACzB,IAAI,CAACmmD,4BAA4B,CAACnmD,IAAI,CAAC;IACvC,IAAIA,IAAI,CAACkG,QAAQ,EAAE;MACjB,IAAI,CAACH,KAAK,CAAC8sC,QAAQ,CAACO,wBAAwB,EAAE;QAAE3tD,EAAE,EAAEua;MAAK,CAAC,CAAC;IAC7D;IACA,OAAO,KAAK,CAACqmD,0BAA0B,CAACrmD,IAAI,CAAC;EAC/C;EAEAkD,eAAeA,CACbC,SAAsB,EACtBf,MAAqB,EACrBgB,WAAoB,EACpBpB,OAAgB,EAChBqB,aAAsB,EACtBC,iBAA0B,EACpB;IACN,MAAME,cAAc,GAAG,IAAI,CAACm3C,wBAAwB,CAClD,IAAI,CAAChD,oBAAoB,CAC1B;IACD,IAAIn0C,cAAc,IAAIH,aAAa,EAAE;MACnC,IAAI,CAAC0C,KAAK,CAAC8sC,QAAQ,CAACW,4BAA4B,EAAE;QAChD/tD,EAAE,EAAE+d;MACN,CAAC,CAAC;IACJ;IAGA,MAAM;MAAE2qB,OAAO,GAAG,KAAK;MAAE17B;IAAM,CAAA,GAAG2P,MAAM;IAExC,IAAI+rB,OAAO,KAAK17B,IAAI,KAAK,KAAK,IAAIA,IAAI,KAAK,KAAK,CAAC,EAAE;MACjD,IAAI,CAACsT,KAAK,CAAC8sC,QAAQ,CAACY,eAAe,EAAE;QAAEhuD,EAAE,EAAE2c,MAAM;QAAE3P;MAAK,CAAC,CAAC;IAC5D;IACA,IAAI+Q,cAAc,EAAEpB,MAAM,CAACoB,cAAc,GAAGA,cAAc;IAC1D,KAAK,CAACN,eAAe,CACnBC,SAAS,EACTf,MAAM,EACNgB,WAAW,EACXpB,OAAO,EACPqB,aAAa,EACbC,iBAAiB,CAClB;EACH;EAEA+yB,sBAAsBA,CACpBlzB,SAAsB,EACtBf,MAA4B,EAC5BgB,WAAoB,EACpBpB,OAAgB,EACV;IACN,MAAMwB,cAAc,GAAG,IAAI,CAACm3C,wBAAwB,CAClD,IAAI,CAAChD,oBAAoB,CAC1B;IACD,IAAIn0C,cAAc,EAAEpB,MAAM,CAACoB,cAAc,GAAGA,cAAc;IAC1D,KAAK,CAAC6yB,sBAAsB,CAAClzB,SAAS,EAAEf,MAAM,EAAEgB,WAAW,EAAEpB,OAAO,CAAC;EACvE;EAEAskD,gCAAgCA,CAC9BtmD,IAAyE,EACzEvN,IAAY,EACZ;IACA,IAAIuN,IAAI,CAAC3N,IAAI,KAAK,iBAAiB,EAAE;IAErC,IAAI2N,IAAI,CAAC3N,IAAI,KAAK,kBAAkB,IAAI,CAAC2N,IAAI,CAACtQ,KAAK,CAACsT,IAAI,EAAE;IAE1D,KAAK,CAACsjD,gCAAgC,CAACtmD,IAAI,EAAEvN,IAAI,CAAC;EACpD;EAEA6jC,eAAeA,CAACt2B,IAAa,EAAQ;IACnC,KAAK,CAACs2B,eAAe,CAACt2B,IAAI,CAAC;IAE3B,IAAIA,IAAI,CAACE,UAAU,KAAK,IAAI,CAACgW,KAAK,CAAO,EAAA,CAAA,IAAI,IAAI,CAACA,KAAK,CAAA,EAAA,CAAc,CAAC,EAAE;MAEtElW,IAAI,CAACu2B,mBAAmB,GAAG,IAAI,CAAC8sB,gCAAgC,EAAE;IACpE;IACA,IAAI,IAAI,CAACrhC,aAAa,CAAA,GAAA,CAAgB,EAAE;MACtChiB,IAAI,CAACmtB,UAAU,GAAG,IAAI,CAACszB,qBAAqB,CAAC,YAAY,CAAC;IAC5D;EACF;EAEA9pB,iBAAiBA,CACf9xB,IAA+C,EAC/CK,QAAqC,EACrC9B,WAAoB,EACpBpB,OAAgB,EAChB8C,SAAkB,EAClBC,UAAmB,EACnBI,mBAA6C,EAC7C;IACA,MAAM3B,cAAc,GAAG,IAAI,CAACm3C,wBAAwB,CAClD,IAAI,CAAChD,oBAAoB,CAC1B;IACD,IAAIn0C,cAAc,EAAEqB,IAAI,CAACrB,cAAc,GAAGA,cAAc;IAExD,OAAO,KAAK,CAACmzB,iBAAiB,CAC5B9xB,IAAI,EAEJK,QAAQ,EACR9B,WAAW,EACXpB,OAAO,EACP8C,SAAS,EACTC,UAAU,EACVI,mBAAmB,CACpB;EACH;EAEA8yB,mBAAmBA,CAACj4B,IAAgB,EAAEqD,aAAsB,EAAQ;IAClE,MAAMG,cAAc,GAAG,IAAI,CAACm3C,wBAAwB,CAClD,IAAI,CAAChD,oBAAoB,CAC1B;IACD,IAAIn0C,cAAc,EAAExD,IAAI,CAACwD,cAAc,GAAGA,cAAc;IACxD,KAAK,CAACy0B,mBAAmB,CAACj4B,IAAI,EAAEqD,aAAa,CAAC;EAChD;EAGA60B,UAAUA,CACR5D,IAA0B,EAC1B7hC,IAAuC,EACjC;IACN,KAAK,CAACylC,UAAU,CAAC5D,IAAI,EAAE7hC,IAAI,CAAC;IAC5B,IACE6hC,IAAI,CAACzwB,EAAE,CAACxR,IAAI,KAAK,YAAY,IAC7B,CAAC,IAAI,CAAC8vB,qBAAqB,EAAE,IAC7B,IAAI,CAAC1J,GAAG,IAAS,EACjB;MACA6b,IAAI,CAAC8xB,QAAQ,GAAG,IAAI;IACtB;IAEA,MAAM/zD,IAAI,GAAG,IAAI,CAACspD,wBAAwB,EAAE;IAC5C,IAAItpD,IAAI,EAAE;MACRiiC,IAAI,CAACzwB,EAAE,CAAC6nB,cAAc,GAAGr5B,IAAI;MAC7B,IAAI,CAAC2V,gBAAgB,CAACssB,IAAI,CAACzwB,EAAE,CAAC;IAChC;EACF;EAGAs0B,iCAAiCA,CAC/Bn4B,IAA+B,EAC/Bo4B,IAAsB,EACK;IAC3B,IAAI,IAAI,CAACliB,KAAK,CAAA,EAAA,CAAU,EAAE;MACxBlW,IAAI,CAACyrB,UAAU,GAAG,IAAI,CAACwuB,qBAAqB,EAAE;IAChD;IACA,OAAO,KAAK,CAAC9hB,iCAAiC,CAACn4B,IAAI,EAAEo4B,IAAI,CAAC;EAC5D;EAEA5E,gBAAgBA,CACdruB,mBAA6C,EAC7CmzB,cAAyB,EACX;IAAA,IAAAC,IAAA,EAAAG,KAAA,EAAA6tB,SAAA,EAAA5tB,KAAA,EAAA6tB,UAAA,EAAAC,KAAA,EAAAC,UAAA;IAGd,IAAI7/C,KAA+B;IACnC,IAAI2xB,GAAG;IACP,IAAImuB,QAAQ;IAEZ,IACE,IAAI,CAACrgD,SAAS,CAAC,KAAK,CAAC,KACpB,IAAI,CAAC4P,KAAK,KAAgB,IAAI,IAAI,CAACA,KAAK,CAAA,EAAA,CAAO,CAAC,EACjD;MAEArP,KAAK,GAAG,IAAI,CAACA,KAAK,CAAC9H,KAAK,EAAE;MAE1By5B,GAAG,GAAG,IAAI,CAAC/V,QAAQ,CACjB,MAAM,KAAK,CAAC+Q,gBAAgB,CAACruB,mBAAmB,EAAEmzB,cAAc,CAAC,EACjEzxB,KAAK,CACN;MAID,IAAI,CAAC2xB,GAAG,CAAC1a,KAAK,EAAE,OAAO0a,GAAG,CAACx4B,IAAI;MAK/B,MAAM;QAAE/R;OAAS,GAAG,IAAI,CAAC4Y,KAAK;MAC9B,MAAM4xB,cAAc,GAAGxqC,OAAO,CAACA,OAAO,CAACG,MAAM,GAAG,CAAC,CAAC;MAClD,IAAIqqC,cAAc,KAAKtqC,KAAE,CAAC7M,MAAM,IAAIm3C,cAAc,KAAKtqC,KAAE,CAAC3M,MAAM,EAAE;QAChEyM,OAAO,CAACC,GAAG,EAAE;MACf;IACF;IAEA,IAAI,EAAAqqC,CAAAA,IAAA,GAACC,GAAG,aAAHD,IAAA,CAAKza,KAAK,CAAA,IAAI,CAAC,IAAI,CAAC5H,KAAK,IAAO,EAAE;MACrC,OAAO,KAAK,CAACsd,gBAAgB,CAACruB,mBAAmB,EAAEmzB,cAAc,CAAC;IACpE;IAOA,IAAI,CAACzxB,KAAK,IAAIA,KAAK,KAAK,IAAI,CAACA,KAAK,EAAEA,KAAK,GAAG,IAAI,CAACA,KAAK,CAAC9H,KAAK,EAAE;IAE9D,IAAIyE,cAA+D;IACnE,MAAMre,KAAK,GAAG,IAAI,CAACs9B,QAAQ,CAACmW,KAAK,IAAI;MAAA,IAAAjD,WAAA,EAAAixB,eAAA;MAEnCpjD,cAAc,GAAG,IAAI,CAACo3C,qBAAqB,CAAC,IAAI,CAACjD,oBAAoB,CAAC;MACtE,MAAMhlB,IAAI,GAAG,KAAK,CAACa,gBAAgB,CACjCruB,mBAAmB,EACnBmzB,cAAc,CACf;MAED,IACE3F,IAAI,CAACtgC,IAAI,KAAK,yBAAyB,IAAAsjC,CAAAA,WAAA,GACvChD,IAAI,CAAChxB,KAAK,KAAA,IAAA,IAAVg0B,WAAA,CAAYnzB,aAAa,EACzB;QACAo2B,KAAK,EAAE;MACT;MAGA,IAAI,CAAAguB,CAAAA,eAAA,GAAApjD,cAAc,KAAdojD,IAAAA,GAAAA,KAAAA,CAAAA,GAAAA,eAAA,CAAgBvkD,MAAM,CAACjU,MAAM,MAAK,CAAC,EAAE;QACvC,IAAI,CAACk3B,0BAA0B,CAACqN,IAAI,EAAEnvB,cAAc,CAAC;MACvD;MACAmvB,IAAI,CAACnvB,cAAc,GAAGA,cAAc;MAqBpC,OAAOmvB,IAAI;IACZ,CAAA,EAAE9rB,KAAK,CAAC;IAGT,IAAI,CAAC1hB,KAAK,CAAC24B,KAAK,IAAI,CAAC34B,KAAK,CAAC49B,OAAO,EAAE;MAIlC,IAAIvf,cAAc,EAAE,IAAI,CAACqjD,4BAA4B,CAACrjD,cAAc,CAAC;MAErE,OAAOre,KAAK,CAAC6a,IAAI;IACnB;IAEA,IAAI,CAACw4B,GAAG,EAAE;MAIRoa,MAAM,CAAC,CAAC,IAAI,CAACtsC,SAAS,CAAC,KAAK,CAAC,CAAC;MAI9BqgD,QAAQ,GAAG,IAAI,CAAClkC,QAAQ,CACtB,MAAM,KAAK,CAAC+Q,gBAAgB,CAACruB,mBAAmB,EAAEmzB,cAAc,CAAC,EACjEzxB,KAAK,CACN;MAGD,IAAI,CAAC8/C,QAAQ,CAAC7oC,KAAK,EAAE,OAAO6oC,QAAQ,CAAC3mD,IAAI;IAC3C;IAEA,IAAA,CAAA04B,KAAA,GAAIF,GAAG,aAAHE,KAAA,CAAK14B,IAAI,EAAE;MAEb,IAAI,CAAC6G,KAAK,GAAG2xB,GAAG,CAAC3V,SAAS;MAC1B,OAAO2V,GAAG,CAACx4B,IAAI;IACjB;IAEA,IAAI7a,KAAK,CAAC6a,IAAI,EAAE;MAEd,IAAI,CAAC6G,KAAK,GAAG1hB,KAAK,CAAC09B,SAAS;MAC5B,IAAIrf,cAAc,EAAE,IAAI,CAACqjD,4BAA4B,CAACrjD,cAAc,CAAC;MAErE,OAAOre,KAAK,CAAC6a,IAAI;IACnB;IAEA,IAAA,CAAAumD,SAAA,GAAII,QAAQ,aAARJ,SAAA,CAAUvmD,IAAI,EAAE;MAElB,IAAI,CAAC6G,KAAK,GAAG8/C,QAAQ,CAAC9jC,SAAS;MAC/B,OAAO8jC,QAAQ,CAAC3mD,IAAI;IACtB;IAEA,IAAA24B,CAAAA,KAAA,GAAIH,GAAG,KAAHG,IAAAA,IAAAA,KAAA,CAAK7V,MAAM,EAAE,MAAM0V,GAAG,CAAC1a,KAAK;IAChC,IAAI34B,KAAK,CAAC29B,MAAM,EAAE,MAAM39B,KAAK,CAAC24B,KAAK;IACnC,IAAA0oC,CAAAA,UAAA,GAAIG,QAAQ,KAARH,IAAAA,IAAAA,UAAA,CAAU1jC,MAAM,EAAE,MAAM6jC,QAAQ,CAAC7oC,KAAK;IAE1C,MAAM,EAAA2oC,KAAA,GAAAjuB,GAAG,KAAHiuB,IAAAA,GAAAA,KAAAA,CAAAA,GAAAA,KAAA,CAAK3oC,KAAK,KAAI34B,KAAK,CAAC24B,KAAK,MAAA4oC,UAAA,GAAIC,QAAQ,KAARD,IAAAA,GAAAA,KAAAA,CAAAA,GAAAA,UAAA,CAAU5oC,KAAK,CAAA;EACpD;EAEA+oC,4BAA4BA,CAAC7mD,IAAS,EAAE;IAAA,IAAA8zB,WAAA;IACtC,IACE9zB,IAAI,CAACqC,MAAM,CAACjU,MAAM,KAAK,CAAC,IACxB,CAAC4R,IAAI,CAACqC,MAAM,CAAC,CAAC,CAAC,CAACo4C,UAAU,IAC1B,EAAA3mB,CAAAA,WAAA,GAAC9zB,IAAI,CAAC2B,KAAK,KAAA,IAAA,IAAVmyB,WAAA,CAAYgzB,aAAa,CAC1B,IAAA,IAAI,CAACpjD,eAAe,CAAC,YAAY,EAAE,0BAA0B,CAAC,EAC9D;MACA,IAAI,CAACqC,KAAK,CAAC8sC,QAAQ,CAAC+C,sBAAsB,EAAE;QAAEnwD,EAAE,EAAEua;MAAK,CAAC,CAAC;IAC3D;EACF;EAGAu+C,eAAeA,CACbp5C,mBAA6C,EAC7C4hD,QAAkB,EACJ;IACd,IAAI,CAAC,IAAI,CAACzgD,SAAS,CAAC,KAAK,CAAC,IAAI,IAAI,CAAC4P,KAAK,CAAA,EAAA,CAAO,EAAE;MAC/C,OAAO,IAAI,CAACsqC,oBAAoB,EAAE;IACpC,CAAC,MAAM;MACL,OAAO,KAAK,CAACjC,eAAe,CAACp5C,mBAAmB,EAAE4hD,QAAQ,CAAC;IAC7D;EACF;EAEA9tB,UAAUA,CACRj5B,IAAuC,EACe;IACtD,IAAI,IAAI,CAACkW,KAAK,CAAA,EAAA,CAAU,EAAE;MAIxB,MAAMge,MAAM,GAAG,IAAI,CAACzR,QAAQ,CAACmW,KAAK,IAAI;QACpC,MAAMnN,UAAU,GAAG,IAAI,CAAC2vB,oCAAoC,CAE3D,EAAA,CAAA;QACD,IAAI,IAAI,CAACl5B,kBAAkB,EAAE,IAAI,CAAC,IAAI,CAAChM,KAAK,CAAA,EAAA,CAAU,EAAE0iB,KAAK,EAAE;QAC/D,OAAOnN,UAAU;MACnB,CAAC,CAAC;MAEF,IAAIyI,MAAM,CAACnR,OAAO,EAAE;MAEpB,IAAI,CAACmR,MAAM,CAACpR,MAAM,EAAE;QAClB,IAAIoR,MAAM,CAACpW,KAAK,EAAE,IAAI,CAACjX,KAAK,GAAGqtB,MAAM,CAACrR,SAAS;QAE/C7iB,IAAI,CAACyrB,UAAU,GAAGyI,MAAM,CAACl0B,IAAI;MAC/B;IACF;IAEA,OAAO,KAAK,CAACi5B,UAAU,CAACj5B,IAAI,CAAC;EAC/B;EAGA42B,4BAA4BA,CAC1B5E,KAAgB,EAChBxxB,KAA4B,EAC5B;IACA,IAAI,EAAEA,KAAK,IAA2C,CAAC,EAAE,OAAOwxB,KAAK;IAErE,IAAI,IAAI,CAACvZ,GAAG,CAAA,EAAA,CAAa,EAAE;MACxBuZ,KAAK,CAAyB9rB,QAAQ,GAAG,IAAI;IAChD;IACA,MAAM7T,IAAI,GAAG,IAAI,CAACspD,wBAAwB,EAAE;IAC5C,IAAItpD,IAAI,EAAE2/B,KAAK,CAACtG,cAAc,GAAGr5B,IAAI;IACrC,IAAI,CAAC2V,gBAAgB,CAACgqB,KAAK,CAAC;IAE5B,OAAOA,KAAK;EACd;EAEAzsB,YAAYA,CAACvF,IAAY,EAAEwF,SAAmB,EAAW;IACvD,QAAQxF,IAAI,CAAC3N,IAAI;MACf,KAAK,sBAAsB;QACzB,OAAO,IAAI,CAACkT,YAAY,CAACvF,IAAI,CAACyB,UAAU,EAAE+D,SAAS,CAAC;MACtD,KAAK,qBAAqB;QACxB,OAAO,IAAI;MACb;QACE,OAAO,KAAK,CAACD,YAAY,CAACvF,IAAI,EAAEwF,SAAS,CAAC;IAAA;EAEhD;EAEAC,YAAYA,CAACzF,IAAY,EAAE0F,KAAc,GAAG,KAAK,EAAQ;IACvD,QAAQ1F,IAAI,CAAC3N,IAAI;MACf,KAAK,yBAAyB;QAC5B,IAAI,CAAC20D,mCAAmC,CAAChnD,IAAI,EAAE0F,KAAK,CAAC;QACrD;MACF,KAAK,gBAAgB;MACrB,KAAK,uBAAuB;MAC5B,KAAK,qBAAqB;MAC1B,KAAK,iBAAiB;QACpB,IAAIA,KAAK,EAAE;UACT,IAAI,CAACye,eAAe,CAAC/D,gCAAgC,CACnDyyB,QAAQ,CAAC+D,6BAA6B,EACtC;YAAEnxD,EAAE,EAAEua;UAAK,CAAC,CACb;QACH,CAAC,MAAM;UACL,IAAI,CAAC+F,KAAK,CAAC8sC,QAAQ,CAAC+D,6BAA6B,EAAE;YAAEnxD,EAAE,EAAEua;UAAK,CAAC,CAAC;QAClE;QACA,IAAI,CAACyF,YAAY,CAACzF,IAAI,CAACyB,UAAU,EAAEiE,KAAK,CAAC;QACzC;MACF,KAAK,sBAAsB;QACzB,IAAI,CAACA,KAAK,IAAI1F,IAAI,CAACu1B,IAAI,CAACljC,IAAI,KAAK,sBAAsB,EAAE;UACvD2N,IAAI,CAACu1B,IAAI,GAAG,IAAI,CAACnD,mBAAmB,CAACpyB,IAAI,CAACu1B,IAAI,CAAC;QACjD;MAEF;QACE,KAAK,CAAC9vB,YAAY,CAACzF,IAAI,EAAE0F,KAAK,CAAC;IAAA;EAErC;EAEAshD,mCAAmCA,CAAChnD,IAAY,EAAE0F,KAAc,EAAQ;IACtE,QAAQ1F,IAAI,CAACyB,UAAU,CAACpP,IAAI;MAC1B,KAAK,gBAAgB;MACrB,KAAK,uBAAuB;MAC5B,KAAK,qBAAqB;MAC1B,KAAK,iBAAiB;MACtB,KAAK,yBAAyB;QAC5B,IAAI,CAACoT,YAAY,CAACzF,IAAI,CAACyB,UAAU,EAAEiE,KAAK,CAAC;QACzC;MACF;QACE,KAAK,CAACD,YAAY,CAACzF,IAAI,EAAE0F,KAAK,CAAC;IAAA;EAErC;EAEA8qC,qBAAqBA,CAACxwC,IAAY,EAAEyyC,YAAqB,EAAQ;IAC/D,QAAQzyC,IAAI,CAAC3N,IAAI;MACf,KAAK,gBAAgB;MACrB,KAAK,uBAAuB;MAC5B,KAAK,iBAAiB;MACtB,KAAK,qBAAqB;QACxB,IAAI,CAACm+C,qBAAqB,CAACxwC,IAAI,CAACyB,UAAU,EAAE,KAAK,CAAC;QAClD;MACF;QACE,KAAK,CAAC+uC,qBAAqB,CAACxwC,IAAI,EAAEyyC,YAAY,CAAC;IAAA;EAErD;EAGArtC,WAAWA,CACT/S,IAMqB,EACrBgT,yBAAkC,EAClCC,OAAqB,EACrB;IACA,OACE0qC,MAAM,CACJ;MAIEiX,oBAAoB,EAAE,IAAI;MAC1BC,mBAAmB,EAAE,WAAW;MAChCC,mBAAmB,EAAE,YAAY;MACjCC,cAAc,EAAE,CAAC9hD,OAAO,KAAK2G,SAAS,IACpC,CAAC5G,yBAAyB,KAAK,CAAC,YAAY,EAAE,IAAI,CAAC;MACrDgiD,qBAAqB,EAAE,CAAC/hD,OAAO,KAAK2G,SAAS,IAC3C,CAAC5G,yBAAyB,KAAK,CAAC,YAAY,EAAE,IAAI,CAAC;MACrDiiD,eAAe,EAAE,CAAChiD,OAAO,KAAK2G,SAAS,IACrC,CAAC5G,yBAAyB,KAAK,CAAC,YAAY,EAAE,IAAI;IACtD,CAAC,EACDhT,IAAI,CACL,IAAI,KAAK,CAAC+S,WAAW,CAAC/S,IAAI,EAAEgT,yBAAyB,EAAEC,OAAO,CAAC;EAEpE;EAEA0yB,gBAAgBA,CAAAA,EAAc;IAC5B,QAAQ,IAAI,CAACnxB,KAAK,CAACxU,IAAI;MACrB,KAAA,EAAA;QAEE,OAAO,IAAI,CAAC64B,eAAe,CAAe,IAAI,CAAC;MACjD;QACE,OAAO,KAAK,CAAC8M,gBAAgB,EAAE;IAAA;EAErC;EAEAuvB,4BAA4BA,CAAC50B,IAAkB,EAAgB;IAE7D,IAAI,IAAI,CAACzc,KAAK,CAAA,EAAA,CAAO,IAAI,IAAI,CAACA,KAAK,CAAA,EAAA,CAAc,EAAE;MACjD,MAAM4jB,aAAa,GAAG,IAAI,CAACupB,gCAAgC,EAAE;MAE7D,IAAI,IAAI,CAACntC,KAAK,CAAA,EAAA,CAAW,EAAE;QACzB,MAAMkiB,IAAI,GAAG,KAAK,CAACmvB,4BAA4B,CAAC50B,IAAI,CAAC;QACrDyF,IAAI,CAAC50B,cAAc,GAAGs2B,aAAa;QACnC,OAAO1B,IAAI;MACb;MAEA,IAAI,CAACjhC,UAAU,CAAC,IAAI,EAAY,EAAA,CAAA;IAClC;IAEA,OAAO,KAAK,CAACowD,4BAA4B,CAAC50B,IAAI,CAAC;EACjD;EAEAye,mBAAmBA,CACjBvb,KAAiD,EACxC;IACT,IACE,IAAI,CAAChvB,KAAK,CAACmM,gBAAgB,IAC3B,IAAI,CAACkD,KAAK,CAAA,EAAA,CAAU,IACpB,IAAI,CAACgD,iBAAiB,EAAE,KAAK2c,KAAK,EAClC;MACA,IAAI,CAACjsB,IAAI,EAAE;MACX,OAAO,KAAK;IACd,CAAC,MAAM;MACL,OAAO,KAAK,CAACwnC,mBAAmB,CAACvb,KAAK,CAAC;IACzC;EACF;EAOAI,aAAaA,CAAAA,EAAY;IACvB,OAAO,IAAI,CAAC/f,KAAK,CAAA,EAAA,CAAO,IAAI,KAAK,CAAC+f,aAAa,EAAE;EACnD;EAEAC,eAAeA,CAAAA,EAAY;IACzB,OACE,IAAI,CAAChgB,KAAK,CAAA,EAAA,CAAS,IAAI,IAAI,CAACA,KAAK,CAAU,EAAA,CAAA,IAAI,KAAK,CAACggB,eAAe,EAAE;EAE1E;EAEAW,iBAAiBA,CACf3xB,QAA0B,EAC1BqwB,IAAqB,EACV;IACX,MAAMv1B,IAAI,GAAG,KAAK,CAAC62B,iBAAiB,CAAC3xB,QAAQ,EAAEqwB,IAAI,CAAC;IAEpD,IACEv1B,IAAI,CAAC3N,IAAI,KAAK,mBAAmB,IACjC2N,IAAI,CAAC0rB,cAAc,IACnB1rB,IAAI,CAACkuB,KAAK,CAACv/B,KAAK,GAAGqR,IAAI,CAAC0rB,cAAc,CAAC/8B,KAAK,EAC5C;MACA,IAAI,CAACoX,KAAK,CAAC8sC,QAAQ,CAACwD,yBAAyB,EAAE;QAC7C5wD,EAAE,EAAEua,IAAI,CAAC0rB;MACX,CAAC,CAAC;IACJ;IAEA,OAAO1rB,IAAI;EACb;EAGA+Z,gBAAgBA,CAACppB,IAAY,EAAQ;IACnC,IAAI,IAAI,CAACkW,KAAK,CAACgM,MAAM,EAAE;MACrB,IAAIliB,IAAI,OAA0B,EAAE;QAClC,IAAI,CAACkqB,QAAQ,CAAQ,EAAA,EAAA,CAAC,CAAC;QACvB;MACF;MACA,IAAIlqB,IAAI,OAAuB,EAAE;QAC/B,IAAI,CAACkqB,QAAQ,CAAQ,EAAA,EAAA,CAAC,CAAC;QACvB;MACF;IACF;IACA,KAAK,CAACd,gBAAgB,CAACppB,IAAI,CAAC;EAC9B;EAGAm0D,YAAYA,CAAAA,EAAG;IACb,MAAM;MAAEzyD;KAAM,GAAG,IAAI,CAACwU,KAAK;IAC3B,IAAIxU,IAAI,OAAU,EAAE;MAClB,IAAI,CAACwU,KAAK,CAAC5H,GAAG,IAAI,CAAC;MACnB,IAAI,CAAC0c,YAAY,EAAE;IACrB,CAAC,MAAM,IAAItpB,IAAI,KAAA,EAAU,EAAE;MACzB,IAAI,CAACwU,KAAK,CAAC5H,GAAG,IAAI,CAAC;MACnB,IAAI,CAAC2c,YAAY,EAAE;IACrB;EACF;EAEA0nC,SAASA,CAAAA,EAAG;IACV,MAAM;MAAEjxD;KAAM,GAAG,IAAI,CAACwU,KAAK;IAC3B,IAAIxU,IAAI,OAAiB,EAAE;MACzB,IAAI,CAACwU,KAAK,CAAC5H,GAAG,IAAI,CAAC;MACnB,IAAI,CAAC4b,QAAQ,CAAQ,EAAA,EAAA,CAAC,CAAC;MACvB,OAAA,EAAA;IACF;IACA,OAAOxoB,IAAI;EACb;EAEA0hC,gBAAgBA,CACdyB,QAAsB,EACtBxB,gBAA6C,EAC7CtuB,KAAc,EACR;IACN,KAAK,IAAI9V,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG4lC,QAAQ,CAACpnC,MAAM,EAAEwB,CAAC,EAAE,EAAE;MACxC,MAAM+iC,IAAI,GAAG6C,QAAQ,CAAC5lC,CAAC,CAAC;MACxB,IAAI,CAAA+iC,IAAI,IAAJA,IAAAA,GAAAA,KAAAA,CAAAA,GAAAA,IAAI,CAAEtgC,IAAI,MAAK,sBAAsB,EAAE;QACzCmjC,QAAQ,CAAC5lC,CAAC,CAAC,GAAG,IAAI,CAACwiC,mBAAmB,CACpCO,IAAI,CACL;MACH;IACF;IACA,KAAK,CAACoB,gBAAgB,CAACyB,QAAQ,EAAExB,gBAAgB,EAAEtuB,KAAK,CAAC;EAC3D;EAEA0sB,mBAAmBA,CAACpyB,IAA4B,EAAU;IACxDA,IAAI,CAACyB,UAAU,CAACiqB,cAAc,GAAG1rB,IAAI,CAAC0rB,cAAc;IAEpD,IAAI,CAAC1jB,gBAAgB,CAAChI,IAAI,CAACyB,UAAU,EAAEzB,IAAI,CAAC0rB,cAAc,CAAC7sB,GAAG,CAACjQ,GAAG,CAAC;IAEnE,OAAOoR,IAAI,CAACyB,UAAU;EACxB;EAEAy3B,gBAAgBA,CAAC72B,MAAqB,EAAE;IACtC,IAAI,IAAI,CAAC6T,KAAK,CAAA,EAAA,CAAU,EAAE;MACxB,OAAO7T,MAAM,CAACwxB,KAAK,CAAClB,IAAI,IAAI,IAAI,CAACptB,YAAY,CAACotB,IAAI,EAAE,IAAI,CAAC,CAAC;IAC5D;IACA,OAAO,KAAK,CAACuG,gBAAgB,CAAC72B,MAAM,CAAC;EACvC;EAEAg2B,qBAAqBA,CAAAA,EAAY;IAC/B,OAAO,IAAI,CAACniB,KAAK,CAAA,EAAA,CAAU,IAAI,KAAK,CAACmiB,qBAAqB,EAAE;EAC9D;EAEAmvB,uBAAuBA,CAAAA,EAAG;IAExB,OAAO,KAAK,CAACA,uBAAuB,EAAE,IAAI,IAAI,CAACrC,eAAe,EAAE;EAClE;EAEA1W,+BAA+BA,CAC7BzuC,IAAyB,EACJ;IAErB,IAAI,IAAI,CAACkW,KAAK,CAAA,EAAA,CAAO,IAAI,IAAI,CAACA,KAAK,CAAA,EAAA,CAAc,EAAE;MACjD,MAAM4jB,aAAa,GAAG,IAAI,CAACuoB,kBAAkB,CAAC,MAE5C,IAAI,CAACgB,gCAAgC,EAAE,CACxC;MAED,IAAIvpB,aAAa,EAAE95B,IAAI,CAACwD,cAAc,GAAGs2B,aAAa;IACxD;IACA,OAAO,KAAK,CAAC2U,+BAA+B,CAACzuC,IAAI,CAAC;EACpD;EAEAynD,iCAAiCA,CAC/BrlD,MAAsC,EAC9B;IACR,MAAMslD,SAAS,GAAG,KAAK,CAACD,iCAAiC,CAACrlD,MAAM,CAAC;IACjE,MAAMC,MAAM,GAAG,IAAI,CAACF,4BAA4B,CAACC,MAAM,CAAC;IACxD,MAAMulD,UAAU,GAAGtlD,MAAM,CAAC,CAAC,CAAC;IAC5B,MAAMulD,eAAe,GAAGD,UAAU,IAAI,IAAI,CAACvxB,WAAW,CAACuxB,UAAU,CAAC;IAElE,OAAOC,eAAe,GAAGF,SAAS,GAAG,CAAC,GAAGA,SAAS;EACpD;EAEAG,qBAAqBA,CAAAA,EAAc;IACjC,MAAM71B,KAAK,GAAG,KAAK,CAAC61B,qBAAqB,EAAE;IAC3C,MAAMx1D,IAAI,GAAG,IAAI,CAACspD,wBAAwB,EAAE;IAE5C,IAAItpD,IAAI,EAAE;MACR2/B,KAAK,CAACtG,cAAc,GAAGr5B,IAAI;MAC3B,IAAI,CAAC2V,gBAAgB,CAACgqB,KAAK,CAAC;IAC9B;IAEA,OAAOA,KAAK;EACd;EAEAywB,kBAAkBA,CAAI1B,EAAW,EAAK;IACpC,MAAM+G,mBAAmB,GAAG,IAAI,CAACjhD,KAAK,CAACmM,gBAAgB;IACvD,IAAI,CAACnM,KAAK,CAACmM,gBAAgB,GAAG,IAAI;IAClC,IAAI;MACF,OAAO+tC,EAAE,EAAE;IACb,CAAC,SAAS;MACR,IAAI,CAACl6C,KAAK,CAACmM,gBAAgB,GAAG80C,mBAAmB;IACnD;EACF;EAEAnF,UAAUA,CACR3iD,IAAe,EACf+0B,WAAoB,EACpBC,UAAoB,EACjB;IACH,MAAM+yB,kBAAkB,GAAG,IAAI,CAAClhD,KAAK,CAACoM,eAAe;IACrD,IAAI,CAACpM,KAAK,CAACoM,eAAe,GAAG,CAAC,CAAEjT,IAAI,CAAS+9C,QAAQ;IACrD,IAAI;MACF,OAAO,KAAK,CAAC4E,UAAU,CAAC3iD,IAAI,EAAE+0B,WAAW,EAAEC,UAAU,CAAC;IACxD,CAAC,SAAS;MACR,IAAI,CAACnuB,KAAK,CAACoM,eAAe,GAAG80C,kBAAkB;IACjD;EACF;EAEA7E,0BAA0BA,CACxBljD,IAAS,EACT2G,UAAgC,EACkC;IAClE,IAAI,IAAI,CAACuP,KAAK,CAAA,EAAA,CAAW,EAAE;MACzBlW,IAAI,CAAC+9C,QAAQ,GAAG,IAAI;MACpB,OAAO,IAAI,CAACiK,mBAAmB,CAC7BrhD,UAAU,EACV,IAAI,CAACg8C,UAAU,CACb3iD,IAAI,EACc,IAAI,EACL,KAAK,CACvB,CACF;IACF,CAAA,MAAM,IAAI,IAAI,CAAC0hB,YAAY,KAAe,EAAE;MAM3C,IAAI,CAAC,IAAI,CAACU,qBAAqB,EAAE,EAAE;QACjCpiB,IAAI,CAAC+9C,QAAQ,GAAG,IAAI;QACpB,IAAI,CAACh4C,KAAK,CAAC8sC,QAAQ,CAACyC,wCAAwC,EAAE;UAC5D7vD,EAAE,EAAEua;QACN,CAAC,CAAC;QACF,OAAO,IAAI,CAAC4gD,2BAA2B,CACrC5gD,IAAI,CACL;MACH;IACF,CAAC,MAAM;MACL,IAAI,CAAC7I,UAAU,CAAC,IAAI,EAAY,EAAA,CAAA;IAClC;EACF;EAEAoM,WAAWA,CAGTvD,IAAe,EACfoD,WAAoB,EACpBpB,OAAgB,EAChBqB,aAAsB,EACtBa,gBAAyB,EACzB7R,IAAe,EACf8R,YAAsB,EACtB;IACA,MAAM/B,MAAM,GAAG,KAAK,CAACmB,WAAW,CAC9BvD,IAAI,EACJoD,WAAW,EACXpB,OAAO,EACPqB,aAAa,EACba,gBAAgB,EAChB7R,IAAI,EACJ8R,YAAY,CACb;IAED,IAAI/B,MAAM,CAAC27C,QAAQ,EAAE;MACnB,MAAMkK,OAAO,GAAG,IAAI,CAAC3hD,SAAS,CAAC,QAAQ,CAAC,GAEpC,CAAC,CAAClE,MAAM,CAAC1S,KAAK,CAACsT,IAAI,GACnB,CAAC,CAACZ,MAAM,CAACY,IAAI;MACjB,IAAIilD,OAAO,EAAE;QACX,MAAM;UAAEpnE;QAAK,CAAA,GAAGuhB,MAAM;QACtB,IAAI,CAAC2D,KAAK,CAAC8sC,QAAQ,CAACC,+BAA+B,EAAE;UACnDrtD,EAAE,EAAE2c,MAAM;UACV2wC,UAAU,EACRlyD,GAAG,CAACwR,IAAI,KAAK,YAAY,IAAI,CAAC+P,MAAM,CAACkC,QAAQ,GACzCzjB,GAAG,CAAC6B,IAAI,GACP,IAAG,IAAI,CAAC+uB,KAAK,CAAC2C,KAAK,CAACvzB,GAAG,CAAC8N,KAAK,EAAE9N,GAAG,CAAC+N,GAAG,CAAE;QACjD,CAAC,CAAC;MACJ;IACF;IACA,OAAOwT,MAAM;EACf;EAEAo4C,wBAAwBA,CAAAA,EAA0B;IAChD,MAAMX,QAAsB,GAAG,IAAI,CAAC3uB,eAAe,EAAE;IACrD,OAAiD2uB,QAAQ,CAACn3D,IAAI;EAChE;EAEAwlE,2BAA2BA,CAAAA,EAAY;IACrC,OAAO,CAAC,CAAC,IAAI,CAACxkD,eAAe,CAAC,YAAY,EAAE,KAAK,CAAC;EACpD;EAEAtD,KAAKA,CAAAA,EAAG;IACN,IAAI,IAAI,CAAC8nD,2BAA2B,EAAE,EAAE;MACtC,IAAI,CAACrhD,KAAK,CAACmM,gBAAgB,GAAG,IAAI;IACpC;IACA,OAAO,KAAK,CAAC5S,KAAK,EAAE;EACtB;EAEA+nD,aAAaA,CAAAA,EAAG;IACd,IAAI,IAAI,CAACD,2BAA2B,EAAE,EAAE;MACtC,IAAI,CAACrhD,KAAK,CAACmM,gBAAgB,GAAG,IAAI;IACpC;IACA,OAAO,KAAK,CAACm1C,aAAa,EAAE;EAC9B;EAEAC,oBAAoBA,CAClBpoD,IAA+B,EAC/BqoD,QAAiB,EACjBC,cAAuB,EACvB7wB,eAAwB,EACxB;IACA,IAAI,CAAC4wB,QAAQ,IAAI5wB,eAAe,EAAE;MAChC,IAAI,CAAC8wB,kCAAkC,CACrCvoD,IAAI,EACW,KAAK,EACpBsoD,cAAc,CACf;MACD,OAAO,IAAI,CAAC/jD,UAAU,CAAoBvE,IAAI,EAAE,iBAAiB,CAAC;IACpE;IACAA,IAAI,CAAC2sB,UAAU,GAAG,OAAO;IACzB,OAAO,KAAK,CAACy7B,oBAAoB,CAC/BpoD,IAAI,EACJqoD,QAAQ,EACRC,cAAc,EACd7wB,eAAe,CAChB;EACH;EAEAH,oBAAoBA,CAClBJ,SAAoC,EACpCK,gBAAyB,EACzBC,kBAA2B,EAC3BC,eAAwB,EAExBhpB,WAAqC,EAClB;IACnB,IAAI,CAAC8oB,gBAAgB,IAAIE,eAAe,EAAE;MACxC,IAAI,CAAC8wB,kCAAkC,CACrCrxB,SAAS,EACM,IAAI,EACnBM,kBAAkB,CACnB;MACD,OAAO,IAAI,CAACjzB,UAAU,CAAoB2yB,SAAS,EAAE,iBAAiB,CAAC;IACzE;IACAA,SAAS,CAAC9N,UAAU,GAAG,OAAO;IAC9B,OAAO,KAAK,CAACkO,oBAAoB,CAC/BJ,SAAS,EACTK,gBAAgB,EAChBC,kBAAkB,EAClBC,eAAe,EACfD,kBAAkB,GAAGnrB,mBAAmB,GAAGf,oBAAoB,CAChE;EACH;EAEAi9C,kCAAkCA,CAChCvoD,IAAS,EACTwoD,QAAiB,EACjBC,wBAAiC,EAC3B;IACN,MAAMC,WAAW,GAAGF,QAAQ,GAAG,UAAU,GAAG,OAAO;IACnD,MAAMG,YAAY,GAAGH,QAAQ,GAAG,OAAO,GAAG,UAAU;IAEpD,IAAII,QAAQ,GAAG5oD,IAAI,CAAC0oD,WAAW,CAAC;IAChC,IAAIG,SAAS;IAEb,IAAIC,gBAAgB,GAAG,KAAK;IAC5B,IAAIC,iBAAiB,GAAG,IAAI;IAE5B,MAAMlqD,GAAG,GAAG+pD,QAAQ,CAAC/pD,GAAG,CAAClQ,KAAK;IAO9B,IAAI,IAAI,CAAC+yB,YAAY,CAAA,EAAA,CAAQ,EAAE;MAE7B,MAAMsnC,OAAO,GAAG,IAAI,CAAC99B,eAAe,EAAE;MACtC,IAAI,IAAI,CAACxJ,YAAY,CAAA,EAAA,CAAQ,EAAE;QAE7B,MAAMunC,QAAQ,GAAG,IAAI,CAAC/9B,eAAe,EAAE;QACvC,IAAIn+B,0BAA0B,CAAC,IAAI,CAAC8Z,KAAK,CAACxU,IAAI,CAAC,EAAE;UAE/Cy2D,gBAAgB,GAAG,IAAI;UACvBF,QAAQ,GAAGI,OAAO;UAClBH,SAAS,GAAGL,QAAQ,GAChB,IAAI,CAACt9B,eAAe,EAAE,GACtB,IAAI,CAACg+B,qBAAqB,EAAE;UAChCH,iBAAiB,GAAG,KAAK;QAC3B,CAAC,MAAM;UAELF,SAAS,GAAGI,QAAQ;UACpBF,iBAAiB,GAAG,KAAK;QAC3B;MACD,CAAA,MAAM,IAAIh8D,0BAA0B,CAAC,IAAI,CAAC8Z,KAAK,CAACxU,IAAI,CAAC,EAAE;QAEtD02D,iBAAiB,GAAG,KAAK;QACzBF,SAAS,GAAGL,QAAQ,GAChB,IAAI,CAACt9B,eAAe,EAAE,GACtB,IAAI,CAACg+B,qBAAqB,EAAE;MAClC,CAAC,MAAM;QAELJ,gBAAgB,GAAG,IAAI;QACvBF,QAAQ,GAAGI,OAAO;MACpB;IACD,CAAA,MAAM,IAAIj8D,0BAA0B,CAAC,IAAI,CAAC8Z,KAAK,CAACxU,IAAI,CAAC,EAAE;MAEtDy2D,gBAAgB,GAAG,IAAI;MACvB,IAAIN,QAAQ,EAAE;QACZI,QAAQ,GAAG,IAAI,CAAC19B,eAAe,CAAC,IAAI,CAAC;QACrC,IAAI,CAAC,IAAI,CAACxJ,YAAY,IAAQ,EAAE;UAC9B,IAAI,CAACqW,iBAAiB,CACpB6wB,QAAQ,CAAClmE,IAAI,EACbkmE,QAAQ,CAAC/pD,GAAG,CAAClQ,KAAK,EAClB,IAAI,EACJ,IAAI,CACL;QACH;MACF,CAAC,MAAM;QACLi6D,QAAQ,GAAG,IAAI,CAACM,qBAAqB,EAAE;MACzC;IACF;IACA,IAAIJ,gBAAgB,IAAIL,wBAAwB,EAAE;MAChD,IAAI,CAAC1iD,KAAK,CACRyiD,QAAQ,GACJ3V,QAAQ,CAAC2D,+BAA+B,GACxC3D,QAAQ,CAAC0D,+BAA+B,EAC5C;QAAE9wD,EAAE,EAAEoZ;MAAI,CAAC,CACZ;IACH;IAEAmB,IAAI,CAAC0oD,WAAW,CAAC,GAAGE,QAAQ;IAC5B5oD,IAAI,CAAC2oD,YAAY,CAAC,GAAGE,SAAS;IAE9B,MAAMM,OAAO,GAAGX,QAAQ,GAAG,YAAY,GAAG,YAAY;IACtDxoD,IAAI,CAACmpD,OAAO,CAAC,GAAGL,gBAAgB,GAAG,MAAM,GAAG,OAAO;IAEnD,IAAIC,iBAAiB,IAAI,IAAI,CAAC/mC,aAAa,IAAQ,EAAE;MACnDhiB,IAAI,CAAC2oD,YAAY,CAAC,GAAGH,QAAQ,GACzB,IAAI,CAACt9B,eAAe,EAAE,GACtB,IAAI,CAACg+B,qBAAqB,EAAE;IAClC;IACA,IAAI,CAAClpD,IAAI,CAAC2oD,YAAY,CAAC,EAAE;MACvB3oD,IAAI,CAAC2oD,YAAY,CAAC,GAAG5jC,eAAe,CAAC/kB,IAAI,CAAC0oD,WAAW,CAAC,CAAC;IACzD;IACA,IAAIF,QAAQ,EAAE;MACZ,IAAI,CAACvW,eAAe,CAClBjyC,IAAI,CAAC2oD,YAAY,CAAC,EAClBG,gBAAgB,GAAGz8C,mBAAmB,GAAGf,oBAAoB,CAC9D;IACH;EACF;AACF,CAAC;AAEH,SAAS89C,qBAAqBA,CAAC3nD,UAAwB,EAAW;EAChE,IAAIA,UAAU,CAACpP,IAAI,KAAK,kBAAkB,EAAE,OAAO,KAAK;EAExD,MAAM;IAAEiS,QAAQ;IAAEkf;EAAU,CAAA,GAAG/hB,UAAU;EAEzC,IACE6C,QAAQ,IACRkf,QAAQ,CAACnxB,IAAI,KAAK,eAAe,KAChCmxB,QAAQ,CAACnxB,IAAI,KAAK,iBAAiB,IAAImxB,QAAQ,CAAC6lC,WAAW,CAACj7D,MAAM,GAAG,CAAC,CAAC,EACxE;IACA,OAAO,KAAK;EACd;EAEA,OAAOk7D,iCAAiC,CAAC7nD,UAAU,CAAChS,MAAM,CAAC;AAC7D;AAQA,SAAS81D,8BAA8BA,CACrC9jD,UAAwB,EACxBxB,MAAe,EACN;EAAA,IAAA+xC,iBAAA;EACT,MAAM;IAAE3/C;EAAM,CAAA,GAAGoP,UAAU;EAC3B,IAAAuwC,CAAAA,iBAAA,GAAIvwC,UAAU,CAACE,KAAK,KAAhBqwC,IAAAA,IAAAA,iBAAA,CAAkBxvC,aAAa,EAAE;IACnC,OAAO,KAAK;EACd;EACA,IAAIvC,MAAM,EAAE;IACV,IAAI5N,IAAI,KAAK,SAAS,EAAE;MACtB,MAAM;QAAE3C;MAAO,CAAA,GAAG+R,UAAU;MAC5B,IAAI,OAAO/R,KAAK,KAAK,QAAQ,IAAI,OAAOA,KAAK,KAAK,SAAS,EAAE;QAC3D,OAAO,IAAI;MACb;IACF;EACF,CAAC,MAAM;IACL,IAAI2C,IAAI,KAAK,eAAe,IAAIA,IAAI,KAAK,gBAAgB,EAAE;MACzD,OAAO,IAAI;IACb;EACF;EACA,IAAIk3D,QAAQ,CAAC9nD,UAAU,EAAExB,MAAM,CAAC,IAAIupD,gBAAgB,CAAC/nD,UAAU,EAAExB,MAAM,CAAC,EAAE;IACxE,OAAO,IAAI;EACb;EACA,IAAI5N,IAAI,KAAK,iBAAiB,IAAIoP,UAAU,CAAC4nD,WAAW,CAACj7D,MAAM,KAAK,CAAC,EAAE;IACrE,OAAO,IAAI;EACb;EACA,IAAIg7D,qBAAqB,CAAC3nD,UAAU,CAAC,EAAE;IACrC,OAAO,IAAI;EACb;EACA,OAAO,KAAK;AACd;AAEA,SAAS8nD,QAAQA,CAAC9nD,UAAwB,EAAExB,MAAe,EAAW;EACpE,IAAIA,MAAM,EAAE;IACV,OACEwB,UAAU,CAACpP,IAAI,KAAK,SAAS,KAC5B,OAAOoP,UAAU,CAAC/R,KAAK,KAAK,QAAQ,IAAI,QAAQ,IAAI+R,UAAU,CAAC;EAEpE,CAAC,MAAM;IACL,OACEA,UAAU,CAACpP,IAAI,KAAK,gBAAgB,IACpCoP,UAAU,CAACpP,IAAI,KAAK,eAAe;EAEvC;AACF;AAEA,SAASm3D,gBAAgBA,CAAC/nD,UAAwB,EAAExB,MAAe,EAAW;EAC5E,IAAIwB,UAAU,CAACpP,IAAI,KAAK,iBAAiB,EAAE;IACzC,MAAM;MAAEi+C,QAAQ;MAAEnxC;IAAU,CAAA,GAAGsC,UAA+B;IAC9D,IAAI6uC,QAAQ,KAAK,GAAG,IAAIiZ,QAAQ,CAACpqD,QAAQ,EAAEc,MAAM,CAAC,EAAE;MAClD,OAAO,IAAI;IACb;EACF;EACA,OAAO,KAAK;AACd;AAEA,SAASqpD,iCAAiCA,CAAC7nD,UAAwB,EAAW;EAC5E,IAAIA,UAAU,CAACpP,IAAI,KAAK,YAAY,EAAE,OAAO,IAAI;EACjD,IAAIoP,UAAU,CAACpP,IAAI,KAAK,kBAAkB,EAAE,OAAO,KAAK;EACxD,IAAIoP,UAAU,CAAC6C,QAAQ,EAAE,OAAO,KAAK;EAErC,OAAOglD,iCAAiC,CAAC7nD,UAAU,CAAChS,MAAM,CAAC;AAC7D;ACtoIA,MAAMg6D,iBAAiB,GAAGvqD,cAAe,cAAa,CAAC;EACrDwqD,mBAAmB,EAAE,2BAA2B;EAChDC,eAAe,EAAE;AACnB,CAAC,CAAC;AAIF,IAAAC,YAAA,GAAgB1pD,UAAyB,IACvC,MAAM2pD,uBAAuB,SAAS3pD,UAAU,CAAmB;EACjE4pD,gBAAgBA,CACd5kC,YAAe,EAC+C;IAC9D,IAAI,IAAI,CAAChP,KAAK,CAAA,GAAA,CAAgB,EAAE;MAC9B,MAAMlW,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAE;MAC7B,IAAI,CAACuF,IAAI,EAAE;MACX,IAAI,CAACmgD,aAAa,EAAE;MAIpB/pD,IAAI,CAACtd,IAAI,GAAG,KAAK,CAACwoC,eAAe,CAAe,IAAI,CAAC;MAErD,IAAI,CAAC6+B,aAAa,EAAE;MACpB,IAAI,CAACvnC,MAAM,CAAgB,GAAA,CAAA;MAE3B,OAAO,IAAI,CAACwnC,iBAAiB,CAAChqD,IAAI,EAAEklB,YAAY,CAAC;IACnD;EACF;EAEA8kC,iBAAiBA,CACfhqD,IAAY,EACZklB,YAAe,EAC2B;IAC1C,MAAM+kC,UAAU,GAAG,CAAC,EAAEjqD,IAAI,CAACklB,YAAY,IAAIllB,IAAI,CAAC3N,IAAI,KAAK,aAAa,CAAC;IACvE2N,IAAI,CAACklB,YAAY,GAAGA,YAAY;IAGhC,OAAO+kC,UAAU,GAAGjqD,IAAI,GAAG,IAAI,CAACuE,UAAU,CAACvE,IAAI,EAAE,aAAa,CAAC;EACjE;EAMA+Z,gBAAgBA,CAACppB,IAAY,EAAE;IAC7B,IACEA,IAAI,KAA0B,EAAA,IAC9B,IAAI,CAAC8gB,KAAK,CAACC,UAAU,CAAC,IAAI,CAAC7K,KAAK,CAAC5H,GAAG,GAAG,CAAC,CAAC,OAA0B,EACnE;MACA,IAAI,CAAC4b,QAAQ,CAAiB,GAAA,EAAA,CAAC,CAAC;IAClC,CAAC,MAAM;MACL,KAAK,CAACd,gBAAgB,CAACppB,IAAI,CAAC;IAC9B;EACF;EAMA07B,aAAaA,CACXlnB,mBAA6C,EACb;IAChC,OACE,IAAI,CAAC2kD,gBAAgB,CAAC,YAAY,CAAC,IACnC,KAAK,CAACz9B,aAAa,CAAClnB,mBAAmB,CAAC;EAE5C;EAEA+lB,eAAeA,CAAC+C,OAAiB,EAAkC;IAKjE,OACE,IAAI,CAAC67B,gBAAgB,CAAC,YAAY,CAAC,IAAI,KAAK,CAAC5+B,eAAe,CAAC+C,OAAO,CAAC;EAEzE;EAEA8J,iBAAiBA,CACf5uB,IAAY,EACZjE,QAAkB,EAClB6/C,aAAsB,EACtBv/C,SAAkB,EAClB;IAIA,IAAI2D,IAAI,KAAK3pB,SAAS,EAAE;MACtB,KAAK,CAACu4C,iBAAiB,CAAC5uB,IAAI,EAAEjE,QAAQ,EAAE6/C,aAAa,EAAEv/C,SAAS,CAAC;IACnE;EACF;EAMAwyB,gBAAgBA,CAAAA,EAAgC;IAC9C,OAAO,IAAI,CAAC8xB,gBAAgB,CAAC,SAAS,CAAC,IAAI,KAAK,CAAC9xB,gBAAgB,EAAE;EACrE;EAEA5yB,WAAWA,CAAC/S,IAAY,EAAE2jC,eAAwB,EAAE1wB,OAAqB,EAAE;IACzE,OACEjT,IAAI,KAAK,aAAa,IACtB,KAAK,CAAC+S,WAAW,CAAC/S,IAAI,EAAE2jC,eAAe,EAAE1wB,OAAO,CAAC;EAErD;EAEAG,YAAYA,CAACzF,IAAY,EAAE0F,KAAc,EAAQ;IAC/C,IACE1F,IAAI,IACJA,IAAI,CAAC3N,IAAI,KAAK,aAAa,IAC3B2N,IAAI,CAACklB,YAAY,KAAK,YAAY,EAClC;MACAllB,IAAI,CAACklB,YAAY,GAAG,SAAS;IAC/B,CAAC,MAAM;MACL,KAAK,CAACzf,YAAY,CAACzF,IAAI,EAAE0F,KAAK,CAAC;IACjC;EACF;EAMAwkD,yBAAyBA,CAACv1C,EAAU,EAAE1V,GAAW,EAAW;IAC1D,IAAI,KAAK,CAACirD,yBAAyB,CAACv1C,EAAE,EAAE1V,GAAG,CAAC,EAAE;MAC5C,OAAO,IAAI;IACb;IAIA,MAAMuZ,SAAS,GAAG,IAAI,CAACI,SAAS,EAAE;IAClC,IAAIJ,SAAS,CAACnmB,IAAI,KAAA,GAAmB,EAAE;MACrC,OAAO,IAAI;IACb;IAEA,OAAO,KAAK;EACd;EAEA83D,mBAAmBA,CACjBnqD,IAA4C,EAC5CoqD,OAAgB,EAChB;IAEA,IAAIpqD,IAAI,CAAC/d,KAAK,IAAI+d,IAAI,CAAC/d,KAAK,CAACoQ,IAAI,KAAK,aAAa,EAAE;IACrD,KAAK,CAAC83D,mBAAmB,CAACnqD,IAAI,EAAEoqD,OAAO,CAAC;EAC1C;EAGA13B,wBAAwBA,CACtB1yB,IAAmC,EACnC2yB,IAAkB,EACa;IAC/B,IACEA,IAAI,CAACtgC,IAAI,KAAK,aAAa,IAC1BsgC,IAAI,CAAChxB,KAAK,IAAIgxB,IAAI,CAAChxB,KAAK,CAACa,aAAc,EACxC;MAEA,OAAO,KAAK,CAACkwB,wBAAwB,CAAC1yB,IAAI,EAAE2yB,IAAI,CAAC;IACnD;IAEA,IAAI,IAAI,CAACzc,KAAK,CAAA,EAAA,CAAU,EAAE;MAExB,MAAMrU,IAAwB,GAAG7B,IAAI;MACrC6B,IAAI,CAAC5f,KAAK,GAAG,IAAI,CAAC+nE,iBAAiB,CAACr3B,IAAI,EAAE,YAAY,CAAC;MACvD,IAAI,CAAC/oB,IAAI,EAAE;MACX/H,IAAI,CAACmB,IAAI,GAAG,KAAK,CAACqnD,+CAA+C,EAAE;MACnE,OAAO,IAAI,CAAC9lD,UAAU,CAAC1C,IAAI,EAAE,kBAAkB,CAAC;IAClD;IAEA,IAAI,CAACygB,SAAS,EAAE;IAChBtiB,IAAI,CAACtd,IAAI,GAAGiwC,IAAI,CAACjwC,IAAI;IACrB,OAAO,IAAI,CAACsnE,iBAAiB,CAAChqD,IAAI,EAAE,WAAW,CAAC;EAClD;EAEAsqD,UAAUA,CACR5nD,eAAyB,EACzB6nD,qBAA+B,EAC/B3nD,eAA2D,EACvB;IACpC,OACE,IAAI,CAACknD,gBAAgB,CAAC,gBAAgB,CAAC,IACvC,KAAK,CAACQ,UAAU,CACd5nD,eAAe,EACf6nD,qBAAqB,EACrB3nD,eAAe,CAChB;EAEL;EAEA4nD,eAAeA,CACbC,SAAmB,EACgC;IACnD,OACE,IAAI,CAACX,gBAAgB,CAAC,YAAY,CAAC,IAAI,KAAK,CAACU,eAAe,CAACC,SAAS,CAAC;EAE3E;EAEA9H,UAAUA,CACR3iD,IAAO,EACP+0B,WAAiD,EACjDC,UAAoB,EACjB;IACH,MAAM3iC,IAAI,GAAG0iC,WAAW,GAAG,kBAAkB,GAAG,iBAAiB;IAEjE,IAAI,CAACnrB,IAAI,EAAE;IACX,MAAM8gD,SAAS,GAAG,IAAI,CAAC7jD,KAAK,CAACiC,MAAM;IAEnC,MAAMlc,WAAW,GAAG,IAAI,CAACk9D,gBAAgB,CAAC,YAAY,CAAC;IACvD,IAAIl9D,WAAW,EAAE;MACf,IACE,IAAI,CAACspB,KAAK,CAAA,EAAA,CAAa,IACvB,IAAI,CAACA,KAAK,CAAA,GAAA,CAAgB,IAC1B,IAAI,CAACA,KAAK,GAAW,EACrB;QACAlW,IAAI,CAAC6D,EAAE,GAAGjX,WAAW;MACvB,CAAC,MAAM,IAAIooC,UAAU,IAAI,CAACD,WAAW,EAAE;QACrC/0B,IAAI,CAAC6D,EAAE,GAAG,IAAI;QACd7D,IAAI,CAACgD,IAAI,GAAG,IAAI,CAACgnD,iBAAiB,CAACp9D,WAAW,EAAE,WAAW,CAAC;QAC5D,OAAO,IAAI,CAAC2X,UAAU,CAACvE,IAAI,EAAE3N,IAAI,CAAC;MACpC,CAAC,MAAM;QACL,MAAM,IAAI,CAAC0T,KAAK,CAAC0jD,iBAAiB,CAACC,mBAAmB,EAAE;UACtDjkE,EAAE,EAAE,IAAI,CAACohB,KAAK,CAAC3B;QACjB,CAAC,CAAC;MACJ;IACF,CAAC,MAAM;MACL,IAAI,CAAC4vB,YAAY,CAAC90B,IAAI,EAAE+0B,WAAW,EAAEC,UAAU,CAAC;IAClD;IAEA,KAAK,CAACsB,eAAe,CAACt2B,IAAI,CAAC;IAC3BA,IAAI,CAACgD,IAAI,GACP,IAAI,CAAC8mD,gBAAgB,CAAC,WAAW,CAAC,IAClC,KAAK,CAACa,cAAc,CAAC,CAAC,CAAC3qD,IAAI,CAACE,UAAU,EAAEwqD,SAAS,CAAC;IACpD,OAAO,IAAI,CAACnmD,UAAU,CAACvE,IAAI,EAAE3N,IAAI,CAAC;EACpC;EAEAqU,WAAWA,CAAC1G,IAAY,EAAE2G,UAAgC,EAAe;IACvE,MAAM/Z,WAAW,GAAG,IAAI,CAACk9D,gBAAgB,CAAC,YAAY,CAAC;IACvD,IAAI,CAACl9D,WAAW,EAAE,OAAO,KAAK,CAAC8Z,WAAW,CAAC1G,IAAI,EAAE2G,UAAU,CAAC;IAE5D,IAAI,CAAC,IAAI,CAAC+a,YAAY,CAAA,EAAA,CAAU,IAAI,CAAC,IAAI,CAACxL,KAAK,CAAA,EAAA,CAAU,EAAE;MAEzDlW,IAAI,CAACgH,UAAU,GAAG,EAAE;MACpBhH,IAAI,CAACoG,MAAM,GAAG,IAAI;MAClBpG,IAAI,CAACkH,WAAW,GAAG,IAAI,CAAC8iD,iBAAiB,CAACp9D,WAAW,EAAE,aAAa,CAAC;MACrE,OAAO,IAAI,CAAC2X,UAAU,CAACvE,IAAI,EAAE,wBAAwB,CAAC;IACxD;IAGA,IAAI,CAAC2a,YAAY,CAAC,mBAAmB,CAAC;IACtC,MAAMuc,SAAS,GAAG,IAAI,CAAC7yB,SAAS,EAAE;IAClC6yB,SAAS,CAACnwB,QAAQ,GAAGna,WAAW;IAChCoT,IAAI,CAACgH,UAAU,GAAG,CAAC,IAAI,CAACzC,UAAU,CAAC2yB,SAAS,EAAE,wBAAwB,CAAC,CAAC;IAExE,OAAO,KAAK,CAACxwB,WAAW,CAAC1G,IAAI,EAAE2G,UAAU,CAAC;EAC5C;EAEAksB,wBAAwBA,CAAAA,EAAY;IAClC,IAAI,IAAI,CAAC3c,KAAK,CAAA,EAAA,CAAa,EAAE;MAC3B,MAAMtM,IAAI,GAAG,IAAI,CAACmP,cAAc,EAAE;MAClC,IAAI,IAAI,CAAC4I,oBAAoB,CAAC/X,IAAI,EAAE,MAAM,CAAC,EAAE;QAC3C,IACE,IAAI,CAAC6H,KAAK,CAACm5C,UAAU,CACnBh9D,cAAc,CAAgB,GAAA,CAAA,EAC9B,IAAI,CAACorB,mBAAmB,CAACpP,IAAI,GAAG,CAAC,CAAC,CACnC,EACD;UACA,OAAO,IAAI;QACb;MACF;IACF;IACA,OAAO,KAAK,CAACipB,wBAAwB,EAAE;EACzC;EAEAg4B,gCAAgCA,CAAC7qD,IAAY,EAAW;IACtD,IAAIA,IAAI,CAACgH,UAAU,IAAIhH,IAAI,CAACgH,UAAU,CAAC5Y,MAAM,GAAG,CAAC,EAAE;MAEjD,OAAO,IAAI;IACb;IACA,OAAO,KAAK,CAACy8D,gCAAgC,CAAC7qD,IAAI,CAAC;EACrD;EAEA8qD,WAAWA,CAAC9qD,IAA8B,EAAQ;IAChD,MAAM;MAAEgH;IAAY,CAAA,GAAGhH,IAAI;IAC3B,IAAIgH,UAAU,IAAA,IAAA,IAAVA,UAAU,CAAE5Y,MAAM,EAAE;MACtB4R,IAAI,CAACgH,UAAU,GAAGA,UAAU,CAAC/W,MAAM,CAEjC+P,IAAI,IAAIA,IAAI,CAAC+G,QAAQ,CAAC1U,IAAI,KAAK,aAAa,CAC7C;IACH;IACA,KAAK,CAACy4D,WAAW,CAAC9qD,IAAI,CAAC;IACvBA,IAAI,CAACgH,UAAU,GAAGA,UAAU;EAC9B;EAEAulB,WAAWA,CACTvsB,IAAiC,EACkB;IACnD,MAAMpT,WAAW,GAAG,IAAI,CAACk9D,gBAAgB,CAAC,YAAY,CAAC;IACvD,IAAI,CAACl9D,WAAW,EAAE,OAAO,KAAK,CAAC2/B,WAAW,CAACvsB,IAAI,CAAC;IAEhDA,IAAI,CAACgH,UAAU,GAAG,EAAE;IAEpB,IAAI,CAAC,IAAI,CAAC0a,YAAY,CAAA,EAAA,CAAU,IAAI,CAAC,IAAI,CAACxL,KAAK,CAAA,EAAA,CAAU,EAAE;MAEzDlW,IAAI,CAACoG,MAAM,GAAG,IAAI,CAAC4jD,iBAAiB,CAACp9D,WAAW,EAAE,eAAe,CAAC;MAClE,IAAI,CAAC01B,SAAS,EAAE;MAChB,OAAO,IAAI,CAAC/d,UAAU,CAACvE,IAAI,EAAE,mBAAmB,CAAC;IACnD;IAGA,MAAMk3B,SAAS,GACb,IAAI,CAACvvB,eAAe,CAA2B/a,WAAW,CAAC;IAC7DsqC,SAAS,CAACC,KAAK,GAAGvqC,WAAW;IAC7BoT,IAAI,CAACgH,UAAU,CAACvjB,IAAI,CAClB,IAAI,CAAC8gB,UAAU,CAAC2yB,SAAS,EAAE,wBAAwB,CAAC,CACrD;IAED,IAAI,IAAI,CAACze,GAAG,CAAA,EAAA,CAAU,EAAE;MAEtB,MAAMsyC,aAAa,GAAG,IAAI,CAACC,6BAA6B,CAAChrD,IAAI,CAAC;MAG9D,IAAI,CAAC+qD,aAAa,EAAE,IAAI,CAACE,0BAA0B,CAACjrD,IAAI,CAAC;IAC3D;IAEA,IAAI,CAACiiB,gBAAgB,CAAU,EAAA,CAAA;IAC/BjiB,IAAI,CAACoG,MAAM,GAAG,IAAI,CAAC8kD,iBAAiB,EAAE;IACtC,IAAI,CAAC5oC,SAAS,EAAE;IAChB,OAAO,IAAI,CAAC/d,UAAU,CAACvE,IAAI,EAAE,mBAAmB,CAAC;EACnD;EAEAkrD,iBAAiBA,CAAAA,EAAsC;IAGrD,OACE,IAAI,CAACpB,gBAAgB,CAAC,eAAe,CAAC,IAAI,KAAK,CAACoB,iBAAiB,EAAE;EAEvE;EAGAnB,aAAaA,CAAAA,EAAS;IACpB,IAAI,IAAI,CAACljD,KAAK,CAAClY,KAAK,GAAG,IAAI,CAACkY,KAAK,CAACoB,aAAa,CAACzZ,KAAK,EAAE;MACrD,IAAI,CAACuX,KAAK,CAAC0jD,iBAAiB,CAACE,eAAe,EAAE;QAC5ClkE,EAAE,EAAE,IAAI,CAACohB,KAAK,CAACoB;MACjB,CAAC,CAAC;IACJ;EACF;AACF,CAAC;ACpXH,IAAAkjD,WAAA,GAAgBjrD,UAAyB,IACvC,MAAMkrD,gBAAgB,SAASlrD,UAAU,CAAmB;EAC1DmrD,gBAAgBA,CAAAA,EAAiB;IAC/B,IAAI,IAAI,CAACn1C,KAAK,CAAA,EAAA,CAAW,EAAE;MACzB,MAAMo1C,mBAAmB,GAAG,IAAI,CAACzkD,KAAK,CAAC3B,QAAQ;MAE/C,MAAMlF,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAgB;MAC3C,IAAI,CAACuF,IAAI,EAAE;MACX,IAAI/c,iBAAiB,CAAC,IAAI,CAACga,KAAK,CAACxU,IAAI,CAAC,EAAE;QACtC,MAAM3P,IAAI,GAAG,IAAI,CAAC6oE,mBAAmB,EAAE;QACvC,MAAM/Y,UAAU,GAAG,IAAI,CAAC/gB,gBAAgB,CAACzxB,IAAI,EAAEtd,IAAI,CAAC;QAEpD8vD,UAAU,CAACngD,IAAI,GAAG,uBAAuB;QACzC,IAAI,IAAI,CAAC6jB,KAAK,CAAA,EAAA,CAAW,EAAE;UACzB,OAAOs8B,UAAU;QACnB;MACF;MACA,IAAI,CAACr7C,UAAU,CAACm0D,mBAAmB,CAAC;IACtC;EACF;EAMAj/B,aAAaA,CAAClnB,mBAA6C,EAAgB;IACzE,OACE,IAAI,CAACkmD,gBAAgB,EAAE,IAAI,KAAK,CAACh/B,aAAa,CAAClnB,mBAAmB,CAAC;EAEvE;AACF,CAAC;ACfI,SAASmB,SAASA,CACvBrmB,OAAmB,EACnBurE,cAA4B,EACnB;EAIT,MAAM,CAACC,YAAY,EAAEC,eAAe,CAAC,GACnC,OAAOF,cAAc,KAAK,QAAQ,GAAG,CAACA,cAAc,EAAE,EAAE,CAAC,GAAGA,cAAc;EAE5E,MAAMG,YAAY,GAAG7qE,MAAM,CAACC,IAAI,CAAC2qE,eAAe,CAAC;EAEjD,MAAME,sBAAsB,GAAGD,YAAY,CAACv9D,MAAM,KAAK,CAAC;EAExD,OAAOnO,OAAO,CAACi+B,IAAI,CAAC2tC,CAAC,IAAI;IACvB,IAAI,OAAOA,CAAC,KAAK,QAAQ,EAAE;MACzB,OAAOD,sBAAsB,IAAIC,CAAC,KAAKJ,YAAY;IACrD,CAAC,MAAM;MACL,MAAM,CAACh8C,UAAU,EAAEC,aAAa,CAAC,GAAGm8C,CAAC;MACrC,IAAIp8C,UAAU,KAAKg8C,YAAY,EAAE;QAC/B,OAAO,KAAK;MACd;MACA,KAAK,MAAM5qE,GAAG,IAAI8qE,YAAY,EAAE;QAE9B,IAAIj8C,aAAa,CAAC7uB,GAAG,CAAC,KAAK6qE,eAAe,CAAC7qE,GAAG,CAAC,EAAE;UAC/C,OAAO,KAAK;QACd;MACF;MACA,OAAO,IAAI;IACb;EACF,CAAC,CAAC;AACJ;AAEO,SAAS6iB,eAAeA,CAG7BzjB,OAAmB,EAAEyC,IAAgB,EAAEopE,MAAkB,EAAE;EAC3D,MAAMl8C,MAAM,GAAG3vB,OAAO,CAAC8rE,IAAI,CAACn8C,MAAM,IAAI;IACpC,IAAIvQ,KAAK,CAACC,OAAO,CAACsQ,MAAM,CAAC,EAAE;MACzB,OAAOA,MAAM,CAAC,CAAC,CAAC,KAAKltB,IAAI;IAC3B,CAAC,MAAM;MACL,OAAOktB,MAAM,KAAKltB,IAAI;IACxB;EACF,CAAC,CAAC;EAEF,IAAIktB,MAAM,IAAIvQ,KAAK,CAACC,OAAO,CAACsQ,MAAM,CAAC,IAAIA,MAAM,CAACxhB,MAAM,GAAG,CAAC,EAAE;IACxD,OAAQwhB,MAAM,CAAC,CAAC,CAAC,CAA+Bk8C,MAAM,CAAC;EACzD;EAEA,OAAO,IAAI;AACb;AAEA,MAAME,kBAAkB,GAAG,CAAC,SAAS,EAAE,QAAQ,EAAE,MAAM,EAAE,OAAO,CAAC;AACjE,MAAMC,YAAY,GAAG,CAAC,IAAI,EAAE,IAAI,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;AAChD,MAAMC,6BAA6B,GAAG,CAAC,MAAM,EAAE,KAAK,CAAC;AAE9C,SAASC,eAAeA,CAAClsE,OAAmB,EAAE;EACnD,IAAIqmB,SAAS,CAACrmB,OAAO,EAAE,YAAY,CAAC,EAAE;IACpC,IAAIqmB,SAAS,CAACrmB,OAAO,EAAE,mBAAmB,CAAC,EAAE;MAC3C,MAAM,IAAIU,KAAK,CACb,iEAAiE,CAClE;IACH;IAEA,MAAMyrE,sBAAsB,GAAG1oD,eAAe,CAC5CzjB,OAAO,EACP,YAAY,EACZ,wBAAwB,CACzB;IACD,IACEmsE,sBAAsB,IAAI,IAAI,IAC9B,OAAOA,sBAAsB,KAAK,SAAS,EAC3C;MACA,MAAM,IAAIzrE,KAAK,CACb,2DAA2D,CAC5D;IACH;IAEA,MAAM0rE,sBAAsB,GAAG3oD,eAAe,CAC5CzjB,OAAO,EACP,YAAY,EACZ,wBAAwB,CACzB;IACD,IACEosE,sBAAsB,IAAI,IAAI,IAC9B,OAAOA,sBAAsB,KAAK,SAAS,EAC3C;MACA,MAAM,IAAI1rE,KAAK,CAAC,6CAA6C,CAAC;IAChE;EACF;EAEA,IAAI2lB,SAAS,CAACrmB,OAAO,EAAE,MAAM,CAAC,IAAIqmB,SAAS,CAACrmB,OAAO,EAAE,YAAY,CAAC,EAAE;IAClE,MAAM,IAAIU,KAAK,CAAC,6CAA6C,CAAC;EAChE;EAEA,IAAI2lB,SAAS,CAACrmB,OAAO,EAAE,cAAc,CAAC,IAAIqmB,SAAS,CAACrmB,OAAO,EAAE,aAAa,CAAC,EAAE;IAC3E,MAAM,IAAIU,KAAK,CAAC,sDAAsD,CAAC;EACzE;EAEA,IAAI2lB,SAAS,CAACrmB,OAAO,EAAE,kBAAkB,CAAC,EAAE;IAC1C,MAAMo7B,QAAQ,GAAG3X,eAAe,CAACzjB,OAAO,EAAE,kBAAkB,EAAE,UAAU,CAAC;IAEzE,IAAI,CAAC+rE,kBAAkB,CAACvvC,QAAQ,CAACpB,QAAQ,CAAC,EAAE;MAC1C,MAAMixC,YAAY,GAAGN,kBAAkB,CAACh8D,GAAG,CAAC67D,CAAC,IAAQA,IAAAA,IAAI,CAAC,CAACxzD,IAAI,CAAC,IAAI,CAAC;MACrE,MAAM,IAAI1X,KAAK,CACgE2rE,6EAAAA,eAAe,CAC7F;IACH;IAEA,MAAMC,iBAAiB,GAAGjmD,SAAS,CAACrmB,OAAO,EAAE,CAC3C,gBAAgB,EAChB;MAAEusE,UAAU,EAAE;IAAQ,CAAA,CACvB,CAAC;IAEF,IAAInxC,QAAQ,KAAK,MAAM,EAAE;MACvB,IAAI/U,SAAS,CAACrmB,OAAO,EAAE,cAAc,CAAC,EAAE;QACtC,MAAM,IAAIU,KAAK,CACb,0DAA0D,CAC3D;MACH;MAEA,IAAI2lB,SAAS,CAACrmB,OAAO,EAAE,aAAa,CAAC,EAAE;QACrC,MAAM,IAAIU,KAAK,CACb,yDAAyD,CAC1D;MACH;MAEA,MAAM26B,UAAU,GAAG5X,eAAe,CAChCzjB,OAAO,EACP,kBAAkB,EAClB,YAAY,CACb;MAED,IAAI,CAACgsE,YAAY,CAACxvC,QAAQ,CAACnB,UAAU,CAAC,EAAE;QACtC,MAAMmxC,SAAS,GAAGR,YAAY,CAACj8D,GAAG,CAAC4vD,CAAC,IAAQA,IAAAA,IAAI,CAAC,CAACvnD,IAAI,CAAC,IAAI,CAAC;QAE5D,MAAM,IAAI1X,KAAK,CACoG8rE,iHAAAA,YAAY,CAC9H;MACH;MAEA,IAAInxC,UAAU,KAAK,GAAG,IAAIixC,iBAAiB,EAAE;QAC3C,MAAM,IAAI5rE,KAAK,CACb,wIAAwI,CACzI;MACH;IACF,CAAC,MAAM,IAAI06B,QAAQ,KAAK,OAAO,IAAIkxC,iBAAiB,EAAE;MACpD,MAAM,IAAI5rE,KAAK,CACb,wHAAwH,CACzH;IACH;EACF;EAEA,IAAI2lB,SAAS,CAACrmB,OAAO,EAAE,kBAAkB,CAAC,EAAE;IAKnC;MACL,IAAIqmB,SAAS,CAACrmB,OAAO,EAAE,kBAAkB,CAAC,EAAE;QAC1C,MAAM,IAAIU,KAAK,CACb,+DAA+D,CAChE;MACH;MACA,MAAM+rE,mCAAmC,GAAGhpD,eAAe,CACzDzjB,OAAO,EACP,kBAAkB,EAClB,SAAS,CACV;MACD,IAAIysE,mCAAmC,KAAK,UAAU,EAAE;QACtD,MAAM,IAAI/rE,KAAK,CACb,4DAA4D,GAC1D,wDAAwD,GACxD,sCAAsC,CACzC;MACH;IACF;EACF;EAEA,IACE2lB,SAAS,CAACrmB,OAAO,EAAE,gBAAgB,CAAC,IACpCyjB,eAAe,CAACzjB,OAAO,EAAE,gBAAgB,EAAE,YAAY,CAAC,IAAI,IAAI,IAChE,CAACisE,6BAA6B,CAACzvC,QAAQ,CACrC/Y,eAAe,CAACzjB,OAAO,EAAE,gBAAgB,EAAE,YAAY,CAAC,CACzD,EACD;IACA,MAAM,IAAIU,KAAK,CACb,yEAAyE,GACvEurE,6BAA6B,CAACl8D,GAAG,CAAC67D,CAAC,IAAQA,IAAAA,IAAI,CAAC,CAACxzD,IAAI,CAAC,IAAI,CAAC,CAC9D;EACH;EAEA,IACEiO,SAAS,CAACrmB,OAAO,EAAE,oBAAoB,CAAC,IACxC,CAACqmB,SAAS,CAACrmB,OAAO,EAAE,eAAe,CAAC,EACpC;IACA,MAAM69B,KAAK,GAAG,IAAIn9B,KAAK,CACrB,8FAA8F,CAC/F;IAEDm9B,KAAK,CAAC6uC,cAAc,GAAG,eAAe;IACtC,MAAM7uC,KAAK;EACb;AACF;AAYO,MAAM8uC,YAAY,GAAG;EAC1B3sD,MAAM;EACNu4B,GAAG;EACHzO,IAAI;EACJotB,UAAU;EACVgU,WAAW;EACXvB;AACF,CAAC;AAEM,MAAMiD,gBAAgB,GAAG/rE,MAAM,CAACC,IAAI,CAAC6rE,YAAY,CAEvD;ACxKc,MAAeE,gBAAgB,SAAS3c,UAAU,CAAC;EAuChE4c,UAAUA,CACRloD,IAAsC,EACtCmoD,QAAoC,EACpCC,QAEC,EACD9nD,mBAA6C,EACvC;IACN,IACEN,IAAI,CAACxS,IAAI,KAAK,eAAe,IAC7B,IAAI,CAACwV,cAAc,CAAChD,IAAI,CAAC,IACzBA,IAAI,CAACP,QAAQ,IAEbO,IAAI,CAACG,SAAS,EACd;MACA;IACF;IAEA,MAAMnkB,GAAG,GAAGgkB,IAAI,CAAChkB,GAAG;IAEpB,MAAM6B,IAAI,GAAG7B,GAAG,CAACwR,IAAI,KAAK,YAAY,GAAGxR,GAAG,CAAC6B,IAAI,GAAG7B,GAAG,CAAC6O,KAAK;IAE7D,IAAIhN,IAAI,KAAK,WAAW,EAAE;MACxB,IAAIsqE,QAAQ,EAAE;QACZ,IAAI,CAACjnD,KAAK,CAAClG,MAAM,CAAC5F,aAAa,EAAE;UAAExU,EAAE,EAAE5E;QAAI,CAAC,CAAC;QAC7C;MACF;MACA,IAAIosE,QAAQ,CAACC,IAAI,EAAE;QACjB,IAAI/nD,mBAAmB,EAAE;UAGvB,IAAIA,mBAAmB,CAACge,cAAc,KAAK,IAAI,EAAE;YAC/Che,mBAAmB,CAACge,cAAc,GAAGtiC,GAAG,CAACge,GAAG,CAAClQ,KAAK;UACpD;QACF,CAAC,MAAM;UACL,IAAI,CAACoX,KAAK,CAAClG,MAAM,CAACrL,cAAc,EAAE;YAAE/O,EAAE,EAAE5E;UAAI,CAAC,CAAC;QAChD;MACF;MAEAosE,QAAQ,CAACC,IAAI,GAAG,IAAI;IACtB;EACF;EAEAC,oBAAoBA,CAACx6B,IAAkB,EAAElgB,gBAAwB,EAAW;IAC1E,OACEkgB,IAAI,CAACtgC,IAAI,KAAK,yBAAyB,IAAIsgC,IAAI,CAAChkC,KAAK,KAAK8jB,gBAAgB;EAE9E;EAGA01C,aAAaA,CAAAA,EAA8C;IACzD,IAAI,CAAC/jC,kBAAkB,EAAE;IACzB,IAAI,CAAC5L,SAAS,EAAE;IAChB,MAAMma,IAAI,GAAG,IAAI,CAAC/H,eAAe,EAAE;IACnC,IAAI,CAAC,IAAI,CAAC1U,KAAK,KAAQ,EAAE;MACvB,IAAI,CAAC/e,UAAU,EAAE;IACnB;IAGA,IAAI,CAACwa,yBAAyB,EAAE;IAChCghB,IAAI,CAAC5iB,QAAQ,GAAG,IAAI,CAAClJ,KAAK,CAACkJ,QAAQ;IACnC4iB,IAAI,CAACngB,MAAM,GAAG,IAAI,CAAC3L,KAAK,CAAC2L,MAAM;IAC/B,IAAI,IAAI,CAAC5xB,OAAO,CAACR,MAAM,EAAE;MACvBuyC,IAAI,CAACvyC,MAAM,GAAG,IAAI,CAACA,MAAM;IAC3B;IAEA,OAAOuyC,IAAI;EACb;EAqBA/H,eAAeA,CAEbwiC,UAAoB,EACpBjoD,mBAAsC,EACxB;IACd,IAAIioD,UAAU,EAAE;MACd,OAAO,IAAI,CAACC,aAAa,CAAC,MACxB,IAAI,CAACC,mBAAmB,CAACnoD,mBAAmB,CAAC,CAC9C;IACH;IACA,OAAO,IAAI,CAACooD,UAAU,CAAC,MAAM,IAAI,CAACD,mBAAmB,CAACnoD,mBAAmB,CAAC,CAAC;EAC7E;EAGAmoD,mBAAmBA,CAEjBnoD,mBAAsC,EACxB;IACd,MAAMD,QAAQ,GAAG,IAAI,CAAC2B,KAAK,CAAC3B,QAAQ;IACpC,MAAMytB,IAAI,GAAG,IAAI,CAACa,gBAAgB,CAACruB,mBAAmB,CAAC;IACvD,IAAI,IAAI,CAAC+Q,KAAK,CAAA,EAAA,CAAU,EAAE;MACxB,MAAMlW,IAAI,GAAG,IAAI,CAACqlB,WAAW,CAACngB,QAAQ,CAAC;MACvClF,IAAI,CAACqpD,WAAW,GAAG,CAAC12B,IAAI,CAAC;MACzB,OAAO,IAAI,CAACla,GAAG,CAAA,EAAA,CAAU,EAAE;QACzBzY,IAAI,CAACqpD,WAAW,CAAC5lE,IAAI,CAAC,IAAI,CAAC+vC,gBAAgB,CAACruB,mBAAmB,CAAC,CAAC;MACnE;MACA,IAAI,CAACswB,gBAAgB,CAACz1B,IAAI,CAACqpD,WAAW,CAAC;MACvC,OAAO,IAAI,CAAC9kD,UAAU,CAACvE,IAAI,EAAE,oBAAoB,CAAC;IACpD;IACA,OAAO2yB,IAAI;EACb;EAGA66B,0BAA0BA,CAExBroD,mBAA6C,EAC7CmzB,cAAyB,EACzB;IACA,OAAO,IAAI,CAAC+0B,aAAa,CAAC,MACxB,IAAI,CAAC75B,gBAAgB,CAACruB,mBAAmB,EAAEmzB,cAAc,CAAC,CAC3D;EACH;EAGA7E,uBAAuBA,CAErBtuB,mBAA6C,EAC7CmzB,cAAyB,EACzB;IACA,OAAO,IAAI,CAACi1B,UAAU,CAAC,MACrB,IAAI,CAAC/5B,gBAAgB,CAACruB,mBAAmB,EAAEmzB,cAAc,CAAC,CAC3D;EACH;EAIAtF,0BAA0BA,CACxB7tB,mBAAqC,EACrCsoD,WAA6B,EAC7B;IAAA,IAAAC,gBAAA;IACAvoD,mBAAmB,CAACke,qBAAqB,GAAA,CAAAqqC,gBAAA,GACvCD,WAAW,IAAXA,IAAAA,GAAAA,KAAAA,CAAAA,GAAAA,WAAW,CAAE5uD,GAAG,YAAA6uD,gBAAA,GAAI,IAAI,CAAC7mD,KAAK,CAAC3B,QAAQ;EAC3C;EAKAsuB,gBAAgBA,CAEdruB,mBAA6C,EAC7CmzB,cAAyB,EACX;IACd,MAAMpzB,QAAQ,GAAG,IAAI,CAAC2B,KAAK,CAAC3B,QAAQ;IACpC,IAAI,IAAI,CAACwc,YAAY,CAAA,GAAA,CAAW,EAAE;MAChC,IAAI,IAAI,CAACuC,SAAS,CAAC7C,QAAQ,EAAE;QAC3B,IAAImU,IAAI,GAAG,IAAI,CAACo4B,UAAU,EAAE;QAC5B,IAAIr1B,cAAc,EAAE;UAClB/C,IAAI,GAAG+C,cAAc,CAACF,IAAI,CAAC,IAAI,EAAE7C,IAAI,EAAErwB,QAAQ,CAAC;QAClD;QACA,OAAOqwB,IAAI;MACb;IACF;IAEA,IAAIq4B,mBAAmB;IACvB,IAAIzoD,mBAAmB,EAAE;MACvByoD,mBAAmB,GAAG,KAAK;IAC7B,CAAC,MAAM;MACLzoD,mBAAmB,GAAG,IAAIof,gBAAgB,EAAE;MAC5CqpC,mBAAmB,GAAG,IAAI;IAC5B;IACA,MAAM;MAAEv7D;KAAM,GAAG,IAAI,CAACwU,KAAK;IAE3B,IAAIxU,IAAI,KAAc,EAAA,IAAIxF,iBAAiB,CAACwF,IAAI,CAAC,EAAE;MACjD,IAAI,CAACwU,KAAK,CAAC4L,gBAAgB,GAAG,IAAI,CAAC5L,KAAK,CAAClY,KAAK;IAChD;IAEA,IAAI4mC,IAAI,GAAG,IAAI,CAACs4B,qBAAqB,CAAC1oD,mBAAmB,CAAC;IAC1D,IAAImzB,cAAc,EAAE;MAClB/C,IAAI,GAAG+C,cAAc,CAACF,IAAI,CAAC,IAAI,EAAE7C,IAAI,EAAErwB,QAAQ,CAAC;IAClD;IACA,IAAI/X,iBAAiB,CAAC,IAAI,CAAC0Z,KAAK,CAACxU,IAAI,CAAC,EAAE;MACtC,MAAM2N,IAAI,GAAG,IAAI,CAACqlB,WAAW,CAAyBngB,QAAQ,CAAC;MAC/D,MAAMorC,QAAQ,GAAG,IAAI,CAACzpC,KAAK,CAACnX,KAAK;MACjCsQ,IAAI,CAACswC,QAAQ,GAAGA,QAAQ;MAExB,IAAI,IAAI,CAACp6B,KAAK,CAAA,EAAA,CAAO,EAAE;QACrB,IAAI,CAACzQ,YAAY,CAAC8vB,IAAI,EAAc,IAAI,CAAC;QACzCv1B,IAAI,CAACu1B,IAAI,GAAGA,IAAI;QAEhB,MAAMu4B,UAAU,GAAG5oD,QAAQ,CAAC1W,KAAK;QACjC,IACE2W,mBAAmB,CAACge,cAAc,IAAI,IAAI,IAC1Che,mBAAmB,CAACge,cAAc,CAAC30B,KAAK,IAAIs/D,UAAU,EACtD;UACA3oD,mBAAmB,CAACge,cAAc,GAAG,IAAI;QAC3C;QACA,IACEhe,mBAAmB,CAAC+d,kBAAkB,IAAI,IAAI,IAC9C/d,mBAAmB,CAAC+d,kBAAkB,CAAC10B,KAAK,IAAIs/D,UAAU,EAC1D;UACA3oD,mBAAmB,CAAC+d,kBAAkB,GAAG,IAAI;QAC/C;QACA,IACE/d,mBAAmB,CAACie,aAAa,IAAI,IAAI,IACzCje,mBAAmB,CAACie,aAAa,CAAC50B,KAAK,IAAIs/D,UAAU,EACrD;UACA,IAAI,CAACxpC,yBAAyB,CAACnf,mBAAmB,CAAC;UACnDA,mBAAmB,CAACie,aAAa,GAAG,IAAI;QAC1C;MACF,CAAC,MAAM;QACLpjB,IAAI,CAACu1B,IAAI,GAAGA,IAAI;MAClB;MAEA,IAAI,CAAC3rB,IAAI,EAAE;MACX5J,IAAI,CAACkuB,KAAK,GAAG,IAAI,CAACsF,gBAAgB,EAAE;MACpC,IAAI,CAACoe,SAAS,CAACrc,IAAI,EAAE;QACnBsc,EAAE,EAAE,IAAI,CAACttC,UAAU,CAACvE,IAAI,EAAE,sBAAsB;MAClD,CAAC,CAAC;MAEF,OAAOA,IAAI;IACZ,CAAA,MAAM,IAAI4tD,mBAAmB,EAAE;MAC9B,IAAI,CAAC5qC,qBAAqB,CAAC7d,mBAAmB,EAAE,IAAI,CAAC;IACvD;IAEA,OAAOowB,IAAI;EACb;EAKAs4B,qBAAqBA,CAEnB1oD,mBAAqC,EACvB;IACd,MAAMD,QAAQ,GAAG,IAAI,CAAC2B,KAAK,CAAC3B,QAAQ;IACpC,MAAMuN,gBAAgB,GAAG,IAAI,CAAC5L,KAAK,CAAC4L,gBAAgB;IACpD,MAAMkgB,IAAI,GAAG,IAAI,CAACo7B,YAAY,CAAC5oD,mBAAmB,CAAC;IAEnD,IAAI,IAAI,CAACgoD,oBAAoB,CAACx6B,IAAI,EAAElgB,gBAAgB,CAAC,EAAE;MACrD,OAAOkgB,IAAI;IACb;IAEA,OAAO,IAAI,CAACI,gBAAgB,CAACJ,IAAI,EAAEztB,QAAQ,EAAEC,mBAAmB,CAAC;EACnE;EAEA4tB,gBAAgBA,CAEdJ,IAAkB,EAClBztB,QAAkB,EAElBC,mBAA6C,EAC/B;IACd,IAAI,IAAI,CAACsT,GAAG,CAAA,EAAA,CAAa,EAAE;MACzB,MAAMzY,IAAI,GAAG,IAAI,CAACqlB,WAAW,CAACngB,QAAQ,CAAC;MACvClF,IAAI,CAAC0I,IAAI,GAAGiqB,IAAI;MAChB3yB,IAAI,CAACkzB,UAAU,GAAG,IAAI,CAACO,uBAAuB,EAAE;MAChD,IAAI,CAACjR,MAAM,CAAU,EAAA,CAAA;MACrBxiB,IAAI,CAACuzB,SAAS,GAAG,IAAI,CAACC,gBAAgB,EAAE;MACxC,OAAO,IAAI,CAACjvB,UAAU,CAACvE,IAAI,EAAE,uBAAuB,CAAC;IACvD;IACA,OAAO2yB,IAAI;EACb;EAEAq7B,wBAAwBA,CAEtB7oD,mBAAsC,EACR;IAC9B,OAAO,IAAI,CAAC+Q,KAAK,CAAA,GAAA,CAAgB,GAC7B,IAAI,CAACzS,gBAAgB,EAAE,GACvB,IAAI,CAAC86C,eAAe,CAACp5C,mBAAmB,CAAC;EAC/C;EAKA4oD,YAAYA,CAEV5oD,mBAAqC,EACvB;IACd,MAAMD,QAAQ,GAAG,IAAI,CAAC2B,KAAK,CAAC3B,QAAQ;IACpC,MAAMuN,gBAAgB,GAAG,IAAI,CAAC5L,KAAK,CAAC4L,gBAAgB;IACpD,MAAMkgB,IAAI,GAAG,IAAI,CAACq7B,wBAAwB,CAAC7oD,mBAAmB,CAAC;IAE/D,IAAI,IAAI,CAACgoD,oBAAoB,CAACx6B,IAAI,EAAElgB,gBAAgB,CAAC,EAAE;MACrD,OAAOkgB,IAAI;IACb;IAEA,OAAO,IAAI,CAAC+xB,WAAW,CAAC/xB,IAAI,EAAEztB,QAAQ,EAAE,CAAC,CAAC,CAAC;EAC7C;EAQAw/C,WAAWA,CAETnvB,IAAkC,EAClCovB,YAAsB,EACtBC,OAAe,EACD;IACd,IAAI,IAAI,CAAC9gD,aAAa,CAACyxB,IAAI,CAAC,EAAE;MAK5B,MAAM7lC,KAAK,GAAG,IAAI,CAACkU,gBAAgB,CAAC2xB,IAAI,CAAC;MAEzC,IACEqvB,OAAO,IAAI/2D,uBAAuB,CAAQ,EAAA,CAAA,IAC1C,CAAC,IAAI,CAACo2B,SAAS,CAAC3C,KAAK,IACrB,CAAC,IAAI,CAACpL,KAAK,IAAQ,EACnB;QACA,IAAI,CAACnQ,KAAK,CAAClG,MAAM,CAACjG,mBAAmB,EAAE;UACrCnU,EAAE,EAAE8vC,IAAI;UACRzmC,cAAc,EAAEY;QAClB,CAAC,CAAC;MACJ;MAEA,IAAI,CAACiW,UAAU,CAACC,cAAc,CAAClW,KAAK,EAAE6lC,IAAI,CAAC12B,GAAG,CAAClQ,KAAK,CAAC;IACvD;IAEA,MAAMs/D,EAAE,GAAG,IAAI,CAACpnD,KAAK,CAACxU,IAAI;IAC1B,IAAI9E,eAAe,CAAC0gE,EAAE,CAAC,KAAK,IAAI,CAAChqC,SAAS,CAAC3C,KAAK,IAAI,CAAC,IAAI,CAACpL,KAAK,CAAA,EAAA,CAAQ,CAAC,EAAE;MACxE,IAAIg4C,IAAI,GAAGrgE,uBAAuB,CAACogE,EAAE,CAAC;MACtC,IAAIC,IAAI,GAAGtJ,OAAO,EAAE;QAClB,IAAIqJ,EAAE,OAAgB,EAAE;UACtB,IAAI,CAACtzC,YAAY,CAAC,kBAAkB,CAAC;UACrC,IAAI,IAAI,CAAC9T,KAAK,CAAC0M,0BAA0B,EAAE;YACzC,OAAOgiB,IAAI;UACb;UACA,IAAI,CAAC44B,4BAA4B,CAAC54B,IAAI,EAAEovB,YAAY,CAAC;QACvD;QACA,MAAM3kD,IAAI,GAAG,IAAI,CAACqlB,WAAW,CAC3Bs/B,YAAY,CACb;QACD3kD,IAAI,CAACu1B,IAAI,GAAGA,IAAI;QAChBv1B,IAAI,CAACswC,QAAQ,GAAG,IAAI,CAACzpC,KAAK,CAACnX,KAAK;QAEhC,MAAM0+D,OAAO,GAAGH,EAAE,KAAiB,EAAA,IAAIA,EAAE,KAAkB,EAAA;QAC3D,MAAMI,QAAQ,GAAGJ,EAAE,KAAyB,EAAA;QAE5C,IAAII,QAAQ,EAAE;UAGZH,IAAI,GAAGrgE,uBAAuB,CAAe,EAAA,CAAA;QAC/C;QAEA,IAAI,CAAC+b,IAAI,EAAE;QAEX,IACEqkD,EAAE,OAAgB,IAClB,IAAI,CAAC3nD,SAAS,CAAC,CAAC,kBAAkB,EAAE;UAAE+U,QAAQ,EAAE;QAAW,CAAA,CAAC,CAAC,EAC7D;UACA,IAAI,IAAI,CAACxU,KAAK,CAACxU,IAAI,KAAA,EAAc,IAAI,IAAI,CAAC4xB,SAAS,CAAC9C,QAAQ,EAAE;YAC5D,MAAM,IAAI,CAACpb,KAAK,CAAClG,MAAM,CAAChF,gCAAgC,EAAE;cACxDpV,EAAE,EAAE,IAAI,CAACohB,KAAK,CAAC3B;YACjB,CAAC,CAAC;UACJ;QACF;QAEAlF,IAAI,CAACkuB,KAAK,GAAG,IAAI,CAACogC,oBAAoB,CAACL,EAAE,EAAEC,IAAI,CAAC;QAChD,MAAMK,YAAY,GAAG,IAAI,CAAChqD,UAAU,CAClCvE,IAAI,EACJouD,OAAO,IAAIC,QAAQ,GAAG,mBAAmB,GAAG,kBAAkB,CAC/D;QAMD,MAAMG,MAAM,GAAG,IAAI,CAAC3nD,KAAK,CAACxU,IAAI;QAC9B,IACGg8D,QAAQ,KAAKG,MAAM,KAAA,EAAiB,IAAIA,MAAM,KAAkB,EAAA,CAAC,IACjEJ,OAAO,IAAII,MAAM,OAA0B,EAC5C;UACA,MAAM,IAAI,CAACzoD,KAAK,CAAClG,MAAM,CAACrH,yBAAyB,EAAE;YACjD/S,EAAE,EAAE,IAAI,CAACohB,KAAK,CAAC3B;UACjB,CAAC,CAAC;QACJ;QAEA,OAAO,IAAI,CAACw/C,WAAW,CAAC6J,YAAY,EAAE5J,YAAY,EAAEC,OAAO,CAAC;MAC9D;IACF;IACA,OAAOrvB,IAAI;EACb;EAKA+4B,oBAAoBA,CAElBL,EAAa,EACbC,IAAY,EACE;IACd,MAAMhpD,QAAQ,GAAG,IAAI,CAAC2B,KAAK,CAAC3B,QAAQ;IACpC,QAAQ+oD,EAAE;MACR,KAAA,EAAA;QACE,QAAQ,IAAI,CAACvqD,eAAe,CAAC,kBAAkB,EAAE,UAAU,CAAC;UAC1D,KAAK,MAAM;YACT,OAAO,IAAI,CAAC+qD,uBAAuB,CAAC,MAAM;cACxC,OAAO,IAAI,CAACC,iBAAiB,EAAE;YACjC,CAAC,CAAC;UAEJ,KAAK,OAAO;YACV,OAAO,IAAI,CAACD,uBAAuB,CAAC,MAAM;cACxC,IAAI,IAAI,CAACxqC,SAAS,CAAC7C,QAAQ,IAAI,IAAI,CAACM,YAAY,CAAA,GAAA,CAAW,EAAE;gBAC3D,MAAM,IAAI,CAAC3b,KAAK,CAAClG,MAAM,CAACjC,iBAAiB,EAAE;kBACzCnY,EAAE,EAAE,IAAI,CAACohB,KAAK,CAAC3B;gBACjB,CAAC,CAAC;cACJ;cACA,OAAO,IAAI,CAACypD,6BAA6B,CACvC,IAAI,CAACC,wBAAwB,CAACX,EAAE,EAAEC,IAAI,CAAC,EACvChpD,QAAQ,CACT;YACH,CAAC,CAAC;UAEJ,KAAK,QAAQ;YACX,OAAO,IAAI,CAAC2pD,8BAA8B,CAAC,MAAM;cAC/C,OAAO,IAAI,CAACC,uBAAuB,CAACZ,IAAI,CAAC;YAC3C,CAAC,CAAC;QAAA;MAIR;QACE,OAAO,IAAI,CAACU,wBAAwB,CAACX,EAAE,EAAEC,IAAI,CAAC;IAAA;EAEpD;EAKAU,wBAAwBA,CAEtBX,EAAa,EACbC,IAAY,EACE;IACd,MAAMhpD,QAAQ,GAAG,IAAI,CAAC2B,KAAK,CAAC3B,QAAQ;IAEpC,OAAO,IAAI,CAACw/C,WAAW,CACrB,IAAI,CAACsJ,wBAAwB,EAAE,EAC/B9oD,QAAQ,EACRpX,uBAAuB,CAACmgE,EAAE,CAAC,GAAGC,IAAI,GAAG,CAAC,GAAGA,IAAI,CAC9C;EACH;EAEAQ,iBAAiBA,CAAAA,EAA6B;IAAA,IAAAK,WAAA;IAC5C,MAAM;MAAE7pD;KAAU,GAAG,IAAI,CAAC2B,KAAK;IAC/B,MAAM7D,IAAI,GAAG,IAAI,CAACwwB,gBAAgB,EAAE;IACpC,MAAMw7B,mBAAmB,GAAGvxD,mCAAmC,CAAC6L,GAAG,CAEjEtG,IAAI,CAAC3Q,IAAI,CACV;IAGD,IAAI28D,mBAAmB,IAAI,EAAAD,CAAAA,WAAA,GAAC/rD,IAAI,CAACrB,KAAK,KAAVotD,IAAAA,IAAAA,WAAA,CAAYvsD,aAAa,CAAE,EAAA;MACrD,IAAI,CAACuD,KAAK,CAAClG,MAAM,CAAC5B,uBAAuB,EAAE;QACzCxY,EAAE,EAAEyf,QAAQ;QAEZ7S,IAAI,EAAE2Q,IAAI,CAAC3Q;MACb,CAAC,CAAC;IACJ;IACA,IAAI,CAAC,IAAI,CAAC48D,qCAAqC,EAAE,EAAE;MAEjD,IAAI,CAAClpD,KAAK,CAAClG,MAAM,CAAC7B,eAAe,EAAE;QAAEvY,EAAE,EAAEyf;MAAS,CAAC,CAAC;IACtD;IAEA,OAAOlC,IAAI;EACb;EAEAksD,0BAA0BA,CACxBlvD,IAAmD,EACnD;IACA,IAAI,IAAI,CAACkW,KAAK,CAAA,EAAA,CAAa,EAAE;MAC3B,IAAI,CAACnQ,KAAK,CAAClG,MAAM,CAACnE,kCAAkC,EAAE;QACpDjW,EAAE,EAAEua,IAAI,CAACb;MACX,CAAC,CAAC;IACJ;EACF;EAIAo/C,eAAeA,CAEbp5C,mBAA6C,EAC7C4hD,QAAkB,EACJ;IACd,MAAM7hD,QAAQ,GAAG,IAAI,CAAC2B,KAAK,CAAC3B,QAAQ;IACpC,MAAMiqD,OAAO,GAAG,IAAI,CAACztC,YAAY,CAAW,EAAA,CAAA;IAE5C,IAAIytC,OAAO,IAAI,IAAI,CAACC,cAAc,EAAE,EAAE;MACpC,IAAI,CAACxlD,IAAI,EAAE;MACX,MAAM+oB,IAAI,GAAG,IAAI,CAAC08B,UAAU,CAACnqD,QAAQ,CAAC;MACtC,IAAI,CAAC6hD,QAAQ,EAAE,IAAI,CAACmI,0BAA0B,CAACv8B,IAAI,CAAC;MACpD,OAAOA,IAAI;IACb;IACA,MAAM28B,MAAM,GAAG,IAAI,CAACp5C,KAAK,CAAW,EAAA,CAAA;IACpC,MAAMlW,IAAI,GAAG,IAAI,CAACqE,SAAS,EAA0C;IACrE,IAAI5W,aAAa,CAAC,IAAI,CAACoZ,KAAK,CAACxU,IAAI,CAAC,EAAE;MAClC2N,IAAI,CAACswC,QAAQ,GAAG,IAAI,CAACzpC,KAAK,CAACnX,KAAK;MAChCsQ,IAAI,CAACle,MAAM,GAAG,IAAI;MAElB,IAAI,IAAI,CAACo0B,KAAK,CAAA,EAAA,CAAW,EAAE;QACzB,IAAI,CAACyE,YAAY,CAAC,kBAAkB,CAAC;MACvC;MACA,MAAM40C,QAAQ,GAAG,IAAI,CAACr5C,KAAK,CAAY,EAAA,CAAA;MACvC,IAAI,CAACtM,IAAI,EAAE;MAEX5J,IAAI,CAACb,QAAQ,GAAG,IAAI,CAACo/C,eAAe,CAAC,IAAI,EAAE,IAAI,CAAC;MAEhD,IAAI,CAACv7B,qBAAqB,CAAC7d,mBAAmB,EAAE,IAAI,CAAC;MAErD,IAAI,IAAI,CAAC0B,KAAK,CAACiC,MAAM,IAAIymD,QAAQ,EAAE;QACjC,MAAMhf,GAAG,GAAGvwC,IAAI,CAACb,QAAQ;QAEzB,IAAIoxC,GAAG,CAACl+C,IAAI,KAAK,YAAY,EAAE;UAC7B,IAAI,CAAC0T,KAAK,CAAClG,MAAM,CAAC7C,YAAY,EAAE;YAAEvX,EAAE,EAAEua;UAAK,CAAC,CAAC;QAC9C,CAAA,MAAM,IAAI,IAAI,CAAC4H,wBAAwB,CAAC2oC,GAAG,CAAC,EAAE;UAC7C,IAAI,CAACxqC,KAAK,CAAClG,MAAM,CAAC3L,kBAAkB,EAAE;YAAEzO,EAAE,EAAEua;UAAK,CAAC,CAAC;QACrD;MACF;MAEA,IAAI,CAACsvD,MAAM,EAAE;QACX,IAAI,CAACvI,QAAQ,EAAE;UACb,IAAI,CAACmI,0BAA0B,CAAClvD,IAAI,CAA8B;QACpE;QACA,OAAO,IAAI,CAACuE,UAAU,CAACvE,IAAI,EAAE,iBAAiB,CAAC;MACjD;IACF;IAEA,MAAM2yB,IAAI,GAAG,IAAI,CAAC68B,WAAW,CAE3BxvD,IAAI,EACJsvD,MAAM,EACNnqD,mBAAmB,CACpB;IAED,IAAIgqD,OAAO,EAAE;MACX,MAAM;QAAE98D;OAAM,GAAG,IAAI,CAACwU,KAAK;MAC3B,MAAMllB,UAAU,GAAG,IAAI,CAAC2kB,SAAS,CAAC,aAAa,CAAC,GAC5CpZ,uBAAuB,CAACmF,IAAI,CAAC,GAC7BnF,uBAAuB,CAACmF,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC6jB,KAAK,CAAW,EAAA,CAAA;MAC3D,IAAIv0B,UAAU,IAAI,CAAC,IAAI,CAAC8tE,gBAAgB,EAAE,EAAE;QAC1C,IAAI,CAAC1xC,cAAc,CAACle,MAAM,CAAC7M,sBAAsB,EAAE;UAAEvN,EAAE,EAAEyf;QAAS,CAAC,CAAC;QACpE,OAAO,IAAI,CAACmqD,UAAU,CAACnqD,QAAQ,CAAC;MAClC;IACF;IAEA,OAAOytB,IAAI;EACb;EAGA68B,WAAWA,CAETxvD,IAAkB,EAClBsvD,MAAe,EACfnqD,mBAA6C,EAC/B;IACd,IAAImqD,MAAM,EAAE;MAEV,MAAMI,oBAAoB,GAAG1vD,IAAkC;MAC/D,IAAI,CAAC4xC,SAAS,CAAC8d,oBAAoB,CAACvwD,QAAQ,EAAE;QAC5C0yC,EAAE,EAAE,IAAI,CAACttC,UAAU,CAACmrD,oBAAoB,EAAE,kBAAkB;MAC9D,CAAC,CAAC;MACF,OAAO1vD,IAAI;IACb;IAEA,MAAMkF,QAAQ,GAAG,IAAI,CAAC2B,KAAK,CAAC3B,QAAQ;IACpC,IAAIytB,IAAI,GAAG,IAAI,CAACg9B,mBAAmB,CAACxqD,mBAAmB,CAAC;IACxD,IAAI,IAAI,CAAC6d,qBAAqB,CAAC7d,mBAAmB,EAAE,KAAK,CAAC,EAAE,OAAOwtB,IAAI;IACvE,OAAOnlC,cAAc,CAAC,IAAI,CAACqZ,KAAK,CAACxU,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC6vB,kBAAkB,EAAE,EAAE;MACpE,MAAMliB,IAAI,GAAG,IAAI,CAACqlB,WAAW,CAAqBngB,QAAQ,CAAC;MAC3DlF,IAAI,CAACswC,QAAQ,GAAG,IAAI,CAACzpC,KAAK,CAACnX,KAAK;MAChCsQ,IAAI,CAACle,MAAM,GAAG,KAAK;MACnBke,IAAI,CAACb,QAAQ,GAAGwzB,IAAI;MACpB,IAAI,CAAC/oB,IAAI,EAAE;MACX,IAAI,CAACgoC,SAAS,CAACjf,IAAI,EAAE;QACnBkf,EAAE,EAAGlf,IAAI,GAAG,IAAI,CAACpuB,UAAU,CAACvE,IAAI,EAAE,kBAAkB;MACtD,CAAC,CAAC;IACJ;IACA,OAAO2yB,IAAI;EACb;EAIAg9B,mBAAmBA,CAEjBxqD,mBAA6C,EAC/B;IACd,MAAMD,QAAQ,GAAG,IAAI,CAAC2B,KAAK,CAAC3B,QAAQ;IACpC,MAAMuN,gBAAgB,GAAG,IAAI,CAAC5L,KAAK,CAAC4L,gBAAgB;IACpD,MAAMkgB,IAAI,GAAG,IAAI,CAACtG,aAAa,CAAClnB,mBAAmB,CAAC;IAEpD,IAAI,IAAI,CAACgoD,oBAAoB,CAACx6B,IAAI,EAAElgB,gBAAgB,CAAC,EAAE;MACrD,OAAOkgB,IAAI;IACb;IAEA,OAAO,IAAI,CAAC8G,eAAe,CAAC9G,IAAI,EAAEztB,QAAQ,CAAC;EAC7C;EAEAu0B,eAAeA,CAEbpyB,IAAkB,EAClBnC,QAAkB,EAClBoC,OAAwB,EACV;IACd,MAAMT,KAAK,GAAG;MACZU,mBAAmB,EAAE,KAAK;MAC1BqoD,eAAe,EAAE,IAAI,CAACvL,oBAAoB,CAACh9C,IAAI,CAAC;MAChDI,IAAI,EAAE;KACP;IACD,GAAG;MACDJ,IAAI,GAAG,IAAI,CAACD,cAAc,CAACC,IAAI,EAAEnC,QAAQ,EAAEoC,OAAO,EAAET,KAAK,CAAC;MAG1DA,KAAK,CAAC+oD,eAAe,GAAG,KAAK;IAC/B,CAAC,QAAQ,CAAC/oD,KAAK,CAACY,IAAI;IACpB,OAAOJ,IAAI;EACb;EAMAD,cAAcA,CAEZC,IAAkB,EAClBnC,QAAkB,EAClBoC,OAAmC,EACnCT,KAA4B,EACd;IACd,MAAM;MAAExU;KAAM,GAAG,IAAI,CAACwU,KAAK;IAC3B,IAAI,CAACS,OAAO,IAAIjV,IAAI,OAAmB,EAAE;MACvC,OAAO,IAAI,CAACw9D,SAAS,CAACxoD,IAAI,EAAEnC,QAAQ,EAAEoC,OAAO,EAAET,KAAK,CAAC;IACvD,CAAC,MAAM,IAAI9Y,eAAe,CAACsE,IAAI,CAAC,EAAE;MAChC,OAAO,IAAI,CAACkyD,6BAA6B,CAACl9C,IAAI,EAAEnC,QAAQ,EAAE2B,KAAK,CAAC;IAClE;IAEA,IAAIX,QAAQ,GAAG,KAAK;IAEpB,IAAI7T,IAAI,OAAmB,EAAE;MAC3B,IAAIiV,OAAO,EAAE;QACX,IAAI,CAACvB,KAAK,CAAClG,MAAM,CAACvG,qBAAqB,EAAE;UACvC7T,EAAE,EAAE,IAAI,CAACohB,KAAK,CAAC3B;QACjB,CAAC,CAAC;QACF,IAAI,IAAI,CAACgU,iBAAiB,EAAE,OAA8B,EAAE;UAE1DrS,KAAK,CAACY,IAAI,GAAG,IAAI;UACjB,OAAOJ,IAAI;QACb;MACF;MACAR,KAAK,CAACU,mBAAmB,GAAGrB,QAAQ,GAAG,IAAI;MAC3C,IAAI,CAAC0D,IAAI,EAAE;IACb;IAEA,IAAI,CAACtC,OAAO,IAAI,IAAI,CAAC4O,KAAK,IAAW,EAAE;MACrC,OAAO,IAAI,CAAC45C,+BAA+B,CACzCzoD,IAAI,EACJnC,QAAQ,EACR2B,KAAK,EACLX,QAAQ,CACT;IACH,CAAC,MAAM;MACL,MAAM5B,QAAQ,GAAG,IAAI,CAACmU,GAAG,CAAa,CAAA,CAAA;MACtC,IAAInU,QAAQ,IAAI4B,QAAQ,IAAI,IAAI,CAACuS,GAAG,IAAQ,EAAE;QAC5C,OAAO,IAAI,CAACs3C,WAAW,CAAC1oD,IAAI,EAAEnC,QAAQ,EAAE2B,KAAK,EAAEvC,QAAQ,EAAE4B,QAAQ,CAAC;MACpE,CAAC,MAAM;QACLW,KAAK,CAACY,IAAI,GAAG,IAAI;QACjB,OAAOJ,IAAI;MACb;IACF;EACF;EAMA0oD,WAAWA,CAET1oD,IAAkB,EAClBnC,QAAkB,EAClB2B,KAA4B,EAC5BvC,QAAiB,EACjB4B,QAAiB,EACgC;IACjD,MAAMlG,IAAI,GAAG,IAAI,CAACqlB,WAAW,CAE3BngB,QAAQ,CAAC;IACXlF,IAAI,CAACvQ,MAAM,GAAG4X,IAAI;IAClBrH,IAAI,CAACsE,QAAQ,GAAGA,QAAQ;IACxB,IAAIA,QAAQ,EAAE;MACZtE,IAAI,CAACwjB,QAAQ,GAAG,IAAI,CAACoH,eAAe,EAAE;MACtC,IAAI,CAACpI,MAAM,CAAa,CAAA,CAAA;IACzB,CAAA,MAAM,IAAI,IAAI,CAACtM,KAAK,KAAgB,EAAE;MACrC,IAAI7O,IAAI,CAAChV,IAAI,KAAK,OAAO,EAAE;QACzB,IAAI,CAAC0T,KAAK,CAAClG,MAAM,CAACtF,iBAAiB,EAAE;UAAE9U,EAAE,EAAEyf;QAAS,CAAC,CAAC;MACxD;MACA,IAAI,CAACS,UAAU,CAACC,cAAc,CAAC,IAAI,CAACiB,KAAK,CAACnX,KAAK,EAAE,IAAI,CAACmX,KAAK,CAAC3B,QAAQ,CAAC;MACrElF,IAAI,CAACwjB,QAAQ,GAAG,IAAI,CAAC/f,gBAAgB,EAAE;IACzC,CAAC,MAAM;MACLzD,IAAI,CAACwjB,QAAQ,GAAG,IAAI,CAAC0H,eAAe,CAAC,IAAI,CAAC;IAC5C;IAEA,IAAIrkB,KAAK,CAACU,mBAAmB,EAAE;MAC5BvH,IAAI,CAAgCkG,QAAQ,GAAGA,QAAQ;MACxD,OAAO,IAAI,CAAC3B,UAAU,CAACvE,IAAI,EAAE,0BAA0B,CAAC;IAC1D,CAAC,MAAM;MACL,OAAO,IAAI,CAACuE,UAAU,CAACvE,IAAI,EAAE,kBAAkB,CAAC;IAClD;EACF;EAGA6vD,SAASA,CAEPxoD,IAAkB,EAClBnC,QAAkB,EAClBoC,OAAmC,EACnCT,KAA4B,EACd;IACd,MAAM7G,IAAI,GAAG,IAAI,CAACqlB,WAAW,CAACngB,QAAQ,CAAC;IACvClF,IAAI,CAACvQ,MAAM,GAAG4X,IAAI;IAClB,IAAI,CAACuC,IAAI,EAAE;IACX5J,IAAI,CAACmG,MAAM,GAAG,IAAI,CAAC6pD,eAAe,EAAE;IACpCnpD,KAAK,CAACY,IAAI,GAAG,IAAI;IACjB,OAAO,IAAI,CAACgyB,eAAe,CACzB,IAAI,CAACl1B,UAAU,CAACvE,IAAI,EAAE,gBAAgB,CAAC,EACvCkF,QAAQ,EACRoC,OAAO,CACR;EACH;EAMAwoD,+BAA+BA,CAE7BzoD,IAAkB,EAClBnC,QAAkB,EAClB2B,KAA4B,EAC5BX,QAAiB,EACH;IACd,MAAMk9C,yBAAyB,GAAG,IAAI,CAACv8C,KAAK,CAAC+L,sBAAsB;IACnE,IAAIzN,mBAA4C,GAAG,IAAI;IAEvD,IAAI,CAAC0B,KAAK,CAAC+L,sBAAsB,GAAG,IAAI;IACxC,IAAI,CAAChJ,IAAI,EAAE;IAEX,MAAM5J,IAAI,GAAG,IAAI,CAACqlB,WAAW,CAC3BngB,QAAQ,CACT;IACDlF,IAAI,CAACmG,MAAM,GAAGkB,IAAI;IAClB,MAAM;MAAEuoD,eAAe;MAAEroD;IAAqB,CAAA,GAAGV,KAAK;IAEtD,IAAI+oD,eAAe,EAAE;MACnB,IAAI,CAACzrC,eAAe,CAAC9V,KAAK,CAACoS,kBAAkB,EAAE,CAAC;MAChDtb,mBAAmB,GAAG,IAAIof,gBAAgB,EAAE;IAC9C;IAEA,IAAIhd,mBAAmB,EAAE;MAEvBvH,IAAI,CAACkG,QAAQ,GAAGA,QAAQ;IAC1B;IAEA,IAAIA,QAAQ,EAAE;MACZlG,IAAI,CAACqG,SAAS,GAAG,IAAI,CAACqzB,4BAA4B,CAAW,EAAA,CAAA;IAC/D,CAAC,MAAM;MACL15B,IAAI,CAACqG,SAAS,GAAG,IAAI,CAACqzB,4BAA4B,CAAA,EAAA,EAEhDryB,IAAI,CAAChV,IAAI,KAAK,QAAQ,EACtBgV,IAAI,CAAChV,IAAI,KAAK,OAAO,EAErB2N,IAAI,EACJmF,mBAAmB,CACpB;IACH;IACA,IAAIopD,YAGyB,GAAG,IAAI,CAACvoD,oBAAoB,CACvDhG,IAAI,EACJuH,mBAAmB,CACpB;IAED,IAAIqoD,eAAe,IAAI,IAAI,CAACv3B,qBAAqB,EAAE,IAAI,CAACnyB,QAAQ,EAAE;MAEhEW,KAAK,CAACY,IAAI,GAAG,IAAI;MACjB,IAAI,CAAC6c,yBAAyB,CAACnf,mBAAmB,CAAC;MACnD,IAAI,CAACgf,eAAe,CAAC7D,iBAAiB,EAAE;MACxC,IAAI,CAAC6D,eAAe,CAAC7V,IAAI,EAAE;MAC3BigD,YAAY,GAAG,IAAI,CAACp2B,iCAAiC,CACnD,IAAI,CAAC9S,WAAW,CAA4BngB,QAAQ,CAAC,EACrDqpD,YAAY,CACb;IACH,CAAC,MAAM;MACL,IAAIqB,eAAe,EAAE;QACnB,IAAI,CAAC5sC,qBAAqB,CAAC7d,mBAAmB,EAAE,IAAI,CAAC;QACrD,IAAI,CAACgf,eAAe,CAAC7V,IAAI,EAAE;MAC7B;MACA,IAAI,CAAC7H,qBAAqB,CAAC8nD,YAAY,CAAC;IAC1C;IAEA,IAAI,CAAC1nD,KAAK,CAAC+L,sBAAsB,GAAGwwC,yBAAyB;IAE7D,OAAOmL,YAAY;EACrB;EAEA9nD,qBAAqBA,CACnBzG,IAAiD,EACjD01B,mBAA6B,EAC7B;IACA,IAAI,CAACib,oBAAoB,CAAC3wC,IAAI,CAACqG,SAAS,EAAEqvB,mBAAmB,CAAC;EAChE;EAIA6uB,6BAA6BA,CAE3Bl9C,IAAkB,EAClBnC,QAAkB,EAClB2B,KAA4B,EACA;IAC5B,MAAM7G,IAAI,GAAG,IAAI,CAACqlB,WAAW,CAA6BngB,QAAQ,CAAC;IACnElF,IAAI,CAACiwD,GAAG,GAAG5oD,IAAI;IACfrH,IAAI,CAACkwD,KAAK,GAAG,IAAI,CAAC/R,aAAa,CAAC,IAAI,CAAC;IACrC,IAAIt3C,KAAK,CAACU,mBAAmB,EAAE;MAC7B,IAAI,CAACxB,KAAK,CAAClG,MAAM,CAACtG,0BAA0B,EAAE;QAAE9T,EAAE,EAAEyf;MAAS,CAAC,CAAC;IACjE;IACA,OAAO,IAAI,CAACX,UAAU,CAACvE,IAAI,EAAE,0BAA0B,CAAC;EAC1D;EAEAqkD,oBAAoBA,CAACh9C,IAAkB,EAAW;IAChD,OACEA,IAAI,CAAChV,IAAI,KAAK,YAAY,IAC1BgV,IAAI,CAAC3kB,IAAI,KAAK,OAAO,IACrB,IAAI,CAACmkB,KAAK,CAACoB,aAAa,CAACzZ,KAAK,KAAK6Y,IAAI,CAACzY,GAAG,IAC3C,CAAC,IAAI,CAACszB,kBAAkB,EAAE,IAE1B7a,IAAI,CAACzY,GAAG,GAAGyY,IAAI,CAAC1Y,KAAK,KAAK,CAAC,IAC3B0Y,IAAI,CAAC1Y,KAAK,KAAK,IAAI,CAACkY,KAAK,CAAC4L,gBAAgB;EAE9C;EAEAzM,oBAAoBA,CAClBhG,IAAe,EACfkG,QAAiB,EACd;IACH,IAAIlG,IAAI,CAACmG,MAAM,CAAC9T,IAAI,KAAK,QAAQ,EAAE;MACjC,IAAI2N,IAAI,CAACqG,SAAS,CAACjY,MAAM,KAAK,CAAC,EAAE;QAGxB;UACL,IAAI,CAAC,IAAI,CAACkY,SAAS,CAAC,kBAAkB,CAAC,EAAE;YACvC,IAAI,CAACqU,YAAY,CAAC,kBAAkB,CAAC;UACvC;QACF;MACF;MACA,IAAI3a,IAAI,CAACqG,SAAS,CAACjY,MAAM,KAAK,CAAC,IAAI4R,IAAI,CAACqG,SAAS,CAACjY,MAAM,GAAG,CAAC,EAAE;QAC5D,IAAI,CAAC2X,KAAK,CAAClG,MAAM,CAACnK,eAAe,EAAE;UACjCjQ,EAAE,EAAEua,IAAI;UACRrK,gBAAgB,EACd,IAAI,CAAC2Q,SAAS,CAAC,kBAAkB,CAAC,IAClC,IAAI,CAACA,SAAS,CAAC,kBAAkB,CAAC,GAC9B,CAAC,GACD;QACR,CAAC,CAAC;MACJ,CAAC,MAAM;QACL,KAAK,MAAMiqC,GAAG,IAAIvwC,IAAI,CAACqG,SAAS,EAAE;UAChC,IAAIkqC,GAAG,CAACl+C,IAAI,KAAK,eAAe,EAAE;YAChC,IAAI,CAAC0T,KAAK,CAAClG,MAAM,CAAChK,wBAAwB,EAAE;cAAEpQ,EAAE,EAAE8qD;YAAI,CAAC,CAAC;UAC1D;QACF;MACF;IACF;IACA,OAAO,IAAI,CAAChsC,UAAU,CACpBvE,IAAI,EACJkG,QAAQ,GAAG,wBAAwB,GAAG,gBAAgB,CACvD;EACH;EAEAwzB,4BAA4BA,CAE1B7D,KAAgB,EAChBs6B,aAAuB,EACvBC,gBAA0B,EAC1BC,YAA4B,EAC5BlrD,mBAA6C,EACL;IACxC,MAAMgsC,IAAoB,GAAG,EAAE;IAC/B,IAAIjgB,KAAK,GAAG,IAAI;IAChB,MAAMo/B,6BAA6B,GAAG,IAAI,CAACzpD,KAAK,CAAC0M,0BAA0B;IAC3E,IAAI,CAAC1M,KAAK,CAAC0M,0BAA0B,GAAG,KAAK;IAE7C,OAAO,CAAC,IAAI,CAACkF,GAAG,CAACod,KAAK,CAAC,EAAE;MACvB,IAAI3E,KAAK,EAAE;QACTA,KAAK,GAAG,KAAK;MACf,CAAC,MAAM;QACL,IAAI,CAAC1O,MAAM,CAAU,EAAA,CAAA;QACrB,IAAI,IAAI,CAACtM,KAAK,CAAC2f,KAAK,CAAC,EAAE;UACrB,IACEs6B,aAAa,IACb,CAAC,IAAI,CAAC7pD,SAAS,CAAC,kBAAkB,CAAC,IACnC,CAAC,IAAI,CAACA,SAAS,CAAC,kBAAkB,CAAC,EACnC;YACA,IAAI,CAACP,KAAK,CAAClG,MAAM,CAACpK,+BAA+B,EAAE;cACjDhQ,EAAE,EAAE,IAAI,CAACohB,KAAK,CAACC;YACjB,CAAC,CAAC;UACJ;UACA,IAAIupD,YAAY,EAAE;YAChB,IAAI,CAACE,2BAA2B,CAACF,YAAY,CAAC;UAChD;UACA,IAAI,CAACzmD,IAAI,EAAE;UACX;QACF;MACF;MAEAunC,IAAI,CAAC1tD,IAAI,CACP,IAAI,CAAC+sE,iBAAiB,CAAC,KAAK,EAAErrD,mBAAmB,EAAEirD,gBAAgB,CAAC,CACrE;IACH;IAEA,IAAI,CAACvpD,KAAK,CAAC0M,0BAA0B,GAAG+8C,6BAA6B;IAErE,OAAOnf,IAAI;EACb;EAEA9Y,qBAAqBA,CAAAA,EAAY;IAC/B,OAAO,IAAI,CAACniB,KAAK,CAAA,EAAA,CAAU,IAAI,CAAC,IAAI,CAACgM,kBAAkB,EAAE;EAC3D;EAEAiW,iCAAiCA,CAE/Bn4B,IAAuC,EACvCo4B,IAAsB,EACK;IAAA,IAAAq4B,WAAA;IAC3B,IAAI,CAAC7+C,iCAAiC,CAACwmB,IAAI,CAAC;IAC5C,IAAI,CAAC5V,MAAM,CAAU,EAAA,CAAA;IACrB,IAAI,CAACyX,oBAAoB,CACvBj6B,IAAI,EACJo4B,IAAI,CAAC/xB,SAAS,EACd,IAAI,GAAAoqD,WAAA,GACJr4B,IAAI,CAACz2B,KAAK,qBAAV8uD,WAAA,CAAYz8B,gBAAgB,CAC7B;IAED,IAAIoE,IAAI,CAAC/nB,aAAa,EAAE;MACtBD,gBAAgB,CAACpQ,IAAI,EAAEo4B,IAAI,CAAC/nB,aAAa,CAAC;IAC5C;IAEA,IAAI+nB,IAAI,CAACjyB,MAAM,CAAC6J,gBAAgB,EAAE;MAChCI,gBAAgB,CAACpQ,IAAI,EAAEo4B,IAAI,CAACjyB,MAAM,CAAC6J,gBAAgB,CAAC;IACtD;IACA,OAAOhQ,IAAI;EACb;EAIAgwD,eAAeA,CAAAA,EAA6B;IAC1C,MAAM9qD,QAAQ,GAAG,IAAI,CAAC2B,KAAK,CAAC3B,QAAQ;IACpC,OAAO,IAAI,CAACu0B,eAAe,CAAC,IAAI,CAACpN,aAAa,EAAE,EAAEnnB,QAAQ,EAAE,IAAI,CAAC;EACnE;EAcAmnB,aAAaA,CAEXlnB,mBAA6C,EAC/B;IACd,IAAInF,IAAI;IACR,IAAI2G,UAAgC,GAAG,IAAI;IAE3C,MAAM;MAAEtU;KAAM,GAAG,IAAI,CAACwU,KAAK;IAC3B,QAAQxU,IAAI;MACV,KAAA,EAAA;QACE,OAAO,IAAI,CAACq+D,UAAU,EAAE;MAE1B,KAAA,EAAA;QACE1wD,IAAI,GAAG,IAAI,CAACqE,SAAS,EAA6B;QAClD,IAAI,CAACuF,IAAI,EAAE;QAEX,IAAI,IAAI,CAACsM,KAAK,CAAA,EAAA,CAAQ,EAAE;UACtB,OAAO,IAAI,CAACy6C,uBAAuB,CAAC3wD,IAAI,CAA2B;QACrE;QAEA,IAAI,CAAC,IAAI,CAACkW,KAAK,IAAW,EAAE;UAC1B,IAAI,CAACnQ,KAAK,CAAClG,MAAM,CAAC9D,iBAAiB,EAAE;YACnCtW,EAAE,EAAE,IAAI,CAACohB,KAAK,CAACC;UACjB,CAAC,CAAC;QACJ;QACA,OAAO,IAAI,CAACvC,UAAU,CAACvE,IAAI,EAAE,QAAQ,CAAC;MACxC,KAAA,EAAA;QACEA,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAE;QACvB,IAAI,CAACuF,IAAI,EAAE;QACX,OAAO,IAAI,CAACrF,UAAU,CAACvE,IAAI,EAAE,gBAAgB,CAAC;MAEhD,KAAA,EAAA;QAAa;UACX,OAAO,IAAI,CAAC4wD,OAAO,CAAC,IAAI,CAACvsD,SAAS,EAAE,EAAE,KAAK,CAAC;QAC9C;MAEA,KAAA,EAAA;MACA,KAAA,EAAA;QAAqB;UACnB,IAAI,CAAC+X,UAAU,EAAE;UACjB,OAAO,IAAI,CAAC9b,kBAAkB,CAAC,IAAI,CAACuG,KAAK,CAACnX,KAAK,CAAC;QAClD;MAEA,KAAA,GAAA;QACE,OAAO,IAAI,CAAC0R,mBAAmB,CAAC,IAAI,CAACyF,KAAK,CAACnX,KAAK,CAAC;MAEnD,KAAA,GAAA;QACE,OAAO,IAAI,CAACmR,kBAAkB,CAAC,IAAI,CAACgG,KAAK,CAACnX,KAAK,CAAC;MAElD,KAAA,GAAA;QACE,OAAO,IAAI,CAACuR,mBAAmB,CAAC,IAAI,CAAC4F,KAAK,CAACnX,KAAK,CAAC;MAEnD,KAAA,GAAA;QACE,OAAO,IAAI,CAACyR,kBAAkB,CAAC,IAAI,CAAC0F,KAAK,CAACnX,KAAK,CAAC;MAElD,KAAA,EAAA;QACE,OAAO,IAAI,CAAC2R,gBAAgB,EAAE;MAEhC,KAAA,EAAA;QACE,OAAO,IAAI,CAACC,mBAAmB,CAAC,IAAI,CAAC;MACvC,KAAA,EAAA;QACE,OAAO,IAAI,CAACA,mBAAmB,CAAC,KAAK,CAAC;MAExC,KAAA,EAAA;QAAgB;UACd,MAAMk4B,UAAU,GAAG,IAAI,CAAC3yB,KAAK,CAAC4L,gBAAgB,KAAK,IAAI,CAAC5L,KAAK,CAAClY,KAAK;UACnE,OAAO,IAAI,CAAC4qC,kCAAkC,CAACC,UAAU,CAAC;QAC5D;MAEA,KAAA,CAAA;MACA,KAAA,CAAA;QAAsB;UACpB,OAAO,IAAI,CAAC5D,cAAc,CACxB,IAAI,CAAC/uB,KAAK,CAACxU,IAAI,MAAmB,GAA+B,CAAA,GAAA,CAAA,EAC9C,KAAK,EACV,IAAI,CACnB;QACH;MACA,KAAA,CAAA;QAAkB;UAChB,OAAO,IAAI,CAACujC,cAAc,CAAA,CAAA,EAEL,IAAI,EACT,KAAK,EACnBzwB,mBAAmB,CACpB;QACH;MACA,KAAA,CAAA;MACA,KAAA,CAAA;QAAoB;UAClB,OAAO,IAAI,CAAC6rC,eAAe,CACzB,IAAI,CAACnqC,KAAK,CAACxU,IAAI,MAAiB,GAA2B,CAAA,GAAA,CAAA,EAC3C,KAAK,EACN,IAAI,CACpB;QACH;MACA,KAAA,CAAA;QAAgB;UACd,OAAO,IAAI,CAAC2+C,eAAe,CAAA,CAAA,EAET,KAAK,EACN,KAAK,EACpB7rC,mBAAmB,CACpB;QACH;MACA,KAAA,EAAA;QACE,OAAO,IAAI,CAAC0rD,2BAA2B,EAAE;MAE3C,KAAA,EAAA;QACElqD,UAAU,GAAG,IAAI,CAACmqD,eAAe,EAAE;MAErC,KAAA,EAAA;QACE,OAAO,IAAI,CAACnO,UAAU,CACpB,IAAI,CAACqF,mBAAmB,CAACrhD,UAAU,EAAE,IAAI,CAACtC,SAAS,EAAE,CAAC,EACtD,KAAK,CACN;MAEH,KAAA,EAAA;QACE,OAAO,IAAI,CAAC0sD,mBAAmB,EAAE;MAEnC,KAAA,EAAA;MACA,KAAA,EAAA;QACE,OAAO,IAAI,CAAC5S,aAAa,CAAC,KAAK,CAAC;MAIlC,KAAA,EAAA;QAAqB;UACnBn+C,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAE;UACvB,IAAI,CAACuF,IAAI,EAAE;UACX5J,IAAI,CAACvQ,MAAM,GAAG,IAAI;UAClB,MAAM0W,MAAM,GAAInG,IAAI,CAACmG,MAAM,GAAG,IAAI,CAAC6pD,eAAe,EAAG;UACrD,IAAI7pD,MAAM,CAAC9T,IAAI,KAAK,kBAAkB,EAAE;YACtC,OAAO,IAAI,CAACkS,UAAU,CAACvE,IAAI,EAAE,gBAAgB,CAAC;UAChD,CAAC,MAAM;YACL,MAAM,IAAI,CAAC+F,KAAK,CAAClG,MAAM,CAACjE,eAAe,EAAE;cAAEnW,EAAE,EAAE0gB;YAAO,CAAC,CAAC;UAC1D;QACF;MAEA,KAAA,GAAA;QAAqB;UAOnB,IAAI,CAACJ,KAAK,CAAClG,MAAM,CAACjG,mBAAmB,EAAE;YACrCnU,EAAE,EAAE,IAAI,CAACohB,KAAK,CAAC3B,QAAQ;YACvBpW,cAAc,EAAE,IAAI,CAAC+X,KAAK,CAACnX;UAC7B,CAAC,CAAC;UACF,OAAO,IAAI,CAAC+T,gBAAgB,EAAE;QAChC;MAEA,KAAA,EAAA;QAAsB;UACpB,OAAO,IAAI,CAACutD,iCAAiC,CAAA,EAAA,EAAY,GAAG,CAAC;QAC/D;MAEA,KAAA,EAAA;QAAmB;UACjB,OAAO,IAAI,CAACA,iCAAiC,CAAA,EAAA,EAAgB,GAAG,CAAC;QACnE;MAEA,KAAA,EAAA;MACA,KAAA,EAAA;QAAkB;UAChB,OAAO,IAAI,CAACC,mBAAmB,CAAC,MAAM,CAAC;QACzC;MAEA,KAAA,EAAA;MACA,KAAA,EAAA;MACA,KAAA,EAAA;QAAc;UACZ,MAAMC,YAAY,GAAG,IAAI,CAACxtD,eAAe,CACvC,kBAAkB,EAClB,UAAU,CACX;UAED,IAAIwtD,YAAY,EAAE;YAChB,OAAO,IAAI,CAACD,mBAAmB,CAACC,YAAY,CAAC;UAC/C;UACA,IAAI,CAAC/5D,UAAU,EAAE;UACjB;QACF;MAEA,KAAA,EAAA;QAAY;UACV,MAAMokB,WAAW,GAAG,IAAI,CAAC9J,KAAK,CAAC+J,WAAW,CAAC,IAAI,CAACzC,cAAc,EAAE,CAAC;UACjE,IACEtQ,iBAAiB,CAAC8S,WAAW,CAAC,IAC9BA,WAAW,OAA0B,EACrC;YACA,IAAI,CAACyC,eAAe,CAAC,CAAC,KAAK,EAAE,MAAM,EAAE,YAAY,CAAC,CAAC;UACrD,CAAC,MAAM;YACL,IAAI,CAAC7mB,UAAU,EAAE;UACnB;UACA;QACF;MAEA;QACE,IAAItK,iBAAiB,CAACwF,IAAI,CAAC,EAAE;UAC3B,IACE,IAAI,CAACqvB,YAAY,CAAY,GAAA,CAAA,IAC7B,IAAI,CAACrI,uBAAuB,EAAE,KAAA,GAA6B,EAC3D;YACA,OAAO,IAAI,CAAC83C,qBAAqB,EAAE;UACrC;UACA,MAAM33B,UAAU,GAAG,IAAI,CAAC3yB,KAAK,CAAC4L,gBAAgB,KAAK,IAAI,CAAC5L,KAAK,CAAClY,KAAK;UACnE,MAAMilB,WAAW,GAAG,IAAI,CAAC/M,KAAK,CAAC+M,WAAW;UAC1C,MAAM/P,EAAE,GAAG,IAAI,CAACqnB,eAAe,EAAE;UAEjC,IACE,CAACtX,WAAW,IACZ/P,EAAE,CAACnhB,IAAI,KAAK,OAAO,IACnB,CAAC,IAAI,CAACw/B,kBAAkB,EAAE,EAC1B;YACA,MAAM;cAAE7vB;aAAM,GAAG,IAAI,CAACwU,KAAK;YAC3B,IAAIxU,IAAI,OAAiB,EAAE;cACzB,IAAI,CAACuf,iCAAiC,CAAC/N,EAAE,CAAC;cAC1C,IAAI,CAAC+F,IAAI,EAAE;cACX,OAAO,IAAI,CAACwnD,4BAA4B,CACtC,IAAI,CAACzpD,eAAe,CAAC9D,EAAE,CAAC,CACzB;YACH,CAAC,MAAM,IAAIhX,iBAAiB,CAACwF,IAAI,CAAC,EAAE;cAIlC,IAAI,IAAI,CAAC6mB,iBAAiB,EAAE,OAAuB,EAAE;gBAInD,OAAO,IAAI,CAACm4C,4BAA4B,CACtC,IAAI,CAAC1pD,eAAe,CAAC9D,EAAE,CAAC,CACzB;cACH,CAAC,MAAM;gBAGL,OAAOA,EAAE;cACX;YACF,CAAC,MAAM,IAAIxR,IAAI,KAAA,EAAW,EAAE;cAC1B,IAAI,CAACuf,iCAAiC,CAAC/N,EAAE,CAAC;cAC1C,OAAO,IAAI,CAAC+sD,OAAO,CAAC,IAAI,CAACjpD,eAAe,CAAC9D,EAAE,CAAC,EAAE,IAAI,CAAC;YACrD;UACF;UAEA,IACE21B,UAAU,IACV,IAAI,CAACtjB,KAAK,CAAA,EAAA,CAAU,IACpB,CAAC,IAAI,CAACgM,kBAAkB,EAAE,EAC1B;YACA,IAAI,CAACtY,IAAI,EAAE;YACX,OAAO,IAAI,CAACqwB,oBAAoB,CAC9B,IAAI,CAACtyB,eAAe,CAAC9D,EAAE,CAAC,EACxB,CAACA,EAAE,CAAC,EACJ,KAAK,CACN;UACH;UAEA,OAAOA,EAAE;QACX,CAAC,MAAM;UACL,IAAI,CAAC1M,UAAU,EAAE;QACnB;IAAA;EAEN;EAYA65D,iCAAiCA,CAC/BM,cAAyB,EACzBC,eAAuB,EACT;IACd,MAAML,YAAY,GAAG,IAAI,CAACxtD,eAAe,CAAC,kBAAkB,EAAE,UAAU,CAAC;IAEzE,IAAIwtD,YAAY,EAAE;MAKhB,IAAI,CAACrqD,KAAK,CAACxU,IAAI,GAAGi/D,cAAc;MAChC,IAAI,CAACzqD,KAAK,CAACnX,KAAK,GAAG6hE,eAAe;MAGlC,IAAI,CAAC1qD,KAAK,CAAC5H,GAAG,EAAE;MAChB,IAAI,CAAC4H,KAAK,CAACjY,GAAG,EAAE;MAGhB,IAAI,CAACiY,KAAK,CAACkB,MAAM,GAAGhZ,8BAA8B,CAAC,IAAI,CAAC8X,KAAK,CAACkB,MAAM,EAAE,CAAC,CAAC,CAAC;MAEzE,OAAO,IAAI,CAACkpD,mBAAmB,CAACC,YAAY,CAAC;IAC/C,CAAC,MAAM;MACL,IAAI,CAAC/5D,UAAU,EAAE;IACnB;EACF;EAQA85D,mBAAmBA,CAACC,YAAoB,EAAgB;IACtD,MAAMlxD,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAoB;IAC/C,MAAMa,QAAQ,GAAG,IAAI,CAAC2B,KAAK,CAAC3B,QAAQ;IACpC,MAAMs/C,SAAS,GAAG,IAAI,CAAC39C,KAAK,CAACxU,IAAI;IAGjC,IAAI,CAACuX,IAAI,EAAE;IAKX,OAAO,IAAI,CAAC4nD,oBAAoB,CAACxxD,IAAI,EAAEkF,QAAQ,EAAEgsD,YAAY,EAAE1M,SAAS,CAAC;EAC3E;EAeAgN,oBAAoBA,CAClBxxD,IAAoB,EACpBkF,QAAkB,EAClBgsD,YAAoB,EACpB1M,SAAoB,EACN;IACd,IACE,IAAI,CAACiN,+BAA+B,CAACP,YAAY,EAAEhsD,QAAQ,EAAEs/C,SAAS,CAAC,EACvE;MAMA,MAAMhG,QAAQ,GACZ0S,YAAY,KAAK,OAAO,GACpB,+BAA+B,GAG/B,gBAAgB;MAEtB,IAAI,CAAC,IAAI,CAACQ,uCAAuC,EAAE,EAAE;QACnD,IAAI,CAAC3rD,KAAK,CAIRmrD,YAAY,KAAK,OAAO,GACpBrxD,MAAM,CAACvB,sBAAsB,GAE7BuB,MAAM,CAAC/B,gBAAgB,EAC3B;UAAErY,EAAE,EAAEyf;QAAS,CAAC,CACjB;MACH;MAIA,IAAI,CAACysD,sBAAsB,EAAE;MAE7B,OAAO,IAAI,CAACptD,UAAU,CAACvE,IAAI,EAAEw+C,QAAQ,CAAC;IACxC,CAAC,MAAM;MAEL,MAAM,IAAI,CAACz4C,KAAK,CAAClG,MAAM,CAAC9B,0BAA0B,EAAE;QAClDtY,EAAE,EAAEyf,QAAQ;QACZhkB,KAAK,EAAE0M,cAAc,CAAC42D,SAAS;MACjC,CAAC,CAAC;IACJ;EACF;EAWAiN,+BAA+BA,CAC7BP,YAAoB,EACpBhsD,QAAkB,EAClBs/C,SAAoB,EACX;IACT,QAAQ0M,YAAY;MAClB,KAAK,MAAM;QAAE;UACX,OAAO,IAAI,CAAC5qD,SAAS,CAAC,CACpB,kBAAkB,EAClB;YAEEgV,UAAU,EAAE1tB,cAAc,CAAC42D,SAAS;UACrC,CAAA,CACF,CAAC;QACJ;MACA,KAAK,OAAO;QACV,OAAOA,SAAS,KAAY,EAAA;MAC9B;QACE,MAAM,IAAI,CAACz+C,KAAK,CAAClG,MAAM,CAAChC,0BAA0B,EAAE;UAAEpY,EAAE,EAAEyf;QAAS,CAAC,CAAC;IAAA;EAE3E;EAGAmsD,4BAA4BA,CAE1BrxD,IAAuC,EACZ;IAG3B,IAAI,CAACikB,SAAS,CAAC5V,KAAK,CAACkT,aAAa,CAAC,IAAI,EAAE,IAAI,CAAC0C,SAAS,CAAC7C,QAAQ,CAAC,CAAC;IAClE,MAAM/e,MAAM,GAAG,CAAC,IAAI,CAAC6oB,eAAe,EAAE,CAAC;IACvC,IAAI,CAACjH,SAAS,CAAC3V,IAAI,EAAE;IACrB,IAAI,IAAI,CAAC6T,qBAAqB,EAAE,EAAE;MAChC,IAAI,CAACpc,KAAK,CAAClG,MAAM,CAACjI,yBAAyB,EAAE;QAC3CnS,EAAE,EAAE,IAAI,CAACohB,KAAK,CAACoN,WAAW;MAC5B,CAAC,CAAC;IACJ;IACA,IAAI,CAACuO,MAAM,CAAU,EAAA,CAAA;IAErB,OAAO,IAAI,CAACyX,oBAAoB,CAACj6B,IAAI,EAAEqC,MAAM,EAAE,IAAI,CAAC;EACtD;EAIAuuD,OAAOA,CAEL5wD,IAA4B,EAC5BgC,OAAgB,EACA;IAChB,IAAI,CAAC2Y,YAAY,CAAC,eAAe,CAAC;IAClC,IAAI3Y,OAAO,EAAE;MACX,IAAI,CAAC2Y,YAAY,CAAC,oBAAoB,CAAC;IACzC;IACA3a,IAAI,CAACg5B,KAAK,GAAGh3B,OAAO;IACpB,IAAI,CAAC4H,IAAI,EAAE;IACX,MAAM8Z,SAAS,GAAG,IAAI,CAAC7c,KAAK,CAAC2M,MAAM;IACnC,IAAI,CAAC3M,KAAK,CAAC2M,MAAM,GAAG,EAAE;IACtB,IAAIxR,OAAO,EAAE;MAGX,IAAI,CAACiiB,SAAS,CAAC5V,KAAK,CAACwS,WAAW,CAAC;MACjC7gB,IAAI,CAACgD,IAAI,GAAG,IAAI,CAACsnD,UAAU,EAAE;MAC7B,IAAI,CAACrmC,SAAS,CAAC3V,IAAI,EAAE;IACvB,CAAC,MAAM;MACLtO,IAAI,CAACgD,IAAI,GAAG,IAAI,CAACsnD,UAAU,EAAE;IAC/B;IAEA,IAAI,CAACzjD,KAAK,CAAC2M,MAAM,GAAGkQ,SAAS;IAC7B,OAAO,IAAI,CAACnf,UAAU,CAACvE,IAAI,EAAE,cAAc,CAAC;EAC9C;EAGA0wD,UAAUA,CAAAA,EAAY;IACpB,MAAM1wD,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAW;IACtC,IAAI,CAACuF,IAAI,EAAE;IACX,IACE,IAAI,CAACsM,KAAK,IAAW,IACrB,CAAC,IAAI,CAAC3H,KAAK,CAACrK,gBAAgB,IAC5B,CAAC,IAAI,CAACtjB,OAAO,CAACb,uBAAuB,EACrC;MACA,IAAI,CAACgmB,KAAK,CAAClG,MAAM,CAACvF,eAAe,EAAE;QAAE7U,EAAE,EAAEua;MAAK,CAAC,CAAC;IAClD,CAAC,MAAM,IACL,CAAC,IAAI,CAACuO,KAAK,CAACX,UAAU,IACtB,CAAC,IAAI,CAAChtB,OAAO,CAACb,uBAAuB,EACrC;MACA,IAAI,CAACgmB,KAAK,CAAClG,MAAM,CAACtE,eAAe,EAAE;QAAE9V,EAAE,EAAEua;MAAK,CAAC,CAAC;IAClD;IAEA,IACE,CAAC,IAAI,CAACkW,KAAK,CAAA,EAAA,CAAW,IACtB,CAAC,IAAI,CAACA,KAAK,GAAa,IACxB,CAAC,IAAI,CAACA,KAAK,IAAQ,EACnB;MACA,IAAI,CAACnQ,KAAK,CAAClG,MAAM,CAACxD,gBAAgB,EAAE;QAAE5W,EAAE,EAAEua;MAAK,CAAC,CAAC;IACnD;IAEA,OAAO,IAAI,CAACuE,UAAU,CAACvE,IAAI,EAAE,OAAO,CAAC;EACvC;EAEAyD,gBAAgBA,CAAAA,EAAkB;IAChC,MAAMzD,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAiB;IAC5C,MAAMR,EAAE,GAAG,IAAI,CAACwhB,WAAW,CAGzBt2B,8BAA8B,CAAC,IAAI,CAAC8X,KAAK,CAAC3B,QAAQ,EAAE,CAAC,CAAC,CACvD;IACD,MAAMxiB,IAAI,GAAG,IAAI,CAACmkB,KAAK,CAACnX,KAAK;IAC7B,IAAI,CAACka,IAAI,EAAE;IACX5J,IAAI,CAAC6D,EAAE,GAAG,IAAI,CAAC4tB,gBAAgB,CAAC5tB,EAAE,EAAEnhB,IAAI,CAAC;IACzC,OAAO,IAAI,CAAC6hB,UAAU,CAACvE,IAAI,EAAE,aAAa,CAAC;EAC7C;EAEA6wD,2BAA2BA,CAAAA,EAEc;IACvC,MAAM7wD,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAyC;IAOpE,IAAI,CAACuF,IAAI,EAAE;IAEX,IAAI,IAAI,CAACqa,SAAS,CAAC7C,QAAQ,IAAI,IAAI,CAAClL,KAAK,CAAA,EAAA,CAAQ,EAAE;MACjD,MAAM07C,IAAI,GAAG,IAAI,CAACngC,gBAAgB,CAChC,IAAI,CAAC9pB,eAAe,CAAe3H,IAAI,CAAC,EACxC,UAAU,CACX;MACD,IAAI,CAAC4J,IAAI,EAAE;MAEX,IAAI,IAAI,CAACsM,KAAK,CAAA,GAAA,CAAU,EAAE;QACxB,IAAI,CAACyE,YAAY,CAAC,cAAc,CAAC;MAClC,CAAA,MAAM,IAAI,CAAC,IAAI,CAACrU,SAAS,CAAC,cAAc,CAAC,EAAE;QAE1C,IAAI,CAACnP,UAAU,EAAE;MACnB;MACA,OAAO,IAAI,CAAC06D,iBAAiB,CAC3B7xD,IAAI,EACJ4xD,IAAI,EACJ,MAAM,CACP;IACH;IACA,OAAO,IAAI,CAACE,aAAa,CAAC9xD,IAAI,CAAiC;EACjE;EAEA6xD,iBAAiBA,CACf7xD,IAA4B,EAC5B4xD,IAAkB,EAClB3e,YAAoB,EACJ;IAChBjzC,IAAI,CAAC4xD,IAAI,GAAGA,IAAI;IAEhB,MAAMh+C,WAAW,GAAG,IAAI,CAAC/M,KAAK,CAAC+M,WAAW;IAE1C5T,IAAI,CAACwjB,QAAQ,GAAG,IAAI,CAAC0H,eAAe,CAAC,IAAI,CAAC;IAE1C,IAAIlrB,IAAI,CAACwjB,QAAQ,CAAC9gC,IAAI,KAAKuwD,YAAY,IAAIr/B,WAAW,EAAE;MACtD,IAAI,CAAC7N,KAAK,CAAClG,MAAM,CAAC7D,uBAAuB,EAAE;QACzCvW,EAAE,EAAEua,IAAI,CAACwjB,QAAQ;QACjBvnB,MAAM,EAAE21D,IAAI,CAAClvE,IAAI;QACjBwZ,qBAAqB,EAAE+2C;MACzB,CAAC,CAAC;IACJ;IAEA,OAAO,IAAI,CAAC1uC,UAAU,CAACvE,IAAI,EAAE,cAAc,CAAC;EAC9C;EAGA2wD,uBAAuBA,CAAC3wD,IAA4B,EAAkB;IACpE,MAAM6D,EAAE,GAAG,IAAI,CAAC4tB,gBAAgB,CAC9B,IAAI,CAAC9pB,eAAe,CAAe3H,IAAI,CAAC,EACxC,QAAQ,CACT;IACD,IAAI,CAAC4J,IAAI,EAAE;IAEX,IAAI,IAAI,CAAC8X,YAAY,CAAA,GAAA,CAAU,EAAE;MAC/B,IAAI,CAAC,IAAI,CAACtY,QAAQ,EAAE;QAClB,IAAI,CAACrD,KAAK,CAAClG,MAAM,CAACpP,uBAAuB,EAAE;UAAEhL,EAAE,EAAEoe;QAAG,CAAC,CAAC;MACxD;MACA,IAAI,CAACyL,iBAAiB,GAAG,IAAI;IAC/B;IAEA,OAAO,IAAI,CAACuiD,iBAAiB,CAAC7xD,IAAI,EAAE6D,EAAE,EAAE,MAAM,CAAC;EACjD;EAEA2tB,kBAAkBA,CAChB9hC,KAAU,EACV2C,IAAe,EACf2N,IAAS,EACN;IACH,IAAI,CAACyhB,QAAQ,CAACzhB,IAAI,EAAE,UAAU,EAAEtQ,KAAK,CAAC;IACtC,IAAI,CAAC+xB,QAAQ,CAACzhB,IAAI,EAAE,KAAK,EAAE,IAAI,CAACyR,KAAK,CAAC2C,KAAK,CAACpU,IAAI,CAACrR,KAAK,EAAE,IAAI,CAACkY,KAAK,CAACjY,GAAG,CAAC,CAAC;IACxEoR,IAAI,CAACtQ,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACka,IAAI,EAAE;IACX,OAAO,IAAI,CAACrF,UAAU,CAAIvE,IAAI,EAAE3N,IAAI,CAAC;EACvC;EAEA6O,YAAYA,CAAmBxR,KAAU,EAAE2C,IAAe,EAAK;IAC7D,MAAM2N,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAE;IAC7B,OAAO,IAAI,CAACmtB,kBAAkB,CAAC9hC,KAAK,EAAE2C,IAAI,EAAE2N,IAAI,CAAC;EACnD;EAEAmB,kBAAkBA,CAACzR,KAAU,EAAE;IAC7B,OAAO,IAAI,CAACwR,YAAY,CAAkBxR,KAAK,EAAE,eAAe,CAAC;EACnE;EAEA0R,mBAAmBA,CAAC1R,KAAU,EAAE;IAC9B,OAAO,IAAI,CAACwR,YAAY,CAAmBxR,KAAK,EAAE,gBAAgB,CAAC;EACrE;EAEAmR,kBAAkBA,CAACnR,KAAU,EAAE;IAC7B,OAAO,IAAI,CAACwR,YAAY,CAAkBxR,KAAK,EAAE,eAAe,CAAC;EACnE;EAEAuR,mBAAmBA,CAACvR,KAAU,EAAE;IAC9B,OAAO,IAAI,CAACwR,YAAY,CAAmBxR,KAAK,EAAE,gBAAgB,CAAC;EACrE;EAEA4Q,kBAAkBA,CAAC5Q,KAIlB,EAAE;IACD,MAAMsQ,IAAI,GAAG,IAAI,CAACkB,YAAY,CAC5BxR,KAAK,CAACA,KAAK,EACX,eAAe,CAChB;IACDsQ,IAAI,CAACO,OAAO,GAAG7Q,KAAK,CAAC6Q,OAAO;IAC5BP,IAAI,CAACQ,KAAK,GAAG9Q,KAAK,CAAC8Q,KAAK;IACxB,OAAOR,IAAI;EACb;EAEAsB,mBAAmBA,CAAC5R,KAAc,EAAE;IAClC,MAAMsQ,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAoB;IAC/CrE,IAAI,CAACtQ,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACka,IAAI,EAAE;IACX,OAAO,IAAI,CAACrF,UAAU,CAACvE,IAAI,EAAE,gBAAgB,CAAC;EAChD;EAEAqB,gBAAgBA,CAAAA,EAAG;IACjB,MAAMrB,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAiB;IAC5C,IAAI,CAACuF,IAAI,EAAE;IACX,OAAO,IAAI,CAACrF,UAAU,CAACvE,IAAI,EAAE,aAAa,CAAC;EAC7C;EAGAu5B,kCAAkCA,CAEhCC,UAAmB,EACL;IACd,MAAMt0B,QAAQ,GAAG,IAAI,CAAC2B,KAAK,CAAC3B,QAAQ;IAEpC,IAAIiP,GAAG;IACP,IAAI,CAACvK,IAAI,EAAE;IACX,IAAI,CAACua,eAAe,CAAC9V,KAAK,CAACmS,iBAAiB,EAAE,CAAC;IAE/C,MAAM4iC,yBAAyB,GAAG,IAAI,CAACv8C,KAAK,CAAC+L,sBAAsB;IACnE,MAAM09C,6BAA6B,GAAG,IAAI,CAACzpD,KAAK,CAAC0M,0BAA0B;IAC3E,IAAI,CAAC1M,KAAK,CAAC+L,sBAAsB,GAAG,IAAI;IACxC,IAAI,CAAC/L,KAAK,CAAC0M,0BAA0B,GAAG,KAAK;IAE7C,MAAMw+C,aAAa,GAAG,IAAI,CAAClrD,KAAK,CAAC3B,QAAQ;IACzC,MAAMswB,QAAwB,GAAG,EAAE;IACnC,MAAMrwB,mBAAmB,GAAG,IAAIof,gBAAgB,EAAE;IAClD,IAAI2M,KAAK,GAAG,IAAI;IAChB,IAAI8gC,cAAc;IAClB,IAAIC,qBAAqB;IAEzB,OAAO,CAAC,IAAI,CAAC/7C,KAAK,IAAW,EAAE;MAC7B,IAAIgb,KAAK,EAAE;QACTA,KAAK,GAAG,KAAK;MACf,CAAC,MAAM;QACL,IAAI,CAAC1O,MAAM,CAETrd,EAAAA,EAAAA,mBAAmB,CAACke,qBAAqB,KAAK,IAAI,GAC9C,IAAI,GACJle,mBAAmB,CAACke,qBAAqB,CAC9C;QACD,IAAI,IAAI,CAACnN,KAAK,CAAA,EAAA,CAAW,EAAE;UACzB+7C,qBAAqB,GAAG,IAAI,CAACprD,KAAK,CAAC3B,QAAQ;UAC3C;QACF;MACF;MAEA,IAAI,IAAI,CAACgR,KAAK,CAAA,EAAA,CAAa,EAAE;QAC3B,MAAMg8C,kBAAkB,GAAG,IAAI,CAACrrD,KAAK,CAAC3B,QAAQ;QAC9C8sD,cAAc,GAAG,IAAI,CAACnrD,KAAK,CAAC3B,QAAQ;QACpCswB,QAAQ,CAAC/xC,IAAI,CACX,IAAI,CAAC0wC,cAAc,CAAC,IAAI,CAAC0c,gBAAgB,EAAE,EAAEqhB,kBAAkB,CAAC,CACjE;QAED,IAAI,CAAC,IAAI,CAAC9gB,mBAAmB,IAA4B,EAAE;UACzD;QACF;MACF,CAAC,MAAM;QACL5b,QAAQ,CAAC/xC,IAAI,CACX,IAAI,CAACgwC,uBAAuB,CAC1BtuB,mBAAmB,EACnB,IAAI,CAACgvB,cAAc,CACpB,CACF;MACH;IACF;IAEA,MAAMg+B,WAAW,GAAG,IAAI,CAACtrD,KAAK,CAACoB,aAAa;IAC5C,IAAI,CAACua,MAAM,CAAW,EAAA,CAAA;IAEtB,IAAI,CAAC3b,KAAK,CAAC+L,sBAAsB,GAAGwwC,yBAAyB;IAC7D,IAAI,CAACv8C,KAAK,CAAC0M,0BAA0B,GAAG+8C,6BAA6B;IAErE,IAAI8B,SAAS,GAAG,IAAI,CAAC/sC,WAAW,CAA4BngB,QAAQ,CAAC;IACrE,IACEs0B,UAAU,IACV,IAAI,CAACN,gBAAgB,CAAC1D,QAAQ,CAAC,KAC9B48B,SAAS,GAAG,IAAI,CAACn5B,UAAU,CAACm5B,SAAS,CAAC,CAAC,EACxC;MACA,IAAI,CAAC9tC,yBAAyB,CAACnf,mBAAmB,CAAC;MACnD,IAAI,CAACgf,eAAe,CAAC7D,iBAAiB,EAAE;MACxC,IAAI,CAAC6D,eAAe,CAAC7V,IAAI,EAAE;MAC3B,IAAI,CAAC2rB,oBAAoB,CAACm4B,SAAS,EAAE58B,QAAQ,EAAE,KAAK,CAAC;MAErD,OAAO48B,SAAS;IAClB;IACA,IAAI,CAACjuC,eAAe,CAAC7V,IAAI,EAAE;IAE3B,IAAI,CAACknB,QAAQ,CAACpnC,MAAM,EAAE;MACpB,IAAI,CAAC+I,UAAU,CAAC,IAAI,CAAC0P,KAAK,CAACC,eAAe,CAAC;IAC7C;IACA,IAAImrD,qBAAqB,EAAE,IAAI,CAAC96D,UAAU,CAAC86D,qBAAqB,CAAC;IACjE,IAAID,cAAc,EAAE,IAAI,CAAC76D,UAAU,CAAC66D,cAAc,CAAC;IACnD,IAAI,CAAChvC,qBAAqB,CAAC7d,mBAAmB,EAAE,IAAI,CAAC;IAErD,IAAI,CAACwrC,oBAAoB,CAACnb,QAAQ,EAA4B,IAAI,CAAC;IACnE,IAAIA,QAAQ,CAACpnC,MAAM,GAAG,CAAC,EAAE;MACvB+lB,GAAG,GAAG,IAAI,CAACkR,WAAW,CAAuB0sC,aAAa,CAAC;MAC3D59C,GAAG,CAACk1C,WAAW,GAAG7zB,QAAQ;MAE1B,IAAI,CAACjxB,UAAU,CAAC4P,GAAG,EAAE,oBAAoB,CAAC;MAC1C,IAAI,CAACnM,gBAAgB,CAACmM,GAAG,EAAEg+C,WAAW,CAAC;IACzC,CAAC,MAAM;MACLh+C,GAAG,GAAGqhB,QAAQ,CAAC,CAAC,CAAC;IACnB;IAEA,OAAO,IAAI,CAAC68B,eAAe,CACzBntD,QAAQ,EAERiP,GAAG,CACJ;EACH;EAEAk+C,eAAeA,CAACntD,QAAkB,EAAEzD,UAAwB,EAAgB;IAC1E,IAAI,CAAC,IAAI,CAAC7gB,OAAO,CAACP,8BAA8B,EAAE;MAChD,IAAI,CAACohC,QAAQ,CAAChgB,UAAU,EAAE,eAAe,EAAE,IAAI,CAAC;MAChD,IAAI,CAACggB,QAAQ,CAAChgB,UAAU,EAAE,YAAY,EAAEyD,QAAQ,CAAC1W,KAAK,CAAC;MAEvD,IAAI,CAACqjB,uBAAuB,CAC1BpQ,UAAU,EACVyD,QAAQ,CAAC1W,KAAK,EACd,IAAI,CAACqY,KAAK,CAACoB,aAAa,CAACzZ,KAAK,CAC/B;MAED,OAAOiT,UAAU;IACnB;IAEA,MAAM6wD,eAAe,GACnB,IAAI,CAACjtC,WAAW,CAA4BngB,QAAQ,CAAC;IACvDotD,eAAe,CAAC7wD,UAAU,GAAGA,UAAU;IACvC,OAAO,IAAI,CAAC8C,UAAU,CAAC+tD,eAAe,EAAE,yBAAyB,CAAC;EACpE;EAGAp5B,gBAAgBA,CAAC72B,MAAqB,EAAW;IAC/C,OAAO,CAAC,IAAI,CAAC6f,kBAAkB,EAAE;EACnC;EAEA+W,UAAUA,CACRj5B,IAAuC,EACQ;IAC/C,IAAI,IAAI,CAACyY,GAAG,CAAA,EAAA,CAAU,EAAE;MACtB,OAAOzY,IAAI;IACb;EACF;EAEAm0B,cAAcA,CACZn0B,IAAkB,EAElBkF,QAAkB,EACJ;IACd,OAAOlF,IAAI;EACb;EAEA+wD,mBAAmBA,CAAAA,EAAiD;IAClE,MAAM/wD,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAoC;IAC/D,IAAI,CAACuF,IAAI,EAAE;IACX,IAAI,IAAI,CAACsM,KAAK,CAAA,EAAA,CAAQ,EAAE;MAEtB,MAAM07C,IAAI,GAAG,IAAI,CAACngC,gBAAgB,CAChC,IAAI,CAAC9pB,eAAe,CAAe3H,IAAI,CAAC,EACxC,KAAK,CACN;MACD,IAAI,CAAC4J,IAAI,EAAE;MACX,MAAM2oD,QAAQ,GAAG,IAAI,CAACV,iBAAiB,CACrC7xD,IAAI,EACJ4xD,IAAI,EACJ,QAAQ,CACT;MAED,IACE,CAAC,IAAI,CAACrjD,KAAK,CAACN,kBAAkB,IAC9B,CAAC,IAAI,CAACM,KAAK,CAACT,OAAO,IACnB,CAAC,IAAI,CAACltB,OAAO,CAACf,6BAA6B,EAC3C;QACA,IAAI,CAACkmB,KAAK,CAAClG,MAAM,CAAC1E,mBAAmB,EAAE;UAAE1V,EAAE,EAAE8sE;QAAS,CAAC,CAAC;MAC1D;MAEA,OAAOA,QAAQ;IACjB;IAEA,OAAO,IAAI,CAACC,QAAQ,CAACxyD,IAAI,CAA4B;EACvD;EAQAwyD,QAAQA,CAAexyD,IAA6B,EAAmB;IACrE,IAAI,CAAC+5B,cAAc,CAAC/5B,IAAI,CAAC;IAEzB,IAAI,IAAI,CAACyY,GAAG,CAAA,EAAA,CAAW,EAAE;MACvB,MAAMhU,IAAI,GAAG,IAAI,CAACguD,aAAa,CAAW,EAAA,CAAA;MAC1C,IAAI,CAACh9B,gBAAgB,CAAChxB,IAAI,CAAC;MAE3BzE,IAAI,CAACqG,SAAS,GAAG5B,IAAI;IACvB,CAAC,MAAM;MACLzE,IAAI,CAACqG,SAAS,GAAG,EAAE;IACrB;IAEA,OAAO,IAAI,CAAC9B,UAAU,CAACvE,IAAI,EAAE,eAAe,CAAC;EAC/C;EAEA+5B,cAAcA,CAAe/5B,IAA6B,EAAQ;IAChEA,IAAI,CAACmG,MAAM,GAAG,IAAI,CAAC6pD,eAAe,EAAE;IACpC,IAAIhwD,IAAI,CAACmG,MAAM,CAAC9T,IAAI,KAAK,QAAQ,EAAE;MACjC,IAAI,CAAC0T,KAAK,CAAClG,MAAM,CAACjK,0BAA0B,EAAE;QAAEnQ,EAAE,EAAEua,IAAI,CAACmG;MAAO,CAAC,CAAC;IACpE;EACF;EAIAusD,oBAAoBA,CAACC,QAAiB,EAAqB;IACzD,MAAM;MAAEhkE,KAAK;MAAEuW,QAAQ;MAAEtW,GAAG;MAAEc;KAAO,GAAG,IAAI,CAACmX,KAAK;IAClD,MAAM+rD,SAAS,GAAGjkE,KAAK,GAAG,CAAC;IAC3B,MAAMkkE,IAAI,GAAG,IAAI,CAACxtC,WAAW,CAC3Bt2B,8BAA8B,CAACmW,QAAQ,EAAE,CAAC,CAAC,CAC5C;IACD,IAAIxV,KAAK,KAAK,IAAI,EAAE;MAClB,IAAI,CAACijE,QAAQ,EAAE;QACb,IAAI,CAAC5sD,KAAK,CAAClG,MAAM,CAACpJ,6BAA6B,EAAE;UAE/ChR,EAAE,EAAEsJ,8BAA8B,CAChC,IAAI,CAAC8X,KAAK,CAACgN,6BAA6B,EACxC,CAAC;QAEL,CAAC,CAAC;MACJ;IACF;IAEA,MAAMi/C,MAAM,GAAG,IAAI,CAAC58C,KAAK,CAAiB,EAAA,CAAA;IAC1C,MAAM68C,SAAS,GAAGD,MAAM,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;IAClC,MAAME,OAAO,GAAGpkE,GAAG,GAAGmkE,SAAS;IAC/BF,IAAI,CAACnjE,KAAK,GAAG;MACXgS,GAAG,EAAE,IAAI,CAAC+P,KAAK,CAAC2C,KAAK,CAACw+C,SAAS,EAAEI,OAAO,CAAC,CAACr2C,OAAO,CAAC,QAAQ,EAAE,IAAI,CAAC;MACjEs2C,MAAM,EAAEvjE,KAAK,KAAK,IAAI,GAAG,IAAI,GAAGA,KAAK,CAAC0kB,KAAK,CAAC,CAAC,EAAE2+C,SAAS;KACzD;IACDF,IAAI,CAACK,IAAI,GAAGJ,MAAM;IAClB,IAAI,CAAClpD,IAAI,EAAE;IACX,MAAM2kD,YAAY,GAAG,IAAI,CAAChqD,UAAU,CAACsuD,IAAI,EAAE,iBAAiB,CAAC;IAC7D,IAAI,CAAC7qD,gBAAgB,CACnBumD,YAAY,EACZx/D,8BAA8B,CAAC,IAAI,CAAC8X,KAAK,CAACoB,aAAa,EAAE8qD,SAAS,CAAC,CACpE;IACD,OAAOxE,YAAY;EACrB;EAGApQ,aAAaA,CAAewU,QAAiB,EAAqB;IAChE,MAAM3yD,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAqB;IAChDrE,IAAI,CAACqpD,WAAW,GAAG,EAAE;IACrB,IAAI8J,MAAM,GAAG,IAAI,CAACT,oBAAoB,CAACC,QAAQ,CAAC;IAChD3yD,IAAI,CAACozD,MAAM,GAAG,CAACD,MAAM,CAAC;IACtB,OAAO,CAACA,MAAM,CAACD,IAAI,EAAE;MACnBlzD,IAAI,CAACqpD,WAAW,CAAC5lE,IAAI,CAAC,IAAI,CAAC26D,yBAAyB,EAAE,CAAC;MACvD,IAAI,CAAC9gC,wBAAwB,EAAE;MAC/Btd,IAAI,CAACozD,MAAM,CAAC3vE,IAAI,CAAE0vE,MAAM,GAAG,IAAI,CAACT,oBAAoB,CAACC,QAAQ,CAAC,CAAE;IAClE;IACA,OAAO,IAAI,CAACpuD,UAAU,CAACvE,IAAI,EAAE,iBAAiB,CAAC;EACjD;EAGAo+C,yBAAyBA,CAAAA,EAA6B;IACpD,OAAO,IAAI,CAACxzB,eAAe,EAAE;EAC/B;EAsBAomB,eAAeA,CAEbnb,KAAgB,EAChB/wB,SAAkB,EAClBkoD,QAAyB,EACzB7nD,mBAA6C,EAC1C;IACH,IAAI6nD,QAAQ,EAAE;MACZ,IAAI,CAACryC,YAAY,CAAC,gBAAgB,CAAC;IACrC;IACA,MAAM21C,6BAA6B,GAAG,IAAI,CAACzpD,KAAK,CAAC0M,0BAA0B;IAC3E,IAAI,CAAC1M,KAAK,CAAC0M,0BAA0B,GAAG,KAAK;IAC7C,MAAM8/C,QAAa,GAAGvyE,MAAM,CAACmkC,MAAM,CAAC,IAAI,CAAC;IACzC,IAAIiM,KAAK,GAAG,IAAI;IAChB,MAAMlxB,IAAI,GAAG,IAAI,CAACqE,SAAS,EAExB;IAEHrE,IAAI,CAAClQ,UAAU,GAAG,EAAE;IACpB,IAAI,CAAC8Z,IAAI,EAAE;IAEX,OAAO,CAAC,IAAI,CAACsM,KAAK,CAAC2f,KAAK,CAAC,EAAE;MACzB,IAAI3E,KAAK,EAAE;QACTA,KAAK,GAAG,KAAK;MACf,CAAC,MAAM;QACL,IAAI,CAAC1O,MAAM,CAAU,EAAA,CAAA;QACrB,IAAI,IAAI,CAACtM,KAAK,CAAC2f,KAAK,CAAC,EAAE;UACrB,IAAI,CAAC06B,2BAA2B,CAE9BvwD,IAAI,CACL;UACD;QACF;MACF;MAEA,IAAI6E,IAAI;MACR,IAAIC,SAAS,EAAE;QACbD,IAAI,GAAG,IAAI,CAAC2sC,oBAAoB,EAAE;MACpC,CAAC,MAAM;QACL3sC,IAAI,GAAG,IAAI,CAACyuD,uBAAuB,CAACnuD,mBAAmB,CAAC;QACxD,IAAI,CAAC4nD,UAAU,CAACloD,IAAI,EAAEmoD,QAAQ,EAAEqG,QAAQ,EAAEluD,mBAAmB,CAAC;MAChE;MAEA,IACE6nD,QAAQ,IACR,CAAC,IAAI,CAAC9qD,gBAAgB,CAAC2C,IAAI,CAAC,IAC5BA,IAAI,CAACxS,IAAI,KAAK,eAAe,EAC7B;QACA,IAAI,CAAC0T,KAAK,CAAClG,MAAM,CAACtI,qBAAqB,EAAE;UAAE9R,EAAE,EAAEof;QAAK,CAAC,CAAC;MACxD;MAGA,IAAIA,IAAI,CAACG,SAAS,EAAE;QAClB,IAAI,CAACyc,QAAQ,CAAC5c,IAAI,EAAE,WAAW,EAAE,IAAI,CAAC;MACxC;MAGA7E,IAAI,CAAClQ,UAAU,CAACrM,IAAI,CAACohB,IAAI,CAAC;IAC5B;IAEA,IAAI,CAAC+E,IAAI,EAAE;IAEX,IAAI,CAAC/C,KAAK,CAAC0M,0BAA0B,GAAG+8C,6BAA6B;IACrE,IAAIj+D,IAAI,GAAG,kBAAkB;IAC7B,IAAIyS,SAAS,EAAE;MACbzS,IAAI,GAAG,eAAe;IACvB,CAAA,MAAM,IAAI26D,QAAQ,EAAE;MACnB36D,IAAI,GAAG,kBAAkB;IAC3B;IAEA,OAAO,IAAI,CAACkS,UAAU,CAACvE,IAAI,EAAE3N,IAAI,CAAC;EACpC;EAEAk+D,2BAA2BA,CAACvwD,IAAY,EAAQ;IAC9C,IAAI,CAACyhB,QAAQ,CAACzhB,IAAI,EAAE,eAAe,EAAE,IAAI,CAAC6G,KAAK,CAAC4M,YAAY,CAAC;IAC7D,IAAI,CAACgO,QAAQ,CAACzhB,IAAI,EAAE,kBAAkB,EAAE,IAAI,CAAC6G,KAAK,CAACC,eAAe,EAAE,KAAK,CAAC;EAC5E;EAKAysD,wBAAwBA,CAAC1uD,IAA8B,EAAW;IAChE,OACE,CAACA,IAAI,CAACP,QAAQ,IACdO,IAAI,CAAChkB,GAAG,CAACwR,IAAI,KAAK,YAAY,KAC7B,IAAI,CAACkxB,qBAAqB,EAAE,IAC3B,IAAI,CAACrN,KAAK,CAAa,CAAA,CAAA,IACvB,IAAI,CAACA,KAAK,CAAA,EAAA,CAAS,CAAC;EAE1B;EAGAo9C,uBAAuBA,CAErBnuD,mBAA6C,EACX;IAClC,IAAIwB,UAAU,GAAG,EAAE;IACnB,IAAI,IAAI,CAACuP,KAAK,CAAA,EAAA,CAAO,EAAE;MACrB,IAAI,IAAI,CAAC5P,SAAS,CAAC,YAAY,CAAC,EAAE;QAChC,IAAI,CAACP,KAAK,CAAClG,MAAM,CAACzD,4BAA4B,EAAE;UAC9C3W,EAAE,EAAE,IAAI,CAACohB,KAAK,CAAC3B;QACjB,CAAC,CAAC;MACJ;MAIA,OAAO,IAAI,CAACgR,KAAK,CAAA,EAAA,CAAO,EAAE;QACxBvP,UAAU,CAACljB,IAAI,CAAC,IAAI,CAAC4tD,cAAc,EAAE,CAAC;MACxC;IACF;IAEA,MAAMxsC,IAAI,GAAG,IAAI,CAACR,SAAS,EAAoB;IAC/C,IAAIrC,OAAO,GAAG,KAAK;IACnB,IAAI+C,UAAU,GAAG,KAAK;IACtB,IAAIG,QAAQ;IAEZ,IAAI,IAAI,CAACgR,KAAK,CAAA,EAAA,CAAa,EAAE;MAC3B,IAAIvP,UAAU,CAACvY,MAAM,EAAE,IAAI,CAAC+I,UAAU,EAAE;MACxC,OAAO,IAAI,CAACy5C,WAAW,EAAE;IAC3B;IAEA,IAAIjqC,UAAU,CAACvY,MAAM,EAAE;MACrByW,IAAI,CAAC8B,UAAU,GAAGA,UAAU;MAC5BA,UAAU,GAAG,EAAE;IACjB;IAEA9B,IAAI,CAACzC,MAAM,GAAG,KAAK;IAEnB,IAAI+C,mBAAmB,EAAE;MACvBD,QAAQ,GAAG,IAAI,CAAC2B,KAAK,CAAC3B,QAAQ;IAChC;IAEA,IAAI9B,WAAW,GAAG,IAAI,CAACqV,GAAG,CAAS,EAAA,CAAA;IACnC,IAAI,CAACie,+BAA+B,CAAC7xB,IAAI,CAAC;IAC1C,MAAM+O,WAAW,GAAG,IAAI,CAAC/M,KAAK,CAAC+M,WAAW;IAC1C,MAAM/yB,GAAG,GAAG,IAAI,CAAC4wD,iBAAiB,CAAC5sC,IAAI,EAAEM,mBAAmB,CAAC;IAE7D,IAAI,CAAC/B,WAAW,IAAI,CAACwQ,WAAW,IAAI,IAAI,CAAC2/C,wBAAwB,CAAC1uD,IAAI,CAAC,EAAE;MACvE,MAAM2uD,OAAO,GAAG3yE,GAAG,CAAC6B,IAAI;MAGxB,IAAI8wE,OAAO,KAAK,OAAO,IAAI,CAAC,IAAI,CAACrxC,qBAAqB,EAAE,EAAE;QACxDngB,OAAO,GAAG,IAAI;QACd,IAAI,CAAC4P,iCAAiC,CAAC/wB,GAAG,CAAC;QAC3CuiB,WAAW,GAAG,IAAI,CAACqV,GAAG,CAAS,EAAA,CAAA;QAC/B,IAAI,CAACg5B,iBAAiB,CAAC5sC,IAAI,CAAC;MAC9B;MAGA,IAAI2uD,OAAO,KAAK,KAAK,IAAIA,OAAO,KAAK,KAAK,EAAE;QAC1CzuD,UAAU,GAAG,IAAI;QACjB,IAAI,CAAC6M,iCAAiC,CAAC/wB,GAAG,CAAC;QAC3CgkB,IAAI,CAACpS,IAAI,GAAG+gE,OAAO;QACnB,IAAI,IAAI,CAACt9C,KAAK,CAAA,EAAA,CAAS,EAAE;UACvB9S,WAAW,GAAG,IAAI;UAClB,IAAI,CAAC2C,KAAK,CAAClG,MAAM,CAACrN,mBAAmB,EAAE;YACrC/M,EAAE,EAAE,IAAI,CAACohB,KAAK,CAACoN,WAAW,EAAE;YAC5BxhB,IAAI,EAAE+gE;UACR,CAAC,CAAC;UACF,IAAI,CAAC5pD,IAAI,EAAE;QACb;QACA,IAAI,CAAC6nC,iBAAiB,CAAC5sC,IAAI,CAAC;MAC9B;IACF;IAEA,OAAO,IAAI,CAAC8xB,iBAAiB,CAC3B9xB,IAAI,EACJK,QAAQ,EACR9B,WAAW,EACXpB,OAAO,EACP,KAAK,EACL+C,UAAU,EACVI,mBAAmB,CACpB;EACH;EAEAsiD,iCAAiCA,CAC/BrlD,MAAsC,EAC9B;IACR,OAAOA,MAAM,CAAC3P,IAAI,KAAK,KAAK,GAAG,CAAC,GAAG,CAAC;EACtC;EAGA0P,4BAA4BA,CAACC,MAAsC,EAAE;IACnE,OAAOA,MAAM,CAACC,MAAM;EACtB;EAIAo0B,uBAAuBA,CAACr0B,MAAsC,EAAQ;IAAA,IAAAqxD,OAAA;IACpE,MAAM/iC,UAAU,GAAG,IAAI,CAAC+2B,iCAAiC,CAACrlD,MAAM,CAAC;IACjE,MAAMC,MAAM,GAAG,IAAI,CAACF,4BAA4B,CAACC,MAAM,CAAC;IAExD,IAAIC,MAAM,CAACjU,MAAM,KAAKsiC,UAAU,EAAE;MAChC,IAAI,CAAC3qB,KAAK,CACR3D,MAAM,CAAC3P,IAAI,KAAK,KAAK,GAAGoN,MAAM,CAAC3M,cAAc,GAAG2M,MAAM,CAAC1M,cAAc,EACrE;QAAE1N,EAAE,EAAE2c;MAAO,CAAC,CACf;IACH;IAEA,IACEA,MAAM,CAAC3P,IAAI,KAAK,KAAK,IACrB,CAAA,CAAAghE,OAAA,GAAApxD,MAAM,CAACA,MAAM,CAACjU,MAAM,GAAG,CAAC,CAAC,KAAA,IAAA,GAAA,KAAA,CAAA,GAAzBqlE,OAAA,CAA2BphE,IAAI,MAAK,aAAa,EACjD;MACA,IAAI,CAAC0T,KAAK,CAAClG,MAAM,CAACzM,sBAAsB,EAAE;QAAE3N,EAAE,EAAE2c;MAAO,CAAC,CAAC;IAC3D;EACF;EAGAwC,iBAAiBA,CAEfC,IAA4B,EAC5BzB,WAAoB,EACpBpB,OAAgB,EAChB8C,SAAkB,EAClBC,UAAmB,EACgB;IACnC,IAAIA,UAAU,EAAE;MAEd,MAAM2uD,YAAY,GAAG,IAAI,CAACnwD,WAAW,CACnCsB,IAAI,EAGJzB,WAAW,EACG,KAAK,EACC,KAAK,EACzB,KAAK,EACL,cAAc,CACf;MACD,IAAI,CAACqzB,uBAAuB,CAACi9B,YAAY,CAAC;MAC1C,OAAOA,YAAY;IACrB;IAEA,IAAI1xD,OAAO,IAAIoB,WAAW,IAAI,IAAI,CAAC8S,KAAK,IAAW,EAAE;MACnD,IAAIpR,SAAS,EAAE,IAAI,CAAC3N,UAAU,EAAE;MAChC0N,IAAI,CAACpS,IAAI,GAAG,QAAQ;MACpBoS,IAAI,CAACzC,MAAM,GAAG,IAAI;MAClB,OAAO,IAAI,CAACmB,WAAW,CACrBsB,IAAI,EACJzB,WAAW,EACXpB,OAAO,EACa,KAAK,EACzB,KAAK,EACL,cAAc,CACf;IACH;EACF;EAIAiD,mBAAmBA,CAEjBJ,IAA8B,EAC9BK,QAAqC,EACrCJ,SAAkB,EAClBK,mBAA6C,EACR;IACrCN,IAAI,CAACG,SAAS,GAAG,KAAK;IAEtB,IAAI,IAAI,CAACyT,GAAG,CAAA,EAAA,CAAU,EAAE;MACtB5T,IAAI,CAACnV,KAAK,GAAGoV,SAAS,GAClB,IAAI,CAAC+xB,iBAAiB,CAAC,IAAI,CAAChwB,KAAK,CAAC3B,QAAQ,CAAC,GAC3C,IAAI,CAACuuB,uBAAuB,CAACtuB,mBAAmB,CAAC;MAErD,OAAO,IAAI,CAACZ,UAAU,CAACM,IAAI,EAAE,gBAAgB,CAAC;IAChD;IAEA,IAAI,CAACA,IAAI,CAACP,QAAQ,IAAIO,IAAI,CAAChkB,GAAG,CAACwR,IAAI,KAAK,YAAY,EAAE;MAKpD,IAAI,CAAC0lC,iBAAiB,CAAClzB,IAAI,CAAChkB,GAAG,CAAC6B,IAAI,EAAEmiB,IAAI,CAAChkB,GAAG,CAACge,GAAG,CAAClQ,KAAK,EAAE,IAAI,EAAE,KAAK,CAAC;MAEtE,IAAImW,SAAS,EAAE;QACbD,IAAI,CAACnV,KAAK,GAAG,IAAI,CAACmnC,iBAAiB,CACjC3xB,QAAQ,EACR6f,eAAe,CAAClgB,IAAI,CAAChkB,GAAG,CAAC,CAC1B;MACF,CAAA,MAAM,IAAI,IAAI,CAACq1B,KAAK,IAAO,EAAE;QAC5B,MAAMgN,kBAAkB,GAAG,IAAI,CAACrc,KAAK,CAAC3B,QAAQ;QAC9C,IAAIC,mBAAmB,IAAI,IAAI,EAAE;UAC/B,IAAIA,mBAAmB,CAAC+d,kBAAkB,KAAK,IAAI,EAAE;YACnD/d,mBAAmB,CAAC+d,kBAAkB,GAAGA,kBAAkB;UAC7D;QACF,CAAC,MAAM;UACL,IAAI,CAACnd,KAAK,CAAClG,MAAM,CAACzJ,2BAA2B,EAAE;YAC7C3Q,EAAE,EAAEy9B;UACN,CAAC,CAAC;QACJ;QACAre,IAAI,CAACnV,KAAK,GAAG,IAAI,CAACmnC,iBAAiB,CACjC3xB,QAAQ,EACR6f,eAAe,CAAClgB,IAAI,CAAChkB,GAAG,CAAC,CAC1B;MACH,CAAC,MAAM;QACLgkB,IAAI,CAACnV,KAAK,GAAGq1B,eAAe,CAAClgB,IAAI,CAAChkB,GAAG,CAAC;MACxC;MACAgkB,IAAI,CAACG,SAAS,GAAG,IAAI;MAErB,OAAO,IAAI,CAACT,UAAU,CAACM,IAAI,EAAE,gBAAgB,CAAC;IAChD;EACF;EAEA8xB,iBAAiBA,CAEf9xB,IAA+C,EAC/CK,QAAqC,EACrC9B,WAAoB,EACpBpB,OAAgB,EAChB8C,SAAkB,EAClBC,UAAmB,EACnBI,mBAA6C,EACV;IACnC,MAAMnF,IAAI,GACR,IAAI,CAAC4E,iBAAiB,CACpBC,IAAI,EACJzB,WAAW,EACXpB,OAAO,EACP8C,SAAS,EACTC,UAAU,CACX,IACD,IAAI,CAACE,mBAAmB,CACtBJ,IAAI,EACJK,QAAQ,EACRJ,SAAS,EACTK,mBAAmB,CACpB;IAEH,IAAI,CAACnF,IAAI,EAAE,IAAI,CAAC7I,UAAU,EAAE;IAE5B,OAAO6I,IAAI;EACb;EAKAyxC,iBAAiBA,CAEf5sC,IAE4B,EAC5BM,mBAA6C,EAChB;IAC7B,IAAI,IAAI,CAACsT,GAAG,CAAA,CAAA,CAAa,EAAE;MACxB5T,IAAI,CAAmCP,QAAQ,GAAG,IAAI;MACvDO,IAAI,CAAChkB,GAAG,GAAG,IAAI,CAAC4yC,uBAAuB,EAAE;MACzC,IAAI,CAACjR,MAAM,CAAa,CAAA,CAAA;IAC1B,CAAC,MAAM;MAEL,MAAM;QAAEnwB,IAAI;QAAE3C;OAAO,GAAG,IAAI,CAACmX,KAAK;MAClC,IAAIhmB,GAAG;MAEP,IAAIkM,0BAA0B,CAACsF,IAAI,CAAC,EAAE;QACpCxR,GAAG,GAAG,IAAI,CAACqqC,eAAe,CAAC,IAAI,CAAC;MAClC,CAAC,MAAM;QACL,QAAQ74B,IAAI;UACV,KAAA,GAAA;YACExR,GAAG,GAAG,IAAI,CAACugB,mBAAmB,CAAC1R,KAAK,CAAC;YACrC;UACF,KAAA,GAAA;YACE7O,GAAG,GAAG,IAAI,CAACsgB,kBAAkB,CAACzR,KAAK,CAAC;YACpC;UACF,KAAA,GAAA;YACE7O,GAAG,GAAG,IAAI,CAACggB,kBAAkB,CAACnR,KAAK,CAAC;YACpC;UACF,KAAA,GAAA;YACE7O,GAAG,GAAG,IAAI,CAACogB,mBAAmB,CAACvR,KAAK,CAAC;YACrC;UACF,KAAA,GAAA;YAAqB;cAEnB,MAAM0zB,aAAa,GAAG,IAAI,CAACvc,KAAK,CAAC3B,QAAQ;cACzC,IAAIC,mBAAmB,IAAI,IAAI,EAAE;gBAC/B,IAAIA,mBAAmB,CAACie,aAAa,KAAK,IAAI,EAAE;kBAC9Cje,mBAAmB,CAACie,aAAa,GAAGA,aAAa;gBACnD;cACF,CAAC,MAAM;gBACL,IAAI,CAACrd,KAAK,CAAClG,MAAM,CAACxE,sBAAsB,EAAE;kBACxC5V,EAAE,EAAE29B;gBACN,CAAC,CAAC;cACJ;cACAviC,GAAG,GAAG,IAAI,CAAC4iB,gBAAgB,EAAE;cAC7B;YACF;UACA;YACE,IAAI,CAACtM,UAAU,EAAE;QAAA;MAEvB;MACC0N,IAAI,CAAShkB,GAAG,GAAGA,GAAG;MACvB,IAAIwR,IAAI,QAAmB,EAAE;QAE3BwS,IAAI,CAACP,QAAQ,GAAG,KAAK;MACvB;IACF;IAEA,OAAOO,IAAI,CAAChkB,GAAG;EACjB;EAIAkhB,YAAYA,CAAC/B,IAAoC,EAAEgC,OAAgB,EAAQ;IACzEhC,IAAI,CAAC6D,EAAE,GAAG,IAAI;IACd7D,IAAI,CAAC2zD,SAAS,GAAG,KAAK;IACtB3zD,IAAI,CAACg5B,KAAK,GAAGh3B,OAAO;EACtB;EAIAuB,WAAWA,CAETvD,IAAe,EACfoD,WAAoB,EACpBpB,OAAgB,EAChBqB,aAAsB,EACtBa,gBAAyB,EACzB7R,IAAe,EACf8R,YAAqB,GAAG,KAAK,EAC1B;IACH,IAAI,CAACpC,YAAY,CAAC/B,IAAI,EAAEgC,OAAO,CAAC;IAChChC,IAAI,CAAC2zD,SAAS,GAAGvwD,WAAW;IAC5B,IAAI,CAACmL,KAAK,CAACF,KAAK,CACdnE,cAAc,GACZG,WAAW,IACVlG,YAAY,GAAGoG,WAAW,GAAG,CAAC,CAAC,IAC/BrG,gBAAgB,GAAGoG,kBAAkB,GAAG,CAAC,CAAC,CAC9C;IACD,IAAI,CAAC2Z,SAAS,CAAC5V,KAAK,CAACkT,aAAa,CAACvf,OAAO,EAAEhC,IAAI,CAAC2zD,SAAS,CAAC,CAAC;IAC5D,IAAI,CAAC17B,mBAAmB,CAACj4B,IAAI,EAAEqD,aAAa,CAAC;IAC7C,MAAMkrD,YAAY,GAAG,IAAI,CAACh8B,0BAA0B,CAACvyB,IAAI,EAAE3N,IAAI,EAAE,IAAI,CAAC;IACtE,IAAI,CAAC4xB,SAAS,CAAC3V,IAAI,EAAE;IACrB,IAAI,CAACC,KAAK,CAACD,IAAI,EAAE;IAEjB,OAAOigD,YAAY;EACrB;EAKA34B,cAAcA,CAEZC,KAAgB,EAChBC,YAAqB,EACrBC,OAAgB,EAChB5wB,mBAA6C,EACN;IACvC,IAAI4wB,OAAO,EAAE;MACX,IAAI,CAACpb,YAAY,CAAC,gBAAgB,CAAC;IACrC;IACA,MAAM21C,6BAA6B,GAAG,IAAI,CAACzpD,KAAK,CAAC0M,0BAA0B;IAC3E,IAAI,CAAC1M,KAAK,CAAC0M,0BAA0B,GAAG,KAAK;IAC7C,MAAMvT,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAyC;IACpE,IAAI,CAACuF,IAAI,EAAE;IACX5J,IAAI,CAACuQ,QAAQ,GAAG,IAAI,CAACkiD,aAAa,CAChC58B,KAAK,EACY,CAACE,OAAO,EACzB5wB,mBAAmB,EAEnBnF,IAAI,CACL;IACD,IAAI,CAAC6G,KAAK,CAAC0M,0BAA0B,GAAG+8C,6BAA6B;IACrE,OAAO,IAAI,CAAC/rD,UAAU,CACpBvE,IAAI,EACJ+1B,OAAO,GAAG,iBAAiB,GAAG,iBAAiB,CAChD;EACH;EAKAkE,oBAAoBA,CAElBj6B,IAAuC,EACvCqC,MAAyC,EACzCL,OAAgB,EAChBgyB,gBAAkC,EACP;IAC3B,IAAI,CAACzlB,KAAK,CAACF,KAAK,CAACnE,cAAc,GAAGC,WAAW,CAAC;IAC9C,IAAI3J,KAAK,GAAG+gB,aAAa,CAACvf,OAAO,EAAE,KAAK,CAAC;IAIzC,IAAI,CAAC,IAAI,CAACkU,KAAK,CAAA,CAAA,CAAW,IAAI,IAAI,CAAC+N,SAAS,CAAC3C,KAAK,EAAE;MAClD9gB,KAAK,IAAIugB,QAAQ;IACnB;IACA,IAAI,CAACkD,SAAS,CAAC5V,KAAK,CAAC7N,KAAK,CAAC;IAC3B,IAAI,CAACuB,YAAY,CAAC/B,IAAI,EAAEgC,OAAO,CAAC;IAChC,MAAMohD,yBAAyB,GAAG,IAAI,CAACv8C,KAAK,CAAC+L,sBAAsB;IAEnE,IAAIvQ,MAAM,EAAE;MACV,IAAI,CAACwE,KAAK,CAAC+L,sBAAsB,GAAG,IAAI;MACxC,IAAI,CAACumB,0BAA0B,CAACn5B,IAAI,EAAEqC,MAAM,EAAE2xB,gBAAgB,CAAC;IACjE;IACA,IAAI,CAACntB,KAAK,CAAC+L,sBAAsB,GAAG,KAAK;IACzC,IAAI,CAAC7O,iBAAiB,CAAC/D,IAAI,EAAE,IAAI,CAAC;IAElC,IAAI,CAACikB,SAAS,CAAC3V,IAAI,EAAE;IACrB,IAAI,CAACC,KAAK,CAACD,IAAI,EAAE;IACjB,IAAI,CAACzH,KAAK,CAAC+L,sBAAsB,GAAGwwC,yBAAyB;IAE7D,OAAO,IAAI,CAAC7+C,UAAU,CAACvE,IAAI,EAAE,yBAAyB,CAAC;EACzD;EAEAm5B,0BAA0BA,CACxBn5B,IAAuC,EACvCqC,MAAsB,EACtB2xB,gBAAkC,EAC5B;IACN,IAAI,CAACD,gBAAgB,CAAC1xB,MAAM,EAAE2xB,gBAAgB,EAAE,KAAK,CAAC;IACtDh0B,IAAI,CAACqC,MAAM,GAAGA,MAA+C;EAC/D;EAEAkwB,0BAA0BA,CAMxBvyB,IAAe,EAAE3N,IAAe,EAAE4R,QAAiB,GAAG,KAAK,EAAK;IAEhE,IAAI,CAACF,iBAAiB,CAAC/D,IAAI,EAAE,KAAK,EAAEiE,QAAQ,CAAC;IAC7C,OAAO,IAAI,CAACM,UAAU,CAACvE,IAAI,EAAE3N,IAAI,CAAC;EACpC;EAGA0R,iBAAiBA,CAEf/D,IAAwB,EACxBgE,eAAgC,EAChCC,QAAiB,GAAG,KAAK,EACnB;IACN,MAAM2vD,YAAY,GAAG5vD,eAAe,IAAI,CAAC,IAAI,CAACkS,KAAK,CAAW,CAAA,CAAA;IAC9D,IAAI,CAACiO,eAAe,CAAC9V,KAAK,CAACqS,kBAAkB,EAAE,CAAC;IAEhD,IAAIkzC,YAAY,EAAE;MAEf5zD,IAAI,CAAuCgD,IAAI,GAC9C,IAAI,CAACwwB,gBAAgB,EAAE;MACzB,IAAI,CAACS,WAAW,CAACj0B,IAAI,EAAE,KAAK,EAAEgE,eAAe,EAAE,KAAK,CAAC;IACvD,CAAC,MAAM;MACL,MAAM0mD,SAAS,GAAG,IAAI,CAAC7jD,KAAK,CAACiC,MAAM;MAGnC,MAAM4a,SAAS,GAAG,IAAI,CAAC7c,KAAK,CAAC2M,MAAM;MACnC,IAAI,CAAC3M,KAAK,CAAC2M,MAAM,GAAG,EAAE;MAItB,IAAI,CAACyQ,SAAS,CAAC5V,KAAK,CAAC,IAAI,CAAC4V,SAAS,CAAC/C,YAAY,EAAE,GAAGJ,YAAY,CAAC;MAClE9gB,IAAI,CAACgD,IAAI,GAAG,IAAI,CAACsnD,UAAU,CACzB,IAAI,EACJ,KAAK,EAEJuJ,sBAA+B,IAAK;QACnC,MAAMC,SAAS,GAAG,CAAC,IAAI,CAACC,iBAAiB,CAAC/zD,IAAI,CAACqC,MAAM,CAAC;QAEtD,IAAIwxD,sBAAsB,IAAIC,SAAS,EAAE;UAEvC,IAAI,CAAC/tD,KAAK,CAAClG,MAAM,CAACxK,4BAA4B,EAAE;YAC9C5P,EAAE,EAEA,CAACua,IAAI,CAACvN,IAAI,KAAK,QAAQ,IAAIuN,IAAI,CAACvN,IAAI,KAAK,aAAa,KAEtD,CAAC,CAACuN,IAAI,CAACnf,GAAG,GAENmf,IAAI,CAACnf,GAAG,CAACge,GAAG,CAACjQ,GAAG,GAChBoR;UACR,CAAC,CAAC;QACJ;QAEA,MAAMs5B,iBAAiB,GAAG,CAACoxB,SAAS,IAAI,IAAI,CAAC7jD,KAAK,CAACiC,MAAM;QAIzD,IAAI,CAACmrB,WAAW,CACdj0B,IAAI,EACJ,CAAC,IAAI,CAAC6G,KAAK,CAACiC,MAAM,IAAI,CAAC9E,eAAe,IAAI,CAACC,QAAQ,IAAI,CAAC6vD,SAAS,EACjE9vD,eAAe,EACfs1B,iBAAiB,CAClB;QAGD,IAAI,IAAI,CAACzyB,KAAK,CAACiC,MAAM,IAAI9I,IAAI,CAAC6D,EAAE,EAAE;UAChC,IAAI,CAACouC,eAAe,CAACjyC,IAAI,CAAC6D,EAAE,EAAEqI,YAAY,EAAEotB,iBAAiB,CAAC;QAChE;MACF,CAAC,CACF;MACD,IAAI,CAACrV,SAAS,CAAC3V,IAAI,EAAE;MACrB,IAAI,CAACzH,KAAK,CAAC2M,MAAM,GAAGkQ,SAAS;IAC/B;IACA,IAAI,CAACS,eAAe,CAAC7V,IAAI,EAAE;EAC7B;EAEAq1C,iBAAiBA,CAAC3jD,IAAuC,EAAE;IACzD,OAAOA,IAAI,CAAC3N,IAAI,KAAK,YAAY;EACnC;EAEA0hE,iBAAiBA,CACf1xD,MAAwD,EAC/C;IACT,KAAK,IAAIzS,CAAC,GAAG,CAAC,EAAE0mB,GAAG,GAAGjU,MAAM,CAACjU,MAAM,EAAEwB,CAAC,GAAG0mB,GAAG,EAAE1mB,CAAC,EAAE,EAAE;MACjD,IAAI,CAAC,IAAI,CAAC+zD,iBAAiB,CAACthD,MAAM,CAACzS,CAAC,CAAC,CAAC,EAAE,OAAO,KAAK;IACtD;IACA,OAAO,IAAI;EACb;EAEAqkC,WAAWA,CACTj0B,IAAwB,EACxBo5B,eAAwB,EAExBC,eAAgC,EAChCC,iBAA0B,GAAG,IAAI,EAC3B;IACN,MAAMwY,YAAY,GAAG,CAAC1Y,eAAe,IAAI,IAAI17B,GAAG,EAAU;IAO1D,MAAMs2D,gBAAgB,GAAG;MAAE3hE,IAAI,EAAE;KAA6B;IAC9D,KAAK,MAAM2/B,KAAK,IAAIhyB,IAAI,CAACqC,MAAM,EAAE;MAC/B,IAAI,CAACuvC,SAAS,CAAC5f,KAAK,EAAE;QACpB6f,EAAE,EAAEmiB,gBAAgB;QACpB1uD,OAAO,EAAEqG,QAAQ;QACjBmmC,YAAY;QACZxY;MACF,CAAC,CAAC;IACJ;EACF;EAQAm5B,aAAaA,CAEX58B,KAAgB,EAChBqb,UAAoB,EACpB/rC,mBAA6C,EAC7CkrD,YAA4B,EACH;IACzB,MAAMlf,IAA6B,GAAG,EAAE;IACxC,IAAIjgB,KAAK,GAAG,IAAI;IAEhB,OAAO,CAAC,IAAI,CAACzY,GAAG,CAACod,KAAK,CAAC,EAAE;MACvB,IAAI3E,KAAK,EAAE;QACTA,KAAK,GAAG,KAAK;MACf,CAAC,MAAM;QACL,IAAI,CAAC1O,MAAM,CAAU,EAAA,CAAA;QACrB,IAAI,IAAI,CAACtM,KAAK,CAAC2f,KAAK,CAAC,EAAE;UACrB,IAAIw6B,YAAY,EAAE;YAChB,IAAI,CAACE,2BAA2B,CAACF,YAAY,CAAC;UAChD;UACA,IAAI,CAACzmD,IAAI,EAAE;UACX;QACF;MACF;MAEAunC,IAAI,CAAC1tD,IAAI,CAAC,IAAI,CAAC+sE,iBAAiB,CAACtf,UAAU,EAAE/rC,mBAAmB,CAAC,CAAC;IACpE;IACA,OAAOgsC,IAAI;EACb;EAcAqf,iBAAiBA,CAEftf,UAA2B,EAC3B/rC,mBAA6C,EAC7CirD,gBAAiC,EACZ;IACrB,IAAI3f,GAAG;IACP,IAAI,IAAI,CAACv6B,KAAK,CAAA,EAAA,CAAU,EAAE;MACxB,IAAI,CAACg7B,UAAU,EAAE;QACf,IAAI,CAACnrC,KAAK,CAAClG,MAAM,CAACrE,eAAe,EAAE;UACjC/V,EAAE,EAAE,IAAI,CAACohB,KAAK,CAACoN,WAAW,EAAE;UAC5B9c,UAAU,EAAE;QACd,CAAC,CAAC;MACJ;MACAs5C,GAAG,GAAG,IAAI;IACX,CAAA,MAAM,IAAI,IAAI,CAACv6B,KAAK,IAAa,EAAE;MAClC,MAAMg8C,kBAAkB,GAAG,IAAI,CAACrrD,KAAK,CAAC3B,QAAQ;MAE9CurC,GAAG,GAAG,IAAI,CAACtc,cAAc,CACvB,IAAI,CAACyc,WAAW,CAACzrC,mBAAmB,CAAC,EACrC+sD,kBAAkB,CACnB;IACF,CAAA,MAAM,IAAI,IAAI,CAACh8C,KAAK,IAAa,EAAE;MAClC,IAAI,CAACyE,YAAY,CAAC,oBAAoB,CAAC;MACvC,IAAI,CAACy1C,gBAAgB,EAAE;QACrB,IAAI,CAACrqD,KAAK,CAAClG,MAAM,CAACjF,6BAA6B,EAAE;UAC/CnV,EAAE,EAAE,IAAI,CAACohB,KAAK,CAAC3B;QACjB,CAAC,CAAC;MACJ;MACA,MAAMlF,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAE;MAC7B,IAAI,CAACuF,IAAI,EAAE;MACX6mC,GAAG,GAAG,IAAI,CAAClsC,UAAU,CAACvE,IAAI,EAAE,qBAAqB,CAAC;IACpD,CAAC,MAAM;MACLywC,GAAG,GAAG,IAAI,CAAChd,uBAAuB,CAChCtuB,mBAAmB,EACnB,IAAI,CAACgvB,cAAc,CACpB;IACH;IACA,OAAOsc,GAAG;EACZ;EAQAvlB,eAAeA,CAAC+C,OAAiB,EAAgB;IAC/C,MAAMjuB,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAgB;IAC3C,MAAM3hB,IAAI,GAAG,IAAI,CAAC6oE,mBAAmB,CAACt9B,OAAO,CAAC;IAE9C,OAAO,IAAI,CAACwD,gBAAgB,CAACzxB,IAAI,EAAEtd,IAAI,CAAC;EAC1C;EAEA+uC,gBAAgBA,CACdzxB,IAAgC,EAChCtd,IAAY,EACE;IACdsd,IAAI,CAACtd,IAAI,GAAGA,IAAI;IAChBsd,IAAI,CAACnB,GAAG,CAAC/P,cAAc,GAAGpM,IAAI;IAE9B,OAAO,IAAI,CAAC6hB,UAAU,CAACvE,IAAI,EAAE,YAAY,CAAC;EAC5C;EAEAurD,mBAAmBA,CAACt9B,OAAiB,EAAU;IAC7C,IAAIvrC,IAAY;IAEhB,MAAM;MAAEwiB,QAAQ;MAAE7S;KAAM,GAAG,IAAI,CAACwU,KAAK;IAErC,IAAI9Z,0BAA0B,CAACsF,IAAI,CAAC,EAAE;MACpC3P,IAAI,GAAG,IAAI,CAACmkB,KAAK,CAACnX,KAAK;IACzB,CAAC,MAAM;MACL,IAAI,CAACyH,UAAU,EAAE;IACnB;IAEA,MAAM7J,cAAc,GAAGR,iCAAiC,CAACuF,IAAI,CAAC;IAE9D,IAAI47B,OAAO,EAAE;MAGX,IAAI3gC,cAAc,EAAE;QAClB,IAAI,CAACitB,YAAY,CAAS,GAAA,CAAA;MAC5B;IACF,CAAC,MAAM;MACL,IAAI,CAACwd,iBAAiB,CAACr1C,IAAI,EAAEwiB,QAAQ,EAAE5X,cAAc,EAAE,KAAK,CAAC;IAC/D;IAEA,IAAI,CAACsc,IAAI,EAAE;IAEX,OAAOlnB,IAAI;EACb;EAEAq1C,iBAAiBA,CACf5uB,IAAY,EACZjE,QAAkB,EAClB6/C,aAAsB,EACtBv/C,SAAkB,EACZ;IAEN,IAAI2D,IAAI,CAAC/a,MAAM,GAAG,EAAE,EAAE;MACpB;IACF;IAGA,IAAI,CAAC2b,iBAAiB,CAACZ,IAAI,CAAC,EAAE;MAC5B;IACF;IAEA,IAAI47C,aAAa,IAAIt7C,SAAS,CAACN,IAAI,CAAC,EAAE;MACpC,IAAI,CAACpD,KAAK,CAAClG,MAAM,CAAC7E,iBAAiB,EAAE;QACnCvV,EAAE,EAAEyf,QAAQ;QACZ/iB,OAAO,EAAEgnB;MACX,CAAC,CAAC;MACF;IACF;IAEA,MAAM8qD,YAAY,GAAG,CAAC,IAAI,CAACptD,KAAK,CAACiC,MAAM,GACnCI,cAAc,GACd1D,SAAS,GACTgE,wBAAwB,GACxBH,oBAAoB;IAExB,IAAI4qD,YAAY,CAAC9qD,IAAI,EAAE,IAAI,CAACC,QAAQ,CAAC,EAAE;MACrC,IAAI,CAACrD,KAAK,CAAClG,MAAM,CAACvE,sBAAsB,EAAE;QACxC7V,EAAE,EAAEyf,QAAQ;QACZvO,YAAY,EAAEwS;MAChB,CAAC,CAAC;MACF;IACF,CAAC,MAAM,IAAIA,IAAI,KAAK,OAAO,EAAE;MAC3B,IAAI,IAAI,CAAC8a,SAAS,CAAC7C,QAAQ,EAAE;QAC3B,IAAI,CAACrb,KAAK,CAAClG,MAAM,CAACjD,sBAAsB,EAAE;UAAEnX,EAAE,EAAEyf;QAAS,CAAC,CAAC;QAC3D;MACF;IACF,CAAC,MAAM,IAAIiE,IAAI,KAAK,OAAO,EAAE;MAC3B,IAAI,IAAI,CAAC8a,SAAS,CAAC9C,QAAQ,EAAE;QAC3B,IAAI,CAACpb,KAAK,CAAClG,MAAM,CAACjN,sBAAsB,EAAE;UAAEnN,EAAE,EAAEyf;QAAS,CAAC,CAAC;QAC3D;MACF;MAEA,IAAI,IAAI,CAACqJ,KAAK,CAACP,aAAa,EAAE;QAC5B,IAAI,CAACjI,KAAK,CAAClG,MAAM,CAAChN,mCAAmC,EAAE;UACrDpN,EAAE,EAAEyf;QACN,CAAC,CAAC;QACF;MACF;MAEA,IAAI,CAACif,eAAe,CAAC9D,+BAA+B,CAAC;QAAE56B,EAAE,EAAEyf;MAAS,CAAC,CAAC;IACxE,CAAC,MAAM,IAAIiE,IAAI,KAAK,WAAW,EAAE;MAC/B,IAAI,IAAI,CAACoF,KAAK,CAACR,+BAA+B,EAAE;QAC9C,IAAI,CAAChI,KAAK,CAAClG,MAAM,CAACnN,gBAAgB,EAAE;UAAEjN,EAAE,EAAEyf;QAAS,CAAC,CAAC;QACrD;MACF;IACF;EACF;EAEAkqD,cAAcA,CAAAA,EAAY;IACxB,IAAI,IAAI,CAACnrC,SAAS,CAAC9C,QAAQ,EAAE,OAAO,IAAI;IACxC,IAAI,IAAI,CAACvgC,OAAO,CAACjB,yBAAyB,IAAI,CAAC,IAAI,CAAC4uB,KAAK,CAACb,UAAU,EAAE;MACpE,OAAO,IAAI;IACb;IACA,OAAO,KAAK;EACd;EAIA2hD,UAAUA,CAAenqD,QAAkB,EAAqB;IAC9D,MAAMlF,IAAI,GAAG,IAAI,CAACqlB,WAAW,CAAoBngB,QAAQ,CAAC;IAE1D,IAAI,CAACif,eAAe,CAACjE,+BAA+B,CAClDrgB,MAAM,CAAC/M,8BAA8B,EACrC;MAEErN,EAAE,EAAEua;IACN,CAAC,CACF;IAED,IAAI,IAAI,CAACyY,GAAG,CAAA,EAAA,CAAS,EAAE;MACrB,IAAI,CAAC1S,KAAK,CAAClG,MAAM,CAACxG,iBAAiB,EAAE;QAAE5T,EAAE,EAAEua;MAAK,CAAC,CAAC;IACpD;IAEA,IAAI,CAAC,IAAI,CAACuO,KAAK,CAACb,UAAU,IAAI,CAAC,IAAI,CAAC9sB,OAAO,CAACjB,yBAAyB,EAAE;MACrE,IAAI,IAAI,CAAC8vE,gBAAgB,EAAE,EAAE;QAC3B,IAAI,CAAClgD,2BAA2B,GAAG,IAAI;MACzC,CAAC,MAAM;QACL,IAAI,CAACD,iBAAiB,GAAG,IAAI;MAC/B;IACF;IAEA,IAAI,CAAC,IAAI,CAACzI,KAAK,CAACyM,SAAS,EAAE;MACzBtT,IAAI,CAACb,QAAQ,GAAG,IAAI,CAACo/C,eAAe,CAAC,IAAI,EAAE,IAAI,CAAC;IAClD;IAEA,OAAO,IAAI,CAACh6C,UAAU,CAACvE,IAAI,EAAE,iBAAiB,CAAC;EACjD;EAEAyvD,gBAAgBA,CAAAA,EAAY;IAC1B,IAAI,IAAI,CAACttC,qBAAqB,EAAE,EAAE,OAAO,IAAI;IAC7C,MAAM;MAAE9vB;KAAM,GAAG,IAAI,CAACwU,KAAK;IAC3B,OAGExU,IAAI,KAAe,EAAA,IACnBA,IAAI,KAAA,EAAc,IAClBA,IAAI,KAAA,CAAgB,IACpBtE,eAAe,CAACsE,IAAI,CAAC,IACpBA,IAAI,KAAA,GAAW,IAAI,CAAC,IAAI,CAACwU,KAAK,CAAC+M,WAAY,IAG5CvhB,IAAI,KAAA,GAAc,IAClBA,IAAI,KAAA,EAAa,IAGhB,IAAI,CAACiU,SAAS,CAAC,aAAa,CAAC,IAAIjU,IAAI,KAAe,EAAA;EAEzD;EAIAs7D,UAAUA,CAAAA,EAAkC;IAC1C,MAAM3tD,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAqB;IAEhD,IAAI,CAAC8f,eAAe,CAACjE,+BAA+B,CAClDrgB,MAAM,CAAChD,gBAAgB,EACvB;MAEEpX,EAAE,EAAEua;IACN,CAAC,CACF;IAED,IAAI,CAAC4J,IAAI,EAAE;IACX,IAAIsqD,UAAU,GAAG,KAAK;IACtB,IAAI/0D,QAA6B,GAAG,IAAI;IACxC,IAAI,CAAC,IAAI,CAACgjB,qBAAqB,EAAE,EAAE;MACjC+xC,UAAU,GAAG,IAAI,CAACz7C,GAAG,CAAS,EAAA,CAAA;MAC9B,QAAQ,IAAI,CAAC5R,KAAK,CAACxU,IAAI;QACrB,KAAA,EAAA;QACA,KAAA,GAAA;QACA,KAAA,CAAA;QACA,KAAA,EAAA;QACA,KAAA,CAAA;QACA,KAAA,CAAA;QACA,KAAA,EAAA;QACA,KAAA,EAAA;UAIE,IAAI,CAAC6hE,UAAU,EAAE;QAEnB;UACE/0D,QAAQ,GAAG,IAAI,CAACq0B,gBAAgB,EAAE;MAAA;IAExC;IACAxzB,IAAI,CAACm0D,QAAQ,GAAGD,UAAU;IAC1Bl0D,IAAI,CAACb,QAAQ,GAAGA,QAAQ;IACxB,OAAO,IAAI,CAACoF,UAAU,CAACvE,IAAI,EAAE,iBAAiB,CAAC;EACjD;EAKAmuD,4BAA4BA,CAAC54B,IAAkB,EAAEovB,YAAsB,EAAE;IACvE,IAAI,IAAI,CAACr+C,SAAS,CAAC,CAAC,kBAAkB,EAAE;MAAE+U,QAAQ,EAAE;IAAS,CAAA,CAAC,CAAC,EAAE;MAC/D,IAAIka,IAAI,CAACljC,IAAI,KAAK,oBAAoB,EAAE;QAGtC,IAAI,CAAC0T,KAAK,CAAClG,MAAM,CAACzB,8BAA8B,EAAE;UAChD3Y,EAAE,EAAEk/D;QACN,CAAC,CAAC;MACJ;IACF;EACF;EAEAgK,6BAA6BA,CAACyF,SAAuB,EAAElvD,QAAkB,EAAE;IACzE,IAAI,IAAI,CAACmvD,iBAAiB,CAACD,SAAS,CAAC,EAAE;MACrC,MAAM9nC,QAAQ,GAAG,IAAI,CAACjH,WAAW,CAAyBngB,QAAQ,CAAC;MACnEonB,QAAQ,CAACnmB,MAAM,GAAGiuD,SAAS;MAC3B,OAAO,IAAI,CAAC7vD,UAAU,CAAC+nB,QAAQ,EAAE,sBAAsB,CAAC;IAC1D,CAAC,MAAM;MACL,MAAMA,QAAQ,GAAG,IAAI,CAACjH,WAAW,CAA4BngB,QAAQ,CAAC;MACtE,IAAI,CAACovD,kCAAkC,CAACpvD,QAAQ,CAAC;MACjDonB,QAAQ,CAAC7qB,UAAU,GAAG2yD,SAAS;MAC/B,OAAO,IAAI,CAAC7vD,UAAU,CAAC+nB,QAAQ,EAAE,yBAAyB,CAAC;IAC7D;EACF;EAEA+nC,iBAAiBA,CAAC5yD,UAAwB,EAAW;IACnD,QAAQA,UAAU,CAACpP,IAAI;MACrB,KAAK,kBAAkB;QACrB,OACE,CAACoP,UAAU,CAAC6C,QAAQ,IAAI,IAAI,CAAC+vD,iBAAiB,CAAC5yD,UAAU,CAAChS,MAAM,CAAC;MAErE,KAAK,YAAY;QACf,OAAO,IAAI;MACb;QACE,OAAO,KAAK;IAAA;EAElB;EAMA6kE,kCAAkCA,CAACpvD,QAAkB,EAAQ;IAO3D,IAAI,IAAI,CAACgR,KAAK,CAAA,EAAA,CAAU,EAAE;MACxB,MAAM,IAAI,CAACnQ,KAAK,CAAClG,MAAM,CAAC3B,mBAAmB,EAAE;QAAEzY,EAAE,EAAE,IAAI,CAACohB,KAAK,CAAC3B;MAAS,CAAC,CAAC;IAC3E;IAGA,IAAI,CAAC,IAAI,CAAC+pD,qCAAqC,EAAE,EAAE;MACjD,IAAI,CAAClpD,KAAK,CAAClG,MAAM,CAACxB,mBAAmB,EAAE;QAAE5Y,EAAE,EAAEyf;MAAS,CAAC,CAAC;IAC1D;EACF;EAQAupD,uBAAuBA,CAAI8F,QAAiB,EAAK;IAC/C,MAAMC,sBAAsB,GAAG,IAAI,CAAC3tD,KAAK,CAACsM,YAAY;IACtD,IAAI,CAACtM,KAAK,CAACsM,YAAY,GAAG;MAExBC,wBAAwB,EAAE,CAAC;MAE3BC,aAAa,EAAE;KAChB;IAED,IAAI;MACF,OAAOkhD,QAAQ,EAAE;IACnB,CAAC,SAAS;MACR,IAAI,CAAC1tD,KAAK,CAACsM,YAAY,GAAGqhD,sBAAsB;IAClD;EACF;EAUAC,kCAAkCA,CAAIF,QAAiB,EAAK;IAC1D,IAAI,IAAI,CAACjuD,SAAS,CAAC,CAAC,kBAAkB,EAAE;MAAE+U,QAAQ,EAAE;IAAS,CAAA,CAAC,CAAC,EAAE;MAE/D,MAAMm5C,sBAAsB,GAAG,IAAI,CAAC3tD,KAAK,CAACsM,YAAY;MACtD,IAAI,CAACtM,KAAK,CAACsM,YAAY,GAAG;QAExBC,wBAAwB,EAAE,CAAC;QAE3BC,aAAa,EAAE;OAChB;MAED,IAAI;QACF,OAAOkhD,QAAQ,EAAE;MACnB,CAAC,SAAS;QACR,IAAI,CAAC1tD,KAAK,CAACsM,YAAY,GAAGqhD,sBAAsB;MAClD;IACF,CAAC,MAAM;MAKL,OAAOD,QAAQ,EAAE;IACnB;EACF;EAEA1F,8BAA8BA,CAAI0F,QAAiB,EAAK;IACtD,MAAMG,0BAA0B,GAAG,IAAI,CAAC7tD,KAAK,CAACyM,SAAS;IACvD,IAAI,CAACzM,KAAK,CAACyM,SAAS,GAAG,IAAI;IAE3B,IAAI;MACF,OAAOihD,QAAQ,EAAE;IACnB,CAAC,SAAS;MACR,IAAI,CAAC1tD,KAAK,CAACyM,SAAS,GAAGohD,0BAA0B;IACnD;EACF;EAEAnH,UAAUA,CAAIgH,QAAiB,EAAK;IAClC,MAAM/zD,KAAK,GAAG,IAAI,CAACyjB,SAAS,CAAC/C,YAAY,EAAE;IAC3C,MAAMyzC,cAAc,GAAG5zC,QAAQ,GAAG,CAACvgB,KAAK;IACxC,IAAIm0D,cAAc,EAAE;MAClB,IAAI,CAAC1wC,SAAS,CAAC5V,KAAK,CAAC7N,KAAK,GAAGugB,QAAQ,CAAC;MACtC,IAAI;QACF,OAAOwzC,QAAQ,EAAE;MACnB,CAAC,SAAS;QACR,IAAI,CAACtwC,SAAS,CAAC3V,IAAI,EAAE;MACvB;IACF;IACA,OAAOimD,QAAQ,EAAE;EACnB;EAEAlH,aAAaA,CAAIkH,QAAiB,EAAK;IACrC,MAAM/zD,KAAK,GAAG,IAAI,CAACyjB,SAAS,CAAC/C,YAAY,EAAE;IAC3C,MAAM0zC,gBAAgB,GAAG7zC,QAAQ,GAAGvgB,KAAK;IACzC,IAAIo0D,gBAAgB,EAAE;MACpB,IAAI,CAAC3wC,SAAS,CAAC5V,KAAK,CAAC7N,KAAK,GAAG,CAACugB,QAAQ,CAAC;MACvC,IAAI;QACF,OAAOwzC,QAAQ,EAAE;MACnB,CAAC,SAAS;QACR,IAAI,CAACtwC,SAAS,CAAC3V,IAAI,EAAE;MACvB;IACF;IACA,OAAOimD,QAAQ,EAAE;EACnB;EAIA5C,sBAAsBA,CAAAA,EAAS;IAC7B,IAAI,CAAC9qD,KAAK,CAACsM,YAAY,CAACE,aAAa,GAAG,CAAC;EAC3C;EAEAq+C,uCAAuCA,CAAAA,EAAY;IACjD,OAAO,IAAI,CAAC7qD,KAAK,CAACsM,YAAY,CAACC,wBAAwB,IAAI,CAAC;EAC9D;EAEA67C,qCAAqCA,CAAAA,EAAY;IAC/C,OACE,IAAI,CAACpoD,KAAK,CAACsM,YAAY,CAACE,aAAa,IAAI,IAAI,IAC7C,IAAI,CAACxM,KAAK,CAACsM,YAAY,CAACE,aAAa,IAAI,CAAC;EAE9C;EAEAy7C,uBAAuBA,CAAeZ,IAAY,EAAgB;IAChE,MAAMhpD,QAAQ,GAAG,IAAI,CAAC2B,KAAK,CAAC3B,QAAQ;IAEpC,IAAI,CAAC2B,KAAK,CAAC4L,gBAAgB,GAAG,IAAI,CAAC5L,KAAK,CAAClY,KAAK;IAC9C,MAAM2hE,6BAA6B,GAAG,IAAI,CAACzpD,KAAK,CAAC0M,0BAA0B;IAC3E,IAAI,CAAC1M,KAAK,CAAC0M,0BAA0B,GAAG,IAAI;IAE5C,MAAMshD,GAAG,GAAG,IAAI,CAACnQ,WAAW,CAC1B,IAAI,CAACsJ,wBAAwB,EAAE,EAC/B9oD,QAAQ,EACRgpD,IAAI,CACL;IAED,IAAI,CAACrnD,KAAK,CAAC0M,0BAA0B,GAAG+8C,6BAA6B;IAErE,OAAOuE,GAAG;EACZ;EAGA1D,qBAAqBA,CAAAA,EAAmC;IACtD,IAAI,CAACx2C,YAAY,CAAC,cAAc,CAAC;IACjC,MAAM3a,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAsB;IACjD,IAAI,CAACuF,IAAI,EAAE;IACX,IAAI,CAAC,IAAI,CAACsM,KAAK,GAAW,EAAE;MAC1B,IAAI,CAAC/e,UAAU,CAAC,IAAI,EAAY,CAAA,CAAA;IAClC;IAEA,MAAMgjC,OAAO,GAAG,IAAI,CAAC9U,WAAW,CAAY,IAAI,CAACxe,KAAK,CAACkB,MAAM,CAAC;IAC9D,IAAI,CAAC6B,IAAI,EAAE;IAEX,MAAMkrD,YAAY,GAAG,IAAI,CAACrxC,gBAAgB,CAAiB,IAAI,CAAC;IAChE,IAAI,CAACW,kBAAkB,EAAE;IAEzB,IAAI;MACFpkB,IAAI,CAACgD,IAAI,GAAG,IAAI,CAAC+xD,YAAY,CAAC56B,OAAO,EAAa,CAAA,EAAA,QAAQ,CAAC;IAC7D,CAAC,SAAS;MACR26B,YAAY,EAAE;IAChB;IACA,OAAO,IAAI,CAACvwD,UAAU,CAAqBvE,IAAI,EAAE,kBAAkB,CAAC;EACtE;EAGA02B,+BAA+BA,CAE7B7xB,IAAmD,EAC7C,CAAC;AACX;ACriGA,MAAMmwD,SAAS,GAAG;IAAEviE,IAAI,EAAE;EAAiB,CAAA;EACzCwiE,WAAW,GAAG;IAAExiE,IAAI,EAAE;GAAmB;AAkB3C,MAAMyiE,aAAa,GAAG,kBAAkB;AAExC,MAAMC,yBAAyB,GAAG,kBAAkB;AAUpD,SAASC,kBAAkBA,CAACh1E,MAA6B,EAAEqxB,KAAa,EAAE;EACxE,KAAK,IAAI7hB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGxP,MAAM,CAACgO,MAAM,EAAEwB,CAAC,EAAE,EAAE;IACtC,MAAM1O,KAAK,GAAGd,MAAM,CAACwP,CAAC,CAAC;IACvB,MAAM;MAAEyC;IAAM,CAAA,GAAGnR,KAAK;IACtB,IAAI,OAAOmR,IAAI,KAAK,QAAQ,EAAE;MACO;QACjC,IAAIA,IAAI,QAAmB,EAAE;UAC3B,MAAM;YAAEwM,GAAG;YAAElQ,KAAK;YAAEe,KAAK;YAAEd;UAAK,CAAA,GAAG1N,KAAK;UACxC,MAAMm0E,UAAU,GAAG1mE,KAAK,GAAG,CAAC;UAC5B,MAAM2mE,UAAU,GAAGvmE,8BAA8B,CAAC8P,GAAG,CAAClQ,KAAK,EAAE,CAAC,CAAC;UAC/DvO,MAAM,CAACkxB,MAAM,CACX1hB,CAAC,EACD,CAAC,EACD,IAAIioB,KAAK,CAAC;YAERxlB,IAAI,EAAErE,gBAAgB,CAAS,EAAA,CAAA;YAC/B0B,KAAK,EAAE,GAAG;YACVf,KAAK,EAAEA,KAAK;YACZC,GAAG,EAAEymE,UAAU;YACfnwD,QAAQ,EAAErG,GAAG,CAAClQ,KAAK;YACnBoZ,MAAM,EAAEutD;UACV,CAAC,CAAC,EACF,IAAIz9C,KAAK,CAAC;YAERxlB,IAAI,EAAErE,gBAAgB,CAAS,GAAA,CAAA;YAC/B0B,KAAK,EAAEA,KAAK;YACZf,KAAK,EAAE0mE,UAAU;YACjBzmE,GAAG,EAAEA,GAAG;YACRsW,QAAQ,EAAEowD,UAAU;YACpBvtD,MAAM,EAAElJ,GAAG,CAACjQ;UACb,CAAA,CAAC,CACH;UACDgB,CAAC,EAAE;UACH;QACF;QAEA,IAAI7B,eAAe,CAACsE,IAAI,CAAC,EAAE;UACzB,MAAM;YAAEwM,GAAG;YAAElQ,KAAK;YAAEe,KAAK;YAAEd;UAAK,CAAA,GAAG1N,KAAK;UACxC,MAAMq0E,YAAY,GAAG5mE,KAAK,GAAG,CAAC;UAC9B,MAAM6mE,eAAe,GAAGzmE,8BAA8B,CAAC8P,GAAG,CAAClQ,KAAK,EAAE,CAAC,CAAC;UACpE,IAAI8mE,UAAU;UACd,IAAIhkD,KAAK,CAACC,UAAU,CAAC/iB,KAAK,CAAC,OAA0B,EAAE;YACrD8mE,UAAU,GAAG,IAAI59C,KAAK,CAAC;cAErBxlB,IAAI,EAAErE,gBAAgB,CAAc,EAAA,CAAA;cACpC0B,KAAK,EAAE,GAAG;cACVf,KAAK,EAAEA,KAAK;cACZC,GAAG,EAAE2mE,YAAY;cACjBrwD,QAAQ,EAAErG,GAAG,CAAClQ,KAAK;cACnBoZ,MAAM,EAAEytD;YACV,CAAC,CAAC;UACJ,CAAC,MAAM;YACLC,UAAU,GAAG,IAAI59C,KAAK,CAAC;cAErBxlB,IAAI,EAAErE,gBAAgB,CAAW,CAAA,CAAA;cACjC0B,KAAK,EAAE,GAAG;cACVf,KAAK,EAAEA,KAAK;cACZC,GAAG,EAAE2mE,YAAY;cACjBrwD,QAAQ,EAAErG,GAAG,CAAClQ,KAAK;cACnBoZ,MAAM,EAAEytD;YACV,CAAC,CAAC;UACJ;UACA,IAAIE,aAAa,EACfC,kBAAkB,EAClBC,qBAAqB,EACrBC,QAAQ;UACV,IAAIxjE,IAAI,OAAoB,EAAE;YAE5BsjE,kBAAkB,GAAG/mE,GAAG,GAAG,CAAC;YAC5BgnE,qBAAqB,GAAG7mE,8BAA8B,CAAC8P,GAAG,CAACjQ,GAAG,EAAE,CAAC,CAAC,CAAC;YACnE8mE,aAAa,GAAGhmE,KAAK,KAAK,IAAI,GAAG,IAAI,GAAGA,KAAK,CAAC0kB,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;YAC1DyhD,QAAQ,GAAG,IAAIh+C,KAAK,CAAC;cAEnBxlB,IAAI,EAAErE,gBAAgB,CAAc,EAAA,CAAA;cACpC0B,KAAK,EAAE,GAAG;cACVf,KAAK,EAAEgnE,kBAAkB;cACzB/mE,GAAG,EAAEA,GAAG;cACRsW,QAAQ,EAAE0wD,qBAAqB;cAC/B7tD,MAAM,EAAElJ,GAAG,CAACjQ;YACd,CAAC,CAAC;UACJ,CAAC,MAAM;YAEL+mE,kBAAkB,GAAG/mE,GAAG,GAAG,CAAC;YAC5BgnE,qBAAqB,GAAG7mE,8BAA8B,CAAC8P,GAAG,CAACjQ,GAAG,EAAE,CAAC,CAAC,CAAC;YACnE8mE,aAAa,GAAGhmE,KAAK,KAAK,IAAI,GAAG,IAAI,GAAGA,KAAK,CAAC0kB,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;YAC1DyhD,QAAQ,GAAG,IAAIh+C,KAAK,CAAC;cAEnBxlB,IAAI,EAAErE,gBAAgB,CAAiB,EAAA,CAAA;cACvC0B,KAAK,EAAE,IAAI;cACXf,KAAK,EAAEgnE,kBAAkB;cACzB/mE,GAAG,EAAEA,GAAG;cACRsW,QAAQ,EAAE0wD,qBAAqB;cAC/B7tD,MAAM,EAAElJ,GAAG,CAACjQ;YACd,CAAC,CAAC;UACJ;UACAxO,MAAM,CAACkxB,MAAM,CACX1hB,CAAC,EACD,CAAC,EACD6lE,UAAU,EACV,IAAI59C,KAAK,CAAC;YAERxlB,IAAI,EAAErE,gBAAgB,CAAa,EAAA,CAAA;YACnC0B,KAAK,EAAEgmE,aAAa;YACpB/mE,KAAK,EAAE4mE,YAAY;YACnB3mE,GAAG,EAAE+mE,kBAAkB;YACvBzwD,QAAQ,EAAEswD,eAAe;YACzBztD,MAAM,EAAE6tD;WACT,CAAC,EACFC,QAAQ,CACT;UACDjmE,CAAC,IAAI,CAAC;UACN;QACF;MACF;MAEA1O,KAAK,CAACmR,IAAI,GAAGrE,gBAAgB,CAACqE,IAAI,CAAC;IACrC;EACF;EACA,OAAOjS,MAAM;AACf;AACe,MAAe01E,eAAe,SAAShJ,gBAAgB,CAAC;EAQrE5yB,aAAaA,CAAe75B,IAAY,EAAE85B,OAAkB,EAAU;IACpE95B,IAAI,CAAC85B,OAAO,GAAG,IAAI,CAAC46B,YAAY,CAAC56B,OAAO,CAAC;IACzC95B,IAAI,CAAC0P,QAAQ,GAAG,IAAI,CAAClJ,KAAK,CAACkJ,QAAQ;IAEnC,IAAI,IAAI,CAACnvB,OAAO,CAACR,MAAM,EAAE;MACvBigB,IAAI,CAACjgB,MAAM,GAAGg1E,kBAAkB,CAAC,IAAI,CAACh1E,MAAM,EAAE,IAAI,CAACqxB,KAAK,CAAC;IAC3D;IAEA,OAAO,IAAI,CAAClN,UAAU,CAAClE,IAAI,EAAE,MAAM,CAAC;EACtC;EAEA00D,YAAYA,CAEV56B,OAA0B,EAC1BvrC,GAAc,GAAS,GAAA,EACvBtP,UAAsB,GAAG,IAAI,CAACsB,OAAO,CAACtB,UAAU,EACrC;IACX66C,OAAO,CAAC76C,UAAU,GAAGA,UAAU;IAC/B66C,OAAO,CAAC47B,WAAW,GAAG,IAAI,CAACC,yBAAyB,EAAE;IACtD,IAAI,CAACvzD,cAAc,CAAC03B,OAAO,EAAE,IAAI,EAAE,IAAI,EAAEvrC,GAAG,CAAC;IAC7C,IACE,IAAI,CAACwa,QAAQ,IACb,CAAC,IAAI,CAACxoB,OAAO,CAACZ,sBAAsB,IACpC,IAAI,CAACuuB,KAAK,CAAChB,gBAAgB,CAACsO,IAAI,GAAG,CAAC,EACpC;MACA,KAAK,MAAM,CAAChnB,SAAS,EAAEpP,EAAE,CAAC,IAAI4Z,KAAK,CAACqf,IAAI,CAAC,IAAI,CAACnQ,KAAK,CAAChB,gBAAgB,CAAC,EAAE;QACrE,IAAI,CAACxH,KAAK,CAAClG,MAAM,CAAC9G,qBAAqB,EAAE;UAAEtT,EAAE;UAAEoP;QAAU,CAAC,CAAC;MAC7D;IACF;IACA,IAAIohE,eAA0B;IAC9B,IAAIrnE,GAAG,QAAW,EAAE;MAElBqnE,eAAe,GAAG,IAAI,CAAC1xD,UAAU,CAAC41B,OAAO,EAAE,SAAS,CAAC;IACvD,CAAC,MAAM;MAEL87B,eAAe,GAAG,IAAI,CAACnuD,YAAY,CACjCqyB,OAAO,EACP,SAAS,EACTprC,8BAA8B,CAAC,IAAI,CAAC8X,KAAK,CAAC3B,QAAQ,EAAE,CAAC,CAAC,CAAC,CACxD;IACH;IACA,OAAO+wD,eAAe;EACxB;EAKAC,eAAeA,CAACr0D,IAAiB,EAAe;IAC9C,MAAML,SAAS,GAAGK,IAAW;IAC7BL,SAAS,CAACnP,IAAI,GAAG,WAAW;IAC5BmP,SAAS,CAAC9R,KAAK,GAAG8R,SAAS,CAACC,UAAU;IACtC,OAAOD,SAAS,CAACC,UAAU;IAE3B,MAAM00D,gBAAgB,GAAG30D,SAAS,CAAC9R,KAAK;IACxC,MAAMkS,eAAe,GAAGu0D,gBAAgB,CAACzmE,KAAK;IAC9C,MAAMgS,GAAG,GAAG,IAAI,CAAC+P,KAAK,CAAC2C,KAAK,CAAC+hD,gBAAgB,CAACxnE,KAAK,EAAEwnE,gBAAgB,CAACvnE,GAAG,CAAC;IAC1E,MAAMulB,GAAG,GAAIgiD,gBAAgB,CAACzmE,KAAK,GAAGgS,GAAG,CAAC0S,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAE;IAEvD,IAAI,CAACqN,QAAQ,CAAC00C,gBAAgB,EAAE,KAAK,EAAEz0D,GAAG,CAAC;IAC3C,IAAI,CAAC+f,QAAQ,CAAC00C,gBAAgB,EAAE,UAAU,EAAEhiD,GAAG,CAAC;IAChD,IAAI,CAACsN,QAAQ,CAAC00C,gBAAgB,EAAE,iBAAiB,EAAEv0D,eAAe,CAAC;IAEnEu0D,gBAAgB,CAAC9jE,IAAI,GAAG,kBAAkB;IAE1C,OAAOmP,SAAS;EAClB;EAEAw0D,yBAAyBA,CAAAA,EAAkC;IACzD,IAAI,CAAC,IAAI,CAAC9/C,KAAK,IAAyB,EAAE;MACxC,OAAO,IAAI;IACb;IAEA,MAAMlW,IAAI,GAAG,IAAI,CAACqE,SAAS,EAA0B;IACrDrE,IAAI,CAACtQ,KAAK,GAAG,IAAI,CAACmX,KAAK,CAACnX,KAAK;IAC7B,IAAI,CAACka,IAAI,EAAE;IACX,OAAO,IAAI,CAACrF,UAAU,CAACvE,IAAI,EAAE,sBAAsB,CAAC;EACtD;EAEA0sB,KAAKA,CAAAA,EAAY;IACf,IAAI,CAAC,IAAI,CAAChL,YAAY,IAAS,EAAE;MAC/B,OAAO,KAAK;IACd;IACA,OAAO,IAAI,CAAC00C,uBAAuB,EAAE;EACvC;EAEAlM,yBAAyBA,CAACv1C,EAAU,EAAE1V,GAAW,EAAE;IACjD,IAAIwJ,iBAAiB,CAACkM,EAAE,CAAC,EAAE;MACzBwgD,yBAAyB,CAACl8C,SAAS,GAAGha,GAAG;MACzC,IAAIk2D,yBAAyB,CAACzsD,IAAI,CAAC,IAAI,CAAC+I,KAAK,CAAC,EAAE;QAG9C,MAAM4kD,KAAK,GAAG,IAAI,CAAC/8C,cAAc,CAAC67C,yBAAyB,CAACl8C,SAAS,CAAC;QACtE,IAAI,CAACrQ,gBAAgB,CAACytD,KAAK,CAAC,IAAIA,KAAK,OAAwB,EAAE;UAC7D,OAAO,KAAK;QACd;MACF;MACA,OAAO,IAAI;IACb,CAAC,MAAM,IAAI1hD,EAAE,KAAA,EAAwB,EAAE;MACrC,OAAO,IAAI;IACb,CAAC,MAAM;MACL,OAAO,KAAK;IACd;EACF;EAEA2hD,sBAAsBA,CAAC3hD,EAAU,EAAE;IACjC,OACEA,EAAE,KAAA,EAAgC,IAAIA,EAAE,KAA6B,GAAA;EAEzE;EAMAyhD,uBAAuBA,CAAAA,EAAY;IACjC,MAAMxsD,IAAI,GAAG,IAAI,CAACmP,cAAc,EAAE;IAClC,MAAM+I,MAAM,GAAG,IAAI,CAACxI,cAAc,CAAC1P,IAAI,CAAC;IACxC,OACE,IAAI,CAAC0sD,sBAAsB,CAACx0C,MAAM,CAAC,IACnC,IAAI,CAACooC,yBAAyB,CAACpoC,MAAM,EAAElY,IAAI,CAAC;EAEhD;EAOA2sD,mCAAmCA,CAAAA,EAAY;IAC7C,MAAM3sD,IAAI,GAAG,IAAI,CAACuP,oBAAoB,EAAE;IACxC,MAAM2I,MAAM,GAAG,IAAI,CAACxI,cAAc,CAAC1P,IAAI,CAAC;IACxC,OAAO,IAAI,CAACsgD,yBAAyB,CAACpoC,MAAM,EAAElY,IAAI,CAAC;EACrD;EAEA4sD,gBAAgBA,CAAAA,EAAY;IAC1B,MAAM;MAAEnkE,IAAI;MAAEuhB;IAAY,CAAC,GAAG,IAAI,CAACgF,SAAS,EAAE;IAC9C,IAAIvmB,IAAI,KAAA,GAAW,IAAI,CAACuhB,WAAW,EAAE;MAEnC,OAAO,KAAK;IACd,CAAC,MAAM,IAAI/mB,iBAAiB,CAACwF,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC+vB,qBAAqB,EAAE,EAAE;MACnE,IAAI,CAACzH,YAAY,CAAC,4BAA4B,CAAC;MAC/C,OAAO,IAAI;IACb;EACF;EAGA87C,eAAeA,CAAAA,EAAe;IAC5B,OAAO,IAAI,CAACjkC,kBAAkB,CAC5BkkC,KACqC,IACQ,IAGJ,CAC1C;EACH;EAGAC,sBAAsBA,CAAAA,EAAe;IACnC,OAAO,IAAI,CAACnkC,kBAAkB,CAC5BkkC,KAC6C,IAC1C,CAAC,IAAI,CAAC91E,OAAO,CAACJ,MAAM,IAAI,IAAI,CAACqmB,KAAK,CAACiC,MAAM,GACtC,CAAC,IACsC,CAAC,CAC/C;EACH;EAEAuhD,+CAA+CA,CAE7CuM,oBAA6B,GAAG,KAAK,EACrC;IACA,IAAIp2D,KAAyB,IAAmC;IAChE,IAAI,IAAI,CAAC5f,OAAO,CAACJ,MAAM,IAAI,CAAC,IAAI,CAACqmB,KAAK,CAACiC,MAAM,EAAE;MAC7CtI,KAAK,KAA+C;MACpD,IAAIo2D,oBAAoB,EAAE;QACxBp2D,KAAK,KAA2C;MAClD;IACF;IACA,OAAO,IAAI,CAACgyB,kBAAkB,CAAChyB,KAAK,CAAC;EACvC;EASAq2D,cAAcA,CAAAA,EAAe;IAC3B,OAAO,IAAI,CAACrkC,kBAAkB,GAAkC;EAClE;EAIAA,kBAAkBA,CAEhBhyB,KAAyB,EAOA;IACzB,IAAImG,UAAgC,GAAG,IAAI;IAE3C,IAAI,IAAI,CAACuP,KAAK,CAAA,EAAA,CAAO,EAAE;MACrBvP,UAAU,GAAG,IAAI,CAACmqD,eAAe,CAAC,IAAI,CAAC;IACzC;IACA,OAAO,IAAI,CAACtL,qBAAqB,CAAChlD,KAAK,EAAEmG,UAAU,CAAC;EACtD;EAEA6+C,qBAAqBA,CAEnBhlD,KAAyB,EACzBmG,UAAiC,EACpB;IACb,MAAM67C,SAAS,GAAG,IAAI,CAAC37C,KAAK,CAACxU,IAAI;IACjC,MAAM2N,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAE;IAC7B,MAAMyyD,gBAAgB,GAAG,CAAC,EAAEt2D,KAAK,IAAsC,CAAC;IACxE,MAAMu2D,wBAAwB,GAAG,CAAC,EAChCv2D,KAAK,IAA8C,CACpD;IACD,MAAMmC,QAAQ,GAAGnC,KAAK,IAAuC;IAM7D,QAAQgiD,SAAS;MACf,KAAA,EAAA;QACE,OAAO,IAAI,CAACwU,2BAA2B,CAACh3D,IAAI,EAAgB,IAAI,CAAC;MACnE,KAAA,EAAA;QACE,OAAO,IAAI,CAACg3D,2BAA2B,CAACh3D,IAAI,EAAgB,KAAK,CAAC;MACpE,KAAA,EAAA;QACE,OAAO,IAAI,CAACi3D,sBAAsB,CAACj3D,IAAI,CAAgC;MACzE,KAAA,EAAA;QACE,OAAO,IAAI,CAACk3D,qBAAqB,CAACl3D,IAAI,CAA+B;MACvE,KAAA,EAAA;QACE,OAAO,IAAI,CAACm3D,iBAAiB,CAACn3D,IAAI,CAA2B;MAC/D,KAAA,EAAA;QACE,IAAI,IAAI,CAACkZ,iBAAiB,EAAE,OAAkB,EAAE;QAChD,IAAI,CAAC69C,wBAAwB,EAAE;UAC7B,IAAI,CAAChxD,KAAK,CACR,IAAI,CAACc,KAAK,CAACiC,MAAM,GACbjJ,MAAM,CAACxC,cAAc,GACrB,IAAI,CAACzc,OAAO,CAACJ,MAAM,GACnBqf,MAAM,CAACzF,oBAAoB,GAC3ByF,MAAM,CAAC1F,cAAc,EACzB;YAAE1U,EAAE,EAAE,IAAI,CAACohB,KAAK,CAAC3B;UAAS,CAAC,CAC5B;QACH;QACA,OAAO,IAAI,CAACw9C,sBAAsB,CAChC1iD,IAAI,EACJ,KAAK,EACL,CAAC82D,gBAAgB,IAAIC,wBAAwB,CAC9C;MACH,KAAA,EAAA;QACE,IAAI,CAACD,gBAAgB,EAAE,IAAI,CAAC3/D,UAAU,EAAE;QACxC,OAAO,IAAI,CAACwrD,UAAU,CACpB,IAAI,CAACqF,mBAAmB,CACtBrhD,UAAU,EACV3G,IAAI,CACL,EACD,IAAI,CACL;MAEH,KAAA,EAAA;QACE,OAAO,IAAI,CAACo3D,gBAAgB,CAACp3D,IAAI,CAA0B;MAC7D,KAAA,EAAA;QACE,OAAO,IAAI,CAACq3D,oBAAoB,CAACr3D,IAAI,CAA8B;MACrE,KAAA,EAAA;QACE,OAAO,IAAI,CAACs3D,oBAAoB,CAACt3D,IAAI,CAA8B;MACrE,KAAA,EAAA;QACE,OAAO,IAAI,CAACu3D,mBAAmB,CAACv3D,IAAI,CAA6B;MACnE,KAAA,EAAA;QACE,OAAO,IAAI,CAACw3D,iBAAiB,CAACx3D,IAAI,CAA2B;MAE/D,KAAA,GAAA;QAEE,IACE,IAAI,CAAC6G,KAAK,CAAC+M,WAAW,IACtB,CAAC,IAAI,CAAC2iD,mCAAmC,EAAE,EAC3C;UACA;QACF;QACA,IAAI,CAAC57C,YAAY,CAAC,4BAA4B,CAAC;QAC/C,IAAI,CAAC,IAAI,CAACpM,KAAK,CAACnF,QAAQ,IAAI,IAAI,CAACmF,KAAK,CAACf,UAAU,EAAE;UACjD,IAAI,CAACzH,KAAK,CAAClG,MAAM,CAAClE,0BAA0B,EAAE;YAC5ClW,EAAE,EAAE,IAAI,CAACohB,KAAK,CAAC3B;UACjB,CAAC,CAAC;QACJ,CAAC,MAAM,IAAI,CAAC4xD,gBAAgB,EAAE;UAC5B,IAAI,CAAC/wD,KAAK,CAAClG,MAAM,CAAC3E,4BAA4B,EAAE;YAC9CzV,EAAE,EAAE,IAAI,CAACohB,KAAK,CAAC3B;UACjB,CAAC,CAAC;QACJ;QACA,OAAO,IAAI,CAAC09C,iBAAiB,CAC3B5iD,IAAI,EACJ,OAAO,CACR;MACH,KAAA,EAAA;QAAc;UACZ,IAAI,IAAI,CAAC6G,KAAK,CAAC+M,WAAW,EAAE;YAC1B;UACF;UAGA,MAAMhK,IAAI,GAAG,IAAI,CAACmP,cAAc,EAAE;UAClC,MAAM+I,MAAM,GAAG,IAAI,CAACxI,cAAc,CAAC1P,IAAI,CAAC;UACxC,IAAIkY,MAAM,OAAgC,EAAE;YAC1C,IAAI,CAACg1C,gBAAgB,IAAI,IAAI,CAAC10C,qBAAqB,EAAE,EAAE;YACvD,IACE,CAAC,IAAI,CAAC8nC,yBAAyB,CAACpoC,MAAM,EAAElY,IAAI,CAAC,IAC7CkY,MAAM,KAAA,GAA6B,EACnC;cACA;YACF;UACF;QACF;MAEA,KAAA,EAAA;QAAgB;UACd,IAAI,CAACg1C,gBAAgB,EAAE;YACrB,IAAI,CAAC/wD,KAAK,CAAClG,MAAM,CAAC3E,4BAA4B,EAAE;cAC9CzV,EAAE,EAAE,IAAI,CAACohB,KAAK,CAAC3B;YACjB,CAAC,CAAC;UACJ;QACF;MAEA,KAAA,EAAA;QAAc;UACZ,MAAMzS,IAAI,GAAG,IAAI,CAACoU,KAAK,CAACnX,KAAK;UAC7B,OAAO,IAAI,CAACkzD,iBAAiB,CAC3B5iD,IAAI,EACJvN,IAAI,CACL;QACH;MACA,KAAA,EAAA;QACE,OAAO,IAAI,CAACglE,mBAAmB,CAACz3D,IAAI,CAA6B;MACnE,KAAA,EAAA;QACE,OAAO,IAAI,CAAC03D,kBAAkB,CAAC13D,IAAI,CAA4B;MACjE,KAAA,CAAA;QACE,OAAO,IAAI,CAACsqD,UAAU,EAAE;MAC1B,KAAA,EAAA;QACE,OAAO,IAAI,CAACqN,mBAAmB,CAAC33D,IAAI,CAA6B;MACnE,KAAA,EAAA;QAAiB;UACf,MAAM43D,iBAAiB,GAAG,IAAI,CAAC1+C,iBAAiB,EAAE;UAClD,IACE0+C,iBAAiB,KAAA,EAA8B,IAC/CA,iBAAiB,OAAkB,EACnC;YACA;UACF;QACF;MAEA,KAAA,EAAA;QAAiB;UACf,IAAI,CAAC,IAAI,CAACh3E,OAAO,CAACd,2BAA2B,IAAI,CAAC6iB,QAAQ,EAAE;YAC1D,IAAI,CAACoD,KAAK,CAAClG,MAAM,CAAC9E,sBAAsB,EAAE;cACxCtV,EAAE,EAAE,IAAI,CAACohB,KAAK,CAAC3B;YACjB,CAAC,CAAC;UACJ;UAEA,IAAI,CAAC0E,IAAI,EAAE;UAEX,IAAIsqB,MAAM;UACV,IAAIsuB,SAAS,OAAe,EAAE;YAC5BtuB,MAAM,GAAG,IAAI,CAAC3H,WAAW,CAACvsB,IAAI,CAAgC;YAE9D,IACEk0B,MAAM,CAAC7hC,IAAI,KAAK,mBAAmB,KAClC,CAAC6hC,MAAM,CAAC9K,UAAU,IAAI8K,MAAM,CAAC9K,UAAU,KAAK,OAAO,CAAC,EACrD;cACA,IAAI,CAAC9Z,iBAAiB,GAAG,IAAI;YAC/B;UACF,CAAC,MAAM;YACL4kB,MAAM,GAAG,IAAI,CAACxtB,WAAW,CACvB1G,IAAI,EAKJ2G,UAAU,CACX;YAED,IACGutB,MAAM,CAAC7hC,IAAI,KAAK,wBAAwB,KACtC,CAAC6hC,MAAM,CAACvH,UAAU,IAAIuH,MAAM,CAACvH,UAAU,KAAK,OAAO,CAAC,IACtDuH,MAAM,CAAC7hC,IAAI,KAAK,sBAAsB,KACpC,CAAC6hC,MAAM,CAACvH,UAAU,IAAIuH,MAAM,CAACvH,UAAU,KAAK,OAAO,CAAE,IACxDuH,MAAM,CAAC7hC,IAAI,KAAK,0BAA0B,EAC1C;cACA,IAAI,CAACid,iBAAiB,GAAG,IAAI;YAC/B;UACF;UAEA,IAAI,CAAC+kB,uBAAuB,CAACH,MAAM,CAAC;UAEpC,OAAOA,MAAM;QACf;MAEA;QAAS;UACP,IAAI,IAAI,CAAC2jC,eAAe,EAAE,EAAE;YAC1B,IAAI,CAACf,gBAAgB,EAAE;cACrB,IAAI,CAAC/wD,KAAK,CAAClG,MAAM,CAAClN,qCAAqC,EAAE;gBACvDlN,EAAE,EAAE,IAAI,CAACohB,KAAK,CAAC3B;cACjB,CAAC,CAAC;YACJ;YACA,IAAI,CAAC0E,IAAI,EAAE;YACX,OAAO,IAAI,CAAC84C,sBAAsB,CAChC1iD,IAAI,EACJ,IAAI,EACJ,CAAC82D,gBAAgB,IAAIC,wBAAwB,CAC9C;UACH;QACF;IAAA;IAQF,MAAMe,SAAS,GAAG,IAAI,CAACjxD,KAAK,CAACnX,KAAK;IAClC,MAAMijC,IAAI,GAAG,IAAI,CAAC/H,eAAe,EAAE;IAEnC,IACE/9B,iBAAiB,CAAC21D,SAAS,CAAC,IAC5B7vB,IAAI,CAACtgC,IAAI,KAAK,YAAY,IAC1B,IAAI,CAAComB,GAAG,IAAU,EAClB;MACA,OAAO,IAAI,CAACs/C,qBAAqB,CAC/B/3D,IAAI,EACJ83D,SAAS,EAETnlC,IAAI,EACJnyB,KAAK,CACN;IACH,CAAC,MAAM;MACL,OAAO,IAAI,CAACkyB,wBAAwB,CAClC1yB,IAAI,EACJ2yB,IAAI,EACJhsB,UAAU,CACX;IACH;EACF;EAEA0tB,uBAAuBA,CAACr0B,IAAY,EAAQ;IAC1C,IAAI,CAAC,IAAI,CAACpf,OAAO,CAACd,2BAA2B,IAAI,CAAC,IAAI,CAACspB,QAAQ,EAAE;MAC/D,IAAI,CAACrD,KAAK,CAAClG,MAAM,CAACjP,mBAAmB,EAAE;QAAEnL,EAAE,EAAEua;MAAK,CAAC,CAAC;IACtD;EACF;EAEAg4D,6BAA6BA,CAAAA,EAAY;IACvC,IAAI,IAAI,CAAC1xD,SAAS,CAAC,mBAAmB,CAAC,EAAE,OAAO,IAAI;IACpD,OACE,IAAI,CAACA,SAAS,CAAC,YAAY,CAAC,IAC5B,IAAI,CAAC5C,eAAe,CAAC,YAAY,EAAE,wBAAwB,CAAC,KAAK,KAAK;EAE1E;EAQAskD,mBAAmBA,CACjBiQ,eAAqC,EACrCC,SAAY,EACZC,UAA0E,EACvE;IACH,IAAIF,eAAe,EAAE;MACnB,IAAIC,SAAS,CAACvxD,UAAU,IAAIuxD,SAAS,CAACvxD,UAAU,CAACvY,MAAM,GAAG,CAAC,EAAE;QAG3D,IACE,OAAO,IAAI,CAACsV,eAAe,CACzB,YAAY,EACZ,wBAAwB,CACzB,KAAK,SAAS,EACf;UAIA,IAAI,CAACqC,KAAK,CAAClG,MAAM,CAAChM,2BAA2B,EAAE;YAC7CpO,EAAE,EAAEyyE,SAAS,CAACvxD,UAAU,CAAC,CAAC;UAC5B,CAAC,CAAC;QACJ;QACAuxD,SAAS,CAACvxD,UAAU,CAACsJ,OAAO,CAAC,GAAGgoD,eAAe,CAAC;MAClD,CAAC,MAAM;QACLC,SAAS,CAACvxD,UAAU,GAAGsxD,eAAe;MACxC;MACA,IAAI,CAAC3yC,0BAA0B,CAAC4yC,SAAS,EAAED,eAAe,CAAC,CAAC,CAAC,CAAC;MAC9D,IAAIE,UAAU,EAAE,IAAI,CAAC7yC,0BAA0B,CAAC6yC,UAAU,EAAED,SAAS,CAAC;IACxE;IACA,OAAOA,SAAS;EAClB;EAEA1Q,uBAAuBA,CAAAA,EAAY;IACjC,OAAO,IAAI,CAACtxC,KAAK,CAAW,EAAA,CAAA;EAC9B;EAEA46C,eAAeA,CAAesH,WAAqB,EAAiB;IAClE,MAAMzxD,UAAU,GAAG,EAAE;IACrB,GAAG;MACDA,UAAU,CAACljB,IAAI,CAAC,IAAI,CAAC4tD,cAAc,EAAE,CAAC;IACxC,CAAC,QAAQ,IAAI,CAACn7B,KAAK,CAAO,EAAA,CAAA;IAE1B,IAAI,IAAI,CAACA,KAAK,CAAA,EAAA,CAAY,EAAE;MAC1B,IAAI,CAACkiD,WAAW,EAAE;QAChB,IAAI,CAACjhE,UAAU,EAAE;MACnB;MAEA,IAAI,CAAC,IAAI,CAAC6gE,6BAA6B,EAAE,EAAE;QACzC,IAAI,CAACjyD,KAAK,CAAClG,MAAM,CAAC9L,oBAAoB,EAAE;UAAEtO,EAAE,EAAE,IAAI,CAACohB,KAAK,CAAC3B;QAAS,CAAC,CAAC;MACtE;IACF,CAAC,MAAM,IAAI,CAAC,IAAI,CAACsiD,uBAAuB,EAAE,EAAE;MAC1C,MAAM,IAAI,CAACzhD,KAAK,CAAClG,MAAM,CAAC5E,0BAA0B,EAAE;QAClDxV,EAAE,EAAE,IAAI,CAACohB,KAAK,CAAC3B;MACjB,CAAC,CAAC;IACJ;IAEA,OAAOyB,UAAU;EACnB;EAEA0qC,cAAcA,CAAAA,EAA4B;IACxC,IAAI,CAACrzB,eAAe,CAAC,CAAC,YAAY,EAAE,mBAAmB,CAAC,CAAC;IAEzD,MAAMhe,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAe;IAC1C,IAAI,CAACuF,IAAI,EAAE;IAEX,IAAI,IAAI,CAACtD,SAAS,CAAC,YAAY,CAAC,EAAE;MAChC,MAAMpB,QAAQ,GAAG,IAAI,CAAC2B,KAAK,CAAC3B,QAAQ;MACpC,IAAIytB,IAAkB;MAEtB,IAAI,IAAI,CAACzc,KAAK,CAAA,EAAA,CAAW,EAAE;QACzB,MAAMhR,QAAQ,GAAG,IAAI,CAAC2B,KAAK,CAAC3B,QAAQ;QACpC,IAAI,CAAC0E,IAAI,EAAE;QACX+oB,IAAI,GAAG,IAAI,CAAC/H,eAAe,EAAE;QAC7B,IAAI,CAACpI,MAAM,CAAW,EAAA,CAAA;QACtBmQ,IAAI,GAAG,IAAI,CAAC0/B,eAAe,CAACntD,QAAQ,EAAEytB,IAAI,CAAC;QAE3C,MAAM0lC,cAAc,GAAG,IAAI,CAACxxD,KAAK,CAAC3B,QAAQ;QAC1ClF,IAAI,CAACyB,UAAU,GAAG,IAAI,CAAC8lD,4BAA4B,CAAC50B,IAAI,CAAC;QACzD,IACE,IAAI,CAACjvB,eAAe,CAAC,YAAY,EAAE,wBAAwB,CAAC,KAC1D,KAAK,IACP1D,IAAI,CAACyB,UAAU,KAAKkxB,IAAI,EACxB;UACA,IAAI,CAAC5sB,KAAK,CAAClG,MAAM,CAAClM,oCAAoC,EAAE;YACtDlO,EAAE,EAAE4yE;UACN,CAAC,CAAC;QACJ;MACF,CAAC,MAAM;QACL1lC,IAAI,GAAG,IAAI,CAACzH,eAAe,CAAC,KAAK,CAAC;QAElC,OAAO,IAAI,CAACzS,GAAG,CAAA,EAAA,CAAQ,EAAE;UACvB,MAAMzY,IAAI,GAAG,IAAI,CAACqlB,WAAW,CAACngB,QAAQ,CAAC;UACvClF,IAAI,CAACvQ,MAAM,GAAGkjC,IAAI;UAClB,IAAI,IAAI,CAACzc,KAAK,CAAA,GAAA,CAAgB,EAAE;YAC9B,IAAI,CAACvQ,UAAU,CAACC,cAAc,CAC5B,IAAI,CAACiB,KAAK,CAACnX,KAAK,EAChB,IAAI,CAACmX,KAAK,CAAC3B,QAAQ,CACpB;YACDlF,IAAI,CAACwjB,QAAQ,GAAG,IAAI,CAAC/f,gBAAgB,EAAE;UACzC,CAAC,MAAM;YACLzD,IAAI,CAACwjB,QAAQ,GAAG,IAAI,CAAC0H,eAAe,CAAC,IAAI,CAAC;UAC5C;UACAlrB,IAAI,CAACsE,QAAQ,GAAG,KAAK;UACrBquB,IAAI,GAAG,IAAI,CAACpuB,UAAU,CAACvE,IAAI,EAAE,kBAAkB,CAAC;QAClD;QAEAA,IAAI,CAACyB,UAAU,GAAG,IAAI,CAAC8lD,4BAA4B,CAAC50B,IAAI,CAAC;MAC3D;IACF,CAAC,MAAM;MACL3yB,IAAI,CAACyB,UAAU,GAAG,IAAI,CAACkuD,mBAAmB,EAAE;IAC9C;IACA,OAAO,IAAI,CAACprD,UAAU,CAACvE,IAAI,EAAE,WAAW,CAAC;EAC3C;EAEAunD,4BAA4BA,CAAe50B,IAAkB,EAAgB;IAC3E,IAAI,IAAI,CAACla,GAAG,CAAA,EAAA,CAAW,EAAE;MACvB,MAAMzY,IAAI,GAAG,IAAI,CAAC2H,eAAe,CAACgrB,IAAI,CAAC;MACvC3yB,IAAI,CAACmG,MAAM,GAAGwsB,IAAI;MAClB3yB,IAAI,CAACqG,SAAS,GAAG,IAAI,CAACqzB,4BAA4B,CAAA,EAAA,EAAY,KAAK,CAAC;MACpE,IAAI,CAACjE,gBAAgB,CAACz1B,IAAI,CAACqG,SAAS,CAAC;MACrC,OAAO,IAAI,CAAC9B,UAAU,CAACvE,IAAI,EAAE,gBAAgB,CAAC;IAChD;IAEA,OAAO2yB,IAAI;EACb;EAUAqkC,2BAA2BA,CACzBh3D,IAAoD,EACpDoqD,OAAgB,EACwB;IACxC,IAAI,CAACxgD,IAAI,EAAE;IAEX,IAAI,IAAI,CAACyY,gBAAgB,EAAE,EAAE;MAC3BriB,IAAI,CAAC/d,KAAK,GAAG,IAAI;IACnB,CAAC,MAAM;MACL+d,IAAI,CAAC/d,KAAK,GAAG,IAAI,CAACipC,eAAe,EAAE;MACnC,IAAI,CAAC5I,SAAS,EAAE;IAClB;IAEA,IAAI,CAAC6nC,mBAAmB,CAACnqD,IAAI,EAAEoqD,OAAO,CAAC;IAEvC,OAAO,IAAI,CAAC7lD,UAAU,CACpBvE,IAAI,EACJoqD,OAAO,GAAG,gBAAgB,GAAG,mBAAmB,CACjD;EACH;EAEAD,mBAAmBA,CACjBnqD,IAAoD,EACpDoqD,OAAgB,EAChB;IACA,IAAIx6D,CAAC;IACL,KAAKA,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACiX,KAAK,CAAC2M,MAAM,CAACplB,MAAM,EAAE,EAAEwB,CAAC,EAAE;MAC7C,MAAM0oE,GAAG,GAAG,IAAI,CAACzxD,KAAK,CAAC2M,MAAM,CAAC5jB,CAAC,CAAC;MAChC,IAAIoQ,IAAI,CAAC/d,KAAK,IAAI,IAAI,IAAIq2E,GAAG,CAAC51E,IAAI,KAAKsd,IAAI,CAAC/d,KAAK,CAACS,IAAI,EAAE;QACtD,IAAI41E,GAAG,CAAC7lE,IAAI,IAAI,IAAI,KAAK23D,OAAO,IAAIkO,GAAG,CAAC7lE,IAAI,KAAK,MAAM,CAAC,EAAE;QAC1D,IAAIuN,IAAI,CAAC/d,KAAK,IAAImoE,OAAO,EAAE;MAC7B;IACF;IACA,IAAIx6D,CAAC,KAAK,IAAI,CAACiX,KAAK,CAAC2M,MAAM,CAACplB,MAAM,EAAE;MAClC,MAAMiE,IAAI,GAAG+3D,OAAO,GAAG,gBAAgB,GAAG,mBAAmB;MAC7D,IAAI,CAACrkD,KAAK,CAAClG,MAAM,CAACzK,oBAAoB,EAAE;QAAE3P,EAAE,EAAEua,IAAI;QAAE3N;MAAK,CAAC,CAAC;IAC7D;EACF;EAEA4kE,sBAAsBA,CACpBj3D,IAAiC,EACZ;IACrB,IAAI,CAAC4J,IAAI,EAAE;IACX,IAAI,CAAC0Y,SAAS,EAAE;IAChB,OAAO,IAAI,CAAC/d,UAAU,CAACvE,IAAI,EAAE,mBAAmB,CAAC;EACnD;EAEAu4D,qBAAqBA,CAAAA,EAA6B;IAChD,IAAI,CAAC/1C,MAAM,CAAW,EAAA,CAAA;IACtB,MAAMrO,GAAG,GAAG,IAAI,CAACyW,eAAe,EAAE;IAClC,IAAI,CAACpI,MAAM,CAAW,EAAA,CAAA;IACtB,OAAOrO,GAAG;EACZ;EAGA+iD,qBAAqBA,CAEnBl3D,IAAgC,EACZ;IACpB,IAAI,CAAC4J,IAAI,EAAE;IACX,IAAI,CAAC/C,KAAK,CAAC2M,MAAM,CAAC/vB,IAAI,CAACuxE,SAAS,CAAC;IAGjCh1D,IAAI,CAACgD,IAAI,GAIP,IAAI,CAACyxD,kCAAkC,CAAC,MAEtC,IAAI,CAACoC,cAAc,EAAE,CACtB;IAEH,IAAI,CAAChwD,KAAK,CAAC2M,MAAM,CAACtlB,GAAG,EAAE;IAEvB,IAAI,CAACs0B,MAAM,CAAW,EAAA,CAAA;IACtBxiB,IAAI,CAAC0I,IAAI,GAAG,IAAI,CAAC6vD,qBAAqB,EAAE;IACxC,IAAI,CAAC9/C,GAAG,CAAS,EAAA,CAAA;IACjB,OAAO,IAAI,CAAClU,UAAU,CAACvE,IAAI,EAAE,kBAAkB,CAAC;EAClD;EAUAm3D,iBAAiBA,CAEfn3D,IAAwC,EAC7B;IACX,IAAI,CAAC4J,IAAI,EAAE;IACX,IAAI,CAAC/C,KAAK,CAAC2M,MAAM,CAAC/vB,IAAI,CAACuxE,SAAS,CAAC;IAEjC,IAAIwD,OAAO,GAAG,IAAI;IAElB,IAAI,IAAI,CAACpJ,cAAc,EAAE,IAAI,IAAI,CAACptC,aAAa,CAAA,EAAA,CAAW,EAAE;MAC1Dw2C,OAAO,GAAG,IAAI,CAAC3xD,KAAK,CAACC,eAAe;IACtC;IACA,IAAI,CAACyH,KAAK,CAACF,KAAK,CAACrE,WAAW,CAAC;IAC7B,IAAI,CAACwY,MAAM,CAAW,EAAA,CAAA;IAEtB,IAAI,IAAI,CAACtM,KAAK,CAAA,EAAA,CAAS,EAAE;MACvB,IAAIsiD,OAAO,KAAK,IAAI,EAAE;QACpB,IAAI,CAACrhE,UAAU,CAACqhE,OAAO,CAAC;MAC1B;MACA,OAAO,IAAI,CAACC,QAAQ,CAACz4D,IAAI,EAA4B,IAAI,CAAC;IAC5D;IAEA,MAAM04D,aAAa,GAAG,IAAI,CAACh3C,YAAY,CAAS,EAAA,CAAA;IAChD,MAAMi3C,eAAe,GAAG,IAAI,CAACj3C,YAAY,CAAW,GAAA,CAAA;IACpD,MAAMk3C,YAAY,GACfF,aAAa,IAAI,IAAI,CAACtC,uBAAuB,EAAE,IAC/CuC,eAAe,IAAI,IAAI,CAACnC,gBAAgB,EAAG;IAC9C,IAAI,IAAI,CAACtgD,KAAK,CAAS,EAAA,CAAA,IAAI,IAAI,CAACA,KAAK,CAAA,EAAA,CAAW,IAAI0iD,YAAY,EAAE;MAChE,MAAMC,QAAQ,GAAG,IAAI,CAACx0D,SAAS,EAAyB;MACxD,MAAM5R,IAAI,GAAG,IAAI,CAACoU,KAAK,CAACnX,KAAK;MAC7B,IAAI,CAACka,IAAI,EAAE;MACX,IAAI,CAACkvD,QAAQ,CAACD,QAAQ,EAAE,IAAI,EAAEpmE,IAAI,CAAC;MACnC,MAAMuhB,IAAI,GAAG,IAAI,CAACzP,UAAU,CAACs0D,QAAQ,EAAE,qBAAqB,CAAC;MAE7D,MAAME,OAAO,GAAG,IAAI,CAAC7iD,KAAK,CAAQ,EAAA,CAAA;MAClC,IAAI6iD,OAAO,IAAIJ,eAAe,EAAE;QAC9B,IAAI,CAAC5yD,KAAK,CAAClG,MAAM,CAAC7K,UAAU,EAAE;UAAEvP,EAAE,EAAEuuB;QAAK,CAAC,CAAC;MAC7C;MACA,IACE,CAAC+kD,OAAO,IAAI,IAAI,CAACr3C,YAAY,CAAA,GAAA,CAAQ,KACrC1N,IAAI,CAACsxC,YAAY,CAACl3D,MAAM,KAAK,CAAC,EAC9B;QACA,OAAO,IAAI,CAAC4qE,UAAU,CAACh5D,IAAI,EAAuBgU,IAAI,EAAEwkD,OAAO,CAAC;MAClE;MACA,IAAIA,OAAO,KAAK,IAAI,EAAE;QACpB,IAAI,CAACrhE,UAAU,CAACqhE,OAAO,CAAC;MAC1B;MACA,OAAO,IAAI,CAACC,QAAQ,CAACz4D,IAAI,EAA4BgU,IAAI,CAAC;IAC5D;IAIA,MAAMilD,eAAe,GAAG,IAAI,CAACv3C,YAAY,CAAW,EAAA,CAAA;IAEpD,MAAMvc,mBAAmB,GAAG,IAAIof,gBAAgB,EAAE;IAClD,MAAMvQ,IAAI,GAAG,IAAI,CAAC4W,eAAe,CAAC,IAAI,EAAEzlB,mBAAmB,CAAC;IAC5D,MAAM+zD,OAAO,GAAG,IAAI,CAACx3C,YAAY,CAAQ,GAAA,CAAA;IACzC,IAAIw3C,OAAO,EAAE;MAEX,IAAIR,aAAa,EAAE;QACjB,IAAI,CAAC3yD,KAAK,CAAClG,MAAM,CAAC3K,QAAQ,EAAE;UAAEzP,EAAE,EAAEuuB;QAAK,CAAC,CAAC;MAC3C;MAEA,IAEEwkD,OAAO,KAAK,IAAI,IAChBS,eAAe,IACfjlD,IAAI,CAAC3hB,IAAI,KAAK,YAAY,EAC1B;QAKA,IAAI,CAAC0T,KAAK,CAAClG,MAAM,CAAC5K,UAAU,EAAE;UAAExP,EAAE,EAAEuuB;QAAK,CAAC,CAAC;MAC7C;IACF;IACA,IAAIklD,OAAO,IAAI,IAAI,CAAChjD,KAAK,IAAQ,EAAE;MACjC,IAAI,CAACoO,yBAAyB,CAACnf,mBAAmB,CAAC;MACnD,IAAI,CAACM,YAAY,CAACuO,IAAI,EAAc,IAAI,CAAC;MACzC,MAAM3hB,IAAI,GAAG6mE,OAAO,GAAG,gBAAgB,GAAG,gBAAgB;MAC1D,IAAI,CAACtnB,SAAS,CAAC59B,IAAI,EAAE;QAAE69B,EAAE,EAAE;UAAEx/C;QAAK;MAAE,CAAC,CAAC;MACtC,OAAO,IAAI,CAAC2mE,UAAU,CACpBh5D,IAAI,EAEJgU,IAAI,EACJwkD,OAAO,CACR;IACH,CAAC,MAAM;MACL,IAAI,CAACx1C,qBAAqB,CAAC7d,mBAAmB,EAAE,IAAI,CAAC;IACvD;IACA,IAAIqzD,OAAO,KAAK,IAAI,EAAE;MACpB,IAAI,CAACrhE,UAAU,CAACqhE,OAAO,CAAC;IAC1B;IACA,OAAO,IAAI,CAACC,QAAQ,CAACz4D,IAAI,EAA4BgU,IAAI,CAAC;EAC5D;EAGA0uC,sBAAsBA,CAEpB1iD,IAAmC,EACnCgC,OAAgB,EAChBm3D,oBAA6B,EACN;IACvB,IAAI,CAACvvD,IAAI,EAAE;IACX,OAAO,IAAI,CAACkoD,aAAa,CACvB9xD,IAAI,EACJo5D,KACGD,oBAAoB,OAA0C,CAAC,CAAC,IAChEn3D,OAAO,OAA6B,CAAC,CAAC,CAC1C;EACH;EAGAo1D,gBAAgBA,CAAep3D,IAA2B,EAAE;IAC1D,IAAI,CAAC4J,IAAI,EAAE;IACX5J,IAAI,CAAC0I,IAAI,GAAG,IAAI,CAAC6vD,qBAAqB,EAAE;IAGxCv4D,IAAI,CAACkzB,UAAU,GAAG,IAAI,CAACm3B,+CAA+C,EAAE;IACxErqD,IAAI,CAACuzB,SAAS,GAAG,IAAI,CAAC9a,GAAG,CAAU,EAAA,CAAA,GAC/B,IAAI,CAAC4xC,+CAA+C,EAAE,GACtD,IAAI;IACR,OAAO,IAAI,CAAC9lD,UAAU,CAACvE,IAAI,EAAE,aAAa,CAAC;EAC7C;EAEAq3D,oBAAoBA,CAAer3D,IAA+B,EAAE;IAClE,IAAI,CAAC,IAAI,CAACikB,SAAS,CAAC5C,SAAS,IAAI,CAAC,IAAI,CAACzgC,OAAO,CAAChB,0BAA0B,EAAE;MACzE,IAAI,CAACmmB,KAAK,CAAClG,MAAM,CAACvK,aAAa,EAAE;QAAE7P,EAAE,EAAE,IAAI,CAACohB,KAAK,CAAC3B;MAAS,CAAC,CAAC;IAC/D;IAEA,IAAI,CAAC0E,IAAI,EAAE;IAMX,IAAI,IAAI,CAACyY,gBAAgB,EAAE,EAAE;MAC3BriB,IAAI,CAACb,QAAQ,GAAG,IAAI;IACtB,CAAC,MAAM;MACLa,IAAI,CAACb,QAAQ,GAAG,IAAI,CAACyrB,eAAe,EAAE;MACtC,IAAI,CAACtI,SAAS,EAAE;IAClB;IAEA,OAAO,IAAI,CAAC/d,UAAU,CAACvE,IAAI,EAAE,iBAAiB,CAAC;EACjD;EAGAs3D,oBAAoBA,CAAet3D,IAA+B,EAAE;IAClE,IAAI,CAAC4J,IAAI,EAAE;IACX5J,IAAI,CAACq5D,YAAY,GAAG,IAAI,CAACd,qBAAqB,EAAE;IAChD,MAAMe,KAAiC,GAAIt5D,IAAI,CAACs5D,KAAK,GAAG,EAAG;IAC3D,IAAI,CAAC92C,MAAM,CAAW,CAAA,CAAA;IACtB,IAAI,CAAC3b,KAAK,CAAC2M,MAAM,CAAC/vB,IAAI,CAACwxE,WAAW,CAAC;IACnC,IAAI,CAAC1mD,KAAK,CAACF,KAAK,CAACrE,WAAW,CAAC;IAM7B,IAAIuvD,GAAG;IACP,KAAK,IAAIC,UAAU,EAAE,CAAC,IAAI,CAACtjD,KAAK,GAAW,GAAI;MAC7C,IAAI,IAAI,CAACA,KAAK,CAAA,EAAA,CAAU,IAAI,IAAI,CAACA,KAAK,CAAA,EAAA,CAAa,EAAE;QACnD,MAAMujD,MAAM,GAAG,IAAI,CAACvjD,KAAK,CAAU,EAAA,CAAA;QACnC,IAAIqjD,GAAG,EAAE,IAAI,CAACh1D,UAAU,CAACg1D,GAAG,EAAE,YAAY,CAAC;QAE3CD,KAAK,CAAC71E,IAAI,CAAE81E,GAAG,GAAG,IAAI,CAACl1D,SAAS,EAAE,CAAE;QACpCk1D,GAAG,CAACrmC,UAAU,GAAG,EAAE;QACnB,IAAI,CAACtpB,IAAI,EAAE;QACX,IAAI6vD,MAAM,EAAE;UACVF,GAAG,CAAC7wD,IAAI,GAAG,IAAI,CAACkiB,eAAe,EAAE;QACnC,CAAC,MAAM;UACL,IAAI4uC,UAAU,EAAE;YACd,IAAI,CAACzzD,KAAK,CAAClG,MAAM,CAAC7G,wBAAwB,EAAE;cAC1CvT,EAAE,EAAE,IAAI,CAACohB,KAAK,CAACC;YACjB,CAAC,CAAC;UACJ;UACA0yD,UAAU,GAAG,IAAI;UACjBD,GAAG,CAAC7wD,IAAI,GAAG,IAAI;QACjB;QACA,IAAI,CAAC8Z,MAAM,CAAU,EAAA,CAAA;MACvB,CAAC,MAAM;QACL,IAAI+2C,GAAG,EAAE;UACPA,GAAG,CAACrmC,UAAU,CAACzvC,IAAI,CAAC,IAAI,CAACkzE,sBAAsB,EAAE,CAAC;QACpD,CAAC,MAAM;UACL,IAAI,CAACx/D,UAAU,EAAE;QACnB;MACF;IACF;IACA,IAAI,CAACoX,KAAK,CAACD,IAAI,EAAE;IACjB,IAAIirD,GAAG,EAAE,IAAI,CAACh1D,UAAU,CAACg1D,GAAG,EAAE,YAAY,CAAC;IAC3C,IAAI,CAAC3vD,IAAI,EAAE;IACX,IAAI,CAAC/C,KAAK,CAAC2M,MAAM,CAACtlB,GAAG,EAAE;IACvB,OAAO,IAAI,CAACqW,UAAU,CAACvE,IAAI,EAAE,iBAAiB,CAAC;EACjD;EAEAu3D,mBAAmBA,CAAev3D,IAA8B,EAAE;IAChE,IAAI,CAAC4J,IAAI,EAAE;IACX,IAAI,IAAI,CAACuY,qBAAqB,EAAE,EAAE;MAChC,IAAI,CAACpc,KAAK,CAAClG,MAAM,CAAC5G,iBAAiB,EAAE;QAAExT,EAAE,EAAE,IAAI,CAACohB,KAAK,CAACoB;MAAc,CAAC,CAAC;IACxE;IACAjI,IAAI,CAACb,QAAQ,GAAG,IAAI,CAACyrB,eAAe,EAAE;IACtC,IAAI,CAACtI,SAAS,EAAE;IAChB,OAAO,IAAI,CAAC/d,UAAU,CAACvE,IAAI,EAAE,gBAAgB,CAAC;EAChD;EAEA6nD,qBAAqBA,CAAAA,EAA0B;IAC7C,MAAM71B,KAAK,GAAG,IAAI,CAACgG,gBAAgB,EAAE;IAErC,IAAI,CAACzpB,KAAK,CAACF,KAAK,CACd,IAAI,CAACztB,OAAO,CAACJ,MAAM,IAAIwxC,KAAK,CAAC3/B,IAAI,KAAK,YAAY,GAC9C+X,kBAAkB,GAClB,CAAC,CACN;IACD,IAAI,CAACwnC,SAAS,CAAC5f,KAAK,EAAE;MACpB6f,EAAE,EAAE;QAAEx/C,IAAI,EAAE;MAAe,CAAA;MAC3BiT,OAAO,EAAEoG;IACX,CAAC,CAAC;IAEF,OAAOsmB,KAAK;EACd;EAEAwlC,iBAAiBA,CAEfx3D,IAA4B,EACZ;IAChB,IAAI,CAAC4J,IAAI,EAAE;IAEX5J,IAAI,CAAC05D,KAAK,GAAG,IAAI,CAACpP,UAAU,EAAE;IAC9BtqD,IAAI,CAAC25D,OAAO,GAAG,IAAI;IAEnB,IAAI,IAAI,CAACzjD,KAAK,CAAA,EAAA,CAAW,EAAE;MACzB,MAAM0jD,MAAM,GAAG,IAAI,CAACv1D,SAAS,EAAiB;MAC9C,IAAI,CAACuF,IAAI,EAAE;MACX,IAAI,IAAI,CAACsM,KAAK,CAAA,EAAA,CAAW,EAAE;QACzB,IAAI,CAACsM,MAAM,CAAW,EAAA,CAAA;QACtBo3C,MAAM,CAAC5nC,KAAK,GAAG,IAAI,CAAC61B,qBAAqB,EAAE;QAC3C,IAAI,CAACrlC,MAAM,CAAW,EAAA,CAAA;MACxB,CAAC,MAAM;QACLo3C,MAAM,CAAC5nC,KAAK,GAAG,IAAI;QACnB,IAAI,CAACzjB,KAAK,CAACF,KAAK,CAACrE,WAAW,CAAC;MAC/B;MAGA4vD,MAAM,CAAC52D,IAAI,GAGT,IAAI,CAACyxD,kCAAkC,CAAC,MAEtC,IAAI,CAACnK,UAAU,CAAC,KAAK,EAAE,KAAK,CAAC,CAC9B;MAEH,IAAI,CAAC/7C,KAAK,CAACD,IAAI,EAAE;MACjBtO,IAAI,CAAC25D,OAAO,GAAG,IAAI,CAACp1D,UAAU,CAACq1D,MAAM,EAAE,aAAa,CAAC;IACvD;IAEA55D,IAAI,CAAC65D,SAAS,GAAG,IAAI,CAACphD,GAAG,CAAa,EAAA,CAAA,GAAG,IAAI,CAAC6xC,UAAU,EAAE,GAAG,IAAI;IAEjE,IAAI,CAACtqD,IAAI,CAAC25D,OAAO,IAAI,CAAC35D,IAAI,CAAC65D,SAAS,EAAE;MACpC,IAAI,CAAC9zD,KAAK,CAAClG,MAAM,CAAC3G,gBAAgB,EAAE;QAAEzT,EAAE,EAAEua;MAAK,CAAC,CAAC;IACnD;IAEA,OAAO,IAAI,CAACuE,UAAU,CAACvE,IAAI,EAAE,cAAc,CAAC;EAC9C;EAIA4iD,iBAAiBA,CAEf5iD,IAAmC,EACnCvN,IAAuC,EACvC4yD,uBAAgC,GAAG,KAAK,EACjB;IACvB,IAAI,CAACz7C,IAAI,EAAE;IACX,IAAI,CAACkvD,QAAQ,CAAC94D,IAAI,EAAE,KAAK,EAAEvN,IAAI,EAAE4yD,uBAAuB,CAAC;IACzD,IAAI,CAAC/iC,SAAS,EAAE;IAChB,OAAO,IAAI,CAAC/d,UAAU,CAACvE,IAAI,EAAE,qBAAqB,CAAC;EACrD;EAGAy3D,mBAAmBA,CAEjBz3D,IAA8B,EACZ;IAClB,IAAI,CAAC4J,IAAI,EAAE;IACX5J,IAAI,CAAC0I,IAAI,GAAG,IAAI,CAAC6vD,qBAAqB,EAAE;IACxC,IAAI,CAAC1xD,KAAK,CAAC2M,MAAM,CAAC/vB,IAAI,CAACuxE,SAAS,CAAC;IAGjCh1D,IAAI,CAACgD,IAAI,GAIP,IAAI,CAACyxD,kCAAkC,CAAC,MAEtC,IAAI,CAACoC,cAAc,EAAE,CACtB;IAEH,IAAI,CAAChwD,KAAK,CAAC2M,MAAM,CAACtlB,GAAG,EAAE;IAEvB,OAAO,IAAI,CAACqW,UAAU,CAACvE,IAAI,EAAE,gBAAgB,CAAC;EAChD;EAEA03D,kBAAkBA,CAEhB13D,IAA6B,EACZ;IACjB,IAAI,IAAI,CAAC6G,KAAK,CAACiC,MAAM,EAAE;MACrB,IAAI,CAAC/C,KAAK,CAAClG,MAAM,CAACrC,UAAU,EAAE;QAAE/X,EAAE,EAAE,IAAI,CAACohB,KAAK,CAAC3B;MAAS,CAAC,CAAC;IAC5D;IACA,IAAI,CAAC0E,IAAI,EAAE;IACX5J,IAAI,CAACvQ,MAAM,GAAG,IAAI,CAAC8oE,qBAAqB,EAAE;IAG1Cv4D,IAAI,CAACgD,IAAI,GAKP,IAAI,CAACyxD,kCAAkC,CAAC,MAEtC,IAAI,CAACoC,cAAc,EAAE,CACtB;IAEH,OAAO,IAAI,CAACtyD,UAAU,CAACvE,IAAI,EAAE,eAAe,CAAC;EAC/C;EAEA23D,mBAAmBA,CAAC33D,IAA8B,EAAoB;IACpE,IAAI,CAAC4J,IAAI,EAAE;IACX,OAAO,IAAI,CAACrF,UAAU,CAACvE,IAAI,EAAE,gBAAgB,CAAC;EAChD;EAGA+3D,qBAAqBA,CAEnB/3D,IAAgC,EAChC83D,SAAiB,EACjBnlC,IAAkB,EAClBnyB,KAAyB,EACL;IACpB,KAAK,MAAMve,KAAK,IAAI,IAAI,CAAC4kB,KAAK,CAAC2M,MAAM,EAAE;MACrC,IAAIvxB,KAAK,CAACS,IAAI,KAAKo1E,SAAS,EAAE;QAC5B,IAAI,CAAC/xD,KAAK,CAAClG,MAAM,CAACpI,kBAAkB,EAAE;UACpChS,EAAE,EAAEktC,IAAI;UACRj7B,SAAS,EAAEogE;QACb,CAAC,CAAC;MACJ;IACF;IAEA,MAAMrlE,IAAI,GAAGpF,WAAW,CAAC,IAAI,CAACwZ,KAAK,CAACxU,IAAI,CAAC,GACrC,MAAM,GACN,IAAI,CAAC6jB,KAAK,IAAY,GACtB,QAAQ,GACR,IAAI;IACR,KAAK,IAAItmB,CAAC,GAAG,IAAI,CAACiX,KAAK,CAAC2M,MAAM,CAACplB,MAAM,GAAG,CAAC,EAAEwB,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;MACtD,MAAM3N,KAAK,GAAG,IAAI,CAAC4kB,KAAK,CAAC2M,MAAM,CAAC5jB,CAAC,CAAC;MAClC,IAAI3N,KAAK,CAAC63E,cAAc,KAAK95D,IAAI,CAACrR,KAAK,EAAE;QACvC1M,KAAK,CAAC63E,cAAc,GAAG,IAAI,CAACjzD,KAAK,CAAClY,KAAK;QACvC1M,KAAK,CAACwQ,IAAI,GAAGA,IAAI;MACnB,CAAC,MAAM;QACL;MACF;IACF;IAEA,IAAI,CAACoU,KAAK,CAAC2M,MAAM,CAAC/vB,IAAI,CAAC;MACrBf,IAAI,EAAEo1E,SAAS;MACfrlE,IAAI,EAAEA,IAAI;MACVqnE,cAAc,EAAE,IAAI,CAACjzD,KAAK,CAAClY;IAC7B,CAAC,CAAC;IAEFqR,IAAI,CAACgD,IAAI,GACPxC,KAAK,IAA0C,GAC3C,IAAI,CAAC6pD,+CAA+C,CAAC,IAAI,CAAC,GAC1D,IAAI,CAACwM,cAAc,EAAE;IAE3B,IAAI,CAAChwD,KAAK,CAAC2M,MAAM,CAACtlB,GAAG,EAAE;IACvB8R,IAAI,CAAC/d,KAAK,GAAG0wC,IAAI;IACjB,OAAO,IAAI,CAACpuB,UAAU,CAACvE,IAAI,EAAE,kBAAkB,CAAC;EAClD;EAEA0yB,wBAAwBA,CACtB1yB,IAAmC,EACnC2yB,IAAkB,EAElBhsB,UAAgC,EAChC;IACA3G,IAAI,CAACyB,UAAU,GAAGkxB,IAAI;IACtB,IAAI,CAACrQ,SAAS,EAAE;IAChB,OAAO,IAAI,CAAC/d,UAAU,CAACvE,IAAI,EAAE,qBAAqB,CAAC;EACrD;EAMAsqD,UAAUA,CAER5nD,eAAwB,GAAG,KAAK,EAChC6nD,qBAA8B,GAAG,IAAI,EACrC3nD,eAA2D,EACzC;IAClB,MAAM5C,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAoB;IAC/C,IAAI3B,eAAe,EAAE;MACnB,IAAI,CAACmE,KAAK,CAACiN,YAAY,CAAC8F,KAAK,EAAE;IACjC;IACA,IAAI,CAAC4I,MAAM,CAAW,CAAA,CAAA;IACtB,IAAI+nC,qBAAqB,EAAE;MACzB,IAAI,CAACh8C,KAAK,CAACF,KAAK,CAACrE,WAAW,CAAC;IAC/B;IACA,IAAI,CAACvH,cAAc,CACjBzC,IAAI,EACJ0C,eAAe,EACf,KAAK,EAELE,CAAAA,EAAAA,eAAe,CAChB;IACD,IAAI2nD,qBAAqB,EAAE;MACzB,IAAI,CAACh8C,KAAK,CAACD,IAAI,EAAE;IACnB;IACA,OAAO,IAAI,CAAC/J,UAAU,CAACvE,IAAI,EAAE,gBAAgB,CAAC;EAChD;EAEAsC,gBAAgBA,CAACT,IAAiB,EAAW;IAC3C,OACEA,IAAI,CAACxP,IAAI,KAAK,qBAAqB,IACnCwP,IAAI,CAACJ,UAAU,CAACpP,IAAI,KAAK,eAAe,IACxC,CAACwP,IAAI,CAACJ,UAAU,CAACE,KAAK,CAACa,aAAa;EAExC;EAEAC,cAAcA,CAEZzC,IAAkC,EAClC0C,eAA2C,EAC3CC,QAAiB,EACjB/T,GAAc,EACdgU,eAA2D,EACrD;IACN,MAAMI,IAAkC,GAAIhD,IAAI,CAACgD,IAAI,GAAG,EAAG;IAC3D,MAAMF,UAA8C,GAAI9C,IAAI,CAAC8C,UAAU,GACrE,EAAG;IACL,IAAI,CAAC0+C,2BAA2B,CAC9Bx+C,IAAI,EACJN,eAAe,GAAGI,UAAU,GAAGtjB,SAAS,EACxCmjB,QAAQ,EACR/T,GAAG,EACHgU,eAAe,CAChB;EACH;EAKA4+C,2BAA2BA,CAEzBx+C,IAAmB,EACnBF,UAA4C,EAC5CH,QAAiB,EACjB/T,GAAc,EACdgU,eAA2D,EACrD;IACN,MAAM8nD,SAAS,GAAG,IAAI,CAAC7jD,KAAK,CAACiC,MAAM;IACnC,IAAI+qD,sBAAsB,GAAG,KAAK;IAClC,IAAIkG,kBAAkB,GAAG,KAAK;IAE9B,OAAO,CAAC,IAAI,CAAC7jD,KAAK,CAACtnB,GAAG,CAAC,EAAE;MACvB,MAAMiT,IAAI,GAAGc,QAAQ,GACjB,IAAI,CAAC8zD,eAAe,EAAE,GACtB,IAAI,CAACE,sBAAsB,EAAE;MAEjC,IAAI7zD,UAAU,IAAI,CAACi3D,kBAAkB,EAAE;QACrC,IAAI,IAAI,CAACz3D,gBAAgB,CAACT,IAAI,CAAC,EAAE;UAC/B,MAAML,SAAS,GAAG,IAAI,CAAC00D,eAAe,CAACr0D,IAAI,CAAC;UAC5CiB,UAAU,CAACrf,IAAI,CAAC+d,SAAS,CAAC;UAE1B,IACE,CAACqyD,sBAAsB,IACvBryD,SAAS,CAAC9R,KAAK,CAACA,KAAK,KAAK,YAAY,EACtC;YACAmkE,sBAAsB,GAAG,IAAI;YAC7B,IAAI,CAACp6C,SAAS,CAAC,IAAI,CAAC;UACtB;UAEA;QACF;QACAsgD,kBAAkB,GAAG,IAAI;QAEzB,IAAI,CAAClzD,KAAK,CAACiN,YAAY,CAAC8F,KAAK,EAAE;MACjC;MACA5W,IAAI,CAACvf,IAAI,CAACoe,IAAI,CAAC;IACjB;IAEA,IAAIe,eAAe,EAAE;MACnBA,eAAe,CAACw1B,IAAI,CAAC,IAAI,EAAEy7B,sBAAsB,CAAC;IACpD;IAEA,IAAI,CAACnJ,SAAS,EAAE;MACd,IAAI,CAACjxC,SAAS,CAAC,KAAK,CAAC;IACvB;IAEA,IAAI,CAAC7P,IAAI,EAAE;EACb;EAMA6uD,QAAQA,CAENz4D,IAA4B,EAC5BgU,IAAkD,EAClC;IAChBhU,IAAI,CAACgU,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACsO,SAAS,CAAgB,KAAK,CAAC;IACpCtiB,IAAI,CAAC0I,IAAI,GAAG,IAAI,CAACwN,KAAK,CAAS,EAAA,CAAA,GAAG,IAAI,GAAG,IAAI,CAAC0U,eAAe,EAAE;IAC/D,IAAI,CAACtI,SAAS,CAAgB,KAAK,CAAC;IACpCtiB,IAAI,CAACsvD,MAAM,GAAG,IAAI,CAACp5C,KAAK,CAAW,EAAA,CAAA,GAAG,IAAI,GAAG,IAAI,CAAC0U,eAAe,EAAE;IACnE,IAAI,CAACpI,MAAM,CAAW,EAAA,CAAA;IAGtBxiB,IAAI,CAACgD,IAAI,GAIP,IAAI,CAACyxD,kCAAkC,CAAC,MAEtC,IAAI,CAACoC,cAAc,EAAE,CACtB;IAEH,IAAI,CAACtoD,KAAK,CAACD,IAAI,EAAE;IACjB,IAAI,CAACzH,KAAK,CAAC2M,MAAM,CAACtlB,GAAG,EAAE;IAEvB,OAAO,IAAI,CAACqW,UAAU,CAACvE,IAAI,EAAE,cAAc,CAAC;EAC9C;EAKAg5D,UAAUA,CAERh5D,IAAuB,EACvBgU,IAAiD,EACjDwkD,OAAyB,EACd;IACX,MAAMO,OAAO,GAAG,IAAI,CAAC7iD,KAAK,CAAQ,EAAA,CAAA;IAClC,IAAI,CAACtM,IAAI,EAAE;IAEX,IAAImvD,OAAO,EAAE;MACX,IAAIP,OAAO,KAAK,IAAI,EAAE,IAAI,CAACrhE,UAAU,CAACqhE,OAAO,CAAC;IAChD,CAAC,MAAM;MACLx4D,IAAI,CAACg6D,KAAK,GAAGxB,OAAO,KAAK,IAAI;IAC/B;IAEA,IACExkD,IAAI,CAAC3hB,IAAI,KAAK,qBAAqB,IACnC2hB,IAAI,CAACsxC,YAAY,CAAC,CAAC,CAAC,CAACtxC,IAAI,IAAI,IAAI,KAChC,CAAC+kD,OAAO,IACP,CAAC,IAAI,CAACn4E,OAAO,CAACJ,MAAM,IACpB,IAAI,CAACqmB,KAAK,CAACiC,MAAM,IACjBkL,IAAI,CAACvhB,IAAI,KAAK,KAAK,IACnBuhB,IAAI,CAACsxC,YAAY,CAAC,CAAC,CAAC,CAACzhD,EAAE,CAACxR,IAAI,KAAK,YAAY,CAAC,EAChD;MACA,IAAI,CAAC0T,KAAK,CAAClG,MAAM,CAAC9K,sBAAsB,EAAE;QACxCtP,EAAE,EAAEuuB,IAAI;QACR3hB,IAAI,EAAE0mE,OAAO,GAAG,gBAAgB,GAAG;MACrC,CAAC,CAAC;IACJ;IAEA,IAAI/kD,IAAI,CAAC3hB,IAAI,KAAK,mBAAmB,EAAE;MACrC,IAAI,CAAC0T,KAAK,CAAClG,MAAM,CAAChJ,UAAU,EAAE;QAC5BpR,EAAE,EAAEuuB,IAAI;QACRld,QAAQ,EAAE;UAAEzE,IAAI,EAAE;QAAe;MACnC,CAAC,CAAC;IACJ;IAEA2N,IAAI,CAACu1B,IAAI,GAAGvhB,IAAI;IAChBhU,IAAI,CAACkuB,KAAK,GAAG6qC,OAAO,GAChB,IAAI,CAACnuC,eAAe,EAAE,GACtB,IAAI,CAAC6I,uBAAuB,EAAE;IAClC,IAAI,CAACjR,MAAM,CAAW,EAAA,CAAA;IAGtBxiB,IAAI,CAACgD,IAAI,GAIP,IAAI,CAACyxD,kCAAkC,CAAC,MAEtC,IAAI,CAACoC,cAAc,EAAE,CACtB;IAEH,IAAI,CAACtoD,KAAK,CAACD,IAAI,EAAE;IACjB,IAAI,CAACzH,KAAK,CAAC2M,MAAM,CAACtlB,GAAG,EAAE;IAEvB,OAAO,IAAI,CAACqW,UAAU,CAACvE,IAAI,EAAE+4D,OAAO,GAAG,gBAAgB,GAAG,gBAAgB,CAAC;EAC7E;EAIAD,QAAQA,CAEN94D,IAAmC,EACnCi6D,KAAc,EACdxnE,IAAuC,EACvC4yD,uBAAgC,GAAG,KAAK,EACT;IAC/B,MAAMC,YAAoC,GAAItlD,IAAI,CAACslD,YAAY,GAAG,EAAG;IACrEtlD,IAAI,CAACvN,IAAI,GAAGA,IAAI;IAChB,SAAS;MACP,MAAM6hC,IAAI,GAAG,IAAI,CAACjwB,SAAS,EAAwB;MACnD,IAAI,CAAC6zB,UAAU,CAAC5D,IAAI,EAAE7hC,IAAI,CAAC;MAC3B6hC,IAAI,CAACtgB,IAAI,GAAG,CAAC,IAAI,CAACyE,GAAG,IAAO,GACxB,IAAI,GACJwhD,KAAK,GACL,IAAI,CAACzM,0BAA0B,EAAE,GACjC,IAAI,CAAC/5B,uBAAuB,EAAE;MAElC,IAAIa,IAAI,CAACtgB,IAAI,KAAK,IAAI,IAAI,CAACqxC,uBAAuB,EAAE;QAClD,IACE/wB,IAAI,CAACzwB,EAAE,CAACxR,IAAI,KAAK,YAAY,IAC7B,EAAE4nE,KAAK,KAAK,IAAI,CAAC/jD,KAAK,IAAQ,IAAI,IAAI,CAACwL,YAAY,CAAA,GAAA,CAAQ,CAAC,CAAC,EAC7D;UACA,IAAI,CAAC3b,KAAK,CAAClG,MAAM,CAACnM,6BAA6B,EAAE;YAC/CjO,EAAE,EAAE,IAAI,CAACohB,KAAK,CAACoB,aAAa;YAC5BxV,IAAI,EAAE;UACR,CAAC,CAAC;QACH,CAAA,MAAM,IACLA,IAAI,KAAK,OAAO,IAChB,EAAE,IAAI,CAACyjB,KAAK,IAAQ,IAAI,IAAI,CAACwL,YAAY,CAAA,GAAA,CAAQ,CAAC,EAClD;UACA,IAAI,CAAC3b,KAAK,CAAClG,MAAM,CAACnM,6BAA6B,EAAE;YAC/CjO,EAAE,EAAE,IAAI,CAACohB,KAAK,CAACoB,aAAa;YAC5BxV,IAAI,EAAE;UACR,CAAC,CAAC;QACJ;MACF;MACA6yD,YAAY,CAAC7hE,IAAI,CAAC,IAAI,CAAC8gB,UAAU,CAAC+vB,IAAI,EAAE,oBAAoB,CAAC,CAAC;MAC9D,IAAI,CAAC,IAAI,CAAC7b,GAAG,IAAU,EAAE;IAC3B;IACA,OAAOzY,IAAI;EACb;EAEAk4B,UAAUA,CAER5D,IAAkC,EAClC7hC,IAAuC,EACjC;IAGN,IAAIA,IAAI,KAAK,OAAO,IAAI,CAAC,IAAI,CAAC2W,QAAQ,IAAI,IAAI,CAAC8M,KAAK,IAAW,EAAE;MAC/D,IAAI,CAACnQ,KAAK,CAAClG,MAAM,CAAC9M,mBAAmB,EAAE;QAAEtN,EAAE,EAAE,IAAI,CAACohB,KAAK,CAAC3B;MAAS,CAAC,CAAC;IACrE;IACA,MAAMrB,EAAE,GAAG,IAAI,CAACm0B,gBAAgB,EAAE;IAClC,IAAI,CAAC4Z,SAAS,CAAC/tC,EAAE,EAAE;MACjBguC,EAAE,EAAE;QAAEx/C,IAAI,EAAE;MAAsB,CAAA;MAClCiT,OAAO,EAAE7S,IAAI,KAAK,KAAK,GAAGkZ,QAAQ,GAAGF;IACvC,CAAC,CAAC;IACF6oB,IAAI,CAACzwB,EAAE,GAAGA,EAAE;EACd;EAGAutD,4BAA4BA,CAE1BpxD,IAAkC,EACZ;IACtB,OAAO,IAAI,CAAC8xD,aAAa,CAAC9xD,IAAI,IAA0B;EAC1D;EAKA8xD,aAAaA,CAEX9xD,IAAe,EACfQ,KAAwB,IAA+B,EACpD;IACH,MAAM05D,kBAAkB,GAAG15D,KAAK,IAAuC;IACvE,MAAM25D,aAAa,GAAG,CAAC,EAAE35D,KAAK,IAAgC,CAAC;IAC/D,MAAMiqD,SAAS,GAAG0P,aAAa,IAAI,EAAE35D,KAAK,IAA+B,CAAC;IAC1E,MAAMwB,OAAO,GAAG,CAAC,EAAExB,KAAK,IAA0B,CAAC;IAEnD,IAAI,CAACuB,YAAY,CAAC/B,IAAI,EAAEgC,OAAO,CAAC;IAEhC,IAAI,IAAI,CAACkU,KAAK,CAAA,EAAA,CAAS,EAAE;MACvB,IAAIgkD,kBAAkB,EAAE;QACtB,IAAI,CAACn0D,KAAK,CAAClG,MAAM,CAAC1K,iCAAiC,EAAE;UACnD1P,EAAE,EAAE,IAAI,CAACohB,KAAK,CAAC3B;QACjB,CAAC,CAAC;MACJ;MACA,IAAI,CAAC0E,IAAI,EAAE;MACX5J,IAAI,CAAC2zD,SAAS,GAAG,IAAI;IACvB;IAEA,IAAIwG,aAAa,EAAE;MACjBn6D,IAAI,CAAC6D,EAAE,GAAG,IAAI,CAAC2mD,eAAe,CAACC,SAAS,CAAC;IAC3C;IAEA,MAAMrH,yBAAyB,GAAG,IAAI,CAACv8C,KAAK,CAAC+L,sBAAsB;IACnE,IAAI,CAAC/L,KAAK,CAAC+L,sBAAsB,GAAG,KAAK;IACzC,IAAI,CAACrE,KAAK,CAACF,KAAK,CAACnE,cAAc,CAAC;IAChC,IAAI,CAAC+Z,SAAS,CAAC5V,KAAK,CAACkT,aAAa,CAACvf,OAAO,EAAEhC,IAAI,CAAC2zD,SAAS,CAAC,CAAC;IAE5D,IAAI,CAACwG,aAAa,EAAE;MAClBn6D,IAAI,CAAC6D,EAAE,GAAG,IAAI,CAAC2mD,eAAe,EAAE;IAClC;IAEA,IAAI,CAACvyB,mBAAmB,CAACj4B,IAAI,EAAsB,KAAK,CAAC;IAKzD,IAAI,CAACy0D,kCAAkC,CAAC,MAAM;MAE5C,IAAI,CAACliC,0BAA0B,CAC7BvyB,IAAI,EACJm6D,aAAa,GAAG,qBAAqB,GAAG,oBAAoB,CAC7D;IACH,CAAC,CAAC;IAEF,IAAI,CAACl2C,SAAS,CAAC3V,IAAI,EAAE;IACrB,IAAI,CAACC,KAAK,CAACD,IAAI,EAAE;IAEjB,IAAI6rD,aAAa,IAAI,CAACD,kBAAkB,EAAE;MAIxC,IAAI,CAACpW,2BAA2B,CAAC9jD,IAAI,CAAM;IAC7C;IAEA,IAAI,CAAC6G,KAAK,CAAC+L,sBAAsB,GAAGwwC,yBAAyB;IAC7D,OAAOpjD,IAAI;EACb;EAEAwqD,eAAeA,CAACC,SAAmB,EAAmC;IACpE,OAAOA,SAAS,IAAI59D,iBAAiB,CAAC,IAAI,CAACga,KAAK,CAACxU,IAAI,CAAC,GAClD,IAAI,CAAC64B,eAAe,EAAE,GACtB,IAAI;EACV;EAEA+M,mBAAmBA,CAEjBj4B,IAAwB,EACxBqD,aAAuB,EACjB;IACN,IAAI,CAACmf,MAAM,CAAW,EAAA,CAAA;IACtB,IAAI,CAAC2B,eAAe,CAAC9V,KAAK,CAACkS,4BAA4B,EAAE,CAAC;IAC1DvgB,IAAI,CAACqC,MAAM,GAAG,IAAI,CAACyuC,gBAAgB,SAGjCC,KACG1tC,aAAa,OAAiD,CAAC,CAAC,CACpE;IAED,IAAI,CAAC8gB,eAAe,CAAC7V,IAAI,EAAE;EAC7B;EAEAw1C,2BAA2BA,CAAC9jD,IAAgB,EAAQ;IAClD,IAAI,CAACA,IAAI,CAAC6D,EAAE,EAAE;IAMd,IAAI,CAAC0K,KAAK,CAACC,WAAW,CACpBxO,IAAI,CAAC6D,EAAE,CAACnhB,IAAI,EACZ,CAAC,IAAI,CAAC9B,OAAO,CAACJ,MAAM,IAAI,IAAI,CAACqmB,KAAK,CAACiC,MAAM,IAAI9I,IAAI,CAAC2zD,SAAS,IAAI3zD,IAAI,CAACg5B,KAAK,GACrE,IAAI,CAACzqB,KAAK,CAACL,mBAAmB,GAC5BvC,QAAQ,GACRF,YAAY,GACdG,aAAa,EACjB5L,IAAI,CAAC6D,EAAE,CAAChF,GAAG,CAAClQ,KAAK,CAClB;EACH;EAKAg0D,UAAUA,CAER3iD,IAAe,EACf+0B,WAAiD,EACjDC,UAAoB,EACjB;IACH,IAAI,CAACprB,IAAI,EAAE;IAGX,MAAM8gD,SAAS,GAAG,IAAI,CAAC7jD,KAAK,CAACiC,MAAM;IACnC,IAAI,CAACjC,KAAK,CAACiC,MAAM,GAAG,IAAI;IAExB,IAAI,CAACgsB,YAAY,CAAC90B,IAAI,EAAE+0B,WAAW,EAAEC,UAAU,CAAC;IAChD,IAAI,CAACsB,eAAe,CAACt2B,IAAI,CAAC;IAE1BA,IAAI,CAACgD,IAAI,GAAG,IAAI,CAAC2nD,cAAc,CAAC,CAAC,CAAC3qD,IAAI,CAACE,UAAU,EAAEwqD,SAAS,CAAC;IAE7D,OAAO,IAAI,CAACnmD,UAAU,CACpBvE,IAAI,EACJ+0B,WAAW,GAAG,kBAAkB,GAAG,iBAAiB,CACrD;EACH;EAEAmB,eAAeA,CAAAA,EAAY;IACzB,OAAO,IAAI,CAAChgB,KAAK,CAAA,EAAA,CAAO,IAAI,IAAI,CAACA,KAAK,CAAS,EAAA,CAAA,IAAI,IAAI,CAACA,KAAK,CAAW,CAAA,CAAA;EAC1E;EAEA+f,aAAaA,CAAAA,EAAY;IACvB,OAAO,IAAI,CAAC/f,KAAK,CAAW,EAAA,CAAA;EAC9B;EAEAigB,sBAAsBA,CAAC/zB,MAAuC,EAAW;IACvE,OACE,CAACA,MAAM,CAACkC,QAAQ,IAChB,CAAClC,MAAM,CAACktB,MAAM,KACbltB,MAAM,CAACvhB,GAAG,CAAC6B,IAAI,KAAK,aAAa,IAChC0f,MAAM,CAACvhB,GAAG,CAAC6O,KAAK,KAAK,aAAa,CAAC;EAEzC;EAGAi7D,cAAcA,CAEZ7E,aAAsB,EACtB4E,SAAkB,EACL;IACb,IAAI,CAAC/kD,UAAU,CAAC0I,KAAK,EAAE;IAEvB,MAAMxH,KAA8B,GAAG;MACrCuzD,cAAc,EAAE,KAAK;MACrBtU;KACD;IACD,IAAIn/C,UAAyB,GAAG,EAAE;IAClC,MAAMxD,SAAS,GAAG,IAAI,CAACkB,SAAS,EAAe;IAC/ClB,SAAS,CAACH,IAAI,GAAG,EAAE;IAEnB,IAAI,CAACwf,MAAM,CAAW,CAAA,CAAA;IAItB,IAAI,CAACiyC,kCAAkC,CAAC,MAAM;MAE5C,OAAO,CAAC,IAAI,CAACv+C,KAAK,GAAW,EAAE;QAC7B,IAAI,IAAI,CAACuC,GAAG,CAAA,EAAA,CAAS,EAAE;UACrB,IAAI9R,UAAU,CAACvY,MAAM,GAAG,CAAC,EAAE;YACzB,MAAM,IAAI,CAAC2X,KAAK,CAAClG,MAAM,CAAC7L,kBAAkB,EAAE;cAC1CvO,EAAE,EAAE,IAAI,CAACohB,KAAK,CAACoB;YACjB,CAAC,CAAC;UACJ;UACA;QACF;QAEA,IAAI,IAAI,CAACiO,KAAK,CAAA,EAAA,CAAO,EAAE;UACrBvP,UAAU,CAACljB,IAAI,CAAC,IAAI,CAAC4tD,cAAc,EAAE,CAAC;UACtC;QACF;QAEA,MAAMnc,MAAM,GAAG,IAAI,CAAC7wB,SAAS,EAAiB;QAG9C,IAAIsC,UAAU,CAACvY,MAAM,EAAE;UAErB8mC,MAAM,CAACvuB,UAAU,GAAGA,UAAU;UAC9B,IAAI,CAAC2e,0BAA0B,CAAC4P,MAAM,EAAEvuB,UAAU,CAAC,CAAC,CAAC,CAAC;UACtDA,UAAU,GAAG,EAAE;QACjB;QAEA,IAAI,CAACsuB,gBAAgB,CAAC9xB,SAAS,EAAE+xB,MAAM,EAAEruB,KAAK,CAAC;QAE/C,IAEEquB,MAAM,CAACziC,IAAI,KAAK,aAAa,IAE7ByiC,MAAM,CAACvuB,UAAU,IAEjBuuB,MAAM,CAACvuB,UAAU,CAACvY,MAAM,GAAG,CAAC,EAC5B;UACA,IAAI,CAAC2X,KAAK,CAAClG,MAAM,CAAC/L,oBAAoB,EAAE;YAAErO,EAAE,EAAEyvC;UAAO,CAAC,CAAC;QACzD;MACF;IACF,CAAC,CAAC;IAEF,IAAI,CAACruB,KAAK,CAACiC,MAAM,GAAG4hD,SAAS;IAE7B,IAAI,CAAC9gD,IAAI,EAAE;IAEX,IAAIjD,UAAU,CAACvY,MAAM,EAAE;MACrB,MAAM,IAAI,CAAC2X,KAAK,CAAClG,MAAM,CAACrF,iBAAiB,EAAE;QAAE/U,EAAE,EAAE,IAAI,CAACohB,KAAK,CAAC3B;MAAS,CAAC,CAAC;IACzE;IAEA,IAAI,CAACS,UAAU,CAAC2I,IAAI,EAAE;IAEtB,OAAO,IAAI,CAAC/J,UAAU,CAACpB,SAAS,EAAE,WAAW,CAAC;EAChD;EAIAgyB,4BAA4BA,CAE1BhyB,SAA8B,EAC9B+xB,MAA6B,EACpB;IACT,MAAMr0C,GAAG,GAAG,IAAI,CAACqqC,eAAe,CAAC,IAAI,CAAC;IAEtC,IAAI,IAAI,CAAC+K,aAAa,EAAE,EAAE;MACxB,MAAM7zB,MAAqB,GAAG8yB,MAAa;MAG3C9yB,MAAM,CAAC3P,IAAI,GAAG,QAAQ;MACtB2P,MAAM,CAACkC,QAAQ,GAAG,KAAK;MACvBlC,MAAM,CAACvhB,GAAG,GAAGA,GAAG;MAChBuhB,MAAM,CAACktB,MAAM,GAAG,KAAK;MACrB,IAAI,CAACpsB,eAAe,CAClBC,SAAS,EACTf,MAAM,EACN,KAAK,EACL,KAAK,EACe,KAAK,EACzB,KAAK,CACN;MACD,OAAO,IAAI;IACb,CAAC,MAAM,IAAI,IAAI,CAAC8zB,eAAe,EAAE,EAAE;MACjC,MAAMrxB,IAAqB,GAAGqwB,MAAa;MAG3CrwB,IAAI,CAACP,QAAQ,GAAG,KAAK;MACrBO,IAAI,CAAChkB,GAAG,GAAGA,GAAG;MACdgkB,IAAI,CAACyqB,MAAM,GAAG,KAAK;MACnBnsB,SAAS,CAACH,IAAI,CAACvf,IAAI,CAAC,IAAI,CAAC+gB,kBAAkB,CAACK,IAAI,CAAC,CAAC;MAClD,OAAO,IAAI;IACb;IACA,IAAI,CAAC+M,iCAAiC,CAAC/wB,GAAG,CAAC;IAC3C,OAAO,KAAK;EACd;EAEAo0C,gBAAgBA,CAEd9xB,SAA8B,EAC9B+xB,MAA6B,EAC7BruB,KAA8B,EACxB;IACN,MAAMwoB,QAAQ,GAAG,IAAI,CAAC3N,YAAY,CAAY,GAAA,CAAA;IAE9C,IAAI2N,QAAQ,EAAE;MACZ,IAAI,IAAI,CAAC8F,4BAA4B,CAAChyB,SAAS,EAAE+xB,MAAM,CAAC,EAAE;QAExD;MACF;MACA,IAAI,IAAI,CAACzc,GAAG,CAAA,CAAA,CAAW,EAAE;QACvB,IAAI,CAACmtC,qBAAqB,CAACziD,SAAS,EAAE+xB,MAAM,CAAyB;QACrE;MACF;IACF;IAEA,IAAI,CAAC2wB,4BAA4B,CAAC1iD,SAAS,EAAE+xB,MAAM,EAAEruB,KAAK,EAAEwoB,QAAQ,CAAC;EACvE;EAEAw2B,4BAA4BA,CAE1B1iD,SAA8B,EAC9B+xB,MAA6B,EAC7BruB,KAA8B,EAC9BwoB,QAAiB,EACjB;IACA,MAAMgrC,YAAY,GAAGnlC,MAAuB;IAC5C,MAAMolC,aAAa,GAAGplC,MAA8B;IACpD,MAAMqlC,UAAU,GAAGrlC,MAAyB;IAC5C,MAAMslC,WAAW,GAAGtlC,MAAgC;IACpD,MAAMulC,YAAY,GAAGvlC,MAAiC;IAEtD,MAAM9yB,MAAkD,GAAGi4D,YAAY;IACvE,MAAMK,YAAqD,GAAGL,YAAY;IAE1EnlC,MAAM,CAAC5F,MAAM,GAAGD,QAAQ;IACxB,IAAI,CAACqH,+BAA+B,CAACxB,MAAM,CAAC;IAE5C,IAAI,IAAI,CAACzc,GAAG,CAAA,EAAA,CAAS,EAAE;MAErBrW,MAAM,CAAC3P,IAAI,GAAG,QAAQ;MACtB,MAAMqR,aAAa,GAAG,IAAI,CAACoS,KAAK,CAAgB,GAAA,CAAA;MAChD,IAAI,CAACykD,qBAAqB,CAACv4D,MAAM,CAAC;MAElC,IAAI0B,aAAa,EAAE;QAEjB,IAAI,CAACuyB,sBAAsB,CAAClzB,SAAS,EAAEm3D,aAAa,EAAE,IAAI,EAAE,KAAK,CAAC;QAClE;MACF;MAEA,IAAI,IAAI,CAACnkC,sBAAsB,CAACkkC,YAAY,CAAC,EAAE;QAC7C,IAAI,CAACt0D,KAAK,CAAClG,MAAM,CAACpM,sBAAsB,EAAE;UACxChO,EAAE,EAAE40E,YAAY,CAACx5E;QACnB,CAAC,CAAC;MACJ;MAEA,IAAI,CAACqiB,eAAe,CAClBC,SAAS,EACTk3D,YAAY,EACZ,IAAI,EACJ,KAAK,EACe,KAAK,EACzB,KAAK,CACN;MAED;IACF;IAEA,MAAM34C,YAAY,GAChB70B,iBAAiB,CAAC,IAAI,CAACga,KAAK,CAACxU,IAAI,CAAC,IAAI,CAAC,IAAI,CAACwU,KAAK,CAAC+M,WAAW;IAC/D,MAAMgnD,SAAS,GAAG,IAAI,CAAC1kD,KAAK,CAAgB,GAAA,CAAA;IAC5C,MAAMr1B,GAAG,GAAG,IAAI,CAAC85E,qBAAqB,CAACzlC,MAAM,CAAC;IAC9C,MAAM2lC,0BAA0B,GAAG,IAAI,CAACh0D,KAAK,CAAC3B,QAAQ;IAEtD,IAAI,CAAC6gD,4BAA4B,CAAC2U,YAAY,CAAC;IAE/C,IAAI,IAAI,CAACzkC,aAAa,EAAE,EAAE;MACxB7zB,MAAM,CAAC3P,IAAI,GAAG,QAAQ;MAEtB,IAAImoE,SAAS,EAAE;QACb,IAAI,CAACvkC,sBAAsB,CAAClzB,SAAS,EAAEm3D,aAAa,EAAE,KAAK,EAAE,KAAK,CAAC;QACnE;MACF;MAGA,MAAMj3D,aAAa,GAAG,IAAI,CAAC8yB,sBAAsB,CAACkkC,YAAY,CAAC;MAC/D,IAAI/2D,iBAAiB,GAAG,KAAK;MAC7B,IAAID,aAAa,EAAE;QACjBg3D,YAAY,CAAC5nE,IAAI,GAAG,aAAa;QAGjC,IAAIoU,KAAK,CAACuzD,cAAc,IAAI,CAAC,IAAI,CAAC9zD,SAAS,CAAC,YAAY,CAAC,EAAE;UACzD,IAAI,CAACP,KAAK,CAAClG,MAAM,CAACzL,oBAAoB,EAAE;YAAE3O,EAAE,EAAE5E;UAAI,CAAC,CAAC;QACtD;QACA,IAAIwiB,aAAa,IAAI,IAAI,CAACiD,SAAS,CAAC,YAAY,CAAC,IAAI4uB,MAAM,CAACsuB,QAAQ,EAAE;UACpE,IAAI,CAACz9C,KAAK,CAAClG,MAAM,CAACrG,qBAAqB,EAAE;YAAE/T,EAAE,EAAE5E;UAAI,CAAC,CAAC;QACvD;QACAgmB,KAAK,CAACuzD,cAAc,GAAG,IAAI;QAC3B92D,iBAAiB,GAAGuD,KAAK,CAACi/C,aAAa;MACzC;MAEA,IAAI,CAAC5iD,eAAe,CAClBC,SAAS,EACTk3D,YAAY,EACZ,KAAK,EACL,KAAK,EACLh3D,aAAa,EACbC,iBAAiB,CAClB;IACH,CAAC,MAAM,IAAI,IAAI,CAAC4yB,eAAe,EAAE,EAAE;MACjC,IAAI0kC,SAAS,EAAE;QACb,IAAI,CAACE,wBAAwB,CAAC33D,SAAS,EAAEq3D,WAAW,CAAC;MACvD,CAAC,MAAM;QACL,IAAI,CAACO,iBAAiB,CAAC53D,SAAS,EAAEo3D,UAAU,CAAC;MAC/C;IACF,CAAC,MAAM,IACL74C,YAAY,IACZ7gC,GAAG,CAAC6B,IAAI,KAAK,OAAO,IACpB,CAAC,IAAI,CAAC2/B,gBAAgB,EAAE,EACxB;MAEA,IAAI,CAACzQ,iCAAiC,CAAC/wB,GAAG,CAAC;MAC3C,MAAMuiB,WAAW,GAAG,IAAI,CAACqV,GAAG,CAAS,EAAA,CAAA;MAErC,IAAIiiD,YAAY,CAACx0D,QAAQ,EAAE;QACzB,IAAI,CAAC/O,UAAU,CAAC0jE,0BAA0B,CAAC;MAC7C;MAEAz4D,MAAM,CAAC3P,IAAI,GAAG,QAAQ;MAEtB,MAAMmoE,SAAS,GAAG,IAAI,CAAC1kD,KAAK,CAAgB,GAAA,CAAA;MAC5C,IAAI,CAACykD,qBAAqB,CAACv4D,MAAM,CAAC;MAClC,IAAI,CAAC2jD,4BAA4B,CAAC2U,YAAY,CAAC;MAE/C,IAAIE,SAAS,EAAE;QAEb,IAAI,CAACvkC,sBAAsB,CACzBlzB,SAAS,EACTm3D,aAAa,EACbl3D,WAAW,EACX,IAAI,CACL;MACH,CAAC,MAAM;QACL,IAAI,IAAI,CAAC+yB,sBAAsB,CAACkkC,YAAY,CAAC,EAAE;UAC7C,IAAI,CAACt0D,KAAK,CAAClG,MAAM,CAACrM,kBAAkB,EAAE;YAAE/N,EAAE,EAAE40E,YAAY,CAACx5E;UAAI,CAAC,CAAC;QACjE;QAEA,IAAI,CAACqiB,eAAe,CAClBC,SAAS,EACTk3D,YAAY,EACZj3D,WAAW,EACX,IAAI,EACgB,KAAK,EACzB,KAAK,CACN;MACH;IACF,CAAC,MAAM,IACLse,YAAY,KACX7gC,GAAG,CAAC6B,IAAI,KAAK,KAAK,IAAI7B,GAAG,CAAC6B,IAAI,KAAK,KAAK,CAAC,IAC1C,EAAE,IAAI,CAACwzB,KAAK,CAAA,EAAA,CAAS,IAAI,IAAI,CAACmM,gBAAgB,EAAE,CAAC,EACjD;MAGA,IAAI,CAACzQ,iCAAiC,CAAC/wB,GAAG,CAAC;MAC3CuhB,MAAM,CAAC3P,IAAI,GAAG5R,GAAG,CAAC6B,IAAI;MAEtB,MAAMk4E,SAAS,GAAG,IAAI,CAAC1kD,KAAK,CAAgB,GAAA,CAAA;MAC5C,IAAI,CAACykD,qBAAqB,CAACN,YAAY,CAAC;MAExC,IAAIO,SAAS,EAAE;QAEb,IAAI,CAACvkC,sBAAsB,CAAClzB,SAAS,EAAEm3D,aAAa,EAAE,KAAK,EAAE,KAAK,CAAC;MACrE,CAAC,MAAM;QACL,IAAI,IAAI,CAACnkC,sBAAsB,CAACkkC,YAAY,CAAC,EAAE;UAC7C,IAAI,CAACt0D,KAAK,CAAClG,MAAM,CAACtM,qBAAqB,EAAE;YAAE9N,EAAE,EAAE40E,YAAY,CAACx5E;UAAI,CAAC,CAAC;QACpE;QACA,IAAI,CAACqiB,eAAe,CAClBC,SAAS,EACTk3D,YAAY,EACZ,KAAK,EACL,KAAK,EACe,KAAK,EACzB,KAAK,CACN;MACH;MAEA,IAAI,CAAC5jC,uBAAuB,CAAC4jC,YAAY,CAAC;IAC5C,CAAC,MAAM,IACL34C,YAAY,IACZ7gC,GAAG,CAAC6B,IAAI,KAAK,UAAU,IACvB,CAAC,IAAI,CAAC2/B,gBAAgB,EAAE,EACxB;MACA,IAAI,CAAC1H,YAAY,CAAC,wBAAwB,CAAC;MAC3C,IAAI,CAAC/I,iCAAiC,CAAC/wB,GAAG,CAAC;MAG3C,MAAM+5E,SAAS,GAAG,IAAI,CAAC1kD,KAAK,CAAgB,GAAA,CAAA;MAC5C,IAAI,CAACykD,qBAAqB,CAACJ,UAAU,CAAC;MACtC,IAAI,CAACS,yBAAyB,CAAC73D,SAAS,EAAEs3D,YAAY,EAAEG,SAAS,CAAC;IACpE,CAAC,MAAM,IAAI,IAAI,CAACv4C,gBAAgB,EAAE,EAAE;MAElC,IAAIu4C,SAAS,EAAE;QACb,IAAI,CAACE,wBAAwB,CAAC33D,SAAS,EAAEq3D,WAAW,CAAC;MACvD,CAAC,MAAM;QACL,IAAI,CAACO,iBAAiB,CAAC53D,SAAS,EAAEo3D,UAAU,CAAC;MAC/C;IACF,CAAC,MAAM;MACL,IAAI,CAACpjE,UAAU,EAAE;IACnB;EACF;EAGAwjE,qBAAqBA,CAEnBzlC,MAA6B,EACA;IAC7B,MAAM;MAAE7iC,IAAI;MAAE3C;KAAO,GAAG,IAAI,CAACmX,KAAK;IAClC,IACE,CAACxU,IAAI,KAAY,GAAA,IAAIA,IAAI,KAAc,GAAA,KACvC6iC,MAAM,CAAC5F,MAAM,IACb5/B,KAAK,KAAK,WAAW,EACrB;MACA,IAAI,CAACqW,KAAK,CAAClG,MAAM,CAACxF,eAAe,EAAE;QAAE5U,EAAE,EAAE,IAAI,CAACohB,KAAK,CAAC3B;MAAS,CAAC,CAAC;IACjE;IAEA,IAAI7S,IAAI,QAAmB,EAAE;MAC3B,IAAI3C,KAAK,KAAK,aAAa,EAAE;QAC3B,IAAI,CAACqW,KAAK,CAAClG,MAAM,CAACvM,4BAA4B,EAAE;UAC9C7N,EAAE,EAAE,IAAI,CAACohB,KAAK,CAAC3B;QACjB,CAAC,CAAC;MACJ;MACA,MAAMrkB,GAAG,GAAG,IAAI,CAAC4iB,gBAAgB,EAAE;MACnCyxB,MAAM,CAACr0C,GAAG,GAAGA,GAAG;MAChB,OAAOA,GAAG;IACZ;IAEA,OAAO,IAAI,CAAC4wD,iBAAiB,CAACvc,MAAM,CAAC;EACvC;EAEA0wB,qBAAqBA,CAEnBziD,SAA8B,EAC9B+xB,MAIC,EACD;IAAA,IAAA+lC,kBAAA;IAEA,IAAI,CAAC1sD,KAAK,CAACF,KAAK,CAAC9D,WAAW,GAAGC,kBAAkB,GAAGH,WAAW,CAAC;IAEhE,MAAMqZ,SAAS,GAAG,IAAI,CAAC7c,KAAK,CAAC2M,MAAM;IACnC,IAAI,CAAC3M,KAAK,CAAC2M,MAAM,GAAG,EAAE;IAGtB,IAAI,CAACyQ,SAAS,CAAC5V,KAAK,CAACsS,KAAK,CAAC;IAC3B,MAAM3d,IAAc,GAAIkyB,MAAM,CAAClyB,IAAI,GAAG,EAAG;IACzC,IAAI,CAACw+C,2BAA2B,CAACx+C,IAAI,EAAExjB,SAAS,EAAE,KAAK,EAAY,CAAA,CAAA;IACnE,IAAI,CAACykC,SAAS,CAAC3V,IAAI,EAAE;IACrB,IAAI,CAACC,KAAK,CAACD,IAAI,EAAE;IACjB,IAAI,CAACzH,KAAK,CAAC2M,MAAM,GAAGkQ,SAAS;IAC7BvgB,SAAS,CAACH,IAAI,CAACvf,IAAI,CAAC,IAAI,CAAC8gB,UAAU,CAAgB2wB,MAAM,EAAE,aAAa,CAAC,CAAC;IAC1E,IAAA+lC,CAAAA,kBAAA,GAAI/lC,MAAM,CAACvuB,UAAU,KAAjBs0D,IAAAA,IAAAA,kBAAA,CAAmB7sE,MAAM,EAAE;MAC7B,IAAI,CAAC2X,KAAK,CAAClG,MAAM,CAAC5L,oBAAoB,EAAE;QAAExO,EAAE,EAAEyvC;MAAO,CAAC,CAAC;IACzD;EACF;EAEA6lC,iBAAiBA,CAEf53D,SAA8B,EAC9B0B,IAAqB,EACrB;IACA,IACE,CAACA,IAAI,CAACP,QAAQ,KACbO,IAAI,CAAChkB,GAAG,CAAC6B,IAAI,KAAK,aAAa,IAAImiB,IAAI,CAAChkB,GAAG,CAAC6O,KAAK,KAAK,aAAa,CAAC,EACrE;MAGA,IAAI,CAACqW,KAAK,CAAClG,MAAM,CAACxM,qBAAqB,EAAE;QAAE5N,EAAE,EAAEof,IAAI,CAAChkB;MAAI,CAAC,CAAC;IAC5D;IAEAsiB,SAAS,CAACH,IAAI,CAACvf,IAAI,CAAC,IAAI,CAAC+gB,kBAAkB,CAACK,IAAI,CAAC,CAAC;EACpD;EAEAi2D,wBAAwBA,CAEtB33D,SAA8B,EAC9B0B,IAAoC,EACpC;IACA,MAAM7E,IAAI,GAAG,IAAI,CAAC2E,yBAAyB,CAACE,IAAI,CAAC;IACjD1B,SAAS,CAACH,IAAI,CAACvf,IAAI,CAACuc,IAAI,CAAC;IAEzB,IAAI,CAAC2F,UAAU,CAACgZ,kBAAkB,CAChC,IAAI,CAAC/a,gBAAgB,CAAC5D,IAAI,CAACnf,GAAG,CAAC,EAC/BksB,mBAAmB,EACnB/M,IAAI,CAACnf,GAAG,CAACge,GAAG,CAAClQ,KAAK,CACnB;EACH;EAEAqsE,yBAAyBA,CAEvB73D,SAA8B,EAC9B0B,IAA6B,EAC7B+1D,SAAkB,EAClB;IACA,IAAI,CAACA,SAAS,IAAI,CAAC/1D,IAAI,CAACP,QAAQ,EAAE;MAEhC,MAAMzjB,GAAG,GAAGgkB,IAAI,CAAChkB,GAAmB;MAEpC,IAAIA,GAAG,CAAC6B,IAAI,KAAK,aAAa,IAAI7B,GAAG,CAAC6O,KAAK,KAAK,aAAa,EAAE;QAG7D,IAAI,CAACqW,KAAK,CAAClG,MAAM,CAACxM,qBAAqB,EAAE;UAAE5N,EAAE,EAAE5E;QAAI,CAAC,CAAC;MACvD;IACF;IAEA,MAAMmf,IAAI,GAAG,IAAI,CAACqmD,0BAA0B,CAACxhD,IAAI,CAAC;IAClD1B,SAAS,CAACH,IAAI,CAACvf,IAAI,CAACuc,IAAI,CAAC;IAEzB,IAAI46D,SAAS,EAAE;MACb,IAAI,CAACj1D,UAAU,CAACgZ,kBAAkB,CAChC,IAAI,CAAC/a,gBAAgB,CAAC5D,IAAI,CAACnf,GAAG,CAAC,EAC/BksB,mBAAmB,EACnB/M,IAAI,CAACnf,GAAG,CAACge,GAAG,CAAClQ,KAAK,CACnB;IACH;EACF;EAEAuU,eAAeA,CAEbC,SAA8B,EAC9Bf,MAA6B,EAC7BgB,WAAoB,EACpBpB,OAAgB,EAChBqB,aAAsB,EACtBC,iBAA0B,EACpB;IACNH,SAAS,CAACH,IAAI,CAACvf,IAAI,CACjB,IAAI,CAAC8f,WAAW,CACdnB,MAAM,EACNgB,WAAW,EACXpB,OAAO,EACPqB,aAAa,EACbC,iBAAiB,EACjB,aAAa,EACb,IAAI,CACL,CACF;EACH;EAEA+yB,sBAAsBA,CAEpBlzB,SAA8B,EAC9Bf,MAAoC,EACpCgB,WAAoB,EACpBpB,OAAgB,EACV;IACN,MAAMhC,IAAI,GAAG,IAAI,CAACuD,WAAW,CAC3BnB,MAAM,EACNgB,WAAW,EACXpB,OAAO,EACa,KAAK,EACzB,KAAK,EACL,oBAAoB,EACpB,IAAI,CACL;IACDmB,SAAS,CAACH,IAAI,CAACvf,IAAI,CAACuc,IAAI,CAAC;IAEzB,MAAMvN,IAAI,GACRuN,IAAI,CAACvN,IAAI,KAAK,KAAK,GACfuN,IAAI,CAACsvB,MAAM,GACT3iB,2BAA2B,GAC3BE,6BAA6B,GAC/B7M,IAAI,CAACvN,IAAI,KAAK,KAAK,GACnBuN,IAAI,CAACsvB,MAAM,GACT1iB,2BAA2B,GAC3BE,6BAA6B,GAC/BC,mBAAmB;IACzB,IAAI,CAACu5C,gCAAgC,CAACtmD,IAAI,EAAEvN,IAAI,CAAC;EACnD;EAEA6zD,gCAAgCA,CAC9BtmD,IAEC,EACDvN,IAAY,EACZ;IACA,IAAI,CAACkT,UAAU,CAACgZ,kBAAkB,CAChC,IAAI,CAAC/a,gBAAgB,CAAC5D,IAAI,CAACnf,GAAG,CAAC,EAC/B4R,IAAI,EACJuN,IAAI,CAACnf,GAAG,CAACge,GAAG,CAAClQ,KAAK,CACnB;EACH;EAGAo3D,4BAA4BA,CAE1BC,YAAqD,EAC/C,CAAC;EAGTrhD,yBAAyBA,CAEvB3E,IAAoC,EACZ;IACxB,IAAI,CAACk7D,gBAAgB,CAACl7D,IAAI,CAAC;IAC3B,IAAI,CAACsiB,SAAS,EAAE;IAChB,OAAO,IAAI,CAAC/d,UAAU,CAACvE,IAAI,EAAE,sBAAsB,CAAC;EACtD;EAGAwE,kBAAkBA,CAAexE,IAAqB,EAAmB;IACvE,IAAI,CAACk7D,gBAAgB,CAACl7D,IAAI,CAAC;IAC3B,IAAI,CAACsiB,SAAS,EAAE;IAChB,OAAO,IAAI,CAAC/d,UAAU,CAACvE,IAAI,EAAE,eAAe,CAAC;EAC/C;EAEAqmD,0BAA0BA,CAExBrmD,IAA6B,EACJ;IACzB,IAAI,CAACk7D,gBAAgB,CAACl7D,IAAI,CAAC;IAC3B,IAAI,CAACsiB,SAAS,EAAE;IAChB,OAAO,IAAI,CAAC/d,UAAU,CAACvE,IAAI,EAAE,uBAAuB,CAAC;EACvD;EAGAk7D,gBAAgBA,CAEdl7D,IAEC,EACK;IACN,IAAI,CAACuO,KAAK,CAACF,KAAK,CAAC9D,WAAW,GAAGF,WAAW,CAAC;IAC3C,IAAI,CAAC8Z,eAAe,CAAC9V,KAAK,CAACqS,kBAAkB,EAAE,CAAC;IAChD,IAAI,CAACuD,SAAS,CAAC5V,KAAK,CAACsS,KAAK,CAAC;IAC3B3gB,IAAI,CAACtQ,KAAK,GAAG,IAAI,CAAC+oB,GAAG,CAAO,EAAA,CAAA,GAAG,IAAI,CAACgb,uBAAuB,EAAE,GAAG,IAAI;IACpE,IAAI,CAACtP,eAAe,CAAC7V,IAAI,EAAE;IAC3B,IAAI,CAAC2V,SAAS,CAAC3V,IAAI,EAAE;IACrB,IAAI,CAACC,KAAK,CAACD,IAAI,EAAE;EACnB;EAEAwmB,YAAYA,CACV90B,IAAqB,EACrB+0B,WAAoB,EACpBC,UAA2B,EAC3BvmB,WAAyB,GAAGjD,UAAU,EAChC;IACN,IAAI3e,iBAAiB,CAAC,IAAI,CAACga,KAAK,CAACxU,IAAI,CAAC,EAAE;MACtC2N,IAAI,CAAC6D,EAAE,GAAG,IAAI,CAACqnB,eAAe,EAAE;MAChC,IAAI6J,WAAW,EAAE;QACf,IAAI,CAACwd,yBAAyB,CAACvyC,IAAI,CAAC6D,EAAE,EAAE4K,WAAW,CAAC;MACtD;IACF,CAAC,MAAM;MACL,IAAIumB,UAAU,IAAI,CAACD,WAAW,EAAE;QAC9B/0B,IAAI,CAAC6D,EAAE,GAAG,IAAI;MAChB,CAAC,MAAM;QACL,MAAM,IAAI,CAACkC,KAAK,CAAClG,MAAM,CAAC/H,gBAAgB,EAAE;UAAErS,EAAE,EAAE,IAAI,CAACohB,KAAK,CAAC3B;QAAS,CAAC,CAAC;MACxE;IACF;EACF;EAGAoxB,eAAeA,CAAet2B,IAAqB,EAAQ;IACzDA,IAAI,CAACE,UAAU,GAAG,IAAI,CAACuY,GAAG,CAAa,EAAA,CAAA,GAAG,IAAI,CAACk3C,mBAAmB,EAAE,GAAG,IAAI;EAC7E;EAKAjpD,WAAWA,CAET1G,IAIC,EACD2G,UAAgC,EACnB;IACb,MAAMw0D,UAAU,GAAG,IAAI,CAACtQ,gCAAgC,CAEtD7qD,IAAI,CACL;IACD,MAAMo7D,iBAAiB,GAAG,CAACD,UAAU,IAAI,IAAI,CAAC1iD,GAAG,CAAU,EAAA,CAAA;IAC3D,MAAM4iD,OAAO,GACXD,iBAAiB,IACjB,IAAI,CAACzmC,aAAa,CAEhB30B,IAAI,CACL;IACH,MAAM60B,YAAY,GAChBwmC,OAAO,IACP,IAAI,CAACzmC,kCAAkC,CAErC50B,IAAI,CACL;IACH,MAAMs7D,mBAAmB,GACvBF,iBAAiB,KAAK,CAACvmC,YAAY,IAAI,IAAI,CAACpc,GAAG,CAAA,EAAA,CAAU,CAAC;IAC5D,MAAM8iD,cAAc,GAAGJ,UAAU,IAAIE,OAAO;IAE5C,IAAIA,OAAO,IAAI,CAACxmC,YAAY,EAAE;MAC5B,IAAIsmC,UAAU,EAAE,IAAI,CAAChkE,UAAU,EAAE;MACjC,IAAIwP,UAAU,EAAE;QACd,MAAM,IAAI,CAACZ,KAAK,CAAClG,MAAM,CAAChE,0BAA0B,EAAE;UAAEpW,EAAE,EAAEua;QAAK,CAAC,CAAC;MACnE;MACA,IAAI,CAAC00B,eAAe,CAAC10B,IAAI,EAAsC,IAAI,CAAC;MAEpE,OAAO,IAAI,CAACuE,UAAU,CAACvE,IAAI,EAAE,sBAAsB,CAAC;IACtD;IAEA,MAAMw7D,aAAa,GAAG,IAAI,CAACC,+BAA+B,CAExDz7D,IAAI,CACL;IAED,IAAIm7D,UAAU,IAAIC,iBAAiB,IAAI,CAACC,OAAO,IAAI,CAACG,aAAa,EAAE;MACjE,IAAI,CAACrkE,UAAU,CAAC,IAAI,EAAY,CAAA,CAAA;IAClC;IAEA,IAAI09B,YAAY,IAAIymC,mBAAmB,EAAE;MACvC,IAAI,CAACnkE,UAAU,CAAC,IAAI,EAAW,EAAA,CAAA;IACjC;IAEA,IAAIukE,cAAc;IAClB,IAAIH,cAAc,IAAIC,aAAa,EAAE;MACnCE,cAAc,GAAG,KAAK;MACtB,IAAI/0D,UAAU,EAAE;QACd,MAAM,IAAI,CAACZ,KAAK,CAAClG,MAAM,CAAChE,0BAA0B,EAAE;UAAEpW,EAAE,EAAEua;QAAK,CAAC,CAAC;MACnE;MACA,IAAI,CAAC00B,eAAe,CAClB10B,IAAI,EACJu7D,cAAc,CACf;IACH,CAAC,MAAM;MACLG,cAAc,GAAG,IAAI,CAACC,2BAA2B,CAC/C37D,IAAI,CACL;IACH;IAEA,IAAIu7D,cAAc,IAAIC,aAAa,IAAIE,cAAc,EAAE;MAAA,IAAAE,kBAAA;MACrD,MAAMhrC,KAAK,GAAG5wB,IAAwC;MACtD,IAAI,CAAC8qD,WAAW,CAACl6B,KAAK,EAAE,IAAI,EAAE,KAAK,EAAE,CAAC,CAACA,KAAK,CAACxqB,MAAM,CAAC;MACpD,IAAI,CAAAw1D,CAAAA,kBAAA,GAAAhrC,KAAK,CAAC1pB,WAAW,KAAjB00D,IAAAA,GAAAA,KAAAA,CAAAA,GAAAA,kBAAA,CAAmBvpE,IAAI,MAAK,kBAAkB,EAAE;QAClD,IAAI,CAAC21D,mBAAmB,CAACrhD,UAAU,EAAEiqB,KAAK,CAAC1pB,WAAW,EAAE0pB,KAAK,CAAC;MAC/D,CAAA,MAAM,IAAIjqB,UAAU,EAAE;QACrB,MAAM,IAAI,CAACZ,KAAK,CAAClG,MAAM,CAAChE,0BAA0B,EAAE;UAAEpW,EAAE,EAAEua;QAAK,CAAC,CAAC;MACnE;MACA,OAAO,IAAI,CAACuE,UAAU,CAACqsB,KAAK,EAAE,wBAAwB,CAAC;IACzD;IAEA,IAAI,IAAI,CAACnY,GAAG,CAAA,EAAA,CAAa,EAAE;MACzB,MAAMmY,KAAK,GAAG5wB,IAA0C;MAExD,MAAMs0B,IAAI,GAAG,IAAI,CAACxB,4BAA4B,EAAE;MAChDlC,KAAK,CAAC1pB,WAAW,GAAGotB,IAAI;MAExB,IAAIA,IAAI,CAACjiC,IAAI,KAAK,kBAAkB,EAAE;QACpC,IAAI,CAAC21D,mBAAmB,CAACrhD,UAAU,EAAE2tB,IAAI,EAAwB1D,KAAK,CAAC;MACxE,CAAA,MAAM,IAAIjqB,UAAU,EAAE;QACrB,MAAM,IAAI,CAACZ,KAAK,CAAClG,MAAM,CAAChE,0BAA0B,EAAE;UAAEpW,EAAE,EAAEua;QAAK,CAAC,CAAC;MACnE;MAEA,IAAI,CAAC8qD,WAAW,CAACl6B,KAAK,EAAE,IAAI,EAAE,IAAI,CAAC;MAEnC,OAAO,IAAI,CAACrsB,UAAU,CAACqsB,KAAK,EAAE,0BAA0B,CAAC;IAC3D;IAEA,IAAI,CAACz5B,UAAU,CAAC,IAAI,EAAY,CAAA,CAAA;EAClC;EAGAw9B,aAAaA,CAAC30B,IAAY,EAAW;IACnC,OAAO,IAAI,CAACyY,GAAG,CAAS,EAAA,CAAA;EAC1B;EAEAoyC,gCAAgCA,CAAC7qD,IAAY,EAAW;IACtD,IAAI,IAAI,CAAC6yB,wBAAwB,EAAE,EAAE;MAEnC,IAAI,CAAClY,YAAY,CAAC,mBAAmB,CAAC;MACtC,MAAMuc,SAAS,GAAG,IAAI,CAAC7yB,SAAS,EAAE;MAClC6yB,SAAS,CAACnwB,QAAQ,GAAG,IAAI,CAACmkB,eAAe,CAAC,IAAI,CAAC;MAC/ClrB,IAAI,CAACgH,UAAU,GAAG,CAAC,IAAI,CAACzC,UAAU,CAAC2yB,SAAS,EAAE,wBAAwB,CAAC,CAAC;MACxE,OAAO,IAAI;IACb;IACA,OAAO,KAAK;EACd;EAEAtC,kCAAkCA,CAAC50B,IAAY,EAAW;IACxD,IAAI,IAAI,CAAC0hB,YAAY,CAAA,EAAA,CAAQ,EAAE;MAC7B,IAAI,CAAC1hB,IAAI,CAACgH,UAAU,EAAEhH,IAAI,CAACgH,UAAU,GAAG,EAAE;MAE1C,MAAMkwB,SAAS,GAAG,IAAI,CAAC7R,WAAW,CAAC,IAAI,CAACxe,KAAK,CAACC,eAAe,CAAC;MAE9D,IAAI,CAAC8C,IAAI,EAAE;MAEXstB,SAAS,CAACnwB,QAAQ,GAAG,IAAI,CAACmiD,qBAAqB,EAAE;MACjDlpD,IAAI,CAACgH,UAAU,CAACvjB,IAAI,CAClB,IAAI,CAAC8gB,UAAU,CAAC2yB,SAAS,EAAE,0BAA0B,CAAC,CACvD;MACD,OAAO,IAAI;IACb;IACA,OAAO,KAAK;EACd;EAEAukC,+BAA+BA,CAACz7D,IAAY,EAAW;IACrD,IAAI,IAAI,CAACkW,KAAK,CAAA,CAAA,CAAW,EAAE;MACzB,IAAI,CAAClW,IAAI,CAACgH,UAAU,EAAEhH,IAAI,CAACgH,UAAU,GAAG,EAAE;MAC1C,MAAM60D,YAAY,GAAG77D,IAAI,CAAC2sB,UAAU,KAAK,MAAM;MAC/C3sB,IAAI,CAACgH,UAAU,CAACvjB,IAAI,CAAC,GAAG,IAAI,CAACgxC,qBAAqB,CAAConC,YAAY,CAAC,CAAC;MAEjE77D,IAAI,CAACoG,MAAM,GAAG,IAAI;MAClBpG,IAAI,CAACkH,WAAW,GAAG,IAAI;MACvB,IAAI,IAAI,CAACZ,SAAS,CAAC,kBAAkB,CAAC,EAAE;QACtCtG,IAAI,CAAC87D,UAAU,GAAG,EAAE;MACtB;MAEA,OAAO,IAAI;IACb;IACA,OAAO,KAAK;EACd;EAEAH,2BAA2BA,CAEzB37D,IAAsC,EAC7B;IACT,IAAI,IAAI,CAAC4yB,4BAA4B,EAAE,EAAE;MACvC5yB,IAAI,CAACgH,UAAU,GAAG,EAAE;MACpBhH,IAAI,CAACoG,MAAM,GAAG,IAAI;MAClB,IAAI,IAAI,CAACE,SAAS,CAAC,kBAAkB,CAAC,EAAE;QACtCtG,IAAI,CAAC87D,UAAU,GAAG,EAAE;MACtB;MACA97D,IAAI,CAACkH,WAAW,GAAG,IAAI,CAACqtB,sBAAsB,CAACv0B,IAAI,CAAC;MACpD,OAAO,IAAI;IACb;IACA,OAAO,KAAK;EACd;EAEA63D,eAAeA,CAAAA,EAAY;IACzB,IAAI,CAAC,IAAI,CAACn2C,YAAY,CAAW,EAAA,CAAA,EAAE,OAAO,KAAK;IAC/C,MAAM9X,IAAI,GAAG,IAAI,CAACmP,cAAc,EAAE;IAClC,OACE,CAACjH,SAAS,CAACpJ,IAAI,CAAC,IAAI,CAAC+I,KAAK,CAAC2C,KAAK,CAAC,IAAI,CAACvN,KAAK,CAAC5H,GAAG,EAAE2K,IAAI,CAAC,CAAC,IACvD,IAAI,CAAC+X,oBAAoB,CAAC/X,IAAI,EAAE,UAAU,CAAC;EAE/C;EAEAkpB,4BAA4BA,CAAAA,EAA6C;IACvE,MAAMH,IAAI,GAAG,IAAI,CAACtuB,SAAS,EAAE;IAE7B,IAAI,IAAI,CAAC6R,KAAK,CAAA,EAAA,CAAc,EAAE;MAC5B,IAAI,CAACtM,IAAI,EAAE;MACX,OAAO,IAAI,CAACkoD,aAAa,CACvBn/B,IAAI,EACJymC,KAA4D,CAC7D;IACH,CAAC,MAAM,IAAI,IAAI,CAACvB,eAAe,EAAE,EAAE;MACjC,IAAI,CAACjuD,IAAI,EAAE;MACX,IAAI,CAACA,IAAI,EAAE;MACX,OAAO,IAAI,CAACkoD,aAAa,CACvBn/B,IAAI,EACJymC,KAC8B,IACL,CAC1B;IACH;IAEA,IAAI,IAAI,CAACljD,KAAK,CAAA,EAAA,CAAW,EAAE;MACzB,OAAO,IAAI,CAACysC,UAAU,CAAChwB,IAAI,EAA+B,IAAI,EAAE,IAAI,CAAC;IACvE;IAEA,IAAI,IAAI,CAACzc,KAAK,CAAA,EAAA,CAAO,EAAE;MACrB,IACE,IAAI,CAAC5P,SAAS,CAAC,YAAY,CAAC,IAC5B,IAAI,CAAC5C,eAAe,CAAC,YAAY,EAAE,wBAAwB,CAAC,KAAK,IAAI,EACrE;QACA,IAAI,CAACqC,KAAK,CAAClG,MAAM,CAACjM,qBAAqB,EAAE;UAAEnO,EAAE,EAAE,IAAI,CAACohB,KAAK,CAAC3B;QAAS,CAAC,CAAC;MACvE;MACA,OAAO,IAAI,CAACy9C,UAAU,CACpB,IAAI,CAACqF,mBAAmB,CACtB,IAAI,CAAC8I,eAAe,CAAC,KAAK,CAAC,EAC3B,IAAI,CAACzsD,SAAS,EAAsB,CACrC,EACD,IAAI,EACJ,IAAI,CACL;IACH;IAEA,IAAI,IAAI,CAAC6R,KAAK,CAAA,EAAA,CAAW,IAAI,IAAI,CAACA,KAAK,CAAA,EAAA,CAAS,IAAI,IAAI,CAACwW,KAAK,EAAE,EAAE;MAChE,MAAM,IAAI,CAAC3mB,KAAK,CAAClG,MAAM,CAAC/D,wBAAwB,EAAE;QAChDrW,EAAE,EAAE,IAAI,CAACohB,KAAK,CAAC3B;MACjB,CAAC,CAAC;IACJ;IAEA,MAAMqQ,GAAG,GAAG,IAAI,CAACke,uBAAuB,EAAE;IAC1C,IAAI,CAACnR,SAAS,EAAE;IAChB,OAAO/M,GAAG;EACZ;EAGAgf,sBAAsBA,CAGpBv0B,IAAsC,EACJ;IAClC,IAAI,IAAI,CAACkW,KAAK,CAAA,EAAA,CAAW,EAAE;MACzB,MAAMlW,IAAI,GAAG,IAAI,CAAC2iD,UAAU,CAC1B,IAAI,CAACt+C,SAAS,EAAsB,EACpC,IAAI,EACJ,KAAK,CACN;MACD,OAAOrE,IAAI;IACb;IACA,OAAO,IAAI,CAAC22D,sBAAsB,EAAE;EACtC;EAEA9jC,wBAAwBA,CAAAA,EAAY;IAClC,MAAM;MAAExgC;KAAM,GAAG,IAAI,CAACwU,KAAK;IAC3B,IAAIha,iBAAiB,CAACwF,IAAI,CAAC,EAAE;MAC3B,IAAKA,IAAI,KAAA,EAAc,IAAI,CAAC,IAAI,CAACwU,KAAK,CAAC+M,WAAW,IAAKvhB,IAAI,KAAA,EAAY,EAAE;QACvE,OAAO,KAAK;MACd;MACA,IACE,CAACA,IAAI,KAAa,GAAA,IAAIA,IAAI,KAAA,GAAkB,KAC5C,CAAC,IAAI,CAACwU,KAAK,CAAC+M,WAAW,EACvB;QACA,MAAM;UAAEvhB,IAAI,EAAE0pE;QAAS,CAAC,GAAG,IAAI,CAACnjD,SAAS,EAAE;QAK3C,IACG/rB,iBAAiB,CAACkvE,QAAQ,CAAC,IAAIA,QAAQ,KAAa,EAAA,IACrDA,QAAQ,KAAA,CAAc,EACtB;UACA,IAAI,CAAC/9C,eAAe,CAAC,CAAC,MAAM,EAAE,YAAY,CAAC,CAAC;UAC5C,OAAO,KAAK;QACd;MACF;IACD,CAAA,MAAM,IAAI,CAAC,IAAI,CAAC9H,KAAK,IAAa,EAAE;MACnC,OAAO,KAAK;IACd;IAEA,MAAMtM,IAAI,GAAG,IAAI,CAACmP,cAAc,EAAE;IAClC,MAAMijD,OAAO,GAAG,IAAI,CAACr6C,oBAAoB,CAAC/X,IAAI,EAAE,MAAM,CAAC;IACvD,IACE,IAAI,CAAC6H,KAAK,CAACC,UAAU,CAAC9H,IAAI,CAAC,KAAoB,EAAA,IAC9C/c,iBAAiB,CAAC,IAAI,CAACga,KAAK,CAACxU,IAAI,CAAC,IAAI2pE,OAAQ,EAC/C;MACA,OAAO,IAAI;IACb;IAEA,IAAI,IAAI,CAAC9lD,KAAK,CAAa,EAAA,CAAA,IAAI8lD,OAAO,EAAE;MACtC,MAAMC,aAAa,GAAG,IAAI,CAACxqD,KAAK,CAACC,UAAU,CACzC,IAAI,CAACsH,mBAAmB,CAACpP,IAAI,GAAG,CAAC,CAAC,CACnC;MACD,OACEqyD,aAAa,KAAA,EAA4B,IACzCA,aAAa,KAAyB,EAAA;IAE1C;IACA,OAAO,KAAK;EACd;EAEAvnC,eAAeA,CAEb10B,IAAsC,EACtCwiB,MAAgB,EACV;IACN,IAAI,IAAI,CAACR,aAAa,CAAA,EAAA,CAAU,EAAE;MAChChiB,IAAI,CAACoG,MAAM,GAAG,IAAI,CAAC8kD,iBAAiB,EAAE;MACtC,IAAI,CAACJ,WAAW,CAAC9qD,IAAI,CAAC;MACtB,MAAM87D,UAAU,GAAG,IAAI,CAACI,0BAA0B,EAAE;MACpD,IAAIJ,UAAU,EAAE;QACd97D,IAAI,CAAC87D,UAAU,GAAGA,UAAU;QAC5B,IAAI,CAACK,qBAAqB,CAACn8D,IAAI,CAAC;MAClC;IACD,CAAA,MAAM,IAAIwiB,MAAM,EAAE;MACjB,IAAI,CAACrrB,UAAU,EAAE;IACnB;IAEA,IAAI,CAACmrB,SAAS,EAAE;EAClB;EAEAsQ,4BAA4BA,CAAAA,EAAY;IACtC,MAAM;MAAEvgC;KAAM,GAAG,IAAI,CAACwU,KAAK;IAC3B,IAAIxU,IAAI,OAAU,EAAE;MAClB,IAAI,CAAC2rB,eAAe,CAAC,CAAC,YAAY,EAAE,mBAAmB,CAAC,CAAC;MACzD,IAAI,IAAI,CAAC1X,SAAS,CAAC,YAAY,CAAC,EAAE;QAChC,IACE,IAAI,CAAC5C,eAAe,CAAC,YAAY,EAAE,wBAAwB,CAAC,KAAK,IAAI,EACrE;UACA,IAAI,CAACqC,KAAK,CAAClG,MAAM,CAACjM,qBAAqB,EAAE;YACvCnO,EAAE,EAAE,IAAI,CAACohB,KAAK,CAAC3B;UACjB,CAAC,CAAC;QACJ;QAEA,OAAO,IAAI;MACb;IACF;IAEA,OACE7S,IAAI,OAAY,IAChBA,IAAI,OAAc,IAClBA,IAAI,OAAiB,IACrBA,IAAI,OAAc,IAClB,IAAI,CAACq6B,KAAK,EAAE,IACZ,IAAI,CAACmrC,eAAe,EAAE;EAE1B;EAEA/M,WAAWA,CACT9qD,IAAmE,EACnEo8D,UAAoB,EACpBC,SAAmB,EACnBC,MAAgB,EACV;IACN,IAAIF,UAAU,EAAE;MAEd,IAAIC,SAAS,EAAE;QAEb,IAAI,CAACrX,qBAAqB,CAAChlD,IAAI,EAAE,SAAS,CAAC;QAC3C,IAAI,IAAI,CAACsG,SAAS,CAAC,mBAAmB,CAAC,EAAE;UAAA,IAAAi2D,kBAAA;UACvC,MAAMr1D,WAAW,GAAIlH,IAAI,CACtBkH,WAAW;UACd,IACEA,WAAW,CAAC7U,IAAI,KAAK,YAAY,IACjC6U,WAAW,CAACxkB,IAAI,KAAK,MAAM,IAC3BwkB,WAAW,CAACtY,GAAG,GAAGsY,WAAW,CAACvY,KAAK,KAAK,CAAC,IACzC,GAAA4tE,kBAAA,GAACr1D,WAAW,CAACvF,KAAK,KAAA,IAAA,IAAjB46D,kBAAA,CAAmB/5D,aAAa,CACjC,EAAA;YACA,IAAI,CAACuD,KAAK,CAAClG,MAAM,CAAC/K,6BAA6B,EAAE;cAC/CrP,EAAE,EAAEyhB;YACN,CAAC,CAAC;UACJ;QACF;MAED,CAAA,MAAM,IAAIlH,IAAI,CAACgH,UAAU,IAAIhH,IAAI,CAACgH,UAAU,CAAC5Y,MAAM,EAAE;QAGpD,KAAK,MAAM8oC,SAAS,IAAIl3B,IAAI,CAACgH,UAAU,EAAE;UACvC,MAAM;YAAED;UAAU,CAAA,GAAGmwB,SAAS;UAC9B,MAAM3iC,UAAU,GACdwS,QAAQ,CAAC1U,IAAI,KAAK,YAAY,GAAG0U,QAAQ,CAACrkB,IAAI,GAAGqkB,QAAQ,CAACrX,KAAK;UACjE,IAAI,CAACs1D,qBAAqB,CAAC9tB,SAAS,EAAE3iC,UAAU,CAAC;UACjD,IAAI,CAAC+nE,MAAM,IAAIplC,SAAS,CAACC,KAAK,EAAE;YAC9B,MAAM;cAAEA;YAAO,CAAA,GAAGD,SAAS;YAC3B,IAAIC,KAAK,CAAC9kC,IAAI,KAAK,YAAY,EAAE;cAC/B,IAAI,CAAC0T,KAAK,CAAClG,MAAM,CAACjL,qBAAqB,EAAE;gBACvCnP,EAAE,EAAEyxC,SAAS;gBACbriC,SAAS,EAAEsiC,KAAK,CAACznC,KAAK;gBACtB6E;cACF,CAAC,CAAC;YACJ,CAAC,MAAM;cAEL,IAAI,CAACwjC,iBAAiB,CAACZ,KAAK,CAACz0C,IAAI,EAAEy0C,KAAK,CAACt4B,GAAG,CAAClQ,KAAK,EAAE,IAAI,EAAE,KAAK,CAAC;cAEhE,IAAI,CAAC4f,KAAK,CAACS,gBAAgB,CAACmoB,KAAK,CAAC;YACpC;UACF;QACF;MACF,CAAC,MAAM,IAAIn3B,IAAI,CAACkH,WAAW,EAAE;QAE3B,IACElH,IAAI,CAACkH,WAAW,CAAC7U,IAAI,KAAK,qBAAqB,IAC/C2N,IAAI,CAACkH,WAAW,CAAC7U,IAAI,KAAK,kBAAkB,EAC5C;UACA,MAAMwR,EAAE,GAAG7D,IAAI,CAACkH,WAAW,CAACrD,EAAE;UAC9B,IAAI,CAACA,EAAE,EAAE,MAAM,IAAIljB,KAAK,CAAC,mBAAmB,CAAC;UAE7C,IAAI,CAACqkE,qBAAqB,CAAChlD,IAAI,EAAE6D,EAAE,CAACnhB,IAAI,CAAC;QAC1C,CAAA,MAAM,IAAIsd,IAAI,CAACkH,WAAW,CAAC7U,IAAI,KAAK,qBAAqB,EAAE;UAC1D,KAAK,MAAM6U,WAAW,IAAIlH,IAAI,CAACkH,WAAW,CAACo+C,YAAY,EAAE;YACvD,IAAI,CAACrjD,gBAAgB,CAACiF,WAAW,CAACrD,EAAE,CAAC;UACvC;QACF;MACF;IACF;EACF;EAEA5B,gBAAgBA,CAACjC,IAAkC,EAAQ;IACzD,IAAIA,IAAI,CAAC3N,IAAI,KAAK,YAAY,EAAE;MAC9B,IAAI,CAAC2yD,qBAAqB,CAAChlD,IAAI,EAAEA,IAAI,CAACtd,IAAI,CAAC;IAC7C,CAAC,MAAM,IAAIsd,IAAI,CAAC3N,IAAI,KAAK,eAAe,EAAE;MACxC,KAAK,MAAMwS,IAAI,IAAI7E,IAAI,CAAClQ,UAAU,EAAE;QAClC,IAAI,CAACmS,gBAAgB,CAAC4C,IAAI,CAAC;MAC7B;IACF,CAAC,MAAM,IAAI7E,IAAI,CAAC3N,IAAI,KAAK,cAAc,EAAE;MACvC,KAAK,MAAMwgE,IAAI,IAAI7yD,IAAI,CAACuQ,QAAQ,EAAE;QAChC,IAAIsiD,IAAI,EAAE;UACR,IAAI,CAAC5wD,gBAAgB,CAAC4wD,IAAI,CAAC;QAC7B;MACF;IACF,CAAC,MAAM,IAAI7yD,IAAI,CAAC3N,IAAI,KAAK,gBAAgB,EAAE;MAEzC,IAAI,CAAC4P,gBAAgB,CAACjC,IAAI,CAACtQ,KAAK,CAAC;IACnC,CAAC,MAAM,IAAIsQ,IAAI,CAAC3N,IAAI,KAAK,aAAa,EAAE;MACtC,IAAI,CAAC4P,gBAAgB,CAACjC,IAAI,CAACb,QAAQ,CAAC;IACtC,CAAC,MAAM,IAAIa,IAAI,CAAC3N,IAAI,KAAK,mBAAmB,EAAE;MAC5C,IAAI,CAAC4P,gBAAgB,CAACjC,IAAI,CAACu1B,IAAI,CAAC;IAClC;EACF;EAEAyvB,qBAAqBA,CACnBhlD,IAMC,EACDzL,UAAkB,EACZ;IACN,IAAI,IAAI,CAACqvB,mBAAmB,CAACta,GAAG,CAAC/U,UAAU,CAAC,EAAE;MAC5C,IAAIA,UAAU,KAAK,SAAS,EAAE;QAC5B,IAAI,CAACwR,KAAK,CAAClG,MAAM,CAACxL,sBAAsB,EAAE;UAAE5O,EAAE,EAAEua;QAAK,CAAC,CAAC;MACzD,CAAC,MAAM;QACL,IAAI,CAAC+F,KAAK,CAAClG,MAAM,CAACvL,eAAe,EAAE;UAAE7O,EAAE,EAAEua,IAAI;UAAEzL;QAAW,CAAC,CAAC;MAC9D;IACF;IACA,IAAI,CAACqvB,mBAAmB,CAACjV,GAAG,CAACpa,UAAU,CAAC;EAC1C;EAIAkgC,qBAAqBA,CAAC6zB,cAAuB,EAA4B;IACvE,MAAMkU,KAAK,GAAG,EAAE;IAChB,IAAItrC,KAAK,GAAG,IAAI;IAGhB,IAAI,CAAC1O,MAAM,CAAW,CAAA,CAAA;IAEtB,OAAO,CAAC,IAAI,CAAC/J,GAAG,GAAW,EAAE;MAC3B,IAAIyY,KAAK,EAAE;QACTA,KAAK,GAAG,KAAK;MACf,CAAC,MAAM;QACL,IAAI,CAAC1O,MAAM,CAAU,EAAA,CAAA;QACrB,IAAI,IAAI,CAAC/J,GAAG,CAAA,CAAA,CAAW,EAAE;MAC3B;MACA,MAAMgf,eAAe,GAAG,IAAI,CAAC/V,YAAY,CAAU,GAAA,CAAA;MACnD,MAAM2mC,QAAQ,GAAG,IAAI,CAACnyC,KAAK,CAAW,GAAA,CAAA;MACtC,MAAMlW,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAE;MAC7BrE,IAAI,CAACm3B,KAAK,GAAG,IAAI,CAAC+xB,qBAAqB,EAAE;MACzCsT,KAAK,CAAC/4E,IAAI,CACR,IAAI,CAAC2kE,oBAAoB,CACvBpoD,IAAI,EACJqoD,QAAQ,EACRC,cAAc,EACd7wB,eAAe,CAChB,CACF;IACH;IAEA,OAAO+kC,KAAK;EACd;EAEApU,oBAAoBA,CAClBpoD,IAAS,EACTqoD,QAAiB,EAEjBC,cAAuB,EACvB7wB,eAAwB,EAEL;IACnB,IAAI,IAAI,CAACzV,aAAa,CAAA,EAAA,CAAQ,EAAE;MAC9BhiB,IAAI,CAAC+G,QAAQ,GAAG,IAAI,CAACmiD,qBAAqB,EAAE;IAC7C,CAAA,MAAM,IAAIb,QAAQ,EAAE;MACnBroD,IAAI,CAAC+G,QAAQ,GAAGoe,kBAAkB,CAACnlB,IAAI,CAACm3B,KAAK,CAAC;IAChD,CAAC,MAAM,IAAI,CAACn3B,IAAI,CAAC+G,QAAQ,EAAE;MACzB/G,IAAI,CAAC+G,QAAQ,GAAGge,eAAe,CAAC/kB,IAAI,CAACm3B,KAAK,CAAC;IAC7C;IACA,OAAO,IAAI,CAAC5yB,UAAU,CAAoBvE,IAAI,EAAE,iBAAiB,CAAC;EACpE;EAGAkpD,qBAAqBA,CAAAA,EAAmC;IACtD,IAAI,IAAI,CAAChzC,KAAK,CAAA,GAAA,CAAW,EAAE;MACzB,MAAMge,MAAM,GAAG,IAAI,CAAC/yB,kBAAkB,CAAC,IAAI,CAAC0F,KAAK,CAACnX,KAAK,CAAC;MACxD,MAAM+sE,SAAS,GAAGvoC,MAAM,CAACxkC,KAAK,CAACwmB,KAAK,CAACg/C,aAAa,CAAC;MACnD,IAAIuH,SAAS,EAAE;QACb,IAAI,CAAC12D,KAAK,CAAClG,MAAM,CAACjH,gCAAgC,EAAE;UAClDnT,EAAE,EAAEyuC,MAAM;UACVr7B,iBAAiB,EAAE4jE,SAAS,CAAC,CAAC,CAAC,CAAC/qD,UAAU,CAAC,CAAC;QAC9C,CAAC,CAAC;MACJ;MACA,OAAOwiB,MAAM;IACf;IACA,OAAO,IAAI,CAAChJ,eAAe,CAAC,IAAI,CAAC;EACnC;EAEAwxC,kBAAkBA,CAChB18D,IAEC,EACQ;IACT,IAAIA,IAAI,CAAC87D,UAAU,IAAI,IAAI,EAAE;MAC3B,OAAO97D,IAAI,CAAC87D,UAAU,CAAC59C,IAAI,CAAC,CAAC;QAAEr9B,GAAG;QAAE6O;MAAM,CAAC,KAAK;QAC9C,OACEA,KAAK,CAACA,KAAK,KAAK,MAAM,KACrB7O,GAAG,CAACwR,IAAI,KAAK,YAAY,GACtBxR,GAAG,CAAC6B,IAAI,KAAK,MAAM,GACnB7B,GAAG,CAAC6O,KAAK,KAAK,MAAM,CAAC;MAE7B,CAAC,CAAC;IACJ;IACA,OAAO,KAAK;EACd;EAEAqnC,qBAAqBA,CAAC/2B,IAAiC,EAAE;IACvD,IAAIA,IAAI,CAACg3B,MAAM,EAAE;MAAA,IAAA2lC,gBAAA;MACf,IACE38D,IAAI,CAACgH,UAAU,CAAC5Y,MAAM,KAAK,CAAC,IAC5B4R,IAAI,CAACgH,UAAU,CAAC,CAAC,CAAC,CAAC3U,IAAI,KAAK,wBAAwB,EACpD;QACA,IAAI,CAAC0T,KAAK,CAAClG,MAAM,CAAC7J,0BAA0B,EAAE;UAC5CvQ,EAAE,EAAEua,IAAI,CAACgH,UAAU,CAAC,CAAC,CAAC,CAACnI,GAAG,CAAClQ;QAC7B,CAAC,CAAC;MACJ;MACA,IAAI,CAAAguE,CAAAA,gBAAA,GAAA38D,IAAI,CAAC87D,UAAU,KAAfa,IAAAA,GAAAA,KAAAA,CAAAA,GAAAA,gBAAA,CAAiBvuE,MAAM,IAAG,CAAC,EAAE;QAC/B,IAAI,CAAC2X,KAAK,CAAClG,MAAM,CAAC9J,4BAA4B,EAAE;UAC9CtQ,EAAE,EAAEua,IAAI,CAACgH,UAAU,CAAC,CAAC,CAAC,CAACnI,GAAG,CAAClQ;QAC7B,CAAC,CAAC;MACJ;IACF;EACF;EAEAwtE,qBAAqBA,CACnBn8D,IAEC,EACD;IAEA,IAAI,IAAI,CAAC08D,kBAAkB,CAAC18D,IAAI,CAAC,IAAIA,IAAI,CAAC3N,IAAI,KAAK,sBAAsB,EAAE;MAEzE,MAAM;QAAE2U;MAAY,CAAA,GAAGhH,IAAI;MAC3B,IAAIgH,UAAU,IAAI,IAAI,EAAE;QAEtB,MAAM41D,wBAAwB,GAAG51D,UAAU,CAAC+kD,IAAI,CAAC70B,SAAS,IAAI;UAC5D,IAAIS,QAAQ;UACZ,IAAIT,SAAS,CAAC7kC,IAAI,KAAK,iBAAiB,EAAE;YACxCslC,QAAQ,GAAGT,SAAS,CAACC,KAAK;UAC5B,CAAC,MAAM,IAAID,SAAS,CAAC7kC,IAAI,KAAK,iBAAiB,EAAE;YAC/CslC,QAAQ,GAAGT,SAAS,CAACS,QAAQ;UAC/B;UACA,IAAIA,QAAQ,KAAKn4C,SAAS,EAAE;YAC1B,OAAOm4C,QAAQ,CAACtlC,IAAI,KAAK,YAAY,GACjCslC,QAAQ,CAACj1C,IAAI,KAAK,SAAS,GAC3Bi1C,QAAQ,CAACjoC,KAAK,KAAK,SAAS;UAClC;QACF,CAAC,CAAC;QACF,IAAIktE,wBAAwB,KAAKp9E,SAAS,EAAE;UAC1C,IAAI,CAACumB,KAAK,CAAClG,MAAM,CAAC/J,2BAA2B,EAAE;YAC7CrQ,EAAE,EAAEm3E,wBAAwB,CAAC/9D,GAAG,CAAClQ;UACnC,CAAC,CAAC;QACJ;MACF;IACF;EACF;EAEAkuE,0BAA0BA,CAAC78D,IAAiC,EAAE;IAC5D,IAAI88D,kBAAkB,GAAG,KAAK;IAC9B,IAAI,IAAI,CAACp7C,YAAY,CAAA,GAAA,CAAY,EAAE;MACjC,MAAM9I,SAAS,GAAG,IAAI,CAACA,SAAS,EAAE;MAClC,MAAMmjD,QAAQ,GAAGnjD,SAAS,CAACvmB,IAAI;MAC/B,IAAIxF,iBAAiB,CAACkvE,QAAQ,CAAC,EAAE;QAC/B,IAAIA,QAAQ,OAAa,EAAE;UAEzBe,kBAAkB,GAAG,IAAI;QAC3B,CAAC,MAAM;UACL,MAAMC,sBAAsB,GAAG,IAAI,CAACtrD,KAAK,CAACC,UAAU,CAClD,IAAI,CAACsH,mBAAmB,CAACJ,SAAS,CAAChqB,GAAG,CAAC,CACxC;UACD,IAAImuE,sBAAsB,QAAyB,EAAE;YAEnDD,kBAAkB,GAAG,IAAI;UAC3B;QACF;MACF,CAAC,MAAM,IAAIf,QAAQ,KAAA,EAAa,EAAE;QAKhCe,kBAAkB,GAAG,IAAI;MAC3B;IACF;IACA,IAAIA,kBAAkB,EAAE;MACtB,IAAI,CAACniD,YAAY,CAAC,kBAAkB,CAAC;MACrC,IAAI,CAAC/Q,IAAI,EAAE;MACX5J,IAAI,CAACg3B,MAAM,GAAG,IAAI;IACnB,CAAA,MAAM,IAAI,IAAI,CAAC1wB,SAAS,CAAC,kBAAkB,CAAC,EAAE;MAC7CtG,IAAI,CAACg3B,MAAM,GAAG,KAAK;IACrB;EACF;EAKAzK,WAAWA,CAAevsB,IAAiC,EAAe;IAExEA,IAAI,CAACgH,UAAU,GAAG,EAAE;IACpB,IAAI,CAAC,IAAI,CAACkP,KAAK,KAAW,EAAE;MAC1B,IAAI,CAAC2mD,0BAA0B,CAAC78D,IAAI,CAAC;MAGrC,MAAMm7D,UAAU,GAAG,IAAI,CAAC9jC,gCAAgC,CAACr3B,IAAI,CAAC;MAO9D,MAAMg9D,SAAS,GAAG,CAAC7B,UAAU,IAAI,IAAI,CAAC1iD,GAAG,CAAU,EAAA,CAAA;MAGnD,MAAM4iD,OAAO,GAAG2B,SAAS,IAAI,IAAI,CAAChS,6BAA6B,CAAChrD,IAAI,CAAC;MAGrE,IAAIg9D,SAAS,IAAI,CAAC3B,OAAO,EAAE,IAAI,CAACpQ,0BAA0B,CAACjrD,IAAI,CAAC;MAChE,IAAI,CAACiiB,gBAAgB,CAAU,EAAA,CAAA;IACjC;IACAjiB,IAAI,CAACoG,MAAM,GAAG,IAAI,CAAC8kD,iBAAiB,EAAE;IAItC,MAAM4Q,UAAU,GAAG,IAAI,CAACI,0BAA0B,EAAE;IACpD,IAAIJ,UAAU,EAAE;MACd97D,IAAI,CAAC87D,UAAU,GAAGA,UAAU;IAC9B,CAAC,MAAyC;MACxC,MAAMt1D,UAAU,GAAG,IAAI,CAACy2D,0BAA0B,EAAE;MACpD,IAAIz2D,UAAU,EAAE;QAEdxG,IAAI,CAACwG,UAAU,GAAGA,UAAU;MAC9B;IACF;IACA,IAAI,CAACuwB,qBAAqB,CAAC/2B,IAAI,CAAC;IAChC,IAAI,CAACm8D,qBAAqB,CAACn8D,IAAI,CAAC;IAEhC,IAAI,CAACsiB,SAAS,EAAE;IAChB,OAAO,IAAI,CAAC/d,UAAU,CAACvE,IAAI,EAAE,mBAAmB,CAAC;EACnD;EAEAkrD,iBAAiBA,CAAAA,EAAgC;IAC/C,IAAI,CAAC,IAAI,CAACh1C,KAAK,KAAW,EAAE,IAAI,CAAC/e,UAAU,EAAE;IAC7C,OAAO,IAAI,CAACk1B,aAAa,EAAE;EAC7B;EAGAyK,wBAAwBA,CAAC92B,IAAiC,EAAW;IACnE,OAAOnT,iBAAiB,CAAC,IAAI,CAACga,KAAK,CAACxU,IAAI,CAAC;EAC3C;EAEA4kC,yBAAyBA,CAMvBj3B,IAAiC,EACjCk3B,SAAoB,EACpB7kC,IAAe,EACT;IACN6kC,SAAS,CAACC,KAAK,GAAG,IAAI,CAACjM,eAAe,EAAE;IACxClrB,IAAI,CAACgH,UAAU,CAACvjB,IAAI,CAAC,IAAI,CAAC2zC,qBAAqB,CAACF,SAAS,EAAE7kC,IAAI,CAAC,CAAC;EACnE;EAEA+kC,qBAAqBA,CAKnBF,SAAoB,EAAE7kC,IAAe,EAAEoc,WAAW,GAAGhD,YAAY,EAAE;IACnE,IAAI,CAACmmC,SAAS,CAAC1a,SAAS,CAACC,KAAK,EAAE;MAC9B0a,EAAE,EAAE;QAAEx/C;MAAM,CAAA;MACZiT,OAAO,EAAEmJ;IACX,CAAC,CAAC;IACF,OAAO,IAAI,CAAClK,UAAU,CAAC2yB,SAAS,EAAE7kC,IAAI,CAAC;EACzC;EAOA6qE,kBAAkBA,CAAAA,EAAwB;IACxC,MAAMC,KAAK,GAAG,EAAE;IAChB,MAAMC,SAAS,GAAG,IAAI1/D,GAAG,EAAE;IAE3B,GAAG;MACD,IAAI,IAAI,CAACwY,KAAK,CAAA,CAAA,CAAW,EAAE;QACzB;MACF;MAEA,MAAMlW,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAqB;MAGhD,MAAMmvD,OAAO,GAAG,IAAI,CAAC3sD,KAAK,CAACnX,KAAK;MAIhC,IAAI0tE,SAAS,CAAC9zD,GAAG,CAACkqD,OAAO,CAAC,EAAE;QAC1B,IAAI,CAACztD,KAAK,CAAClG,MAAM,CAAClH,iCAAiC,EAAE;UACnDlT,EAAE,EAAE,IAAI,CAACohB,KAAK,CAAC3B,QAAQ;UACvBrkB,GAAG,EAAE2yE;QACP,CAAC,CAAC;MACJ;MACA4J,SAAS,CAACzuD,GAAG,CAAC6kD,OAAO,CAAC;MACtB,IAAI,IAAI,CAACt9C,KAAK,CAAA,GAAA,CAAW,EAAE;QACzBlW,IAAI,CAACnf,GAAG,GAAG,IAAI,CAACsgB,kBAAkB,CAACqyD,OAAO,CAAC;MAC7C,CAAC,MAAM;QACLxzD,IAAI,CAACnf,GAAG,GAAG,IAAI,CAACqqC,eAAe,CAAC,IAAI,CAAC;MACvC;MACA,IAAI,CAAC1I,MAAM,CAAU,EAAA,CAAA;MAErB,IAAI,CAAC,IAAI,CAACtM,KAAK,KAAW,EAAE;QAC1B,MAAM,IAAI,CAACnQ,KAAK,CAAClG,MAAM,CAACnH,2BAA2B,EAAE;UACnDjT,EAAE,EAAE,IAAI,CAACohB,KAAK,CAAC3B;QACjB,CAAC,CAAC;MACJ;MACAlF,IAAI,CAACtQ,KAAK,GAAG,IAAI,CAACyR,kBAAkB,CAAC,IAAI,CAAC0F,KAAK,CAACnX,KAAK,CAAC;MACtDytE,KAAK,CAAC15E,IAAI,CAAC,IAAI,CAAC8gB,UAAU,CAACvE,IAAI,EAAE,iBAAiB,CAAC,CAAC;IACtD,CAAC,QAAQ,IAAI,CAACyY,GAAG,CAAU,EAAA,CAAA;IAE3B,OAAO0kD,KAAK;EACd;EAMAF,0BAA0BA,CAAAA,EAAG;IAC3B,IAAI,IAAI,CAAC/mD,KAAK,CAAU,EAAA,CAAA,IAAI,CAAC,IAAI,CAACiM,qBAAqB,EAAE,EAAE;MACzD,IAAI,CAACxH,YAAY,CAAC,kBAAkB,CAAC;MACrC,IAAI,CAAC/Q,IAAI,EAAE;IACb,CAAC,MAAM;MACL,IAAI,IAAI,CAACtD,SAAS,CAAC,kBAAkB,CAAC,EAAE,OAAO,EAAE;MACjD,OAAO,IAAI;IACb;IACA,MAAM62D,KAAK,GAAG,EAAE;IAChB,MAAM32D,UAAU,GAAG,IAAI9I,GAAG,EAAE;IAC5B,GAAG;MACD,MAAMsC,IAAI,GAAG,IAAI,CAACqE,SAAS,EAAE;MAC7BrE,IAAI,CAACnf,GAAG,GAAG,IAAI,CAACqqC,eAAe,CAAC,IAAI,CAAC;MAErC,IAAIlrB,IAAI,CAACnf,GAAG,CAAC6B,IAAI,KAAK,MAAM,EAAE;QAC5B,IAAI,CAACqjB,KAAK,CAAClG,MAAM,CAACpH,gCAAgC,EAAE;UAClDhT,EAAE,EAAEua,IAAI,CAACnf;QACX,CAAC,CAAC;MACJ;MAEA,IAAI2lB,UAAU,CAAC8C,GAAG,CAACtJ,IAAI,CAACnf,GAAG,CAAC6B,IAAI,CAAC,EAAE;QACjC,IAAI,CAACqjB,KAAK,CAAClG,MAAM,CAAClH,iCAAiC,EAAE;UACnDlT,EAAE,EAAEua,IAAI,CAACnf,GAAG;UACZA,GAAG,EAAEmf,IAAI,CAACnf,GAAG,CAAC6B;QAChB,CAAC,CAAC;MACJ;MACA8jB,UAAU,CAACmI,GAAG,CAAC3O,IAAI,CAACnf,GAAG,CAAC6B,IAAI,CAAC;MAC7B,IAAI,CAAC8/B,MAAM,CAAU,EAAA,CAAA;MACrB,IAAI,CAAC,IAAI,CAACtM,KAAK,KAAW,EAAE;QAC1B,MAAM,IAAI,CAACnQ,KAAK,CAAClG,MAAM,CAACnH,2BAA2B,EAAE;UACnDjT,EAAE,EAAE,IAAI,CAACohB,KAAK,CAAC3B;QACjB,CAAC,CAAC;MACJ;MACAlF,IAAI,CAACtQ,KAAK,GAAG,IAAI,CAACyR,kBAAkB,CAAC,IAAI,CAAC0F,KAAK,CAACnX,KAAK,CAAC;MACtD,IAAI,CAAC6U,UAAU,CAACvE,IAAI,EAAE,iBAAiB,CAAC;MACxCm9D,KAAK,CAAC15E,IAAI,CAACuc,IAAI,CAAC;IAClB,CAAC,QAAQ,IAAI,CAACyY,GAAG,CAAU,EAAA,CAAA;IAE3B,OAAO0kD,KAAK;EACd;EAEAjB,0BAA0BA,CAAAA,EAAG;IAE3B,IAAI,IAAI,CAACx6C,YAAY,CAAY,EAAA,CAAA,IAAI,CAAC,IAAI,CAACS,qBAAqB,EAAE,EAAE;MAClE,IAAI,CAACxH,YAAY,CAAC,kBAAkB,CAAC;MACrC,IAAI,CAAC/Q,IAAI,EAAE;IACb,CAAC,MAAM;MACL,IAAI,IAAI,CAACtD,SAAS,CAAC,kBAAkB,CAAC,EAAE,OAAO,EAAE;MACjD,OAAO,IAAI;IACb;IAEA,IAAI,CAACmS,GAAG,CAAW,CAAA,CAAA;IACnB,MAAM0kD,KAAK,GAAG,IAAI,CAACD,kBAAkB,EAAE;IACvC,IAAI,CAACzkD,GAAG,CAAW,CAAA,CAAA;IAEnB,OAAO0kD,KAAK;EACd;EAEA9lC,gCAAgCA,CAACr3B,IAAiC,EAAW;IAC3E,IAAI,IAAI,CAAC82B,wBAAwB,CAAC92B,IAAI,CAAC,EAAE;MAEvC,IAAI,CAACi3B,yBAAyB,CAC5Bj3B,IAAI,EACJ,IAAI,CAACqE,SAAS,EAA4B,EAC1C,wBAAwB,CACzB;MACD,OAAO,IAAI;IACb;IACA,OAAO,KAAK;EACd;EAEA2mD,6BAA6BA,CAAChrD,IAAiC,EAAW;IACxE,IAAI,IAAI,CAACkW,KAAK,CAAA,EAAA,CAAS,EAAE;MACvB,MAAMghB,SAAS,GAAG,IAAI,CAAC7yB,SAAS,EAA8B;MAC9D,IAAI,CAACuF,IAAI,EAAE;MACX,IAAI,CAACqY,gBAAgB,CAAQ,EAAA,CAAA;MAE7B,IAAI,CAACgV,yBAAyB,CAC5Bj3B,IAAI,EACJk3B,SAAS,EACT,0BAA0B,CAC3B;MACD,OAAO,IAAI;IACb;IACA,OAAO,KAAK;EACd;EAEA+zB,0BAA0BA,CAACjrD,IAAiC,EAAE;IAC5D,IAAIkxB,KAAK,GAAG,IAAI;IAChB,IAAI,CAAC1O,MAAM,CAAW,CAAA,CAAA;IACtB,OAAO,CAAC,IAAI,CAAC/J,GAAG,GAAW,EAAE;MAC3B,IAAIyY,KAAK,EAAE;QACTA,KAAK,GAAG,KAAK;MACf,CAAC,MAAM;QAEL,IAAI,IAAI,CAACzY,GAAG,CAAA,EAAA,CAAU,EAAE;UACtB,MAAM,IAAI,CAAC1S,KAAK,CAAClG,MAAM,CAAC1L,sBAAsB,EAAE;YAC9C1O,EAAE,EAAE,IAAI,CAACohB,KAAK,CAAC3B;UACjB,CAAC,CAAC;QACJ;QAEA,IAAI,CAACsd,MAAM,CAAU,EAAA,CAAA;QACrB,IAAI,IAAI,CAAC/J,GAAG,CAAA,CAAA,CAAW,EAAE;MAC3B;MAEA,MAAMye,SAAS,GAAG,IAAI,CAAC7yB,SAAS,EAAqB;MACrD,MAAMkzB,gBAAgB,GAAG,IAAI,CAACrhB,KAAK,CAAW,GAAA,CAAA;MAC9C,MAAMuhB,eAAe,GAAG,IAAI,CAAC/V,YAAY,CAAU,GAAA,CAAA;MACnDwV,SAAS,CAACS,QAAQ,GAAG,IAAI,CAACuxB,qBAAqB,EAAE;MACjD,MAAMmU,eAAe,GAAG,IAAI,CAAC/lC,oBAAoB,CAC/CJ,SAAS,EACTK,gBAAgB,EAChBv3B,IAAI,CAACopB,UAAU,KAAK,MAAM,IAAIppB,IAAI,CAACopB,UAAU,KAAK,QAAQ,EAC1DqO,eAAe,EACfj4C,SAAS,CACV;MACDwgB,IAAI,CAACgH,UAAU,CAACvjB,IAAI,CAAC45E,eAAe,CAAC;IACvC;EACF;EAGA/lC,oBAAoBA,CAClBJ,SAAoC,EACpCK,gBAAyB,EAEzBC,kBAA2B,EAC3BC,eAAwB,EACxBhpB,WAAqC,EAElB;IACnB,IAAI,IAAI,CAACuT,aAAa,CAAA,EAAA,CAAQ,EAAE;MAC9BkV,SAAS,CAACC,KAAK,GAAG,IAAI,CAACjM,eAAe,EAAE;IAC1C,CAAC,MAAM;MACL,MAAM;QAAEyM;MAAU,CAAA,GAAGT,SAAS;MAC9B,IAAIK,gBAAgB,EAAE;QACpB,MAAM,IAAI,CAACxxB,KAAK,CAAClG,MAAM,CAACtK,qBAAqB,EAAE;UAC7C9P,EAAE,EAAEyxC,SAAS;UACb1hC,UAAU,EAAGmiC,QAAQ,CAAqBjoC;QAC5C,CAAC,CAAC;MACJ;MACA,IAAI,CAACqoC,iBAAiB,CACnBJ,QAAQ,CAAkBj1C,IAAI,EAC/Bw0C,SAAS,CAACr4B,GAAG,CAAClQ,KAAK,EACnB,IAAI,EACJ,IAAI,CACL;MACD,IAAI,CAACuoC,SAAS,CAACC,KAAK,EAAE;QACpBD,SAAS,CAACC,KAAK,GAAGpS,eAAe,CAAC4S,QAAQ,CAAC;MAC7C;IACF;IACA,OAAO,IAAI,CAACP,qBAAqB,CAC/BF,SAAS,EACT,iBAAiB,EACjBzoB,WAAW,CACZ;EACH;EAIA2nB,WAAWA,CACTpE,KAAuD,EAC9C;IACT,OAAOA,KAAK,CAAC3/B,IAAI,KAAK,YAAY,IAAI2/B,KAAK,CAACtvC,IAAI,KAAK,MAAM;EAC7D;AACF;ACpoGe,MAAM46E,MAAM,SAASxH,eAAe,CAAC;EAOlD70E,WAAWA,CAACL,OAAmC,EAAE6wB,KAAa,EAAE;IAC9D7wB,OAAO,GAAGH,UAAU,CAACG,OAAO,CAAC;IAC7B,KAAK,CAACA,OAAO,EAAE6wB,KAAK,CAAC;IAErB,IAAI,CAAC7wB,OAAO,GAAGA,OAAO;IACtB,IAAI,CAAC6iC,gBAAgB,EAAE;IACvB,IAAI,CAACxjC,OAAO,GAAGs9E,UAAU,CAAC,IAAI,CAAC38E,OAAO,CAACX,OAAO,CAAC;IAC/C,IAAI,CAAC4O,QAAQ,GAAGjO,OAAO,CAACrB,cAAc;EACxC;EAGAwkC,eAAeA,CAAAA,EAEb;IACA,OAAO3W,YAAY;EACrB;EAEAhN,KAAKA,CAAAA,EAAW;IACd,IAAI,CAACgkB,kBAAkB,EAAE;IACzB,MAAM/jB,IAAI,GAAG,IAAI,CAACgE,SAAS,EAAY;IACvC,MAAM81B,OAAO,GAAG,IAAI,CAAC91B,SAAS,EAAe;IAC7C,IAAI,CAACmU,SAAS,EAAE;IAChBnY,IAAI,CAACmS,MAAM,GAAG,IAAI;IAClB,IAAI,CAAC0nB,aAAa,CAAC75B,IAAI,EAAE85B,OAAO,CAAC;IACjC95B,IAAI,CAACmS,MAAM,GAAG,IAAI,CAAC3L,KAAK,CAAC2L,MAAM;IAC/B,OAAOnS,IAAI;EACb;AACF;AAEA,SAASk9D,UAAUA,CAACt9E,OAAmB,EAAc;EACnD,MAAMu9E,SAAqB,GAAG,IAAIh7E,GAAG,EAAE;EACvC,KAAK,MAAMotB,MAAM,IAAI3vB,OAAO,EAAE;IAC5B,MAAM,CAACyC,IAAI,EAAE9B,OAAO,CAAC,GAAGye,KAAK,CAACC,OAAO,CAACsQ,MAAM,CAAC,GAAGA,MAAM,GAAG,CAACA,MAAM,EAAE,CAAE,CAAA,CAAC;IACrE,IAAI,CAAC4tD,SAAS,CAACl0D,GAAG,CAAC5mB,IAAI,CAAC,EAAE86E,SAAS,CAAC56E,GAAG,CAACF,IAAI,EAAE9B,OAAO,IAAI,CAAA,CAAE,CAAC;EAC9D;EACA,OAAO48E,SAAS;AAClB;AC/BO,SAASp9D,KAAKA,CAACqR,KAAa,EAAE7wB,OAAiB,EAAQ;EAAA,IAAA68E,QAAA;EAC5D,IAAI,CAAA,CAAAA,QAAA,GAAA78E,OAAO,KAAA,IAAA,GAAA,KAAA,CAAA,GAAP68E,QAAA,CAASn+E,UAAU,MAAK,aAAa,EAAE;IACzCsB,OAAO,GAAAE,MAAA,CAAA+E,MAAA,CAAA,CAAA,CAAA,EACFjF,OAAO,CACX;IACD,IAAI;MACFA,OAAO,CAACtB,UAAU,GAAG,QAAQ;MAC7B,MAAM+tB,MAAM,GAAGqwD,SAAS,CAAC98E,OAAO,EAAE6wB,KAAK,CAAC;MACxC,MAAMksD,GAAG,GAAGtwD,MAAM,CAACjN,KAAK,EAAE;MAE1B,IAAIiN,MAAM,CAACiC,iBAAiB,EAAE;QAC5B,OAAOquD,GAAG;MACZ;MAEA,IAAItwD,MAAM,CAACkC,2BAA2B,EAAE;QAMtC,IAAI;UACF3uB,OAAO,CAACtB,UAAU,GAAG,QAAQ;UAC7B,OAAOo+E,SAAS,CAAC98E,OAAO,EAAE6wB,KAAK,CAAC,CAACrR,KAAK,EAAE;QAC1C,CAAC,CAAC,OAAAY,OAAA,EAAM,CAAC;MACX,CAAC,MAAM;QAGL28D,GAAG,CAACxjC,OAAO,CAAC76C,UAAU,GAAG,QAAQ;MACnC;MAEA,OAAOq+E,GAAG;IACX,CAAA,CAAC,OAAOC,WAAW,EAAE;MACpB,IAAI;QACFh9E,OAAO,CAACtB,UAAU,GAAG,QAAQ;QAC7B,OAAOo+E,SAAS,CAAC98E,OAAO,EAAE6wB,KAAK,CAAC,CAACrR,KAAK,EAAE;MAC1C,CAAC,CAAC,OAAAs/C,QAAA,EAAM,CAAC;MAET,MAAMke,WAAW;IACnB;EACF,CAAC,MAAM;IACL,OAAOF,SAAS,CAAC98E,OAAO,EAAE6wB,KAAK,CAAC,CAACrR,KAAK,EAAE;EAC1C;AACF;AAEO,SAASwqB,eAAeA,CAACnZ,KAAa,EAAE7wB,OAAiB,EAAc;EAC5E,MAAMysB,MAAM,GAAGqwD,SAAS,CAAC98E,OAAO,EAAE6wB,KAAK,CAAC;EACxC,IAAIpE,MAAM,CAACzsB,OAAO,CAACV,UAAU,EAAE;IAC7BmtB,MAAM,CAACxG,KAAK,CAACiC,MAAM,GAAG,IAAI;EAC5B;EACA,OAAOuE,MAAM,CAAC86C,aAAa,EAAE;AAC/B;AAEA,SAAS0V,0BAA0BA,CACjCC,kBAAsC,EACH;EACnC,MAAM/6E,UAA6C,GAAG,CAAA,CAAE;EACxD,KAAK,MAAM82D,QAAQ,IAAI/4D,MAAM,CAACC,IAAI,CAChC+8E,kBAAkB,CACnB,EAAkC;IACjC/6E,UAAU,CAAC82D,QAAQ,CAAC,GAAG7rD,gBAAgB,CAAC8vE,kBAAkB,CAACjkB,QAAQ,CAAC,CAAC;EACvE;EACA,OAAO92D,UAAU;AACnB;MAEag7E,QAAQ,GAAGF,0BAA0B,CAACC,EAAkB,CAAC;AAEtE,SAASJ,SAASA,CAAC98E,OAAmC,EAAE6wB,KAAa,EAAU;EAC7E,IAAI2zC,GAAG,GAAGkY,MAAM;EAChB,IAAI18E,OAAO,IAAA,IAAA,IAAPA,OAAO,CAAEX,OAAO,EAAE;IACpBksE,eAAe,CAACvrE,OAAO,CAACX,OAAO,CAAC;IAChCmlE,GAAG,GAAG4Y,cAAc,CAACp9E,OAAO,CAACX,OAAO,CAAC;EACvC;EAEA,OAAO,IAAImlE,GAAG,CAACxkE,OAAO,EAAE6wB,KAAK,CAAC;AAChC;AAEA,MAAMwsD,gBAAmE,GAAG,CAAA,CAAE;AAG9E,SAASD,cAAcA,CAACE,kBAA8B,EAEpD;EACA,MAAMC,UAAU,GAAGtR,gBAAgB,CAAC58D,MAAM,CAACvN,IAAI,IAC7C4jB,SAAS,CAAC43D,kBAAkB,EAAEx7E,IAAI,CAAC,CACpC;EAED,MAAM7B,GAAG,GAAGs9E,UAAU,CAAC9lE,IAAI,CAAC,GAAG,CAAC;EAChC,IAAI+sD,GAAG,GAAG6Y,gBAAgB,CAACp9E,GAAG,CAAC;EAC/B,IAAI,CAACukE,GAAG,EAAE;IACRA,GAAG,GAAGkY,MAAM;IACZ,KAAK,MAAM1tD,MAAM,IAAIuuD,UAAU,EAAE;MAE/B/Y,GAAG,GAAGwH,YAAY,CAACh9C,MAAM,CAAC,CAACw1C,GAAG,CAAC;IACjC;IACA6Y,gBAAgB,CAACp9E,GAAG,CAAC,GAAGukE,GAAG;EAC7B;EACA,OAAOA,GAAG;AACZ;;;&quot;</span><span class="s0">}</span></pre>
</body>
</html>