<html>
<head>
<title>runtime-core.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #808080;}
.s5 { color: #629755; font-weight: bold; font-style: italic;}
.s6 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
runtime-core.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">{ camelize } from </span><span class="s2">'@vue/shared'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ capitalize } from </span><span class="s2">'@vue/shared'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ ComponentPropsOptions as ComponentPropsOptions_2 } from </span><span class="s2">'@vue/runtime-core'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ computed as computed_2 } from </span><span class="s2">'@vue/reactivity'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ ComputedGetter } from </span><span class="s2">'@vue/reactivity'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ ComputedRef } from </span><span class="s2">'@vue/reactivity'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ ComputedSetter } from </span><span class="s2">'@vue/reactivity'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ customRef } from </span><span class="s2">'@vue/reactivity'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ CustomRefFactory } from </span><span class="s2">'@vue/reactivity'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ DebuggerEvent } from </span><span class="s2">'@vue/reactivity'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ DebuggerEventExtraInfo } from </span><span class="s2">'@vue/reactivity'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ DebuggerOptions } from </span><span class="s2">'@vue/reactivity'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ DeepReadonly } from </span><span class="s2">'@vue/reactivity'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ effect } from </span><span class="s2">'@vue/reactivity'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ EffectScheduler } from </span><span class="s2">'@vue/reactivity'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ EffectScope } from </span><span class="s2">'@vue/reactivity'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ effectScope } from </span><span class="s2">'@vue/reactivity'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ getCurrentScope } from </span><span class="s2">'@vue/reactivity'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ IfAny } from </span><span class="s2">'@vue/shared'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ isProxy } from </span><span class="s2">'@vue/reactivity'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ isReactive } from </span><span class="s2">'@vue/reactivity'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ isReadonly } from </span><span class="s2">'@vue/reactivity'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ isRef } from </span><span class="s2">'@vue/reactivity'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ isShallow } from </span><span class="s2">'@vue/reactivity'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ LooseRequired } from </span><span class="s2">'@vue/shared'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ markRaw } from </span><span class="s2">'@vue/reactivity'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ normalizeClass } from </span><span class="s2">'@vue/shared'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ normalizeProps } from </span><span class="s2">'@vue/shared'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ normalizeStyle } from </span><span class="s2">'@vue/shared'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ onScopeDispose } from </span><span class="s2">'@vue/reactivity'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ proxyRefs } from </span><span class="s2">'@vue/reactivity'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ Raw } from </span><span class="s2">'@vue/reactivity'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ reactive } from </span><span class="s2">'@vue/reactivity'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ ReactiveEffect } from </span><span class="s2">'@vue/reactivity'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ ReactiveEffectOptions } from </span><span class="s2">'@vue/reactivity'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ ReactiveEffectRunner } from </span><span class="s2">'@vue/reactivity'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ ReactiveFlags } from </span><span class="s2">'@vue/reactivity'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ readonly } from </span><span class="s2">'@vue/reactivity'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ Ref } from </span><span class="s2">'@vue/reactivity'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ ref } from </span><span class="s2">'@vue/reactivity'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ ShallowReactive } from </span><span class="s2">'@vue/reactivity'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ shallowReactive } from </span><span class="s2">'@vue/reactivity'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ shallowReadonly } from </span><span class="s2">'@vue/reactivity'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ ShallowRef } from </span><span class="s2">'@vue/reactivity'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ shallowRef } from </span><span class="s2">'@vue/reactivity'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ ShallowUnwrapRef } from </span><span class="s2">'@vue/reactivity'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ ShapeFlags } from </span><span class="s2">'@vue/shared'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ SlotFlags } from </span><span class="s2">'@vue/shared'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ stop as stop_2 } from </span><span class="s2">'@vue/reactivity'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ toDisplayString } from </span><span class="s2">'@vue/shared'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ toHandlerKey } from </span><span class="s2">'@vue/shared'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ toRaw } from </span><span class="s2">'@vue/reactivity'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ ToRef } from </span><span class="s2">'@vue/reactivity'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ toRef } from </span><span class="s2">'@vue/reactivity'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ ToRefs } from </span><span class="s2">'@vue/reactivity'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ toRefs } from </span><span class="s2">'@vue/reactivity'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ TrackOpTypes } from </span><span class="s2">'@vue/reactivity'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ TriggerOpTypes } from </span><span class="s2">'@vue/reactivity'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ triggerRef } from </span><span class="s2">'@vue/reactivity'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ UnionToIntersection } from </span><span class="s2">'@vue/shared'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ unref } from </span><span class="s2">'@vue/reactivity'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ UnwrapNestedRefs } from </span><span class="s2">'@vue/reactivity'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ UnwrapRef } from </span><span class="s2">'@vue/reactivity'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ WritableComputedOptions } from </span><span class="s2">'@vue/reactivity'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ WritableComputedRef } from </span><span class="s2">'@vue/reactivity'</span><span class="s0">;</span>

<span class="s3">/**</span>
 <span class="s3">* Default allowed non-declared props on component in TSX</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">interface </span><span class="s1">AllowedComponentProps {</span>
    <span class="s0">class</span><span class="s1">?: unknown</span><span class="s0">;</span>
    <span class="s1">style?: unknown</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">interface </span><span class="s1">App&lt;HostElement = any&gt; {</span>
    <span class="s1">version: string</span><span class="s0">;</span>
    <span class="s1">config: AppConfig</span><span class="s0">;</span>
    <span class="s1">use&lt;Options </span><span class="s0">extends </span><span class="s1">unknown[]&gt;(plugin: Plugin_2&lt;Options&gt;</span><span class="s0">, </span><span class="s1">...options: Options): </span><span class="s0">this;</span>
    <span class="s1">use&lt;Options&gt;(plugin: Plugin_2&lt;Options&gt;</span><span class="s0">, </span><span class="s1">options: Options): </span><span class="s0">this;</span>
    <span class="s1">mixin(mixin: ComponentOptions): </span><span class="s0">this;</span>
    <span class="s1">component(name: string): Component | undefined</span><span class="s0">;</span>
    <span class="s1">component(name: string</span><span class="s0">, </span><span class="s1">component: Component): </span><span class="s0">this;</span>
    <span class="s1">directive(name: string): Directive | undefined</span><span class="s0">;</span>
    <span class="s1">directive(name: string</span><span class="s0">, </span><span class="s1">directive: Directive): </span><span class="s0">this;</span>
    <span class="s1">mount(rootContainer: HostElement | string</span><span class="s0">, </span><span class="s1">isHydrate?: boolean</span><span class="s0">, </span><span class="s1">isSVG?: boolean): ComponentPublicInstance</span><span class="s0">;</span>
    <span class="s1">unmount(): </span><span class="s0">void;</span>
    <span class="s1">provide&lt;T&gt;(key: InjectionKey&lt;T&gt; | string</span><span class="s0">, </span><span class="s1">value: T): </span><span class="s0">this;</span>
    <span class="s1">_uid: number</span><span class="s0">;</span>
    <span class="s1">_component: ConcreteComponent</span><span class="s0">;</span>
    <span class="s1">_props: Data | </span><span class="s0">null;</span>
    <span class="s1">_container: HostElement | </span><span class="s0">null;</span>
    <span class="s1">_context: AppContext</span><span class="s0">;</span>
    <span class="s1">_instance: ComponentInternalInstance | </span><span class="s0">null;</span>
    <span class="s3">/**</span>
     <span class="s3">* v2 compat only</span>
     <span class="s3">*/</span>
    <span class="s1">filter?(name: string): Function | undefined</span><span class="s0">;</span>
    <span class="s1">filter?(name: string</span><span class="s0">, </span><span class="s1">filter: Function): </span><span class="s0">this;</span>
    <span class="s4">/* Excluded from this release type: _createRoot */</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">interface </span><span class="s1">AppConfig {</span>
    <span class="s1">readonly isNativeTag?: (tag: string) =&gt; boolean</span><span class="s0">;</span>
    <span class="s1">performance: boolean</span><span class="s0">;</span>
    <span class="s1">optionMergeStrategies: Record&lt;string</span><span class="s0">, </span><span class="s1">OptionMergeFunction&gt;</span><span class="s0">;</span>
    <span class="s1">globalProperties: ComponentCustomProperties &amp; Record&lt;string</span><span class="s0">, </span><span class="s1">any&gt;</span><span class="s0">;</span>
    <span class="s1">errorHandler?: (err: unknown</span><span class="s0">, </span><span class="s1">instance: ComponentPublicInstance | </span><span class="s0">null, </span><span class="s1">info: string) =&gt; </span><span class="s0">void;</span>
    <span class="s1">warnHandler?: (msg: string</span><span class="s0">, </span><span class="s1">instance: ComponentPublicInstance | </span><span class="s0">null, </span><span class="s1">trace: string) =&gt; </span><span class="s0">void;</span>
    <span class="s3">/**</span>
     <span class="s3">* Options to pass to `@vue/compiler-dom`.</span>
     <span class="s3">* Only supported in runtime compiler build.</span>
     <span class="s3">*/</span>
    <span class="s1">compilerOptions: RuntimeCompilerOptions</span><span class="s0">;</span>
    <span class="s3">/**</span>
     <span class="s3">* </span><span class="s5">@deprecated </span><span class="s3">use config.compilerOptions.isCustomElement</span>
     <span class="s3">*/</span>
    <span class="s1">isCustomElement?: (tag: string) =&gt; boolean</span><span class="s0">;</span>
    <span class="s3">/**</span>
     <span class="s3">* Temporary config for opt-in to unwrap injected refs.</span>
     <span class="s3">* TODO deprecate in 3.3</span>
     <span class="s3">*/</span>
    <span class="s1">unwrapInjectedRef?: boolean</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">interface </span><span class="s1">AppContext {</span>
    <span class="s1">app: App</span><span class="s0">;</span>
    <span class="s1">config: AppConfig</span><span class="s0">;</span>
    <span class="s1">mixins: ComponentOptions[]</span><span class="s0">;</span>
    <span class="s1">components: Record&lt;string</span><span class="s0">, </span><span class="s1">Component&gt;</span><span class="s0">;</span>
    <span class="s1">directives: Record&lt;string</span><span class="s0">, </span><span class="s1">Directive&gt;</span><span class="s0">;</span>
    <span class="s1">provides: Record&lt;string | symbol</span><span class="s0">, </span><span class="s1">any&gt;</span><span class="s0">;</span>
    <span class="s4">/* Excluded from this release type: optionsCache */</span>
    <span class="s4">/* Excluded from this release type: propsCache */</span>
    <span class="s4">/* Excluded from this release type: emitsCache */</span>
    <span class="s4">/* Excluded from this release type: reload */</span>
    <span class="s4">/* Excluded from this release type: filters */</span>
<span class="s1">}</span>

<span class="s1">declare </span><span class="s0">interface </span><span class="s1">AppRecord {</span>
    <span class="s1">id: number</span><span class="s0">;</span>
    <span class="s1">app: App</span><span class="s0">;</span>
    <span class="s1">version: string</span><span class="s0">;</span>
    <span class="s1">types: Record&lt;string</span><span class="s0">, </span><span class="s1">string | Symbol&gt;</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s4">/* Excluded from this release type: assertNumber */</span>

<span class="s0">export </span><span class="s1">declare type AsyncComponentLoader&lt;T = any&gt; = () =&gt; Promise&lt;AsyncComponentResolveResult&lt;T&gt;&gt;</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">interface </span><span class="s1">AsyncComponentOptions&lt;T = any&gt; {</span>
    <span class="s1">loader: AsyncComponentLoader&lt;T&gt;</span><span class="s0">;</span>
    <span class="s1">loadingComponent?: Component</span><span class="s0">;</span>
    <span class="s1">errorComponent?: Component</span><span class="s0">;</span>
    <span class="s1">delay?: number</span><span class="s0">;</span>
    <span class="s1">timeout?: number</span><span class="s0">;</span>
    <span class="s1">suspensible?: boolean</span><span class="s0">;</span>
    <span class="s1">onError?: (error: Error</span><span class="s0">, </span><span class="s1">retry: () =&gt; </span><span class="s0">void, </span><span class="s1">fail: () =&gt; </span><span class="s0">void, </span><span class="s1">attempts: number) =&gt; any</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s1">declare type AsyncComponentResolveResult&lt;T = Component&gt; = T | {</span>
    <span class="s0">default</span><span class="s1">: T</span><span class="s0">;</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">const </span><span class="s1">BaseTransition: </span><span class="s0">new </span><span class="s1">() =&gt; {</span>
    <span class="s1">$props: BaseTransitionProps&lt;any&gt;</span><span class="s0">;</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">interface </span><span class="s1">BaseTransitionProps&lt;HostElement = RendererElement&gt; {</span>
    <span class="s1">mode?: </span><span class="s2">'in-out' </span><span class="s1">| </span><span class="s2">'out-in' </span><span class="s1">| </span><span class="s2">'default'</span><span class="s0">;</span>
    <span class="s1">appear?: boolean</span><span class="s0">;</span>
    <span class="s1">persisted?: boolean</span><span class="s0">;</span>
    <span class="s1">onBeforeEnter?: Hook&lt;(el: HostElement) =&gt; </span><span class="s0">void</span><span class="s1">&gt;</span><span class="s0">;</span>
    <span class="s1">onEnter?: Hook&lt;(el: HostElement</span><span class="s0">, </span><span class="s1">done: () =&gt; </span><span class="s0">void</span><span class="s1">) =&gt; </span><span class="s0">void</span><span class="s1">&gt;</span><span class="s0">;</span>
    <span class="s1">onAfterEnter?: Hook&lt;(el: HostElement) =&gt; </span><span class="s0">void</span><span class="s1">&gt;</span><span class="s0">;</span>
    <span class="s1">onEnterCancelled?: Hook&lt;(el: HostElement) =&gt; </span><span class="s0">void</span><span class="s1">&gt;</span><span class="s0">;</span>
    <span class="s1">onBeforeLeave?: Hook&lt;(el: HostElement) =&gt; </span><span class="s0">void</span><span class="s1">&gt;</span><span class="s0">;</span>
    <span class="s1">onLeave?: Hook&lt;(el: HostElement</span><span class="s0">, </span><span class="s1">done: () =&gt; </span><span class="s0">void</span><span class="s1">) =&gt; </span><span class="s0">void</span><span class="s1">&gt;</span><span class="s0">;</span>
    <span class="s1">onAfterLeave?: Hook&lt;(el: HostElement) =&gt; </span><span class="s0">void</span><span class="s1">&gt;</span><span class="s0">;</span>
    <span class="s1">onLeaveCancelled?: Hook&lt;(el: HostElement) =&gt; </span><span class="s0">void</span><span class="s1">&gt;</span><span class="s0">;</span>
    <span class="s1">onBeforeAppear?: Hook&lt;(el: HostElement) =&gt; </span><span class="s0">void</span><span class="s1">&gt;</span><span class="s0">;</span>
    <span class="s1">onAppear?: Hook&lt;(el: HostElement</span><span class="s0">, </span><span class="s1">done: () =&gt; </span><span class="s0">void</span><span class="s1">) =&gt; </span><span class="s0">void</span><span class="s1">&gt;</span><span class="s0">;</span>
    <span class="s1">onAfterAppear?: Hook&lt;(el: HostElement) =&gt; </span><span class="s0">void</span><span class="s1">&gt;</span><span class="s0">;</span>
    <span class="s1">onAppearCancelled?: Hook&lt;(el: HostElement) =&gt; </span><span class="s0">void</span><span class="s1">&gt;</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s1">declare </span><span class="s0">const enum </span><span class="s1">BooleanFlags {</span>
    <span class="s1">shouldCast = </span><span class="s6">0</span><span class="s0">,</span>
    <span class="s1">shouldCastTrue = </span><span class="s6">1</span>
<span class="s1">}</span>

<span class="s1">declare type BooleanKey&lt;T</span><span class="s0">, </span><span class="s1">K </span><span class="s0">extends </span><span class="s1">keyof T = keyof T&gt; = K </span><span class="s0">extends </span><span class="s1">any ? [T[K]] </span><span class="s0">extends </span><span class="s1">[boolean | undefined] ? K : never : never</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">callWithAsyncErrorHandling(fn: Function | Function[]</span><span class="s0">, </span><span class="s1">instance: ComponentInternalInstance | </span><span class="s0">null, </span><span class="s1">type: ErrorTypes</span><span class="s0">, </span><span class="s1">args?: unknown[]): any[]</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">callWithErrorHandling(fn: Function</span><span class="s0">, </span><span class="s1">instance: ComponentInternalInstance | </span><span class="s0">null, </span><span class="s1">type: ErrorTypes</span><span class="s0">, </span><span class="s1">args?: unknown[]): any</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">{ camelize }</span>

<span class="s0">export </span><span class="s1">{ capitalize }</span>

<span class="s3">/**</span>
 <span class="s3">* Use this for features with the same syntax but with mutually exclusive</span>
 <span class="s3">* behavior in 2 vs 3. Only warn if compat is enabled.</span>
 <span class="s3">* e.g. render function</span>
 <span class="s3">*/</span>
<span class="s1">declare </span><span class="s0">function </span><span class="s1">checkCompatEnabled(key: DeprecationTypes</span><span class="s0">, </span><span class="s1">instance: ComponentInternalInstance | </span><span class="s0">null, </span><span class="s1">...args: any[]): boolean</span><span class="s0">;</span>

<span class="s1">declare </span><span class="s0">interface </span><span class="s1">ClassComponent {</span>
    <span class="s0">new </span><span class="s1">(...args: any[]): ComponentPublicInstance&lt;any</span><span class="s0">, </span><span class="s1">any</span><span class="s0">, </span><span class="s1">any</span><span class="s0">, </span><span class="s1">any</span><span class="s0">, </span><span class="s1">any&gt;</span><span class="s0">;</span>
    <span class="s1">__vccOpts: ComponentOptions</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">cloneVNode&lt;T</span><span class="s0">, </span><span class="s1">U&gt;(vnode: VNode&lt;T</span><span class="s0">, </span><span class="s1">U&gt;</span><span class="s0">, </span><span class="s1">extraProps?: (Data &amp; VNodeProps) | </span><span class="s0">null, </span><span class="s1">mergeRef?: boolean): VNode&lt;T</span><span class="s0">, </span><span class="s1">U&gt;</span><span class="s0">;</span>

<span class="s1">declare </span><span class="s0">const </span><span class="s1">Comment_2: unique symbol</span><span class="s0">;</span>
<span class="s0">export </span><span class="s1">{ Comment_2 as Comment }</span>

<span class="s1">declare type CompatConfig = Partial&lt;Record&lt;DeprecationTypes</span><span class="s0">, </span><span class="s1">boolean | </span><span class="s2">'suppress-warning'</span><span class="s1">&gt;&gt; &amp; {</span>
    <span class="s1">MODE?: </span><span class="s6">2 </span><span class="s1">| </span><span class="s6">3 </span><span class="s1">| ((comp: Component | </span><span class="s0">null</span><span class="s1">) =&gt; </span><span class="s6">2 </span><span class="s1">| </span><span class="s6">3</span><span class="s1">)</span><span class="s0">;</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s4">/* Excluded from this release type: compatUtils */</span>

<span class="s3">/**</span>
 <span class="s3">* </span><span class="s5">@deprecated </span><span class="s3">the default `Vue` export has been removed in Vue 3. The type for</span>
 <span class="s3">* the default export is provided only for migration purposes. Please use</span>
 <span class="s3">* named imports instead - e.g. `import { createApp } from 'vue'`.</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare type CompatVue = Pick&lt;App</span><span class="s0">, </span><span class="s2">'version' </span><span class="s1">| </span><span class="s2">'component' </span><span class="s1">| </span><span class="s2">'directive'</span><span class="s1">&gt; &amp; {</span>
    <span class="s1">configureCompat: </span><span class="s0">typeof </span><span class="s1">configureCompat</span><span class="s0">;</span>
    <span class="s0">new </span><span class="s1">(options?: ComponentOptions): LegacyPublicInstance</span><span class="s0">;</span>
    <span class="s1">version: string</span><span class="s0">;</span>
    <span class="s1">config: AppConfig &amp; LegacyConfig</span><span class="s0">;</span>
    <span class="s1">nextTick: </span><span class="s0">typeof </span><span class="s1">nextTick</span><span class="s0">;</span>
    <span class="s1">use(plugin: Plugin_2</span><span class="s0">, </span><span class="s1">...options: any[]): CompatVue</span><span class="s0">;</span>
    <span class="s1">mixin(mixin: ComponentOptions): CompatVue</span><span class="s0">;</span>
    <span class="s1">component(name: string): Component | undefined</span><span class="s0">;</span>
    <span class="s1">component(name: string</span><span class="s0">, </span><span class="s1">component: Component): CompatVue</span><span class="s0">;</span>
    <span class="s1">directive(name: string): Directive | undefined</span><span class="s0">;</span>
    <span class="s1">directive(name: string</span><span class="s0">, </span><span class="s1">directive: Directive): CompatVue</span><span class="s0">;</span>
    <span class="s1">compile(template: string): RenderFunction</span><span class="s0">;</span>
    <span class="s3">/**</span>
     <span class="s3">* </span><span class="s5">@deprecated </span><span class="s3">Vue 3 no longer supports extending constructors.</span>
     <span class="s3">*/</span>
    <span class="s1">extend: (options?: ComponentOptions) =&gt; CompatVue</span><span class="s0">;</span>
    <span class="s3">/**</span>
     <span class="s3">* </span><span class="s5">@deprecated </span><span class="s3">Vue 3 no longer needs set() for adding new properties.</span>
     <span class="s3">*/</span>
    <span class="s1">set(target: any</span><span class="s0">, </span><span class="s1">key: string | number | symbol</span><span class="s0">, </span><span class="s1">value: any): </span><span class="s0">void;</span>
    <span class="s3">/**</span>
     <span class="s3">* </span><span class="s5">@deprecated </span><span class="s3">Vue 3 no longer needs delete() for property deletions.</span>
     <span class="s3">*/</span>
    <span class="s0">delete</span><span class="s1">(target: any</span><span class="s0">, </span><span class="s1">key: string | number | symbol): </span><span class="s0">void;</span>
    <span class="s3">/**</span>
     <span class="s3">* </span><span class="s5">@deprecated </span><span class="s3">use `reactive` instead.</span>
     <span class="s3">*/</span>
    <span class="s1">observable: </span><span class="s0">typeof </span><span class="s1">reactive</span><span class="s0">;</span>
    <span class="s3">/**</span>
     <span class="s3">* </span><span class="s5">@deprecated </span><span class="s3">filters have been removed from Vue 3.</span>
     <span class="s3">*/</span>
    <span class="s1">filter(name: string</span><span class="s0">, </span><span class="s1">arg?: any): </span><span class="s0">null;</span>
    <span class="s4">/* Excluded from this release type: cid */</span>
    <span class="s4">/* Excluded from this release type: options */</span>
    <span class="s4">/* Excluded from this release type: util */</span>
    <span class="s4">/* Excluded from this release type: super */</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s1">declare </span><span class="s0">interface </span><span class="s1">CompiledSlotDescriptor {</span>
    <span class="s1">name: string</span><span class="s0">;</span>
    <span class="s1">fn: SSRSlot</span><span class="s0">;</span>
    <span class="s1">key?: string</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* A type used in public APIs where a component type is expected.</span>
 <span class="s3">* The constructor type is an artificial type returned by defineComponent().</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare type Component&lt;Props = any</span><span class="s0">, </span><span class="s1">RawBindings = any</span><span class="s0">, </span><span class="s1">D = any</span><span class="s0">, </span><span class="s1">C </span><span class="s0">extends </span><span class="s1">ComputedOptions = ComputedOptions</span><span class="s0">, </span><span class="s1">M </span><span class="s0">extends </span><span class="s1">MethodOptions = MethodOptions&gt; = ConcreteComponent&lt;Props</span><span class="s0">, </span><span class="s1">RawBindings</span><span class="s0">, </span><span class="s1">D</span><span class="s0">, </span><span class="s1">C</span><span class="s0">, </span><span class="s1">M&gt; | ComponentPublicInstanceConstructor&lt;Props&gt;</span><span class="s0">;</span>

<span class="s3">/**</span>
 <span class="s3">* Interface for declaring custom options.</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s5">@example</span>
 <span class="s3">* ```ts</span>
 <span class="s3">* declare module '@vue/runtime-core' {</span>
 <span class="s3">*   interface ComponentCustomOptions {</span>
 <span class="s3">*     beforeRouteUpdate?(</span>
 <span class="s3">*       to: Route,</span>
 <span class="s3">*       from: Route,</span>
 <span class="s3">*       next: () =&gt; void</span>
 <span class="s3">*     ): void</span>
 <span class="s3">*   }</span>
 <span class="s3">* }</span>
 <span class="s3">* ```</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">interface </span><span class="s1">ComponentCustomOptions {</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Custom properties added to component instances in any way and can be accessed through `this`</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s5">@example</span>
 <span class="s3">* Here is an example of adding a property `$router` to every component instance:</span>
 <span class="s3">* ```ts</span>
 <span class="s3">* import { createApp } from 'vue'</span>
 <span class="s3">* import { Router, createRouter } from 'vue-router'</span>
 <span class="s3">*</span>
 <span class="s3">* declare module '@vue/runtime-core' {</span>
 <span class="s3">*   interface ComponentCustomProperties {</span>
 <span class="s3">*     $router: Router</span>
 <span class="s3">*   }</span>
 <span class="s3">* }</span>
 <span class="s3">*</span>
 <span class="s3">* // effectively adding the router to every component instance</span>
 <span class="s3">* const app = createApp({})</span>
 <span class="s3">* const router = createRouter()</span>
 <span class="s3">* app.config.globalProperties.$router = router</span>
 <span class="s3">*</span>
 <span class="s3">* const vm = app.mount('#app')</span>
 <span class="s3">* // we can access the router from the instance</span>
 <span class="s3">* vm.$router.push('/')</span>
 <span class="s3">* ```</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">interface </span><span class="s1">ComponentCustomProperties {</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* For extending allowed non-declared props on components in TSX</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">interface </span><span class="s1">ComponentCustomProps {</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">declare type ComponentInjectOptions = string[] | ObjectInjectOptions</span><span class="s0">;</span>

<span class="s3">/**</span>
 <span class="s3">* We expose a subset of properties on the internal instance as they are</span>
 <span class="s3">* useful for advanced external libraries and tools.</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">interface </span><span class="s1">ComponentInternalInstance {</span>
    <span class="s1">uid: number</span><span class="s0">;</span>
    <span class="s1">type: ConcreteComponent</span><span class="s0">;</span>
    <span class="s1">parent: ComponentInternalInstance | </span><span class="s0">null;</span>
    <span class="s1">root: ComponentInternalInstance</span><span class="s0">;</span>
    <span class="s1">appContext: AppContext</span><span class="s0">;</span>
    <span class="s3">/**</span>
     <span class="s3">* Vnode representing this component in its parent's vdom tree</span>
     <span class="s3">*/</span>
    <span class="s1">vnode: VNode</span><span class="s0">;</span>
    <span class="s4">/* Excluded from this release type: next */</span>
    <span class="s3">/**</span>
     <span class="s3">* Root vnode of this component's own vdom tree</span>
     <span class="s3">*/</span>
    <span class="s1">subTree: VNode</span><span class="s0">;</span>
    <span class="s3">/**</span>
     <span class="s3">* Render effect instance</span>
     <span class="s3">*/</span>
    <span class="s1">effect: ReactiveEffect</span><span class="s0">;</span>
    <span class="s3">/**</span>
     <span class="s3">* Bound effect runner to be passed to schedulers</span>
     <span class="s3">*/</span>
    <span class="s1">update: SchedulerJob</span><span class="s0">;</span>
    <span class="s4">/* Excluded from this release type: render */</span>
    <span class="s4">/* Excluded from this release type: ssrRender */</span>
    <span class="s4">/* Excluded from this release type: provides */</span>
    <span class="s4">/* Excluded from this release type: scope */</span>
    <span class="s4">/* Excluded from this release type: accessCache */</span>
    <span class="s4">/* Excluded from this release type: renderCache */</span>
    <span class="s4">/* Excluded from this release type: components */</span>
    <span class="s4">/* Excluded from this release type: directives */</span>
    <span class="s4">/* Excluded from this release type: filters */</span>
    <span class="s4">/* Excluded from this release type: propsOptions */</span>
    <span class="s4">/* Excluded from this release type: emitsOptions */</span>
    <span class="s4">/* Excluded from this release type: inheritAttrs */</span>
    <span class="s4">/* Excluded from this release type: isCE */</span>
    <span class="s4">/* Excluded from this release type: ceReload */</span>
    <span class="s1">proxy: ComponentPublicInstance | </span><span class="s0">null;</span>
    <span class="s1">exposed: Record&lt;string</span><span class="s0">, </span><span class="s1">any&gt; | </span><span class="s0">null;</span>
    <span class="s1">exposeProxy: Record&lt;string</span><span class="s0">, </span><span class="s1">any&gt; | </span><span class="s0">null;</span>
    <span class="s4">/* Excluded from this release type: withProxy */</span>
    <span class="s4">/* Excluded from this release type: ctx */</span>
    <span class="s1">data: Data</span><span class="s0">;</span>
    <span class="s1">props: Data</span><span class="s0">;</span>
    <span class="s1">attrs: Data</span><span class="s0">;</span>
    <span class="s1">slots: InternalSlots</span><span class="s0">;</span>
    <span class="s1">refs: Data</span><span class="s0">;</span>
    <span class="s1">emit: EmitFn</span><span class="s0">;</span>
    <span class="s4">/* Excluded from this release type: emitted */</span>
    <span class="s4">/* Excluded from this release type: propsDefaults */</span>
    <span class="s4">/* Excluded from this release type: setupState */</span>
    <span class="s4">/* Excluded from this release type: devtoolsRawSetupState */</span>
    <span class="s4">/* Excluded from this release type: setupContext */</span>
    <span class="s4">/* Excluded from this release type: suspense */</span>
    <span class="s4">/* Excluded from this release type: suspenseId */</span>
    <span class="s4">/* Excluded from this release type: asyncDep */</span>
    <span class="s4">/* Excluded from this release type: asyncResolved */</span>
    <span class="s1">isMounted: boolean</span><span class="s0">;</span>
    <span class="s1">isUnmounted: boolean</span><span class="s0">;</span>
    <span class="s1">isDeactivated: boolean</span><span class="s0">;</span>
    <span class="s4">/* Excluded from this release type: bc */</span>
    <span class="s4">/* Excluded from this release type: c */</span>
    <span class="s4">/* Excluded from this release type: bm */</span>
    <span class="s4">/* Excluded from this release type: m */</span>
    <span class="s4">/* Excluded from this release type: bu */</span>
    <span class="s4">/* Excluded from this release type: u */</span>
    <span class="s4">/* Excluded from this release type: bum */</span>
    <span class="s4">/* Excluded from this release type: um */</span>
    <span class="s4">/* Excluded from this release type: rtc */</span>
    <span class="s4">/* Excluded from this release type: rtg */</span>
    <span class="s4">/* Excluded from this release type: a */</span>
    <span class="s4">/* Excluded from this release type: da */</span>
    <span class="s4">/* Excluded from this release type: ec */</span>
    <span class="s4">/* Excluded from this release type: sp */</span>
    <span class="s4">/* Excluded from this release type: f */</span>
    <span class="s4">/* Excluded from this release type: n */</span>
    <span class="s4">/* Excluded from this release type: ut */</span>
<span class="s1">}</span>

<span class="s1">declare </span><span class="s0">interface </span><span class="s1">ComponentInternalOptions {</span>
    <span class="s4">/* Excluded from this release type: __scopeId */</span>
    <span class="s4">/* Excluded from this release type: __cssModules */</span>
    <span class="s4">/* Excluded from this release type: __hmrId */</span>
    <span class="s3">/**</span>
     <span class="s3">* Compat build only, for bailing out of certain compatibility behavior</span>
     <span class="s3">*/</span>
    <span class="s1">__isBuiltIn?: boolean</span><span class="s0">;</span>
    <span class="s3">/**</span>
     <span class="s3">* This one should be exposed so that devtools can make use of it</span>
     <span class="s3">*/</span>
    <span class="s1">__file?: string</span><span class="s0">;</span>
    <span class="s3">/**</span>
     <span class="s3">* name inferred from filename</span>
     <span class="s3">*/</span>
    <span class="s1">__name?: string</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">declare type ComponentObjectPropsOptions&lt;P = Data&gt; = {</span>
    <span class="s1">[K </span><span class="s0">in </span><span class="s1">keyof P]: Prop&lt;P[K]&gt; | </span><span class="s0">null;</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare type ComponentOptions&lt;Props = {}</span><span class="s0">, </span><span class="s1">RawBindings = any</span><span class="s0">, </span><span class="s1">D = any</span><span class="s0">, </span><span class="s1">C </span><span class="s0">extends </span><span class="s1">ComputedOptions = any</span><span class="s0">, </span><span class="s1">M </span><span class="s0">extends </span><span class="s1">MethodOptions = any</span><span class="s0">, </span><span class="s1">Mixin </span><span class="s0">extends </span><span class="s1">ComponentOptionsMixin = any</span><span class="s0">, </span><span class="s1">Extends </span><span class="s0">extends </span><span class="s1">ComponentOptionsMixin = any</span><span class="s0">, </span><span class="s1">E </span><span class="s0">extends </span><span class="s1">EmitsOptions = any&gt; = ComponentOptionsBase&lt;Props</span><span class="s0">, </span><span class="s1">RawBindings</span><span class="s0">, </span><span class="s1">D</span><span class="s0">, </span><span class="s1">C</span><span class="s0">, </span><span class="s1">M</span><span class="s0">, </span><span class="s1">Mixin</span><span class="s0">, </span><span class="s1">Extends</span><span class="s0">, </span><span class="s1">E&gt; &amp; ThisType&lt;CreateComponentPublicInstance&lt;{}</span><span class="s0">, </span><span class="s1">RawBindings</span><span class="s0">, </span><span class="s1">D</span><span class="s0">, </span><span class="s1">C</span><span class="s0">, </span><span class="s1">M</span><span class="s0">, </span><span class="s1">Mixin</span><span class="s0">, </span><span class="s1">Extends</span><span class="s0">, </span><span class="s1">E</span><span class="s0">, </span><span class="s1">Readonly&lt;Props&gt;&gt;&gt;</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">interface </span><span class="s1">ComponentOptionsBase&lt;Props</span><span class="s0">, </span><span class="s1">RawBindings</span><span class="s0">, </span><span class="s1">D</span><span class="s0">, </span><span class="s1">C </span><span class="s0">extends </span><span class="s1">ComputedOptions</span><span class="s0">, </span><span class="s1">M </span><span class="s0">extends </span><span class="s1">MethodOptions</span><span class="s0">, </span><span class="s1">Mixin </span><span class="s0">extends </span><span class="s1">ComponentOptionsMixin</span><span class="s0">, </span><span class="s1">Extends </span><span class="s0">extends </span><span class="s1">ComponentOptionsMixin</span><span class="s0">, </span><span class="s1">E </span><span class="s0">extends </span><span class="s1">EmitsOptions</span><span class="s0">, </span><span class="s1">EE </span><span class="s0">extends </span><span class="s1">string = string</span><span class="s0">, </span><span class="s1">Defaults = {}</span><span class="s0">, </span><span class="s1">I </span><span class="s0">extends </span><span class="s1">ComponentInjectOptions = {}</span><span class="s0">, </span><span class="s1">II </span><span class="s0">extends </span><span class="s1">string = string&gt; </span><span class="s0">extends </span><span class="s1">LegacyOptions&lt;Props</span><span class="s0">, </span><span class="s1">D</span><span class="s0">, </span><span class="s1">C</span><span class="s0">, </span><span class="s1">M</span><span class="s0">, </span><span class="s1">Mixin</span><span class="s0">, </span><span class="s1">Extends</span><span class="s0">, </span><span class="s1">I</span><span class="s0">, </span><span class="s1">II&gt;</span><span class="s0">, </span><span class="s1">ComponentInternalOptions</span><span class="s0">, </span><span class="s1">ComponentCustomOptions {</span>
    <span class="s1">setup?: (</span><span class="s0">this</span><span class="s1">: </span><span class="s0">void, </span><span class="s1">props: Readonly&lt;LooseRequired&lt;Props &amp; UnionToIntersection&lt;ExtractOptionProp&lt;Mixin&gt;&gt; &amp; UnionToIntersection&lt;ExtractOptionProp&lt;Extends&gt;&gt;&gt;&gt;</span><span class="s0">, </span><span class="s1">ctx: SetupContext&lt;E&gt;) =&gt; Promise&lt;RawBindings&gt; | RawBindings | RenderFunction | </span><span class="s0">void;</span>
    <span class="s1">name?: string</span><span class="s0">;</span>
    <span class="s1">template?: string | object</span><span class="s0">;</span>
    <span class="s1">render?: Function</span><span class="s0">;</span>
    <span class="s1">components?: Record&lt;string</span><span class="s0">, </span><span class="s1">Component&gt;</span><span class="s0">;</span>
    <span class="s1">directives?: Record&lt;string</span><span class="s0">, </span><span class="s1">Directive&gt;</span><span class="s0">;</span>
    <span class="s1">inheritAttrs?: boolean</span><span class="s0">;</span>
    <span class="s1">emits?: (E | EE[]) &amp; ThisType&lt;</span><span class="s0">void</span><span class="s1">&gt;</span><span class="s0">;</span>
    <span class="s1">expose?: string[]</span><span class="s0">;</span>
    <span class="s1">serverPrefetch?(): </span><span class="s0">void </span><span class="s1">| Promise&lt;any&gt;</span><span class="s0">;</span>
    <span class="s1">compilerOptions?: RuntimeCompilerOptions</span><span class="s0">;</span>
    <span class="s4">/* Excluded from this release type: ssrRender */</span>
    <span class="s4">/* Excluded from this release type: __ssrInlineRender */</span>
    <span class="s4">/* Excluded from this release type: __asyncLoader */</span>
    <span class="s4">/* Excluded from this release type: __asyncResolved */</span>
    <span class="s1">call?: (</span><span class="s0">this</span><span class="s1">: unknown</span><span class="s0">, </span><span class="s1">...args: unknown[]) =&gt; never</span><span class="s0">;</span>
    <span class="s1">__isFragment?: never</span><span class="s0">;</span>
    <span class="s1">__isTeleport?: never</span><span class="s0">;</span>
    <span class="s1">__isSuspense?: never</span><span class="s0">;</span>
    <span class="s1">__defaults?: Defaults</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">declare type ComponentOptionsMixin = ComponentOptionsBase&lt;any</span><span class="s0">, </span><span class="s1">any</span><span class="s0">, </span><span class="s1">any</span><span class="s0">, </span><span class="s1">any</span><span class="s0">, </span><span class="s1">any</span><span class="s0">, </span><span class="s1">any</span><span class="s0">, </span><span class="s1">any</span><span class="s0">, </span><span class="s1">any</span><span class="s0">, </span><span class="s1">any</span><span class="s0">, </span><span class="s1">any&gt;</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare type ComponentOptionsWithArrayProps&lt;PropNames </span><span class="s0">extends </span><span class="s1">string = string</span><span class="s0">, </span><span class="s1">RawBindings = {}</span><span class="s0">, </span><span class="s1">D = {}</span><span class="s0">, </span><span class="s1">C </span><span class="s0">extends </span><span class="s1">ComputedOptions = {}</span><span class="s0">, </span><span class="s1">M </span><span class="s0">extends </span><span class="s1">MethodOptions = {}</span><span class="s0">, </span><span class="s1">Mixin </span><span class="s0">extends </span><span class="s1">ComponentOptionsMixin = ComponentOptionsMixin</span><span class="s0">, </span><span class="s1">Extends </span><span class="s0">extends </span><span class="s1">ComponentOptionsMixin = ComponentOptionsMixin</span><span class="s0">, </span><span class="s1">E </span><span class="s0">extends </span><span class="s1">EmitsOptions = EmitsOptions</span><span class="s0">, </span><span class="s1">EE </span><span class="s0">extends </span><span class="s1">string = string</span><span class="s0">, </span><span class="s1">I </span><span class="s0">extends </span><span class="s1">ComponentInjectOptions = {}</span><span class="s0">, </span><span class="s1">II </span><span class="s0">extends </span><span class="s1">string = string</span><span class="s0">, </span><span class="s1">Props = Readonly&lt;{</span>
    <span class="s1">[key </span><span class="s0">in </span><span class="s1">PropNames]?: any</span><span class="s0">;</span>
<span class="s1">}&gt; &amp; EmitsToProps&lt;E&gt;&gt; = ComponentOptionsBase&lt;Props</span><span class="s0">, </span><span class="s1">RawBindings</span><span class="s0">, </span><span class="s1">D</span><span class="s0">, </span><span class="s1">C</span><span class="s0">, </span><span class="s1">M</span><span class="s0">, </span><span class="s1">Mixin</span><span class="s0">, </span><span class="s1">Extends</span><span class="s0">, </span><span class="s1">E</span><span class="s0">, </span><span class="s1">EE</span><span class="s0">, </span><span class="s1">{}</span><span class="s0">, </span><span class="s1">I</span><span class="s0">, </span><span class="s1">II&gt; &amp; {</span>
    <span class="s1">props: PropNames[]</span><span class="s0">;</span>
<span class="s1">} &amp; ThisType&lt;CreateComponentPublicInstance&lt;Props</span><span class="s0">, </span><span class="s1">RawBindings</span><span class="s0">, </span><span class="s1">D</span><span class="s0">, </span><span class="s1">C</span><span class="s0">, </span><span class="s1">M</span><span class="s0">, </span><span class="s1">Mixin</span><span class="s0">, </span><span class="s1">Extends</span><span class="s0">, </span><span class="s1">E</span><span class="s0">, </span><span class="s1">Props</span><span class="s0">, </span><span class="s1">{}</span><span class="s0">, false, </span><span class="s1">I&gt;&gt;</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare type ComponentOptionsWithObjectProps&lt;PropsOptions = ComponentObjectPropsOptions</span><span class="s0">, </span><span class="s1">RawBindings = {}</span><span class="s0">, </span><span class="s1">D = {}</span><span class="s0">, </span><span class="s1">C </span><span class="s0">extends </span><span class="s1">ComputedOptions = {}</span><span class="s0">, </span><span class="s1">M </span><span class="s0">extends </span><span class="s1">MethodOptions = {}</span><span class="s0">, </span><span class="s1">Mixin </span><span class="s0">extends </span><span class="s1">ComponentOptionsMixin = ComponentOptionsMixin</span><span class="s0">, </span><span class="s1">Extends </span><span class="s0">extends </span><span class="s1">ComponentOptionsMixin = ComponentOptionsMixin</span><span class="s0">, </span><span class="s1">E </span><span class="s0">extends </span><span class="s1">EmitsOptions = EmitsOptions</span><span class="s0">, </span><span class="s1">EE </span><span class="s0">extends </span><span class="s1">string = string</span><span class="s0">, </span><span class="s1">I </span><span class="s0">extends </span><span class="s1">ComponentInjectOptions = {}</span><span class="s0">, </span><span class="s1">II </span><span class="s0">extends </span><span class="s1">string = string</span><span class="s0">, </span><span class="s1">Props = Readonly&lt;ExtractPropTypes&lt;PropsOptions&gt;&gt; &amp; EmitsToProps&lt;E&gt;</span><span class="s0">, </span><span class="s1">Defaults = ExtractDefaultPropTypes&lt;PropsOptions&gt;&gt; = ComponentOptionsBase&lt;Props</span><span class="s0">, </span><span class="s1">RawBindings</span><span class="s0">, </span><span class="s1">D</span><span class="s0">, </span><span class="s1">C</span><span class="s0">, </span><span class="s1">M</span><span class="s0">, </span><span class="s1">Mixin</span><span class="s0">, </span><span class="s1">Extends</span><span class="s0">, </span><span class="s1">E</span><span class="s0">, </span><span class="s1">EE</span><span class="s0">, </span><span class="s1">Defaults</span><span class="s0">, </span><span class="s1">I</span><span class="s0">, </span><span class="s1">II&gt; &amp; {</span>
    <span class="s1">props: PropsOptions &amp; ThisType&lt;</span><span class="s0">void</span><span class="s1">&gt;</span><span class="s0">;</span>
<span class="s1">} &amp; ThisType&lt;CreateComponentPublicInstance&lt;Props</span><span class="s0">, </span><span class="s1">RawBindings</span><span class="s0">, </span><span class="s1">D</span><span class="s0">, </span><span class="s1">C</span><span class="s0">, </span><span class="s1">M</span><span class="s0">, </span><span class="s1">Mixin</span><span class="s0">, </span><span class="s1">Extends</span><span class="s0">, </span><span class="s1">E</span><span class="s0">, </span><span class="s1">Props</span><span class="s0">, </span><span class="s1">Defaults</span><span class="s0">, false, </span><span class="s1">I&gt;&gt;</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare type ComponentOptionsWithoutProps&lt;Props = {}</span><span class="s0">, </span><span class="s1">RawBindings = {}</span><span class="s0">, </span><span class="s1">D = {}</span><span class="s0">, </span><span class="s1">C </span><span class="s0">extends </span><span class="s1">ComputedOptions = {}</span><span class="s0">, </span><span class="s1">M </span><span class="s0">extends </span><span class="s1">MethodOptions = {}</span><span class="s0">, </span><span class="s1">Mixin </span><span class="s0">extends </span><span class="s1">ComponentOptionsMixin = ComponentOptionsMixin</span><span class="s0">, </span><span class="s1">Extends </span><span class="s0">extends </span><span class="s1">ComponentOptionsMixin = ComponentOptionsMixin</span><span class="s0">, </span><span class="s1">E </span><span class="s0">extends </span><span class="s1">EmitsOptions = EmitsOptions</span><span class="s0">, </span><span class="s1">EE </span><span class="s0">extends </span><span class="s1">string = string</span><span class="s0">, </span><span class="s1">I </span><span class="s0">extends </span><span class="s1">ComponentInjectOptions = {}</span><span class="s0">, </span><span class="s1">II </span><span class="s0">extends </span><span class="s1">string = string</span><span class="s0">, </span><span class="s1">PE = Props &amp; EmitsToProps&lt;E&gt;&gt; = ComponentOptionsBase&lt;PE</span><span class="s0">, </span><span class="s1">RawBindings</span><span class="s0">, </span><span class="s1">D</span><span class="s0">, </span><span class="s1">C</span><span class="s0">, </span><span class="s1">M</span><span class="s0">, </span><span class="s1">Mixin</span><span class="s0">, </span><span class="s1">Extends</span><span class="s0">, </span><span class="s1">E</span><span class="s0">, </span><span class="s1">EE</span><span class="s0">, </span><span class="s1">{}</span><span class="s0">, </span><span class="s1">I</span><span class="s0">, </span><span class="s1">II&gt; &amp; {</span>
    <span class="s1">props?: undefined</span><span class="s0">;</span>
<span class="s1">} &amp; ThisType&lt;CreateComponentPublicInstance&lt;PE</span><span class="s0">, </span><span class="s1">RawBindings</span><span class="s0">, </span><span class="s1">D</span><span class="s0">, </span><span class="s1">C</span><span class="s0">, </span><span class="s1">M</span><span class="s0">, </span><span class="s1">Mixin</span><span class="s0">, </span><span class="s1">Extends</span><span class="s0">, </span><span class="s1">E</span><span class="s0">, </span><span class="s1">PE</span><span class="s0">, </span><span class="s1">{}</span><span class="s0">, false, </span><span class="s1">I&gt;&gt;</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare type ComponentPropsOptions&lt;P = Data&gt; = ComponentObjectPropsOptions&lt;P&gt; | string[]</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare type ComponentProvideOptions = ObjectProvideOptions | Function</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare type ComponentPublicInstance&lt;P = {}</span><span class="s0">, </span><span class="s4">// props type extracted from props option</span>
<span class="s1">B = {}</span><span class="s0">, </span><span class="s4">// raw bindings returned from setup()</span>
<span class="s1">D = {}</span><span class="s0">, </span><span class="s4">// return from data()</span>
<span class="s1">C </span><span class="s0">extends </span><span class="s1">ComputedOptions = {}</span><span class="s0">, </span><span class="s1">M </span><span class="s0">extends </span><span class="s1">MethodOptions = {}</span><span class="s0">, </span><span class="s1">E </span><span class="s0">extends </span><span class="s1">EmitsOptions = {}</span><span class="s0">, </span><span class="s1">PublicProps = P</span><span class="s0">, </span><span class="s1">Defaults = {}</span><span class="s0">, </span><span class="s1">MakeDefaultsOptional </span><span class="s0">extends </span><span class="s1">boolean = </span><span class="s0">false, </span><span class="s1">Options = ComponentOptionsBase&lt;any</span><span class="s0">, </span><span class="s1">any</span><span class="s0">, </span><span class="s1">any</span><span class="s0">, </span><span class="s1">any</span><span class="s0">, </span><span class="s1">any</span><span class="s0">, </span><span class="s1">any</span><span class="s0">, </span><span class="s1">any</span><span class="s0">, </span><span class="s1">any</span><span class="s0">, </span><span class="s1">any&gt;</span><span class="s0">, </span><span class="s1">I </span><span class="s0">extends </span><span class="s1">ComponentInjectOptions = {}&gt; = {</span>
    <span class="s1">$: ComponentInternalInstance</span><span class="s0">;</span>
    <span class="s1">$data: D</span><span class="s0">;</span>
    <span class="s1">$props: MakeDefaultsOptional </span><span class="s0">extends true </span><span class="s1">? Partial&lt;Defaults&gt; &amp; Omit&lt;P &amp; PublicProps</span><span class="s0">, </span><span class="s1">keyof Defaults&gt; : P &amp; PublicProps</span><span class="s0">;</span>
    <span class="s1">$attrs: Data</span><span class="s0">;</span>
    <span class="s1">$refs: Data</span><span class="s0">;</span>
    <span class="s1">$slots: Slots</span><span class="s0">;</span>
    <span class="s1">$root: ComponentPublicInstance | </span><span class="s0">null;</span>
    <span class="s1">$parent: ComponentPublicInstance | </span><span class="s0">null;</span>
    <span class="s1">$emit: EmitFn&lt;E&gt;</span><span class="s0">;</span>
    <span class="s1">$el: any</span><span class="s0">;</span>
    <span class="s1">$options: Options &amp; MergedComponentOptionsOverride</span><span class="s0">;</span>
    <span class="s1">$forceUpdate: () =&gt; </span><span class="s0">void;</span>
    <span class="s1">$nextTick: </span><span class="s0">typeof </span><span class="s1">nextTick</span><span class="s0">;</span>
    <span class="s1">$watch&lt;T </span><span class="s0">extends </span><span class="s1">string | ((...args: any) =&gt; any)&gt;(source: T</span><span class="s0">, </span><span class="s1">cb: T </span><span class="s0">extends </span><span class="s1">(...args: any) =&gt; infer R ? (...args: [R</span><span class="s0">, </span><span class="s1">R]) =&gt; any : (...args: any) =&gt; any</span><span class="s0">, </span><span class="s1">options?: WatchOptions): WatchStopHandle</span><span class="s0">;</span>
<span class="s1">} &amp; P &amp; ShallowUnwrapRef&lt;B&gt; &amp; UnwrapNestedRefs&lt;D&gt; &amp; ExtractComputedReturns&lt;C&gt; &amp; M &amp; ComponentCustomProperties &amp; InjectToObject&lt;I&gt;</span><span class="s0">;</span>

<span class="s1">declare type ComponentPublicInstanceConstructor&lt;T </span><span class="s0">extends </span><span class="s1">ComponentPublicInstance&lt;Props</span><span class="s0">, </span><span class="s1">RawBindings</span><span class="s0">, </span><span class="s1">D</span><span class="s0">, </span><span class="s1">C</span><span class="s0">, </span><span class="s1">M&gt; = ComponentPublicInstance&lt;any&gt;</span><span class="s0">, </span><span class="s1">Props = any</span><span class="s0">, </span><span class="s1">RawBindings = any</span><span class="s0">, </span><span class="s1">D = any</span><span class="s0">, </span><span class="s1">C </span><span class="s0">extends </span><span class="s1">ComputedOptions = ComputedOptions</span><span class="s0">, </span><span class="s1">M </span><span class="s0">extends </span><span class="s1">MethodOptions = MethodOptions&gt; = {</span>
    <span class="s1">__isFragment?: never</span><span class="s0">;</span>
    <span class="s1">__isTeleport?: never</span><span class="s0">;</span>
    <span class="s1">__isSuspense?: never</span><span class="s0">;</span>
    <span class="s0">new </span><span class="s1">(...args: any[]): T</span><span class="s0">;</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s1">declare type ComponentWatchOptionItem = WatchOptionItem | WatchOptionItem[]</span><span class="s0">;</span>

<span class="s1">declare type ComponentWatchOptions = Record&lt;string</span><span class="s0">, </span><span class="s1">ComponentWatchOptionItem&gt;</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">const </span><span class="s1">computed: </span><span class="s0">typeof </span><span class="s1">computed_2</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">{ ComputedGetter }</span>

<span class="s0">export </span><span class="s1">declare type ComputedOptions = Record&lt;string</span><span class="s0">, </span><span class="s1">ComputedGetter&lt;any&gt; | WritableComputedOptions&lt;any&gt;&gt;</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">{ ComputedRef }</span>

<span class="s0">export </span><span class="s1">{ ComputedSetter }</span>

<span class="s3">/**</span>
 <span class="s3">* Concrete component type matches its actual value: it's either an options</span>
 <span class="s3">* object, or a function. Use this where the code expects to work with actual</span>
 <span class="s3">* values, e.g. checking if its a function or not. This is mostly for internal</span>
 <span class="s3">* implementation code.</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare type ConcreteComponent&lt;Props = {}</span><span class="s0">, </span><span class="s1">RawBindings = any</span><span class="s0">, </span><span class="s1">D = any</span><span class="s0">, </span><span class="s1">C </span><span class="s0">extends </span><span class="s1">ComputedOptions = ComputedOptions</span><span class="s0">, </span><span class="s1">M </span><span class="s0">extends </span><span class="s1">MethodOptions = MethodOptions&gt; = ComponentOptions&lt;Props</span><span class="s0">, </span><span class="s1">RawBindings</span><span class="s0">, </span><span class="s1">D</span><span class="s0">, </span><span class="s1">C</span><span class="s0">, </span><span class="s1">M&gt; | FunctionalComponent&lt;Props</span><span class="s0">, </span><span class="s1">any&gt;</span><span class="s0">;</span>

<span class="s1">declare </span><span class="s0">function </span><span class="s1">configureCompat(config: CompatConfig): </span><span class="s0">void;</span>

<span class="s1">declare </span><span class="s0">interface </span><span class="s1">Constructor&lt;P = any&gt; {</span>
    <span class="s1">__isFragment?: never</span><span class="s0">;</span>
    <span class="s1">__isTeleport?: never</span><span class="s0">;</span>
    <span class="s1">__isSuspense?: never</span><span class="s0">;</span>
    <span class="s0">new </span><span class="s1">(...args: any[]): {</span>
        <span class="s1">$props: P</span><span class="s0">;</span>
    <span class="s1">}</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">declare type CreateAppFunction&lt;HostElement&gt; = (rootComponent: Component</span><span class="s0">, </span><span class="s1">rootProps?: Data | </span><span class="s0">null</span><span class="s1">) =&gt; App&lt;HostElement&gt;</span><span class="s0">;</span>

<span class="s3">/**</span>
 <span class="s3">* Create a block root vnode. Takes the same exact arguments as `createVNode`.</span>
 <span class="s3">* A block root keeps track of dynamic nodes within the block in the</span>
 <span class="s3">* `dynamicChildren` array.</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s5">@private</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">createBlock(type: VNodeTypes | ClassComponent</span><span class="s0">, </span><span class="s1">props?: Record&lt;string</span><span class="s0">, </span><span class="s1">any&gt; | </span><span class="s0">null, </span><span class="s1">children?: any</span><span class="s0">, </span><span class="s1">patchFlag?: number</span><span class="s0">, </span><span class="s1">dynamicProps?: string[]): VNode</span><span class="s0">;</span>

<span class="s3">/**</span>
 <span class="s3">* </span><span class="s5">@private</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">createCommentVNode(text?: string</span><span class="s0">, </span><span class="s1">asBlock?: boolean): VNode</span><span class="s0">;</span>

<span class="s1">declare </span><span class="s0">function </span><span class="s1">createCompatVue(createApp: CreateAppFunction&lt;Element&gt;</span><span class="s0">, </span><span class="s1">createSingletonApp: CreateAppFunction&lt;Element&gt;): CompatVue</span><span class="s0">;</span>

<span class="s1">declare </span><span class="s0">function </span><span class="s1">createComponentInstance(vnode: VNode</span><span class="s0">, </span><span class="s1">parent: ComponentInternalInstance | </span><span class="s0">null, </span><span class="s1">suspense: SuspenseBoundary | </span><span class="s0">null</span><span class="s1">): ComponentInternalInstance</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare type CreateComponentPublicInstance&lt;P = {}</span><span class="s0">, </span><span class="s1">B = {}</span><span class="s0">, </span><span class="s1">D = {}</span><span class="s0">, </span><span class="s1">C </span><span class="s0">extends </span><span class="s1">ComputedOptions = {}</span><span class="s0">, </span><span class="s1">M </span><span class="s0">extends </span><span class="s1">MethodOptions = {}</span><span class="s0">, </span><span class="s1">Mixin </span><span class="s0">extends </span><span class="s1">ComponentOptionsMixin = ComponentOptionsMixin</span><span class="s0">, </span><span class="s1">Extends </span><span class="s0">extends </span><span class="s1">ComponentOptionsMixin = ComponentOptionsMixin</span><span class="s0">, </span><span class="s1">E </span><span class="s0">extends </span><span class="s1">EmitsOptions = {}</span><span class="s0">, </span><span class="s1">PublicProps = P</span><span class="s0">, </span><span class="s1">Defaults = {}</span><span class="s0">, </span><span class="s1">MakeDefaultsOptional </span><span class="s0">extends </span><span class="s1">boolean = </span><span class="s0">false, </span><span class="s1">I </span><span class="s0">extends </span><span class="s1">ComponentInjectOptions = {}</span><span class="s0">, </span><span class="s1">PublicMixin = IntersectionMixin&lt;Mixin&gt; &amp; IntersectionMixin&lt;Extends&gt;</span><span class="s0">, </span><span class="s1">PublicP = UnwrapMixinsType&lt;PublicMixin</span><span class="s0">, </span><span class="s2">'P'</span><span class="s1">&gt; &amp; EnsureNonVoid&lt;P&gt;</span><span class="s0">, </span><span class="s1">PublicB = UnwrapMixinsType&lt;PublicMixin</span><span class="s0">, </span><span class="s2">'B'</span><span class="s1">&gt; &amp; EnsureNonVoid&lt;B&gt;</span><span class="s0">, </span><span class="s1">PublicD = UnwrapMixinsType&lt;PublicMixin</span><span class="s0">, </span><span class="s2">'D'</span><span class="s1">&gt; &amp; EnsureNonVoid&lt;D&gt;</span><span class="s0">, </span><span class="s1">PublicC </span><span class="s0">extends </span><span class="s1">ComputedOptions = UnwrapMixinsType&lt;PublicMixin</span><span class="s0">, </span><span class="s2">'C'</span><span class="s1">&gt; &amp; EnsureNonVoid&lt;C&gt;</span><span class="s0">, </span><span class="s1">PublicM </span><span class="s0">extends </span><span class="s1">MethodOptions = UnwrapMixinsType&lt;PublicMixin</span><span class="s0">, </span><span class="s2">'M'</span><span class="s1">&gt; &amp; EnsureNonVoid&lt;M&gt;</span><span class="s0">, </span><span class="s1">PublicDefaults = UnwrapMixinsType&lt;PublicMixin</span><span class="s0">, </span><span class="s2">'Defaults'</span><span class="s1">&gt; &amp; EnsureNonVoid&lt;Defaults&gt;&gt; = ComponentPublicInstance&lt;PublicP</span><span class="s0">, </span><span class="s1">PublicB</span><span class="s0">, </span><span class="s1">PublicD</span><span class="s0">, </span><span class="s1">PublicC</span><span class="s0">, </span><span class="s1">PublicM</span><span class="s0">, </span><span class="s1">E</span><span class="s0">, </span><span class="s1">PublicProps</span><span class="s0">, </span><span class="s1">PublicDefaults</span><span class="s0">, </span><span class="s1">MakeDefaultsOptional</span><span class="s0">, </span><span class="s1">ComponentOptionsBase&lt;P</span><span class="s0">, </span><span class="s1">B</span><span class="s0">, </span><span class="s1">D</span><span class="s0">, </span><span class="s1">C</span><span class="s0">, </span><span class="s1">M</span><span class="s0">, </span><span class="s1">Mixin</span><span class="s0">, </span><span class="s1">Extends</span><span class="s0">, </span><span class="s1">E</span><span class="s0">, </span><span class="s1">string</span><span class="s0">, </span><span class="s1">Defaults&gt;</span><span class="s0">, </span><span class="s1">I&gt;</span><span class="s0">;</span>

<span class="s3">/**</span>
 <span class="s3">* </span><span class="s5">@private</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">createElementBlock(type: string | </span><span class="s0">typeof </span><span class="s1">Fragment</span><span class="s0">, </span><span class="s1">props?: Record&lt;string</span><span class="s0">, </span><span class="s1">any&gt; | </span><span class="s0">null, </span><span class="s1">children?: any</span><span class="s0">, </span><span class="s1">patchFlag?: number</span><span class="s0">, </span><span class="s1">dynamicProps?: string[]</span><span class="s0">, </span><span class="s1">shapeFlag?: number): VNode&lt;RendererNode</span><span class="s0">, </span><span class="s1">RendererElement</span><span class="s0">, </span><span class="s1">{</span>
    <span class="s1">[key: string]: any</span><span class="s0">;</span>
<span class="s1">}&gt;</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">createElementVNode(type: VNodeTypes | ClassComponent | </span><span class="s0">typeof </span><span class="s1">NULL_DYNAMIC_COMPONENT</span><span class="s0">, </span><span class="s1">props?: (Data &amp; VNodeProps) | </span><span class="s0">null, </span><span class="s1">children?: unknown</span><span class="s0">, </span><span class="s1">patchFlag?: number</span><span class="s0">, </span><span class="s1">dynamicProps?: string[] | </span><span class="s0">null, </span><span class="s1">shapeFlag?: number | ShapeFlags</span><span class="s0">, </span><span class="s1">isBlockNode?: boolean</span><span class="s0">, </span><span class="s1">needFullChildrenNormalization?: boolean): VNode&lt;RendererNode</span><span class="s0">, </span><span class="s1">RendererElement</span><span class="s0">, </span><span class="s1">{</span>
    <span class="s1">[key: string]: any</span><span class="s0">;</span>
<span class="s1">}&gt;</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">createHydrationRenderer(options: RendererOptions&lt;Node</span><span class="s0">, </span><span class="s1">Element&gt;): HydrationRenderer</span><span class="s0">;</span>

<span class="s4">/* Excluded from this release type: createPropsRestProxy */</span>

<span class="s1">declare </span><span class="s0">function </span><span class="s1">createRecord(id: string</span><span class="s0">, </span><span class="s1">initialDef: HMRComponent): boolean</span><span class="s0">;</span>

<span class="s3">/**</span>
 <span class="s3">* The createRenderer function accepts two generic arguments:</span>
 <span class="s3">* HostNode and HostElement, corresponding to Node and Element types in the</span>
 <span class="s3">* host environment. For example, for runtime-dom, HostNode would be the DOM</span>
 <span class="s3">* `Node` interface and HostElement would be the DOM `Element` interface.</span>
 <span class="s3">*</span>
 <span class="s3">* Custom renderers can pass in the platform specific types like this:</span>
 <span class="s3">*</span>
 <span class="s3">* ``` js</span>
 <span class="s3">* const { render, createApp } = createRenderer&lt;Node, Element&gt;({</span>
 <span class="s3">*   patchProp,</span>
 <span class="s3">*   ...nodeOps</span>
 <span class="s3">* })</span>
 <span class="s3">* ```</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">createRenderer&lt;HostNode = RendererNode</span><span class="s0">, </span><span class="s1">HostElement = RendererElement&gt;(options: RendererOptions&lt;HostNode</span><span class="s0">, </span><span class="s1">HostElement&gt;): Renderer&lt;HostElement&gt;</span><span class="s0">;</span>

<span class="s3">/**</span>
 <span class="s3">* Compiler runtime helper for creating dynamic slots object</span>
 <span class="s3">* </span><span class="s5">@private</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">createSlots(slots: Record&lt;string</span><span class="s0">, </span><span class="s1">SSRSlot&gt;</span><span class="s0">, </span><span class="s1">dynamicSlots: (CompiledSlotDescriptor | CompiledSlotDescriptor[] | undefined)[]): Record&lt;string</span><span class="s0">, </span><span class="s1">SSRSlot&gt;</span><span class="s0">;</span>

<span class="s3">/**</span>
 <span class="s3">* </span><span class="s5">@private</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">createStaticVNode(content: string</span><span class="s0">, </span><span class="s1">numberOfNodes: number): VNode</span><span class="s0">;</span>

<span class="s1">declare </span><span class="s0">function </span><span class="s1">createSuspenseBoundary(vnode: VNode</span><span class="s0">, </span><span class="s1">parent: SuspenseBoundary | </span><span class="s0">null, </span><span class="s1">parentComponent: ComponentInternalInstance | </span><span class="s0">null, </span><span class="s1">container: RendererElement</span><span class="s0">, </span><span class="s1">hiddenContainer: RendererElement</span><span class="s0">, </span><span class="s1">anchor: RendererNode | </span><span class="s0">null, </span><span class="s1">isSVG: boolean</span><span class="s0">, </span><span class="s1">slotScopeIds: string[] | </span><span class="s0">null, </span><span class="s1">optimized: boolean</span><span class="s0">, </span><span class="s1">rendererInternals: RendererInternals</span><span class="s0">, </span><span class="s1">isHydrating?: boolean): SuspenseBoundary</span><span class="s0">;</span>

<span class="s3">/**</span>
 <span class="s3">* </span><span class="s5">@private</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">createTextVNode(text?: string</span><span class="s0">, </span><span class="s1">flag?: number): VNode</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">const </span><span class="s1">createVNode: </span><span class="s0">typeof </span><span class="s1">_createVNode</span><span class="s0">;</span>

<span class="s1">declare </span><span class="s0">function </span><span class="s1">_createVNode(type: VNodeTypes | ClassComponent | </span><span class="s0">typeof </span><span class="s1">NULL_DYNAMIC_COMPONENT</span><span class="s0">, </span><span class="s1">props?: (Data &amp; VNodeProps) | </span><span class="s0">null, </span><span class="s1">children?: unknown</span><span class="s0">, </span><span class="s1">patchFlag?: number</span><span class="s0">, </span><span class="s1">dynamicProps?: string[] | </span><span class="s0">null, </span><span class="s1">isBlockNode?: boolean): VNode</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">{ customRef }</span>

<span class="s0">export </span><span class="s1">{ CustomRefFactory }</span>

<span class="s1">declare type Data = Record&lt;string</span><span class="s0">, </span><span class="s1">unknown&gt;</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">{ DebuggerEvent }</span>

<span class="s0">export </span><span class="s1">{ DebuggerEventExtraInfo }</span>

<span class="s1">declare type DebuggerHook = (e: DebuggerEvent) =&gt; </span><span class="s0">void;</span>

<span class="s0">export </span><span class="s1">{ DebuggerOptions }</span>

<span class="s0">export </span><span class="s1">{ DeepReadonly }</span>

<span class="s1">declare type DefaultFactory&lt;T&gt; = (props: Data) =&gt; T | </span><span class="s0">null </span><span class="s1">| undefined</span><span class="s0">;</span>

<span class="s1">declare type DefaultKeys&lt;T&gt; = {</span>
    <span class="s1">[K </span><span class="s0">in </span><span class="s1">keyof T]: T[K] </span><span class="s0">extends </span><span class="s1">{</span>
        <span class="s0">default</span><span class="s1">: any</span><span class="s0">;</span>
    <span class="s1">} | BooleanConstructor | {</span>
        <span class="s1">type: BooleanConstructor</span><span class="s0">;</span>
    <span class="s1">} ? T[K] </span><span class="s0">extends </span><span class="s1">{</span>
        <span class="s1">type: BooleanConstructor</span><span class="s0">;</span>
        <span class="s1">required: </span><span class="s0">true;</span>
    <span class="s1">} ? never : K : never</span><span class="s0">;</span>
<span class="s1">}[keyof T]</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">defineAsyncComponent&lt;T </span><span class="s0">extends </span><span class="s1">Component = {</span>
    <span class="s0">new </span><span class="s1">(): ComponentPublicInstance</span><span class="s0">;</span>
<span class="s1">}&gt;(source: AsyncComponentLoader&lt;T&gt; | AsyncComponentOptions&lt;T&gt;): T</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare type DefineComponent&lt;PropsOrPropOptions = {}</span><span class="s0">, </span><span class="s1">RawBindings = {}</span><span class="s0">, </span><span class="s1">D = {}</span><span class="s0">, </span><span class="s1">C </span><span class="s0">extends </span><span class="s1">ComputedOptions = ComputedOptions</span><span class="s0">, </span><span class="s1">M </span><span class="s0">extends </span><span class="s1">MethodOptions = MethodOptions</span><span class="s0">, </span><span class="s1">Mixin </span><span class="s0">extends </span><span class="s1">ComponentOptionsMixin = ComponentOptionsMixin</span><span class="s0">, </span><span class="s1">Extends </span><span class="s0">extends </span><span class="s1">ComponentOptionsMixin = ComponentOptionsMixin</span><span class="s0">, </span><span class="s1">E </span><span class="s0">extends </span><span class="s1">EmitsOptions = {}</span><span class="s0">, </span><span class="s1">EE </span><span class="s0">extends </span><span class="s1">string = string</span><span class="s0">, </span><span class="s1">PP = PublicProps</span><span class="s0">, </span><span class="s1">Props = Readonly&lt;PropsOrPropOptions </span><span class="s0">extends </span><span class="s1">ComponentPropsOptions ? ExtractPropTypes&lt;PropsOrPropOptions&gt; : PropsOrPropOptions&gt; &amp; ({} </span><span class="s0">extends </span><span class="s1">E ? {} : EmitsToProps&lt;E&gt;)</span><span class="s0">, </span><span class="s1">Defaults = ExtractDefaultPropTypes&lt;PropsOrPropOptions&gt;&gt; = ComponentPublicInstanceConstructor&lt;CreateComponentPublicInstance&lt;Props</span><span class="s0">, </span><span class="s1">RawBindings</span><span class="s0">, </span><span class="s1">D</span><span class="s0">, </span><span class="s1">C</span><span class="s0">, </span><span class="s1">M</span><span class="s0">, </span><span class="s1">Mixin</span><span class="s0">, </span><span class="s1">Extends</span><span class="s0">, </span><span class="s1">E</span><span class="s0">, </span><span class="s1">PP &amp; Props</span><span class="s0">, </span><span class="s1">Defaults</span><span class="s0">, true</span><span class="s1">&gt; &amp; Props&gt; &amp; ComponentOptionsBase&lt;Props</span><span class="s0">, </span><span class="s1">RawBindings</span><span class="s0">, </span><span class="s1">D</span><span class="s0">, </span><span class="s1">C</span><span class="s0">, </span><span class="s1">M</span><span class="s0">, </span><span class="s1">Mixin</span><span class="s0">, </span><span class="s1">Extends</span><span class="s0">, </span><span class="s1">E</span><span class="s0">, </span><span class="s1">EE</span><span class="s0">, </span><span class="s1">Defaults&gt; &amp; PP</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">defineComponent&lt;Props</span><span class="s0">, </span><span class="s1">RawBindings = object&gt;(setup: (props: Readonly&lt;Props&gt;</span><span class="s0">, </span><span class="s1">ctx: SetupContext) =&gt; RawBindings | RenderFunction): DefineComponent&lt;Props</span><span class="s0">, </span><span class="s1">RawBindings&gt;</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">defineComponent&lt;Props = {}</span><span class="s0">, </span><span class="s1">RawBindings = {}</span><span class="s0">, </span><span class="s1">D = {}</span><span class="s0">, </span><span class="s1">C </span><span class="s0">extends </span><span class="s1">ComputedOptions = {}</span><span class="s0">, </span><span class="s1">M </span><span class="s0">extends </span><span class="s1">MethodOptions = {}</span><span class="s0">, </span><span class="s1">Mixin </span><span class="s0">extends </span><span class="s1">ComponentOptionsMixin = ComponentOptionsMixin</span><span class="s0">, </span><span class="s1">Extends </span><span class="s0">extends </span><span class="s1">ComponentOptionsMixin = ComponentOptionsMixin</span><span class="s0">, </span><span class="s1">E </span><span class="s0">extends </span><span class="s1">EmitsOptions = {}</span><span class="s0">, </span><span class="s1">EE </span><span class="s0">extends </span><span class="s1">string = string</span><span class="s0">, </span><span class="s1">I </span><span class="s0">extends </span><span class="s1">ComponentInjectOptions = {}</span><span class="s0">, </span><span class="s1">II </span><span class="s0">extends </span><span class="s1">string = string&gt;(options: ComponentOptionsWithoutProps&lt;Props</span><span class="s0">, </span><span class="s1">RawBindings</span><span class="s0">, </span><span class="s1">D</span><span class="s0">, </span><span class="s1">C</span><span class="s0">, </span><span class="s1">M</span><span class="s0">, </span><span class="s1">Mixin</span><span class="s0">, </span><span class="s1">Extends</span><span class="s0">, </span><span class="s1">E</span><span class="s0">, </span><span class="s1">EE</span><span class="s0">, </span><span class="s1">I</span><span class="s0">, </span><span class="s1">II&gt;): DefineComponent&lt;Props</span><span class="s0">, </span><span class="s1">RawBindings</span><span class="s0">, </span><span class="s1">D</span><span class="s0">, </span><span class="s1">C</span><span class="s0">, </span><span class="s1">M</span><span class="s0">, </span><span class="s1">Mixin</span><span class="s0">, </span><span class="s1">Extends</span><span class="s0">, </span><span class="s1">E</span><span class="s0">, </span><span class="s1">EE&gt;</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">defineComponent&lt;PropNames </span><span class="s0">extends </span><span class="s1">string</span><span class="s0">, </span><span class="s1">RawBindings</span><span class="s0">, </span><span class="s1">D</span><span class="s0">, </span><span class="s1">C </span><span class="s0">extends </span><span class="s1">ComputedOptions = {}</span><span class="s0">, </span><span class="s1">M </span><span class="s0">extends </span><span class="s1">MethodOptions = {}</span><span class="s0">, </span><span class="s1">Mixin </span><span class="s0">extends </span><span class="s1">ComponentOptionsMixin = ComponentOptionsMixin</span><span class="s0">, </span><span class="s1">Extends </span><span class="s0">extends </span><span class="s1">ComponentOptionsMixin = ComponentOptionsMixin</span><span class="s0">, </span><span class="s1">E </span><span class="s0">extends </span><span class="s1">EmitsOptions = {}</span><span class="s0">, </span><span class="s1">EE </span><span class="s0">extends </span><span class="s1">string = string</span><span class="s0">, </span><span class="s1">I </span><span class="s0">extends </span><span class="s1">ComponentInjectOptions = {}</span><span class="s0">, </span><span class="s1">II </span><span class="s0">extends </span><span class="s1">string = string&gt;(options: ComponentOptionsWithArrayProps&lt;PropNames</span><span class="s0">, </span><span class="s1">RawBindings</span><span class="s0">, </span><span class="s1">D</span><span class="s0">, </span><span class="s1">C</span><span class="s0">, </span><span class="s1">M</span><span class="s0">, </span><span class="s1">Mixin</span><span class="s0">, </span><span class="s1">Extends</span><span class="s0">, </span><span class="s1">E</span><span class="s0">, </span><span class="s1">EE</span><span class="s0">, </span><span class="s1">I</span><span class="s0">, </span><span class="s1">II&gt;): DefineComponent&lt;Readonly&lt;{</span>
    <span class="s1">[key </span><span class="s0">in </span><span class="s1">PropNames]?: any</span><span class="s0">;</span>
<span class="s1">}&gt;</span><span class="s0">, </span><span class="s1">RawBindings</span><span class="s0">, </span><span class="s1">D</span><span class="s0">, </span><span class="s1">C</span><span class="s0">, </span><span class="s1">M</span><span class="s0">, </span><span class="s1">Mixin</span><span class="s0">, </span><span class="s1">Extends</span><span class="s0">, </span><span class="s1">E</span><span class="s0">, </span><span class="s1">EE&gt;</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">defineComponent&lt;PropsOptions </span><span class="s0">extends </span><span class="s1">Readonly&lt;ComponentPropsOptions&gt;</span><span class="s0">, </span><span class="s1">RawBindings</span><span class="s0">, </span><span class="s1">D</span><span class="s0">, </span><span class="s1">C </span><span class="s0">extends </span><span class="s1">ComputedOptions = {}</span><span class="s0">, </span><span class="s1">M </span><span class="s0">extends </span><span class="s1">MethodOptions = {}</span><span class="s0">, </span><span class="s1">Mixin </span><span class="s0">extends </span><span class="s1">ComponentOptionsMixin = ComponentOptionsMixin</span><span class="s0">, </span><span class="s1">Extends </span><span class="s0">extends </span><span class="s1">ComponentOptionsMixin = ComponentOptionsMixin</span><span class="s0">, </span><span class="s1">E </span><span class="s0">extends </span><span class="s1">EmitsOptions = {}</span><span class="s0">, </span><span class="s1">EE </span><span class="s0">extends </span><span class="s1">string = string</span><span class="s0">, </span><span class="s1">I </span><span class="s0">extends </span><span class="s1">ComponentInjectOptions = {}</span><span class="s0">, </span><span class="s1">II </span><span class="s0">extends </span><span class="s1">string = string&gt;(options: ComponentOptionsWithObjectProps&lt;PropsOptions</span><span class="s0">, </span><span class="s1">RawBindings</span><span class="s0">, </span><span class="s1">D</span><span class="s0">, </span><span class="s1">C</span><span class="s0">, </span><span class="s1">M</span><span class="s0">, </span><span class="s1">Mixin</span><span class="s0">, </span><span class="s1">Extends</span><span class="s0">, </span><span class="s1">E</span><span class="s0">, </span><span class="s1">EE</span><span class="s0">, </span><span class="s1">I</span><span class="s0">, </span><span class="s1">II&gt;): DefineComponent&lt;PropsOptions</span><span class="s0">, </span><span class="s1">RawBindings</span><span class="s0">, </span><span class="s1">D</span><span class="s0">, </span><span class="s1">C</span><span class="s0">, </span><span class="s1">M</span><span class="s0">, </span><span class="s1">Mixin</span><span class="s0">, </span><span class="s1">Extends</span><span class="s0">, </span><span class="s1">E</span><span class="s0">, </span><span class="s1">EE&gt;</span><span class="s0">;</span>

<span class="s3">/**</span>
 <span class="s3">* Vue `&lt;script setup&gt;` compiler macro for declaring a component's emitted</span>
 <span class="s3">* events. The expected argument is the same as the component `emits` option.</span>
 <span class="s3">*</span>
 <span class="s3">* Example runtime declaration:</span>
 <span class="s3">* ```js</span>
 <span class="s3">* const emit = defineEmits(['change', 'update'])</span>
 <span class="s3">* ```</span>
 <span class="s3">*</span>
 <span class="s3">* Example type-based declaration:</span>
 <span class="s3">* ```ts</span>
 <span class="s3">* const emit = defineEmits&lt;{</span>
 <span class="s3">*   (event: 'change'): void</span>
 <span class="s3">*   (event: 'update', id: number): void</span>
 <span class="s3">* }&gt;()</span>
 <span class="s3">*</span>
 <span class="s3">* emit('change')</span>
 <span class="s3">* emit('update', 1)</span>
 <span class="s3">* ```</span>
 <span class="s3">*</span>
 <span class="s3">* This is only usable inside `&lt;script setup&gt;`, is compiled away in the</span>
 <span class="s3">* output and should **not** be actually called at runtime.</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">defineEmits&lt;EE </span><span class="s0">extends </span><span class="s1">string = string&gt;(emitOptions: EE[]): EmitFn&lt;EE[]&gt;</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">defineEmits&lt;E </span><span class="s0">extends </span><span class="s1">EmitsOptions = EmitsOptions&gt;(emitOptions: E): EmitFn&lt;E&gt;</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">defineEmits&lt;TypeEmit&gt;(): TypeEmit</span><span class="s0">;</span>

<span class="s3">/**</span>
 <span class="s3">* Vue `&lt;script setup&gt;` compiler macro for declaring a component's exposed</span>
 <span class="s3">* instance properties when it is accessed by a parent component via template</span>
 <span class="s3">* refs.</span>
 <span class="s3">*</span>
 <span class="s3">* `&lt;script setup&gt;` components are closed by default - i.e. variables inside</span>
 <span class="s3">* the `&lt;script setup&gt;` scope is not exposed to parent unless explicitly exposed</span>
 <span class="s3">* via `defineExpose`.</span>
 <span class="s3">*</span>
 <span class="s3">* This is only usable inside `&lt;script setup&gt;`, is compiled away in the</span>
 <span class="s3">* output and should **not** be actually called at runtime.</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">defineExpose&lt;Exposed </span><span class="s0">extends </span><span class="s1">Record&lt;string</span><span class="s0">, </span><span class="s1">any&gt; = Record&lt;string</span><span class="s0">, </span><span class="s1">any&gt;&gt;(exposed?: Exposed): </span><span class="s0">void;</span>

<span class="s3">/**</span>
 <span class="s3">* Vue `&lt;script setup&gt;` compiler macro for declaring component props. The</span>
 <span class="s3">* expected argument is the same as the component `props` option.</span>
 <span class="s3">*</span>
 <span class="s3">* Example runtime declaration:</span>
 <span class="s3">* ```js</span>
 <span class="s3">* // using Array syntax</span>
 <span class="s3">* const props = defineProps(['foo', 'bar'])</span>
 <span class="s3">* // using Object syntax</span>
 <span class="s3">* const props = defineProps({</span>
 <span class="s3">*   foo: String,</span>
 <span class="s3">*   bar: {</span>
 <span class="s3">*     type: Number,</span>
 <span class="s3">*     required: true</span>
 <span class="s3">*   }</span>
 <span class="s3">* })</span>
 <span class="s3">* ```</span>
 <span class="s3">*</span>
 <span class="s3">* Equivalent type-based declaration:</span>
 <span class="s3">* ```ts</span>
 <span class="s3">* // will be compiled into equivalent runtime declarations</span>
 <span class="s3">* const props = defineProps&lt;{</span>
 <span class="s3">*   foo?: string</span>
 <span class="s3">*   bar: number</span>
 <span class="s3">* }&gt;()</span>
 <span class="s3">* ```</span>
 <span class="s3">*</span>
 <span class="s3">* This is only usable inside `&lt;script setup&gt;`, is compiled away in the</span>
 <span class="s3">* output and should **not** be actually called at runtime.</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">defineProps&lt;PropNames </span><span class="s0">extends </span><span class="s1">string = string&gt;(props: PropNames[]): Readonly&lt;{</span>
    <span class="s1">[key </span><span class="s0">in </span><span class="s1">PropNames]?: any</span><span class="s0">;</span>
<span class="s1">}&gt;</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">defineProps&lt;PP </span><span class="s0">extends </span><span class="s1">ComponentObjectPropsOptions = ComponentObjectPropsOptions&gt;(props: PP): Readonly&lt;ExtractPropTypes&lt;PP&gt;&gt;</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">defineProps&lt;TypeProps&gt;(): Readonly&lt;Omit&lt;TypeProps</span><span class="s0">, </span><span class="s1">BooleanKey&lt;TypeProps&gt;&gt; &amp; {</span>
    <span class="s1">[K </span><span class="s0">in </span><span class="s1">keyof Pick&lt;TypeProps</span><span class="s0">, </span><span class="s1">BooleanKey&lt;TypeProps&gt;&gt;]-?: NotUndefined&lt;TypeProps[K]&gt;</span><span class="s0">;</span>
<span class="s1">}&gt;</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">const enum </span><span class="s1">DeprecationTypes {</span>
    <span class="s1">GLOBAL_MOUNT = </span><span class="s2">&quot;GLOBAL_MOUNT&quot;</span><span class="s0">,</span>
    <span class="s1">GLOBAL_MOUNT_CONTAINER = </span><span class="s2">&quot;GLOBAL_MOUNT_CONTAINER&quot;</span><span class="s0">,</span>
    <span class="s1">GLOBAL_EXTEND = </span><span class="s2">&quot;GLOBAL_EXTEND&quot;</span><span class="s0">,</span>
    <span class="s1">GLOBAL_PROTOTYPE = </span><span class="s2">&quot;GLOBAL_PROTOTYPE&quot;</span><span class="s0">,</span>
    <span class="s1">GLOBAL_SET = </span><span class="s2">&quot;GLOBAL_SET&quot;</span><span class="s0">,</span>
    <span class="s1">GLOBAL_DELETE = </span><span class="s2">&quot;GLOBAL_DELETE&quot;</span><span class="s0">,</span>
    <span class="s1">GLOBAL_OBSERVABLE = </span><span class="s2">&quot;GLOBAL_OBSERVABLE&quot;</span><span class="s0">,</span>
    <span class="s1">GLOBAL_PRIVATE_UTIL = </span><span class="s2">&quot;GLOBAL_PRIVATE_UTIL&quot;</span><span class="s0">,</span>
    <span class="s1">CONFIG_SILENT = </span><span class="s2">&quot;CONFIG_SILENT&quot;</span><span class="s0">,</span>
    <span class="s1">CONFIG_DEVTOOLS = </span><span class="s2">&quot;CONFIG_DEVTOOLS&quot;</span><span class="s0">,</span>
    <span class="s1">CONFIG_KEY_CODES = </span><span class="s2">&quot;CONFIG_KEY_CODES&quot;</span><span class="s0">,</span>
    <span class="s1">CONFIG_PRODUCTION_TIP = </span><span class="s2">&quot;CONFIG_PRODUCTION_TIP&quot;</span><span class="s0">,</span>
    <span class="s1">CONFIG_IGNORED_ELEMENTS = </span><span class="s2">&quot;CONFIG_IGNORED_ELEMENTS&quot;</span><span class="s0">,</span>
    <span class="s1">CONFIG_WHITESPACE = </span><span class="s2">&quot;CONFIG_WHITESPACE&quot;</span><span class="s0">,</span>
    <span class="s1">CONFIG_OPTION_MERGE_STRATS = </span><span class="s2">&quot;CONFIG_OPTION_MERGE_STRATS&quot;</span><span class="s0">,</span>
    <span class="s1">INSTANCE_SET = </span><span class="s2">&quot;INSTANCE_SET&quot;</span><span class="s0">,</span>
    <span class="s1">INSTANCE_DELETE = </span><span class="s2">&quot;INSTANCE_DELETE&quot;</span><span class="s0">,</span>
    <span class="s1">INSTANCE_DESTROY = </span><span class="s2">&quot;INSTANCE_DESTROY&quot;</span><span class="s0">,</span>
    <span class="s1">INSTANCE_EVENT_EMITTER = </span><span class="s2">&quot;INSTANCE_EVENT_EMITTER&quot;</span><span class="s0">,</span>
    <span class="s1">INSTANCE_EVENT_HOOKS = </span><span class="s2">&quot;INSTANCE_EVENT_HOOKS&quot;</span><span class="s0">,</span>
    <span class="s1">INSTANCE_CHILDREN = </span><span class="s2">&quot;INSTANCE_CHILDREN&quot;</span><span class="s0">,</span>
    <span class="s1">INSTANCE_LISTENERS = </span><span class="s2">&quot;INSTANCE_LISTENERS&quot;</span><span class="s0">,</span>
    <span class="s1">INSTANCE_SCOPED_SLOTS = </span><span class="s2">&quot;INSTANCE_SCOPED_SLOTS&quot;</span><span class="s0">,</span>
    <span class="s1">INSTANCE_ATTRS_CLASS_STYLE = </span><span class="s2">&quot;INSTANCE_ATTRS_CLASS_STYLE&quot;</span><span class="s0">,</span>
    <span class="s1">OPTIONS_DATA_FN = </span><span class="s2">&quot;OPTIONS_DATA_FN&quot;</span><span class="s0">,</span>
    <span class="s1">OPTIONS_DATA_MERGE = </span><span class="s2">&quot;OPTIONS_DATA_MERGE&quot;</span><span class="s0">,</span>
    <span class="s1">OPTIONS_BEFORE_DESTROY = </span><span class="s2">&quot;OPTIONS_BEFORE_DESTROY&quot;</span><span class="s0">,</span>
    <span class="s1">OPTIONS_DESTROYED = </span><span class="s2">&quot;OPTIONS_DESTROYED&quot;</span><span class="s0">,</span>
    <span class="s1">WATCH_ARRAY = </span><span class="s2">&quot;WATCH_ARRAY&quot;</span><span class="s0">,</span>
    <span class="s1">PROPS_DEFAULT_THIS = </span><span class="s2">&quot;PROPS_DEFAULT_THIS&quot;</span><span class="s0">,</span>
    <span class="s1">V_ON_KEYCODE_MODIFIER = </span><span class="s2">&quot;V_ON_KEYCODE_MODIFIER&quot;</span><span class="s0">,</span>
    <span class="s1">CUSTOM_DIR = </span><span class="s2">&quot;CUSTOM_DIR&quot;</span><span class="s0">,</span>
    <span class="s1">ATTR_FALSE_VALUE = </span><span class="s2">&quot;ATTR_FALSE_VALUE&quot;</span><span class="s0">,</span>
    <span class="s1">ATTR_ENUMERATED_COERCION = </span><span class="s2">&quot;ATTR_ENUMERATED_COERCION&quot;</span><span class="s0">,</span>
    <span class="s1">TRANSITION_CLASSES = </span><span class="s2">&quot;TRANSITION_CLASSES&quot;</span><span class="s0">,</span>
    <span class="s1">TRANSITION_GROUP_ROOT = </span><span class="s2">&quot;TRANSITION_GROUP_ROOT&quot;</span><span class="s0">,</span>
    <span class="s1">COMPONENT_ASYNC = </span><span class="s2">&quot;COMPONENT_ASYNC&quot;</span><span class="s0">,</span>
    <span class="s1">COMPONENT_FUNCTIONAL = </span><span class="s2">&quot;COMPONENT_FUNCTIONAL&quot;</span><span class="s0">,</span>
    <span class="s1">COMPONENT_V_MODEL = </span><span class="s2">&quot;COMPONENT_V_MODEL&quot;</span><span class="s0">,</span>
    <span class="s1">RENDER_FUNCTION = </span><span class="s2">&quot;RENDER_FUNCTION&quot;</span><span class="s0">,</span>
    <span class="s1">FILTERS = </span><span class="s2">&quot;FILTERS&quot;</span><span class="s0">,</span>
    <span class="s1">PRIVATE_APIS = </span><span class="s2">&quot;PRIVATE_APIS&quot;</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">let </span><span class="s1">devtools: DevtoolsHook</span><span class="s0">;</span>

<span class="s1">declare </span><span class="s0">interface </span><span class="s1">DevtoolsHook {</span>
    <span class="s1">enabled?: boolean</span><span class="s0">;</span>
    <span class="s1">emit: (event: string</span><span class="s0">, </span><span class="s1">...payload: any[]) =&gt; </span><span class="s0">void;</span>
    <span class="s1">on: (event: string</span><span class="s0">, </span><span class="s1">handler: Function) =&gt; </span><span class="s0">void;</span>
    <span class="s1">once: (event: string</span><span class="s0">, </span><span class="s1">handler: Function) =&gt; </span><span class="s0">void;</span>
    <span class="s1">off: (event: string</span><span class="s0">, </span><span class="s1">handler: Function) =&gt; </span><span class="s0">void;</span>
    <span class="s1">appRecords: AppRecord[]</span><span class="s0">;</span>
    <span class="s3">/**</span>
     <span class="s3">* Added at https://github.com/vuejs/devtools/commit/f2ad51eea789006ab66942e5a27c0f0986a257f9</span>
     <span class="s3">* Returns wether the arg was buffered or not</span>
     <span class="s3">*/</span>
    <span class="s1">cleanupBuffer?: (matchArg: unknown) =&gt; boolean</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">declare type Directive&lt;T = any</span><span class="s0">, </span><span class="s1">V = any&gt; = ObjectDirective&lt;T</span><span class="s0">, </span><span class="s1">V&gt; | FunctionDirective&lt;T</span><span class="s0">, </span><span class="s1">V&gt;</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare type DirectiveArguments = Array&lt;[Directive | undefined] | [Directive | undefined</span><span class="s0">, </span><span class="s1">any] | [Directive | undefined</span><span class="s0">, </span><span class="s1">any</span><span class="s0">, </span><span class="s1">string] | [Directive | undefined</span><span class="s0">, </span><span class="s1">any</span><span class="s0">, </span><span class="s1">string</span><span class="s0">, </span><span class="s1">DirectiveModifiers]&gt;</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">interface </span><span class="s1">DirectiveBinding&lt;V = any&gt; {</span>
    <span class="s1">instance: ComponentPublicInstance | </span><span class="s0">null;</span>
    <span class="s1">value: V</span><span class="s0">;</span>
    <span class="s1">oldValue: V | </span><span class="s0">null;</span>
    <span class="s1">arg?: string</span><span class="s0">;</span>
    <span class="s1">modifiers: DirectiveModifiers</span><span class="s0">;</span>
    <span class="s1">dir: ObjectDirective&lt;any</span><span class="s0">, </span><span class="s1">V&gt;</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">declare type DirectiveHook&lt;T = any</span><span class="s0">, </span><span class="s1">Prev = VNode&lt;any</span><span class="s0">, </span><span class="s1">T&gt; | </span><span class="s0">null, </span><span class="s1">V = any&gt; = (el: T</span><span class="s0">, </span><span class="s1">binding: DirectiveBinding&lt;V&gt;</span><span class="s0">, </span><span class="s1">vnode: VNode&lt;any</span><span class="s0">, </span><span class="s1">T&gt;</span><span class="s0">, </span><span class="s1">prevVNode: Prev) =&gt; </span><span class="s0">void;</span>

<span class="s1">declare type DirectiveModifiers = Record&lt;string</span><span class="s0">, </span><span class="s1">boolean&gt;</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">{ effect }</span>

<span class="s0">export </span><span class="s1">{ EffectScheduler }</span>

<span class="s0">export </span><span class="s1">{ EffectScope }</span>

<span class="s0">export </span><span class="s1">{ effectScope }</span>

<span class="s1">declare type EmitFn&lt;Options = ObjectEmitsOptions</span><span class="s0">, </span><span class="s1">Event </span><span class="s0">extends </span><span class="s1">keyof Options = keyof Options&gt; = Options </span><span class="s0">extends </span><span class="s1">Array&lt;infer V&gt; ? (event: V</span><span class="s0">, </span><span class="s1">...args: any[]) =&gt; </span><span class="s0">void </span><span class="s1">: {} </span><span class="s0">extends </span><span class="s1">Options ? (event: string</span><span class="s0">, </span><span class="s1">...args: any[]) =&gt; </span><span class="s0">void </span><span class="s1">: UnionToIntersection&lt;{</span>
    <span class="s1">[key </span><span class="s0">in </span><span class="s1">Event]: Options[key] </span><span class="s0">extends </span><span class="s1">(...args: infer Args) =&gt; any ? (event: key</span><span class="s0">, </span><span class="s1">...args: Args) =&gt; </span><span class="s0">void </span><span class="s1">: (event: key</span><span class="s0">, </span><span class="s1">...args: any[]) =&gt; </span><span class="s0">void;</span>
<span class="s1">}[Event]&gt;</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare type EmitsOptions = ObjectEmitsOptions | string[]</span><span class="s0">;</span>

<span class="s1">declare type EmitsToProps&lt;T </span><span class="s0">extends </span><span class="s1">EmitsOptions&gt; = T </span><span class="s0">extends </span><span class="s1">string[] ? {</span>
    <span class="s1">[K </span><span class="s0">in </span><span class="s1">string &amp; </span><span class="s2">`on</span><span class="s1">${Capitalize&lt;T[number]&gt;}</span><span class="s2">`</span><span class="s1">]?: (...args: any[]) =&gt; any</span><span class="s0">;</span>
<span class="s1">} : T </span><span class="s0">extends </span><span class="s1">ObjectEmitsOptions ? {</span>
    <span class="s1">[K </span><span class="s0">in </span><span class="s1">string &amp; </span><span class="s2">`on</span><span class="s1">${Capitalize&lt;string &amp; keyof T&gt;}</span><span class="s2">`</span><span class="s1">]?: K </span><span class="s0">extends </span><span class="s2">`on</span><span class="s1">${infer C}</span><span class="s2">` </span><span class="s1">? T[Uncapitalize&lt;C&gt;] </span><span class="s0">extends null </span><span class="s1">? (...args: any[]) =&gt; any : (...args: T[Uncapitalize&lt;C&gt;] </span><span class="s0">extends </span><span class="s1">(...args: infer P) =&gt; any ? P : never) =&gt; any : never</span><span class="s0">;</span>
<span class="s1">} : {}</span><span class="s0">;</span>

<span class="s1">declare type EnsureNonVoid&lt;T&gt; = T </span><span class="s0">extends void </span><span class="s1">? {} : T</span><span class="s0">;</span>

<span class="s1">declare type ErrorCapturedHook&lt;TError = unknown&gt; = (err: TError</span><span class="s0">, </span><span class="s1">instance: ComponentPublicInstance | </span><span class="s0">null, </span><span class="s1">info: string) =&gt; boolean | </span><span class="s0">void;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">const enum </span><span class="s1">ErrorCodes {</span>
    <span class="s1">SETUP_FUNCTION = </span><span class="s6">0</span><span class="s0">,</span>
    <span class="s1">RENDER_FUNCTION = </span><span class="s6">1</span><span class="s0">,</span>
    <span class="s1">WATCH_GETTER = </span><span class="s6">2</span><span class="s0">,</span>
    <span class="s1">WATCH_CALLBACK = </span><span class="s6">3</span><span class="s0">,</span>
    <span class="s1">WATCH_CLEANUP = </span><span class="s6">4</span><span class="s0">,</span>
    <span class="s1">NATIVE_EVENT_HANDLER = </span><span class="s6">5</span><span class="s0">,</span>
    <span class="s1">COMPONENT_EVENT_HANDLER = </span><span class="s6">6</span><span class="s0">,</span>
    <span class="s1">VNODE_HOOK = </span><span class="s6">7</span><span class="s0">,</span>
    <span class="s1">DIRECTIVE_HOOK = </span><span class="s6">8</span><span class="s0">,</span>
    <span class="s1">TRANSITION_HOOK = </span><span class="s6">9</span><span class="s0">,</span>
    <span class="s1">APP_ERROR_HANDLER = </span><span class="s6">10</span><span class="s0">,</span>
    <span class="s1">APP_WARN_HANDLER = </span><span class="s6">11</span><span class="s0">,</span>
    <span class="s1">FUNCTION_REF = </span><span class="s6">12</span><span class="s0">,</span>
    <span class="s1">ASYNC_COMPONENT_LOADER = </span><span class="s6">13</span><span class="s0">,</span>
    <span class="s1">SCHEDULER = </span><span class="s6">14</span>
<span class="s1">}</span>

<span class="s1">declare type ErrorTypes = LifecycleHooks | ErrorCodes</span><span class="s0">;</span>

<span class="s1">declare type ExtractComputedReturns&lt;T </span><span class="s0">extends </span><span class="s1">any&gt; = {</span>
    <span class="s1">[key </span><span class="s0">in </span><span class="s1">keyof T]: T[key] </span><span class="s0">extends </span><span class="s1">{</span>
        <span class="s1">get: (...args: any[]) =&gt; infer TReturn</span><span class="s0">;</span>
    <span class="s1">} ? TReturn : T[key] </span><span class="s0">extends </span><span class="s1">(...args: any[]) =&gt; infer TReturn ? TReturn : never</span><span class="s0">;</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare type ExtractDefaultPropTypes&lt;O&gt; = O </span><span class="s0">extends </span><span class="s1">object ? {</span>
    <span class="s1">[K </span><span class="s0">in </span><span class="s1">keyof Pick&lt;O</span><span class="s0">, </span><span class="s1">DefaultKeys&lt;O&gt;&gt;]: InferPropType&lt;O[K]&gt;</span><span class="s0">;</span>
<span class="s1">} : {}</span><span class="s0">;</span>

<span class="s1">declare type ExtractMixin&lt;T&gt; = {</span>
    <span class="s1">Mixin: MixinToOptionTypes&lt;T&gt;</span><span class="s0">;</span>
<span class="s1">}[T </span><span class="s0">extends </span><span class="s1">ComponentOptionsMixin ? </span><span class="s2">'Mixin' </span><span class="s1">: never]</span><span class="s0">;</span>

<span class="s1">declare type ExtractOptionProp&lt;T&gt; = T </span><span class="s0">extends </span><span class="s1">ComponentOptionsBase&lt;infer P</span><span class="s0">, </span><span class="s4">// Props</span>
<span class="s1">any</span><span class="s0">, </span><span class="s4">// RawBindings</span>
<span class="s1">any</span><span class="s0">, </span><span class="s4">// D</span>
<span class="s1">any</span><span class="s0">, </span><span class="s4">// C</span>
<span class="s1">any</span><span class="s0">, </span><span class="s4">// M</span>
<span class="s1">any</span><span class="s0">, </span><span class="s4">// Mixin</span>
<span class="s1">any</span><span class="s0">, </span><span class="s4">// Extends</span>
<span class="s1">any&gt; ? unknown </span><span class="s0">extends </span><span class="s1">P ? {} : P : {}</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare type ExtractPropTypes&lt;O&gt; = {</span>
    <span class="s1">[K </span><span class="s0">in </span><span class="s1">keyof Pick&lt;O</span><span class="s0">, </span><span class="s1">RequiredKeys&lt;O&gt;&gt;]: InferPropType&lt;O[K]&gt;</span><span class="s0">;</span>
<span class="s1">} &amp; {</span>
    <span class="s1">[K </span><span class="s0">in </span><span class="s1">keyof Pick&lt;O</span><span class="s0">, </span><span class="s1">OptionalKeys&lt;O&gt;&gt;]?: InferPropType&lt;O[K]&gt;</span><span class="s0">;</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">const </span><span class="s1">Fragment: {</span>
    <span class="s0">new </span><span class="s1">(): {</span>
        <span class="s1">$props: VNodeProps</span><span class="s0">;</span>
    <span class="s1">}</span><span class="s0">;</span>
    <span class="s1">__isFragment: </span><span class="s0">true;</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">interface </span><span class="s1">FunctionalComponent&lt;P = {}</span><span class="s0">, </span><span class="s1">E </span><span class="s0">extends </span><span class="s1">EmitsOptions = {}&gt; </span><span class="s0">extends </span><span class="s1">ComponentInternalOptions {</span>
    <span class="s1">(props: P</span><span class="s0">, </span><span class="s1">ctx: Omit&lt;SetupContext&lt;E&gt;</span><span class="s0">, </span><span class="s2">'expose'</span><span class="s1">&gt;): any</span><span class="s0">;</span>
    <span class="s1">props?: ComponentPropsOptions&lt;P&gt;</span><span class="s0">;</span>
    <span class="s1">emits?: E | (keyof E)[]</span><span class="s0">;</span>
    <span class="s1">inheritAttrs?: boolean</span><span class="s0">;</span>
    <span class="s1">displayName?: string</span><span class="s0">;</span>
    <span class="s1">compatConfig?: CompatConfig</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">declare type FunctionDirective&lt;T = any</span><span class="s0">, </span><span class="s1">V = any&gt; = DirectiveHook&lt;T</span><span class="s0">, </span><span class="s1">any</span><span class="s0">, </span><span class="s1">V&gt;</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">const </span><span class="s1">getCurrentInstance: () =&gt; ComponentInternalInstance | </span><span class="s0">null;</span>

<span class="s0">export </span><span class="s1">{ getCurrentScope }</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">getTransitionRawChildren(children: VNode[]</span><span class="s0">, </span><span class="s1">keepComment?: boolean</span><span class="s0">, </span><span class="s1">parentKey?: VNode[</span><span class="s2">'key'</span><span class="s1">]): VNode[]</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">guardReactiveProps(props: (Data &amp; VNodeProps) | </span><span class="s0">null</span><span class="s1">): (Data &amp; VNodeProps) | </span><span class="s0">null;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">h(type: string</span><span class="s0">, </span><span class="s1">children?: RawChildren): VNode</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">h(type: string</span><span class="s0">, </span><span class="s1">props?: RawProps | </span><span class="s0">null, </span><span class="s1">children?: RawChildren | RawSlots): VNode</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">h(type: </span><span class="s0">typeof </span><span class="s1">Text_2 | </span><span class="s0">typeof </span><span class="s1">Comment_2</span><span class="s0">, </span><span class="s1">children?: string | number | boolean): VNode</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">h(type: </span><span class="s0">typeof </span><span class="s1">Text_2 | </span><span class="s0">typeof </span><span class="s1">Comment_2</span><span class="s0">, </span><span class="s1">props?: </span><span class="s0">null, </span><span class="s1">children?: string | number | boolean): VNode</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">h(type: </span><span class="s0">typeof </span><span class="s1">Fragment</span><span class="s0">, </span><span class="s1">children?: VNodeArrayChildren): VNode</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">h(type: </span><span class="s0">typeof </span><span class="s1">Fragment</span><span class="s0">, </span><span class="s1">props?: RawProps | </span><span class="s0">null, </span><span class="s1">children?: VNodeArrayChildren): VNode</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">h(type: </span><span class="s0">typeof </span><span class="s1">Teleport</span><span class="s0">, </span><span class="s1">props: RawProps &amp; TeleportProps</span><span class="s0">, </span><span class="s1">children: RawChildren | RawSlots): VNode</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">h(type: </span><span class="s0">typeof </span><span class="s1">Suspense</span><span class="s0">, </span><span class="s1">children?: RawChildren): VNode</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">h(type: </span><span class="s0">typeof </span><span class="s1">Suspense</span><span class="s0">, </span><span class="s1">props?: (RawProps &amp; SuspenseProps) | </span><span class="s0">null, </span><span class="s1">children?: RawChildren | RawSlots): VNode</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">h&lt;P</span><span class="s0">, </span><span class="s1">E </span><span class="s0">extends </span><span class="s1">EmitsOptions = {}&gt;(type: FunctionalComponent&lt;P</span><span class="s0">, </span><span class="s1">E&gt;</span><span class="s0">, </span><span class="s1">props?: (RawProps &amp; P) | ({} </span><span class="s0">extends </span><span class="s1">P ? </span><span class="s0">null </span><span class="s1">: never)</span><span class="s0">, </span><span class="s1">children?: RawChildren | RawSlots): VNode</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">h(type: Component</span><span class="s0">, </span><span class="s1">children?: RawChildren): VNode</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">h&lt;P&gt;(type: ConcreteComponent | string</span><span class="s0">, </span><span class="s1">children?: RawChildren): VNode</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">h&lt;P&gt;(type: ConcreteComponent&lt;P&gt; | string</span><span class="s0">, </span><span class="s1">props?: (RawProps &amp; P) | ({} </span><span class="s0">extends </span><span class="s1">P ? </span><span class="s0">null </span><span class="s1">: never)</span><span class="s0">, </span><span class="s1">children?: RawChildren): VNode</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">h&lt;P&gt;(type: Component&lt;P&gt;</span><span class="s0">, </span><span class="s1">props?: (RawProps &amp; P) | </span><span class="s0">null, </span><span class="s1">children?: RawChildren | RawSlots): VNode</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">h&lt;P&gt;(type: ComponentOptions&lt;P&gt;</span><span class="s0">, </span><span class="s1">props?: (RawProps &amp; P) | ({} </span><span class="s0">extends </span><span class="s1">P ? </span><span class="s0">null </span><span class="s1">: never)</span><span class="s0">, </span><span class="s1">children?: RawChildren | RawSlots): VNode</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">h(type: Constructor</span><span class="s0">, </span><span class="s1">children?: RawChildren): VNode</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">h&lt;P&gt;(type: Constructor&lt;P&gt;</span><span class="s0">, </span><span class="s1">props?: (RawProps &amp; P) | ({} </span><span class="s0">extends </span><span class="s1">P ? </span><span class="s0">null </span><span class="s1">: never)</span><span class="s0">, </span><span class="s1">children?: RawChildren | RawSlots): VNode</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">h(type: DefineComponent</span><span class="s0">, </span><span class="s1">children?: RawChildren): VNode</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">h&lt;P&gt;(type: DefineComponent&lt;P&gt;</span><span class="s0">, </span><span class="s1">props?: (RawProps &amp; P) | ({} </span><span class="s0">extends </span><span class="s1">P ? </span><span class="s0">null </span><span class="s1">: never)</span><span class="s0">, </span><span class="s1">children?: RawChildren | RawSlots): VNode</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">handleError(err: unknown</span><span class="s0">, </span><span class="s1">instance: ComponentInternalInstance | </span><span class="s0">null, </span><span class="s1">type: ErrorTypes</span><span class="s0">, </span><span class="s1">throwInDev?: boolean): </span><span class="s0">void;</span>

<span class="s1">declare type HMRComponent = ComponentOptions | ClassComponent</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">interface </span><span class="s1">HMRRuntime {</span>
    <span class="s1">createRecord: </span><span class="s0">typeof </span><span class="s1">createRecord</span><span class="s0">;</span>
    <span class="s1">rerender: </span><span class="s0">typeof </span><span class="s1">rerender</span><span class="s0">;</span>
    <span class="s1">reload: </span><span class="s0">typeof </span><span class="s1">reload</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s1">declare type Hook&lt;T = () =&gt; </span><span class="s0">void</span><span class="s1">&gt; = T | T[]</span><span class="s0">;</span>

<span class="s1">declare </span><span class="s0">function </span><span class="s1">hydrateSuspense(node: Node</span><span class="s0">, </span><span class="s1">vnode: VNode</span><span class="s0">, </span><span class="s1">parentComponent: ComponentInternalInstance | </span><span class="s0">null, </span><span class="s1">parentSuspense: SuspenseBoundary | </span><span class="s0">null, </span><span class="s1">isSVG: boolean</span><span class="s0">, </span><span class="s1">slotScopeIds: string[] | </span><span class="s0">null, </span><span class="s1">optimized: boolean</span><span class="s0">, </span><span class="s1">rendererInternals: RendererInternals</span><span class="s0">, </span><span class="s1">hydrateNode: (node: Node</span><span class="s0">, </span><span class="s1">vnode: VNode</span><span class="s0">, </span><span class="s1">parentComponent: ComponentInternalInstance | </span><span class="s0">null, </span><span class="s1">parentSuspense: SuspenseBoundary | </span><span class="s0">null, </span><span class="s1">slotScopeIds: string[] | </span><span class="s0">null, </span><span class="s1">optimized: boolean) =&gt; Node | </span><span class="s0">null</span><span class="s1">): Node | </span><span class="s0">null;</span>

<span class="s1">declare </span><span class="s0">function </span><span class="s1">hydrateTeleport(node: Node</span><span class="s0">, </span><span class="s1">vnode: TeleportVNode</span><span class="s0">, </span><span class="s1">parentComponent: ComponentInternalInstance | </span><span class="s0">null, </span><span class="s1">parentSuspense: SuspenseBoundary | </span><span class="s0">null, </span><span class="s1">slotScopeIds: string[] | </span><span class="s0">null, </span><span class="s1">optimized: boolean</span><span class="s0">, </span><span class="s1">{ o: { nextSibling</span><span class="s0">, </span><span class="s1">parentNode</span><span class="s0">, </span><span class="s1">querySelector } }: RendererInternals&lt;Node</span><span class="s0">, </span><span class="s1">Element&gt;</span><span class="s0">, </span><span class="s1">hydrateChildren: (node: Node | </span><span class="s0">null, </span><span class="s1">vnode: VNode</span><span class="s0">, </span><span class="s1">container: Element</span><span class="s0">, </span><span class="s1">parentComponent: ComponentInternalInstance | </span><span class="s0">null, </span><span class="s1">parentSuspense: SuspenseBoundary | </span><span class="s0">null, </span><span class="s1">slotScopeIds: string[] | </span><span class="s0">null, </span><span class="s1">optimized: boolean) =&gt; Node | </span><span class="s0">null</span><span class="s1">): Node | </span><span class="s0">null;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">interface </span><span class="s1">HydrationRenderer </span><span class="s0">extends </span><span class="s1">Renderer&lt;Element | ShadowRoot&gt; {</span>
    <span class="s1">hydrate: RootHydrateFunction</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s1">declare type InferDefault&lt;P</span><span class="s0">, </span><span class="s1">T&gt; = T </span><span class="s0">extends null </span><span class="s1">| number | string | boolean | symbol | Function ? T | ((props: P) =&gt; T) : (props: P) =&gt; T</span><span class="s0">;</span>

<span class="s1">declare type InferDefaults&lt;T&gt; = {</span>
    <span class="s1">[K </span><span class="s0">in </span><span class="s1">keyof T]?: InferDefault&lt;T</span><span class="s0">, </span><span class="s1">NotUndefined&lt;T[K]&gt;&gt;</span><span class="s0">;</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s1">declare type InferPropType&lt;T&gt; = [T] </span><span class="s0">extends </span><span class="s1">[</span><span class="s0">null</span><span class="s1">] ? any : [T] </span><span class="s0">extends </span><span class="s1">[{</span>
    <span class="s1">type: </span><span class="s0">null </span><span class="s1">| </span><span class="s0">true;</span>
<span class="s1">}] ? any : [T] </span><span class="s0">extends </span><span class="s1">[ObjectConstructor | {</span>
    <span class="s1">type: ObjectConstructor</span><span class="s0">;</span>
<span class="s1">}] ? Record&lt;string</span><span class="s0">, </span><span class="s1">any&gt; : [T] </span><span class="s0">extends </span><span class="s1">[BooleanConstructor | {</span>
    <span class="s1">type: BooleanConstructor</span><span class="s0">;</span>
<span class="s1">}] ? boolean : [T] </span><span class="s0">extends </span><span class="s1">[DateConstructor | {</span>
    <span class="s1">type: DateConstructor</span><span class="s0">;</span>
<span class="s1">}] ? Date : [T] </span><span class="s0">extends </span><span class="s1">[(infer U)[] | {</span>
    <span class="s1">type: (infer U)[]</span><span class="s0">;</span>
<span class="s1">}] ? U </span><span class="s0">extends </span><span class="s1">DateConstructor ? Date | InferPropType&lt;U&gt; : InferPropType&lt;U&gt; : [T] </span><span class="s0">extends </span><span class="s1">[Prop&lt;infer V</span><span class="s0">, </span><span class="s1">infer D&gt;] ? unknown </span><span class="s0">extends </span><span class="s1">V ? IfAny&lt;V</span><span class="s0">, </span><span class="s1">V</span><span class="s0">, </span><span class="s1">D&gt; : V : T</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">initCustomFormatter(): </span><span class="s0">void;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">inject&lt;T&gt;(key: InjectionKey&lt;T&gt; | string): T | undefined</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">inject&lt;T&gt;(key: InjectionKey&lt;T&gt; | string</span><span class="s0">, </span><span class="s1">defaultValue: T</span><span class="s0">, </span><span class="s1">treatDefaultAsFactory?: </span><span class="s0">false</span><span class="s1">): T</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">inject&lt;T&gt;(key: InjectionKey&lt;T&gt; | string</span><span class="s0">, </span><span class="s1">defaultValue: T | (() =&gt; T)</span><span class="s0">, </span><span class="s1">treatDefaultAsFactory: </span><span class="s0">true</span><span class="s1">): T</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">interface </span><span class="s1">InjectionKey&lt;T&gt; </span><span class="s0">extends </span><span class="s1">Symbol {</span>
<span class="s1">}</span>

<span class="s1">declare type InjectToObject&lt;T </span><span class="s0">extends </span><span class="s1">ComponentInjectOptions&gt; = T </span><span class="s0">extends </span><span class="s1">string[] ? {</span>
    <span class="s1">[K </span><span class="s0">in </span><span class="s1">T[number]]?: unknown</span><span class="s0">;</span>
<span class="s1">} : T </span><span class="s0">extends </span><span class="s1">ObjectInjectOptions ? {</span>
    <span class="s1">[K </span><span class="s0">in </span><span class="s1">keyof T]?: unknown</span><span class="s0">;</span>
<span class="s1">} : never</span><span class="s0">;</span>

<span class="s4">/* Excluded from this release type: InternalRenderFunction */</span>

<span class="s1">declare type InternalSlots = {</span>
    <span class="s1">[name: string]: Slot | undefined</span><span class="s0">;</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s1">declare type IntersectionMixin&lt;T&gt; = IsDefaultMixinComponent&lt;T&gt; </span><span class="s0">extends true </span><span class="s1">? OptionTypesType&lt;{}</span><span class="s0">, </span><span class="s1">{}</span><span class="s0">, </span><span class="s1">{}</span><span class="s0">, </span><span class="s1">{}</span><span class="s0">, </span><span class="s1">{}&gt; : UnionToIntersection&lt;ExtractMixin&lt;T&gt;&gt;</span><span class="s0">;</span>

<span class="s1">declare </span><span class="s0">function </span><span class="s1">isCompatEnabled(key: DeprecationTypes</span><span class="s0">, </span><span class="s1">instance: ComponentInternalInstance | </span><span class="s0">null, </span><span class="s1">enableForBuiltIn?: boolean): boolean</span><span class="s0">;</span>

<span class="s1">declare type IsDefaultMixinComponent&lt;T&gt; = T </span><span class="s0">extends </span><span class="s1">ComponentOptionsMixin ? ComponentOptionsMixin </span><span class="s0">extends </span><span class="s1">T ? </span><span class="s0">true </span><span class="s1">: </span><span class="s0">false </span><span class="s1">: </span><span class="s0">false;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">isMemoSame(cached: VNode</span><span class="s0">, </span><span class="s1">memo: any[]): boolean</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">{ isProxy }</span>

<span class="s0">export </span><span class="s1">{ isReactive }</span>

<span class="s0">export </span><span class="s1">{ isReadonly }</span>

<span class="s0">export </span><span class="s1">{ isRef }</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">const </span><span class="s1">isRuntimeOnly: () =&gt; boolean</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">{ isShallow }</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">isVNode(value: any): value is VNode</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">const </span><span class="s1">KeepAlive: {</span>
    <span class="s0">new </span><span class="s1">(): {</span>
        <span class="s1">$props: VNodeProps &amp; KeepAliveProps</span><span class="s0">;</span>
    <span class="s1">}</span><span class="s0">;</span>
    <span class="s1">__isKeepAlive: </span><span class="s0">true;</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">interface </span><span class="s1">KeepAliveProps {</span>
    <span class="s1">include?: MatchPattern</span><span class="s0">;</span>
    <span class="s1">exclude?: MatchPattern</span><span class="s0">;</span>
    <span class="s1">max?: number | string</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">declare type LegacyConfig = {</span>
    <span class="s3">/**</span>
     <span class="s3">* </span><span class="s5">@deprecated </span><span class="s3">`config.silent` option has been removed</span>
     <span class="s3">*/</span>
    <span class="s1">silent?: boolean</span><span class="s0">;</span>
    <span class="s3">/**</span>
     <span class="s3">* </span><span class="s5">@deprecated </span><span class="s3">use __VUE_PROD_DEVTOOLS__ compile-time feature flag instead</span>
     <span class="s3">* https://github.com/vuejs/core/tree/main/packages/vue#bundler-build-feature-flags</span>
     <span class="s3">*/</span>
    <span class="s1">devtools?: boolean</span><span class="s0">;</span>
    <span class="s3">/**</span>
     <span class="s3">* </span><span class="s5">@deprecated </span><span class="s3">use `config.isCustomElement` instead</span>
     <span class="s3">* https://v3-migration.vuejs.org/breaking-changes/global-api.html#config-ignoredelements-is-now-config-iscustomelement</span>
     <span class="s3">*/</span>
    <span class="s1">ignoredElements?: (string | RegExp)[]</span><span class="s0">;</span>
    <span class="s3">/**</span>
     <span class="s3">* </span><span class="s5">@deprecated</span>
     <span class="s3">* https://v3-migration.vuejs.org/breaking-changes/keycode-modifiers.html</span>
     <span class="s3">*/</span>
    <span class="s1">keyCodes?: Record&lt;string</span><span class="s0">, </span><span class="s1">number | number[]&gt;</span><span class="s0">;</span>
    <span class="s3">/**</span>
     <span class="s3">* </span><span class="s5">@deprecated</span>
     <span class="s3">* https://v3-migration.vuejs.org/breaking-changes/global-api.html#config-productiontip-removed</span>
     <span class="s3">*/</span>
    <span class="s1">productionTip?: boolean</span><span class="s0">;</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s1">declare </span><span class="s0">interface </span><span class="s1">LegacyOptions&lt;Props</span><span class="s0">, </span><span class="s1">D</span><span class="s0">, </span><span class="s1">C </span><span class="s0">extends </span><span class="s1">ComputedOptions</span><span class="s0">, </span><span class="s1">M </span><span class="s0">extends </span><span class="s1">MethodOptions</span><span class="s0">, </span><span class="s1">Mixin </span><span class="s0">extends </span><span class="s1">ComponentOptionsMixin</span><span class="s0">, </span><span class="s1">Extends </span><span class="s0">extends </span><span class="s1">ComponentOptionsMixin</span><span class="s0">, </span><span class="s1">I </span><span class="s0">extends </span><span class="s1">ComponentInjectOptions</span><span class="s0">, </span><span class="s1">II </span><span class="s0">extends </span><span class="s1">string&gt; {</span>
    <span class="s1">compatConfig?: CompatConfig</span><span class="s0">;</span>
    <span class="s1">[key: string]: any</span><span class="s0">;</span>
    <span class="s1">data?: (</span><span class="s0">this</span><span class="s1">: CreateComponentPublicInstance&lt;Props</span><span class="s0">, </span><span class="s1">{}</span><span class="s0">, </span><span class="s1">{}</span><span class="s0">, </span><span class="s1">{}</span><span class="s0">, </span><span class="s1">MethodOptions</span><span class="s0">, </span><span class="s1">Mixin</span><span class="s0">, </span><span class="s1">Extends&gt;</span><span class="s0">, </span><span class="s1">vm: CreateComponentPublicInstance&lt;Props</span><span class="s0">, </span><span class="s1">{}</span><span class="s0">, </span><span class="s1">{}</span><span class="s0">, </span><span class="s1">{}</span><span class="s0">, </span><span class="s1">MethodOptions</span><span class="s0">, </span><span class="s1">Mixin</span><span class="s0">, </span><span class="s1">Extends&gt;) =&gt; D</span><span class="s0">;</span>
    <span class="s1">computed?: C</span><span class="s0">;</span>
    <span class="s1">methods?: M</span><span class="s0">;</span>
    <span class="s1">watch?: ComponentWatchOptions</span><span class="s0">;</span>
    <span class="s1">provide?: ComponentProvideOptions</span><span class="s0">;</span>
    <span class="s1">inject?: I | II[]</span><span class="s0">;</span>
    <span class="s1">filters?: Record&lt;string</span><span class="s0">, </span><span class="s1">Function&gt;</span><span class="s0">;</span>
    <span class="s1">mixins?: Mixin[]</span><span class="s0">;</span>
    <span class="s0">extends</span><span class="s1">?: Extends</span><span class="s0">;</span>
    <span class="s1">beforeCreate?(): </span><span class="s0">void;</span>
    <span class="s1">created?(): </span><span class="s0">void;</span>
    <span class="s1">beforeMount?(): </span><span class="s0">void;</span>
    <span class="s1">mounted?(): </span><span class="s0">void;</span>
    <span class="s1">beforeUpdate?(): </span><span class="s0">void;</span>
    <span class="s1">updated?(): </span><span class="s0">void;</span>
    <span class="s1">activated?(): </span><span class="s0">void;</span>
    <span class="s1">deactivated?(): </span><span class="s0">void;</span>
    <span class="s3">/** </span><span class="s5">@deprecated </span><span class="s3">use `beforeUnmount` instead */</span>
    <span class="s1">beforeDestroy?(): </span><span class="s0">void;</span>
    <span class="s1">beforeUnmount?(): </span><span class="s0">void;</span>
    <span class="s3">/** </span><span class="s5">@deprecated </span><span class="s3">use `unmounted` instead */</span>
    <span class="s1">destroyed?(): </span><span class="s0">void;</span>
    <span class="s1">unmounted?(): </span><span class="s0">void;</span>
    <span class="s1">renderTracked?: DebuggerHook</span><span class="s0">;</span>
    <span class="s1">renderTriggered?: DebuggerHook</span><span class="s0">;</span>
    <span class="s1">errorCaptured?: ErrorCapturedHook</span><span class="s0">;</span>
    <span class="s3">/**</span>
     <span class="s3">* runtime compile only</span>
     <span class="s3">* </span><span class="s5">@deprecated </span><span class="s3">use `compilerOptions.delimiters` instead.</span>
     <span class="s3">*/</span>
    <span class="s1">delimiters?: [string</span><span class="s0">, </span><span class="s1">string]</span><span class="s0">;</span>
    <span class="s3">/**</span>
     <span class="s3">* #3468</span>
     <span class="s3">*</span>
     <span class="s3">* type-only, used to assist Mixin's type inference,</span>
     <span class="s3">* typescript will try to simplify the inferred `Mixin` type,</span>
     <span class="s3">* with the `__differentiator`, typescript won't be able to combine different mixins,</span>
     <span class="s3">* because the `__differentiator` will be different</span>
     <span class="s3">*/</span>
    <span class="s1">__differentiator?: keyof D | keyof C | keyof M</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s1">declare type LegacyPublicInstance = ComponentPublicInstance &amp; LegacyPublicProperties</span><span class="s0">;</span>

<span class="s1">declare </span><span class="s0">interface </span><span class="s1">LegacyPublicProperties {</span>
    <span class="s1">$set(target: object</span><span class="s0">, </span><span class="s1">key: string</span><span class="s0">, </span><span class="s1">value: any): </span><span class="s0">void;</span>
    <span class="s1">$delete(target: object</span><span class="s0">, </span><span class="s1">key: string): </span><span class="s0">void;</span>
    <span class="s1">$mount(el?: string | Element): </span><span class="s0">this;</span>
    <span class="s1">$destroy(): </span><span class="s0">void;</span>
    <span class="s1">$scopedSlots: Slots</span><span class="s0">;</span>
    <span class="s1">$on(event: string | string[]</span><span class="s0">, </span><span class="s1">fn: Function): </span><span class="s0">this;</span>
    <span class="s1">$once(event: string</span><span class="s0">, </span><span class="s1">fn: Function): </span><span class="s0">this;</span>
    <span class="s1">$off(event?: string | string[]</span><span class="s0">, </span><span class="s1">fn?: Function): </span><span class="s0">this;</span>
    <span class="s1">$children: LegacyPublicProperties[]</span><span class="s0">;</span>
    <span class="s1">$listeners: Record&lt;string</span><span class="s0">, </span><span class="s1">Function | Function[]&gt;</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s1">declare type LifecycleHook&lt;TFn = Function&gt; = TFn[] | </span><span class="s0">null;</span>

<span class="s1">declare </span><span class="s0">const enum </span><span class="s1">LifecycleHooks {</span>
    <span class="s1">BEFORE_CREATE = </span><span class="s2">&quot;bc&quot;</span><span class="s0">,</span>
    <span class="s1">CREATED = </span><span class="s2">&quot;c&quot;</span><span class="s0">,</span>
    <span class="s1">BEFORE_MOUNT = </span><span class="s2">&quot;bm&quot;</span><span class="s0">,</span>
    <span class="s1">MOUNTED = </span><span class="s2">&quot;m&quot;</span><span class="s0">,</span>
    <span class="s1">BEFORE_UPDATE = </span><span class="s2">&quot;bu&quot;</span><span class="s0">,</span>
    <span class="s1">UPDATED = </span><span class="s2">&quot;u&quot;</span><span class="s0">,</span>
    <span class="s1">BEFORE_UNMOUNT = </span><span class="s2">&quot;bum&quot;</span><span class="s0">,</span>
    <span class="s1">UNMOUNTED = </span><span class="s2">&quot;um&quot;</span><span class="s0">,</span>
    <span class="s1">DEACTIVATED = </span><span class="s2">&quot;da&quot;</span><span class="s0">,</span>
    <span class="s1">ACTIVATED = </span><span class="s2">&quot;a&quot;</span><span class="s0">,</span>
    <span class="s1">RENDER_TRIGGERED = </span><span class="s2">&quot;rtg&quot;</span><span class="s0">,</span>
    <span class="s1">RENDER_TRACKED = </span><span class="s2">&quot;rtc&quot;</span><span class="s0">,</span>
    <span class="s1">ERROR_CAPTURED = </span><span class="s2">&quot;ec&quot;</span><span class="s0">,</span>
    <span class="s1">SERVER_PREFETCH = </span><span class="s2">&quot;sp&quot;</span>
<span class="s1">}</span>

<span class="s1">declare type MapSources&lt;T</span><span class="s0">, </span><span class="s1">Immediate&gt; = {</span>
    <span class="s1">[K </span><span class="s0">in </span><span class="s1">keyof T]: T[K] </span><span class="s0">extends </span><span class="s1">WatchSource&lt;infer V&gt; ? Immediate </span><span class="s0">extends true </span><span class="s1">? V | undefined : V : T[K] </span><span class="s0">extends </span><span class="s1">object ? Immediate </span><span class="s0">extends true </span><span class="s1">? T[K] | undefined : T[K] : never</span><span class="s0">;</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">{ markRaw }</span>

<span class="s1">declare type MatchPattern = string | RegExp | (string | RegExp)[]</span><span class="s0">;</span>

<span class="s1">declare type MergedComponentOptions = ComponentOptions &amp; MergedComponentOptionsOverride</span><span class="s0">;</span>

<span class="s1">declare type MergedComponentOptionsOverride = {</span>
    <span class="s1">beforeCreate?: MergedHook</span><span class="s0">;</span>
    <span class="s1">created?: MergedHook</span><span class="s0">;</span>
    <span class="s1">beforeMount?: MergedHook</span><span class="s0">;</span>
    <span class="s1">mounted?: MergedHook</span><span class="s0">;</span>
    <span class="s1">beforeUpdate?: MergedHook</span><span class="s0">;</span>
    <span class="s1">updated?: MergedHook</span><span class="s0">;</span>
    <span class="s1">activated?: MergedHook</span><span class="s0">;</span>
    <span class="s1">deactivated?: MergedHook</span><span class="s0">;</span>
    <span class="s3">/** </span><span class="s5">@deprecated </span><span class="s3">use `beforeUnmount` instead */</span>
    <span class="s1">beforeDestroy?: MergedHook</span><span class="s0">;</span>
    <span class="s1">beforeUnmount?: MergedHook</span><span class="s0">;</span>
    <span class="s3">/** </span><span class="s5">@deprecated </span><span class="s3">use `unmounted` instead */</span>
    <span class="s1">destroyed?: MergedHook</span><span class="s0">;</span>
    <span class="s1">unmounted?: MergedHook</span><span class="s0">;</span>
    <span class="s1">renderTracked?: MergedHook&lt;DebuggerHook&gt;</span><span class="s0">;</span>
    <span class="s1">renderTriggered?: MergedHook&lt;DebuggerHook&gt;</span><span class="s0">;</span>
    <span class="s1">errorCaptured?: MergedHook&lt;ErrorCapturedHook&gt;</span><span class="s0">;</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s4">/* Excluded from this release type: mergeDefaults */</span>

<span class="s1">declare type MergedHook&lt;T = () =&gt; </span><span class="s0">void</span><span class="s1">&gt; = T | T[]</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">mergeProps(...args: (Data &amp; VNodeProps)[]): Data</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">interface </span><span class="s1">MethodOptions {</span>
    <span class="s1">[key: string]: Function</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s1">declare type MixinToOptionTypes&lt;T&gt; = T </span><span class="s0">extends </span><span class="s1">ComponentOptionsBase&lt;infer P</span><span class="s0">, </span><span class="s1">infer B</span><span class="s0">, </span><span class="s1">infer D</span><span class="s0">, </span><span class="s1">infer C</span><span class="s0">, </span><span class="s1">infer M</span><span class="s0">, </span><span class="s1">infer Mixin</span><span class="s0">, </span><span class="s1">infer Extends</span><span class="s0">, </span><span class="s1">any</span><span class="s0">, </span><span class="s1">any</span><span class="s0">, </span><span class="s1">infer Defaults&gt; ? OptionTypesType&lt;P &amp; {}</span><span class="s0">, </span><span class="s1">B &amp; {}</span><span class="s0">, </span><span class="s1">D &amp; {}</span><span class="s0">, </span><span class="s1">C &amp; {}</span><span class="s0">, </span><span class="s1">M &amp; {}</span><span class="s0">, </span><span class="s1">Defaults &amp; {}&gt; &amp; IntersectionMixin&lt;Mixin&gt; &amp; IntersectionMixin&lt;Extends&gt; : never</span><span class="s0">;</span>

<span class="s1">declare type MountChildrenFn = (children: VNodeArrayChildren</span><span class="s0">, </span><span class="s1">container: RendererElement</span><span class="s0">, </span><span class="s1">anchor: RendererNode | </span><span class="s0">null, </span><span class="s1">parentComponent: ComponentInternalInstance | </span><span class="s0">null, </span><span class="s1">parentSuspense: SuspenseBoundary | </span><span class="s0">null, </span><span class="s1">isSVG: boolean</span><span class="s0">, </span><span class="s1">slotScopeIds: string[] | </span><span class="s0">null, </span><span class="s1">optimized: boolean</span><span class="s0">, </span><span class="s1">start?: number) =&gt; </span><span class="s0">void;</span>

<span class="s1">declare type MountComponentFn = (initialVNode: VNode</span><span class="s0">, </span><span class="s1">container: RendererElement</span><span class="s0">, </span><span class="s1">anchor: RendererNode | </span><span class="s0">null, </span><span class="s1">parentComponent: ComponentInternalInstance | </span><span class="s0">null, </span><span class="s1">parentSuspense: SuspenseBoundary | </span><span class="s0">null, </span><span class="s1">isSVG: boolean</span><span class="s0">, </span><span class="s1">optimized: boolean) =&gt; </span><span class="s0">void;</span>

<span class="s1">declare type MoveFn = (vnode: VNode</span><span class="s0">, </span><span class="s1">container: RendererElement</span><span class="s0">, </span><span class="s1">anchor: RendererNode | </span><span class="s0">null, </span><span class="s1">type: MoveType</span><span class="s0">, </span><span class="s1">parentSuspense?: SuspenseBoundary | </span><span class="s0">null</span><span class="s1">) =&gt; </span><span class="s0">void;</span>

<span class="s1">declare </span><span class="s0">function </span><span class="s1">moveTeleport(vnode: VNode</span><span class="s0">, </span><span class="s1">container: RendererElement</span><span class="s0">, </span><span class="s1">parentAnchor: RendererNode | </span><span class="s0">null, </span><span class="s1">{ o: { insert }</span><span class="s0">, </span><span class="s1">m: move }: RendererInternals</span><span class="s0">, </span><span class="s1">moveType?: TeleportMoveTypes): </span><span class="s0">void;</span>

<span class="s1">declare </span><span class="s0">const enum </span><span class="s1">MoveType {</span>
    <span class="s1">ENTER = </span><span class="s6">0</span><span class="s0">,</span>
    <span class="s1">LEAVE = </span><span class="s6">1</span><span class="s0">,</span>
    <span class="s1">REORDER = </span><span class="s6">2</span>
<span class="s1">}</span>

<span class="s1">declare type MultiWatchSources = (WatchSource&lt;unknown&gt; | object)[]</span><span class="s0">;</span>

<span class="s1">declare type NextFn = (vnode: VNode) =&gt; RendererNode | </span><span class="s0">null;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">nextTick&lt;T = </span><span class="s0">void</span><span class="s1">&gt;(</span><span class="s0">this</span><span class="s1">: T</span><span class="s0">, </span><span class="s1">fn?: (</span><span class="s0">this</span><span class="s1">: T) =&gt; </span><span class="s0">void</span><span class="s1">): Promise&lt;</span><span class="s0">void</span><span class="s1">&gt;</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">{ normalizeClass }</span>

<span class="s1">declare type NormalizedProp = </span><span class="s0">null </span><span class="s1">| (PropOptions &amp; {</span>
    <span class="s1">[BooleanFlags.shouldCast]?: boolean</span><span class="s0">;</span>
    <span class="s1">[BooleanFlags.shouldCastTrue]?: boolean</span><span class="s0">;</span>
<span class="s1">})</span><span class="s0">;</span>

<span class="s1">declare type NormalizedProps = Record&lt;string</span><span class="s0">, </span><span class="s1">NormalizedProp&gt;</span><span class="s0">;</span>

<span class="s1">declare type NormalizedPropsOptions = [NormalizedProps</span><span class="s0">, </span><span class="s1">string[]] | []</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">{ normalizeProps }</span>

<span class="s0">export </span><span class="s1">{ normalizeStyle }</span>

<span class="s1">declare </span><span class="s0">function </span><span class="s1">normalizeSuspenseChildren(vnode: VNode): </span><span class="s0">void;</span>

<span class="s1">declare </span><span class="s0">function </span><span class="s1">normalizeVNode(child: VNodeChild): VNode</span><span class="s0">;</span>

<span class="s1">declare type NotUndefined&lt;T&gt; = T </span><span class="s0">extends </span><span class="s1">undefined ? never : T</span><span class="s0">;</span>

<span class="s1">declare </span><span class="s0">const </span><span class="s1">NULL_DYNAMIC_COMPONENT: unique symbol</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">interface </span><span class="s1">ObjectDirective&lt;T = any</span><span class="s0">, </span><span class="s1">V = any&gt; {</span>
    <span class="s1">created?: DirectiveHook&lt;T</span><span class="s0">, null, </span><span class="s1">V&gt;</span><span class="s0">;</span>
    <span class="s1">beforeMount?: DirectiveHook&lt;T</span><span class="s0">, null, </span><span class="s1">V&gt;</span><span class="s0">;</span>
    <span class="s1">mounted?: DirectiveHook&lt;T</span><span class="s0">, null, </span><span class="s1">V&gt;</span><span class="s0">;</span>
    <span class="s1">beforeUpdate?: DirectiveHook&lt;T</span><span class="s0">, </span><span class="s1">VNode&lt;any</span><span class="s0">, </span><span class="s1">T&gt;</span><span class="s0">, </span><span class="s1">V&gt;</span><span class="s0">;</span>
    <span class="s1">updated?: DirectiveHook&lt;T</span><span class="s0">, </span><span class="s1">VNode&lt;any</span><span class="s0">, </span><span class="s1">T&gt;</span><span class="s0">, </span><span class="s1">V&gt;</span><span class="s0">;</span>
    <span class="s1">beforeUnmount?: DirectiveHook&lt;T</span><span class="s0">, null, </span><span class="s1">V&gt;</span><span class="s0">;</span>
    <span class="s1">unmounted?: DirectiveHook&lt;T</span><span class="s0">, null, </span><span class="s1">V&gt;</span><span class="s0">;</span>
    <span class="s1">getSSRProps?: SSRDirectiveHook</span><span class="s0">;</span>
    <span class="s1">deep?: boolean</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">declare type ObjectEmitsOptions = Record&lt;string</span><span class="s0">, </span><span class="s1">((...args: any[]) =&gt; any) | </span><span class="s0">null</span><span class="s1">&gt;</span><span class="s0">;</span>

<span class="s1">declare type ObjectInjectOptions = Record&lt;string | symbol</span><span class="s0">, </span><span class="s1">string | symbol | {</span>
    <span class="s1">from?: string | symbol</span><span class="s0">;</span>
    <span class="s0">default</span><span class="s1">?: unknown</span><span class="s0">;</span>
<span class="s1">}&gt;</span><span class="s0">;</span>

<span class="s1">declare type ObjectProvideOptions = Record&lt;string | symbol</span><span class="s0">, </span><span class="s1">unknown&gt;</span><span class="s0">;</span>

<span class="s1">declare type ObjectWatchOptionItem = {</span>
    <span class="s1">handler: WatchCallback | string</span><span class="s0">;</span>
<span class="s1">} &amp; WatchOptions</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">onActivated(hook: Function</span><span class="s0">, </span><span class="s1">target?: ComponentInternalInstance | </span><span class="s0">null</span><span class="s1">): </span><span class="s0">void;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">const </span><span class="s1">onBeforeMount: (hook: () =&gt; any</span><span class="s0">, </span><span class="s1">target?: ComponentInternalInstance | </span><span class="s0">null</span><span class="s1">) =&gt; </span><span class="s0">false </span><span class="s1">| Function | undefined</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">const </span><span class="s1">onBeforeUnmount: (hook: () =&gt; any</span><span class="s0">, </span><span class="s1">target?: ComponentInternalInstance | </span><span class="s0">null</span><span class="s1">) =&gt; </span><span class="s0">false </span><span class="s1">| Function | undefined</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">const </span><span class="s1">onBeforeUpdate: (hook: () =&gt; any</span><span class="s0">, </span><span class="s1">target?: ComponentInternalInstance | </span><span class="s0">null</span><span class="s1">) =&gt; </span><span class="s0">false </span><span class="s1">| Function | undefined</span><span class="s0">;</span>

<span class="s1">declare type OnCleanup = (cleanupFn: () =&gt; </span><span class="s0">void</span><span class="s1">) =&gt; </span><span class="s0">void;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">onDeactivated(hook: Function</span><span class="s0">, </span><span class="s1">target?: ComponentInternalInstance | </span><span class="s0">null</span><span class="s1">): </span><span class="s0">void;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">onErrorCaptured&lt;TError = Error&gt;(hook: ErrorCapturedHook&lt;TError&gt;</span><span class="s0">, </span><span class="s1">target?: ComponentInternalInstance | </span><span class="s0">null</span><span class="s1">): </span><span class="s0">void;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">const </span><span class="s1">onMounted: (hook: () =&gt; any</span><span class="s0">, </span><span class="s1">target?: ComponentInternalInstance | </span><span class="s0">null</span><span class="s1">) =&gt; </span><span class="s0">false </span><span class="s1">| Function | undefined</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">const </span><span class="s1">onRenderTracked: (hook: DebuggerHook</span><span class="s0">, </span><span class="s1">target?: ComponentInternalInstance | </span><span class="s0">null</span><span class="s1">) =&gt; </span><span class="s0">false </span><span class="s1">| Function | undefined</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">const </span><span class="s1">onRenderTriggered: (hook: DebuggerHook</span><span class="s0">, </span><span class="s1">target?: ComponentInternalInstance | </span><span class="s0">null</span><span class="s1">) =&gt; </span><span class="s0">false </span><span class="s1">| Function | undefined</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">{ onScopeDispose }</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">const </span><span class="s1">onServerPrefetch: (hook: () =&gt; any</span><span class="s0">, </span><span class="s1">target?: ComponentInternalInstance | </span><span class="s0">null</span><span class="s1">) =&gt; </span><span class="s0">false </span><span class="s1">| Function | undefined</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">const </span><span class="s1">onUnmounted: (hook: () =&gt; any</span><span class="s0">, </span><span class="s1">target?: ComponentInternalInstance | </span><span class="s0">null</span><span class="s1">) =&gt; </span><span class="s0">false </span><span class="s1">| Function | undefined</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">const </span><span class="s1">onUpdated: (hook: () =&gt; any</span><span class="s0">, </span><span class="s1">target?: ComponentInternalInstance | </span><span class="s0">null</span><span class="s1">) =&gt; </span><span class="s0">false </span><span class="s1">| Function | undefined</span><span class="s0">;</span>

<span class="s3">/**</span>
 <span class="s3">* Open a block.</span>
 <span class="s3">* This must be called before `createBlock`. It cannot be part of `createBlock`</span>
 <span class="s3">* because the children of the block are evaluated before `createBlock` itself</span>
 <span class="s3">* is called. The generated code typically looks like this:</span>
 <span class="s3">*</span>
 <span class="s3">* ```js</span>
 <span class="s3">* function render() {</span>
 <span class="s3">*   return (openBlock(),createBlock('div', null, [...]))</span>
 <span class="s3">* }</span>
 <span class="s3">* ```</span>
 <span class="s3">* disableTracking is true when creating a v-for fragment block, since a v-for</span>
 <span class="s3">* fragment always diffs its children.</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s5">@private</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">openBlock(disableTracking?: boolean): </span><span class="s0">void;</span>

<span class="s1">declare type OptionalKeys&lt;T&gt; = Exclude&lt;keyof T</span><span class="s0">, </span><span class="s1">RequiredKeys&lt;T&gt;&gt;</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare type OptionMergeFunction = (to: unknown</span><span class="s0">, </span><span class="s1">from: unknown) =&gt; any</span><span class="s0">;</span>

<span class="s1">declare type OptionTypesKeys = </span><span class="s2">'P' </span><span class="s1">| </span><span class="s2">'B' </span><span class="s1">| </span><span class="s2">'D' </span><span class="s1">| </span><span class="s2">'C' </span><span class="s1">| </span><span class="s2">'M' </span><span class="s1">| </span><span class="s2">'Defaults'</span><span class="s0">;</span>

<span class="s1">declare type OptionTypesType&lt;P = {}</span><span class="s0">, </span><span class="s1">B = {}</span><span class="s0">, </span><span class="s1">D = {}</span><span class="s0">, </span><span class="s1">C </span><span class="s0">extends </span><span class="s1">ComputedOptions = {}</span><span class="s0">, </span><span class="s1">M </span><span class="s0">extends </span><span class="s1">MethodOptions = {}</span><span class="s0">, </span><span class="s1">Defaults = {}&gt; = {</span>
    <span class="s1">P: P</span><span class="s0">;</span>
    <span class="s1">B: B</span><span class="s0">;</span>
    <span class="s1">D: D</span><span class="s0">;</span>
    <span class="s1">C: C</span><span class="s0">;</span>
    <span class="s1">M: M</span><span class="s0">;</span>
    <span class="s1">Defaults: Defaults</span><span class="s0">;</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s1">declare type PatchBlockChildrenFn = (oldChildren: VNode[]</span><span class="s0">, </span><span class="s1">newChildren: VNode[]</span><span class="s0">, </span><span class="s1">fallbackContainer: RendererElement</span><span class="s0">, </span><span class="s1">parentComponent: ComponentInternalInstance | </span><span class="s0">null, </span><span class="s1">parentSuspense: SuspenseBoundary | </span><span class="s0">null, </span><span class="s1">isSVG: boolean</span><span class="s0">, </span><span class="s1">slotScopeIds: string[] | </span><span class="s0">null</span><span class="s1">) =&gt; </span><span class="s0">void;</span>

<span class="s1">declare type PatchChildrenFn = (n1: VNode | </span><span class="s0">null, </span><span class="s1">n2: VNode</span><span class="s0">, </span><span class="s1">container: RendererElement</span><span class="s0">, </span><span class="s1">anchor: RendererNode | </span><span class="s0">null, </span><span class="s1">parentComponent: ComponentInternalInstance | </span><span class="s0">null, </span><span class="s1">parentSuspense: SuspenseBoundary | </span><span class="s0">null, </span><span class="s1">isSVG: boolean</span><span class="s0">, </span><span class="s1">slotScopeIds: string[] | </span><span class="s0">null, </span><span class="s1">optimized: boolean) =&gt; </span><span class="s0">void;</span>

<span class="s1">declare type PatchFn = (n1: VNode | </span><span class="s0">null, </span><span class="s4">// null means this is a mount</span>
<span class="s1">n2: VNode</span><span class="s0">, </span><span class="s1">container: RendererElement</span><span class="s0">, </span><span class="s1">anchor?: RendererNode | </span><span class="s0">null, </span><span class="s1">parentComponent?: ComponentInternalInstance | </span><span class="s0">null, </span><span class="s1">parentSuspense?: SuspenseBoundary | </span><span class="s0">null, </span><span class="s1">isSVG?: boolean</span><span class="s0">, </span><span class="s1">slotScopeIds?: string[] | </span><span class="s0">null, </span><span class="s1">optimized?: boolean) =&gt; </span><span class="s0">void;</span>

<span class="s1">declare type Plugin_2&lt;Options = any[]&gt; = (PluginInstallFunction&lt;Options&gt; &amp; {</span>
    <span class="s1">install?: PluginInstallFunction&lt;Options&gt;</span><span class="s0">;</span>
<span class="s1">}) | {</span>
    <span class="s1">install: PluginInstallFunction&lt;Options&gt;</span><span class="s0">;</span>
<span class="s1">}</span><span class="s0">;</span>
<span class="s0">export </span><span class="s1">{ Plugin_2 as Plugin }</span>

<span class="s1">declare type PluginInstallFunction&lt;Options&gt; = Options </span><span class="s0">extends </span><span class="s1">unknown[] ? (app: App</span><span class="s0">, </span><span class="s1">...options: Options) =&gt; any : (app: App</span><span class="s0">, </span><span class="s1">options: Options) =&gt; any</span><span class="s0">;</span>

<span class="s3">/**</span>
 <span class="s3">* Technically we no longer need this after 3.0.8 but we need to keep the same</span>
 <span class="s3">* API for backwards compat w/ code generated by compilers.</span>
 <span class="s3">* </span><span class="s5">@private</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">popScopeId(): </span><span class="s0">void;</span>

<span class="s0">export </span><span class="s1">declare type Prop&lt;T</span><span class="s0">, </span><span class="s1">D = T&gt; = PropOptions&lt;T</span><span class="s0">, </span><span class="s1">D&gt; | PropType&lt;T&gt;</span><span class="s0">;</span>

<span class="s1">declare type PropConstructor&lt;T = any&gt; = {</span>
    <span class="s0">new </span><span class="s1">(...args: any[]): T &amp; {}</span><span class="s0">;</span>
<span class="s1">} | {</span>
    <span class="s1">(): T</span><span class="s0">;</span>
<span class="s1">} | PropMethod&lt;T&gt;</span><span class="s0">;</span>

<span class="s1">declare type PropMethod&lt;T</span><span class="s0">, </span><span class="s1">TConstructor = any&gt; = [T] </span><span class="s0">extends </span><span class="s1">[</span>
<span class="s1">((...args: any) =&gt; any) | undefined</span>
<span class="s1">] ? {</span>
    <span class="s0">new </span><span class="s1">(): TConstructor</span><span class="s0">;</span>
    <span class="s1">(): T</span><span class="s0">;</span>
    <span class="s1">readonly prototype: TConstructor</span><span class="s0">;</span>
<span class="s1">} : never</span><span class="s0">;</span>

<span class="s1">declare </span><span class="s0">interface </span><span class="s1">PropOptions&lt;T = any</span><span class="s0">, </span><span class="s1">D = T&gt; {</span>
    <span class="s1">type?: PropType&lt;T&gt; | </span><span class="s0">true </span><span class="s1">| </span><span class="s0">null;</span>
    <span class="s1">required?: boolean</span><span class="s0">;</span>
    <span class="s0">default</span><span class="s1">?: D | DefaultFactory&lt;D&gt; | </span><span class="s0">null </span><span class="s1">| undefined | object</span><span class="s0">;</span>
    <span class="s1">validator?(value: unknown): boolean</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s1">declare type PropsWithDefaults&lt;Base</span><span class="s0">, </span><span class="s1">Defaults&gt; = Base &amp; {</span>
    <span class="s1">[K </span><span class="s0">in </span><span class="s1">keyof Defaults]: K </span><span class="s0">extends </span><span class="s1">keyof Base ? Defaults[K] </span><span class="s0">extends </span><span class="s1">undefined ? Base[K] : NotUndefined&lt;Base[K]&gt; : never</span><span class="s0">;</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare type PropType&lt;T&gt; = PropConstructor&lt;T&gt; | PropConstructor&lt;T&gt;[]</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">provide&lt;T&gt;(key: InjectionKey&lt;T&gt; | string | number</span><span class="s0">, </span><span class="s1">value: T): </span><span class="s0">void;</span>

<span class="s0">export </span><span class="s1">{ proxyRefs }</span>

<span class="s1">declare type PublicProps = VNodeProps &amp; AllowedComponentProps &amp; ComponentCustomProps</span><span class="s0">;</span>

<span class="s3">/**</span>
 <span class="s3">* Set scope id when creating hoisted vnodes.</span>
 <span class="s3">* </span><span class="s5">@private </span><span class="s3">compiler helper</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">pushScopeId(id: string | </span><span class="s0">null</span><span class="s1">): </span><span class="s0">void;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">queuePostFlushCb(cb: SchedulerJobs): </span><span class="s0">void;</span>

<span class="s0">export </span><span class="s1">{ Raw }</span>

<span class="s1">declare type RawChildren = string | number | boolean | VNode | VNodeArrayChildren | (() =&gt; any)</span><span class="s0">;</span>

<span class="s1">declare type RawProps = VNodeProps &amp; {</span>
    <span class="s1">__v_isVNode?: never</span><span class="s0">;</span>
    <span class="s1">[Symbol.iterator]?: never</span><span class="s0">;</span>
<span class="s1">} &amp; Record&lt;string</span><span class="s0">, </span><span class="s1">any&gt;</span><span class="s0">;</span>

<span class="s1">declare type RawSlots = {</span>
    <span class="s1">[name: string]: unknown</span><span class="s0">;</span>
    <span class="s1">$stable?: boolean</span><span class="s0">;</span>
    <span class="s4">/* Excluded from this release type: _ctx */</span>
    <span class="s4">/* Excluded from this release type: _ */</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">{ reactive }</span>

<span class="s0">export </span><span class="s1">{ ReactiveEffect }</span>

<span class="s0">export </span><span class="s1">{ ReactiveEffectOptions }</span>

<span class="s0">export </span><span class="s1">{ ReactiveEffectRunner }</span>

<span class="s0">export </span><span class="s1">{ ReactiveFlags }</span>

<span class="s0">export </span><span class="s1">{ readonly }</span>

<span class="s0">export </span><span class="s1">{ Ref }</span>

<span class="s0">export </span><span class="s1">{ ref }</span>

<span class="s3">/**</span>
 <span class="s3">* For runtime-dom to register the compiler.</span>
 <span class="s3">* Note the exported method uses any to avoid d.ts relying on the compiler types.</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">registerRuntimeCompiler(_compile: any): </span><span class="s0">void;</span>

<span class="s1">declare </span><span class="s0">function </span><span class="s1">reload(id: string</span><span class="s0">, </span><span class="s1">newComp: HMRComponent): </span><span class="s0">void;</span>

<span class="s1">declare type RemoveFn = (vnode: VNode) =&gt; </span><span class="s0">void;</span>

<span class="s1">declare </span><span class="s0">function </span><span class="s1">renderComponentRoot(instance: ComponentInternalInstance): VNode</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">interface </span><span class="s1">Renderer&lt;HostElement = RendererElement&gt; {</span>
    <span class="s1">render: RootRenderFunction&lt;HostElement&gt;</span><span class="s0">;</span>
    <span class="s1">createApp: CreateAppFunction&lt;HostElement&gt;</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">interface </span><span class="s1">RendererElement </span><span class="s0">extends </span><span class="s1">RendererNode {</span>
<span class="s1">}</span>

<span class="s1">declare </span><span class="s0">interface </span><span class="s1">RendererInternals&lt;HostNode = RendererNode</span><span class="s0">, </span><span class="s1">HostElement = RendererElement&gt; {</span>
    <span class="s1">p: PatchFn</span><span class="s0">;</span>
    <span class="s1">um: UnmountFn</span><span class="s0">;</span>
    <span class="s1">r: RemoveFn</span><span class="s0">;</span>
    <span class="s1">m: MoveFn</span><span class="s0">;</span>
    <span class="s1">mt: MountComponentFn</span><span class="s0">;</span>
    <span class="s1">mc: MountChildrenFn</span><span class="s0">;</span>
    <span class="s1">pc: PatchChildrenFn</span><span class="s0">;</span>
    <span class="s1">pbc: PatchBlockChildrenFn</span><span class="s0">;</span>
    <span class="s1">n: NextFn</span><span class="s0">;</span>
    <span class="s1">o: RendererOptions&lt;HostNode</span><span class="s0">, </span><span class="s1">HostElement&gt;</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">interface </span><span class="s1">RendererNode {</span>
    <span class="s1">[key: string]: any</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">interface </span><span class="s1">RendererOptions&lt;HostNode = RendererNode</span><span class="s0">, </span><span class="s1">HostElement = RendererElement&gt; {</span>
    <span class="s1">patchProp(el: HostElement</span><span class="s0">, </span><span class="s1">key: string</span><span class="s0">, </span><span class="s1">prevValue: any</span><span class="s0">, </span><span class="s1">nextValue: any</span><span class="s0">, </span><span class="s1">isSVG?: boolean</span><span class="s0">, </span><span class="s1">prevChildren?: VNode&lt;HostNode</span><span class="s0">, </span><span class="s1">HostElement&gt;[]</span><span class="s0">, </span><span class="s1">parentComponent?: ComponentInternalInstance | </span><span class="s0">null, </span><span class="s1">parentSuspense?: SuspenseBoundary | </span><span class="s0">null, </span><span class="s1">unmountChildren?: UnmountChildrenFn): </span><span class="s0">void;</span>
    <span class="s1">insert(el: HostNode</span><span class="s0">, </span><span class="s1">parent: HostElement</span><span class="s0">, </span><span class="s1">anchor?: HostNode | </span><span class="s0">null</span><span class="s1">): </span><span class="s0">void;</span>
    <span class="s1">remove(el: HostNode): </span><span class="s0">void;</span>
    <span class="s1">createElement(type: string</span><span class="s0">, </span><span class="s1">isSVG?: boolean</span><span class="s0">, </span><span class="s1">isCustomizedBuiltIn?: string</span><span class="s0">, </span><span class="s1">vnodeProps?: (VNodeProps &amp; {</span>
        <span class="s1">[key: string]: any</span><span class="s0">;</span>
    <span class="s1">}) | </span><span class="s0">null</span><span class="s1">): HostElement</span><span class="s0">;</span>
    <span class="s1">createText(text: string): HostNode</span><span class="s0">;</span>
    <span class="s1">createComment(text: string): HostNode</span><span class="s0">;</span>
    <span class="s1">setText(node: HostNode</span><span class="s0">, </span><span class="s1">text: string): </span><span class="s0">void;</span>
    <span class="s1">setElementText(node: HostElement</span><span class="s0">, </span><span class="s1">text: string): </span><span class="s0">void;</span>
    <span class="s1">parentNode(node: HostNode): HostElement | </span><span class="s0">null;</span>
    <span class="s1">nextSibling(node: HostNode): HostNode | </span><span class="s0">null;</span>
    <span class="s1">querySelector?(selector: string): HostElement | </span><span class="s0">null;</span>
    <span class="s1">setScopeId?(el: HostElement</span><span class="s0">, </span><span class="s1">id: string): </span><span class="s0">void;</span>
    <span class="s1">cloneNode?(node: HostNode): HostNode</span><span class="s0">;</span>
    <span class="s1">insertStaticContent?(content: string</span><span class="s0">, </span><span class="s1">parent: HostElement</span><span class="s0">, </span><span class="s1">anchor: HostNode | </span><span class="s0">null, </span><span class="s1">isSVG: boolean</span><span class="s0">, </span><span class="s1">start?: HostNode | </span><span class="s0">null, </span><span class="s1">end?: HostNode | </span><span class="s0">null</span><span class="s1">): [HostNode</span><span class="s0">, </span><span class="s1">HostNode]</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">declare type RenderFunction = () =&gt; VNodeChild</span><span class="s0">;</span>

<span class="s3">/**</span>
 <span class="s3">* v-for string</span>
 <span class="s3">* </span><span class="s5">@private</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">renderList(source: string</span><span class="s0">, </span><span class="s1">renderItem: (value: string</span><span class="s0">, </span><span class="s1">index: number) =&gt; VNodeChild): VNodeChild[]</span><span class="s0">;</span>

<span class="s3">/**</span>
 <span class="s3">* v-for number</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">renderList(source: number</span><span class="s0">, </span><span class="s1">renderItem: (value: number</span><span class="s0">, </span><span class="s1">index: number) =&gt; VNodeChild): VNodeChild[]</span><span class="s0">;</span>

<span class="s3">/**</span>
 <span class="s3">* v-for array</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">renderList&lt;T&gt;(source: T[]</span><span class="s0">, </span><span class="s1">renderItem: (value: T</span><span class="s0">, </span><span class="s1">index: number) =&gt; VNodeChild): VNodeChild[]</span><span class="s0">;</span>

<span class="s3">/**</span>
 <span class="s3">* v-for iterable</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">renderList&lt;T&gt;(source: Iterable&lt;T&gt;</span><span class="s0">, </span><span class="s1">renderItem: (value: T</span><span class="s0">, </span><span class="s1">index: number) =&gt; VNodeChild): VNodeChild[]</span><span class="s0">;</span>

<span class="s3">/**</span>
 <span class="s3">* v-for object</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">renderList&lt;T&gt;(source: T</span><span class="s0">, </span><span class="s1">renderItem: &lt;K </span><span class="s0">extends </span><span class="s1">keyof T&gt;(value: T[K]</span><span class="s0">, </span><span class="s1">key: K</span><span class="s0">, </span><span class="s1">index: number) =&gt; VNodeChild): VNodeChild[]</span><span class="s0">;</span>

<span class="s3">/**</span>
 <span class="s3">* Compiler runtime helper for rendering `&lt;slot/&gt;`</span>
 <span class="s3">* </span><span class="s5">@private</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">renderSlot(slots: Slots</span><span class="s0">, </span><span class="s1">name: string</span><span class="s0">, </span><span class="s1">props?: Data</span><span class="s0">, </span><span class="s1">fallback?: () =&gt; VNodeArrayChildren</span><span class="s0">, </span><span class="s1">noSlotted?: boolean): VNode</span><span class="s0">;</span>

<span class="s1">declare type RequiredKeys&lt;T&gt; = {</span>
    <span class="s1">[K </span><span class="s0">in </span><span class="s1">keyof T]: T[K] </span><span class="s0">extends </span><span class="s1">{</span>
        <span class="s1">required: </span><span class="s0">true;</span>
    <span class="s1">} | {</span>
        <span class="s0">default</span><span class="s1">: any</span><span class="s0">;</span>
    <span class="s1">} | BooleanConstructor | {</span>
        <span class="s1">type: BooleanConstructor</span><span class="s0">;</span>
    <span class="s1">} ? T[K] </span><span class="s0">extends </span><span class="s1">{</span>
        <span class="s0">default</span><span class="s1">: undefined | (() =&gt; undefined)</span><span class="s0">;</span>
    <span class="s1">} ? never : K : never</span><span class="s0">;</span>
<span class="s1">}[keyof T]</span><span class="s0">;</span>

<span class="s1">declare </span><span class="s0">function </span><span class="s1">rerender(id: string</span><span class="s0">, </span><span class="s1">newRender?: Function): </span><span class="s0">void;</span>

<span class="s3">/**</span>
 <span class="s3">* </span><span class="s5">@private</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">resolveComponent(name: string</span><span class="s0">, </span><span class="s1">maybeSelfReference?: boolean): ConcreteComponent | string</span><span class="s0">;</span>

<span class="s3">/**</span>
 <span class="s3">* </span><span class="s5">@private</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">resolveDirective(name: string): Directive | undefined</span><span class="s0">;</span>

<span class="s3">/**</span>
 <span class="s3">* </span><span class="s5">@private</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">resolveDynamicComponent(component: unknown): VNodeTypes</span><span class="s0">;</span>

<span class="s4">/* Excluded from this release type: resolveFilter */</span>

<span class="s4">/* Excluded from this release type: resolveFilter_2 */</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">resolveTransitionHooks(vnode: VNode</span><span class="s0">, </span><span class="s1">props: BaseTransitionProps&lt;any&gt;</span><span class="s0">, </span><span class="s1">state: TransitionState</span><span class="s0">, </span><span class="s1">instance: ComponentInternalInstance): TransitionHooks</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare type RootHydrateFunction = (vnode: VNode&lt;Node</span><span class="s0">, </span><span class="s1">Element&gt;</span><span class="s0">, </span><span class="s1">container: (Element | ShadowRoot) &amp; {</span>
    <span class="s1">_vnode?: VNode</span><span class="s0">;</span>
<span class="s1">}) =&gt; </span><span class="s0">void;</span>

<span class="s0">export </span><span class="s1">declare type RootRenderFunction&lt;HostElement = RendererElement&gt; = (vnode: VNode | </span><span class="s0">null, </span><span class="s1">container: HostElement</span><span class="s0">, </span><span class="s1">isSVG?: boolean) =&gt; </span><span class="s0">void;</span>

<span class="s3">/**</span>
 <span class="s3">* Subset of compiler options that makes sense for the runtime.</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">interface </span><span class="s1">RuntimeCompilerOptions {</span>
    <span class="s1">isCustomElement?: (tag: string) =&gt; boolean</span><span class="s0">;</span>
    <span class="s1">whitespace?: </span><span class="s2">'preserve' </span><span class="s1">| </span><span class="s2">'condense'</span><span class="s0">;</span>
    <span class="s1">comments?: boolean</span><span class="s0">;</span>
    <span class="s1">delimiters?: [string</span><span class="s0">, </span><span class="s1">string]</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s1">declare </span><span class="s0">interface </span><span class="s1">SchedulerJob </span><span class="s0">extends </span><span class="s1">Function {</span>
    <span class="s1">id?: number</span><span class="s0">;</span>
    <span class="s1">pre?: boolean</span><span class="s0">;</span>
    <span class="s1">active?: boolean</span><span class="s0">;</span>
    <span class="s1">computed?: boolean</span><span class="s0">;</span>
    <span class="s3">/**</span>
     <span class="s3">* Indicates whether the effect is allowed to recursively trigger itself</span>
     <span class="s3">* when managed by the scheduler.</span>
     <span class="s3">*</span>
     <span class="s3">* By default, a job cannot trigger itself because some built-in method calls,</span>
     <span class="s3">* e.g. Array.prototype.push actually performs reads as well (#1740) which</span>
     <span class="s3">* can lead to confusing infinite loops.</span>
     <span class="s3">* The allowed cases are component update functions and watch callbacks.</span>
     <span class="s3">* Component update functions may update child component props, which in turn</span>
     <span class="s3">* trigger flush: &quot;pre&quot; watch callbacks that mutates state that the parent</span>
     <span class="s3">* relies on (#1801). Watch callbacks doesn't track its dependencies so if it</span>
     <span class="s3">* triggers itself again, it's likely intentional and it is the user's</span>
     <span class="s3">* responsibility to perform recursive state mutation that eventually</span>
     <span class="s3">* stabilizes (#1727).</span>
     <span class="s3">*/</span>
    <span class="s1">allowRecurse?: boolean</span><span class="s0">;</span>
    <span class="s3">/**</span>
     <span class="s3">* Attached by renderer.ts when setting up a component's render effect</span>
     <span class="s3">* Used to obtain component information when reporting max recursive updates.</span>
     <span class="s3">* dev only.</span>
     <span class="s3">*/</span>
    <span class="s1">ownerInstance?: ComponentInternalInstance</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s1">declare type SchedulerJobs = SchedulerJob | SchedulerJob[]</span><span class="s0">;</span>

<span class="s3">/**</span>
 <span class="s3">* Block tracking sometimes needs to be disabled, for example during the</span>
 <span class="s3">* creation of a tree that needs to be cached by v-once. The compiler generates</span>
 <span class="s3">* code like this:</span>
 <span class="s3">*</span>
 <span class="s3">* ``` js</span>
 <span class="s3">* _cache[1] || (</span>
 <span class="s3">*   setBlockTracking(-1),</span>
 <span class="s3">*   _cache[1] = createVNode(...),</span>
 <span class="s3">*   setBlockTracking(1),</span>
 <span class="s3">*   _cache[1]</span>
 <span class="s3">* )</span>
 <span class="s3">* ```</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s5">@private</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">setBlockTracking(value: number): </span><span class="s0">void;</span>

<span class="s3">/**</span>
 <span class="s3">* Note: rendering calls maybe nested. The function returns the parent rendering</span>
 <span class="s3">* instance if present, which should be restored after the render is done:</span>
 <span class="s3">*</span>
 <span class="s3">* ```js</span>
 <span class="s3">* const prev = setCurrentRenderingInstance(i)</span>
 <span class="s3">* // ...render</span>
 <span class="s3">* setCurrentRenderingInstance(prev)</span>
 <span class="s3">* ```</span>
 <span class="s3">*/</span>
<span class="s1">declare </span><span class="s0">function </span><span class="s1">setCurrentRenderingInstance(instance: ComponentInternalInstance | </span><span class="s0">null</span><span class="s1">): ComponentInternalInstance | </span><span class="s0">null;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">setDevtoolsHook(hook: DevtoolsHook</span><span class="s0">, </span><span class="s1">target: any): </span><span class="s0">void;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">setTransitionHooks(vnode: VNode</span><span class="s0">, </span><span class="s1">hooks: TransitionHooks): </span><span class="s0">void;</span>

<span class="s1">declare </span><span class="s0">function </span><span class="s1">setupComponent(instance: ComponentInternalInstance</span><span class="s0">, </span><span class="s1">isSSR?: boolean): Promise&lt;</span><span class="s0">void</span><span class="s1">&gt; | undefined</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare type SetupContext&lt;E = EmitsOptions&gt; = E </span><span class="s0">extends </span><span class="s1">any ? {</span>
    <span class="s1">attrs: Data</span><span class="s0">;</span>
    <span class="s1">slots: Slots</span><span class="s0">;</span>
    <span class="s1">emit: EmitFn&lt;E&gt;</span><span class="s0">;</span>
    <span class="s1">expose: (exposed?: Record&lt;string</span><span class="s0">, </span><span class="s1">any&gt;) =&gt; </span><span class="s0">void;</span>
<span class="s1">} : never</span><span class="s0">;</span>

<span class="s1">declare type SetupRenderEffectFn = (instance: ComponentInternalInstance</span><span class="s0">, </span><span class="s1">initialVNode: VNode</span><span class="s0">, </span><span class="s1">container: RendererElement</span><span class="s0">, </span><span class="s1">anchor: RendererNode | </span><span class="s0">null, </span><span class="s1">parentSuspense: SuspenseBoundary | </span><span class="s0">null, </span><span class="s1">isSVG: boolean</span><span class="s0">, </span><span class="s1">optimized: boolean) =&gt; </span><span class="s0">void;</span>

<span class="s0">export </span><span class="s1">{ ShallowReactive }</span>

<span class="s0">export </span><span class="s1">{ shallowReactive }</span>

<span class="s0">export </span><span class="s1">{ shallowReadonly }</span>

<span class="s0">export </span><span class="s1">{ ShallowRef }</span>

<span class="s0">export </span><span class="s1">{ shallowRef }</span>

<span class="s0">export </span><span class="s1">{ ShallowUnwrapRef }</span>

<span class="s0">export </span><span class="s1">declare type Slot = (...args: any[]) =&gt; VNode[]</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare type Slots = Readonly&lt;InternalSlots&gt;</span><span class="s0">;</span>

<span class="s3">/**</span>
 <span class="s3">* Use this for features where legacy usage is still possible, but will likely</span>
 <span class="s3">* lead to runtime error if compat is disabled. (warn in all cases)</span>
 <span class="s3">*/</span>
<span class="s1">declare </span><span class="s0">function </span><span class="s1">softAssertCompatEnabled(key: DeprecationTypes</span><span class="s0">, </span><span class="s1">instance: ComponentInternalInstance | </span><span class="s0">null, </span><span class="s1">...args: any[]): boolean</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">const </span><span class="s1">ssrContextKey: unique symbol</span><span class="s0">;</span>

<span class="s1">declare type SSRDirectiveHook = (binding: DirectiveBinding</span><span class="s0">, </span><span class="s1">vnode: VNode) =&gt; Data | undefined</span><span class="s0">;</span>

<span class="s1">declare type SSRSlot = (...args: any[]) =&gt; VNode[] | undefined</span><span class="s0">;</span>

<span class="s4">/* Excluded from this release type: ssrUtils */</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">const </span><span class="s1">Static: unique symbol</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">{ stop_2 as stop }</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">const </span><span class="s1">Suspense: {</span>
    <span class="s0">new </span><span class="s1">(): {</span>
        <span class="s1">$props: VNodeProps &amp; SuspenseProps</span><span class="s0">;</span>
    <span class="s1">}</span><span class="s0">;</span>
    <span class="s1">__isSuspense: </span><span class="s0">true;</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">interface </span><span class="s1">SuspenseBoundary {</span>
    <span class="s1">vnode: VNode&lt;RendererNode</span><span class="s0">, </span><span class="s1">RendererElement</span><span class="s0">, </span><span class="s1">SuspenseProps&gt;</span><span class="s0">;</span>
    <span class="s1">parent: SuspenseBoundary | </span><span class="s0">null;</span>
    <span class="s1">parentComponent: ComponentInternalInstance | </span><span class="s0">null;</span>
    <span class="s1">isSVG: boolean</span><span class="s0">;</span>
    <span class="s1">container: RendererElement</span><span class="s0">;</span>
    <span class="s1">hiddenContainer: RendererElement</span><span class="s0">;</span>
    <span class="s1">anchor: RendererNode | </span><span class="s0">null;</span>
    <span class="s1">activeBranch: VNode | </span><span class="s0">null;</span>
    <span class="s1">pendingBranch: VNode | </span><span class="s0">null;</span>
    <span class="s1">deps: number</span><span class="s0">;</span>
    <span class="s1">pendingId: number</span><span class="s0">;</span>
    <span class="s1">timeout: number</span><span class="s0">;</span>
    <span class="s1">isInFallback: boolean</span><span class="s0">;</span>
    <span class="s1">isHydrating: boolean</span><span class="s0">;</span>
    <span class="s1">isUnmounted: boolean</span><span class="s0">;</span>
    <span class="s1">effects: Function[]</span><span class="s0">;</span>
    <span class="s1">resolve(force?: boolean): </span><span class="s0">void;</span>
    <span class="s1">fallback(fallbackVNode: VNode): </span><span class="s0">void;</span>
    <span class="s1">move(container: RendererElement</span><span class="s0">, </span><span class="s1">anchor: RendererNode | </span><span class="s0">null, </span><span class="s1">type: MoveType): </span><span class="s0">void;</span>
    <span class="s1">next(): RendererNode | </span><span class="s0">null;</span>
    <span class="s1">registerDep(instance: ComponentInternalInstance</span><span class="s0">, </span><span class="s1">setupRenderEffect: SetupRenderEffectFn): </span><span class="s0">void;</span>
    <span class="s1">unmount(parentSuspense: SuspenseBoundary | </span><span class="s0">null, </span><span class="s1">doRemove?: boolean): </span><span class="s0">void;</span>
<span class="s1">}</span>

<span class="s1">declare </span><span class="s0">const </span><span class="s1">SuspenseImpl: {</span>
    <span class="s1">name: string</span><span class="s0">;</span>
    <span class="s1">__isSuspense: boolean</span><span class="s0">;</span>
    <span class="s1">process(n1: VNode | </span><span class="s0">null, </span><span class="s1">n2: VNode</span><span class="s0">, </span><span class="s1">container: RendererElement</span><span class="s0">, </span><span class="s1">anchor: RendererNode | </span><span class="s0">null, </span><span class="s1">parentComponent: ComponentInternalInstance | </span><span class="s0">null, </span><span class="s1">parentSuspense: SuspenseBoundary | </span><span class="s0">null, </span><span class="s1">isSVG: boolean</span><span class="s0">, </span><span class="s1">slotScopeIds: string[] | </span><span class="s0">null, </span><span class="s1">optimized: boolean</span><span class="s0">, </span><span class="s1">rendererInternals: RendererInternals): </span><span class="s0">void;</span>
    <span class="s1">hydrate: </span><span class="s0">typeof </span><span class="s1">hydrateSuspense</span><span class="s0">;</span>
    <span class="s1">create: </span><span class="s0">typeof </span><span class="s1">createSuspenseBoundary</span><span class="s0">;</span>
    <span class="s1">normalize: </span><span class="s0">typeof </span><span class="s1">normalizeSuspenseChildren</span><span class="s0">;</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">interface </span><span class="s1">SuspenseProps {</span>
    <span class="s1">onResolve?: () =&gt; </span><span class="s0">void;</span>
    <span class="s1">onPending?: () =&gt; </span><span class="s0">void;</span>
    <span class="s1">onFallback?: () =&gt; </span><span class="s0">void;</span>
    <span class="s1">timeout?: string | number</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">const </span><span class="s1">Teleport: {</span>
    <span class="s0">new </span><span class="s1">(): {</span>
        <span class="s1">$props: VNodeProps &amp; TeleportProps</span><span class="s0">;</span>
    <span class="s1">}</span><span class="s0">;</span>
    <span class="s1">__isTeleport: </span><span class="s0">true;</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s1">declare </span><span class="s0">const </span><span class="s1">TeleportImpl: {</span>
    <span class="s1">__isTeleport: boolean</span><span class="s0">;</span>
    <span class="s1">process(n1: TeleportVNode | </span><span class="s0">null, </span><span class="s1">n2: TeleportVNode</span><span class="s0">, </span><span class="s1">container: RendererElement</span><span class="s0">, </span><span class="s1">anchor: RendererNode | </span><span class="s0">null, </span><span class="s1">parentComponent: ComponentInternalInstance | </span><span class="s0">null, </span><span class="s1">parentSuspense: SuspenseBoundary | </span><span class="s0">null, </span><span class="s1">isSVG: boolean</span><span class="s0">, </span><span class="s1">slotScopeIds: string[] | </span><span class="s0">null, </span><span class="s1">optimized: boolean</span><span class="s0">, </span><span class="s1">internals: RendererInternals): </span><span class="s0">void;</span>
    <span class="s1">remove(vnode: VNode</span><span class="s0">, </span><span class="s1">parentComponent: ComponentInternalInstance | </span><span class="s0">null, </span><span class="s1">parentSuspense: SuspenseBoundary | </span><span class="s0">null, </span><span class="s1">optimized: boolean</span><span class="s0">, </span><span class="s1">{ um</span><span class="s0">, </span><span class="s1">o: { remove } }: RendererInternals</span><span class="s0">, </span><span class="s1">doRemove: Boolean): </span><span class="s0">void;</span>
    <span class="s1">move: </span><span class="s0">typeof </span><span class="s1">moveTeleport</span><span class="s0">;</span>
    <span class="s1">hydrate: </span><span class="s0">typeof </span><span class="s1">hydrateTeleport</span><span class="s0">;</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s1">declare </span><span class="s0">const enum </span><span class="s1">TeleportMoveTypes {</span>
    <span class="s1">TARGET_CHANGE = </span><span class="s6">0</span><span class="s0">,</span>
    <span class="s1">TOGGLE = </span><span class="s6">1</span><span class="s0">,</span>
    <span class="s1">REORDER = </span><span class="s6">2</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">interface </span><span class="s1">TeleportProps {</span>
    <span class="s1">to: string | RendererElement | </span><span class="s0">null </span><span class="s1">| undefined</span><span class="s0">;</span>
    <span class="s1">disabled?: boolean</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s1">declare type TeleportVNode = VNode&lt;RendererNode</span><span class="s0">, </span><span class="s1">RendererElement</span><span class="s0">, </span><span class="s1">TeleportProps&gt;</span><span class="s0">;</span>

<span class="s1">declare </span><span class="s0">const </span><span class="s1">Text_2: unique symbol</span><span class="s0">;</span>
<span class="s0">export </span><span class="s1">{ Text_2 as Text }</span>

<span class="s0">export </span><span class="s1">{ toDisplayString }</span>

<span class="s0">export </span><span class="s1">{ toHandlerKey }</span>

<span class="s3">/**</span>
 <span class="s3">* For prefixing keys in v-on=&quot;obj&quot; with &quot;on&quot;</span>
 <span class="s3">* </span><span class="s5">@private</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">toHandlers(obj: Record&lt;string</span><span class="s0">, </span><span class="s1">any&gt;</span><span class="s0">, </span><span class="s1">preserveCaseIfNecessary?: boolean): Record&lt;string</span><span class="s0">, </span><span class="s1">any&gt;</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">{ toRaw }</span>

<span class="s0">export </span><span class="s1">{ ToRef }</span>

<span class="s0">export </span><span class="s1">{ toRef }</span>

<span class="s0">export </span><span class="s1">{ ToRefs }</span>

<span class="s0">export </span><span class="s1">{ toRefs }</span>

<span class="s0">export </span><span class="s1">{ TrackOpTypes }</span>

<span class="s3">/**</span>
 <span class="s3">* Internal API for registering an arguments transform for createVNode</span>
 <span class="s3">* used for creating stubs in the test-utils</span>
 <span class="s3">* It is *internal* but needs to be exposed for test-utils to pick up proper</span>
 <span class="s3">* typings</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">transformVNodeArgs(transformer?: </span><span class="s0">typeof </span><span class="s1">vnodeArgsTransformer): </span><span class="s0">void;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">interface </span><span class="s1">TransitionHooks&lt;HostElement = RendererElement&gt; {</span>
    <span class="s1">mode: BaseTransitionProps[</span><span class="s2">'mode'</span><span class="s1">]</span><span class="s0">;</span>
    <span class="s1">persisted: boolean</span><span class="s0">;</span>
    <span class="s1">beforeEnter(el: HostElement): </span><span class="s0">void;</span>
    <span class="s1">enter(el: HostElement): </span><span class="s0">void;</span>
    <span class="s1">leave(el: HostElement</span><span class="s0">, </span><span class="s1">remove: () =&gt; </span><span class="s0">void</span><span class="s1">): </span><span class="s0">void;</span>
    <span class="s1">clone(vnode: VNode): TransitionHooks&lt;HostElement&gt;</span><span class="s0">;</span>
    <span class="s1">afterLeave?(): </span><span class="s0">void;</span>
    <span class="s1">delayLeave?(el: HostElement</span><span class="s0">, </span><span class="s1">earlyRemove: () =&gt; </span><span class="s0">void, </span><span class="s1">delayedLeave: () =&gt; </span><span class="s0">void</span><span class="s1">): </span><span class="s0">void;</span>
    <span class="s1">delayedLeave?(): </span><span class="s0">void;</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">interface </span><span class="s1">TransitionState {</span>
    <span class="s1">isMounted: boolean</span><span class="s0">;</span>
    <span class="s1">isLeaving: boolean</span><span class="s0">;</span>
    <span class="s1">isUnmounting: boolean</span><span class="s0">;</span>
    <span class="s1">leavingVNodes: Map&lt;any</span><span class="s0">, </span><span class="s1">Record&lt;string</span><span class="s0">, </span><span class="s1">VNode&gt;&gt;</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">{ TriggerOpTypes }</span>

<span class="s0">export </span><span class="s1">{ triggerRef }</span>

<span class="s1">declare type UnmountChildrenFn = (children: VNode[]</span><span class="s0">, </span><span class="s1">parentComponent: ComponentInternalInstance | </span><span class="s0">null, </span><span class="s1">parentSuspense: SuspenseBoundary | </span><span class="s0">null, </span><span class="s1">doRemove?: boolean</span><span class="s0">, </span><span class="s1">optimized?: boolean</span><span class="s0">, </span><span class="s1">start?: number) =&gt; </span><span class="s0">void;</span>

<span class="s1">declare type UnmountFn = (vnode: VNode</span><span class="s0">, </span><span class="s1">parentComponent: ComponentInternalInstance | </span><span class="s0">null, </span><span class="s1">parentSuspense: SuspenseBoundary | </span><span class="s0">null, </span><span class="s1">doRemove?: boolean</span><span class="s0">, </span><span class="s1">optimized?: boolean) =&gt; </span><span class="s0">void;</span>

<span class="s0">export </span><span class="s1">{ unref }</span>

<span class="s1">declare type UnwrapMixinsType&lt;T</span><span class="s0">, </span><span class="s1">Type </span><span class="s0">extends </span><span class="s1">OptionTypesKeys&gt; = T </span><span class="s0">extends </span><span class="s1">OptionTypesType ? T[Type] : never</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">{ UnwrapNestedRefs }</span>

<span class="s0">export </span><span class="s1">{ UnwrapRef }</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">useAttrs(): SetupContext[</span><span class="s2">'attrs'</span><span class="s1">]</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">useSlots(): SetupContext[</span><span class="s2">'slots'</span><span class="s1">]</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">const </span><span class="s1">useSSRContext: &lt;T = Record&lt;string</span><span class="s0">, </span><span class="s1">any&gt;&gt;() =&gt; T | undefined</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">useTransitionState(): TransitionState</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">const </span><span class="s1">version: string</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">interface </span><span class="s1">VNode&lt;HostNode = RendererNode</span><span class="s0">, </span><span class="s1">HostElement = RendererElement</span><span class="s0">, </span><span class="s1">ExtraProps = {</span>
    <span class="s1">[key: string]: any</span><span class="s0">;</span>
<span class="s1">}&gt; {</span>
    <span class="s4">/* Excluded from this release type: __v_isVNode */</span>
    <span class="s4">/* Excluded from this release type: __v_skip */</span>
    <span class="s1">type: VNodeTypes</span><span class="s0">;</span>
    <span class="s1">props: (VNodeProps &amp; ExtraProps) | </span><span class="s0">null;</span>
    <span class="s1">key: string | number | symbol | </span><span class="s0">null;</span>
    <span class="s1">ref: VNodeNormalizedRef | </span><span class="s0">null;</span>
    <span class="s3">/**</span>
     <span class="s3">* SFC only. This is assigned on vnode creation using currentScopeId</span>
     <span class="s3">* which is set alongside currentRenderingInstance.</span>
     <span class="s3">*/</span>
    <span class="s1">scopeId: string | </span><span class="s0">null;</span>
    <span class="s4">/* Excluded from this release type: slotScopeIds */</span>
    <span class="s1">children: VNodeNormalizedChildren</span><span class="s0">;</span>
    <span class="s1">component: ComponentInternalInstance | </span><span class="s0">null;</span>
    <span class="s1">dirs: DirectiveBinding[] | </span><span class="s0">null;</span>
    <span class="s1">transition: TransitionHooks&lt;HostElement&gt; | </span><span class="s0">null;</span>
    <span class="s1">el: HostNode | </span><span class="s0">null;</span>
    <span class="s1">anchor: HostNode | </span><span class="s0">null;</span>
    <span class="s1">target: HostElement | </span><span class="s0">null;</span>
    <span class="s1">targetAnchor: HostNode | </span><span class="s0">null;</span>
    <span class="s4">/* Excluded from this release type: staticCount */</span>
    <span class="s1">suspense: SuspenseBoundary | </span><span class="s0">null;</span>
    <span class="s4">/* Excluded from this release type: ssContent */</span>
    <span class="s4">/* Excluded from this release type: ssFallback */</span>
    <span class="s1">shapeFlag: number</span><span class="s0">;</span>
    <span class="s1">patchFlag: number</span><span class="s0">;</span>
    <span class="s4">/* Excluded from this release type: dynamicProps */</span>
    <span class="s4">/* Excluded from this release type: dynamicChildren */</span>
    <span class="s1">appContext: AppContext | </span><span class="s0">null;</span>
    <span class="s4">/* Excluded from this release type: ctx */</span>
    <span class="s4">/* Excluded from this release type: memo */</span>
    <span class="s4">/* Excluded from this release type: isCompatRoot */</span>
    <span class="s4">/* Excluded from this release type: ce */</span>
<span class="s1">}</span>

<span class="s1">declare </span><span class="s0">let </span><span class="s1">vnodeArgsTransformer: ((args: Parameters&lt;</span><span class="s0">typeof </span><span class="s1">_createVNode&gt;</span><span class="s0">, </span><span class="s1">instance: ComponentInternalInstance | </span><span class="s0">null</span><span class="s1">) =&gt; Parameters&lt;</span><span class="s0">typeof </span><span class="s1">_createVNode&gt;) | undefined</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare type VNodeArrayChildren = Array&lt;VNodeArrayChildren | VNodeChildAtom&gt;</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare type VNodeChild = VNodeChildAtom | VNodeArrayChildren</span><span class="s0">;</span>

<span class="s1">declare type VNodeChildAtom = VNode | string | number | boolean | </span><span class="s0">null </span><span class="s1">| undefined | </span><span class="s0">void;</span>

<span class="s1">declare type VNodeMountHook = (vnode: VNode) =&gt; </span><span class="s0">void;</span>

<span class="s0">export </span><span class="s1">declare type VNodeNormalizedChildren = string | VNodeArrayChildren | RawSlots | </span><span class="s0">null;</span>

<span class="s1">declare type VNodeNormalizedRef = VNodeNormalizedRefAtom | VNodeNormalizedRefAtom[]</span><span class="s0">;</span>

<span class="s1">declare type VNodeNormalizedRefAtom = {</span>
    <span class="s1">i: ComponentInternalInstance</span><span class="s0">;</span>
    <span class="s1">r: VNodeRef</span><span class="s0">;</span>
    <span class="s1">k?: string</span><span class="s0">;</span>
    <span class="s1">f?: boolean</span><span class="s0">;</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare type VNodeProps = {</span>
    <span class="s1">key?: string | number | symbol</span><span class="s0">;</span>
    <span class="s1">ref?: VNodeRef</span><span class="s0">;</span>
    <span class="s1">ref_for?: boolean</span><span class="s0">;</span>
    <span class="s1">ref_key?: string</span><span class="s0">;</span>
    <span class="s1">onVnodeBeforeMount?: VNodeMountHook | VNodeMountHook[]</span><span class="s0">;</span>
    <span class="s1">onVnodeMounted?: VNodeMountHook | VNodeMountHook[]</span><span class="s0">;</span>
    <span class="s1">onVnodeBeforeUpdate?: VNodeUpdateHook | VNodeUpdateHook[]</span><span class="s0">;</span>
    <span class="s1">onVnodeUpdated?: VNodeUpdateHook | VNodeUpdateHook[]</span><span class="s0">;</span>
    <span class="s1">onVnodeBeforeUnmount?: VNodeMountHook | VNodeMountHook[]</span><span class="s0">;</span>
    <span class="s1">onVnodeUnmounted?: VNodeMountHook | VNodeMountHook[]</span><span class="s0">;</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare type VNodeRef = string | Ref | ((ref: Element | ComponentPublicInstance | </span><span class="s0">null, </span><span class="s1">refs: Record&lt;string</span><span class="s0">, </span><span class="s1">any&gt;) =&gt; </span><span class="s0">void</span><span class="s1">)</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare type VNodeTypes = string | VNode | Component | </span><span class="s0">typeof </span><span class="s1">Text_2 | </span><span class="s0">typeof </span><span class="s1">Static | </span><span class="s0">typeof </span><span class="s1">Comment_2 | </span><span class="s0">typeof </span><span class="s1">Fragment | </span><span class="s0">typeof </span><span class="s1">Teleport | </span><span class="s0">typeof </span><span class="s1">TeleportImpl | </span><span class="s0">typeof </span><span class="s1">Suspense | </span><span class="s0">typeof </span><span class="s1">SuspenseImpl</span><span class="s0">;</span>

<span class="s1">declare type VNodeUpdateHook = (vnode: VNode</span><span class="s0">, </span><span class="s1">oldVNode: VNode) =&gt; </span><span class="s0">void;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">warn(msg: string</span><span class="s0">, </span><span class="s1">...args: any[]): </span><span class="s0">void;</span>

<span class="s1">declare </span><span class="s0">function </span><span class="s1">warnDeprecation(key: DeprecationTypes</span><span class="s0">, </span><span class="s1">instance: ComponentInternalInstance | </span><span class="s0">null, </span><span class="s1">...args: any[]): </span><span class="s0">void;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">watch&lt;T </span><span class="s0">extends </span><span class="s1">MultiWatchSources</span><span class="s0">, </span><span class="s1">Immediate </span><span class="s0">extends </span><span class="s1">Readonly&lt;boolean&gt; = </span><span class="s0">false</span><span class="s1">&gt;(sources: [...T]</span><span class="s0">, </span><span class="s1">cb: WatchCallback&lt;MapSources&lt;T</span><span class="s0">, false</span><span class="s1">&gt;</span><span class="s0">, </span><span class="s1">MapSources&lt;T</span><span class="s0">, </span><span class="s1">Immediate&gt;&gt;</span><span class="s0">, </span><span class="s1">options?: WatchOptions&lt;Immediate&gt;): WatchStopHandle</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">watch&lt;T </span><span class="s0">extends </span><span class="s1">Readonly&lt;MultiWatchSources&gt;</span><span class="s0">, </span><span class="s1">Immediate </span><span class="s0">extends </span><span class="s1">Readonly&lt;boolean&gt; = </span><span class="s0">false</span><span class="s1">&gt;(source: T</span><span class="s0">, </span><span class="s1">cb: WatchCallback&lt;MapSources&lt;T</span><span class="s0">, false</span><span class="s1">&gt;</span><span class="s0">, </span><span class="s1">MapSources&lt;T</span><span class="s0">, </span><span class="s1">Immediate&gt;&gt;</span><span class="s0">, </span><span class="s1">options?: WatchOptions&lt;Immediate&gt;): WatchStopHandle</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">watch&lt;T</span><span class="s0">, </span><span class="s1">Immediate </span><span class="s0">extends </span><span class="s1">Readonly&lt;boolean&gt; = </span><span class="s0">false</span><span class="s1">&gt;(source: WatchSource&lt;T&gt;</span><span class="s0">, </span><span class="s1">cb: WatchCallback&lt;T</span><span class="s0">, </span><span class="s1">Immediate </span><span class="s0">extends true </span><span class="s1">? T | undefined : T&gt;</span><span class="s0">, </span><span class="s1">options?: WatchOptions&lt;Immediate&gt;): WatchStopHandle</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">watch&lt;T </span><span class="s0">extends </span><span class="s1">object</span><span class="s0">, </span><span class="s1">Immediate </span><span class="s0">extends </span><span class="s1">Readonly&lt;boolean&gt; = </span><span class="s0">false</span><span class="s1">&gt;(source: T</span><span class="s0">, </span><span class="s1">cb: WatchCallback&lt;T</span><span class="s0">, </span><span class="s1">Immediate </span><span class="s0">extends true </span><span class="s1">? T | undefined : T&gt;</span><span class="s0">, </span><span class="s1">options?: WatchOptions&lt;Immediate&gt;): WatchStopHandle</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare type WatchCallback&lt;V = any</span><span class="s0">, </span><span class="s1">OV = any&gt; = (value: V</span><span class="s0">, </span><span class="s1">oldValue: OV</span><span class="s0">, </span><span class="s1">onCleanup: OnCleanup) =&gt; any</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare type WatchEffect = (onCleanup: OnCleanup) =&gt; </span><span class="s0">void;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">watchEffect(effect: WatchEffect</span><span class="s0">, </span><span class="s1">options?: WatchOptionsBase): WatchStopHandle</span><span class="s0">;</span>

<span class="s1">declare type WatchOptionItem = string | WatchCallback | ObjectWatchOptionItem</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">interface </span><span class="s1">WatchOptions&lt;Immediate = boolean&gt; </span><span class="s0">extends </span><span class="s1">WatchOptionsBase {</span>
    <span class="s1">immediate?: Immediate</span><span class="s0">;</span>
    <span class="s1">deep?: boolean</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">interface </span><span class="s1">WatchOptionsBase </span><span class="s0">extends </span><span class="s1">DebuggerOptions {</span>
    <span class="s1">flush?: </span><span class="s2">'pre' </span><span class="s1">| </span><span class="s2">'post' </span><span class="s1">| </span><span class="s2">'sync'</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">watchPostEffect(effect: WatchEffect</span><span class="s0">, </span><span class="s1">options?: DebuggerOptions): WatchStopHandle</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare type WatchSource&lt;T = any&gt; = Ref&lt;T&gt; | ComputedRef&lt;T&gt; | (() =&gt; T)</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare type WatchStopHandle = () =&gt; </span><span class="s0">void;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">watchSyncEffect(effect: WatchEffect</span><span class="s0">, </span><span class="s1">options?: DebuggerOptions): WatchStopHandle</span><span class="s0">;</span>

<span class="s4">/* Excluded from this release type: withAsyncContext */</span>

<span class="s3">/**</span>
 <span class="s3">* Wrap a slot function to memoize current rendering instance</span>
 <span class="s3">* </span><span class="s5">@private </span><span class="s3">compiler helper</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">withCtx(fn: Function</span><span class="s0">, </span><span class="s1">ctx?: ComponentInternalInstance | </span><span class="s0">null, </span><span class="s1">isNonScopedSlot?: boolean): Function</span><span class="s0">;</span>

<span class="s3">/**</span>
 <span class="s3">* Vue `&lt;script setup&gt;` compiler macro for providing props default values when</span>
 <span class="s3">* using type-based `defineProps` declaration.</span>
 <span class="s3">*</span>
 <span class="s3">* Example usage:</span>
 <span class="s3">* ```ts</span>
 <span class="s3">* withDefaults(defineProps&lt;{</span>
 <span class="s3">*   size?: number</span>
 <span class="s3">*   labels?: string[]</span>
 <span class="s3">* }&gt;(), {</span>
 <span class="s3">*   size: 3,</span>
 <span class="s3">*   labels: () =&gt; ['default label']</span>
 <span class="s3">* })</span>
 <span class="s3">* ```</span>
 <span class="s3">*</span>
 <span class="s3">* This is only usable inside `&lt;script setup&gt;`, is compiled away in the output</span>
 <span class="s3">* and should **not** be actually called at runtime.</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">withDefaults&lt;Props</span><span class="s0">, </span><span class="s1">Defaults </span><span class="s0">extends </span><span class="s1">InferDefaults&lt;Props&gt;&gt;(props: Props</span><span class="s0">, </span><span class="s1">defaults: Defaults): PropsWithDefaults&lt;Props</span><span class="s0">, </span><span class="s1">Defaults&gt;</span><span class="s0">;</span>

<span class="s3">/**</span>
 <span class="s3">* Adds directives to a VNode.</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">withDirectives&lt;T </span><span class="s0">extends </span><span class="s1">VNode&gt;(vnode: T</span><span class="s0">, </span><span class="s1">directives: DirectiveArguments): T</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">declare </span><span class="s0">function </span><span class="s1">withMemo(memo: any[]</span><span class="s0">, </span><span class="s1">render: () =&gt; VNode&lt;any</span><span class="s0">, </span><span class="s1">any&gt;</span><span class="s0">, </span><span class="s1">cache: any[]</span><span class="s0">, </span><span class="s1">index: number): VNode&lt;any</span><span class="s0">, </span><span class="s1">any</span><span class="s0">, </span><span class="s1">{</span>
    <span class="s1">[key: string]: any</span><span class="s0">;</span>
<span class="s1">}&gt;</span><span class="s0">;</span>

<span class="s3">/**</span>
 <span class="s3">* Only for backwards compat</span>
 <span class="s3">* </span><span class="s5">@private</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">const </span><span class="s1">withScopeId: (_id: string) =&gt; </span><span class="s0">typeof </span><span class="s1">withCtx</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">{ WritableComputedOptions }</span>

<span class="s0">export </span><span class="s1">{ WritableComputedRef }</span>

<span class="s0">export </span><span class="s1">{ }</span>

<span class="s4">// Note: this file is auto concatenated to the end of the bundled d.ts during</span>
<span class="s4">// build.</span>

<span class="s1">declare module </span><span class="s2">'@vue/reactivity' </span><span class="s1">{</span>
  <span class="s0">export interface </span><span class="s1">RefUnwrapBailTypes {</span>
    <span class="s1">runtimeCoreBailTypes:</span>
      <span class="s1">| VNode</span>
      <span class="s1">| {</span>
          <span class="s4">// directly bailing on ComponentPublicInstance results in recursion</span>
          <span class="s4">// so we use this as a bail hint</span>
          <span class="s1">$: ComponentInternalInstance</span>
        <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s4">// Note: this file is auto concatenated to the end of the bundled d.ts during</span>
<span class="s4">// build.</span>
<span class="s1">type _defineProps = </span><span class="s0">typeof </span><span class="s1">defineProps</span>
<span class="s1">type _defineEmits = </span><span class="s0">typeof </span><span class="s1">defineEmits</span>
<span class="s1">type _defineExpose = </span><span class="s0">typeof </span><span class="s1">defineExpose</span>
<span class="s1">type _withDefaults = </span><span class="s0">typeof </span><span class="s1">withDefaults</span>

<span class="s1">declare global {</span>
  <span class="s0">const </span><span class="s1">defineProps: _defineProps</span>
  <span class="s0">const </span><span class="s1">defineEmits: _defineEmits</span>
  <span class="s0">const </span><span class="s1">defineExpose: _defineExpose</span>
  <span class="s0">const </span><span class="s1">withDefaults: _withDefaults</span>
<span class="s1">}</span>
</pre>
</body>
</html>