<html>
<head>
<title>vue.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #629755; font-style: italic;}
.s6 { color: #629755; font-weight: bold; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
vue.js</font>
</center></td></tr></table>
<pre><span class="s0">// node_modules/@vue/shared/dist/shared.esm-bundler.js</span>
<span class="s2">function </span><span class="s1">makeMap(str</span><span class="s2">, </span><span class="s1">expectsLowerCase) {</span>
  <span class="s2">const </span><span class="s1">map2 = </span><span class="s0">/* @__PURE__ */ </span><span class="s1">Object.create(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">list = str.split(</span><span class="s3">&quot;,&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; list.length</span><span class="s2">; </span><span class="s1">i++) {</span>
    <span class="s1">map2[list[i]] = </span><span class="s2">true;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">expectsLowerCase ? (val) =&gt; !!map2[val.toLowerCase()] : (val) =&gt; !!map2[val]</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">GLOBALS_WHITE_LISTED = </span><span class="s3">&quot;Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt&quot;</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">isGloballyWhitelisted = makeMap(GLOBALS_WHITE_LISTED)</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">normalizeStyle(value) {</span>
  <span class="s2">if </span><span class="s1">(isArray(value)) {</span>
    <span class="s2">const </span><span class="s1">res = {}</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; value.length</span><span class="s2">; </span><span class="s1">i++) {</span>
      <span class="s2">const </span><span class="s1">item = value[i]</span><span class="s2">;</span>
      <span class="s2">const </span><span class="s1">normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(normalized) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">normalized) {</span>
          <span class="s1">res[key] = normalized[key]</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">res</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isString(value)) {</span>
    <span class="s2">return </span><span class="s1">value</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isObject(value)) {</span>
    <span class="s2">return </span><span class="s1">value</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">listDelimiterRE = </span><span class="s4">/;(?![^(]*\))/g</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">propertyDelimiterRE = </span><span class="s4">/:([^]+)/</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">styleCommentRE = </span><span class="s4">/\/\*.*?\*\//gs</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">parseStringStyle(cssText) {</span>
  <span class="s2">const </span><span class="s1">ret = {}</span><span class="s2">;</span>
  <span class="s1">cssText.replace(styleCommentRE</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">).split(listDelimiterRE).forEach((item) =&gt; {</span>
    <span class="s2">if </span><span class="s1">(item) {</span>
      <span class="s2">const </span><span class="s1">tmp = item.split(propertyDelimiterRE)</span><span class="s2">;</span>
      <span class="s1">tmp.length &gt; </span><span class="s4">1 </span><span class="s1">&amp;&amp; (ret[tmp[</span><span class="s4">0</span><span class="s1">].trim()] = tmp[</span><span class="s4">1</span><span class="s1">].trim())</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">})</span><span class="s2">;</span>
  <span class="s2">return </span><span class="s1">ret</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">normalizeClass(value) {</span>
  <span class="s2">let </span><span class="s1">res = </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(isString(value)) {</span>
    <span class="s1">res = value</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isArray(value)) {</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; value.length</span><span class="s2">; </span><span class="s1">i++) {</span>
      <span class="s2">const </span><span class="s1">normalized = normalizeClass(value[i])</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(normalized) {</span>
        <span class="s1">res += normalized + </span><span class="s3">&quot; &quot;</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isObject(value)) {</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">name </span><span class="s2">in </span><span class="s1">value) {</span>
      <span class="s2">if </span><span class="s1">(value[name]) {</span>
        <span class="s1">res += name + </span><span class="s3">&quot; &quot;</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">res.trim()</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">normalizeProps(props) {</span>
  <span class="s2">if </span><span class="s1">(!props)</span>
    <span class="s2">return null;</span>
  <span class="s2">let </span><span class="s1">{ </span><span class="s2">class</span><span class="s1">: klass</span><span class="s2">, </span><span class="s1">style } = props</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(klass &amp;&amp; !isString(klass)) {</span>
    <span class="s1">props.class = normalizeClass(klass)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(style) {</span>
    <span class="s1">props.style = normalizeStyle(style)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">props</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">HTML_TAGS = </span><span class="s3">&quot;html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot&quot;</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">SVG_TAGS = </span><span class="s3">&quot;svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view&quot;</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">VOID_TAGS = </span><span class="s3">&quot;area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr&quot;</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">isHTMLTag = makeMap(HTML_TAGS)</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">isSVGTag = makeMap(SVG_TAGS)</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">isVoidTag = makeMap(VOID_TAGS)</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">specialBooleanAttrs = </span><span class="s3">`itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">isSpecialBooleanAttr = makeMap(specialBooleanAttrs)</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">isBooleanAttr = makeMap(specialBooleanAttrs + </span><span class="s3">`,async,autofocus,autoplay,controls,default,defer,disabled,hidden,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">includeBooleanAttr(value) {</span>
  <span class="s2">return </span><span class="s1">!!value || value === </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">isKnownHtmlAttr = makeMap(</span><span class="s3">`accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap`</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">isKnownSvgAttr = makeMap(</span><span class="s3">`xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">looseCompareArrays(a</span><span class="s2">, </span><span class="s1">b) {</span>
  <span class="s2">if </span><span class="s1">(a.length !== b.length)</span>
    <span class="s2">return false;</span>
  <span class="s2">let </span><span class="s1">equal = </span><span class="s2">true;</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">equal &amp;&amp; i &lt; a.length</span><span class="s2">; </span><span class="s1">i++) {</span>
    <span class="s1">equal = looseEqual(a[i]</span><span class="s2">, </span><span class="s1">b[i])</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">equal</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">looseEqual(a</span><span class="s2">, </span><span class="s1">b) {</span>
  <span class="s2">if </span><span class="s1">(a === b)</span>
    <span class="s2">return true;</span>
  <span class="s2">let </span><span class="s1">aValidType = isDate(a)</span><span class="s2">;</span>
  <span class="s2">let </span><span class="s1">bValidType = isDate(b)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(aValidType || bValidType) {</span>
    <span class="s2">return </span><span class="s1">aValidType &amp;&amp; bValidType ? a.getTime() === b.getTime() : </span><span class="s2">false;</span>
  <span class="s1">}</span>
  <span class="s1">aValidType = isSymbol(a)</span><span class="s2">;</span>
  <span class="s1">bValidType = isSymbol(b)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(aValidType || bValidType) {</span>
    <span class="s2">return </span><span class="s1">a === b</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s1">aValidType = isArray(a)</span><span class="s2">;</span>
  <span class="s1">bValidType = isArray(b)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(aValidType || bValidType) {</span>
    <span class="s2">return </span><span class="s1">aValidType &amp;&amp; bValidType ? looseCompareArrays(a</span><span class="s2">, </span><span class="s1">b) : </span><span class="s2">false;</span>
  <span class="s1">}</span>
  <span class="s1">aValidType = isObject(a)</span><span class="s2">;</span>
  <span class="s1">bValidType = isObject(b)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(aValidType || bValidType) {</span>
    <span class="s2">if </span><span class="s1">(!aValidType || !bValidType) {</span>
      <span class="s2">return false;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">aKeysCount = Object.keys(a).length</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">bKeysCount = Object.keys(b).length</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(aKeysCount !== bKeysCount) {</span>
      <span class="s2">return false;</span>
    <span class="s1">}</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">a) {</span>
      <span class="s2">const </span><span class="s1">aHasKey = a.hasOwnProperty(key)</span><span class="s2">;</span>
      <span class="s2">const </span><span class="s1">bHasKey = b.hasOwnProperty(key)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(aHasKey &amp;&amp; !bHasKey || !aHasKey &amp;&amp; bHasKey || !looseEqual(a[key]</span><span class="s2">, </span><span class="s1">b[key])) {</span>
        <span class="s2">return false;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">String(a) === String(b)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">looseIndexOf(arr</span><span class="s2">, </span><span class="s1">val) {</span>
  <span class="s2">return </span><span class="s1">arr.findIndex((item) =&gt; looseEqual(item</span><span class="s2">, </span><span class="s1">val))</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">toDisplayString = (val) =&gt; {</span>
  <span class="s2">return </span><span class="s1">isString(val) ? val : val == </span><span class="s2">null </span><span class="s1">? </span><span class="s3">&quot;&quot; </span><span class="s1">: isArray(val) || isObject(val) &amp;&amp; (val.toString === objectToString || !isFunction(val.toString)) ? JSON.stringify(val</span><span class="s2">, </span><span class="s1">replacer</span><span class="s2">, </span><span class="s4">2</span><span class="s1">) : String(val)</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">replacer = (_key</span><span class="s2">, </span><span class="s1">val) =&gt; {</span>
  <span class="s2">if </span><span class="s1">(val &amp;&amp; val.__v_isRef) {</span>
    <span class="s2">return </span><span class="s1">replacer(_key</span><span class="s2">, </span><span class="s1">val.value)</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isMap(val)) {</span>
    <span class="s2">return </span><span class="s1">{</span>
      <span class="s1">[</span><span class="s3">`Map(</span><span class="s1">${val.size}</span><span class="s3">)`</span><span class="s1">]: [...val.entries()].reduce((entries</span><span class="s2">, </span><span class="s1">[key</span><span class="s2">, </span><span class="s1">val2]) =&gt; {</span>
        <span class="s1">entries[</span><span class="s3">`</span><span class="s1">${key} </span><span class="s3">=&gt;`</span><span class="s1">] = val2</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">entries</span><span class="s2">;</span>
      <span class="s1">}</span><span class="s2">, </span><span class="s1">{})</span>
    <span class="s1">}</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isSet(val)) {</span>
    <span class="s2">return </span><span class="s1">{</span>
      <span class="s1">[</span><span class="s3">`Set(</span><span class="s1">${val.size}</span><span class="s3">)`</span><span class="s1">]: [...val.values()]</span>
    <span class="s1">}</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isObject(val) &amp;&amp; !isArray(val) &amp;&amp; !isPlainObject(val)) {</span>
    <span class="s2">return </span><span class="s1">String(val)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">val</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">EMPTY_OBJ = </span><span class="s2">true </span><span class="s1">? Object.freeze({}) : {}</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">EMPTY_ARR = </span><span class="s2">true </span><span class="s1">? Object.freeze([]) : []</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">NOOP = () =&gt; {</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">NO = () =&gt; </span><span class="s2">false;</span>
<span class="s2">var </span><span class="s1">onRE = </span><span class="s4">/^on[^a-z]/</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">isOn = (key) =&gt; onRE.test(key)</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">isModelListener = (key) =&gt; key.startsWith(</span><span class="s3">&quot;onUpdate:&quot;</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">extend = Object.assign</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">remove = (arr</span><span class="s2">, </span><span class="s1">el) =&gt; {</span>
  <span class="s2">const </span><span class="s1">i = arr.indexOf(el)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(i &gt; -</span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s1">arr.splice(i</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">hasOwnProperty = Object.prototype.hasOwnProperty</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">hasOwn = (val</span><span class="s2">, </span><span class="s1">key) =&gt; hasOwnProperty.call(val</span><span class="s2">, </span><span class="s1">key)</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">isArray = Array.isArray</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">isMap = (val) =&gt; toTypeString(val) === </span><span class="s3">&quot;[object Map]&quot;</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">isSet = (val) =&gt; toTypeString(val) === </span><span class="s3">&quot;[object Set]&quot;</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">isDate = (val) =&gt; toTypeString(val) === </span><span class="s3">&quot;[object Date]&quot;</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">isRegExp = (val) =&gt; toTypeString(val) === </span><span class="s3">&quot;[object RegExp]&quot;</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">isFunction = (val) =&gt; </span><span class="s2">typeof </span><span class="s1">val === </span><span class="s3">&quot;function&quot;</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">isString = (val) =&gt; </span><span class="s2">typeof </span><span class="s1">val === </span><span class="s3">&quot;string&quot;</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">isSymbol = (val) =&gt; </span><span class="s2">typeof </span><span class="s1">val === </span><span class="s3">&quot;symbol&quot;</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">isObject = (val) =&gt; val !== </span><span class="s2">null </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">val === </span><span class="s3">&quot;object&quot;</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">isPromise = (val) =&gt; {</span>
  <span class="s2">return </span><span class="s1">isObject(val) &amp;&amp; isFunction(val.then) &amp;&amp; isFunction(val.catch)</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">objectToString = Object.prototype.toString</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">toTypeString = (value) =&gt; objectToString.call(value)</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">toRawType = (value) =&gt; {</span>
  <span class="s2">return </span><span class="s1">toTypeString(value).slice(</span><span class="s4">8</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">isPlainObject = (val) =&gt; toTypeString(val) === </span><span class="s3">&quot;[object Object]&quot;</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">isIntegerKey = (key) =&gt; isString(key) &amp;&amp; key !== </span><span class="s3">&quot;NaN&quot; </span><span class="s1">&amp;&amp; key[</span><span class="s4">0</span><span class="s1">] !== </span><span class="s3">&quot;-&quot; </span><span class="s1">&amp;&amp; </span><span class="s3">&quot;&quot; </span><span class="s1">+ parseInt(key</span><span class="s2">, </span><span class="s4">10</span><span class="s1">) === key</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">isReservedProp = makeMap(</span>
  <span class="s0">// the leading comma is intentional so empty string &quot;&quot; is also included</span>
  <span class="s3">&quot;,key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted&quot;</span>
<span class="s1">)</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">isBuiltInDirective = makeMap(</span><span class="s3">&quot;bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo&quot;</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">cacheStringFunction = (fn) =&gt; {</span>
  <span class="s2">const </span><span class="s1">cache = </span><span class="s0">/* @__PURE__ */ </span><span class="s1">Object.create(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s2">return </span><span class="s1">(str) =&gt; {</span>
    <span class="s2">const </span><span class="s1">hit = cache[str]</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">hit || (cache[str] = fn(str))</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">camelizeRE = </span><span class="s4">/-(\w)/g</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">camelize = cacheStringFunction((str) =&gt; {</span>
  <span class="s2">return </span><span class="s1">str.replace(camelizeRE</span><span class="s2">, </span><span class="s1">(_</span><span class="s2">, </span><span class="s1">c) =&gt; c ? c.toUpperCase() : </span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">})</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">hyphenateRE = </span><span class="s4">/\B([A-Z])/g</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">hyphenate = cacheStringFunction((str) =&gt; str.replace(hyphenateRE</span><span class="s2">, </span><span class="s3">&quot;-$1&quot;</span><span class="s1">).toLowerCase())</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">capitalize = cacheStringFunction((str) =&gt; str.charAt(</span><span class="s4">0</span><span class="s1">).toUpperCase() + str.slice(</span><span class="s4">1</span><span class="s1">))</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">toHandlerKey = cacheStringFunction((str) =&gt; str ? </span><span class="s3">`on</span><span class="s1">${capitalize(str)}</span><span class="s3">` </span><span class="s1">: </span><span class="s3">``</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">hasChanged = (value</span><span class="s2">, </span><span class="s1">oldValue) =&gt; !Object.is(value</span><span class="s2">, </span><span class="s1">oldValue)</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">invokeArrayFns = (fns</span><span class="s2">, </span><span class="s1">arg) =&gt; {</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; fns.length</span><span class="s2">; </span><span class="s1">i++) {</span>
    <span class="s1">fns[i](arg)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">def = (obj</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value) =&gt; {</span>
  <span class="s1">Object.defineProperty(obj</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">{</span>
    <span class="s1">configurable: </span><span class="s2">true,</span>
    <span class="s1">enumerable: </span><span class="s2">false,</span>
    <span class="s1">value</span>
  <span class="s1">})</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">looseToNumber = (val) =&gt; {</span>
  <span class="s2">const </span><span class="s1">n = parseFloat(val)</span><span class="s2">;</span>
  <span class="s2">return </span><span class="s1">isNaN(n) ? val : n</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">toNumber = (val) =&gt; {</span>
  <span class="s2">const </span><span class="s1">n = isString(val) ? Number(val) : NaN</span><span class="s2">;</span>
  <span class="s2">return </span><span class="s1">isNaN(n) ? val : n</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">_globalThis</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">getGlobalThis = () =&gt; {</span>
  <span class="s2">return </span><span class="s1">_globalThis || (_globalThis = </span><span class="s2">typeof </span><span class="s1">globalThis !== </span><span class="s3">&quot;undefined&quot; </span><span class="s1">? globalThis : </span><span class="s2">typeof </span><span class="s1">self !== </span><span class="s3">&quot;undefined&quot; </span><span class="s1">? self : </span><span class="s2">typeof </span><span class="s1">window !== </span><span class="s3">&quot;undefined&quot; </span><span class="s1">? window : </span><span class="s2">typeof </span><span class="s1">global !== </span><span class="s3">&quot;undefined&quot; </span><span class="s1">? global : {})</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js</span>
<span class="s2">function </span><span class="s1">warn(msg</span><span class="s2">, </span><span class="s1">...args) {</span>
  <span class="s1">console.warn(</span><span class="s3">`[Vue warn] </span><span class="s1">${msg}</span><span class="s3">`</span><span class="s2">, </span><span class="s1">...args)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">activeEffectScope</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">EffectScope = </span><span class="s2">class </span><span class="s1">{</span>
  <span class="s1">constructor(detached = </span><span class="s2">false</span><span class="s1">) {</span>
    <span class="s2">this</span><span class="s1">.detached = detached</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">._active = </span><span class="s2">true;</span>
    <span class="s2">this</span><span class="s1">.effects = []</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">.cleanups = []</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">.parent = activeEffectScope</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!detached &amp;&amp; activeEffectScope) {</span>
      <span class="s2">this</span><span class="s1">.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(</span><span class="s2">this</span><span class="s1">) - </span><span class="s4">1</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">get active() {</span>
    <span class="s2">return this</span><span class="s1">._active</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s1">run(fn) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">._active) {</span>
      <span class="s2">const </span><span class="s1">currentEffectScope = activeEffectScope</span><span class="s2">;</span>
      <span class="s2">try </span><span class="s1">{</span>
        <span class="s1">activeEffectScope = </span><span class="s2">this;</span>
        <span class="s2">return </span><span class="s1">fn()</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
        <span class="s1">activeEffectScope = currentEffectScope</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
      <span class="s1">warn(</span><span class="s3">`cannot run an inactive effect scope.`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s5">/**</span>
   <span class="s5">* This should only be called on non-detached scopes</span>
   <span class="s5">* </span><span class="s6">@internal</span>
   <span class="s5">*/</span>
  <span class="s1">on() {</span>
    <span class="s1">activeEffectScope = </span><span class="s2">this;</span>
  <span class="s1">}</span>
  <span class="s5">/**</span>
   <span class="s5">* This should only be called on non-detached scopes</span>
   <span class="s5">* </span><span class="s6">@internal</span>
   <span class="s5">*/</span>
  <span class="s1">off() {</span>
    <span class="s1">activeEffectScope = </span><span class="s2">this</span><span class="s1">.parent</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s1">stop(fromParent) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">._active) {</span>
      <span class="s2">let </span><span class="s1">i</span><span class="s2">, </span><span class="s1">l</span><span class="s2">;</span>
      <span class="s2">for </span><span class="s1">(i = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">l = </span><span class="s2">this</span><span class="s1">.effects.length</span><span class="s2">; </span><span class="s1">i &lt; l</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s2">this</span><span class="s1">.effects[i].stop()</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">for </span><span class="s1">(i = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">l = </span><span class="s2">this</span><span class="s1">.cleanups.length</span><span class="s2">; </span><span class="s1">i &lt; l</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s2">this</span><span class="s1">.cleanups[i]()</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.scopes) {</span>
        <span class="s2">for </span><span class="s1">(i = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">l = </span><span class="s2">this</span><span class="s1">.scopes.length</span><span class="s2">; </span><span class="s1">i &lt; l</span><span class="s2">; </span><span class="s1">i++) {</span>
          <span class="s2">this</span><span class="s1">.scopes[i].stop(</span><span class="s2">true</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.detached &amp;&amp; </span><span class="s2">this</span><span class="s1">.parent &amp;&amp; !fromParent) {</span>
        <span class="s2">const </span><span class="s1">last = </span><span class="s2">this</span><span class="s1">.parent.scopes.pop()</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(last &amp;&amp; last !== </span><span class="s2">this</span><span class="s1">) {</span>
          <span class="s2">this</span><span class="s1">.parent.scopes[</span><span class="s2">this</span><span class="s1">.index] = last</span><span class="s2">;</span>
          <span class="s1">last.index = </span><span class="s2">this</span><span class="s1">.index</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">this</span><span class="s1">.parent = </span><span class="s2">void </span><span class="s4">0</span><span class="s2">;</span>
      <span class="s2">this</span><span class="s1">._active = </span><span class="s2">false;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">effectScope(detached) {</span>
  <span class="s2">return new </span><span class="s1">EffectScope(detached)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">recordEffectScope(effect2</span><span class="s2">, </span><span class="s1">scope = activeEffectScope) {</span>
  <span class="s2">if </span><span class="s1">(scope &amp;&amp; scope.active) {</span>
    <span class="s1">scope.effects.push(effect2)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getCurrentScope() {</span>
  <span class="s2">return </span><span class="s1">activeEffectScope</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">onScopeDispose(fn) {</span>
  <span class="s2">if </span><span class="s1">(activeEffectScope) {</span>
    <span class="s1">activeEffectScope.cleanups.push(fn)</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s1">warn(</span><span class="s3">`onScopeDispose() is called when there is no active effect scope to be associated with.`</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">createDep = (effects) =&gt; {</span>
  <span class="s2">const </span><span class="s1">dep = </span><span class="s2">new </span><span class="s1">Set(effects)</span><span class="s2">;</span>
  <span class="s1">dep.w = </span><span class="s4">0</span><span class="s2">;</span>
  <span class="s1">dep.n = </span><span class="s4">0</span><span class="s2">;</span>
  <span class="s2">return </span><span class="s1">dep</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">wasTracked = (dep) =&gt; (dep.w &amp; trackOpBit) &gt; </span><span class="s4">0</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">newTracked = (dep) =&gt; (dep.n &amp; trackOpBit) &gt; </span><span class="s4">0</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">initDepMarkers = ({ deps }) =&gt; {</span>
  <span class="s2">if </span><span class="s1">(deps.length) {</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; deps.length</span><span class="s2">; </span><span class="s1">i++) {</span>
      <span class="s1">deps[i].w |= trackOpBit</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">finalizeDepMarkers = (effect2) =&gt; {</span>
  <span class="s2">const </span><span class="s1">{ deps } = effect2</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(deps.length) {</span>
    <span class="s2">let </span><span class="s1">ptr = </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; deps.length</span><span class="s2">; </span><span class="s1">i++) {</span>
      <span class="s2">const </span><span class="s1">dep = deps[i]</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(wasTracked(dep) &amp;&amp; !newTracked(dep)) {</span>
        <span class="s1">dep.delete(effect2)</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">deps[ptr++] = dep</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s1">dep.w &amp;= ~trackOpBit</span><span class="s2">;</span>
      <span class="s1">dep.n &amp;= ~trackOpBit</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">deps.length = ptr</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">targetMap = </span><span class="s0">/* @__PURE__ */ </span><span class="s2">new </span><span class="s1">WeakMap()</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">effectTrackDepth = </span><span class="s4">0</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">trackOpBit = </span><span class="s4">1</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">maxMarkerBits = </span><span class="s4">30</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">activeEffect</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">ITERATE_KEY = Symbol(</span><span class="s2">true </span><span class="s1">? </span><span class="s3">&quot;iterate&quot; </span><span class="s1">: </span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">MAP_KEY_ITERATE_KEY = Symbol(</span><span class="s2">true </span><span class="s1">? </span><span class="s3">&quot;Map key iterate&quot; </span><span class="s1">: </span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">ReactiveEffect = </span><span class="s2">class </span><span class="s1">{</span>
  <span class="s1">constructor(fn</span><span class="s2">, </span><span class="s1">scheduler = </span><span class="s2">null, </span><span class="s1">scope) {</span>
    <span class="s2">this</span><span class="s1">.fn = fn</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">.scheduler = scheduler</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">.active = </span><span class="s2">true;</span>
    <span class="s2">this</span><span class="s1">.deps = []</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">.parent = </span><span class="s2">void </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s1">recordEffectScope(</span><span class="s2">this, </span><span class="s1">scope)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s1">run() {</span>
    <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.active) {</span>
      <span class="s2">return this</span><span class="s1">.fn()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">let </span><span class="s1">parent = activeEffect</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">lastShouldTrack = shouldTrack</span><span class="s2">;</span>
    <span class="s2">while </span><span class="s1">(parent) {</span>
      <span class="s2">if </span><span class="s1">(parent === </span><span class="s2">this</span><span class="s1">) {</span>
        <span class="s2">return;</span>
      <span class="s1">}</span>
      <span class="s1">parent = parent.parent</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">try </span><span class="s1">{</span>
      <span class="s2">this</span><span class="s1">.parent = activeEffect</span><span class="s2">;</span>
      <span class="s1">activeEffect = </span><span class="s2">this;</span>
      <span class="s1">shouldTrack = </span><span class="s2">true;</span>
      <span class="s1">trackOpBit = </span><span class="s4">1 </span><span class="s1">&lt;&lt; ++effectTrackDepth</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(effectTrackDepth &lt;= maxMarkerBits) {</span>
        <span class="s1">initDepMarkers(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">cleanupEffect(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">return this</span><span class="s1">.fn()</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(effectTrackDepth &lt;= maxMarkerBits) {</span>
        <span class="s1">finalizeDepMarkers(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s1">trackOpBit = </span><span class="s4">1 </span><span class="s1">&lt;&lt; --effectTrackDepth</span><span class="s2">;</span>
      <span class="s1">activeEffect = </span><span class="s2">this</span><span class="s1">.parent</span><span class="s2">;</span>
      <span class="s1">shouldTrack = lastShouldTrack</span><span class="s2">;</span>
      <span class="s2">this</span><span class="s1">.parent = </span><span class="s2">void </span><span class="s4">0</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.deferStop) {</span>
        <span class="s2">this</span><span class="s1">.stop()</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">stop() {</span>
    <span class="s2">if </span><span class="s1">(activeEffect === </span><span class="s2">this</span><span class="s1">) {</span>
      <span class="s2">this</span><span class="s1">.deferStop = </span><span class="s2">true;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.active) {</span>
      <span class="s1">cleanupEffect(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.onStop) {</span>
        <span class="s2">this</span><span class="s1">.onStop()</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">this</span><span class="s1">.active = </span><span class="s2">false;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">cleanupEffect(effect2) {</span>
  <span class="s2">const </span><span class="s1">{ deps } = effect2</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(deps.length) {</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; deps.length</span><span class="s2">; </span><span class="s1">i++) {</span>
      <span class="s1">deps[i].delete(effect2)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">deps.length = </span><span class="s4">0</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">effect(fn</span><span class="s2">, </span><span class="s1">options) {</span>
  <span class="s2">if </span><span class="s1">(fn.effect) {</span>
    <span class="s1">fn = fn.effect.fn</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">const </span><span class="s1">_effect = </span><span class="s2">new </span><span class="s1">ReactiveEffect(fn)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(options) {</span>
    <span class="s1">extend(_effect</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(options.scope)</span>
      <span class="s1">recordEffectScope(_effect</span><span class="s2">, </span><span class="s1">options.scope)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(!options || !options.lazy) {</span>
    <span class="s1">_effect.run()</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">const </span><span class="s1">runner = _effect.run.bind(_effect)</span><span class="s2">;</span>
  <span class="s1">runner.effect = _effect</span><span class="s2">;</span>
  <span class="s2">return </span><span class="s1">runner</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">stop(runner) {</span>
  <span class="s1">runner.effect.stop()</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">shouldTrack = </span><span class="s2">true;</span>
<span class="s2">var </span><span class="s1">trackStack = []</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">pauseTracking() {</span>
  <span class="s1">trackStack.push(shouldTrack)</span><span class="s2">;</span>
  <span class="s1">shouldTrack = </span><span class="s2">false;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">resetTracking() {</span>
  <span class="s2">const </span><span class="s1">last = trackStack.pop()</span><span class="s2">;</span>
  <span class="s1">shouldTrack = last === </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">? </span><span class="s2">true </span><span class="s1">: last</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">track(target</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">key) {</span>
  <span class="s2">if </span><span class="s1">(shouldTrack &amp;&amp; activeEffect) {</span>
    <span class="s2">let </span><span class="s1">depsMap = targetMap.get(target)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!depsMap) {</span>
      <span class="s1">targetMap.set(target</span><span class="s2">, </span><span class="s1">depsMap = </span><span class="s0">/* @__PURE__ */ </span><span class="s2">new </span><span class="s1">Map())</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">let </span><span class="s1">dep = depsMap.get(key)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!dep) {</span>
      <span class="s1">depsMap.set(key</span><span class="s2">, </span><span class="s1">dep = createDep())</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">eventInfo = </span><span class="s2">true </span><span class="s1">? { effect: activeEffect</span><span class="s2">, </span><span class="s1">target</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">key } : </span><span class="s2">void </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s1">trackEffects(dep</span><span class="s2">, </span><span class="s1">eventInfo)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">trackEffects(dep</span><span class="s2">, </span><span class="s1">debuggerEventExtraInfo) {</span>
  <span class="s2">let </span><span class="s1">shouldTrack2 = </span><span class="s2">false;</span>
  <span class="s2">if </span><span class="s1">(effectTrackDepth &lt;= maxMarkerBits) {</span>
    <span class="s2">if </span><span class="s1">(!newTracked(dep)) {</span>
      <span class="s1">dep.n |= trackOpBit</span><span class="s2">;</span>
      <span class="s1">shouldTrack2 = !wasTracked(dep)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s1">shouldTrack2 = !dep.has(activeEffect)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(shouldTrack2) {</span>
    <span class="s1">dep.add(activeEffect)</span><span class="s2">;</span>
    <span class="s1">activeEffect.deps.push(dep)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(activeEffect.onTrack) {</span>
      <span class="s1">activeEffect.onTrack(Object.assign({ effect: activeEffect }</span><span class="s2">, </span><span class="s1">debuggerEventExtraInfo))</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">trigger(target</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">newValue</span><span class="s2">, </span><span class="s1">oldValue</span><span class="s2">, </span><span class="s1">oldTarget) {</span>
  <span class="s2">const </span><span class="s1">depsMap = targetMap.get(target)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(!depsMap) {</span>
    <span class="s2">return;</span>
  <span class="s1">}</span>
  <span class="s2">let </span><span class="s1">deps = []</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(type === </span><span class="s3">&quot;clear&quot;</span><span class="s1">) {</span>
    <span class="s1">deps = [...depsMap.values()]</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(key === </span><span class="s3">&quot;length&quot; </span><span class="s1">&amp;&amp; isArray(target)) {</span>
    <span class="s2">const </span><span class="s1">newLength = Number(newValue)</span><span class="s2">;</span>
    <span class="s1">depsMap.forEach((dep</span><span class="s2">, </span><span class="s1">key2) =&gt; {</span>
      <span class="s2">if </span><span class="s1">(key2 === </span><span class="s3">&quot;length&quot; </span><span class="s1">|| key2 &gt;= newLength) {</span>
        <span class="s1">deps.push(dep)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">})</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s2">if </span><span class="s1">(key !== </span><span class="s2">void </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s1">deps.push(depsMap.get(key))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">switch </span><span class="s1">(type) {</span>
      <span class="s2">case </span><span class="s3">&quot;add&quot;</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">(!isArray(target)) {</span>
          <span class="s1">deps.push(depsMap.get(ITERATE_KEY))</span><span class="s2">;</span>
          <span class="s2">if </span><span class="s1">(isMap(target)) {</span>
            <span class="s1">deps.push(depsMap.get(MAP_KEY_ITERATE_KEY))</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isIntegerKey(key)) {</span>
          <span class="s1">deps.push(depsMap.get(</span><span class="s3">&quot;length&quot;</span><span class="s1">))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">break;</span>
      <span class="s2">case </span><span class="s3">&quot;delete&quot;</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">(!isArray(target)) {</span>
          <span class="s1">deps.push(depsMap.get(ITERATE_KEY))</span><span class="s2">;</span>
          <span class="s2">if </span><span class="s1">(isMap(target)) {</span>
            <span class="s1">deps.push(depsMap.get(MAP_KEY_ITERATE_KEY))</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">break;</span>
      <span class="s2">case </span><span class="s3">&quot;set&quot;</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">(isMap(target)) {</span>
          <span class="s1">deps.push(depsMap.get(ITERATE_KEY))</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">break;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">const </span><span class="s1">eventInfo = </span><span class="s2">true </span><span class="s1">? { target</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">newValue</span><span class="s2">, </span><span class="s1">oldValue</span><span class="s2">, </span><span class="s1">oldTarget } : </span><span class="s2">void </span><span class="s4">0</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(deps.length === </span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s2">if </span><span class="s1">(deps[</span><span class="s4">0</span><span class="s1">]) {</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s1">triggerEffects(deps[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">eventInfo)</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">triggerEffects(deps[</span><span class="s4">0</span><span class="s1">])</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s2">const </span><span class="s1">effects = []</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">dep of deps) {</span>
      <span class="s2">if </span><span class="s1">(dep) {</span>
        <span class="s1">effects.push(...dep)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
      <span class="s1">triggerEffects(createDep(effects)</span><span class="s2">, </span><span class="s1">eventInfo)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">triggerEffects(createDep(effects))</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">triggerEffects(dep</span><span class="s2">, </span><span class="s1">debuggerEventExtraInfo) {</span>
  <span class="s2">const </span><span class="s1">effects = isArray(dep) ? dep : [...dep]</span><span class="s2">;</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">effect2 of effects) {</span>
    <span class="s2">if </span><span class="s1">(effect2.computed) {</span>
      <span class="s1">triggerEffect(effect2</span><span class="s2">, </span><span class="s1">debuggerEventExtraInfo)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">effect2 of effects) {</span>
    <span class="s2">if </span><span class="s1">(!effect2.computed) {</span>
      <span class="s1">triggerEffect(effect2</span><span class="s2">, </span><span class="s1">debuggerEventExtraInfo)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">triggerEffect(effect2</span><span class="s2">, </span><span class="s1">debuggerEventExtraInfo) {</span>
  <span class="s2">if </span><span class="s1">(effect2 !== activeEffect || effect2.allowRecurse) {</span>
    <span class="s2">if </span><span class="s1">(effect2.onTrigger) {</span>
      <span class="s1">effect2.onTrigger(extend({ effect: effect2 }</span><span class="s2">, </span><span class="s1">debuggerEventExtraInfo))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(effect2.scheduler) {</span>
      <span class="s1">effect2.scheduler()</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">effect2.run()</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getDepFromReactive(object</span><span class="s2">, </span><span class="s1">key) {</span>
  <span class="s2">var </span><span class="s1">_a2</span><span class="s2">;</span>
  <span class="s2">return </span><span class="s1">(_a2 = targetMap.get(object)) === </span><span class="s2">null </span><span class="s1">|| _a2 === </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _a2.get(key)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">isNonTrackableKeys = makeMap(</span><span class="s3">`__proto__,__v_isRef,__isVue`</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">builtInSymbols = </span><span class="s2">new </span><span class="s1">Set(</span>
  <span class="s1">Object.getOwnPropertyNames(Symbol).filter((key) =&gt; key !== </span><span class="s3">&quot;arguments&quot; </span><span class="s1">&amp;&amp; key !== </span><span class="s3">&quot;caller&quot;</span><span class="s1">).map((key) =&gt; Symbol[key]).filter(isSymbol)</span>
<span class="s1">)</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">get$1 = createGetter()</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">shallowGet = createGetter(</span><span class="s2">false, true</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">readonlyGet = createGetter(</span><span class="s2">true</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">shallowReadonlyGet = createGetter(</span><span class="s2">true, true</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">arrayInstrumentations = createArrayInstrumentations()</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">createArrayInstrumentations() {</span>
  <span class="s2">const </span><span class="s1">instrumentations = {}</span><span class="s2">;</span>
  <span class="s1">[</span><span class="s3">&quot;includes&quot;</span><span class="s2">, </span><span class="s3">&quot;indexOf&quot;</span><span class="s2">, </span><span class="s3">&quot;lastIndexOf&quot;</span><span class="s1">].forEach((key) =&gt; {</span>
    <span class="s1">instrumentations[key] = </span><span class="s2">function</span><span class="s1">(...args) {</span>
      <span class="s2">const </span><span class="s1">arr = toRaw(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">l = </span><span class="s2">this</span><span class="s1">.length</span><span class="s2">; </span><span class="s1">i &lt; l</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s1">track(arr</span><span class="s2">, </span><span class="s3">&quot;get&quot;</span><span class="s2">, </span><span class="s1">i + </span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">const </span><span class="s1">res = arr[key](...args)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(res === -</span><span class="s4">1 </span><span class="s1">|| res === </span><span class="s2">false</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">arr[key](...args.map(toRaw))</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">return </span><span class="s1">res</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">;</span>
  <span class="s1">})</span><span class="s2">;</span>
  <span class="s1">[</span><span class="s3">&quot;push&quot;</span><span class="s2">, </span><span class="s3">&quot;pop&quot;</span><span class="s2">, </span><span class="s3">&quot;shift&quot;</span><span class="s2">, </span><span class="s3">&quot;unshift&quot;</span><span class="s2">, </span><span class="s3">&quot;splice&quot;</span><span class="s1">].forEach((key) =&gt; {</span>
    <span class="s1">instrumentations[key] = </span><span class="s2">function</span><span class="s1">(...args) {</span>
      <span class="s1">pauseTracking()</span><span class="s2">;</span>
      <span class="s2">const </span><span class="s1">res = toRaw(</span><span class="s2">this</span><span class="s1">)[key].apply(</span><span class="s2">this, </span><span class="s1">args)</span><span class="s2">;</span>
      <span class="s1">resetTracking()</span><span class="s2">;</span>
      <span class="s2">return </span><span class="s1">res</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">;</span>
  <span class="s1">})</span><span class="s2">;</span>
  <span class="s2">return </span><span class="s1">instrumentations</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">hasOwnProperty2(key) {</span>
  <span class="s2">const </span><span class="s1">obj = toRaw(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">track(obj</span><span class="s2">, </span><span class="s3">&quot;has&quot;</span><span class="s2">, </span><span class="s1">key)</span><span class="s2">;</span>
  <span class="s2">return </span><span class="s1">obj.hasOwnProperty(key)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createGetter(isReadonly2 = </span><span class="s2">false, </span><span class="s1">shallow = </span><span class="s2">false</span><span class="s1">) {</span>
  <span class="s2">return function </span><span class="s1">get2(target</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">receiver) {</span>
    <span class="s2">if </span><span class="s1">(key === </span><span class="s3">&quot;__v_isReactive&quot;</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s1">!isReadonly2</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(key === </span><span class="s3">&quot;__v_isReadonly&quot;</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s1">isReadonly2</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(key === </span><span class="s3">&quot;__v_isShallow&quot;</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s1">shallow</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(key === </span><span class="s3">&quot;__v_raw&quot; </span><span class="s1">&amp;&amp; receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {</span>
      <span class="s2">return </span><span class="s1">target</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">targetIsArray = isArray(target)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!isReadonly2) {</span>
      <span class="s2">if </span><span class="s1">(targetIsArray &amp;&amp; hasOwn(arrayInstrumentations</span><span class="s2">, </span><span class="s1">key)) {</span>
        <span class="s2">return </span><span class="s1">Reflect.get(arrayInstrumentations</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">receiver)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(key === </span><span class="s3">&quot;hasOwnProperty&quot;</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">hasOwnProperty2</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">res = Reflect.get(target</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">receiver)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {</span>
      <span class="s2">return </span><span class="s1">res</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(!isReadonly2) {</span>
      <span class="s1">track(target</span><span class="s2">, </span><span class="s3">&quot;get&quot;</span><span class="s2">, </span><span class="s1">key)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(shallow) {</span>
      <span class="s2">return </span><span class="s1">res</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(isRef(res)) {</span>
      <span class="s2">return </span><span class="s1">targetIsArray &amp;&amp; isIntegerKey(key) ? res : res.value</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(isObject(res)) {</span>
      <span class="s2">return </span><span class="s1">isReadonly2 ? readonly(res) : reactive(res)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">res</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">set$1 = createSetter()</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">shallowSet = createSetter(</span><span class="s2">true</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">createSetter(shallow = </span><span class="s2">false</span><span class="s1">) {</span>
  <span class="s2">return function </span><span class="s1">set2(target</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">receiver) {</span>
    <span class="s2">let </span><span class="s1">oldValue = target[key]</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(isReadonly(oldValue) &amp;&amp; isRef(oldValue) &amp;&amp; !isRef(value)) {</span>
      <span class="s2">return false;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(!shallow) {</span>
      <span class="s2">if </span><span class="s1">(!isShallow(value) &amp;&amp; !isReadonly(value)) {</span>
        <span class="s1">oldValue = toRaw(oldValue)</span><span class="s2">;</span>
        <span class="s1">value = toRaw(value)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(!isArray(target) &amp;&amp; isRef(oldValue) &amp;&amp; !isRef(value)) {</span>
        <span class="s1">oldValue.value = value</span><span class="s2">;</span>
        <span class="s2">return true;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">hadKey = isArray(target) &amp;&amp; isIntegerKey(key) ? Number(key) &lt; target.length : hasOwn(target</span><span class="s2">, </span><span class="s1">key)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">result = Reflect.set(target</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">receiver)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(target === toRaw(receiver)) {</span>
      <span class="s2">if </span><span class="s1">(!hadKey) {</span>
        <span class="s1">trigger(target</span><span class="s2">, </span><span class="s3">&quot;add&quot;</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value)</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(hasChanged(value</span><span class="s2">, </span><span class="s1">oldValue)) {</span>
        <span class="s1">trigger(target</span><span class="s2">, </span><span class="s3">&quot;set&quot;</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">oldValue)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">result</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">deleteProperty(target</span><span class="s2">, </span><span class="s1">key) {</span>
  <span class="s2">const </span><span class="s1">hadKey = hasOwn(target</span><span class="s2">, </span><span class="s1">key)</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">oldValue = target[key]</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">result = Reflect.deleteProperty(target</span><span class="s2">, </span><span class="s1">key)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(result &amp;&amp; hadKey) {</span>
    <span class="s1">trigger(target</span><span class="s2">, </span><span class="s3">&quot;delete&quot;</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, void </span><span class="s4">0</span><span class="s2">, </span><span class="s1">oldValue)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">result</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">has$1(target</span><span class="s2">, </span><span class="s1">key) {</span>
  <span class="s2">const </span><span class="s1">result = Reflect.has(target</span><span class="s2">, </span><span class="s1">key)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(!isSymbol(key) || !builtInSymbols.has(key)) {</span>
    <span class="s1">track(target</span><span class="s2">, </span><span class="s3">&quot;has&quot;</span><span class="s2">, </span><span class="s1">key)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">result</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">ownKeys(target) {</span>
  <span class="s1">track(target</span><span class="s2">, </span><span class="s3">&quot;iterate&quot;</span><span class="s2">, </span><span class="s1">isArray(target) ? </span><span class="s3">&quot;length&quot; </span><span class="s1">: ITERATE_KEY)</span><span class="s2">;</span>
  <span class="s2">return </span><span class="s1">Reflect.ownKeys(target)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">mutableHandlers = {</span>
  <span class="s1">get: get$1</span><span class="s2">,</span>
  <span class="s1">set: set$1</span><span class="s2">,</span>
  <span class="s1">deleteProperty</span><span class="s2">,</span>
  <span class="s1">has: has$1</span><span class="s2">,</span>
  <span class="s1">ownKeys</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">readonlyHandlers = {</span>
  <span class="s1">get: readonlyGet</span><span class="s2">,</span>
  <span class="s1">set(target</span><span class="s2">, </span><span class="s1">key) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
      <span class="s1">warn(</span><span class="s3">`Set operation on key &quot;</span><span class="s1">${String(key)}</span><span class="s3">&quot; failed: target is readonly.`</span><span class="s2">, </span><span class="s1">target)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return true;</span>
  <span class="s1">}</span><span class="s2">,</span>
  <span class="s1">deleteProperty(target</span><span class="s2">, </span><span class="s1">key) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
      <span class="s1">warn(</span><span class="s3">`Delete operation on key &quot;</span><span class="s1">${String(key)}</span><span class="s3">&quot; failed: target is readonly.`</span><span class="s2">, </span><span class="s1">target)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return true;</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">shallowReactiveHandlers = extend({}</span><span class="s2">, </span><span class="s1">mutableHandlers</span><span class="s2">, </span><span class="s1">{</span>
  <span class="s1">get: shallowGet</span><span class="s2">,</span>
  <span class="s1">set: shallowSet</span>
<span class="s1">})</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">shallowReadonlyHandlers = extend({}</span><span class="s2">, </span><span class="s1">readonlyHandlers</span><span class="s2">, </span><span class="s1">{</span>
  <span class="s1">get: shallowReadonlyGet</span>
<span class="s1">})</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">toShallow = (value) =&gt; value</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">getProto = (v) =&gt; Reflect.getPrototypeOf(v)</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">get(target</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">isReadonly2 = </span><span class="s2">false, </span><span class="s1">isShallow3 = </span><span class="s2">false</span><span class="s1">) {</span>
  <span class="s1">target = target[</span>
    <span class="s3">&quot;__v_raw&quot;</span>
    <span class="s0">/* ReactiveFlags.RAW */</span>
  <span class="s1">]</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">rawTarget = toRaw(target)</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">rawKey = toRaw(key)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(!isReadonly2) {</span>
    <span class="s2">if </span><span class="s1">(key !== rawKey) {</span>
      <span class="s1">track(rawTarget</span><span class="s2">, </span><span class="s3">&quot;get&quot;</span><span class="s2">, </span><span class="s1">key)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">track(rawTarget</span><span class="s2">, </span><span class="s3">&quot;get&quot;</span><span class="s2">, </span><span class="s1">rawKey)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">const </span><span class="s1">{ has: has2 } = getProto(rawTarget)</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">wrap = isShallow3 ? toShallow : isReadonly2 ? toReadonly : toReactive</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(has2.call(rawTarget</span><span class="s2">, </span><span class="s1">key)) {</span>
    <span class="s2">return </span><span class="s1">wrap(target.get(key))</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(has2.call(rawTarget</span><span class="s2">, </span><span class="s1">rawKey)) {</span>
    <span class="s2">return </span><span class="s1">wrap(target.get(rawKey))</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(target !== rawTarget) {</span>
    <span class="s1">target.get(key)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">has(key</span><span class="s2">, </span><span class="s1">isReadonly2 = </span><span class="s2">false</span><span class="s1">) {</span>
  <span class="s2">const </span><span class="s1">target = </span><span class="s2">this</span><span class="s1">[</span>
    <span class="s3">&quot;__v_raw&quot;</span>
    <span class="s0">/* ReactiveFlags.RAW */</span>
  <span class="s1">]</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">rawTarget = toRaw(target)</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">rawKey = toRaw(key)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(!isReadonly2) {</span>
    <span class="s2">if </span><span class="s1">(key !== rawKey) {</span>
      <span class="s1">track(rawTarget</span><span class="s2">, </span><span class="s3">&quot;has&quot;</span><span class="s2">, </span><span class="s1">key)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">track(rawTarget</span><span class="s2">, </span><span class="s3">&quot;has&quot;</span><span class="s2">, </span><span class="s1">rawKey)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">size(target</span><span class="s2">, </span><span class="s1">isReadonly2 = </span><span class="s2">false</span><span class="s1">) {</span>
  <span class="s1">target = target[</span>
    <span class="s3">&quot;__v_raw&quot;</span>
    <span class="s0">/* ReactiveFlags.RAW */</span>
  <span class="s1">]</span><span class="s2">;</span>
  <span class="s1">!isReadonly2 &amp;&amp; track(toRaw(target)</span><span class="s2">, </span><span class="s3">&quot;iterate&quot;</span><span class="s2">, </span><span class="s1">ITERATE_KEY)</span><span class="s2">;</span>
  <span class="s2">return </span><span class="s1">Reflect.get(target</span><span class="s2">, </span><span class="s3">&quot;size&quot;</span><span class="s2">, </span><span class="s1">target)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">add(value) {</span>
  <span class="s1">value = toRaw(value)</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">target = toRaw(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">proto = getProto(target)</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">hadKey = proto.has.call(target</span><span class="s2">, </span><span class="s1">value)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(!hadKey) {</span>
    <span class="s1">target.add(value)</span><span class="s2">;</span>
    <span class="s1">trigger(target</span><span class="s2">, </span><span class="s3">&quot;add&quot;</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">value)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return this;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">set(key</span><span class="s2">, </span><span class="s1">value) {</span>
  <span class="s1">value = toRaw(value)</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">target = toRaw(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">{ has: has2</span><span class="s2">, </span><span class="s1">get: get2 } = getProto(target)</span><span class="s2">;</span>
  <span class="s2">let </span><span class="s1">hadKey = has2.call(target</span><span class="s2">, </span><span class="s1">key)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(!hadKey) {</span>
    <span class="s1">key = toRaw(key)</span><span class="s2">;</span>
    <span class="s1">hadKey = has2.call(target</span><span class="s2">, </span><span class="s1">key)</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s1">checkIdentityKeys(target</span><span class="s2">, </span><span class="s1">has2</span><span class="s2">, </span><span class="s1">key)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">const </span><span class="s1">oldValue = get2.call(target</span><span class="s2">, </span><span class="s1">key)</span><span class="s2">;</span>
  <span class="s1">target.set(key</span><span class="s2">, </span><span class="s1">value)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(!hadKey) {</span>
    <span class="s1">trigger(target</span><span class="s2">, </span><span class="s3">&quot;add&quot;</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value)</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(hasChanged(value</span><span class="s2">, </span><span class="s1">oldValue)) {</span>
    <span class="s1">trigger(target</span><span class="s2">, </span><span class="s3">&quot;set&quot;</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">oldValue)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return this;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">deleteEntry(key) {</span>
  <span class="s2">const </span><span class="s1">target = toRaw(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">{ has: has2</span><span class="s2">, </span><span class="s1">get: get2 } = getProto(target)</span><span class="s2">;</span>
  <span class="s2">let </span><span class="s1">hadKey = has2.call(target</span><span class="s2">, </span><span class="s1">key)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(!hadKey) {</span>
    <span class="s1">key = toRaw(key)</span><span class="s2">;</span>
    <span class="s1">hadKey = has2.call(target</span><span class="s2">, </span><span class="s1">key)</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s1">checkIdentityKeys(target</span><span class="s2">, </span><span class="s1">has2</span><span class="s2">, </span><span class="s1">key)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">const </span><span class="s1">oldValue = get2 ? get2.call(target</span><span class="s2">, </span><span class="s1">key) : </span><span class="s2">void </span><span class="s4">0</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">result = target.delete(key)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(hadKey) {</span>
    <span class="s1">trigger(target</span><span class="s2">, </span><span class="s3">&quot;delete&quot;</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, void </span><span class="s4">0</span><span class="s2">, </span><span class="s1">oldValue)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">result</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">clear() {</span>
  <span class="s2">const </span><span class="s1">target = toRaw(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">hadItems = target.size !== </span><span class="s4">0</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">oldTarget = </span><span class="s2">true </span><span class="s1">? isMap(target) ? </span><span class="s2">new </span><span class="s1">Map(target) : </span><span class="s2">new </span><span class="s1">Set(target) : </span><span class="s2">void </span><span class="s4">0</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">result = target.clear()</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(hadItems) {</span>
    <span class="s1">trigger(target</span><span class="s2">, </span><span class="s3">&quot;clear&quot;</span><span class="s2">, void </span><span class="s4">0</span><span class="s2">, void </span><span class="s4">0</span><span class="s2">, </span><span class="s1">oldTarget)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">result</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createForEach(isReadonly2</span><span class="s2">, </span><span class="s1">isShallow3) {</span>
  <span class="s2">return function </span><span class="s1">forEach(callback</span><span class="s2">, </span><span class="s1">thisArg) {</span>
    <span class="s2">const </span><span class="s1">observed = </span><span class="s2">this;</span>
    <span class="s2">const </span><span class="s1">target = observed[</span>
      <span class="s3">&quot;__v_raw&quot;</span>
      <span class="s0">/* ReactiveFlags.RAW */</span>
    <span class="s1">]</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">rawTarget = toRaw(target)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">wrap = isShallow3 ? toShallow : isReadonly2 ? toReadonly : toReactive</span><span class="s2">;</span>
    <span class="s1">!isReadonly2 &amp;&amp; track(rawTarget</span><span class="s2">, </span><span class="s3">&quot;iterate&quot;</span><span class="s2">, </span><span class="s1">ITERATE_KEY)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">target.forEach((value</span><span class="s2">, </span><span class="s1">key) =&gt; {</span>
      <span class="s2">return </span><span class="s1">callback.call(thisArg</span><span class="s2">, </span><span class="s1">wrap(value)</span><span class="s2">, </span><span class="s1">wrap(key)</span><span class="s2">, </span><span class="s1">observed)</span><span class="s2">;</span>
    <span class="s1">})</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createIterableMethod(method</span><span class="s2">, </span><span class="s1">isReadonly2</span><span class="s2">, </span><span class="s1">isShallow3) {</span>
  <span class="s2">return function</span><span class="s1">(...args) {</span>
    <span class="s2">const </span><span class="s1">target = </span><span class="s2">this</span><span class="s1">[</span>
      <span class="s3">&quot;__v_raw&quot;</span>
      <span class="s0">/* ReactiveFlags.RAW */</span>
    <span class="s1">]</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">rawTarget = toRaw(target)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">targetIsMap = isMap(rawTarget)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">isPair = method === </span><span class="s3">&quot;entries&quot; </span><span class="s1">|| method === Symbol.iterator &amp;&amp; targetIsMap</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">isKeyOnly = method === </span><span class="s3">&quot;keys&quot; </span><span class="s1">&amp;&amp; targetIsMap</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">innerIterator = target[method](...args)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">wrap = isShallow3 ? toShallow : isReadonly2 ? toReadonly : toReactive</span><span class="s2">;</span>
    <span class="s1">!isReadonly2 &amp;&amp; track(rawTarget</span><span class="s2">, </span><span class="s3">&quot;iterate&quot;</span><span class="s2">, </span><span class="s1">isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">{</span>
      <span class="s0">// iterator protocol</span>
      <span class="s1">next() {</span>
        <span class="s2">const </span><span class="s1">{ value</span><span class="s2">, </span><span class="s1">done } = innerIterator.next()</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">done ? { value</span><span class="s2">, </span><span class="s1">done } : {</span>
          <span class="s1">value: isPair ? [wrap(value[</span><span class="s4">0</span><span class="s1">])</span><span class="s2">, </span><span class="s1">wrap(value[</span><span class="s4">1</span><span class="s1">])] : wrap(value)</span><span class="s2">,</span>
          <span class="s1">done</span>
        <span class="s1">}</span><span class="s2">;</span>
      <span class="s1">}</span><span class="s2">,</span>
      <span class="s0">// iterable protocol</span>
      <span class="s1">[Symbol.iterator]() {</span>
        <span class="s2">return this;</span>
      <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createReadonlyMethod(type) {</span>
  <span class="s2">return function</span><span class="s1">(...args) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
      <span class="s2">const </span><span class="s1">key = args[</span><span class="s4">0</span><span class="s1">] ? </span><span class="s3">`on key &quot;</span><span class="s1">${args[</span><span class="s4">0</span><span class="s1">]}</span><span class="s3">&quot; ` </span><span class="s1">: </span><span class="s3">``</span><span class="s2">;</span>
      <span class="s1">console.warn(</span><span class="s3">`</span><span class="s1">${capitalize(type)} </span><span class="s3">operation </span><span class="s1">${key}</span><span class="s3">failed: target is readonly.`</span><span class="s2">, </span><span class="s1">toRaw(</span><span class="s2">this</span><span class="s1">))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">type === </span><span class="s3">&quot;delete&quot; </span><span class="s1">? </span><span class="s2">false </span><span class="s1">: </span><span class="s2">this;</span>
  <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createInstrumentations() {</span>
  <span class="s2">const </span><span class="s1">mutableInstrumentations2 = {</span>
    <span class="s1">get(key) {</span>
      <span class="s2">return </span><span class="s1">get(</span><span class="s2">this, </span><span class="s1">key)</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">get size() {</span>
      <span class="s2">return </span><span class="s1">size(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">has</span><span class="s2">,</span>
    <span class="s1">add</span><span class="s2">,</span>
    <span class="s1">set</span><span class="s2">,</span>
    <span class="s2">delete</span><span class="s1">: deleteEntry</span><span class="s2">,</span>
    <span class="s1">clear</span><span class="s2">,</span>
    <span class="s1">forEach: createForEach(</span><span class="s2">false, false</span><span class="s1">)</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">shallowInstrumentations2 = {</span>
    <span class="s1">get(key) {</span>
      <span class="s2">return </span><span class="s1">get(</span><span class="s2">this, </span><span class="s1">key</span><span class="s2">, false, true</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">get size() {</span>
      <span class="s2">return </span><span class="s1">size(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">has</span><span class="s2">,</span>
    <span class="s1">add</span><span class="s2">,</span>
    <span class="s1">set</span><span class="s2">,</span>
    <span class="s2">delete</span><span class="s1">: deleteEntry</span><span class="s2">,</span>
    <span class="s1">clear</span><span class="s2">,</span>
    <span class="s1">forEach: createForEach(</span><span class="s2">false, true</span><span class="s1">)</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">readonlyInstrumentations2 = {</span>
    <span class="s1">get(key) {</span>
      <span class="s2">return </span><span class="s1">get(</span><span class="s2">this, </span><span class="s1">key</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">get size() {</span>
      <span class="s2">return </span><span class="s1">size(</span><span class="s2">this, true</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">has(key) {</span>
      <span class="s2">return </span><span class="s1">has.call(</span><span class="s2">this, </span><span class="s1">key</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">add: createReadonlyMethod(</span>
      <span class="s3">&quot;add&quot;</span>
      <span class="s0">/* TriggerOpTypes.ADD */</span>
    <span class="s1">)</span><span class="s2">,</span>
    <span class="s1">set: createReadonlyMethod(</span>
      <span class="s3">&quot;set&quot;</span>
      <span class="s0">/* TriggerOpTypes.SET */</span>
    <span class="s1">)</span><span class="s2">,</span>
    <span class="s2">delete</span><span class="s1">: createReadonlyMethod(</span>
      <span class="s3">&quot;delete&quot;</span>
      <span class="s0">/* TriggerOpTypes.DELETE */</span>
    <span class="s1">)</span><span class="s2">,</span>
    <span class="s1">clear: createReadonlyMethod(</span>
      <span class="s3">&quot;clear&quot;</span>
      <span class="s0">/* TriggerOpTypes.CLEAR */</span>
    <span class="s1">)</span><span class="s2">,</span>
    <span class="s1">forEach: createForEach(</span><span class="s2">true, false</span><span class="s1">)</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">shallowReadonlyInstrumentations2 = {</span>
    <span class="s1">get(key) {</span>
      <span class="s2">return </span><span class="s1">get(</span><span class="s2">this, </span><span class="s1">key</span><span class="s2">, true, true</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">get size() {</span>
      <span class="s2">return </span><span class="s1">size(</span><span class="s2">this, true</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">has(key) {</span>
      <span class="s2">return </span><span class="s1">has.call(</span><span class="s2">this, </span><span class="s1">key</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">add: createReadonlyMethod(</span>
      <span class="s3">&quot;add&quot;</span>
      <span class="s0">/* TriggerOpTypes.ADD */</span>
    <span class="s1">)</span><span class="s2">,</span>
    <span class="s1">set: createReadonlyMethod(</span>
      <span class="s3">&quot;set&quot;</span>
      <span class="s0">/* TriggerOpTypes.SET */</span>
    <span class="s1">)</span><span class="s2">,</span>
    <span class="s2">delete</span><span class="s1">: createReadonlyMethod(</span>
      <span class="s3">&quot;delete&quot;</span>
      <span class="s0">/* TriggerOpTypes.DELETE */</span>
    <span class="s1">)</span><span class="s2">,</span>
    <span class="s1">clear: createReadonlyMethod(</span>
      <span class="s3">&quot;clear&quot;</span>
      <span class="s0">/* TriggerOpTypes.CLEAR */</span>
    <span class="s1">)</span><span class="s2">,</span>
    <span class="s1">forEach: createForEach(</span><span class="s2">true, true</span><span class="s1">)</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">iteratorMethods = [</span><span class="s3">&quot;keys&quot;</span><span class="s2">, </span><span class="s3">&quot;values&quot;</span><span class="s2">, </span><span class="s3">&quot;entries&quot;</span><span class="s2">, </span><span class="s1">Symbol.iterator]</span><span class="s2">;</span>
  <span class="s1">iteratorMethods.forEach((method) =&gt; {</span>
    <span class="s1">mutableInstrumentations2[method] = createIterableMethod(method</span><span class="s2">, false, false</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">readonlyInstrumentations2[method] = createIterableMethod(method</span><span class="s2">, true, false</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">shallowInstrumentations2[method] = createIterableMethod(method</span><span class="s2">, false, true</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">shallowReadonlyInstrumentations2[method] = createIterableMethod(method</span><span class="s2">, true, true</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">})</span><span class="s2">;</span>
  <span class="s2">return </span><span class="s1">[</span>
    <span class="s1">mutableInstrumentations2</span><span class="s2">,</span>
    <span class="s1">readonlyInstrumentations2</span><span class="s2">,</span>
    <span class="s1">shallowInstrumentations2</span><span class="s2">,</span>
    <span class="s1">shallowReadonlyInstrumentations2</span>
  <span class="s1">]</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">[mutableInstrumentations</span><span class="s2">, </span><span class="s1">readonlyInstrumentations</span><span class="s2">, </span><span class="s1">shallowInstrumentations</span><span class="s2">, </span><span class="s1">shallowReadonlyInstrumentations] = createInstrumentations()</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">createInstrumentationGetter(isReadonly2</span><span class="s2">, </span><span class="s1">shallow) {</span>
  <span class="s2">const </span><span class="s1">instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations</span><span class="s2">;</span>
  <span class="s2">return </span><span class="s1">(target</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">receiver) =&gt; {</span>
    <span class="s2">if </span><span class="s1">(key === </span><span class="s3">&quot;__v_isReactive&quot;</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s1">!isReadonly2</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(key === </span><span class="s3">&quot;__v_isReadonly&quot;</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s1">isReadonly2</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(key === </span><span class="s3">&quot;__v_raw&quot;</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s1">target</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">Reflect.get(hasOwn(instrumentations</span><span class="s2">, </span><span class="s1">key) &amp;&amp; key </span><span class="s2">in </span><span class="s1">target ? instrumentations : target</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">receiver)</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">mutableCollectionHandlers = {</span>
  <span class="s1">get: createInstrumentationGetter(</span><span class="s2">false, false</span><span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">shallowCollectionHandlers = {</span>
  <span class="s1">get: createInstrumentationGetter(</span><span class="s2">false, true</span><span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">readonlyCollectionHandlers = {</span>
  <span class="s1">get: createInstrumentationGetter(</span><span class="s2">true, false</span><span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">shallowReadonlyCollectionHandlers = {</span>
  <span class="s1">get: createInstrumentationGetter(</span><span class="s2">true, true</span><span class="s1">)</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">checkIdentityKeys(target</span><span class="s2">, </span><span class="s1">has2</span><span class="s2">, </span><span class="s1">key) {</span>
  <span class="s2">const </span><span class="s1">rawKey = toRaw(key)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(rawKey !== key &amp;&amp; has2.call(target</span><span class="s2">, </span><span class="s1">rawKey)) {</span>
    <span class="s2">const </span><span class="s1">type = toRawType(target)</span><span class="s2">;</span>
    <span class="s1">console.warn(</span><span class="s3">`Reactive </span><span class="s1">${type} </span><span class="s3">contains both the raw and reactive versions of the same object</span><span class="s1">${type === </span><span class="s3">`Map` </span><span class="s1">? </span><span class="s3">` as keys` </span><span class="s1">: </span><span class="s3">``</span><span class="s1">}</span><span class="s3">, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">reactiveMap = </span><span class="s0">/* @__PURE__ */ </span><span class="s2">new </span><span class="s1">WeakMap()</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">shallowReactiveMap = </span><span class="s0">/* @__PURE__ */ </span><span class="s2">new </span><span class="s1">WeakMap()</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">readonlyMap = </span><span class="s0">/* @__PURE__ */ </span><span class="s2">new </span><span class="s1">WeakMap()</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">shallowReadonlyMap = </span><span class="s0">/* @__PURE__ */ </span><span class="s2">new </span><span class="s1">WeakMap()</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">targetTypeMap(rawType) {</span>
  <span class="s2">switch </span><span class="s1">(rawType) {</span>
    <span class="s2">case </span><span class="s3">&quot;Object&quot;</span><span class="s1">:</span>
    <span class="s2">case </span><span class="s3">&quot;Array&quot;</span><span class="s1">:</span>
      <span class="s2">return </span><span class="s4">1</span><span class="s2">;</span>
    <span class="s2">case </span><span class="s3">&quot;Map&quot;</span><span class="s1">:</span>
    <span class="s2">case </span><span class="s3">&quot;Set&quot;</span><span class="s1">:</span>
    <span class="s2">case </span><span class="s3">&quot;WeakMap&quot;</span><span class="s1">:</span>
    <span class="s2">case </span><span class="s3">&quot;WeakSet&quot;</span><span class="s1">:</span>
      <span class="s2">return </span><span class="s4">2</span><span class="s2">;</span>
    <span class="s2">default</span><span class="s1">:</span>
      <span class="s2">return </span><span class="s4">0</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getTargetType(value) {</span>
  <span class="s2">return </span><span class="s1">value[</span>
    <span class="s3">&quot;__v_skip&quot;</span>
    <span class="s0">/* ReactiveFlags.SKIP */</span>
  <span class="s1">] || !Object.isExtensible(value) ? </span><span class="s4">0 </span><span class="s1">: targetTypeMap(toRawType(value))</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">reactive(target) {</span>
  <span class="s2">if </span><span class="s1">(isReadonly(target)) {</span>
    <span class="s2">return </span><span class="s1">target</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">createReactiveObject(target</span><span class="s2">, false, </span><span class="s1">mutableHandlers</span><span class="s2">, </span><span class="s1">mutableCollectionHandlers</span><span class="s2">, </span><span class="s1">reactiveMap)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">shallowReactive(target) {</span>
  <span class="s2">return </span><span class="s1">createReactiveObject(target</span><span class="s2">, false, </span><span class="s1">shallowReactiveHandlers</span><span class="s2">, </span><span class="s1">shallowCollectionHandlers</span><span class="s2">, </span><span class="s1">shallowReactiveMap)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">readonly(target) {</span>
  <span class="s2">return </span><span class="s1">createReactiveObject(target</span><span class="s2">, true, </span><span class="s1">readonlyHandlers</span><span class="s2">, </span><span class="s1">readonlyCollectionHandlers</span><span class="s2">, </span><span class="s1">readonlyMap)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">shallowReadonly(target) {</span>
  <span class="s2">return </span><span class="s1">createReactiveObject(target</span><span class="s2">, true, </span><span class="s1">shallowReadonlyHandlers</span><span class="s2">, </span><span class="s1">shallowReadonlyCollectionHandlers</span><span class="s2">, </span><span class="s1">shallowReadonlyMap)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createReactiveObject(target</span><span class="s2">, </span><span class="s1">isReadonly2</span><span class="s2">, </span><span class="s1">baseHandlers</span><span class="s2">, </span><span class="s1">collectionHandlers</span><span class="s2">, </span><span class="s1">proxyMap) {</span>
  <span class="s2">if </span><span class="s1">(!isObject(target)) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
      <span class="s1">console.warn(</span><span class="s3">`value cannot be made reactive: </span><span class="s1">${String(target)}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">target</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(target[</span>
    <span class="s3">&quot;__v_raw&quot;</span>
    <span class="s0">/* ReactiveFlags.RAW */</span>
  <span class="s1">] &amp;&amp; !(isReadonly2 &amp;&amp; target[</span>
    <span class="s3">&quot;__v_isReactive&quot;</span>
    <span class="s0">/* ReactiveFlags.IS_REACTIVE */</span>
  <span class="s1">])) {</span>
    <span class="s2">return </span><span class="s1">target</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">const </span><span class="s1">existingProxy = proxyMap.get(target)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(existingProxy) {</span>
    <span class="s2">return </span><span class="s1">existingProxy</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">const </span><span class="s1">targetType = getTargetType(target)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(targetType === </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s2">return </span><span class="s1">target</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">const </span><span class="s1">proxy = </span><span class="s2">new </span><span class="s1">Proxy(target</span><span class="s2">, </span><span class="s1">targetType === </span><span class="s4">2 </span><span class="s1">? collectionHandlers : baseHandlers)</span><span class="s2">;</span>
  <span class="s1">proxyMap.set(target</span><span class="s2">, </span><span class="s1">proxy)</span><span class="s2">;</span>
  <span class="s2">return </span><span class="s1">proxy</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isReactive(value) {</span>
  <span class="s2">if </span><span class="s1">(isReadonly(value)) {</span>
    <span class="s2">return </span><span class="s1">isReactive(value[</span>
      <span class="s3">&quot;__v_raw&quot;</span>
      <span class="s0">/* ReactiveFlags.RAW */</span>
    <span class="s1">])</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">!!(value &amp;&amp; value[</span>
    <span class="s3">&quot;__v_isReactive&quot;</span>
    <span class="s0">/* ReactiveFlags.IS_REACTIVE */</span>
  <span class="s1">])</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isReadonly(value) {</span>
  <span class="s2">return </span><span class="s1">!!(value &amp;&amp; value[</span>
    <span class="s3">&quot;__v_isReadonly&quot;</span>
    <span class="s0">/* ReactiveFlags.IS_READONLY */</span>
  <span class="s1">])</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isShallow(value) {</span>
  <span class="s2">return </span><span class="s1">!!(value &amp;&amp; value[</span>
    <span class="s3">&quot;__v_isShallow&quot;</span>
    <span class="s0">/* ReactiveFlags.IS_SHALLOW */</span>
  <span class="s1">])</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isProxy(value) {</span>
  <span class="s2">return </span><span class="s1">isReactive(value) || isReadonly(value)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">toRaw(observed) {</span>
  <span class="s2">const </span><span class="s1">raw = observed &amp;&amp; observed[</span>
    <span class="s3">&quot;__v_raw&quot;</span>
    <span class="s0">/* ReactiveFlags.RAW */</span>
  <span class="s1">]</span><span class="s2">;</span>
  <span class="s2">return </span><span class="s1">raw ? toRaw(raw) : observed</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">markRaw(value) {</span>
  <span class="s1">def(value</span><span class="s2">, </span><span class="s3">&quot;__v_skip&quot;</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s2">return </span><span class="s1">value</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">toReactive = (value) =&gt; isObject(value) ? reactive(value) : value</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">toReadonly = (value) =&gt; isObject(value) ? readonly(value) : value</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">trackRefValue(ref2) {</span>
  <span class="s2">if </span><span class="s1">(shouldTrack &amp;&amp; activeEffect) {</span>
    <span class="s1">ref2 = toRaw(ref2)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
      <span class="s1">trackEffects(ref2.dep || (ref2.dep = createDep())</span><span class="s2">, </span><span class="s1">{</span>
        <span class="s1">target: ref2</span><span class="s2">,</span>
        <span class="s1">type: </span><span class="s3">&quot;get&quot;</span><span class="s2">,</span>
        <span class="s1">key: </span><span class="s3">&quot;value&quot;</span>
      <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">trackEffects(ref2.dep || (ref2.dep = createDep()))</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">triggerRefValue(ref2</span><span class="s2">, </span><span class="s1">newVal) {</span>
  <span class="s1">ref2 = toRaw(ref2)</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">dep = ref2.dep</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(dep) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
      <span class="s1">triggerEffects(dep</span><span class="s2">, </span><span class="s1">{</span>
        <span class="s1">target: ref2</span><span class="s2">,</span>
        <span class="s1">type: </span><span class="s3">&quot;set&quot;</span><span class="s2">,</span>
        <span class="s1">key: </span><span class="s3">&quot;value&quot;</span><span class="s2">,</span>
        <span class="s1">newValue: newVal</span>
      <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">triggerEffects(dep)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isRef(r) {</span>
  <span class="s2">return </span><span class="s1">!!(r &amp;&amp; r.__v_isRef === </span><span class="s2">true</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">ref(value) {</span>
  <span class="s2">return </span><span class="s1">createRef(value</span><span class="s2">, false</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">shallowRef(value) {</span>
  <span class="s2">return </span><span class="s1">createRef(value</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createRef(rawValue</span><span class="s2">, </span><span class="s1">shallow) {</span>
  <span class="s2">if </span><span class="s1">(isRef(rawValue)) {</span>
    <span class="s2">return </span><span class="s1">rawValue</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return new </span><span class="s1">RefImpl(rawValue</span><span class="s2">, </span><span class="s1">shallow)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">RefImpl = </span><span class="s2">class </span><span class="s1">{</span>
  <span class="s1">constructor(value</span><span class="s2">, </span><span class="s1">__v_isShallow) {</span>
    <span class="s2">this</span><span class="s1">.__v_isShallow = __v_isShallow</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">.dep = </span><span class="s2">void </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">.__v_isRef = </span><span class="s2">true;</span>
    <span class="s2">this</span><span class="s1">._rawValue = __v_isShallow ? value : toRaw(value)</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">._value = __v_isShallow ? value : toReactive(value)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s1">get value() {</span>
    <span class="s1">trackRefValue(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">return this</span><span class="s1">._value</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s1">set value(newVal) {</span>
    <span class="s2">const </span><span class="s1">useDirectValue = </span><span class="s2">this</span><span class="s1">.__v_isShallow || isShallow(newVal) || isReadonly(newVal)</span><span class="s2">;</span>
    <span class="s1">newVal = useDirectValue ? newVal : toRaw(newVal)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(hasChanged(newVal</span><span class="s2">, this</span><span class="s1">._rawValue)) {</span>
      <span class="s2">this</span><span class="s1">._rawValue = newVal</span><span class="s2">;</span>
      <span class="s2">this</span><span class="s1">._value = useDirectValue ? newVal : toReactive(newVal)</span><span class="s2">;</span>
      <span class="s1">triggerRefValue(</span><span class="s2">this, </span><span class="s1">newVal)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">triggerRef(ref2) {</span>
  <span class="s1">triggerRefValue(ref2</span><span class="s2">, true </span><span class="s1">? ref2.value : </span><span class="s2">void </span><span class="s4">0</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">unref(ref2) {</span>
  <span class="s2">return </span><span class="s1">isRef(ref2) ? ref2.value : ref2</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">shallowUnwrapHandlers = {</span>
  <span class="s1">get: (target</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">receiver) =&gt; unref(Reflect.get(target</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">receiver))</span><span class="s2">,</span>
  <span class="s1">set: (target</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">receiver) =&gt; {</span>
    <span class="s2">const </span><span class="s1">oldValue = target[key]</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(isRef(oldValue) &amp;&amp; !isRef(value)) {</span>
      <span class="s1">oldValue.value = value</span><span class="s2">;</span>
      <span class="s2">return true;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">return </span><span class="s1">Reflect.set(target</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">receiver)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">proxyRefs(objectWithRefs) {</span>
  <span class="s2">return </span><span class="s1">isReactive(objectWithRefs) ? objectWithRefs : </span><span class="s2">new </span><span class="s1">Proxy(objectWithRefs</span><span class="s2">, </span><span class="s1">shallowUnwrapHandlers)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">CustomRefImpl = </span><span class="s2">class </span><span class="s1">{</span>
  <span class="s1">constructor(factory) {</span>
    <span class="s2">this</span><span class="s1">.dep = </span><span class="s2">void </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">.__v_isRef = </span><span class="s2">true;</span>
    <span class="s2">const </span><span class="s1">{ get: get2</span><span class="s2">, </span><span class="s1">set: set2 } = factory(() =&gt; trackRefValue(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">, </span><span class="s1">() =&gt; triggerRefValue(</span><span class="s2">this</span><span class="s1">))</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">._get = get2</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">._set = set2</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s1">get value() {</span>
    <span class="s2">return this</span><span class="s1">._get()</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s1">set value(newVal) {</span>
    <span class="s2">this</span><span class="s1">._set(newVal)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">customRef(factory) {</span>
  <span class="s2">return new </span><span class="s1">CustomRefImpl(factory)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">toRefs(object) {</span>
  <span class="s2">if </span><span class="s1">(!isProxy(object)) {</span>
    <span class="s1">console.warn(</span><span class="s3">`toRefs() expects a reactive object but received a plain one.`</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">const </span><span class="s1">ret = isArray(object) ? </span><span class="s2">new </span><span class="s1">Array(object.length) : {}</span><span class="s2">;</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">object) {</span>
    <span class="s1">ret[key] = toRef(object</span><span class="s2">, </span><span class="s1">key)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">ret</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">ObjectRefImpl = </span><span class="s2">class </span><span class="s1">{</span>
  <span class="s1">constructor(_object</span><span class="s2">, </span><span class="s1">_key</span><span class="s2">, </span><span class="s1">_defaultValue) {</span>
    <span class="s2">this</span><span class="s1">._object = _object</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">._key = _key</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">._defaultValue = _defaultValue</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">.__v_isRef = </span><span class="s2">true;</span>
  <span class="s1">}</span>
  <span class="s1">get value() {</span>
    <span class="s2">const </span><span class="s1">val = </span><span class="s2">this</span><span class="s1">._object[</span><span class="s2">this</span><span class="s1">._key]</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">val === </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">? </span><span class="s2">this</span><span class="s1">._defaultValue : val</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s1">set value(newVal) {</span>
    <span class="s2">this</span><span class="s1">._object[</span><span class="s2">this</span><span class="s1">._key] = newVal</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s1">get dep() {</span>
    <span class="s2">return </span><span class="s1">getDepFromReactive(toRaw(</span><span class="s2">this</span><span class="s1">._object)</span><span class="s2">, this</span><span class="s1">._key)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">toRef(object</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">defaultValue) {</span>
  <span class="s2">const </span><span class="s1">val = object[key]</span><span class="s2">;</span>
  <span class="s2">return </span><span class="s1">isRef(val) ? val : </span><span class="s2">new </span><span class="s1">ObjectRefImpl(object</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">defaultValue)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">_a$1</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">ComputedRefImpl = </span><span class="s2">class </span><span class="s1">{</span>
  <span class="s1">constructor(getter</span><span class="s2">, </span><span class="s1">_setter</span><span class="s2">, </span><span class="s1">isReadonly2</span><span class="s2">, </span><span class="s1">isSSR) {</span>
    <span class="s2">this</span><span class="s1">._setter = _setter</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">.dep = </span><span class="s2">void </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">.__v_isRef = </span><span class="s2">true;</span>
    <span class="s2">this</span><span class="s1">[_a$1] = </span><span class="s2">false;</span>
    <span class="s2">this</span><span class="s1">._dirty = </span><span class="s2">true;</span>
    <span class="s2">this</span><span class="s1">.effect = </span><span class="s2">new </span><span class="s1">ReactiveEffect(getter</span><span class="s2">, </span><span class="s1">() =&gt; {</span>
      <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">._dirty) {</span>
        <span class="s2">this</span><span class="s1">._dirty = </span><span class="s2">true;</span>
        <span class="s1">triggerRefValue(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">})</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">.effect.computed = </span><span class="s2">this;</span>
    <span class="s2">this</span><span class="s1">.effect.active = </span><span class="s2">this</span><span class="s1">._cacheable = !isSSR</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">[</span>
      <span class="s3">&quot;__v_isReadonly&quot;</span>
      <span class="s0">/* ReactiveFlags.IS_READONLY */</span>
    <span class="s1">] = isReadonly2</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s1">get value() {</span>
    <span class="s2">const </span><span class="s1">self2 = toRaw(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">trackRefValue(self2)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(self2._dirty || !self2._cacheable) {</span>
      <span class="s1">self2._dirty = </span><span class="s2">false;</span>
      <span class="s1">self2._value = self2.effect.run()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">self2._value</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s1">set value(newValue) {</span>
    <span class="s2">this</span><span class="s1">._setter(newValue)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s1">_a$1 = </span><span class="s3">&quot;__v_isReadonly&quot;</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">computed(getterOrOptions</span><span class="s2">, </span><span class="s1">debugOptions</span><span class="s2">, </span><span class="s1">isSSR = </span><span class="s2">false</span><span class="s1">) {</span>
  <span class="s2">let </span><span class="s1">getter</span><span class="s2">;</span>
  <span class="s2">let </span><span class="s1">setter</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">onlyGetter = isFunction(getterOrOptions)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(onlyGetter) {</span>
    <span class="s1">getter = getterOrOptions</span><span class="s2">;</span>
    <span class="s1">setter = </span><span class="s2">true </span><span class="s1">? () =&gt; {</span>
      <span class="s1">console.warn(</span><span class="s3">&quot;Write operation failed: computed value is readonly&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">} : NOOP</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s1">getter = getterOrOptions.get</span><span class="s2">;</span>
    <span class="s1">setter = getterOrOptions.set</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">const </span><span class="s1">cRef = </span><span class="s2">new </span><span class="s1">ComputedRefImpl(getter</span><span class="s2">, </span><span class="s1">setter</span><span class="s2">, </span><span class="s1">onlyGetter || !setter</span><span class="s2">, </span><span class="s1">isSSR)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(debugOptions &amp;&amp; !isSSR) {</span>
    <span class="s1">cRef.effect.onTrack = debugOptions.onTrack</span><span class="s2">;</span>
    <span class="s1">cRef.effect.onTrigger = debugOptions.onTrigger</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">cRef</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">_a</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">tick = Promise.resolve()</span><span class="s2">;</span>
<span class="s1">_a = </span><span class="s3">&quot;__v_isReadonly&quot;</span><span class="s2">;</span>

<span class="s0">// node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js</span>
<span class="s2">var </span><span class="s1">stack = []</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">pushWarningContext(vnode) {</span>
  <span class="s1">stack.push(vnode)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">popWarningContext() {</span>
  <span class="s1">stack.pop()</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">warn2(msg</span><span class="s2">, </span><span class="s1">...args) {</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">false</span><span class="s1">)</span>
    <span class="s2">return;</span>
  <span class="s1">pauseTracking()</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">instance = stack.length ? stack[stack.length - </span><span class="s4">1</span><span class="s1">].component : </span><span class="s2">null;</span>
  <span class="s2">const </span><span class="s1">appWarnHandler = instance &amp;&amp; instance.appContext.config.warnHandler</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">trace = getComponentTrace()</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(appWarnHandler) {</span>
    <span class="s1">callWithErrorHandling(appWarnHandler</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s4">11</span><span class="s2">, </span><span class="s1">[</span>
      <span class="s1">msg + args.join(</span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s2">,</span>
      <span class="s1">instance &amp;&amp; instance.proxy</span><span class="s2">,</span>
      <span class="s1">trace.map(({ vnode }) =&gt; </span><span class="s3">`at &lt;</span><span class="s1">${formatComponentName(instance</span><span class="s2">, </span><span class="s1">vnode.type)}</span><span class="s3">&gt;`</span><span class="s1">).join(</span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">)</span><span class="s2">,</span>
      <span class="s1">trace</span>
    <span class="s1">])</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s2">const </span><span class="s1">warnArgs = [</span><span class="s3">`[Vue warn]: </span><span class="s1">${msg}</span><span class="s3">`</span><span class="s2">, </span><span class="s1">...args]</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(trace.length &amp;&amp; </span><span class="s0">// avoid spamming console during tests</span>
    <span class="s2">true</span><span class="s1">) {</span>
      <span class="s1">warnArgs.push(</span><span class="s3">`</span>
<span class="s3">`</span><span class="s2">, </span><span class="s1">...formatTrace(trace))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">console.warn(...warnArgs)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s1">resetTracking()</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getComponentTrace() {</span>
  <span class="s2">let </span><span class="s1">currentVNode = stack[stack.length - </span><span class="s4">1</span><span class="s1">]</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(!currentVNode) {</span>
    <span class="s2">return </span><span class="s1">[]</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">const </span><span class="s1">normalizedStack = []</span><span class="s2">;</span>
  <span class="s2">while </span><span class="s1">(currentVNode) {</span>
    <span class="s2">const </span><span class="s1">last = normalizedStack[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(last &amp;&amp; last.vnode === currentVNode) {</span>
      <span class="s1">last.recurseCount++</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">normalizedStack.push({</span>
        <span class="s1">vnode: currentVNode</span><span class="s2">,</span>
        <span class="s1">recurseCount: </span><span class="s4">0</span>
      <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">parentInstance = currentVNode.component &amp;&amp; currentVNode.component.parent</span><span class="s2">;</span>
    <span class="s1">currentVNode = parentInstance &amp;&amp; parentInstance.vnode</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">normalizedStack</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">formatTrace(trace) {</span>
  <span class="s2">const </span><span class="s1">logs = []</span><span class="s2">;</span>
  <span class="s1">trace.forEach((entry</span><span class="s2">, </span><span class="s1">i) =&gt; {</span>
    <span class="s1">logs.push(...i === </span><span class="s4">0 </span><span class="s1">? [] : [</span><span class="s3">`</span>
<span class="s3">`</span><span class="s1">]</span><span class="s2">, </span><span class="s1">...formatTraceEntry(entry))</span><span class="s2">;</span>
  <span class="s1">})</span><span class="s2">;</span>
  <span class="s2">return </span><span class="s1">logs</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">formatTraceEntry({ vnode</span><span class="s2">, </span><span class="s1">recurseCount }) {</span>
  <span class="s2">const </span><span class="s1">postfix = recurseCount &gt; </span><span class="s4">0 </span><span class="s1">? </span><span class="s3">`... (</span><span class="s1">${recurseCount} </span><span class="s3">recursive calls)` </span><span class="s1">: </span><span class="s3">``</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">isRoot = vnode.component ? vnode.component.parent == </span><span class="s2">null </span><span class="s1">: </span><span class="s2">false;</span>
  <span class="s2">const </span><span class="s1">open = </span><span class="s3">` at &lt;</span><span class="s1">${formatComponentName(vnode.component</span><span class="s2">, </span><span class="s1">vnode.type</span><span class="s2">, </span><span class="s1">isRoot)}</span><span class="s3">`</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">close = </span><span class="s3">`&gt;` </span><span class="s1">+ postfix</span><span class="s2">;</span>
  <span class="s2">return </span><span class="s1">vnode.props ? [open</span><span class="s2">, </span><span class="s1">...formatProps(vnode.props)</span><span class="s2">, </span><span class="s1">close] : [open + close]</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">formatProps(props) {</span>
  <span class="s2">const </span><span class="s1">res = []</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">keys = Object.keys(props)</span><span class="s2">;</span>
  <span class="s1">keys.slice(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">3</span><span class="s1">).forEach((key) =&gt; {</span>
    <span class="s1">res.push(...formatProp(key</span><span class="s2">, </span><span class="s1">props[key]))</span><span class="s2">;</span>
  <span class="s1">})</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(keys.length &gt; </span><span class="s4">3</span><span class="s1">) {</span>
    <span class="s1">res.push(</span><span class="s3">` ...`</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">res</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">formatProp(key</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">raw) {</span>
  <span class="s2">if </span><span class="s1">(isString(value)) {</span>
    <span class="s1">value = JSON.stringify(value)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">raw ? value : [</span><span class="s3">`</span><span class="s1">${key}</span><span class="s3">=</span><span class="s1">${value}</span><span class="s3">`</span><span class="s1">]</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">value === </span><span class="s3">&quot;number&quot; </span><span class="s1">|| </span><span class="s2">typeof </span><span class="s1">value === </span><span class="s3">&quot;boolean&quot; </span><span class="s1">|| value == </span><span class="s2">null</span><span class="s1">) {</span>
    <span class="s2">return </span><span class="s1">raw ? value : [</span><span class="s3">`</span><span class="s1">${key}</span><span class="s3">=</span><span class="s1">${value}</span><span class="s3">`</span><span class="s1">]</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isRef(value)) {</span>
    <span class="s1">value = formatProp(key</span><span class="s2">, </span><span class="s1">toRaw(value.value)</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">raw ? value : [</span><span class="s3">`</span><span class="s1">${key}</span><span class="s3">=Ref&lt;`</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s3">`&gt;`</span><span class="s1">]</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isFunction(value)) {</span>
    <span class="s2">return </span><span class="s1">[</span><span class="s3">`</span><span class="s1">${key}</span><span class="s3">=fn</span><span class="s1">${value.name ? </span><span class="s3">`&lt;</span><span class="s1">${value.name}</span><span class="s3">&gt;` </span><span class="s1">: </span><span class="s3">``</span><span class="s1">}</span><span class="s3">`</span><span class="s1">]</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s1">value = toRaw(value)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">raw ? value : [</span><span class="s3">`</span><span class="s1">${key}</span><span class="s3">=`</span><span class="s2">, </span><span class="s1">value]</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">assertNumber(val</span><span class="s2">, </span><span class="s1">type) {</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">false</span><span class="s1">)</span>
    <span class="s2">return;</span>
  <span class="s2">if </span><span class="s1">(val === </span><span class="s2">void </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s2">return;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">val !== </span><span class="s3">&quot;number&quot;</span><span class="s1">) {</span>
    <span class="s1">warn2(</span><span class="s3">`</span><span class="s1">${type} </span><span class="s3">is not a valid number - got </span><span class="s1">${JSON.stringify(val)}</span><span class="s3">.`</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isNaN(val)) {</span>
    <span class="s1">warn2(</span><span class="s3">`</span><span class="s1">${type} </span><span class="s3">is NaN - the duration expression might be incorrect.`</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">ErrorTypeStrings = {</span>
  <span class="s1">[</span>
    <span class="s3">&quot;sp&quot;</span>
    <span class="s0">/* LifecycleHooks.SERVER_PREFETCH */</span>
  <span class="s1">]: </span><span class="s3">&quot;serverPrefetch hook&quot;</span><span class="s2">,</span>
  <span class="s1">[</span>
    <span class="s3">&quot;bc&quot;</span>
    <span class="s0">/* LifecycleHooks.BEFORE_CREATE */</span>
  <span class="s1">]: </span><span class="s3">&quot;beforeCreate hook&quot;</span><span class="s2">,</span>
  <span class="s1">[</span>
    <span class="s3">&quot;c&quot;</span>
    <span class="s0">/* LifecycleHooks.CREATED */</span>
  <span class="s1">]: </span><span class="s3">&quot;created hook&quot;</span><span class="s2">,</span>
  <span class="s1">[</span>
    <span class="s3">&quot;bm&quot;</span>
    <span class="s0">/* LifecycleHooks.BEFORE_MOUNT */</span>
  <span class="s1">]: </span><span class="s3">&quot;beforeMount hook&quot;</span><span class="s2">,</span>
  <span class="s1">[</span>
    <span class="s3">&quot;m&quot;</span>
    <span class="s0">/* LifecycleHooks.MOUNTED */</span>
  <span class="s1">]: </span><span class="s3">&quot;mounted hook&quot;</span><span class="s2">,</span>
  <span class="s1">[</span>
    <span class="s3">&quot;bu&quot;</span>
    <span class="s0">/* LifecycleHooks.BEFORE_UPDATE */</span>
  <span class="s1">]: </span><span class="s3">&quot;beforeUpdate hook&quot;</span><span class="s2">,</span>
  <span class="s1">[</span>
    <span class="s3">&quot;u&quot;</span>
    <span class="s0">/* LifecycleHooks.UPDATED */</span>
  <span class="s1">]: </span><span class="s3">&quot;updated&quot;</span><span class="s2">,</span>
  <span class="s1">[</span>
    <span class="s3">&quot;bum&quot;</span>
    <span class="s0">/* LifecycleHooks.BEFORE_UNMOUNT */</span>
  <span class="s1">]: </span><span class="s3">&quot;beforeUnmount hook&quot;</span><span class="s2">,</span>
  <span class="s1">[</span>
    <span class="s3">&quot;um&quot;</span>
    <span class="s0">/* LifecycleHooks.UNMOUNTED */</span>
  <span class="s1">]: </span><span class="s3">&quot;unmounted hook&quot;</span><span class="s2">,</span>
  <span class="s1">[</span>
    <span class="s3">&quot;a&quot;</span>
    <span class="s0">/* LifecycleHooks.ACTIVATED */</span>
  <span class="s1">]: </span><span class="s3">&quot;activated hook&quot;</span><span class="s2">,</span>
  <span class="s1">[</span>
    <span class="s3">&quot;da&quot;</span>
    <span class="s0">/* LifecycleHooks.DEACTIVATED */</span>
  <span class="s1">]: </span><span class="s3">&quot;deactivated hook&quot;</span><span class="s2">,</span>
  <span class="s1">[</span>
    <span class="s3">&quot;ec&quot;</span>
    <span class="s0">/* LifecycleHooks.ERROR_CAPTURED */</span>
  <span class="s1">]: </span><span class="s3">&quot;errorCaptured hook&quot;</span><span class="s2">,</span>
  <span class="s1">[</span>
    <span class="s3">&quot;rtc&quot;</span>
    <span class="s0">/* LifecycleHooks.RENDER_TRACKED */</span>
  <span class="s1">]: </span><span class="s3">&quot;renderTracked hook&quot;</span><span class="s2">,</span>
  <span class="s1">[</span>
    <span class="s3">&quot;rtg&quot;</span>
    <span class="s0">/* LifecycleHooks.RENDER_TRIGGERED */</span>
  <span class="s1">]: </span><span class="s3">&quot;renderTriggered hook&quot;</span><span class="s2">,</span>
  <span class="s1">[</span>
    <span class="s4">0</span>
    <span class="s0">/* ErrorCodes.SETUP_FUNCTION */</span>
  <span class="s1">]: </span><span class="s3">&quot;setup function&quot;</span><span class="s2">,</span>
  <span class="s1">[</span>
    <span class="s4">1</span>
    <span class="s0">/* ErrorCodes.RENDER_FUNCTION */</span>
  <span class="s1">]: </span><span class="s3">&quot;render function&quot;</span><span class="s2">,</span>
  <span class="s1">[</span>
    <span class="s4">2</span>
    <span class="s0">/* ErrorCodes.WATCH_GETTER */</span>
  <span class="s1">]: </span><span class="s3">&quot;watcher getter&quot;</span><span class="s2">,</span>
  <span class="s1">[</span>
    <span class="s4">3</span>
    <span class="s0">/* ErrorCodes.WATCH_CALLBACK */</span>
  <span class="s1">]: </span><span class="s3">&quot;watcher callback&quot;</span><span class="s2">,</span>
  <span class="s1">[</span>
    <span class="s4">4</span>
    <span class="s0">/* ErrorCodes.WATCH_CLEANUP */</span>
  <span class="s1">]: </span><span class="s3">&quot;watcher cleanup function&quot;</span><span class="s2">,</span>
  <span class="s1">[</span>
    <span class="s4">5</span>
    <span class="s0">/* ErrorCodes.NATIVE_EVENT_HANDLER */</span>
  <span class="s1">]: </span><span class="s3">&quot;native event handler&quot;</span><span class="s2">,</span>
  <span class="s1">[</span>
    <span class="s4">6</span>
    <span class="s0">/* ErrorCodes.COMPONENT_EVENT_HANDLER */</span>
  <span class="s1">]: </span><span class="s3">&quot;component event handler&quot;</span><span class="s2">,</span>
  <span class="s1">[</span>
    <span class="s4">7</span>
    <span class="s0">/* ErrorCodes.VNODE_HOOK */</span>
  <span class="s1">]: </span><span class="s3">&quot;vnode hook&quot;</span><span class="s2">,</span>
  <span class="s1">[</span>
    <span class="s4">8</span>
    <span class="s0">/* ErrorCodes.DIRECTIVE_HOOK */</span>
  <span class="s1">]: </span><span class="s3">&quot;directive hook&quot;</span><span class="s2">,</span>
  <span class="s1">[</span>
    <span class="s4">9</span>
    <span class="s0">/* ErrorCodes.TRANSITION_HOOK */</span>
  <span class="s1">]: </span><span class="s3">&quot;transition hook&quot;</span><span class="s2">,</span>
  <span class="s1">[</span>
    <span class="s4">10</span>
    <span class="s0">/* ErrorCodes.APP_ERROR_HANDLER */</span>
  <span class="s1">]: </span><span class="s3">&quot;app errorHandler&quot;</span><span class="s2">,</span>
  <span class="s1">[</span>
    <span class="s4">11</span>
    <span class="s0">/* ErrorCodes.APP_WARN_HANDLER */</span>
  <span class="s1">]: </span><span class="s3">&quot;app warnHandler&quot;</span><span class="s2">,</span>
  <span class="s1">[</span>
    <span class="s4">12</span>
    <span class="s0">/* ErrorCodes.FUNCTION_REF */</span>
  <span class="s1">]: </span><span class="s3">&quot;ref function&quot;</span><span class="s2">,</span>
  <span class="s1">[</span>
    <span class="s4">13</span>
    <span class="s0">/* ErrorCodes.ASYNC_COMPONENT_LOADER */</span>
  <span class="s1">]: </span><span class="s3">&quot;async component loader&quot;</span><span class="s2">,</span>
  <span class="s1">[</span>
    <span class="s4">14</span>
    <span class="s0">/* ErrorCodes.SCHEDULER */</span>
  <span class="s1">]: </span><span class="s3">&quot;scheduler flush. This is likely a Vue internals bug. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core&quot;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">callWithErrorHandling(fn</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">args) {</span>
  <span class="s2">let </span><span class="s1">res</span><span class="s2">;</span>
  <span class="s2">try </span><span class="s1">{</span>
    <span class="s1">res = args ? fn(...args) : fn()</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
    <span class="s1">handleError(err</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s1">type)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">res</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">callWithAsyncErrorHandling(fn</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">args) {</span>
  <span class="s2">if </span><span class="s1">(isFunction(fn)) {</span>
    <span class="s2">const </span><span class="s1">res = callWithErrorHandling(fn</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">args)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(res &amp;&amp; isPromise(res)) {</span>
      <span class="s1">res.catch((err) =&gt; {</span>
        <span class="s1">handleError(err</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s1">type)</span><span class="s2">;</span>
      <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">res</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">const </span><span class="s1">values = []</span><span class="s2">;</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; fn.length</span><span class="s2">; </span><span class="s1">i++) {</span>
    <span class="s1">values.push(callWithAsyncErrorHandling(fn[i]</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">args))</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">values</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">handleError(err</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">throwInDev = </span><span class="s2">true</span><span class="s1">) {</span>
  <span class="s2">const </span><span class="s1">contextVNode = instance ? instance.vnode : </span><span class="s2">null;</span>
  <span class="s2">if </span><span class="s1">(instance) {</span>
    <span class="s2">let </span><span class="s1">cur = instance.parent</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">exposedInstance = instance.proxy</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">errorInfo = </span><span class="s2">true </span><span class="s1">? ErrorTypeStrings[type] : type</span><span class="s2">;</span>
    <span class="s2">while </span><span class="s1">(cur) {</span>
      <span class="s2">const </span><span class="s1">errorCapturedHooks = cur.ec</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(errorCapturedHooks) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; errorCapturedHooks.length</span><span class="s2">; </span><span class="s1">i++) {</span>
          <span class="s2">if </span><span class="s1">(errorCapturedHooks[i](err</span><span class="s2">, </span><span class="s1">exposedInstance</span><span class="s2">, </span><span class="s1">errorInfo) === </span><span class="s2">false</span><span class="s1">) {</span>
            <span class="s2">return;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s1">cur = cur.parent</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">appErrorHandler = instance.appContext.config.errorHandler</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(appErrorHandler) {</span>
      <span class="s1">callWithErrorHandling(appErrorHandler</span><span class="s2">, null, </span><span class="s4">10</span><span class="s2">, </span><span class="s1">[err</span><span class="s2">, </span><span class="s1">exposedInstance</span><span class="s2">, </span><span class="s1">errorInfo])</span><span class="s2">;</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">logError(err</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">contextVNode</span><span class="s2">, </span><span class="s1">throwInDev)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">logError(err</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">contextVNode</span><span class="s2">, </span><span class="s1">throwInDev = </span><span class="s2">true</span><span class="s1">) {</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s2">const </span><span class="s1">info = ErrorTypeStrings[type]</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(contextVNode) {</span>
      <span class="s1">pushWarningContext(contextVNode)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">warn2(</span><span class="s3">`Unhandled error</span><span class="s1">${info ? </span><span class="s3">` during execution of </span><span class="s1">${info}</span><span class="s3">` </span><span class="s1">: </span><span class="s3">``</span><span class="s1">}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(contextVNode) {</span>
      <span class="s1">popWarningContext()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(throwInDev) {</span>
      <span class="s2">throw </span><span class="s1">err</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">console.error(err)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s1">console.error(err)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">isFlushing = </span><span class="s2">false;</span>
<span class="s2">var </span><span class="s1">isFlushPending = </span><span class="s2">false;</span>
<span class="s2">var </span><span class="s1">queue = []</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">flushIndex = </span><span class="s4">0</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">pendingPostFlushCbs = []</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">activePostFlushCbs = </span><span class="s2">null;</span>
<span class="s2">var </span><span class="s1">postFlushIndex = </span><span class="s4">0</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">resolvedPromise = Promise.resolve()</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">currentFlushPromise = </span><span class="s2">null;</span>
<span class="s2">var </span><span class="s1">RECURSION_LIMIT = </span><span class="s4">100</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">nextTick(fn) {</span>
  <span class="s2">const </span><span class="s1">p2 = currentFlushPromise || resolvedPromise</span><span class="s2">;</span>
  <span class="s2">return </span><span class="s1">fn ? p2.then(</span><span class="s2">this </span><span class="s1">? fn.bind(</span><span class="s2">this</span><span class="s1">) : fn) : p2</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">findInsertionIndex(id) {</span>
  <span class="s2">let </span><span class="s1">start = flushIndex + </span><span class="s4">1</span><span class="s2">;</span>
  <span class="s2">let </span><span class="s1">end = queue.length</span><span class="s2">;</span>
  <span class="s2">while </span><span class="s1">(start &lt; end) {</span>
    <span class="s2">const </span><span class="s1">middle = start + end &gt;&gt;&gt; </span><span class="s4">1</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">middleJobId = getId(queue[middle])</span><span class="s2">;</span>
    <span class="s1">middleJobId &lt; id ? start = middle + </span><span class="s4">1 </span><span class="s1">: end = middle</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">start</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">queueJob(job) {</span>
  <span class="s2">if </span><span class="s1">(!queue.length || !queue.includes(job</span><span class="s2">, </span><span class="s1">isFlushing &amp;&amp; job.allowRecurse ? flushIndex + </span><span class="s4">1 </span><span class="s1">: flushIndex)) {</span>
    <span class="s2">if </span><span class="s1">(job.id == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">queue.push(job)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">queue.splice(findInsertionIndex(job.id)</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">job)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">queueFlush()</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">queueFlush() {</span>
  <span class="s2">if </span><span class="s1">(!isFlushing &amp;&amp; !isFlushPending) {</span>
    <span class="s1">isFlushPending = </span><span class="s2">true;</span>
    <span class="s1">currentFlushPromise = resolvedPromise.then(flushJobs)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">invalidateJob(job) {</span>
  <span class="s2">const </span><span class="s1">i = queue.indexOf(job)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(i &gt; flushIndex) {</span>
    <span class="s1">queue.splice(i</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">queuePostFlushCb(cb) {</span>
  <span class="s2">if </span><span class="s1">(!isArray(cb)) {</span>
    <span class="s2">if </span><span class="s1">(!activePostFlushCbs || !activePostFlushCbs.includes(cb</span><span class="s2">, </span><span class="s1">cb.allowRecurse ? postFlushIndex + </span><span class="s4">1 </span><span class="s1">: postFlushIndex)) {</span>
      <span class="s1">pendingPostFlushCbs.push(cb)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s1">pendingPostFlushCbs.push(...cb)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s1">queueFlush()</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">flushPreFlushCbs(seen</span><span class="s2">, </span><span class="s1">i = isFlushing ? flushIndex + </span><span class="s4">1 </span><span class="s1">: </span><span class="s4">0</span><span class="s1">) {</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s1">seen = seen || </span><span class="s0">/* @__PURE__ */ </span><span class="s2">new </span><span class="s1">Map()</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">; </span><span class="s1">i &lt; queue.length</span><span class="s2">; </span><span class="s1">i++) {</span>
    <span class="s2">const </span><span class="s1">cb = queue[i]</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(cb &amp;&amp; cb.pre) {</span>
      <span class="s2">if </span><span class="s1">(checkRecursiveUpdates(seen</span><span class="s2">, </span><span class="s1">cb)) {</span>
        <span class="s2">continue;</span>
      <span class="s1">}</span>
      <span class="s1">queue.splice(i</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">i--</span><span class="s2">;</span>
      <span class="s1">cb()</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">flushPostFlushCbs(seen) {</span>
  <span class="s2">if </span><span class="s1">(pendingPostFlushCbs.length) {</span>
    <span class="s2">const </span><span class="s1">deduped = [...</span><span class="s2">new </span><span class="s1">Set(pendingPostFlushCbs)]</span><span class="s2">;</span>
    <span class="s1">pendingPostFlushCbs.length = </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(activePostFlushCbs) {</span>
      <span class="s1">activePostFlushCbs.push(...deduped)</span><span class="s2">;</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s1">activePostFlushCbs = deduped</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
      <span class="s1">seen = seen || </span><span class="s0">/* @__PURE__ */ </span><span class="s2">new </span><span class="s1">Map()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">activePostFlushCbs.sort((a</span><span class="s2">, </span><span class="s1">b) =&gt; getId(a) - getId(b))</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(postFlushIndex = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">postFlushIndex &lt; activePostFlushCbs.length</span><span class="s2">; </span><span class="s1">postFlushIndex++) {</span>
      <span class="s2">if </span><span class="s1">(checkRecursiveUpdates(seen</span><span class="s2">, </span><span class="s1">activePostFlushCbs[postFlushIndex])) {</span>
        <span class="s2">continue;</span>
      <span class="s1">}</span>
      <span class="s1">activePostFlushCbs[postFlushIndex]()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">activePostFlushCbs = </span><span class="s2">null;</span>
    <span class="s1">postFlushIndex = </span><span class="s4">0</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">getId = (job) =&gt; job.id == </span><span class="s2">null </span><span class="s1">? Infinity : job.id</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">comparator = (a</span><span class="s2">, </span><span class="s1">b) =&gt; {</span>
  <span class="s2">const </span><span class="s1">diff = getId(a) - getId(b)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(diff === </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s2">if </span><span class="s1">(a.pre &amp;&amp; !b.pre)</span>
      <span class="s2">return </span><span class="s1">-</span><span class="s4">1</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(b.pre &amp;&amp; !a.pre)</span>
      <span class="s2">return </span><span class="s4">1</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">diff</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">flushJobs(seen) {</span>
  <span class="s1">isFlushPending = </span><span class="s2">false;</span>
  <span class="s1">isFlushing = </span><span class="s2">true;</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s1">seen = seen || </span><span class="s0">/* @__PURE__ */ </span><span class="s2">new </span><span class="s1">Map()</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s1">queue.sort(comparator)</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">check = </span><span class="s2">true </span><span class="s1">? (job) =&gt; checkRecursiveUpdates(seen</span><span class="s2">, </span><span class="s1">job) : NOOP</span><span class="s2">;</span>
  <span class="s2">try </span><span class="s1">{</span>
    <span class="s2">for </span><span class="s1">(flushIndex = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">flushIndex &lt; queue.length</span><span class="s2">; </span><span class="s1">flushIndex++) {</span>
      <span class="s2">const </span><span class="s1">job = queue[flushIndex]</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(job &amp;&amp; job.active !== </span><span class="s2">false</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(check(job)) {</span>
          <span class="s2">continue;</span>
        <span class="s1">}</span>
        <span class="s1">callWithErrorHandling(</span>
          <span class="s1">job</span><span class="s2">,</span>
          <span class="s2">null,</span>
          <span class="s4">14</span>
          <span class="s0">/* ErrorCodes.SCHEDULER */</span>
        <span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
    <span class="s1">flushIndex = </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s1">queue.length = </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s1">flushPostFlushCbs(seen)</span><span class="s2">;</span>
    <span class="s1">isFlushing = </span><span class="s2">false;</span>
    <span class="s1">currentFlushPromise = </span><span class="s2">null;</span>
    <span class="s2">if </span><span class="s1">(queue.length || pendingPostFlushCbs.length) {</span>
      <span class="s1">flushJobs(seen)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">checkRecursiveUpdates(seen</span><span class="s2">, </span><span class="s1">fn) {</span>
  <span class="s2">if </span><span class="s1">(!seen.has(fn)) {</span>
    <span class="s1">seen.set(fn</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s2">const </span><span class="s1">count = seen.get(fn)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(count &gt; RECURSION_LIMIT) {</span>
      <span class="s2">const </span><span class="s1">instance = fn.ownerInstance</span><span class="s2">;</span>
      <span class="s2">const </span><span class="s1">componentName = instance &amp;&amp; getComponentName(instance.type)</span><span class="s2">;</span>
      <span class="s1">warn2(</span><span class="s3">`Maximum recursive updates exceeded</span><span class="s1">${componentName ? </span><span class="s3">` in component &lt;</span><span class="s1">${componentName}</span><span class="s3">&gt;` </span><span class="s1">: </span><span class="s3">``</span><span class="s1">}</span><span class="s3">. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">return true;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">seen.set(fn</span><span class="s2">, </span><span class="s1">count + </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">isHmrUpdating = </span><span class="s2">false;</span>
<span class="s2">var </span><span class="s1">hmrDirtyComponents = </span><span class="s0">/* @__PURE__ */ </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
<span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
  <span class="s1">getGlobalThis().__VUE_HMR_RUNTIME__ = {</span>
    <span class="s1">createRecord: tryWrap(createRecord)</span><span class="s2">,</span>
    <span class="s1">rerender: tryWrap(rerender)</span><span class="s2">,</span>
    <span class="s1">reload: tryWrap(reload)</span>
  <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">map = </span><span class="s0">/* @__PURE__ */ </span><span class="s2">new </span><span class="s1">Map()</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">registerHMR(instance) {</span>
  <span class="s2">const </span><span class="s1">id = instance.type.__hmrId</span><span class="s2">;</span>
  <span class="s2">let </span><span class="s1">record = map.get(id)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(!record) {</span>
    <span class="s1">createRecord(id</span><span class="s2">, </span><span class="s1">instance.type)</span><span class="s2">;</span>
    <span class="s1">record = map.get(id)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s1">record.instances.add(instance)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">unregisterHMR(instance) {</span>
  <span class="s1">map.get(instance.type.__hmrId).instances.delete(instance)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createRecord(id</span><span class="s2">, </span><span class="s1">initialDef) {</span>
  <span class="s2">if </span><span class="s1">(map.has(id)) {</span>
    <span class="s2">return false;</span>
  <span class="s1">}</span>
  <span class="s1">map.set(id</span><span class="s2">, </span><span class="s1">{</span>
    <span class="s1">initialDef: normalizeClassComponent(initialDef)</span><span class="s2">,</span>
    <span class="s1">instances: </span><span class="s0">/* @__PURE__ */ </span><span class="s2">new </span><span class="s1">Set()</span>
  <span class="s1">})</span><span class="s2">;</span>
  <span class="s2">return true;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">normalizeClassComponent(component) {</span>
  <span class="s2">return </span><span class="s1">isClassComponent(component) ? component.__vccOpts : component</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">rerender(id</span><span class="s2">, </span><span class="s1">newRender) {</span>
  <span class="s2">const </span><span class="s1">record = map.get(id)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(!record) {</span>
    <span class="s2">return;</span>
  <span class="s1">}</span>
  <span class="s1">record.initialDef.render = newRender</span><span class="s2">;</span>
  <span class="s1">[...record.instances].forEach((instance) =&gt; {</span>
    <span class="s2">if </span><span class="s1">(newRender) {</span>
      <span class="s1">instance.render = newRender</span><span class="s2">;</span>
      <span class="s1">normalizeClassComponent(instance.type).render = newRender</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">instance.renderCache = []</span><span class="s2">;</span>
    <span class="s1">isHmrUpdating = </span><span class="s2">true;</span>
    <span class="s1">instance.update()</span><span class="s2">;</span>
    <span class="s1">isHmrUpdating = </span><span class="s2">false;</span>
  <span class="s1">})</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">reload(id</span><span class="s2">, </span><span class="s1">newComp) {</span>
  <span class="s2">const </span><span class="s1">record = map.get(id)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(!record)</span>
    <span class="s2">return;</span>
  <span class="s1">newComp = normalizeClassComponent(newComp)</span><span class="s2">;</span>
  <span class="s1">updateComponentDef(record.initialDef</span><span class="s2">, </span><span class="s1">newComp)</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">instances = [...record.instances]</span><span class="s2">;</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">instance of instances) {</span>
    <span class="s2">const </span><span class="s1">oldComp = normalizeClassComponent(instance.type)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!hmrDirtyComponents.has(oldComp)) {</span>
      <span class="s2">if </span><span class="s1">(oldComp !== record.initialDef) {</span>
        <span class="s1">updateComponentDef(oldComp</span><span class="s2">, </span><span class="s1">newComp)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s1">hmrDirtyComponents.add(oldComp)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">instance.appContext.optionsCache.delete(instance.type)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(instance.ceReload) {</span>
      <span class="s1">hmrDirtyComponents.add(oldComp)</span><span class="s2">;</span>
      <span class="s1">instance.ceReload(newComp.styles)</span><span class="s2">;</span>
      <span class="s1">hmrDirtyComponents.delete(oldComp)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(instance.parent) {</span>
      <span class="s1">queueJob(instance.parent.update)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(instance.appContext.reload) {</span>
      <span class="s1">instance.appContext.reload()</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">window !== </span><span class="s3">&quot;undefined&quot;</span><span class="s1">) {</span>
      <span class="s1">window.location.reload()</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">console.warn(</span><span class="s3">&quot;[HMR] Root or manually mounted instance modified. Full reload required.&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">queuePostFlushCb(() =&gt; {</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">instance of instances) {</span>
      <span class="s1">hmrDirtyComponents.delete(normalizeClassComponent(instance.type))</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">})</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">updateComponentDef(oldComp</span><span class="s2">, </span><span class="s1">newComp) {</span>
  <span class="s1">extend(oldComp</span><span class="s2">, </span><span class="s1">newComp)</span><span class="s2">;</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">oldComp) {</span>
    <span class="s2">if </span><span class="s1">(key !== </span><span class="s3">&quot;__file&quot; </span><span class="s1">&amp;&amp; !(key </span><span class="s2">in </span><span class="s1">newComp)) {</span>
      <span class="s2">delete </span><span class="s1">oldComp[key]</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">tryWrap(fn) {</span>
  <span class="s2">return </span><span class="s1">(id</span><span class="s2">, </span><span class="s1">arg) =&gt; {</span>
    <span class="s2">try </span><span class="s1">{</span>
      <span class="s2">return </span><span class="s1">fn(id</span><span class="s2">, </span><span class="s1">arg)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(e) {</span>
      <span class="s1">console.error(e)</span><span class="s2">;</span>
      <span class="s1">console.warn(</span><span class="s3">`[HMR] Something went wrong during Vue component hot-reload. Full reload required.`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">devtools</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">buffer = []</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">devtoolsNotInstalled = </span><span class="s2">false;</span>
<span class="s2">function </span><span class="s1">emit$1(event</span><span class="s2">, </span><span class="s1">...args) {</span>
  <span class="s2">if </span><span class="s1">(devtools) {</span>
    <span class="s1">devtools.emit(event</span><span class="s2">, </span><span class="s1">...args)</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!devtoolsNotInstalled) {</span>
    <span class="s1">buffer.push({ event</span><span class="s2">, </span><span class="s1">args })</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">setDevtoolsHook(hook</span><span class="s2">, </span><span class="s1">target) {</span>
  <span class="s2">var </span><span class="s1">_a2</span><span class="s2">, </span><span class="s1">_b</span><span class="s2">;</span>
  <span class="s1">devtools = hook</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(devtools) {</span>
    <span class="s1">devtools.enabled = </span><span class="s2">true;</span>
    <span class="s1">buffer.forEach(({ event</span><span class="s2">, </span><span class="s1">args }) =&gt; devtools.emit(event</span><span class="s2">, </span><span class="s1">...args))</span><span class="s2">;</span>
    <span class="s1">buffer = []</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span>
    <span class="s0">// handle late devtools injection - only do this if we are in an actual</span>
    <span class="s0">// browser environment to avoid the timer handle stalling test runner exit</span>
    <span class="s0">// (#4815)</span>
    <span class="s2">typeof </span><span class="s1">window !== </span><span class="s3">&quot;undefined&quot; </span><span class="s1">&amp;&amp; </span><span class="s0">// some envs mock window but not fully</span>
    <span class="s1">window.HTMLElement &amp;&amp; </span><span class="s0">// also exclude jsdom</span>
    <span class="s1">!((_b = (_a2 = window.navigator) === </span><span class="s2">null </span><span class="s1">|| _a2 === </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _a2.userAgent) === </span><span class="s2">null </span><span class="s1">|| _b === </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _b.includes(</span><span class="s3">&quot;jsdom&quot;</span><span class="s1">))</span>
  <span class="s1">) {</span>
    <span class="s2">const </span><span class="s1">replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || []</span><span class="s2">;</span>
    <span class="s1">replay.push((newHook) =&gt; {</span>
      <span class="s1">setDevtoolsHook(newHook</span><span class="s2">, </span><span class="s1">target)</span><span class="s2">;</span>
    <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">setTimeout(() =&gt; {</span>
      <span class="s2">if </span><span class="s1">(!devtools) {</span>
        <span class="s1">target.__VUE_DEVTOOLS_HOOK_REPLAY__ = </span><span class="s2">null;</span>
        <span class="s1">devtoolsNotInstalled = </span><span class="s2">true;</span>
        <span class="s1">buffer = []</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">, </span><span class="s4">3e3</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s1">devtoolsNotInstalled = </span><span class="s2">true;</span>
    <span class="s1">buffer = []</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">devtoolsInitApp(app</span><span class="s2">, </span><span class="s1">version2) {</span>
  <span class="s1">emit$1(</span><span class="s3">&quot;app:init&quot;</span><span class="s2">, </span><span class="s1">app</span><span class="s2">, </span><span class="s1">version2</span><span class="s2">, </span><span class="s1">{</span>
    <span class="s1">Fragment</span><span class="s2">,</span>
    <span class="s1">Text</span><span class="s2">,</span>
    <span class="s1">Comment</span><span class="s2">,</span>
    <span class="s1">Static</span>
  <span class="s1">})</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">devtoolsUnmountApp(app) {</span>
  <span class="s1">emit$1(</span><span class="s3">&quot;app:unmount&quot;</span><span class="s2">, </span><span class="s1">app)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">devtoolsComponentAdded = createDevtoolsComponentHook(</span>
  <span class="s3">&quot;component:added&quot;</span>
  <span class="s0">/* DevtoolsHooks.COMPONENT_ADDED */</span>
<span class="s1">)</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">devtoolsComponentUpdated = createDevtoolsComponentHook(</span>
  <span class="s3">&quot;component:updated&quot;</span>
  <span class="s0">/* DevtoolsHooks.COMPONENT_UPDATED */</span>
<span class="s1">)</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">_devtoolsComponentRemoved = createDevtoolsComponentHook(</span>
  <span class="s3">&quot;component:removed&quot;</span>
  <span class="s0">/* DevtoolsHooks.COMPONENT_REMOVED */</span>
<span class="s1">)</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">devtoolsComponentRemoved = (component) =&gt; {</span>
  <span class="s2">if </span><span class="s1">(devtools &amp;&amp; </span><span class="s2">typeof </span><span class="s1">devtools.cleanupBuffer === </span><span class="s3">&quot;function&quot; </span><span class="s1">&amp;&amp; </span><span class="s0">// remove the component if it wasn't buffered</span>
  <span class="s1">!devtools.cleanupBuffer(component)) {</span>
    <span class="s1">_devtoolsComponentRemoved(component)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">createDevtoolsComponentHook(hook) {</span>
  <span class="s2">return </span><span class="s1">(component) =&gt; {</span>
    <span class="s1">emit$1(hook</span><span class="s2">, </span><span class="s1">component.appContext.app</span><span class="s2">, </span><span class="s1">component.uid</span><span class="s2">, </span><span class="s1">component.parent ? component.parent.uid : </span><span class="s2">void </span><span class="s4">0</span><span class="s2">, </span><span class="s1">component)</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">devtoolsPerfStart = createDevtoolsPerformanceHook(</span>
  <span class="s3">&quot;perf:start&quot;</span>
  <span class="s0">/* DevtoolsHooks.PERFORMANCE_START */</span>
<span class="s1">)</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">devtoolsPerfEnd = createDevtoolsPerformanceHook(</span>
  <span class="s3">&quot;perf:end&quot;</span>
  <span class="s0">/* DevtoolsHooks.PERFORMANCE_END */</span>
<span class="s1">)</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">createDevtoolsPerformanceHook(hook) {</span>
  <span class="s2">return </span><span class="s1">(component</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">time) =&gt; {</span>
    <span class="s1">emit$1(hook</span><span class="s2">, </span><span class="s1">component.appContext.app</span><span class="s2">, </span><span class="s1">component.uid</span><span class="s2">, </span><span class="s1">component</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">time)</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">devtoolsComponentEmit(component</span><span class="s2">, </span><span class="s1">event</span><span class="s2">, </span><span class="s1">params) {</span>
  <span class="s1">emit$1(</span><span class="s3">&quot;component:emit&quot;</span><span class="s2">, </span><span class="s1">component.appContext.app</span><span class="s2">, </span><span class="s1">component</span><span class="s2">, </span><span class="s1">event</span><span class="s2">, </span><span class="s1">params)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">emit(instance</span><span class="s2">, </span><span class="s1">event</span><span class="s2">, </span><span class="s1">...rawArgs) {</span>
  <span class="s2">if </span><span class="s1">(instance.isUnmounted)</span>
    <span class="s2">return;</span>
  <span class="s2">const </span><span class="s1">props = instance.vnode.props || EMPTY_OBJ</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s2">const </span><span class="s1">{ emitsOptions</span><span class="s2">, </span><span class="s1">propsOptions: [propsOptions] } = instance</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(emitsOptions) {</span>
      <span class="s2">if </span><span class="s1">(!(event </span><span class="s2">in </span><span class="s1">emitsOptions) &amp;&amp; </span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(!propsOptions || !(toHandlerKey(event) </span><span class="s2">in </span><span class="s1">propsOptions)) {</span>
          <span class="s1">warn2(</span><span class="s3">`Component emitted event &quot;</span><span class="s1">${event}</span><span class="s3">&quot; but it is neither declared in the emits option nor as an &quot;</span><span class="s1">${toHandlerKey(event)}</span><span class="s3">&quot; prop.`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">const </span><span class="s1">validator = emitsOptions[event]</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(isFunction(validator)) {</span>
          <span class="s2">const </span><span class="s1">isValid = validator(...rawArgs)</span><span class="s2">;</span>
          <span class="s2">if </span><span class="s1">(!isValid) {</span>
            <span class="s1">warn2(</span><span class="s3">`Invalid event arguments: event validation failed for event &quot;</span><span class="s1">${event}</span><span class="s3">&quot;.`</span><span class="s1">)</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">let </span><span class="s1">args = rawArgs</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">isModelListener2 = event.startsWith(</span><span class="s3">&quot;update:&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">modelArg = isModelListener2 &amp;&amp; event.slice(</span><span class="s4">7</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(modelArg &amp;&amp; modelArg </span><span class="s2">in </span><span class="s1">props) {</span>
    <span class="s2">const </span><span class="s1">modifiersKey = </span><span class="s3">`</span><span class="s1">${modelArg === </span><span class="s3">&quot;modelValue&quot; </span><span class="s1">? </span><span class="s3">&quot;model&quot; </span><span class="s1">: modelArg}</span><span class="s3">Modifiers`</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">{ number</span><span class="s2">, </span><span class="s1">trim } = props[modifiersKey] || EMPTY_OBJ</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(trim) {</span>
      <span class="s1">args = rawArgs.map((a) =&gt; isString(a) ? a.trim() : a)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(number) {</span>
      <span class="s1">args = rawArgs.map(looseToNumber)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s1">devtoolsComponentEmit(instance</span><span class="s2">, </span><span class="s1">event</span><span class="s2">, </span><span class="s1">args)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s2">const </span><span class="s1">lowerCaseEvent = event.toLowerCase()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(lowerCaseEvent !== event &amp;&amp; props[toHandlerKey(lowerCaseEvent)]) {</span>
      <span class="s1">warn2(</span><span class="s3">`Event &quot;</span><span class="s1">${lowerCaseEvent}</span><span class="s3">&quot; is emitted in component </span><span class="s1">${formatComponentName(instance</span><span class="s2">, </span><span class="s1">instance.type)} </span><span class="s3">but the handler is registered for &quot;</span><span class="s1">${event}</span><span class="s3">&quot;. Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use &quot;</span><span class="s1">${hyphenate(event)}</span><span class="s3">&quot; instead of &quot;</span><span class="s1">${event}</span><span class="s3">&quot;.`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">let </span><span class="s1">handlerName</span><span class="s2">;</span>
  <span class="s2">let </span><span class="s1">handler = props[handlerName = toHandlerKey(event)] || </span><span class="s0">// also try camelCase event handler (#2249)</span>
  <span class="s1">props[handlerName = toHandlerKey(camelize(event))]</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(!handler &amp;&amp; isModelListener2) {</span>
    <span class="s1">handler = props[handlerName = toHandlerKey(hyphenate(event))]</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(handler) {</span>
    <span class="s1">callWithAsyncErrorHandling(handler</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s1">args)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">const </span><span class="s1">onceHandler = props[handlerName + </span><span class="s3">`Once`</span><span class="s1">]</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(onceHandler) {</span>
    <span class="s2">if </span><span class="s1">(!instance.emitted) {</span>
      <span class="s1">instance.emitted = {}</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(instance.emitted[handlerName]) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s1">instance.emitted[handlerName] = </span><span class="s2">true;</span>
    <span class="s1">callWithAsyncErrorHandling(onceHandler</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s1">args)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">normalizeEmitsOptions(comp</span><span class="s2">, </span><span class="s1">appContext</span><span class="s2">, </span><span class="s1">asMixin = </span><span class="s2">false</span><span class="s1">) {</span>
  <span class="s2">const </span><span class="s1">cache = appContext.emitsCache</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">cached = cache.get(comp)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(cached !== </span><span class="s2">void </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s2">return </span><span class="s1">cached</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">const </span><span class="s1">raw = comp.emits</span><span class="s2">;</span>
  <span class="s2">let </span><span class="s1">normalized = {}</span><span class="s2">;</span>
  <span class="s2">let </span><span class="s1">hasExtends = </span><span class="s2">false;</span>
  <span class="s2">if </span><span class="s1">(__VUE_OPTIONS_API__ &amp;&amp; !isFunction(comp)) {</span>
    <span class="s2">const </span><span class="s1">extendEmits = (raw2) =&gt; {</span>
      <span class="s2">const </span><span class="s1">normalizedFromExtend = normalizeEmitsOptions(raw2</span><span class="s2">, </span><span class="s1">appContext</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(normalizedFromExtend) {</span>
        <span class="s1">hasExtends = </span><span class="s2">true;</span>
        <span class="s1">extend(normalized</span><span class="s2">, </span><span class="s1">normalizedFromExtend)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!asMixin &amp;&amp; appContext.mixins.length) {</span>
      <span class="s1">appContext.mixins.forEach(extendEmits)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(comp.extends) {</span>
      <span class="s1">extendEmits(comp.extends)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(comp.mixins) {</span>
      <span class="s1">comp.mixins.forEach(extendEmits)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(!raw &amp;&amp; !hasExtends) {</span>
    <span class="s2">if </span><span class="s1">(isObject(comp)) {</span>
      <span class="s1">cache.set(comp</span><span class="s2">, null</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return null;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(isArray(raw)) {</span>
    <span class="s1">raw.forEach((key) =&gt; normalized[key] = </span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s1">extend(normalized</span><span class="s2">, </span><span class="s1">raw)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(isObject(comp)) {</span>
    <span class="s1">cache.set(comp</span><span class="s2">, </span><span class="s1">normalized)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">normalized</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isEmitListener(options</span><span class="s2">, </span><span class="s1">key) {</span>
  <span class="s2">if </span><span class="s1">(!options || !isOn(key)) {</span>
    <span class="s2">return false;</span>
  <span class="s1">}</span>
  <span class="s1">key = key.slice(</span><span class="s4">2</span><span class="s1">).replace(</span><span class="s4">/Once$/</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s2">return </span><span class="s1">hasOwn(options</span><span class="s2">, </span><span class="s1">key[</span><span class="s4">0</span><span class="s1">].toLowerCase() + key.slice(</span><span class="s4">1</span><span class="s1">)) || hasOwn(options</span><span class="s2">, </span><span class="s1">hyphenate(key)) || hasOwn(options</span><span class="s2">, </span><span class="s1">key)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">currentRenderingInstance = </span><span class="s2">null;</span>
<span class="s2">var </span><span class="s1">currentScopeId = </span><span class="s2">null;</span>
<span class="s2">function </span><span class="s1">setCurrentRenderingInstance(instance) {</span>
  <span class="s2">const </span><span class="s1">prev = currentRenderingInstance</span><span class="s2">;</span>
  <span class="s1">currentRenderingInstance = instance</span><span class="s2">;</span>
  <span class="s1">currentScopeId = instance &amp;&amp; instance.type.__scopeId || </span><span class="s2">null;</span>
  <span class="s2">return </span><span class="s1">prev</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">pushScopeId(id) {</span>
  <span class="s1">currentScopeId = id</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">popScopeId() {</span>
  <span class="s1">currentScopeId = </span><span class="s2">null;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">withScopeId = (_id) =&gt; withCtx</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">withCtx(fn</span><span class="s2">, </span><span class="s1">ctx = currentRenderingInstance</span><span class="s2">, </span><span class="s1">isNonScopedSlot) {</span>
  <span class="s2">if </span><span class="s1">(!ctx)</span>
    <span class="s2">return </span><span class="s1">fn</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(fn._n) {</span>
    <span class="s2">return </span><span class="s1">fn</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">const </span><span class="s1">renderFnWithContext = (...args) =&gt; {</span>
    <span class="s2">if </span><span class="s1">(renderFnWithContext._d) {</span>
      <span class="s1">setBlockTracking(-</span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">prevInstance = setCurrentRenderingInstance(ctx)</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">res</span><span class="s2">;</span>
    <span class="s2">try </span><span class="s1">{</span>
      <span class="s1">res = fn(...args)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">finally </span><span class="s1">{</span>
      <span class="s1">setCurrentRenderingInstance(prevInstance)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(renderFnWithContext._d) {</span>
        <span class="s1">setBlockTracking(</span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
      <span class="s1">devtoolsComponentUpdated(ctx)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">res</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s1">renderFnWithContext._n = </span><span class="s2">true;</span>
  <span class="s1">renderFnWithContext._c = </span><span class="s2">true;</span>
  <span class="s1">renderFnWithContext._d = </span><span class="s2">true;</span>
  <span class="s2">return </span><span class="s1">renderFnWithContext</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">accessedAttrs = </span><span class="s2">false;</span>
<span class="s2">function </span><span class="s1">markAttrsAccessed() {</span>
  <span class="s1">accessedAttrs = </span><span class="s2">true;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">renderComponentRoot(instance) {</span>
  <span class="s2">const </span><span class="s1">{ type: Component</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">proxy</span><span class="s2">, </span><span class="s1">withProxy</span><span class="s2">, </span><span class="s1">props</span><span class="s2">, </span><span class="s1">propsOptions: [propsOptions]</span><span class="s2">, </span><span class="s1">slots</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">, </span><span class="s1">emit: emit2</span><span class="s2">, </span><span class="s1">render: render2</span><span class="s2">, </span><span class="s1">renderCache</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">setupState</span><span class="s2">, </span><span class="s1">ctx</span><span class="s2">, </span><span class="s1">inheritAttrs } = instance</span><span class="s2">;</span>
  <span class="s2">let </span><span class="s1">result</span><span class="s2">;</span>
  <span class="s2">let </span><span class="s1">fallthroughAttrs</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">prev = setCurrentRenderingInstance(instance)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s1">accessedAttrs = </span><span class="s2">false;</span>
  <span class="s1">}</span>
  <span class="s2">try </span><span class="s1">{</span>
    <span class="s2">if </span><span class="s1">(vnode.shapeFlag &amp; </span><span class="s4">4</span><span class="s1">) {</span>
      <span class="s2">const </span><span class="s1">proxyToUse = withProxy || proxy</span><span class="s2">;</span>
      <span class="s1">result = normalizeVNode(render2.call(proxyToUse</span><span class="s2">, </span><span class="s1">proxyToUse</span><span class="s2">, </span><span class="s1">renderCache</span><span class="s2">, </span><span class="s1">props</span><span class="s2">, </span><span class="s1">setupState</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">ctx))</span><span class="s2">;</span>
      <span class="s1">fallthroughAttrs = attrs</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">const </span><span class="s1">render3 = Component</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(attrs === props) {</span>
        <span class="s1">markAttrsAccessed()</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s1">result = normalizeVNode(render3.length &gt; </span><span class="s4">1 </span><span class="s1">? render3(props</span><span class="s2">, true </span><span class="s1">? {</span>
        <span class="s1">get attrs() {</span>
          <span class="s1">markAttrsAccessed()</span><span class="s2">;</span>
          <span class="s2">return </span><span class="s1">attrs</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">slots</span><span class="s2">,</span>
        <span class="s1">emit: emit2</span>
      <span class="s1">} : { attrs</span><span class="s2">, </span><span class="s1">slots</span><span class="s2">, </span><span class="s1">emit: emit2 }) : render3(</span>
        <span class="s1">props</span><span class="s2">,</span>
        <span class="s2">null</span>
        <span class="s0">/* we know it doesn't need it */</span>
      <span class="s1">))</span><span class="s2">;</span>
      <span class="s1">fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
    <span class="s1">blockStack.length = </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s1">handleError(</span>
      <span class="s1">err</span><span class="s2">,</span>
      <span class="s1">instance</span><span class="s2">,</span>
      <span class="s4">1</span>
      <span class="s0">/* ErrorCodes.RENDER_FUNCTION */</span>
    <span class="s1">)</span><span class="s2">;</span>
    <span class="s1">result = createVNode(Comment)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">let </span><span class="s1">root = result</span><span class="s2">;</span>
  <span class="s2">let </span><span class="s1">setRoot = </span><span class="s2">void </span><span class="s4">0</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(result.patchFlag &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp; result.patchFlag &amp; </span><span class="s4">2048</span><span class="s1">) {</span>
    <span class="s1">[root</span><span class="s2">, </span><span class="s1">setRoot] = getChildRoot(result)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(fallthroughAttrs &amp;&amp; inheritAttrs !== </span><span class="s2">false</span><span class="s1">) {</span>
    <span class="s2">const </span><span class="s1">keys = Object.keys(fallthroughAttrs)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">{ shapeFlag } = root</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(keys.length) {</span>
      <span class="s2">if </span><span class="s1">(shapeFlag &amp; (</span><span class="s4">1 </span><span class="s1">| </span><span class="s4">6</span><span class="s1">)) {</span>
        <span class="s2">if </span><span class="s1">(propsOptions &amp;&amp; keys.some(isModelListener)) {</span>
          <span class="s1">fallthroughAttrs = filterModelListeners(fallthroughAttrs</span><span class="s2">, </span><span class="s1">propsOptions)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">root = cloneVNode(root</span><span class="s2">, </span><span class="s1">fallthroughAttrs)</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!accessedAttrs &amp;&amp; root.type !== Comment) {</span>
        <span class="s2">const </span><span class="s1">allAttrs = Object.keys(attrs)</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">eventAttrs = []</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">extraAttrs = []</span><span class="s2">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">l = allAttrs.length</span><span class="s2">; </span><span class="s1">i &lt; l</span><span class="s2">; </span><span class="s1">i++) {</span>
          <span class="s2">const </span><span class="s1">key = allAttrs[i]</span><span class="s2">;</span>
          <span class="s2">if </span><span class="s1">(isOn(key)) {</span>
            <span class="s2">if </span><span class="s1">(!isModelListener(key)) {</span>
              <span class="s1">eventAttrs.push(key[</span><span class="s4">2</span><span class="s1">].toLowerCase() + key.slice(</span><span class="s4">3</span><span class="s1">))</span><span class="s2">;</span>
            <span class="s1">}</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">extraAttrs.push(key)</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(extraAttrs.length) {</span>
          <span class="s1">warn2(</span><span class="s3">`Extraneous non-props attributes (</span><span class="s1">${extraAttrs.join(</span><span class="s3">&quot;, &quot;</span><span class="s1">)}</span><span class="s3">) were passed to component but could not be automatically inherited because component renders fragment or text root nodes.`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(eventAttrs.length) {</span>
          <span class="s1">warn2(</span><span class="s3">`Extraneous non-emits event listeners (</span><span class="s1">${eventAttrs.join(</span><span class="s3">&quot;, &quot;</span><span class="s1">)}</span><span class="s3">) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the &quot;emits&quot; option.`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(vnode.dirs) {</span>
    <span class="s2">if </span><span class="s1">(!isElementRoot(root)) {</span>
      <span class="s1">warn2(</span><span class="s3">`Runtime directive used on component with non-element root node. The directives will not function as intended.`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">root = cloneVNode(root)</span><span class="s2">;</span>
    <span class="s1">root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(vnode.transition) {</span>
    <span class="s2">if </span><span class="s1">(!isElementRoot(root)) {</span>
      <span class="s1">warn2(</span><span class="s3">`Component inside &lt;Transition&gt; renders non-element root node that cannot be animated.`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">root.transition = vnode.transition</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(setRoot) {</span>
    <span class="s1">setRoot(root)</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s1">result = root</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s1">setCurrentRenderingInstance(prev)</span><span class="s2">;</span>
  <span class="s2">return </span><span class="s1">result</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">getChildRoot = (vnode) =&gt; {</span>
  <span class="s2">const </span><span class="s1">rawChildren = vnode.children</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">dynamicChildren = vnode.dynamicChildren</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">childRoot = filterSingleRoot(rawChildren)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(!childRoot) {</span>
    <span class="s2">return </span><span class="s1">[vnode</span><span class="s2">, void </span><span class="s4">0</span><span class="s1">]</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">const </span><span class="s1">index = rawChildren.indexOf(childRoot)</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -</span><span class="s4">1</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">setRoot = (updatedRoot) =&gt; {</span>
    <span class="s1">rawChildren[index] = updatedRoot</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(dynamicChildren) {</span>
      <span class="s2">if </span><span class="s1">(dynamicIndex &gt; -</span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s1">dynamicChildren[dynamicIndex] = updatedRoot</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(updatedRoot.patchFlag &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">vnode.dynamicChildren = [...dynamicChildren</span><span class="s2">, </span><span class="s1">updatedRoot]</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">return </span><span class="s1">[normalizeVNode(childRoot)</span><span class="s2">, </span><span class="s1">setRoot]</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">filterSingleRoot(children) {</span>
  <span class="s2">let </span><span class="s1">singleRoot</span><span class="s2">;</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; children.length</span><span class="s2">; </span><span class="s1">i++) {</span>
    <span class="s2">const </span><span class="s1">child = children[i]</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(isVNode(child)) {</span>
      <span class="s2">if </span><span class="s1">(child.type !== Comment || child.children === </span><span class="s3">&quot;v-if&quot;</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(singleRoot) {</span>
          <span class="s2">return;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">singleRoot = child</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">singleRoot</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">getFunctionalFallthrough = (attrs) =&gt; {</span>
  <span class="s2">let </span><span class="s1">res</span><span class="s2">;</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">attrs) {</span>
    <span class="s2">if </span><span class="s1">(key === </span><span class="s3">&quot;class&quot; </span><span class="s1">|| key === </span><span class="s3">&quot;style&quot; </span><span class="s1">|| isOn(key)) {</span>
      <span class="s1">(res || (res = {}))[key] = attrs[key]</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">res</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">filterModelListeners = (attrs</span><span class="s2">, </span><span class="s1">props) =&gt; {</span>
  <span class="s2">const </span><span class="s1">res = {}</span><span class="s2">;</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">attrs) {</span>
    <span class="s2">if </span><span class="s1">(!isModelListener(key) || !(key.slice(</span><span class="s4">9</span><span class="s1">) </span><span class="s2">in </span><span class="s1">props)) {</span>
      <span class="s1">res[key] = attrs[key]</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">res</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">isElementRoot = (vnode) =&gt; {</span>
  <span class="s2">return </span><span class="s1">vnode.shapeFlag &amp; (</span><span class="s4">6 </span><span class="s1">| </span><span class="s4">1</span><span class="s1">) || vnode.type === Comment</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">shouldUpdateComponent(prevVNode</span><span class="s2">, </span><span class="s1">nextVNode</span><span class="s2">, </span><span class="s1">optimized) {</span>
  <span class="s2">const </span><span class="s1">{ props: prevProps</span><span class="s2">, </span><span class="s1">children: prevChildren</span><span class="s2">, </span><span class="s1">component } = prevVNode</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">{ props: nextProps</span><span class="s2">, </span><span class="s1">children: nextChildren</span><span class="s2">, </span><span class="s1">patchFlag } = nextVNode</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">emits = component.emitsOptions</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">((prevChildren || nextChildren) &amp;&amp; isHmrUpdating) {</span>
    <span class="s2">return true;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(nextVNode.dirs || nextVNode.transition) {</span>
    <span class="s2">return true;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(optimized &amp;&amp; patchFlag &gt;= </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s2">if </span><span class="s1">(patchFlag &amp; </span><span class="s4">1024</span><span class="s1">) {</span>
      <span class="s2">return true;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(patchFlag &amp; </span><span class="s4">16</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(!prevProps) {</span>
        <span class="s2">return </span><span class="s1">!!nextProps</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">hasPropsChanged(prevProps</span><span class="s2">, </span><span class="s1">nextProps</span><span class="s2">, </span><span class="s1">emits)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(patchFlag &amp; </span><span class="s4">8</span><span class="s1">) {</span>
      <span class="s2">const </span><span class="s1">dynamicProps = nextVNode.dynamicProps</span><span class="s2">;</span>
      <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; dynamicProps.length</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s2">const </span><span class="s1">key = dynamicProps[i]</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(nextProps[key] !== prevProps[key] &amp;&amp; !isEmitListener(emits</span><span class="s2">, </span><span class="s1">key)) {</span>
          <span class="s2">return true;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s2">if </span><span class="s1">(prevChildren || nextChildren) {</span>
      <span class="s2">if </span><span class="s1">(!nextChildren || !nextChildren.$stable) {</span>
        <span class="s2">return true;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(prevProps === nextProps) {</span>
      <span class="s2">return false;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(!prevProps) {</span>
      <span class="s2">return </span><span class="s1">!!nextProps</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(!nextProps) {</span>
      <span class="s2">return true;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">hasPropsChanged(prevProps</span><span class="s2">, </span><span class="s1">nextProps</span><span class="s2">, </span><span class="s1">emits)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return false;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">hasPropsChanged(prevProps</span><span class="s2">, </span><span class="s1">nextProps</span><span class="s2">, </span><span class="s1">emitsOptions) {</span>
  <span class="s2">const </span><span class="s1">nextKeys = Object.keys(nextProps)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(nextKeys.length !== Object.keys(prevProps).length) {</span>
    <span class="s2">return true;</span>
  <span class="s1">}</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; nextKeys.length</span><span class="s2">; </span><span class="s1">i++) {</span>
    <span class="s2">const </span><span class="s1">key = nextKeys[i]</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(nextProps[key] !== prevProps[key] &amp;&amp; !isEmitListener(emitsOptions</span><span class="s2">, </span><span class="s1">key)) {</span>
      <span class="s2">return true;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">return false;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">updateHOCHostEl({ vnode</span><span class="s2">, </span><span class="s1">parent }</span><span class="s2">, </span><span class="s1">el) {</span>
  <span class="s2">while </span><span class="s1">(parent &amp;&amp; parent.subTree === vnode) {</span>
    <span class="s1">(vnode = parent.vnode).el = el</span><span class="s2">;</span>
    <span class="s1">parent = parent.parent</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">isSuspense = (type) =&gt; type.__isSuspense</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">SuspenseImpl = {</span>
  <span class="s1">name: </span><span class="s3">&quot;Suspense&quot;</span><span class="s2">,</span>
  <span class="s0">// In order to make Suspense tree-shakable, we need to avoid importing it</span>
  <span class="s0">// directly in the renderer. The renderer checks for the __isSuspense flag</span>
  <span class="s0">// on a vnode's type and calls the `process` method, passing in renderer</span>
  <span class="s0">// internals.</span>
  <span class="s1">__isSuspense: </span><span class="s2">true,</span>
  <span class="s1">process(n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized</span><span class="s2">, </span><span class="s1">rendererInternals) {</span>
    <span class="s2">if </span><span class="s1">(n1 == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">mountSuspense(n2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized</span><span class="s2">, </span><span class="s1">rendererInternals)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">patchSuspense(n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized</span><span class="s2">, </span><span class="s1">rendererInternals)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">,</span>
  <span class="s1">hydrate: hydrateSuspense</span><span class="s2">,</span>
  <span class="s1">create: createSuspenseBoundary</span><span class="s2">,</span>
  <span class="s1">normalize: normalizeSuspenseChildren</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">Suspense = SuspenseImpl</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">triggerEvent(vnode</span><span class="s2">, </span><span class="s1">name) {</span>
  <span class="s2">const </span><span class="s1">eventListener = vnode.props &amp;&amp; vnode.props[name]</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(isFunction(eventListener)) {</span>
    <span class="s1">eventListener()</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">mountSuspense(vnode</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized</span><span class="s2">, </span><span class="s1">rendererInternals) {</span>
  <span class="s2">const </span><span class="s1">{ p: patch</span><span class="s2">, </span><span class="s1">o: { createElement } } = rendererInternals</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">hiddenContainer = createElement(</span><span class="s3">&quot;div&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">suspense = vnode.suspense = createSuspenseBoundary(vnode</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">hiddenContainer</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized</span><span class="s2">, </span><span class="s1">rendererInternals)</span><span class="s2">;</span>
  <span class="s1">patch(</span><span class="s2">null, </span><span class="s1">suspense.pendingBranch = vnode.ssContent</span><span class="s2">, </span><span class="s1">hiddenContainer</span><span class="s2">, null, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">suspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(suspense.deps &gt; </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s1">triggerEvent(vnode</span><span class="s2">, </span><span class="s3">&quot;onPending&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">triggerEvent(vnode</span><span class="s2">, </span><span class="s3">&quot;onFallback&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">patch(</span>
      <span class="s2">null,</span>
      <span class="s1">vnode.ssFallback</span><span class="s2">,</span>
      <span class="s1">container</span><span class="s2">,</span>
      <span class="s1">anchor</span><span class="s2">,</span>
      <span class="s1">parentComponent</span><span class="s2">,</span>
      <span class="s2">null,</span>
      <span class="s0">// fallback tree will not have suspense context</span>
      <span class="s1">isSVG</span><span class="s2">,</span>
      <span class="s1">slotScopeIds</span>
    <span class="s1">)</span><span class="s2">;</span>
    <span class="s1">setActiveBranch(suspense</span><span class="s2">, </span><span class="s1">vnode.ssFallback)</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s1">suspense.resolve()</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">patchSuspense(n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized</span><span class="s2">, </span><span class="s1">{ p: patch</span><span class="s2">, </span><span class="s1">um: unmount</span><span class="s2">, </span><span class="s1">o: { createElement } }) {</span>
  <span class="s2">const </span><span class="s1">suspense = n2.suspense = n1.suspense</span><span class="s2">;</span>
  <span class="s1">suspense.vnode = n2</span><span class="s2">;</span>
  <span class="s1">n2.el = n1.el</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">newBranch = n2.ssContent</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">newFallback = n2.ssFallback</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">{ activeBranch</span><span class="s2">, </span><span class="s1">pendingBranch</span><span class="s2">, </span><span class="s1">isInFallback</span><span class="s2">, </span><span class="s1">isHydrating } = suspense</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(pendingBranch) {</span>
    <span class="s1">suspense.pendingBranch = newBranch</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(isSameVNodeType(newBranch</span><span class="s2">, </span><span class="s1">pendingBranch)) {</span>
      <span class="s1">patch(pendingBranch</span><span class="s2">, </span><span class="s1">newBranch</span><span class="s2">, </span><span class="s1">suspense.hiddenContainer</span><span class="s2">, null, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">suspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(suspense.deps &lt;= </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">suspense.resolve()</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isInFallback) {</span>
        <span class="s1">patch(</span>
          <span class="s1">activeBranch</span><span class="s2">,</span>
          <span class="s1">newFallback</span><span class="s2">,</span>
          <span class="s1">container</span><span class="s2">,</span>
          <span class="s1">anchor</span><span class="s2">,</span>
          <span class="s1">parentComponent</span><span class="s2">,</span>
          <span class="s2">null,</span>
          <span class="s0">// fallback tree will not have suspense context</span>
          <span class="s1">isSVG</span><span class="s2">,</span>
          <span class="s1">slotScopeIds</span><span class="s2">,</span>
          <span class="s1">optimized</span>
        <span class="s1">)</span><span class="s2">;</span>
        <span class="s1">setActiveBranch(suspense</span><span class="s2">, </span><span class="s1">newFallback)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">suspense.pendingId++</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(isHydrating) {</span>
        <span class="s1">suspense.isHydrating = </span><span class="s2">false;</span>
        <span class="s1">suspense.activeBranch = pendingBranch</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">unmount(pendingBranch</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">suspense)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s1">suspense.deps = </span><span class="s4">0</span><span class="s2">;</span>
      <span class="s1">suspense.effects.length = </span><span class="s4">0</span><span class="s2">;</span>
      <span class="s1">suspense.hiddenContainer = createElement(</span><span class="s3">&quot;div&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(isInFallback) {</span>
        <span class="s1">patch(</span><span class="s2">null, </span><span class="s1">newBranch</span><span class="s2">, </span><span class="s1">suspense.hiddenContainer</span><span class="s2">, null, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">suspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(suspense.deps &lt;= </span><span class="s4">0</span><span class="s1">) {</span>
          <span class="s1">suspense.resolve()</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">patch(</span>
            <span class="s1">activeBranch</span><span class="s2">,</span>
            <span class="s1">newFallback</span><span class="s2">,</span>
            <span class="s1">container</span><span class="s2">,</span>
            <span class="s1">anchor</span><span class="s2">,</span>
            <span class="s1">parentComponent</span><span class="s2">,</span>
            <span class="s2">null,</span>
            <span class="s0">// fallback tree will not have suspense context</span>
            <span class="s1">isSVG</span><span class="s2">,</span>
            <span class="s1">slotScopeIds</span><span class="s2">,</span>
            <span class="s1">optimized</span>
          <span class="s1">)</span><span class="s2">;</span>
          <span class="s1">setActiveBranch(suspense</span><span class="s2">, </span><span class="s1">newFallback)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(activeBranch &amp;&amp; isSameVNodeType(newBranch</span><span class="s2">, </span><span class="s1">activeBranch)) {</span>
        <span class="s1">patch(activeBranch</span><span class="s2">, </span><span class="s1">newBranch</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">suspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
        <span class="s1">suspense.resolve(</span><span class="s2">true</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">patch(</span><span class="s2">null, </span><span class="s1">newBranch</span><span class="s2">, </span><span class="s1">suspense.hiddenContainer</span><span class="s2">, null, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">suspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(suspense.deps &lt;= </span><span class="s4">0</span><span class="s1">) {</span>
          <span class="s1">suspense.resolve()</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s2">if </span><span class="s1">(activeBranch &amp;&amp; isSameVNodeType(newBranch</span><span class="s2">, </span><span class="s1">activeBranch)) {</span>
      <span class="s1">patch(activeBranch</span><span class="s2">, </span><span class="s1">newBranch</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">suspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
      <span class="s1">setActiveBranch(suspense</span><span class="s2">, </span><span class="s1">newBranch)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">triggerEvent(n2</span><span class="s2">, </span><span class="s3">&quot;onPending&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">suspense.pendingBranch = newBranch</span><span class="s2">;</span>
      <span class="s1">suspense.pendingId++</span><span class="s2">;</span>
      <span class="s1">patch(</span><span class="s2">null, </span><span class="s1">newBranch</span><span class="s2">, </span><span class="s1">suspense.hiddenContainer</span><span class="s2">, null, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">suspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(suspense.deps &lt;= </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">suspense.resolve()</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">const </span><span class="s1">{ timeout</span><span class="s2">, </span><span class="s1">pendingId } = suspense</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(timeout &gt; </span><span class="s4">0</span><span class="s1">) {</span>
          <span class="s1">setTimeout(() =&gt; {</span>
            <span class="s2">if </span><span class="s1">(suspense.pendingId === pendingId) {</span>
              <span class="s1">suspense.fallback(newFallback)</span><span class="s2">;</span>
            <span class="s1">}</span>
          <span class="s1">}</span><span class="s2">, </span><span class="s1">timeout)</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(timeout === </span><span class="s4">0</span><span class="s1">) {</span>
          <span class="s1">suspense.fallback(newFallback)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">hasWarned = </span><span class="s2">false;</span>
<span class="s2">function </span><span class="s1">createSuspenseBoundary(vnode</span><span class="s2">, </span><span class="s1">parent</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">hiddenContainer</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized</span><span class="s2">, </span><span class="s1">rendererInternals</span><span class="s2">, </span><span class="s1">isHydrating = </span><span class="s2">false</span><span class="s1">) {</span>
  <span class="s2">if </span><span class="s1">(!hasWarned) {</span>
    <span class="s1">hasWarned = </span><span class="s2">true;</span>
    <span class="s1">console[console.info ? </span><span class="s3">&quot;info&quot; </span><span class="s1">: </span><span class="s3">&quot;log&quot;</span><span class="s1">](</span><span class="s3">`&lt;Suspense&gt; is an experimental feature and its API will likely change.`</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">const </span><span class="s1">{ p: patch</span><span class="s2">, </span><span class="s1">m: move</span><span class="s2">, </span><span class="s1">um: unmount</span><span class="s2">, </span><span class="s1">n: next</span><span class="s2">, </span><span class="s1">o: { parentNode</span><span class="s2">, </span><span class="s1">remove: remove2 } } = rendererInternals</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">timeout = vnode.props ? toNumber(vnode.props.timeout) : </span><span class="s2">void </span><span class="s4">0</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s1">assertNumber(timeout</span><span class="s2">, </span><span class="s3">`Suspense timeout`</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">const </span><span class="s1">suspense = {</span>
    <span class="s1">vnode</span><span class="s2">,</span>
    <span class="s1">parent</span><span class="s2">,</span>
    <span class="s1">parentComponent</span><span class="s2">,</span>
    <span class="s1">isSVG</span><span class="s2">,</span>
    <span class="s1">container</span><span class="s2">,</span>
    <span class="s1">hiddenContainer</span><span class="s2">,</span>
    <span class="s1">anchor</span><span class="s2">,</span>
    <span class="s1">deps: </span><span class="s4">0</span><span class="s2">,</span>
    <span class="s1">pendingId: </span><span class="s4">0</span><span class="s2">,</span>
    <span class="s1">timeout: </span><span class="s2">typeof </span><span class="s1">timeout === </span><span class="s3">&quot;number&quot; </span><span class="s1">? timeout : -</span><span class="s4">1</span><span class="s2">,</span>
    <span class="s1">activeBranch: </span><span class="s2">null,</span>
    <span class="s1">pendingBranch: </span><span class="s2">null,</span>
    <span class="s1">isInFallback: </span><span class="s2">true,</span>
    <span class="s1">isHydrating</span><span class="s2">,</span>
    <span class="s1">isUnmounted: </span><span class="s2">false,</span>
    <span class="s1">effects: []</span><span class="s2">,</span>
    <span class="s1">resolve(resume = </span><span class="s2">false</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(!resume &amp;&amp; !suspense.pendingBranch) {</span>
          <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">`suspense.resolve() is called without a pending branch.`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(suspense.isUnmounted) {</span>
          <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">`suspense.resolve() is called on an already unmounted suspense boundary.`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">const </span><span class="s1">{ vnode: vnode2</span><span class="s2">, </span><span class="s1">activeBranch</span><span class="s2">, </span><span class="s1">pendingBranch</span><span class="s2">, </span><span class="s1">pendingId</span><span class="s2">, </span><span class="s1">effects</span><span class="s2">, </span><span class="s1">parentComponent: parentComponent2</span><span class="s2">, </span><span class="s1">container: container2 } = suspense</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(suspense.isHydrating) {</span>
        <span class="s1">suspense.isHydrating = </span><span class="s2">false;</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!resume) {</span>
        <span class="s2">const </span><span class="s1">delayEnter = activeBranch &amp;&amp; pendingBranch.transition &amp;&amp; pendingBranch.transition.mode === </span><span class="s3">&quot;out-in&quot;</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(delayEnter) {</span>
          <span class="s1">activeBranch.transition.afterLeave = () =&gt; {</span>
            <span class="s2">if </span><span class="s1">(pendingId === suspense.pendingId) {</span>
              <span class="s1">move(</span>
                <span class="s1">pendingBranch</span><span class="s2">,</span>
                <span class="s1">container2</span><span class="s2">,</span>
                <span class="s1">anchor2</span><span class="s2">,</span>
                <span class="s4">0</span>
                <span class="s0">/* MoveType.ENTER */</span>
              <span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
          <span class="s1">}</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">let </span><span class="s1">{ anchor: anchor2 } = suspense</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(activeBranch) {</span>
          <span class="s1">anchor2 = next(activeBranch)</span><span class="s2">;</span>
          <span class="s1">unmount(activeBranch</span><span class="s2">, </span><span class="s1">parentComponent2</span><span class="s2">, </span><span class="s1">suspense</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(!delayEnter) {</span>
          <span class="s1">move(</span>
            <span class="s1">pendingBranch</span><span class="s2">,</span>
            <span class="s1">container2</span><span class="s2">,</span>
            <span class="s1">anchor2</span><span class="s2">,</span>
            <span class="s4">0</span>
            <span class="s0">/* MoveType.ENTER */</span>
          <span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s1">setActiveBranch(suspense</span><span class="s2">, </span><span class="s1">pendingBranch)</span><span class="s2">;</span>
      <span class="s1">suspense.pendingBranch = </span><span class="s2">null;</span>
      <span class="s1">suspense.isInFallback = </span><span class="s2">false;</span>
      <span class="s2">let </span><span class="s1">parent2 = suspense.parent</span><span class="s2">;</span>
      <span class="s2">let </span><span class="s1">hasUnresolvedAncestor = </span><span class="s2">false;</span>
      <span class="s2">while </span><span class="s1">(parent2) {</span>
        <span class="s2">if </span><span class="s1">(parent2.pendingBranch) {</span>
          <span class="s1">parent2.effects.push(...effects)</span><span class="s2">;</span>
          <span class="s1">hasUnresolvedAncestor = </span><span class="s2">true;</span>
          <span class="s2">break;</span>
        <span class="s1">}</span>
        <span class="s1">parent2 = parent2.parent</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(!hasUnresolvedAncestor) {</span>
        <span class="s1">queuePostFlushCb(effects)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s1">suspense.effects = []</span><span class="s2">;</span>
      <span class="s1">triggerEvent(vnode2</span><span class="s2">, </span><span class="s3">&quot;onResolve&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">fallback(fallbackVNode) {</span>
      <span class="s2">if </span><span class="s1">(!suspense.pendingBranch) {</span>
        <span class="s2">return;</span>
      <span class="s1">}</span>
      <span class="s2">const </span><span class="s1">{ vnode: vnode2</span><span class="s2">, </span><span class="s1">activeBranch</span><span class="s2">, </span><span class="s1">parentComponent: parentComponent2</span><span class="s2">, </span><span class="s1">container: container2</span><span class="s2">, </span><span class="s1">isSVG: isSVG2 } = suspense</span><span class="s2">;</span>
      <span class="s1">triggerEvent(vnode2</span><span class="s2">, </span><span class="s3">&quot;onFallback&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">const </span><span class="s1">anchor2 = next(activeBranch)</span><span class="s2">;</span>
      <span class="s2">const </span><span class="s1">mountFallback = () =&gt; {</span>
        <span class="s2">if </span><span class="s1">(!suspense.isInFallback) {</span>
          <span class="s2">return;</span>
        <span class="s1">}</span>
        <span class="s1">patch(</span>
          <span class="s2">null,</span>
          <span class="s1">fallbackVNode</span><span class="s2">,</span>
          <span class="s1">container2</span><span class="s2">,</span>
          <span class="s1">anchor2</span><span class="s2">,</span>
          <span class="s1">parentComponent2</span><span class="s2">,</span>
          <span class="s2">null,</span>
          <span class="s0">// fallback tree will not have suspense context</span>
          <span class="s1">isSVG2</span><span class="s2">,</span>
          <span class="s1">slotScopeIds</span><span class="s2">,</span>
          <span class="s1">optimized</span>
        <span class="s1">)</span><span class="s2">;</span>
        <span class="s1">setActiveBranch(suspense</span><span class="s2">, </span><span class="s1">fallbackVNode)</span><span class="s2">;</span>
      <span class="s1">}</span><span class="s2">;</span>
      <span class="s2">const </span><span class="s1">delayEnter = fallbackVNode.transition &amp;&amp; fallbackVNode.transition.mode === </span><span class="s3">&quot;out-in&quot;</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(delayEnter) {</span>
        <span class="s1">activeBranch.transition.afterLeave = mountFallback</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s1">suspense.isInFallback = </span><span class="s2">true;</span>
      <span class="s1">unmount(</span>
        <span class="s1">activeBranch</span><span class="s2">,</span>
        <span class="s1">parentComponent2</span><span class="s2">,</span>
        <span class="s2">null,</span>
        <span class="s0">// no suspense so unmount hooks fire now</span>
        <span class="s2">true</span>
        <span class="s0">// shouldRemove</span>
      <span class="s1">)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(!delayEnter) {</span>
        <span class="s1">mountFallback()</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">move(container2</span><span class="s2">, </span><span class="s1">anchor2</span><span class="s2">, </span><span class="s1">type) {</span>
      <span class="s1">suspense.activeBranch &amp;&amp; move(suspense.activeBranch</span><span class="s2">, </span><span class="s1">container2</span><span class="s2">, </span><span class="s1">anchor2</span><span class="s2">, </span><span class="s1">type)</span><span class="s2">;</span>
      <span class="s1">suspense.container = container2</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">next() {</span>
      <span class="s2">return </span><span class="s1">suspense.activeBranch &amp;&amp; next(suspense.activeBranch)</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">registerDep(instance</span><span class="s2">, </span><span class="s1">setupRenderEffect) {</span>
      <span class="s2">const </span><span class="s1">isInPendingSuspense = !!suspense.pendingBranch</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(isInPendingSuspense) {</span>
        <span class="s1">suspense.deps++</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">const </span><span class="s1">hydratedEl = instance.vnode.el</span><span class="s2">;</span>
      <span class="s1">instance.asyncDep.catch((err) =&gt; {</span>
        <span class="s1">handleError(</span>
          <span class="s1">err</span><span class="s2">,</span>
          <span class="s1">instance</span><span class="s2">,</span>
          <span class="s4">0</span>
          <span class="s0">/* ErrorCodes.SETUP_FUNCTION */</span>
        <span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}).then((asyncSetupResult) =&gt; {</span>
        <span class="s2">if </span><span class="s1">(instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) {</span>
          <span class="s2">return;</span>
        <span class="s1">}</span>
        <span class="s1">instance.asyncResolved = </span><span class="s2">true;</span>
        <span class="s2">const </span><span class="s1">{ vnode: vnode2 } = instance</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
          <span class="s1">pushWarningContext(vnode2)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">handleSetupResult(instance</span><span class="s2">, </span><span class="s1">asyncSetupResult</span><span class="s2">, false</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(hydratedEl) {</span>
          <span class="s1">vnode2.el = hydratedEl</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">placeholder = !hydratedEl &amp;&amp; instance.subTree.el</span><span class="s2">;</span>
        <span class="s1">setupRenderEffect(</span>
          <span class="s1">instance</span><span class="s2">,</span>
          <span class="s1">vnode2</span><span class="s2">,</span>
          <span class="s0">// component may have been moved before resolve.</span>
          <span class="s0">// if this is not a hydration, instance.subTree will be the comment</span>
          <span class="s0">// placeholder.</span>
          <span class="s1">parentNode(hydratedEl || instance.subTree.el)</span><span class="s2">,</span>
          <span class="s0">// anchor will not be used if this is hydration, so only need to</span>
          <span class="s0">// consider the comment placeholder case.</span>
          <span class="s1">hydratedEl ? </span><span class="s2">null </span><span class="s1">: next(instance.subTree)</span><span class="s2">,</span>
          <span class="s1">suspense</span><span class="s2">,</span>
          <span class="s1">isSVG</span><span class="s2">,</span>
          <span class="s1">optimized</span>
        <span class="s1">)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(placeholder) {</span>
          <span class="s1">remove2(placeholder)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">updateHOCHostEl(instance</span><span class="s2">, </span><span class="s1">vnode2.el)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
          <span class="s1">popWarningContext()</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(isInPendingSuspense &amp;&amp; --suspense.deps === </span><span class="s4">0</span><span class="s1">) {</span>
          <span class="s1">suspense.resolve()</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">unmount(parentSuspense</span><span class="s2">, </span><span class="s1">doRemove) {</span>
      <span class="s1">suspense.isUnmounted = </span><span class="s2">true;</span>
      <span class="s2">if </span><span class="s1">(suspense.activeBranch) {</span>
        <span class="s1">unmount(suspense.activeBranch</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">doRemove)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(suspense.pendingBranch) {</span>
        <span class="s1">unmount(suspense.pendingBranch</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">doRemove)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">return </span><span class="s1">suspense</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">hydrateSuspense(node</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized</span><span class="s2">, </span><span class="s1">rendererInternals</span><span class="s2">, </span><span class="s1">hydrateNode) {</span>
  <span class="s2">const </span><span class="s1">suspense = vnode.suspense = createSuspenseBoundary(</span>
    <span class="s1">vnode</span><span class="s2">,</span>
    <span class="s1">parentSuspense</span><span class="s2">,</span>
    <span class="s1">parentComponent</span><span class="s2">,</span>
    <span class="s1">node.parentNode</span><span class="s2">,</span>
    <span class="s1">document.createElement(</span><span class="s3">&quot;div&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s2">null,</span>
    <span class="s1">isSVG</span><span class="s2">,</span>
    <span class="s1">slotScopeIds</span><span class="s2">,</span>
    <span class="s1">optimized</span><span class="s2">,</span>
    <span class="s1">rendererInternals</span><span class="s2">,</span>
    <span class="s2">true</span>
    <span class="s0">/* hydrating */</span>
  <span class="s1">)</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">result = hydrateNode(node</span><span class="s2">, </span><span class="s1">suspense.pendingBranch = vnode.ssContent</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">suspense</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(suspense.deps === </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s1">suspense.resolve()</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">result</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">normalizeSuspenseChildren(vnode) {</span>
  <span class="s2">const </span><span class="s1">{ shapeFlag</span><span class="s2">, </span><span class="s1">children } = vnode</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">isSlotChildren = shapeFlag &amp; </span><span class="s4">32</span><span class="s2">;</span>
  <span class="s1">vnode.ssContent = normalizeSuspenseSlot(isSlotChildren ? children.default : children)</span><span class="s2">;</span>
  <span class="s1">vnode.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children.fallback) : createVNode(Comment)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">normalizeSuspenseSlot(s) {</span>
  <span class="s2">let </span><span class="s1">block</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(isFunction(s)) {</span>
    <span class="s2">const </span><span class="s1">trackBlock = isBlockTreeEnabled &amp;&amp; s._c</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(trackBlock) {</span>
      <span class="s1">s._d = </span><span class="s2">false;</span>
      <span class="s1">openBlock()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">s = s()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(trackBlock) {</span>
      <span class="s1">s._d = </span><span class="s2">true;</span>
      <span class="s1">block = currentBlock</span><span class="s2">;</span>
      <span class="s1">closeBlock()</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(isArray(s)) {</span>
    <span class="s2">const </span><span class="s1">singleChild = filterSingleRoot(s)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!singleChild) {</span>
      <span class="s1">warn2(</span><span class="s3">`&lt;Suspense&gt; slots expect a single root node.`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">s = singleChild</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s1">s = normalizeVNode(s)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(block &amp;&amp; !s.dynamicChildren) {</span>
    <span class="s1">s.dynamicChildren = block.filter((c) =&gt; c !== s)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">s</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">queueEffectWithSuspense(fn</span><span class="s2">, </span><span class="s1">suspense) {</span>
  <span class="s2">if </span><span class="s1">(suspense &amp;&amp; suspense.pendingBranch) {</span>
    <span class="s2">if </span><span class="s1">(isArray(fn)) {</span>
      <span class="s1">suspense.effects.push(...fn)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">suspense.effects.push(fn)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s1">queuePostFlushCb(fn)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">setActiveBranch(suspense</span><span class="s2">, </span><span class="s1">branch) {</span>
  <span class="s1">suspense.activeBranch = branch</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">{ vnode</span><span class="s2">, </span><span class="s1">parentComponent } = suspense</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">el = vnode.el = branch.el</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(parentComponent &amp;&amp; parentComponent.subTree === vnode) {</span>
    <span class="s1">parentComponent.vnode.el = el</span><span class="s2">;</span>
    <span class="s1">updateHOCHostEl(parentComponent</span><span class="s2">, </span><span class="s1">el)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">provide(key</span><span class="s2">, </span><span class="s1">value) {</span>
  <span class="s2">if </span><span class="s1">(!currentInstance) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
      <span class="s1">warn2(</span><span class="s3">`provide() can only be used inside setup().`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s2">let </span><span class="s1">provides = currentInstance.provides</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">parentProvides = currentInstance.parent &amp;&amp; currentInstance.parent.provides</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(parentProvides === provides) {</span>
      <span class="s1">provides = currentInstance.provides = Object.create(parentProvides)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">provides[key] = value</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">inject(key</span><span class="s2">, </span><span class="s1">defaultValue</span><span class="s2">, </span><span class="s1">treatDefaultAsFactory = </span><span class="s2">false</span><span class="s1">) {</span>
  <span class="s2">const </span><span class="s1">instance = currentInstance || currentRenderingInstance</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(instance) {</span>
    <span class="s2">const </span><span class="s1">provides = instance.parent == </span><span class="s2">null </span><span class="s1">? instance.vnode.appContext &amp;&amp; instance.vnode.appContext.provides : instance.parent.provides</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(provides &amp;&amp; key </span><span class="s2">in </span><span class="s1">provides) {</span>
      <span class="s2">return </span><span class="s1">provides[key]</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(arguments.length &gt; </span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s1">treatDefaultAsFactory &amp;&amp; isFunction(defaultValue) ? defaultValue.call(instance.proxy) : defaultValue</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
      <span class="s1">warn2(</span><span class="s3">`injection &quot;</span><span class="s1">${String(key)}</span><span class="s3">&quot; not found.`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s1">warn2(</span><span class="s3">`inject() can only be used inside setup() or functional components.`</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">watchEffect(effect2</span><span class="s2">, </span><span class="s1">options) {</span>
  <span class="s2">return </span><span class="s1">doWatch(effect2</span><span class="s2">, null, </span><span class="s1">options)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">watchPostEffect(effect2</span><span class="s2">, </span><span class="s1">options) {</span>
  <span class="s2">return </span><span class="s1">doWatch(effect2</span><span class="s2">, null, true </span><span class="s1">? Object.assign(Object.assign({}</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">, </span><span class="s1">{ flush: </span><span class="s3">&quot;post&quot; </span><span class="s1">}) : { flush: </span><span class="s3">&quot;post&quot; </span><span class="s1">})</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">watchSyncEffect(effect2</span><span class="s2">, </span><span class="s1">options) {</span>
  <span class="s2">return </span><span class="s1">doWatch(effect2</span><span class="s2">, null, true </span><span class="s1">? Object.assign(Object.assign({}</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">, </span><span class="s1">{ flush: </span><span class="s3">&quot;sync&quot; </span><span class="s1">}) : { flush: </span><span class="s3">&quot;sync&quot; </span><span class="s1">})</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">INITIAL_WATCHER_VALUE = {}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">watch(source</span><span class="s2">, </span><span class="s1">cb</span><span class="s2">, </span><span class="s1">options) {</span>
  <span class="s2">if </span><span class="s1">(!isFunction(cb)) {</span>
    <span class="s1">warn2(</span><span class="s3">`</span><span class="s2">\`</span><span class="s3">watch(fn, options?)</span><span class="s2">\` </span><span class="s3">signature has been moved to a separate API. Use </span><span class="s2">\`</span><span class="s3">watchEffect(fn, options?)</span><span class="s2">\` </span><span class="s3">instead. </span><span class="s2">\`</span><span class="s3">watch</span><span class="s2">\` </span><span class="s3">now only supports </span><span class="s2">\`</span><span class="s3">watch(source, cb, options?) signature.`</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">doWatch(source</span><span class="s2">, </span><span class="s1">cb</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">doWatch(source</span><span class="s2">, </span><span class="s1">cb</span><span class="s2">, </span><span class="s1">{ immediate</span><span class="s2">, </span><span class="s1">deep</span><span class="s2">, </span><span class="s1">flush</span><span class="s2">, </span><span class="s1">onTrack</span><span class="s2">, </span><span class="s1">onTrigger } = EMPTY_OBJ) {</span>
  <span class="s2">if </span><span class="s1">(!cb) {</span>
    <span class="s2">if </span><span class="s1">(immediate !== </span><span class="s2">void </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s1">warn2(</span><span class="s3">`watch() &quot;immediate&quot; option is only respected when using the watch(source, callback, options?) signature.`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(deep !== </span><span class="s2">void </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s1">warn2(</span><span class="s3">`watch() &quot;deep&quot; option is only respected when using the watch(source, callback, options?) signature.`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">const </span><span class="s1">warnInvalidSource = (s) =&gt; {</span>
    <span class="s1">warn2(</span><span class="s3">`Invalid watch source: `</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s3">`A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">instance = getCurrentScope() === (currentInstance === </span><span class="s2">null </span><span class="s1">|| currentInstance === </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: currentInstance.scope) ? currentInstance : </span><span class="s2">null;</span>
  <span class="s2">let </span><span class="s1">getter</span><span class="s2">;</span>
  <span class="s2">let </span><span class="s1">forceTrigger = </span><span class="s2">false;</span>
  <span class="s2">let </span><span class="s1">isMultiSource = </span><span class="s2">false;</span>
  <span class="s2">if </span><span class="s1">(isRef(source)) {</span>
    <span class="s1">getter = () =&gt; source.value</span><span class="s2">;</span>
    <span class="s1">forceTrigger = isShallow(source)</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isReactive(source)) {</span>
    <span class="s1">getter = () =&gt; source</span><span class="s2">;</span>
    <span class="s1">deep = </span><span class="s2">true;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isArray(source)) {</span>
    <span class="s1">isMultiSource = </span><span class="s2">true;</span>
    <span class="s1">forceTrigger = source.some((s) =&gt; isReactive(s) || isShallow(s))</span><span class="s2">;</span>
    <span class="s1">getter = () =&gt; source.map((s) =&gt; {</span>
      <span class="s2">if </span><span class="s1">(isRef(s)) {</span>
        <span class="s2">return </span><span class="s1">s.value</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isReactive(s)) {</span>
        <span class="s2">return </span><span class="s1">traverse(s)</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isFunction(s)) {</span>
        <span class="s2">return </span><span class="s1">callWithErrorHandling(</span>
          <span class="s1">s</span><span class="s2">,</span>
          <span class="s1">instance</span><span class="s2">,</span>
          <span class="s4">2</span>
          <span class="s0">/* ErrorCodes.WATCH_GETTER */</span>
        <span class="s1">)</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">warnInvalidSource(s)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">})</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isFunction(source)) {</span>
    <span class="s2">if </span><span class="s1">(cb) {</span>
      <span class="s1">getter = () =&gt; callWithErrorHandling(</span>
        <span class="s1">source</span><span class="s2">,</span>
        <span class="s1">instance</span><span class="s2">,</span>
        <span class="s4">2</span>
        <span class="s0">/* ErrorCodes.WATCH_GETTER */</span>
      <span class="s1">)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">getter = () =&gt; {</span>
        <span class="s2">if </span><span class="s1">(instance &amp;&amp; instance.isUnmounted) {</span>
          <span class="s2">return;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(cleanup) {</span>
          <span class="s1">cleanup()</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">callWithAsyncErrorHandling(source</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s1">[onCleanup])</span><span class="s2">;</span>
      <span class="s1">}</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s1">getter = NOOP</span><span class="s2">;</span>
    <span class="s1">warnInvalidSource(source)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(cb &amp;&amp; deep) {</span>
    <span class="s2">const </span><span class="s1">baseGetter = getter</span><span class="s2">;</span>
    <span class="s1">getter = () =&gt; traverse(baseGetter())</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">let </span><span class="s1">cleanup</span><span class="s2">;</span>
  <span class="s2">let </span><span class="s1">onCleanup = (fn) =&gt; {</span>
    <span class="s1">cleanup = effect2.onStop = () =&gt; {</span>
      <span class="s1">callWithErrorHandling(</span>
        <span class="s1">fn</span><span class="s2">,</span>
        <span class="s1">instance</span><span class="s2">,</span>
        <span class="s4">4</span>
        <span class="s0">/* ErrorCodes.WATCH_CLEANUP */</span>
      <span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">let </span><span class="s1">ssrCleanup</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(isInSSRComponentSetup) {</span>
    <span class="s1">onCleanup = NOOP</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!cb) {</span>
      <span class="s1">getter()</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(immediate) {</span>
      <span class="s1">callWithAsyncErrorHandling(cb</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s1">[</span>
        <span class="s1">getter()</span><span class="s2">,</span>
        <span class="s1">isMultiSource ? [] : </span><span class="s2">void </span><span class="s4">0</span><span class="s2">,</span>
        <span class="s1">onCleanup</span>
      <span class="s1">])</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(flush === </span><span class="s3">&quot;sync&quot;</span><span class="s1">) {</span>
      <span class="s2">const </span><span class="s1">ctx = useSSRContext()</span><span class="s2">;</span>
      <span class="s1">ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = [])</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">return </span><span class="s1">NOOP</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">let </span><span class="s1">oldValue = isMultiSource ? </span><span class="s2">new </span><span class="s1">Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">job = () =&gt; {</span>
    <span class="s2">if </span><span class="s1">(!effect2.active) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(cb) {</span>
      <span class="s2">const </span><span class="s1">newValue = effect2.run()</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(deep || forceTrigger || (isMultiSource ? newValue.some((v</span><span class="s2">, </span><span class="s1">i) =&gt; hasChanged(v</span><span class="s2">, </span><span class="s1">oldValue[i])) : hasChanged(newValue</span><span class="s2">, </span><span class="s1">oldValue)) || </span><span class="s2">false</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(cleanup) {</span>
          <span class="s1">cleanup()</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">callWithAsyncErrorHandling(cb</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s1">[</span>
          <span class="s1">newValue</span><span class="s2">,</span>
          <span class="s0">// pass undefined as the old value when it's changed for the first time</span>
          <span class="s1">oldValue === INITIAL_WATCHER_VALUE ? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: isMultiSource &amp;&amp; oldValue[</span><span class="s4">0</span><span class="s1">] === INITIAL_WATCHER_VALUE ? [] : oldValue</span><span class="s2">,</span>
          <span class="s1">onCleanup</span>
        <span class="s1">])</span><span class="s2">;</span>
        <span class="s1">oldValue = newValue</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">effect2.run()</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s1">job.allowRecurse = !!cb</span><span class="s2">;</span>
  <span class="s2">let </span><span class="s1">scheduler</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(flush === </span><span class="s3">&quot;sync&quot;</span><span class="s1">) {</span>
    <span class="s1">scheduler = job</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(flush === </span><span class="s3">&quot;post&quot;</span><span class="s1">) {</span>
    <span class="s1">scheduler = () =&gt; queuePostRenderEffect(job</span><span class="s2">, </span><span class="s1">instance &amp;&amp; instance.suspense)</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s1">job.pre = </span><span class="s2">true;</span>
    <span class="s2">if </span><span class="s1">(instance)</span>
      <span class="s1">job.id = instance.uid</span><span class="s2">;</span>
    <span class="s1">scheduler = () =&gt; queueJob(job)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">const </span><span class="s1">effect2 = </span><span class="s2">new </span><span class="s1">ReactiveEffect(getter</span><span class="s2">, </span><span class="s1">scheduler)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s1">effect2.onTrack = onTrack</span><span class="s2">;</span>
    <span class="s1">effect2.onTrigger = onTrigger</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(cb) {</span>
    <span class="s2">if </span><span class="s1">(immediate) {</span>
      <span class="s1">job()</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">oldValue = effect2.run()</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(flush === </span><span class="s3">&quot;post&quot;</span><span class="s1">) {</span>
    <span class="s1">queuePostRenderEffect(effect2.run.bind(effect2)</span><span class="s2">, </span><span class="s1">instance &amp;&amp; instance.suspense)</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s1">effect2.run()</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">const </span><span class="s1">unwatch = () =&gt; {</span>
    <span class="s1">effect2.stop()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(instance &amp;&amp; instance.scope) {</span>
      <span class="s1">remove(instance.scope.effects</span><span class="s2">, </span><span class="s1">effect2)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(ssrCleanup)</span>
    <span class="s1">ssrCleanup.push(unwatch)</span><span class="s2">;</span>
  <span class="s2">return </span><span class="s1">unwatch</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">instanceWatch(source</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">options) {</span>
  <span class="s2">const </span><span class="s1">publicThis = </span><span class="s2">this</span><span class="s1">.proxy</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">getter = isString(source) ? source.includes(</span><span class="s3">&quot;.&quot;</span><span class="s1">) ? createPathGetter(publicThis</span><span class="s2">, </span><span class="s1">source) : () =&gt; publicThis[source] : source.bind(publicThis</span><span class="s2">, </span><span class="s1">publicThis)</span><span class="s2">;</span>
  <span class="s2">let </span><span class="s1">cb</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(isFunction(value)) {</span>
    <span class="s1">cb = value</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s1">cb = value.handler</span><span class="s2">;</span>
    <span class="s1">options = value</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">const </span><span class="s1">cur = currentInstance</span><span class="s2">;</span>
  <span class="s1">setCurrentInstance(</span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">res = doWatch(getter</span><span class="s2">, </span><span class="s1">cb.bind(publicThis)</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(cur) {</span>
    <span class="s1">setCurrentInstance(cur)</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s1">unsetCurrentInstance()</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">res</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createPathGetter(ctx</span><span class="s2">, </span><span class="s1">path) {</span>
  <span class="s2">const </span><span class="s1">segments = path.split(</span><span class="s3">&quot;.&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s2">return </span><span class="s1">() =&gt; {</span>
    <span class="s2">let </span><span class="s1">cur = ctx</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; segments.length &amp;&amp; cur</span><span class="s2">; </span><span class="s1">i++) {</span>
      <span class="s1">cur = cur[segments[i]]</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">cur</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">traverse(value</span><span class="s2">, </span><span class="s1">seen) {</span>
  <span class="s2">if </span><span class="s1">(!isObject(value) || value[</span>
    <span class="s3">&quot;__v_skip&quot;</span>
    <span class="s0">/* ReactiveFlags.SKIP */</span>
  <span class="s1">]) {</span>
    <span class="s2">return </span><span class="s1">value</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s1">seen = seen || </span><span class="s0">/* @__PURE__ */ </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(seen.has(value)) {</span>
    <span class="s2">return </span><span class="s1">value</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s1">seen.add(value)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(isRef(value)) {</span>
    <span class="s1">traverse(value.value</span><span class="s2">, </span><span class="s1">seen)</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isArray(value)) {</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; value.length</span><span class="s2">; </span><span class="s1">i++) {</span>
      <span class="s1">traverse(value[i]</span><span class="s2">, </span><span class="s1">seen)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isSet(value) || isMap(value)) {</span>
    <span class="s1">value.forEach((v) =&gt; {</span>
      <span class="s1">traverse(v</span><span class="s2">, </span><span class="s1">seen)</span><span class="s2">;</span>
    <span class="s1">})</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isPlainObject(value)) {</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">value) {</span>
      <span class="s1">traverse(value[key]</span><span class="s2">, </span><span class="s1">seen)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">value</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">useTransitionState() {</span>
  <span class="s2">const </span><span class="s1">state = {</span>
    <span class="s1">isMounted: </span><span class="s2">false,</span>
    <span class="s1">isLeaving: </span><span class="s2">false,</span>
    <span class="s1">isUnmounting: </span><span class="s2">false,</span>
    <span class="s1">leavingVNodes: </span><span class="s0">/* @__PURE__ */ </span><span class="s2">new </span><span class="s1">Map()</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s1">onMounted(() =&gt; {</span>
    <span class="s1">state.isMounted = </span><span class="s2">true;</span>
  <span class="s1">})</span><span class="s2">;</span>
  <span class="s1">onBeforeUnmount(() =&gt; {</span>
    <span class="s1">state.isUnmounting = </span><span class="s2">true;</span>
  <span class="s1">})</span><span class="s2">;</span>
  <span class="s2">return </span><span class="s1">state</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">TransitionHookValidator = [Function</span><span class="s2">, </span><span class="s1">Array]</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">BaseTransitionImpl = {</span>
  <span class="s1">name: </span><span class="s3">`BaseTransition`</span><span class="s2">,</span>
  <span class="s1">props: {</span>
    <span class="s1">mode: String</span><span class="s2">,</span>
    <span class="s1">appear: Boolean</span><span class="s2">,</span>
    <span class="s1">persisted: Boolean</span><span class="s2">,</span>
    <span class="s0">// enter</span>
    <span class="s1">onBeforeEnter: TransitionHookValidator</span><span class="s2">,</span>
    <span class="s1">onEnter: TransitionHookValidator</span><span class="s2">,</span>
    <span class="s1">onAfterEnter: TransitionHookValidator</span><span class="s2">,</span>
    <span class="s1">onEnterCancelled: TransitionHookValidator</span><span class="s2">,</span>
    <span class="s0">// leave</span>
    <span class="s1">onBeforeLeave: TransitionHookValidator</span><span class="s2">,</span>
    <span class="s1">onLeave: TransitionHookValidator</span><span class="s2">,</span>
    <span class="s1">onAfterLeave: TransitionHookValidator</span><span class="s2">,</span>
    <span class="s1">onLeaveCancelled: TransitionHookValidator</span><span class="s2">,</span>
    <span class="s0">// appear</span>
    <span class="s1">onBeforeAppear: TransitionHookValidator</span><span class="s2">,</span>
    <span class="s1">onAppear: TransitionHookValidator</span><span class="s2">,</span>
    <span class="s1">onAfterAppear: TransitionHookValidator</span><span class="s2">,</span>
    <span class="s1">onAppearCancelled: TransitionHookValidator</span>
  <span class="s1">}</span><span class="s2">,</span>
  <span class="s1">setup(props</span><span class="s2">, </span><span class="s1">{ slots }) {</span>
    <span class="s2">const </span><span class="s1">instance = getCurrentInstance()</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">state = useTransitionState()</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">prevTransitionKey</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">() =&gt; {</span>
      <span class="s2">const </span><span class="s1">children = slots.default &amp;&amp; getTransitionRawChildren(slots.default()</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(!children || !children.length) {</span>
        <span class="s2">return;</span>
      <span class="s1">}</span>
      <span class="s2">let </span><span class="s1">child = children[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(children.length &gt; </span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s2">let </span><span class="s1">hasFound = </span><span class="s2">false;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">c of children) {</span>
          <span class="s2">if </span><span class="s1">(c.type !== Comment) {</span>
            <span class="s2">if </span><span class="s1">(hasFound) {</span>
              <span class="s1">warn2(</span><span class="s3">&quot;&lt;transition&gt; can only be used on a single element or component. Use &lt;transition-group&gt; for lists.&quot;</span><span class="s1">)</span><span class="s2">;</span>
              <span class="s2">break;</span>
            <span class="s1">}</span>
            <span class="s1">child = c</span><span class="s2">;</span>
            <span class="s1">hasFound = </span><span class="s2">true;</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">false</span><span class="s1">)</span>
              <span class="s2">break;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">const </span><span class="s1">rawProps = toRaw(props)</span><span class="s2">;</span>
      <span class="s2">const </span><span class="s1">{ mode } = rawProps</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(mode &amp;&amp; mode !== </span><span class="s3">&quot;in-out&quot; </span><span class="s1">&amp;&amp; mode !== </span><span class="s3">&quot;out-in&quot; </span><span class="s1">&amp;&amp; mode !== </span><span class="s3">&quot;default&quot;</span><span class="s1">) {</span>
        <span class="s1">warn2(</span><span class="s3">`invalid &lt;transition&gt; mode: </span><span class="s1">${mode}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(state.isLeaving) {</span>
        <span class="s2">return </span><span class="s1">emptyPlaceholder(child)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">const </span><span class="s1">innerChild = getKeepAliveChild(child)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(!innerChild) {</span>
        <span class="s2">return </span><span class="s1">emptyPlaceholder(child)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">const </span><span class="s1">enterHooks = resolveTransitionHooks(innerChild</span><span class="s2">, </span><span class="s1">rawProps</span><span class="s2">, </span><span class="s1">state</span><span class="s2">, </span><span class="s1">instance)</span><span class="s2">;</span>
      <span class="s1">setTransitionHooks(innerChild</span><span class="s2">, </span><span class="s1">enterHooks)</span><span class="s2">;</span>
      <span class="s2">const </span><span class="s1">oldChild = instance.subTree</span><span class="s2">;</span>
      <span class="s2">const </span><span class="s1">oldInnerChild = oldChild &amp;&amp; getKeepAliveChild(oldChild)</span><span class="s2">;</span>
      <span class="s2">let </span><span class="s1">transitionKeyChanged = </span><span class="s2">false;</span>
      <span class="s2">const </span><span class="s1">{ getTransitionKey } = innerChild.type</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(getTransitionKey) {</span>
        <span class="s2">const </span><span class="s1">key = getTransitionKey()</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(prevTransitionKey === </span><span class="s2">void </span><span class="s4">0</span><span class="s1">) {</span>
          <span class="s1">prevTransitionKey = key</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(key !== prevTransitionKey) {</span>
          <span class="s1">prevTransitionKey = key</span><span class="s2">;</span>
          <span class="s1">transitionKeyChanged = </span><span class="s2">true;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(oldInnerChild &amp;&amp; oldInnerChild.type !== Comment &amp;&amp; (!isSameVNodeType(innerChild</span><span class="s2">, </span><span class="s1">oldInnerChild) || transitionKeyChanged)) {</span>
        <span class="s2">const </span><span class="s1">leavingHooks = resolveTransitionHooks(oldInnerChild</span><span class="s2">, </span><span class="s1">rawProps</span><span class="s2">, </span><span class="s1">state</span><span class="s2">, </span><span class="s1">instance)</span><span class="s2">;</span>
        <span class="s1">setTransitionHooks(oldInnerChild</span><span class="s2">, </span><span class="s1">leavingHooks)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(mode === </span><span class="s3">&quot;out-in&quot;</span><span class="s1">) {</span>
          <span class="s1">state.isLeaving = </span><span class="s2">true;</span>
          <span class="s1">leavingHooks.afterLeave = () =&gt; {</span>
            <span class="s1">state.isLeaving = </span><span class="s2">false;</span>
            <span class="s2">if </span><span class="s1">(instance.update.active !== </span><span class="s2">false</span><span class="s1">) {</span>
              <span class="s1">instance.update()</span><span class="s2">;</span>
            <span class="s1">}</span>
          <span class="s1">}</span><span class="s2">;</span>
          <span class="s2">return </span><span class="s1">emptyPlaceholder(child)</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(mode === </span><span class="s3">&quot;in-out&quot; </span><span class="s1">&amp;&amp; innerChild.type !== Comment) {</span>
          <span class="s1">leavingHooks.delayLeave = (el</span><span class="s2">, </span><span class="s1">earlyRemove</span><span class="s2">, </span><span class="s1">delayedLeave) =&gt; {</span>
            <span class="s2">const </span><span class="s1">leavingVNodesCache = getLeavingNodesForType(state</span><span class="s2">, </span><span class="s1">oldInnerChild)</span><span class="s2">;</span>
            <span class="s1">leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild</span><span class="s2">;</span>
            <span class="s1">el._leaveCb = () =&gt; {</span>
              <span class="s1">earlyRemove()</span><span class="s2">;</span>
              <span class="s1">el._leaveCb = </span><span class="s2">void </span><span class="s4">0</span><span class="s2">;</span>
              <span class="s2">delete </span><span class="s1">enterHooks.delayedLeave</span><span class="s2">;</span>
            <span class="s1">}</span><span class="s2">;</span>
            <span class="s1">enterHooks.delayedLeave = delayedLeave</span><span class="s2">;</span>
          <span class="s1">}</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">child</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">BaseTransition = BaseTransitionImpl</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">getLeavingNodesForType(state</span><span class="s2">, </span><span class="s1">vnode) {</span>
  <span class="s2">const </span><span class="s1">{ leavingVNodes } = state</span><span class="s2">;</span>
  <span class="s2">let </span><span class="s1">leavingVNodesCache = leavingVNodes.get(vnode.type)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(!leavingVNodesCache) {</span>
    <span class="s1">leavingVNodesCache = </span><span class="s0">/* @__PURE__ */ </span><span class="s1">Object.create(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">leavingVNodes.set(vnode.type</span><span class="s2">, </span><span class="s1">leavingVNodesCache)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">leavingVNodesCache</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">resolveTransitionHooks(vnode</span><span class="s2">, </span><span class="s1">props</span><span class="s2">, </span><span class="s1">state</span><span class="s2">, </span><span class="s1">instance) {</span>
  <span class="s2">const </span><span class="s1">{ appear</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">, </span><span class="s1">persisted = </span><span class="s2">false, </span><span class="s1">onBeforeEnter</span><span class="s2">, </span><span class="s1">onEnter</span><span class="s2">, </span><span class="s1">onAfterEnter</span><span class="s2">, </span><span class="s1">onEnterCancelled</span><span class="s2">, </span><span class="s1">onBeforeLeave</span><span class="s2">, </span><span class="s1">onLeave</span><span class="s2">, </span><span class="s1">onAfterLeave</span><span class="s2">, </span><span class="s1">onLeaveCancelled</span><span class="s2">, </span><span class="s1">onBeforeAppear</span><span class="s2">, </span><span class="s1">onAppear</span><span class="s2">, </span><span class="s1">onAfterAppear</span><span class="s2">, </span><span class="s1">onAppearCancelled } = props</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">key = String(vnode.key)</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">leavingVNodesCache = getLeavingNodesForType(state</span><span class="s2">, </span><span class="s1">vnode)</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">callHook3 = (hook</span><span class="s2">, </span><span class="s1">args) =&gt; {</span>
    <span class="s1">hook &amp;&amp; callWithAsyncErrorHandling(hook</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s1">args)</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">callAsyncHook = (hook</span><span class="s2">, </span><span class="s1">args) =&gt; {</span>
    <span class="s2">const </span><span class="s1">done = args[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">;</span>
    <span class="s1">callHook3(hook</span><span class="s2">, </span><span class="s1">args)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(isArray(hook)) {</span>
      <span class="s2">if </span><span class="s1">(hook.every((hook2) =&gt; hook2.length &lt;= </span><span class="s4">1</span><span class="s1">))</span>
        <span class="s1">done()</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(hook.length &lt;= </span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s1">done()</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">hooks = {</span>
    <span class="s1">mode</span><span class="s2">,</span>
    <span class="s1">persisted</span><span class="s2">,</span>
    <span class="s1">beforeEnter(el) {</span>
      <span class="s2">let </span><span class="s1">hook = onBeforeEnter</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(!state.isMounted) {</span>
        <span class="s2">if </span><span class="s1">(appear) {</span>
          <span class="s1">hook = onBeforeAppear || onBeforeEnter</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s2">return;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(el._leaveCb) {</span>
        <span class="s1">el._leaveCb(</span>
          <span class="s2">true</span>
          <span class="s0">/* cancelled */</span>
        <span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">const </span><span class="s1">leavingVNode = leavingVNodesCache[key]</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(leavingVNode &amp;&amp; isSameVNodeType(vnode</span><span class="s2">, </span><span class="s1">leavingVNode) &amp;&amp; leavingVNode.el._leaveCb) {</span>
        <span class="s1">leavingVNode.el._leaveCb()</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s1">callHook3(hook</span><span class="s2">, </span><span class="s1">[el])</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">enter(el) {</span>
      <span class="s2">let </span><span class="s1">hook = onEnter</span><span class="s2">;</span>
      <span class="s2">let </span><span class="s1">afterHook = onAfterEnter</span><span class="s2">;</span>
      <span class="s2">let </span><span class="s1">cancelHook = onEnterCancelled</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(!state.isMounted) {</span>
        <span class="s2">if </span><span class="s1">(appear) {</span>
          <span class="s1">hook = onAppear || onEnter</span><span class="s2">;</span>
          <span class="s1">afterHook = onAfterAppear || onAfterEnter</span><span class="s2">;</span>
          <span class="s1">cancelHook = onAppearCancelled || onEnterCancelled</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s2">return;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">let </span><span class="s1">called = </span><span class="s2">false;</span>
      <span class="s2">const </span><span class="s1">done = el._enterCb = (cancelled) =&gt; {</span>
        <span class="s2">if </span><span class="s1">(called)</span>
          <span class="s2">return;</span>
        <span class="s1">called = </span><span class="s2">true;</span>
        <span class="s2">if </span><span class="s1">(cancelled) {</span>
          <span class="s1">callHook3(cancelHook</span><span class="s2">, </span><span class="s1">[el])</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">callHook3(afterHook</span><span class="s2">, </span><span class="s1">[el])</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(hooks.delayedLeave) {</span>
          <span class="s1">hooks.delayedLeave()</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">el._enterCb = </span><span class="s2">void </span><span class="s4">0</span><span class="s2">;</span>
      <span class="s1">}</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(hook) {</span>
        <span class="s1">callAsyncHook(hook</span><span class="s2">, </span><span class="s1">[el</span><span class="s2">, </span><span class="s1">done])</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">done()</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">leave(el</span><span class="s2">, </span><span class="s1">remove2) {</span>
      <span class="s2">const </span><span class="s1">key2 = String(vnode.key)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(el._enterCb) {</span>
        <span class="s1">el._enterCb(</span>
          <span class="s2">true</span>
          <span class="s0">/* cancelled */</span>
        <span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(state.isUnmounting) {</span>
        <span class="s2">return </span><span class="s1">remove2()</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s1">callHook3(onBeforeLeave</span><span class="s2">, </span><span class="s1">[el])</span><span class="s2">;</span>
      <span class="s2">let </span><span class="s1">called = </span><span class="s2">false;</span>
      <span class="s2">const </span><span class="s1">done = el._leaveCb = (cancelled) =&gt; {</span>
        <span class="s2">if </span><span class="s1">(called)</span>
          <span class="s2">return;</span>
        <span class="s1">called = </span><span class="s2">true;</span>
        <span class="s1">remove2()</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(cancelled) {</span>
          <span class="s1">callHook3(onLeaveCancelled</span><span class="s2">, </span><span class="s1">[el])</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">callHook3(onAfterLeave</span><span class="s2">, </span><span class="s1">[el])</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">el._leaveCb = </span><span class="s2">void </span><span class="s4">0</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(leavingVNodesCache[key2] === vnode) {</span>
          <span class="s2">delete </span><span class="s1">leavingVNodesCache[key2]</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span><span class="s2">;</span>
      <span class="s1">leavingVNodesCache[key2] = vnode</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(onLeave) {</span>
        <span class="s1">callAsyncHook(onLeave</span><span class="s2">, </span><span class="s1">[el</span><span class="s2">, </span><span class="s1">done])</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">done()</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">clone(vnode2) {</span>
      <span class="s2">return </span><span class="s1">resolveTransitionHooks(vnode2</span><span class="s2">, </span><span class="s1">props</span><span class="s2">, </span><span class="s1">state</span><span class="s2">, </span><span class="s1">instance)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">return </span><span class="s1">hooks</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">emptyPlaceholder(vnode) {</span>
  <span class="s2">if </span><span class="s1">(isKeepAlive(vnode)) {</span>
    <span class="s1">vnode = cloneVNode(vnode)</span><span class="s2">;</span>
    <span class="s1">vnode.children = </span><span class="s2">null;</span>
    <span class="s2">return </span><span class="s1">vnode</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getKeepAliveChild(vnode) {</span>
  <span class="s2">return </span><span class="s1">isKeepAlive(vnode) ? vnode.children ? vnode.children[</span><span class="s4">0</span><span class="s1">] : </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: vnode</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">setTransitionHooks(vnode</span><span class="s2">, </span><span class="s1">hooks) {</span>
  <span class="s2">if </span><span class="s1">(vnode.shapeFlag &amp; </span><span class="s4">6 </span><span class="s1">&amp;&amp; vnode.component) {</span>
    <span class="s1">setTransitionHooks(vnode.component.subTree</span><span class="s2">, </span><span class="s1">hooks)</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(vnode.shapeFlag &amp; </span><span class="s4">128</span><span class="s1">) {</span>
    <span class="s1">vnode.ssContent.transition = hooks.clone(vnode.ssContent)</span><span class="s2">;</span>
    <span class="s1">vnode.ssFallback.transition = hooks.clone(vnode.ssFallback)</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s1">vnode.transition = hooks</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getTransitionRawChildren(children</span><span class="s2">, </span><span class="s1">keepComment = </span><span class="s2">false, </span><span class="s1">parentKey) {</span>
  <span class="s2">let </span><span class="s1">ret = []</span><span class="s2">;</span>
  <span class="s2">let </span><span class="s1">keyedFragmentCount = </span><span class="s4">0</span><span class="s2">;</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; children.length</span><span class="s2">; </span><span class="s1">i++) {</span>
    <span class="s2">let </span><span class="s1">child = children[i]</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">key = parentKey == </span><span class="s2">null </span><span class="s1">? child.key : String(parentKey) + String(child.key != </span><span class="s2">null </span><span class="s1">? child.key : i)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(child.type === Fragment) {</span>
      <span class="s2">if </span><span class="s1">(child.patchFlag &amp; </span><span class="s4">128</span><span class="s1">)</span>
        <span class="s1">keyedFragmentCount++</span><span class="s2">;</span>
      <span class="s1">ret = ret.concat(getTransitionRawChildren(child.children</span><span class="s2">, </span><span class="s1">keepComment</span><span class="s2">, </span><span class="s1">key))</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(keepComment || child.type !== Comment) {</span>
      <span class="s1">ret.push(key != </span><span class="s2">null </span><span class="s1">? cloneVNode(child</span><span class="s2">, </span><span class="s1">{ key }) : child)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(keyedFragmentCount &gt; </span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; ret.length</span><span class="s2">; </span><span class="s1">i++) {</span>
      <span class="s1">ret[i].patchFlag = -</span><span class="s4">2</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">ret</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">defineComponent(options) {</span>
  <span class="s2">return </span><span class="s1">isFunction(options) ? { setup: options</span><span class="s2">, </span><span class="s1">name: options.name } : options</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">isAsyncWrapper = (i) =&gt; !!i.type.__asyncLoader</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">defineAsyncComponent(source) {</span>
  <span class="s2">if </span><span class="s1">(isFunction(source)) {</span>
    <span class="s1">source = { loader: source }</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">const </span><span class="s1">{</span>
    <span class="s1">loader</span><span class="s2">,</span>
    <span class="s1">loadingComponent</span><span class="s2">,</span>
    <span class="s1">errorComponent</span><span class="s2">,</span>
    <span class="s1">delay = </span><span class="s4">200</span><span class="s2">,</span>
    <span class="s1">timeout</span><span class="s2">,</span>
    <span class="s0">// undefined = never times out</span>
    <span class="s1">suspensible = </span><span class="s2">true,</span>
    <span class="s1">onError: userOnError</span>
  <span class="s1">} = source</span><span class="s2">;</span>
  <span class="s2">let </span><span class="s1">pendingRequest = </span><span class="s2">null;</span>
  <span class="s2">let </span><span class="s1">resolvedComp</span><span class="s2">;</span>
  <span class="s2">let </span><span class="s1">retries = </span><span class="s4">0</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">retry = () =&gt; {</span>
    <span class="s1">retries++</span><span class="s2">;</span>
    <span class="s1">pendingRequest = </span><span class="s2">null;</span>
    <span class="s2">return </span><span class="s1">load()</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">load = () =&gt; {</span>
    <span class="s2">let </span><span class="s1">thisRequest</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">pendingRequest || (thisRequest = pendingRequest = loader().catch((err) =&gt; {</span>
      <span class="s1">err = err </span><span class="s2">instanceof </span><span class="s1">Error ? err : </span><span class="s2">new </span><span class="s1">Error(String(err))</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(userOnError) {</span>
        <span class="s2">return new </span><span class="s1">Promise((resolve2</span><span class="s2">, </span><span class="s1">reject) =&gt; {</span>
          <span class="s2">const </span><span class="s1">userRetry = () =&gt; resolve2(retry())</span><span class="s2">;</span>
          <span class="s2">const </span><span class="s1">userFail = () =&gt; reject(err)</span><span class="s2">;</span>
          <span class="s1">userOnError(err</span><span class="s2">, </span><span class="s1">userRetry</span><span class="s2">, </span><span class="s1">userFail</span><span class="s2">, </span><span class="s1">retries + </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">})</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">throw </span><span class="s1">err</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}).then((comp) =&gt; {</span>
      <span class="s2">if </span><span class="s1">(thisRequest !== pendingRequest &amp;&amp; pendingRequest) {</span>
        <span class="s2">return </span><span class="s1">pendingRequest</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(!comp) {</span>
        <span class="s1">warn2(</span><span class="s3">`Async component loader resolved to undefined. If you are using retry(), make sure to return its return value.`</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(comp &amp;&amp; (comp.__esModule || comp[Symbol.toStringTag] === </span><span class="s3">&quot;Module&quot;</span><span class="s1">)) {</span>
        <span class="s1">comp = comp.default</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(comp &amp;&amp; !isObject(comp) &amp;&amp; !isFunction(comp)) {</span>
        <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">`Invalid async component load result: </span><span class="s1">${comp}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s1">resolvedComp = comp</span><span class="s2">;</span>
      <span class="s2">return </span><span class="s1">comp</span><span class="s2">;</span>
    <span class="s1">}))</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">return </span><span class="s1">defineComponent({</span>
    <span class="s1">name: </span><span class="s3">&quot;AsyncComponentWrapper&quot;</span><span class="s2">,</span>
    <span class="s1">__asyncLoader: load</span><span class="s2">,</span>
    <span class="s1">get __asyncResolved() {</span>
      <span class="s2">return </span><span class="s1">resolvedComp</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">setup() {</span>
      <span class="s2">const </span><span class="s1">instance = currentInstance</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(resolvedComp) {</span>
        <span class="s2">return </span><span class="s1">() =&gt; createInnerComp(resolvedComp</span><span class="s2">, </span><span class="s1">instance)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">const </span><span class="s1">onError = (err) =&gt; {</span>
        <span class="s1">pendingRequest = </span><span class="s2">null;</span>
        <span class="s1">handleError(</span>
          <span class="s1">err</span><span class="s2">,</span>
          <span class="s1">instance</span><span class="s2">,</span>
          <span class="s4">13</span><span class="s2">,</span>
          <span class="s1">!errorComponent</span>
          <span class="s0">/* do not throw in dev if user provided error component */</span>
        <span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(suspensible &amp;&amp; instance.suspense || isInSSRComponentSetup) {</span>
        <span class="s2">return </span><span class="s1">load().then((comp) =&gt; {</span>
          <span class="s2">return </span><span class="s1">() =&gt; createInnerComp(comp</span><span class="s2">, </span><span class="s1">instance)</span><span class="s2">;</span>
        <span class="s1">}).catch((err) =&gt; {</span>
          <span class="s1">onError(err)</span><span class="s2">;</span>
          <span class="s2">return </span><span class="s1">() =&gt; errorComponent ? createVNode(errorComponent</span><span class="s2">, </span><span class="s1">{</span>
            <span class="s1">error: err</span>
          <span class="s1">}) : </span><span class="s2">null;</span>
        <span class="s1">})</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">const </span><span class="s1">loaded = ref(</span><span class="s2">false</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">const </span><span class="s1">error = ref()</span><span class="s2">;</span>
      <span class="s2">const </span><span class="s1">delayed = ref(!!delay)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(delay) {</span>
        <span class="s1">setTimeout(() =&gt; {</span>
          <span class="s1">delayed.value = </span><span class="s2">false;</span>
        <span class="s1">}</span><span class="s2">, </span><span class="s1">delay)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(timeout != </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">setTimeout(() =&gt; {</span>
          <span class="s2">if </span><span class="s1">(!loaded.value &amp;&amp; !error.value) {</span>
            <span class="s2">const </span><span class="s1">err = </span><span class="s2">new </span><span class="s1">Error(</span><span class="s3">`Async component timed out after </span><span class="s1">${timeout}</span><span class="s3">ms.`</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">onError(err)</span><span class="s2">;</span>
            <span class="s1">error.value = err</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span><span class="s2">, </span><span class="s1">timeout)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s1">load().then(() =&gt; {</span>
        <span class="s1">loaded.value = </span><span class="s2">true;</span>
        <span class="s2">if </span><span class="s1">(instance.parent &amp;&amp; isKeepAlive(instance.parent.vnode)) {</span>
          <span class="s1">queueJob(instance.parent.update)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}).catch((err) =&gt; {</span>
        <span class="s1">onError(err)</span><span class="s2">;</span>
        <span class="s1">error.value = err</span><span class="s2">;</span>
      <span class="s1">})</span><span class="s2">;</span>
      <span class="s2">return </span><span class="s1">() =&gt; {</span>
        <span class="s2">if </span><span class="s1">(loaded.value &amp;&amp; resolvedComp) {</span>
          <span class="s2">return </span><span class="s1">createInnerComp(resolvedComp</span><span class="s2">, </span><span class="s1">instance)</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(error.value &amp;&amp; errorComponent) {</span>
          <span class="s2">return </span><span class="s1">createVNode(errorComponent</span><span class="s2">, </span><span class="s1">{</span>
            <span class="s1">error: error.value</span>
          <span class="s1">})</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(loadingComponent &amp;&amp; !delayed.value) {</span>
          <span class="s2">return </span><span class="s1">createVNode(loadingComponent)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">})</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createInnerComp(comp</span><span class="s2">, </span><span class="s1">parent) {</span>
  <span class="s2">const </span><span class="s1">{ ref: ref2</span><span class="s2">, </span><span class="s1">props</span><span class="s2">, </span><span class="s1">children</span><span class="s2">, </span><span class="s1">ce } = parent.vnode</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">vnode = createVNode(comp</span><span class="s2">, </span><span class="s1">props</span><span class="s2">, </span><span class="s1">children)</span><span class="s2">;</span>
  <span class="s1">vnode.ref = ref2</span><span class="s2">;</span>
  <span class="s1">vnode.ce = ce</span><span class="s2">;</span>
  <span class="s2">delete </span><span class="s1">parent.vnode.ce</span><span class="s2">;</span>
  <span class="s2">return </span><span class="s1">vnode</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">isKeepAlive = (vnode) =&gt; vnode.type.__isKeepAlive</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">KeepAliveImpl = {</span>
  <span class="s1">name: </span><span class="s3">`KeepAlive`</span><span class="s2">,</span>
  <span class="s0">// Marker for special handling inside the renderer. We are not using a ===</span>
  <span class="s0">// check directly on KeepAlive in the renderer, because importing it directly</span>
  <span class="s0">// would prevent it from being tree-shaken.</span>
  <span class="s1">__isKeepAlive: </span><span class="s2">true,</span>
  <span class="s1">props: {</span>
    <span class="s1">include: [String</span><span class="s2">, </span><span class="s1">RegExp</span><span class="s2">, </span><span class="s1">Array]</span><span class="s2">,</span>
    <span class="s1">exclude: [String</span><span class="s2">, </span><span class="s1">RegExp</span><span class="s2">, </span><span class="s1">Array]</span><span class="s2">,</span>
    <span class="s1">max: [String</span><span class="s2">, </span><span class="s1">Number]</span>
  <span class="s1">}</span><span class="s2">,</span>
  <span class="s1">setup(props</span><span class="s2">, </span><span class="s1">{ slots }) {</span>
    <span class="s2">const </span><span class="s1">instance = getCurrentInstance()</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">sharedContext = instance.ctx</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!sharedContext.renderer) {</span>
      <span class="s2">return </span><span class="s1">() =&gt; {</span>
        <span class="s2">const </span><span class="s1">children = slots.default &amp;&amp; slots.default()</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">children &amp;&amp; children.length === </span><span class="s4">1 </span><span class="s1">? children[</span><span class="s4">0</span><span class="s1">] : children</span><span class="s2">;</span>
      <span class="s1">}</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">cache = </span><span class="s0">/* @__PURE__ */ </span><span class="s2">new </span><span class="s1">Map()</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">keys = </span><span class="s0">/* @__PURE__ */ </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">current = </span><span class="s2">null;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
      <span class="s1">instance.__v_cache = cache</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">parentSuspense = instance.suspense</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">{ renderer: { p: patch</span><span class="s2">, </span><span class="s1">m: move</span><span class="s2">, </span><span class="s1">um: _unmount</span><span class="s2">, </span><span class="s1">o: { createElement } } } = sharedContext</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">storageContainer = createElement(</span><span class="s3">&quot;div&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">sharedContext.activate = (vnode</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">optimized) =&gt; {</span>
      <span class="s2">const </span><span class="s1">instance2 = vnode.component</span><span class="s2">;</span>
      <span class="s1">move(vnode</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">parentSuspense)</span><span class="s2">;</span>
      <span class="s1">patch(instance2.vnode</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">instance2</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">vnode.slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
      <span class="s1">queuePostRenderEffect(() =&gt; {</span>
        <span class="s1">instance2.isDeactivated = </span><span class="s2">false;</span>
        <span class="s2">if </span><span class="s1">(instance2.a) {</span>
          <span class="s1">invokeArrayFns(instance2.a)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">vnodeHook = vnode.props &amp;&amp; vnode.props.onVnodeMounted</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(vnodeHook) {</span>
          <span class="s1">invokeVNodeHook(vnodeHook</span><span class="s2">, </span><span class="s1">instance2.parent</span><span class="s2">, </span><span class="s1">vnode)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span><span class="s2">, </span><span class="s1">parentSuspense)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s1">devtoolsComponentAdded(instance2)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s1">sharedContext.deactivate = (vnode) =&gt; {</span>
      <span class="s2">const </span><span class="s1">instance2 = vnode.component</span><span class="s2">;</span>
      <span class="s1">move(vnode</span><span class="s2">, </span><span class="s1">storageContainer</span><span class="s2">, null, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">parentSuspense)</span><span class="s2">;</span>
      <span class="s1">queuePostRenderEffect(() =&gt; {</span>
        <span class="s2">if </span><span class="s1">(instance2.da) {</span>
          <span class="s1">invokeArrayFns(instance2.da)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">vnodeHook = vnode.props &amp;&amp; vnode.props.onVnodeUnmounted</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(vnodeHook) {</span>
          <span class="s1">invokeVNodeHook(vnodeHook</span><span class="s2">, </span><span class="s1">instance2.parent</span><span class="s2">, </span><span class="s1">vnode)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">instance2.isDeactivated = </span><span class="s2">true;</span>
      <span class="s1">}</span><span class="s2">, </span><span class="s1">parentSuspense)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s1">devtoolsComponentAdded(instance2)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">function </span><span class="s1">unmount(vnode) {</span>
      <span class="s1">resetShapeFlag(vnode)</span><span class="s2">;</span>
      <span class="s1">_unmount(vnode</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">function </span><span class="s1">pruneCache(filter) {</span>
      <span class="s1">cache.forEach((vnode</span><span class="s2">, </span><span class="s1">key) =&gt; {</span>
        <span class="s2">const </span><span class="s1">name = getComponentName(vnode.type)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(name &amp;&amp; (!filter || !filter(name))) {</span>
          <span class="s1">pruneCacheEntry(key)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">function </span><span class="s1">pruneCacheEntry(key) {</span>
      <span class="s2">const </span><span class="s1">cached = cache.get(key)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(!current || !isSameVNodeType(cached</span><span class="s2">, </span><span class="s1">current)) {</span>
        <span class="s1">unmount(cached)</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(current) {</span>
        <span class="s1">resetShapeFlag(current)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s1">cache.delete(key)</span><span class="s2">;</span>
      <span class="s1">keys.delete(key)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">watch(</span>
      <span class="s1">() =&gt; [props.include</span><span class="s2">, </span><span class="s1">props.exclude]</span><span class="s2">,</span>
      <span class="s1">([include</span><span class="s2">, </span><span class="s1">exclude]) =&gt; {</span>
        <span class="s1">include &amp;&amp; pruneCache((name) =&gt; matches(include</span><span class="s2">, </span><span class="s1">name))</span><span class="s2">;</span>
        <span class="s1">exclude &amp;&amp; pruneCache((name) =&gt; !matches(exclude</span><span class="s2">, </span><span class="s1">name))</span><span class="s2">;</span>
      <span class="s1">}</span><span class="s2">,</span>
      <span class="s0">// prune post-render after `current` has been updated</span>
      <span class="s1">{ flush: </span><span class="s3">&quot;post&quot;</span><span class="s2">, </span><span class="s1">deep: </span><span class="s2">true </span><span class="s1">}</span>
    <span class="s1">)</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">pendingCacheKey = </span><span class="s2">null;</span>
    <span class="s2">const </span><span class="s1">cacheSubtree = () =&gt; {</span>
      <span class="s2">if </span><span class="s1">(pendingCacheKey != </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">cache.set(pendingCacheKey</span><span class="s2">, </span><span class="s1">getInnerChild(instance.subTree))</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s1">onMounted(cacheSubtree)</span><span class="s2">;</span>
    <span class="s1">onUpdated(cacheSubtree)</span><span class="s2">;</span>
    <span class="s1">onBeforeUnmount(() =&gt; {</span>
      <span class="s1">cache.forEach((cached) =&gt; {</span>
        <span class="s2">const </span><span class="s1">{ subTree</span><span class="s2">, </span><span class="s1">suspense } = instance</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">vnode = getInnerChild(subTree)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(cached.type === vnode.type &amp;&amp; cached.key === vnode.key) {</span>
          <span class="s1">resetShapeFlag(vnode)</span><span class="s2">;</span>
          <span class="s2">const </span><span class="s1">da = vnode.component.da</span><span class="s2">;</span>
          <span class="s1">da &amp;&amp; queuePostRenderEffect(da</span><span class="s2">, </span><span class="s1">suspense)</span><span class="s2">;</span>
          <span class="s2">return;</span>
        <span class="s1">}</span>
        <span class="s1">unmount(cached)</span><span class="s2">;</span>
      <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">})</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">() =&gt; {</span>
      <span class="s1">pendingCacheKey = </span><span class="s2">null;</span>
      <span class="s2">if </span><span class="s1">(!slots.default) {</span>
        <span class="s2">return null;</span>
      <span class="s1">}</span>
      <span class="s2">const </span><span class="s1">children = slots.default()</span><span class="s2">;</span>
      <span class="s2">const </span><span class="s1">rawVNode = children[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(children.length &gt; </span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
          <span class="s1">warn2(</span><span class="s3">`KeepAlive should contain exactly one component child.`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">current = </span><span class="s2">null;</span>
        <span class="s2">return </span><span class="s1">children</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!isVNode(rawVNode) || !(rawVNode.shapeFlag &amp; </span><span class="s4">4</span><span class="s1">) &amp;&amp; !(rawVNode.shapeFlag &amp; </span><span class="s4">128</span><span class="s1">)) {</span>
        <span class="s1">current = </span><span class="s2">null;</span>
        <span class="s2">return </span><span class="s1">rawVNode</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">let </span><span class="s1">vnode = getInnerChild(rawVNode)</span><span class="s2">;</span>
      <span class="s2">const </span><span class="s1">comp = vnode.type</span><span class="s2">;</span>
      <span class="s2">const </span><span class="s1">name = getComponentName(isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp)</span><span class="s2">;</span>
      <span class="s2">const </span><span class="s1">{ include</span><span class="s2">, </span><span class="s1">exclude</span><span class="s2">, </span><span class="s1">max } = props</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(include &amp;&amp; (!name || !matches(include</span><span class="s2">, </span><span class="s1">name)) || exclude &amp;&amp; name &amp;&amp; matches(exclude</span><span class="s2">, </span><span class="s1">name)) {</span>
        <span class="s1">current = vnode</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">rawVNode</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">const </span><span class="s1">key = vnode.key == </span><span class="s2">null </span><span class="s1">? comp : vnode.key</span><span class="s2">;</span>
      <span class="s2">const </span><span class="s1">cachedVNode = cache.get(key)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(vnode.el) {</span>
        <span class="s1">vnode = cloneVNode(vnode)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(rawVNode.shapeFlag &amp; </span><span class="s4">128</span><span class="s1">) {</span>
          <span class="s1">rawVNode.ssContent = vnode</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s1">pendingCacheKey = key</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(cachedVNode) {</span>
        <span class="s1">vnode.el = cachedVNode.el</span><span class="s2">;</span>
        <span class="s1">vnode.component = cachedVNode.component</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(vnode.transition) {</span>
          <span class="s1">setTransitionHooks(vnode</span><span class="s2">, </span><span class="s1">vnode.transition)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">vnode.shapeFlag |= </span><span class="s4">512</span><span class="s2">;</span>
        <span class="s1">keys.delete(key)</span><span class="s2">;</span>
        <span class="s1">keys.add(key)</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">keys.add(key)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(max &amp;&amp; keys.size &gt; parseInt(max</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)) {</span>
          <span class="s1">pruneCacheEntry(keys.values().next().value)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s1">vnode.shapeFlag |= </span><span class="s4">256</span><span class="s2">;</span>
      <span class="s1">current = vnode</span><span class="s2">;</span>
      <span class="s2">return </span><span class="s1">isSuspense(rawVNode.type) ? rawVNode : vnode</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">KeepAlive = KeepAliveImpl</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">matches(pattern</span><span class="s2">, </span><span class="s1">name) {</span>
  <span class="s2">if </span><span class="s1">(isArray(pattern)) {</span>
    <span class="s2">return </span><span class="s1">pattern.some((p2) =&gt; matches(p2</span><span class="s2">, </span><span class="s1">name))</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isString(pattern)) {</span>
    <span class="s2">return </span><span class="s1">pattern.split(</span><span class="s3">&quot;,&quot;</span><span class="s1">).includes(name)</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isRegExp(pattern)) {</span>
    <span class="s2">return </span><span class="s1">pattern.test(name)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return false;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">onActivated(hook</span><span class="s2">, </span><span class="s1">target) {</span>
  <span class="s1">registerKeepAliveHook(hook</span><span class="s2">, </span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s1">target)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">onDeactivated(hook</span><span class="s2">, </span><span class="s1">target) {</span>
  <span class="s1">registerKeepAliveHook(hook</span><span class="s2">, </span><span class="s3">&quot;da&quot;</span><span class="s2">, </span><span class="s1">target)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">registerKeepAliveHook(hook</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">target = currentInstance) {</span>
  <span class="s2">const </span><span class="s1">wrappedHook = hook.__wdc || (hook.__wdc = () =&gt; {</span>
    <span class="s2">let </span><span class="s1">current = target</span><span class="s2">;</span>
    <span class="s2">while </span><span class="s1">(current) {</span>
      <span class="s2">if </span><span class="s1">(current.isDeactivated) {</span>
        <span class="s2">return;</span>
      <span class="s1">}</span>
      <span class="s1">current = current.parent</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">hook()</span><span class="s2">;</span>
  <span class="s1">})</span><span class="s2">;</span>
  <span class="s1">injectHook(type</span><span class="s2">, </span><span class="s1">wrappedHook</span><span class="s2">, </span><span class="s1">target)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(target) {</span>
    <span class="s2">let </span><span class="s1">current = target.parent</span><span class="s2">;</span>
    <span class="s2">while </span><span class="s1">(current &amp;&amp; current.parent) {</span>
      <span class="s2">if </span><span class="s1">(isKeepAlive(current.parent.vnode)) {</span>
        <span class="s1">injectToKeepAliveRoot(wrappedHook</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">target</span><span class="s2">, </span><span class="s1">current)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s1">current = current.parent</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">injectToKeepAliveRoot(hook</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">target</span><span class="s2">, </span><span class="s1">keepAliveRoot) {</span>
  <span class="s2">const </span><span class="s1">injected = injectHook(</span>
    <span class="s1">type</span><span class="s2">,</span>
    <span class="s1">hook</span><span class="s2">,</span>
    <span class="s1">keepAliveRoot</span><span class="s2">,</span>
    <span class="s2">true</span>
    <span class="s0">/* prepend */</span>
  <span class="s1">)</span><span class="s2">;</span>
  <span class="s1">onUnmounted(() =&gt; {</span>
    <span class="s1">remove(keepAliveRoot[type]</span><span class="s2">, </span><span class="s1">injected)</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">, </span><span class="s1">target)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">resetShapeFlag(vnode) {</span>
  <span class="s1">vnode.shapeFlag &amp;= ~</span><span class="s4">256</span><span class="s2">;</span>
  <span class="s1">vnode.shapeFlag &amp;= ~</span><span class="s4">512</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getInnerChild(vnode) {</span>
  <span class="s2">return </span><span class="s1">vnode.shapeFlag &amp; </span><span class="s4">128 </span><span class="s1">? vnode.ssContent : vnode</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">injectHook(type</span><span class="s2">, </span><span class="s1">hook</span><span class="s2">, </span><span class="s1">target = currentInstance</span><span class="s2">, </span><span class="s1">prepend = </span><span class="s2">false</span><span class="s1">) {</span>
  <span class="s2">if </span><span class="s1">(target) {</span>
    <span class="s2">const </span><span class="s1">hooks = target[type] || (target[type] = [])</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">wrappedHook = hook.__weh || (hook.__weh = (...args) =&gt; {</span>
      <span class="s2">if </span><span class="s1">(target.isUnmounted) {</span>
        <span class="s2">return;</span>
      <span class="s1">}</span>
      <span class="s1">pauseTracking()</span><span class="s2">;</span>
      <span class="s1">setCurrentInstance(target)</span><span class="s2">;</span>
      <span class="s2">const </span><span class="s1">res = callWithAsyncErrorHandling(hook</span><span class="s2">, </span><span class="s1">target</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">args)</span><span class="s2">;</span>
      <span class="s1">unsetCurrentInstance()</span><span class="s2">;</span>
      <span class="s1">resetTracking()</span><span class="s2">;</span>
      <span class="s2">return </span><span class="s1">res</span><span class="s2">;</span>
    <span class="s1">})</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(prepend) {</span>
      <span class="s1">hooks.unshift(wrappedHook)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">hooks.push(wrappedHook)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">wrappedHook</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s2">const </span><span class="s1">apiName = toHandlerKey(ErrorTypeStrings[type].replace(</span><span class="s4">/ hook$/</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">))</span><span class="s2">;</span>
    <span class="s1">warn2(</span><span class="s3">`</span><span class="s1">${apiName} </span><span class="s3">is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">createHook = (lifecycle) =&gt; (hook</span><span class="s2">, </span><span class="s1">target = currentInstance) =&gt; (</span>
  <span class="s0">// post-create lifecycle registrations are noops during SSR (except for serverPrefetch)</span>
  <span class="s1">(!isInSSRComponentSetup || lifecycle === </span><span class="s3">&quot;sp&quot;</span><span class="s1">) &amp;&amp; injectHook(lifecycle</span><span class="s2">, </span><span class="s1">(...args) =&gt; hook(...args)</span><span class="s2">, </span><span class="s1">target)</span>
<span class="s1">)</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">onBeforeMount = createHook(</span>
  <span class="s3">&quot;bm&quot;</span>
  <span class="s0">/* LifecycleHooks.BEFORE_MOUNT */</span>
<span class="s1">)</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">onMounted = createHook(</span>
  <span class="s3">&quot;m&quot;</span>
  <span class="s0">/* LifecycleHooks.MOUNTED */</span>
<span class="s1">)</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">onBeforeUpdate = createHook(</span>
  <span class="s3">&quot;bu&quot;</span>
  <span class="s0">/* LifecycleHooks.BEFORE_UPDATE */</span>
<span class="s1">)</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">onUpdated = createHook(</span>
  <span class="s3">&quot;u&quot;</span>
  <span class="s0">/* LifecycleHooks.UPDATED */</span>
<span class="s1">)</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">onBeforeUnmount = createHook(</span>
  <span class="s3">&quot;bum&quot;</span>
  <span class="s0">/* LifecycleHooks.BEFORE_UNMOUNT */</span>
<span class="s1">)</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">onUnmounted = createHook(</span>
  <span class="s3">&quot;um&quot;</span>
  <span class="s0">/* LifecycleHooks.UNMOUNTED */</span>
<span class="s1">)</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">onServerPrefetch = createHook(</span>
  <span class="s3">&quot;sp&quot;</span>
  <span class="s0">/* LifecycleHooks.SERVER_PREFETCH */</span>
<span class="s1">)</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">onRenderTriggered = createHook(</span>
  <span class="s3">&quot;rtg&quot;</span>
  <span class="s0">/* LifecycleHooks.RENDER_TRIGGERED */</span>
<span class="s1">)</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">onRenderTracked = createHook(</span>
  <span class="s3">&quot;rtc&quot;</span>
  <span class="s0">/* LifecycleHooks.RENDER_TRACKED */</span>
<span class="s1">)</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">onErrorCaptured(hook</span><span class="s2">, </span><span class="s1">target = currentInstance) {</span>
  <span class="s1">injectHook(</span><span class="s3">&quot;ec&quot;</span><span class="s2">, </span><span class="s1">hook</span><span class="s2">, </span><span class="s1">target)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">validateDirectiveName(name) {</span>
  <span class="s2">if </span><span class="s1">(isBuiltInDirective(name)) {</span>
    <span class="s1">warn2(</span><span class="s3">&quot;Do not use built-in directive ids as custom directive id: &quot; </span><span class="s1">+ name)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">withDirectives(vnode</span><span class="s2">, </span><span class="s1">directives) {</span>
  <span class="s2">const </span><span class="s1">internalInstance = currentRenderingInstance</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(internalInstance === </span><span class="s2">null</span><span class="s1">) {</span>
    <span class="s1">warn2(</span><span class="s3">`withDirectives can only be used inside render functions.`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">vnode</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">const </span><span class="s1">instance = getExposeProxy(internalInstance) || internalInstance.proxy</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">bindings = vnode.dirs || (vnode.dirs = [])</span><span class="s2">;</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; directives.length</span><span class="s2">; </span><span class="s1">i++) {</span>
    <span class="s2">let </span><span class="s1">[dir</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">arg</span><span class="s2">, </span><span class="s1">modifiers = EMPTY_OBJ] = directives[i]</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(dir) {</span>
      <span class="s2">if </span><span class="s1">(isFunction(dir)) {</span>
        <span class="s1">dir = {</span>
          <span class="s1">mounted: dir</span><span class="s2">,</span>
          <span class="s1">updated: dir</span>
        <span class="s1">}</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(dir.deep) {</span>
        <span class="s1">traverse(value)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s1">bindings.push({</span>
        <span class="s1">dir</span><span class="s2">,</span>
        <span class="s1">instance</span><span class="s2">,</span>
        <span class="s1">value</span><span class="s2">,</span>
        <span class="s1">oldValue: </span><span class="s2">void </span><span class="s4">0</span><span class="s2">,</span>
        <span class="s1">arg</span><span class="s2">,</span>
        <span class="s1">modifiers</span>
      <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">vnode</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">invokeDirectiveHook(vnode</span><span class="s2">, </span><span class="s1">prevVNode</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s1">name) {</span>
  <span class="s2">const </span><span class="s1">bindings = vnode.dirs</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">oldBindings = prevVNode &amp;&amp; prevVNode.dirs</span><span class="s2">;</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; bindings.length</span><span class="s2">; </span><span class="s1">i++) {</span>
    <span class="s2">const </span><span class="s1">binding = bindings[i]</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(oldBindings) {</span>
      <span class="s1">binding.oldValue = oldBindings[i].value</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">let </span><span class="s1">hook = binding.dir[name]</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(hook) {</span>
      <span class="s1">pauseTracking()</span><span class="s2">;</span>
      <span class="s1">callWithAsyncErrorHandling(hook</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s1">[</span>
        <span class="s1">vnode.el</span><span class="s2">,</span>
        <span class="s1">binding</span><span class="s2">,</span>
        <span class="s1">vnode</span><span class="s2">,</span>
        <span class="s1">prevVNode</span>
      <span class="s1">])</span><span class="s2">;</span>
      <span class="s1">resetTracking()</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">COMPONENTS = </span><span class="s3">&quot;components&quot;</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">DIRECTIVES = </span><span class="s3">&quot;directives&quot;</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">resolveComponent(name</span><span class="s2">, </span><span class="s1">maybeSelfReference) {</span>
  <span class="s2">return </span><span class="s1">resolveAsset(COMPONENTS</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, true, </span><span class="s1">maybeSelfReference) || name</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">NULL_DYNAMIC_COMPONENT = Symbol()</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">resolveDynamicComponent(component) {</span>
  <span class="s2">if </span><span class="s1">(isString(component)) {</span>
    <span class="s2">return </span><span class="s1">resolveAsset(COMPONENTS</span><span class="s2">, </span><span class="s1">component</span><span class="s2">, false</span><span class="s1">) || component</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s2">return </span><span class="s1">component || NULL_DYNAMIC_COMPONENT</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">resolveDirective(name) {</span>
  <span class="s2">return </span><span class="s1">resolveAsset(DIRECTIVES</span><span class="s2">, </span><span class="s1">name)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">resolveAsset(type</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">warnMissing = </span><span class="s2">true, </span><span class="s1">maybeSelfReference = </span><span class="s2">false</span><span class="s1">) {</span>
  <span class="s2">const </span><span class="s1">instance = currentRenderingInstance || currentInstance</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(instance) {</span>
    <span class="s2">const </span><span class="s1">Component = instance.type</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(type === COMPONENTS) {</span>
      <span class="s2">const </span><span class="s1">selfName = getComponentName(</span>
        <span class="s1">Component</span><span class="s2">,</span>
        <span class="s2">false</span>
        <span class="s0">/* do not include inferred name to avoid breaking existing code */</span>
      <span class="s1">)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(selfName &amp;&amp; (selfName === name || selfName === camelize(name) || selfName === capitalize(camelize(name)))) {</span>
        <span class="s2">return </span><span class="s1">Component</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">res = (</span>
      <span class="s0">// local registration</span>
      <span class="s0">// check instance[type] first which is resolved for options API</span>
      <span class="s1">resolve(instance[type] || Component[type]</span><span class="s2">, </span><span class="s1">name) || </span><span class="s0">// global registration</span>
      <span class="s1">resolve(instance.appContext[type]</span><span class="s2">, </span><span class="s1">name)</span>
    <span class="s1">)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!res &amp;&amp; maybeSelfReference) {</span>
      <span class="s2">return </span><span class="s1">Component</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(warnMissing &amp;&amp; !res) {</span>
      <span class="s2">const </span><span class="s1">extra = type === COMPONENTS ? </span><span class="s3">`</span>
<span class="s3">If this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.` </span><span class="s1">: </span><span class="s3">``</span><span class="s2">;</span>
      <span class="s1">warn2(</span><span class="s3">`Failed to resolve </span><span class="s1">${type.slice(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)}</span><span class="s3">: </span><span class="s1">${name}${extra}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">res</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s1">warn2(</span><span class="s3">`resolve</span><span class="s1">${capitalize(type.slice(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">))} </span><span class="s3">can only be used in render() or setup().`</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">resolve(registry</span><span class="s2">, </span><span class="s1">name) {</span>
  <span class="s2">return </span><span class="s1">registry &amp;&amp; (registry[name] || registry[camelize(name)] || registry[capitalize(camelize(name))])</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">renderList(source</span><span class="s2">, </span><span class="s1">renderItem</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">index) {</span>
  <span class="s2">let </span><span class="s1">ret</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">cached = cache &amp;&amp; cache[index]</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(isArray(source) || isString(source)) {</span>
    <span class="s1">ret = </span><span class="s2">new </span><span class="s1">Array(source.length)</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">l = source.length</span><span class="s2">; </span><span class="s1">i &lt; l</span><span class="s2">; </span><span class="s1">i++) {</span>
      <span class="s1">ret[i] = renderItem(source[i]</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, void </span><span class="s4">0</span><span class="s2">, </span><span class="s1">cached &amp;&amp; cached[i])</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">source === </span><span class="s3">&quot;number&quot;</span><span class="s1">) {</span>
    <span class="s2">if </span><span class="s1">(!Number.isInteger(source)) {</span>
      <span class="s1">warn2(</span><span class="s3">`The v-for range expect an integer value but got </span><span class="s1">${source}</span><span class="s3">.`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">ret = </span><span class="s2">new </span><span class="s1">Array(source)</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; source</span><span class="s2">; </span><span class="s1">i++) {</span>
      <span class="s1">ret[i] = renderItem(i + </span><span class="s4">1</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, void </span><span class="s4">0</span><span class="s2">, </span><span class="s1">cached &amp;&amp; cached[i])</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isObject(source)) {</span>
    <span class="s2">if </span><span class="s1">(source[Symbol.iterator]) {</span>
      <span class="s1">ret = Array.from(source</span><span class="s2">, </span><span class="s1">(item</span><span class="s2">, </span><span class="s1">i) =&gt; renderItem(item</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, void </span><span class="s4">0</span><span class="s2">, </span><span class="s1">cached &amp;&amp; cached[i]))</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">const </span><span class="s1">keys = Object.keys(source)</span><span class="s2">;</span>
      <span class="s1">ret = </span><span class="s2">new </span><span class="s1">Array(keys.length)</span><span class="s2">;</span>
      <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">l = keys.length</span><span class="s2">; </span><span class="s1">i &lt; l</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s2">const </span><span class="s1">key = keys[i]</span><span class="s2">;</span>
        <span class="s1">ret[i] = renderItem(source[key]</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">cached &amp;&amp; cached[i])</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s1">ret = []</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(cache) {</span>
    <span class="s1">cache[index] = ret</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">ret</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createSlots(slots</span><span class="s2">, </span><span class="s1">dynamicSlots) {</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; dynamicSlots.length</span><span class="s2">; </span><span class="s1">i++) {</span>
    <span class="s2">const </span><span class="s1">slot = dynamicSlots[i]</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(isArray(slot)) {</span>
      <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">j = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">j &lt; slot.length</span><span class="s2">; </span><span class="s1">j++) {</span>
        <span class="s1">slots[slot[j].name] = slot[j].fn</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(slot) {</span>
      <span class="s1">slots[slot.name] = slot.key ? (...args) =&gt; {</span>
        <span class="s2">const </span><span class="s1">res = slot.fn(...args)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(res)</span>
          <span class="s1">res.key = slot.key</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">res</span><span class="s2">;</span>
      <span class="s1">} : slot.fn</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">slots</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">renderSlot(slots</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">props = {}</span><span class="s2">, </span><span class="s1">fallback</span><span class="s2">, </span><span class="s1">noSlotted) {</span>
  <span class="s2">if </span><span class="s1">(currentRenderingInstance.isCE || currentRenderingInstance.parent &amp;&amp; isAsyncWrapper(currentRenderingInstance.parent) &amp;&amp; currentRenderingInstance.parent.isCE) {</span>
    <span class="s2">if </span><span class="s1">(name !== </span><span class="s3">&quot;default&quot;</span><span class="s1">)</span>
      <span class="s1">props.name = name</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">createVNode(</span><span class="s3">&quot;slot&quot;</span><span class="s2">, </span><span class="s1">props</span><span class="s2">, </span><span class="s1">fallback &amp;&amp; fallback())</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">let </span><span class="s1">slot = slots[name]</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(slot &amp;&amp; slot.length &gt; </span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s1">warn2(</span><span class="s3">`SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template.`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">slot = () =&gt; []</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(slot &amp;&amp; slot._c) {</span>
    <span class="s1">slot._d = </span><span class="s2">false;</span>
  <span class="s1">}</span>
  <span class="s1">openBlock()</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">validSlotContent = slot &amp;&amp; ensureValidVNode(slot(props))</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">rendered = createBlock(</span>
    <span class="s1">Fragment</span><span class="s2">,</span>
    <span class="s1">{</span>
      <span class="s1">key: props.key || </span><span class="s0">// slot content array of a dynamic conditional slot may have a branch</span>
      <span class="s0">// key attached in the `createSlots` helper, respect that</span>
      <span class="s1">validSlotContent &amp;&amp; validSlotContent.key || </span><span class="s3">`_</span><span class="s1">${name}</span><span class="s3">`</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">validSlotContent || (fallback ? fallback() : [])</span><span class="s2">,</span>
    <span class="s1">validSlotContent &amp;&amp; slots._ === </span><span class="s4">1 </span><span class="s1">? </span><span class="s4">64 </span><span class="s1">: -</span><span class="s4">2</span>
    <span class="s0">/* PatchFlags.BAIL */</span>
  <span class="s1">)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(!noSlotted &amp;&amp; rendered.scopeId) {</span>
    <span class="s1">rendered.slotScopeIds = [rendered.scopeId + </span><span class="s3">&quot;-s&quot;</span><span class="s1">]</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(slot &amp;&amp; slot._c) {</span>
    <span class="s1">slot._d = </span><span class="s2">true;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">rendered</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">ensureValidVNode(vnodes) {</span>
  <span class="s2">return </span><span class="s1">vnodes.some((child) =&gt; {</span>
    <span class="s2">if </span><span class="s1">(!isVNode(child))</span>
      <span class="s2">return true;</span>
    <span class="s2">if </span><span class="s1">(child.type === Comment)</span>
      <span class="s2">return false;</span>
    <span class="s2">if </span><span class="s1">(child.type === Fragment &amp;&amp; !ensureValidVNode(child.children))</span>
      <span class="s2">return false;</span>
    <span class="s2">return true;</span>
  <span class="s1">}) ? vnodes : </span><span class="s2">null;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">toHandlers(obj</span><span class="s2">, </span><span class="s1">preserveCaseIfNecessary) {</span>
  <span class="s2">const </span><span class="s1">ret = {}</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(!isObject(obj)) {</span>
    <span class="s1">warn2(</span><span class="s3">`v-on with no argument expects an object value.`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">ret</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">obj) {</span>
    <span class="s1">ret[preserveCaseIfNecessary &amp;&amp; </span><span class="s4">/[A-Z]/</span><span class="s1">.test(key) ? </span><span class="s3">`on:</span><span class="s1">${key}</span><span class="s3">` </span><span class="s1">: toHandlerKey(key)] = obj[key]</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">ret</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">getPublicInstance = (i) =&gt; {</span>
  <span class="s2">if </span><span class="s1">(!i)</span>
    <span class="s2">return null;</span>
  <span class="s2">if </span><span class="s1">(isStatefulComponent(i))</span>
    <span class="s2">return </span><span class="s1">getExposeProxy(i) || i.proxy</span><span class="s2">;</span>
  <span class="s2">return </span><span class="s1">getPublicInstance(i.parent)</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">publicPropertiesMap = (</span>
  <span class="s0">// Move PURE marker to new line to workaround compiler discarding it</span>
  <span class="s0">// due to type annotation</span>
  <span class="s1">extend(</span><span class="s0">/* @__PURE__ */ </span><span class="s1">Object.create(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">, </span><span class="s1">{</span>
    <span class="s1">$: (i) =&gt; i</span><span class="s2">,</span>
    <span class="s1">$el: (i) =&gt; i.vnode.el</span><span class="s2">,</span>
    <span class="s1">$data: (i) =&gt; i.data</span><span class="s2">,</span>
    <span class="s1">$props: (i) =&gt; </span><span class="s2">true </span><span class="s1">? shallowReadonly(i.props) : i.props</span><span class="s2">,</span>
    <span class="s1">$attrs: (i) =&gt; </span><span class="s2">true </span><span class="s1">? shallowReadonly(i.attrs) : i.attrs</span><span class="s2">,</span>
    <span class="s1">$slots: (i) =&gt; </span><span class="s2">true </span><span class="s1">? shallowReadonly(i.slots) : i.slots</span><span class="s2">,</span>
    <span class="s1">$refs: (i) =&gt; </span><span class="s2">true </span><span class="s1">? shallowReadonly(i.refs) : i.refs</span><span class="s2">,</span>
    <span class="s1">$parent: (i) =&gt; getPublicInstance(i.parent)</span><span class="s2">,</span>
    <span class="s1">$root: (i) =&gt; getPublicInstance(i.root)</span><span class="s2">,</span>
    <span class="s1">$emit: (i) =&gt; i.emit</span><span class="s2">,</span>
    <span class="s1">$options: (i) =&gt; __VUE_OPTIONS_API__ ? resolveMergedOptions(i) : i.type</span><span class="s2">,</span>
    <span class="s1">$forceUpdate: (i) =&gt; i.f || (i.f = () =&gt; queueJob(i.update))</span><span class="s2">,</span>
    <span class="s1">$nextTick: (i) =&gt; i.n || (i.n = nextTick.bind(i.proxy))</span><span class="s2">,</span>
    <span class="s1">$watch: (i) =&gt; __VUE_OPTIONS_API__ ? instanceWatch.bind(i) : NOOP</span>
  <span class="s1">})</span>
<span class="s1">)</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">isReservedPrefix = (key) =&gt; key === </span><span class="s3">&quot;_&quot; </span><span class="s1">|| key === </span><span class="s3">&quot;$&quot;</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">hasSetupBinding = (state</span><span class="s2">, </span><span class="s1">key) =&gt; state !== EMPTY_OBJ &amp;&amp; !state.__isScriptSetup &amp;&amp; hasOwn(state</span><span class="s2">, </span><span class="s1">key)</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">PublicInstanceProxyHandlers = {</span>
  <span class="s1">get({ _: instance }</span><span class="s2">, </span><span class="s1">key) {</span>
    <span class="s2">const </span><span class="s1">{ ctx</span><span class="s2">, </span><span class="s1">setupState</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">props</span><span class="s2">, </span><span class="s1">accessCache</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">appContext } = instance</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(key === </span><span class="s3">&quot;__isVue&quot;</span><span class="s1">) {</span>
      <span class="s2">return true;</span>
    <span class="s1">}</span>
    <span class="s2">let </span><span class="s1">normalizedProps</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(key[</span><span class="s4">0</span><span class="s1">] !== </span><span class="s3">&quot;$&quot;</span><span class="s1">) {</span>
      <span class="s2">const </span><span class="s1">n = accessCache[key]</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(n !== </span><span class="s2">void </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s2">switch </span><span class="s1">(n) {</span>
          <span class="s2">case </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">setupState[key]</span><span class="s2">;</span>
          <span class="s2">case </span><span class="s4">2</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">data[key]</span><span class="s2">;</span>
          <span class="s2">case </span><span class="s4">4</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">ctx[key]</span><span class="s2">;</span>
          <span class="s2">case </span><span class="s4">3</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">props[key]</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(hasSetupBinding(setupState</span><span class="s2">, </span><span class="s1">key)) {</span>
        <span class="s1">accessCache[key] = </span><span class="s4">1</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">setupState[key]</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(data !== EMPTY_OBJ &amp;&amp; hasOwn(data</span><span class="s2">, </span><span class="s1">key)) {</span>
        <span class="s1">accessCache[key] = </span><span class="s4">2</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">data[key]</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span>
        <span class="s0">// only cache other properties when instance has declared (thus stable)</span>
        <span class="s0">// props</span>
        <span class="s1">(normalizedProps = instance.propsOptions[</span><span class="s4">0</span><span class="s1">]) &amp;&amp; hasOwn(normalizedProps</span><span class="s2">, </span><span class="s1">key)</span>
      <span class="s1">) {</span>
        <span class="s1">accessCache[key] = </span><span class="s4">3</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">props[key]</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(ctx !== EMPTY_OBJ &amp;&amp; hasOwn(ctx</span><span class="s2">, </span><span class="s1">key)) {</span>
        <span class="s1">accessCache[key] = </span><span class="s4">4</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">ctx[key]</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!__VUE_OPTIONS_API__ || shouldCacheAccess) {</span>
        <span class="s1">accessCache[key] = </span><span class="s4">0</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">publicGetter = publicPropertiesMap[key]</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">cssModule</span><span class="s2">, </span><span class="s1">globalProperties</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(publicGetter) {</span>
      <span class="s2">if </span><span class="s1">(key === </span><span class="s3">&quot;$attrs&quot;</span><span class="s1">) {</span>
        <span class="s1">track(instance</span><span class="s2">, </span><span class="s3">&quot;get&quot;</span><span class="s2">, </span><span class="s1">key)</span><span class="s2">;</span>
        <span class="s1">markAttrsAccessed()</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">publicGetter(instance)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span>
      <span class="s0">// css module (injected by vue-loader)</span>
      <span class="s1">(cssModule = type.__cssModules) &amp;&amp; (cssModule = cssModule[key])</span>
    <span class="s1">) {</span>
      <span class="s2">return </span><span class="s1">cssModule</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(ctx !== EMPTY_OBJ &amp;&amp; hasOwn(ctx</span><span class="s2">, </span><span class="s1">key)) {</span>
      <span class="s1">accessCache[key] = </span><span class="s4">4</span><span class="s2">;</span>
      <span class="s2">return </span><span class="s1">ctx[key]</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span>
      <span class="s0">// global properties</span>
      <span class="s1">globalProperties = appContext.config.globalProperties</span><span class="s2">, </span><span class="s1">hasOwn(globalProperties</span><span class="s2">, </span><span class="s1">key)</span>
    <span class="s1">) {</span>
      <span class="s1">{</span>
        <span class="s2">return </span><span class="s1">globalProperties[key]</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(currentRenderingInstance &amp;&amp; (!isString(key) || </span><span class="s0">// #1091 avoid internal isRef/isVNode checks on component instance leading</span>
    <span class="s0">// to infinite warning loop</span>
    <span class="s1">key.indexOf(</span><span class="s3">&quot;__v&quot;</span><span class="s1">) !== </span><span class="s4">0</span><span class="s1">)) {</span>
      <span class="s2">if </span><span class="s1">(data !== EMPTY_OBJ &amp;&amp; isReservedPrefix(key[</span><span class="s4">0</span><span class="s1">]) &amp;&amp; hasOwn(data</span><span class="s2">, </span><span class="s1">key)) {</span>
        <span class="s1">warn2(</span><span class="s3">`Property </span><span class="s1">${JSON.stringify(key)} </span><span class="s3">must be accessed via $data because it starts with a reserved character (&quot;$&quot; or &quot;_&quot;) and is not proxied on the render context.`</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(instance === currentRenderingInstance) {</span>
        <span class="s1">warn2(</span><span class="s3">`Property </span><span class="s1">${JSON.stringify(key)} </span><span class="s3">was accessed during render but is not defined on instance.`</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">,</span>
  <span class="s1">set({ _: instance }</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value) {</span>
    <span class="s2">const </span><span class="s1">{ data</span><span class="s2">, </span><span class="s1">setupState</span><span class="s2">, </span><span class="s1">ctx } = instance</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(hasSetupBinding(setupState</span><span class="s2">, </span><span class="s1">key)) {</span>
      <span class="s1">setupState[key] = value</span><span class="s2">;</span>
      <span class="s2">return true;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(setupState.__isScriptSetup &amp;&amp; hasOwn(setupState</span><span class="s2">, </span><span class="s1">key)) {</span>
      <span class="s1">warn2(</span><span class="s3">`Cannot mutate &lt;script setup&gt; binding &quot;</span><span class="s1">${key}</span><span class="s3">&quot; from Options API.`</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">return false;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(data !== EMPTY_OBJ &amp;&amp; hasOwn(data</span><span class="s2">, </span><span class="s1">key)) {</span>
      <span class="s1">data[key] = value</span><span class="s2">;</span>
      <span class="s2">return true;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(hasOwn(instance.props</span><span class="s2">, </span><span class="s1">key)) {</span>
      <span class="s1">warn2(</span><span class="s3">`Attempting to mutate prop &quot;</span><span class="s1">${key}</span><span class="s3">&quot;. Props are readonly.`</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">return false;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(key[</span><span class="s4">0</span><span class="s1">] === </span><span class="s3">&quot;$&quot; </span><span class="s1">&amp;&amp; key.slice(</span><span class="s4">1</span><span class="s1">) </span><span class="s2">in </span><span class="s1">instance) {</span>
      <span class="s1">warn2(</span><span class="s3">`Attempting to mutate public property &quot;</span><span class="s1">${key}</span><span class="s3">&quot;. Properties starting with $ are reserved and readonly.`</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">return false;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(key </span><span class="s2">in </span><span class="s1">instance.appContext.config.globalProperties) {</span>
        <span class="s1">Object.defineProperty(ctx</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">{</span>
          <span class="s1">enumerable: </span><span class="s2">true,</span>
          <span class="s1">configurable: </span><span class="s2">true,</span>
          <span class="s1">value</span>
        <span class="s1">})</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">ctx[key] = value</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return true;</span>
  <span class="s1">}</span><span class="s2">,</span>
  <span class="s1">has({ _: { data</span><span class="s2">, </span><span class="s1">setupState</span><span class="s2">, </span><span class="s1">accessCache</span><span class="s2">, </span><span class="s1">ctx</span><span class="s2">, </span><span class="s1">appContext</span><span class="s2">, </span><span class="s1">propsOptions } }</span><span class="s2">, </span><span class="s1">key) {</span>
    <span class="s2">let </span><span class="s1">normalizedProps</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">!!accessCache[key] || data !== EMPTY_OBJ &amp;&amp; hasOwn(data</span><span class="s2">, </span><span class="s1">key) || hasSetupBinding(setupState</span><span class="s2">, </span><span class="s1">key) || (normalizedProps = propsOptions[</span><span class="s4">0</span><span class="s1">]) &amp;&amp; hasOwn(normalizedProps</span><span class="s2">, </span><span class="s1">key) || hasOwn(ctx</span><span class="s2">, </span><span class="s1">key) || hasOwn(publicPropertiesMap</span><span class="s2">, </span><span class="s1">key) || hasOwn(appContext.config.globalProperties</span><span class="s2">, </span><span class="s1">key)</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">,</span>
  <span class="s1">defineProperty(target</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">descriptor) {</span>
    <span class="s2">if </span><span class="s1">(descriptor.get != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">target._.accessCache[key] = </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(hasOwn(descriptor</span><span class="s2">, </span><span class="s3">&quot;value&quot;</span><span class="s1">)) {</span>
      <span class="s2">this</span><span class="s1">.set(target</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">descriptor.value</span><span class="s2">, null</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">Reflect.defineProperty(target</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">descriptor)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
  <span class="s1">PublicInstanceProxyHandlers.ownKeys = (target) =&gt; {</span>
    <span class="s1">warn2(</span><span class="s3">`Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead.`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">Reflect.ownKeys(target)</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">RuntimeCompiledPublicInstanceProxyHandlers = extend({}</span><span class="s2">, </span><span class="s1">PublicInstanceProxyHandlers</span><span class="s2">, </span><span class="s1">{</span>
  <span class="s1">get(target</span><span class="s2">, </span><span class="s1">key) {</span>
    <span class="s2">if </span><span class="s1">(key === Symbol.unscopables) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">PublicInstanceProxyHandlers.get(target</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">target)</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">,</span>
  <span class="s1">has(_</span><span class="s2">, </span><span class="s1">key) {</span>
    <span class="s2">const </span><span class="s1">has2 = key[</span><span class="s4">0</span><span class="s1">] !== </span><span class="s3">&quot;_&quot; </span><span class="s1">&amp;&amp; !isGloballyWhitelisted(key)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!has2 &amp;&amp; PublicInstanceProxyHandlers.has(_</span><span class="s2">, </span><span class="s1">key)) {</span>
      <span class="s1">warn2(</span><span class="s3">`Property </span><span class="s1">${JSON.stringify(key)} </span><span class="s3">should not start with _ which is a reserved prefix for Vue internals.`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">has2</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">})</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">createDevRenderContext(instance) {</span>
  <span class="s2">const </span><span class="s1">target = {}</span><span class="s2">;</span>
  <span class="s1">Object.defineProperty(target</span><span class="s2">, </span><span class="s3">`_`</span><span class="s2">, </span><span class="s1">{</span>
    <span class="s1">configurable: </span><span class="s2">true,</span>
    <span class="s1">enumerable: </span><span class="s2">false,</span>
    <span class="s1">get: () =&gt; instance</span>
  <span class="s1">})</span><span class="s2">;</span>
  <span class="s1">Object.keys(publicPropertiesMap).forEach((key) =&gt; {</span>
    <span class="s1">Object.defineProperty(target</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">{</span>
      <span class="s1">configurable: </span><span class="s2">true,</span>
      <span class="s1">enumerable: </span><span class="s2">false,</span>
      <span class="s1">get: () =&gt; publicPropertiesMap[key](instance)</span><span class="s2">,</span>
      <span class="s0">// intercepted by the proxy so no need for implementation,</span>
      <span class="s0">// but needed to prevent set errors</span>
      <span class="s1">set: NOOP</span>
    <span class="s1">})</span><span class="s2">;</span>
  <span class="s1">})</span><span class="s2">;</span>
  <span class="s2">return </span><span class="s1">target</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">exposePropsOnRenderContext(instance) {</span>
  <span class="s2">const </span><span class="s1">{ ctx</span><span class="s2">, </span><span class="s1">propsOptions: [propsOptions] } = instance</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(propsOptions) {</span>
    <span class="s1">Object.keys(propsOptions).forEach((key) =&gt; {</span>
      <span class="s1">Object.defineProperty(ctx</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">{</span>
        <span class="s1">enumerable: </span><span class="s2">true,</span>
        <span class="s1">configurable: </span><span class="s2">true,</span>
        <span class="s1">get: () =&gt; instance.props[key]</span><span class="s2">,</span>
        <span class="s1">set: NOOP</span>
      <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">})</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">exposeSetupStateOnRenderContext(instance) {</span>
  <span class="s2">const </span><span class="s1">{ ctx</span><span class="s2">, </span><span class="s1">setupState } = instance</span><span class="s2">;</span>
  <span class="s1">Object.keys(toRaw(setupState)).forEach((key) =&gt; {</span>
    <span class="s2">if </span><span class="s1">(!setupState.__isScriptSetup) {</span>
      <span class="s2">if </span><span class="s1">(isReservedPrefix(key[</span><span class="s4">0</span><span class="s1">])) {</span>
        <span class="s1">warn2(</span><span class="s3">`setup() return property </span><span class="s1">${JSON.stringify(key)} </span><span class="s3">should not start with &quot;$&quot; or &quot;_&quot; which are reserved prefixes for Vue internals.`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">return;</span>
      <span class="s1">}</span>
      <span class="s1">Object.defineProperty(ctx</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">{</span>
        <span class="s1">enumerable: </span><span class="s2">true,</span>
        <span class="s1">configurable: </span><span class="s2">true,</span>
        <span class="s1">get: () =&gt; setupState[key]</span><span class="s2">,</span>
        <span class="s1">set: NOOP</span>
      <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">})</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createDuplicateChecker() {</span>
  <span class="s2">const </span><span class="s1">cache = </span><span class="s0">/* @__PURE__ */ </span><span class="s1">Object.create(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s2">return </span><span class="s1">(type</span><span class="s2">, </span><span class="s1">key) =&gt; {</span>
    <span class="s2">if </span><span class="s1">(cache[key]) {</span>
      <span class="s1">warn2(</span><span class="s3">`</span><span class="s1">${type} </span><span class="s3">property &quot;</span><span class="s1">${key}</span><span class="s3">&quot; is already defined in </span><span class="s1">${cache[key]}</span><span class="s3">.`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">cache[key] = type</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">shouldCacheAccess = </span><span class="s2">true;</span>
<span class="s2">function </span><span class="s1">applyOptions(instance) {</span>
  <span class="s2">const </span><span class="s1">options = resolveMergedOptions(instance)</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">publicThis = instance.proxy</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">ctx = instance.ctx</span><span class="s2">;</span>
  <span class="s1">shouldCacheAccess = </span><span class="s2">false;</span>
  <span class="s2">if </span><span class="s1">(options.beforeCreate) {</span>
    <span class="s1">callHook(</span>
      <span class="s1">options.beforeCreate</span><span class="s2">,</span>
      <span class="s1">instance</span><span class="s2">,</span>
      <span class="s3">&quot;bc&quot;</span>
      <span class="s0">/* LifecycleHooks.BEFORE_CREATE */</span>
    <span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">const </span><span class="s1">{</span>
    <span class="s0">// state</span>
    <span class="s1">data: dataOptions</span><span class="s2">,</span>
    <span class="s1">computed: computedOptions</span><span class="s2">,</span>
    <span class="s1">methods</span><span class="s2">,</span>
    <span class="s1">watch: watchOptions</span><span class="s2">,</span>
    <span class="s1">provide: provideOptions</span><span class="s2">,</span>
    <span class="s1">inject: injectOptions</span><span class="s2">,</span>
    <span class="s0">// lifecycle</span>
    <span class="s1">created</span><span class="s2">,</span>
    <span class="s1">beforeMount</span><span class="s2">,</span>
    <span class="s1">mounted</span><span class="s2">,</span>
    <span class="s1">beforeUpdate</span><span class="s2">,</span>
    <span class="s1">updated</span><span class="s2">,</span>
    <span class="s1">activated</span><span class="s2">,</span>
    <span class="s1">deactivated</span><span class="s2">,</span>
    <span class="s1">beforeDestroy</span><span class="s2">,</span>
    <span class="s1">beforeUnmount</span><span class="s2">,</span>
    <span class="s1">destroyed</span><span class="s2">,</span>
    <span class="s1">unmounted</span><span class="s2">,</span>
    <span class="s1">render: render2</span><span class="s2">,</span>
    <span class="s1">renderTracked</span><span class="s2">,</span>
    <span class="s1">renderTriggered</span><span class="s2">,</span>
    <span class="s1">errorCaptured</span><span class="s2">,</span>
    <span class="s1">serverPrefetch</span><span class="s2">,</span>
    <span class="s0">// public API</span>
    <span class="s1">expose</span><span class="s2">,</span>
    <span class="s1">inheritAttrs</span><span class="s2">,</span>
    <span class="s0">// assets</span>
    <span class="s1">components</span><span class="s2">,</span>
    <span class="s1">directives</span><span class="s2">,</span>
    <span class="s1">filters</span>
  <span class="s1">} = options</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">checkDuplicateProperties = </span><span class="s2">true </span><span class="s1">? createDuplicateChecker() : </span><span class="s2">null;</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s2">const </span><span class="s1">[propsOptions] = instance.propsOptions</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(propsOptions) {</span>
      <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">propsOptions) {</span>
        <span class="s1">checkDuplicateProperties(</span><span class="s3">&quot;Props&quot;</span><span class="s2">, </span><span class="s1">key)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(injectOptions) {</span>
    <span class="s1">resolveInjections(injectOptions</span><span class="s2">, </span><span class="s1">ctx</span><span class="s2">, </span><span class="s1">checkDuplicateProperties</span><span class="s2">, </span><span class="s1">instance.appContext.config.unwrapInjectedRef)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(methods) {</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">methods) {</span>
      <span class="s2">const </span><span class="s1">methodHandler = methods[key]</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(isFunction(methodHandler)) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
          <span class="s1">Object.defineProperty(ctx</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">{</span>
            <span class="s1">value: methodHandler.bind(publicThis)</span><span class="s2">,</span>
            <span class="s1">configurable: </span><span class="s2">true,</span>
            <span class="s1">enumerable: </span><span class="s2">true,</span>
            <span class="s1">writable: </span><span class="s2">true</span>
          <span class="s1">})</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">ctx[key] = methodHandler.bind(publicThis)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
          <span class="s1">checkDuplicateProperties(</span><span class="s3">&quot;Methods&quot;</span><span class="s2">, </span><span class="s1">key)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s1">warn2(</span><span class="s3">`Method &quot;</span><span class="s1">${key}</span><span class="s3">&quot; has type &quot;</span><span class="s1">${</span><span class="s2">typeof </span><span class="s1">methodHandler}</span><span class="s3">&quot; in the component definition. Did you reference the function correctly?`</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(dataOptions) {</span>
    <span class="s2">if </span><span class="s1">(!isFunction(dataOptions)) {</span>
      <span class="s1">warn2(</span><span class="s3">`The data option must be a function. Plain object usage is no longer supported.`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">data = dataOptions.call(publicThis</span><span class="s2">, </span><span class="s1">publicThis)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(isPromise(data)) {</span>
      <span class="s1">warn2(</span><span class="s3">`data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + &lt;Suspense&gt;.`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(!isObject(data)) {</span>
      <span class="s1">warn2(</span><span class="s3">`data() should return an object.`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">instance.data = reactive(data)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">data) {</span>
          <span class="s1">checkDuplicateProperties(</span><span class="s3">&quot;Data&quot;</span><span class="s2">, </span><span class="s1">key)</span><span class="s2">;</span>
          <span class="s2">if </span><span class="s1">(!isReservedPrefix(key[</span><span class="s4">0</span><span class="s1">])) {</span>
            <span class="s1">Object.defineProperty(ctx</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">{</span>
              <span class="s1">configurable: </span><span class="s2">true,</span>
              <span class="s1">enumerable: </span><span class="s2">true,</span>
              <span class="s1">get: () =&gt; data[key]</span><span class="s2">,</span>
              <span class="s1">set: NOOP</span>
            <span class="s1">})</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">shouldCacheAccess = </span><span class="s2">true;</span>
  <span class="s2">if </span><span class="s1">(computedOptions) {</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">computedOptions) {</span>
      <span class="s2">const </span><span class="s1">opt = computedOptions[key]</span><span class="s2">;</span>
      <span class="s2">const </span><span class="s1">get2 = isFunction(opt) ? opt.bind(publicThis</span><span class="s2">, </span><span class="s1">publicThis) : isFunction(opt.get) ? opt.get.bind(publicThis</span><span class="s2">, </span><span class="s1">publicThis) : NOOP</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(get2 === NOOP) {</span>
        <span class="s1">warn2(</span><span class="s3">`Computed property &quot;</span><span class="s1">${key}</span><span class="s3">&quot; has no getter.`</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">const </span><span class="s1">set2 = !isFunction(opt) &amp;&amp; isFunction(opt.set) ? opt.set.bind(publicThis) : </span><span class="s2">true </span><span class="s1">? () =&gt; {</span>
        <span class="s1">warn2(</span><span class="s3">`Write operation failed: computed property &quot;</span><span class="s1">${key}</span><span class="s3">&quot; is readonly.`</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">} : NOOP</span><span class="s2">;</span>
      <span class="s2">const </span><span class="s1">c = computed2({</span>
        <span class="s1">get: get2</span><span class="s2">,</span>
        <span class="s1">set: set2</span>
      <span class="s1">})</span><span class="s2">;</span>
      <span class="s1">Object.defineProperty(ctx</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">{</span>
        <span class="s1">enumerable: </span><span class="s2">true,</span>
        <span class="s1">configurable: </span><span class="s2">true,</span>
        <span class="s1">get: () =&gt; c.value</span><span class="s2">,</span>
        <span class="s1">set: (v) =&gt; c.value = v</span>
      <span class="s1">})</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s1">checkDuplicateProperties(</span><span class="s3">&quot;Computed&quot;</span><span class="s2">, </span><span class="s1">key)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(watchOptions) {</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">watchOptions) {</span>
      <span class="s1">createWatcher(watchOptions[key]</span><span class="s2">, </span><span class="s1">ctx</span><span class="s2">, </span><span class="s1">publicThis</span><span class="s2">, </span><span class="s1">key)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(provideOptions) {</span>
    <span class="s2">const </span><span class="s1">provides = isFunction(provideOptions) ? provideOptions.call(publicThis) : provideOptions</span><span class="s2">;</span>
    <span class="s1">Reflect.ownKeys(provides).forEach((key) =&gt; {</span>
      <span class="s1">provide(key</span><span class="s2">, </span><span class="s1">provides[key])</span><span class="s2">;</span>
    <span class="s1">})</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(created) {</span>
    <span class="s1">callHook(</span>
      <span class="s1">created</span><span class="s2">,</span>
      <span class="s1">instance</span><span class="s2">,</span>
      <span class="s3">&quot;c&quot;</span>
      <span class="s0">/* LifecycleHooks.CREATED */</span>
    <span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">registerLifecycleHook(register</span><span class="s2">, </span><span class="s1">hook) {</span>
    <span class="s2">if </span><span class="s1">(isArray(hook)) {</span>
      <span class="s1">hook.forEach((_hook) =&gt; register(_hook.bind(publicThis)))</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(hook) {</span>
      <span class="s1">register(hook.bind(publicThis))</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">registerLifecycleHook(onBeforeMount</span><span class="s2">, </span><span class="s1">beforeMount)</span><span class="s2">;</span>
  <span class="s1">registerLifecycleHook(onMounted</span><span class="s2">, </span><span class="s1">mounted)</span><span class="s2">;</span>
  <span class="s1">registerLifecycleHook(onBeforeUpdate</span><span class="s2">, </span><span class="s1">beforeUpdate)</span><span class="s2">;</span>
  <span class="s1">registerLifecycleHook(onUpdated</span><span class="s2">, </span><span class="s1">updated)</span><span class="s2">;</span>
  <span class="s1">registerLifecycleHook(onActivated</span><span class="s2">, </span><span class="s1">activated)</span><span class="s2">;</span>
  <span class="s1">registerLifecycleHook(onDeactivated</span><span class="s2">, </span><span class="s1">deactivated)</span><span class="s2">;</span>
  <span class="s1">registerLifecycleHook(onErrorCaptured</span><span class="s2">, </span><span class="s1">errorCaptured)</span><span class="s2">;</span>
  <span class="s1">registerLifecycleHook(onRenderTracked</span><span class="s2">, </span><span class="s1">renderTracked)</span><span class="s2">;</span>
  <span class="s1">registerLifecycleHook(onRenderTriggered</span><span class="s2">, </span><span class="s1">renderTriggered)</span><span class="s2">;</span>
  <span class="s1">registerLifecycleHook(onBeforeUnmount</span><span class="s2">, </span><span class="s1">beforeUnmount)</span><span class="s2">;</span>
  <span class="s1">registerLifecycleHook(onUnmounted</span><span class="s2">, </span><span class="s1">unmounted)</span><span class="s2">;</span>
  <span class="s1">registerLifecycleHook(onServerPrefetch</span><span class="s2">, </span><span class="s1">serverPrefetch)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(isArray(expose)) {</span>
    <span class="s2">if </span><span class="s1">(expose.length) {</span>
      <span class="s2">const </span><span class="s1">exposed = instance.exposed || (instance.exposed = {})</span><span class="s2">;</span>
      <span class="s1">expose.forEach((key) =&gt; {</span>
        <span class="s1">Object.defineProperty(exposed</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">{</span>
          <span class="s1">get: () =&gt; publicThis[key]</span><span class="s2">,</span>
          <span class="s1">set: (val) =&gt; publicThis[key] = val</span>
        <span class="s1">})</span><span class="s2">;</span>
      <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!instance.exposed) {</span>
      <span class="s1">instance.exposed = {}</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(render2 &amp;&amp; instance.render === NOOP) {</span>
    <span class="s1">instance.render = render2</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(inheritAttrs != </span><span class="s2">null</span><span class="s1">) {</span>
    <span class="s1">instance.inheritAttrs = inheritAttrs</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(components)</span>
    <span class="s1">instance.components = components</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(directives)</span>
    <span class="s1">instance.directives = directives</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">resolveInjections(injectOptions</span><span class="s2">, </span><span class="s1">ctx</span><span class="s2">, </span><span class="s1">checkDuplicateProperties = NOOP</span><span class="s2">, </span><span class="s1">unwrapRef = </span><span class="s2">false</span><span class="s1">) {</span>
  <span class="s2">if </span><span class="s1">(isArray(injectOptions)) {</span>
    <span class="s1">injectOptions = normalizeInject(injectOptions)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">injectOptions) {</span>
    <span class="s2">const </span><span class="s1">opt = injectOptions[key]</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">injected</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(isObject(opt)) {</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s3">&quot;default&quot; </span><span class="s2">in </span><span class="s1">opt) {</span>
        <span class="s1">injected = inject(</span>
          <span class="s1">opt.from || key</span><span class="s2">,</span>
          <span class="s1">opt.default</span><span class="s2">,</span>
          <span class="s2">true</span>
          <span class="s0">/* treat default function as factory */</span>
        <span class="s1">)</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">injected = inject(opt.from || key)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">injected = inject(opt)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(isRef(injected)) {</span>
      <span class="s2">if </span><span class="s1">(unwrapRef) {</span>
        <span class="s1">Object.defineProperty(ctx</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">{</span>
          <span class="s1">enumerable: </span><span class="s2">true,</span>
          <span class="s1">configurable: </span><span class="s2">true,</span>
          <span class="s1">get: () =&gt; injected.value</span><span class="s2">,</span>
          <span class="s1">set: (v) =&gt; injected.value = v</span>
        <span class="s1">})</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
          <span class="s1">warn2(</span><span class="s3">`injected property &quot;</span><span class="s1">${key}</span><span class="s3">&quot; is a ref and will be auto-unwrapped and no longer needs </span><span class="s2">\`</span><span class="s3">.value</span><span class="s2">\` </span><span class="s3">in the next minor release. To opt-in to the new behavior now, set </span><span class="s2">\`</span><span class="s3">app.config.unwrapInjectedRef = true</span><span class="s2">\` </span><span class="s3">(this config is temporary and will not be needed in the future.)`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">ctx[key] = injected</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">ctx[key] = injected</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
      <span class="s1">checkDuplicateProperties(</span><span class="s3">&quot;Inject&quot;</span><span class="s2">, </span><span class="s1">key)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">callHook(hook</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s1">type) {</span>
  <span class="s1">callWithAsyncErrorHandling(isArray(hook) ? hook.map((h2) =&gt; h2.bind(instance.proxy)) : hook.bind(instance.proxy)</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s1">type)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createWatcher(raw</span><span class="s2">, </span><span class="s1">ctx</span><span class="s2">, </span><span class="s1">publicThis</span><span class="s2">, </span><span class="s1">key) {</span>
  <span class="s2">const </span><span class="s1">getter = key.includes(</span><span class="s3">&quot;.&quot;</span><span class="s1">) ? createPathGetter(publicThis</span><span class="s2">, </span><span class="s1">key) : () =&gt; publicThis[key]</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(isString(raw)) {</span>
    <span class="s2">const </span><span class="s1">handler = ctx[raw]</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(isFunction(handler)) {</span>
      <span class="s1">watch(getter</span><span class="s2">, </span><span class="s1">handler)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
      <span class="s1">warn2(</span><span class="s3">`Invalid watch handler specified by key &quot;</span><span class="s1">${raw}</span><span class="s3">&quot;`</span><span class="s2">, </span><span class="s1">handler)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isFunction(raw)) {</span>
    <span class="s1">watch(getter</span><span class="s2">, </span><span class="s1">raw.bind(publicThis))</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isObject(raw)) {</span>
    <span class="s2">if </span><span class="s1">(isArray(raw)) {</span>
      <span class="s1">raw.forEach((r) =&gt; createWatcher(r</span><span class="s2">, </span><span class="s1">ctx</span><span class="s2">, </span><span class="s1">publicThis</span><span class="s2">, </span><span class="s1">key))</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">const </span><span class="s1">handler = isFunction(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler]</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(isFunction(handler)) {</span>
        <span class="s1">watch(getter</span><span class="s2">, </span><span class="s1">handler</span><span class="s2">, </span><span class="s1">raw)</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s1">warn2(</span><span class="s3">`Invalid watch handler specified by key &quot;</span><span class="s1">${raw.handler}</span><span class="s3">&quot;`</span><span class="s2">, </span><span class="s1">handler)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s1">warn2(</span><span class="s3">`Invalid watch option: &quot;</span><span class="s1">${key}</span><span class="s3">&quot;`</span><span class="s2">, </span><span class="s1">raw)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">resolveMergedOptions(instance) {</span>
  <span class="s2">const </span><span class="s1">base = instance.type</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">{ mixins</span><span class="s2">, extends</span><span class="s1">: extendsOptions } = base</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">{ mixins: globalMixins</span><span class="s2">, </span><span class="s1">optionsCache: cache</span><span class="s2">, </span><span class="s1">config: { optionMergeStrategies } } = instance.appContext</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">cached = cache.get(base)</span><span class="s2">;</span>
  <span class="s2">let </span><span class="s1">resolved</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(cached) {</span>
    <span class="s1">resolved = cached</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!globalMixins.length &amp;&amp; !mixins &amp;&amp; !extendsOptions) {</span>
    <span class="s1">{</span>
      <span class="s1">resolved = base</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s1">resolved = {}</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(globalMixins.length) {</span>
      <span class="s1">globalMixins.forEach((m) =&gt; mergeOptions(resolved</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">optionMergeStrategies</span><span class="s2">, true</span><span class="s1">))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">mergeOptions(resolved</span><span class="s2">, </span><span class="s1">base</span><span class="s2">, </span><span class="s1">optionMergeStrategies)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(isObject(base)) {</span>
    <span class="s1">cache.set(base</span><span class="s2">, </span><span class="s1">resolved)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">resolved</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">mergeOptions(to</span><span class="s2">, </span><span class="s1">from</span><span class="s2">, </span><span class="s1">strats</span><span class="s2">, </span><span class="s1">asMixin = </span><span class="s2">false</span><span class="s1">) {</span>
  <span class="s2">const </span><span class="s1">{ mixins</span><span class="s2">, extends</span><span class="s1">: extendsOptions } = from</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(extendsOptions) {</span>
    <span class="s1">mergeOptions(to</span><span class="s2">, </span><span class="s1">extendsOptions</span><span class="s2">, </span><span class="s1">strats</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(mixins) {</span>
    <span class="s1">mixins.forEach((m) =&gt; mergeOptions(to</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">strats</span><span class="s2">, true</span><span class="s1">))</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">from) {</span>
    <span class="s2">if </span><span class="s1">(asMixin &amp;&amp; key === </span><span class="s3">&quot;expose&quot;</span><span class="s1">) {</span>
      <span class="s1">warn2(</span><span class="s3">`&quot;expose&quot; option is ignored when declared in mixins or extends. It should only be declared in the base component itself.`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">const </span><span class="s1">strat = internalOptionMergeStrats[key] || strats &amp;&amp; strats[key]</span><span class="s2">;</span>
      <span class="s1">to[key] = strat ? strat(to[key]</span><span class="s2">, </span><span class="s1">from[key]) : from[key]</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">to</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">internalOptionMergeStrats = {</span>
  <span class="s1">data: mergeDataFn</span><span class="s2">,</span>
  <span class="s1">props: mergeObjectOptions</span><span class="s2">,</span>
  <span class="s1">emits: mergeObjectOptions</span><span class="s2">,</span>
  <span class="s0">// objects</span>
  <span class="s1">methods: mergeObjectOptions</span><span class="s2">,</span>
  <span class="s1">computed: mergeObjectOptions</span><span class="s2">,</span>
  <span class="s0">// lifecycle</span>
  <span class="s1">beforeCreate: mergeAsArray</span><span class="s2">,</span>
  <span class="s1">created: mergeAsArray</span><span class="s2">,</span>
  <span class="s1">beforeMount: mergeAsArray</span><span class="s2">,</span>
  <span class="s1">mounted: mergeAsArray</span><span class="s2">,</span>
  <span class="s1">beforeUpdate: mergeAsArray</span><span class="s2">,</span>
  <span class="s1">updated: mergeAsArray</span><span class="s2">,</span>
  <span class="s1">beforeDestroy: mergeAsArray</span><span class="s2">,</span>
  <span class="s1">beforeUnmount: mergeAsArray</span><span class="s2">,</span>
  <span class="s1">destroyed: mergeAsArray</span><span class="s2">,</span>
  <span class="s1">unmounted: mergeAsArray</span><span class="s2">,</span>
  <span class="s1">activated: mergeAsArray</span><span class="s2">,</span>
  <span class="s1">deactivated: mergeAsArray</span><span class="s2">,</span>
  <span class="s1">errorCaptured: mergeAsArray</span><span class="s2">,</span>
  <span class="s1">serverPrefetch: mergeAsArray</span><span class="s2">,</span>
  <span class="s0">// assets</span>
  <span class="s1">components: mergeObjectOptions</span><span class="s2">,</span>
  <span class="s1">directives: mergeObjectOptions</span><span class="s2">,</span>
  <span class="s0">// watch</span>
  <span class="s1">watch: mergeWatchOptions</span><span class="s2">,</span>
  <span class="s0">// provide / inject</span>
  <span class="s1">provide: mergeDataFn</span><span class="s2">,</span>
  <span class="s1">inject: mergeInject</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">mergeDataFn(to</span><span class="s2">, </span><span class="s1">from) {</span>
  <span class="s2">if </span><span class="s1">(!from) {</span>
    <span class="s2">return </span><span class="s1">to</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(!to) {</span>
    <span class="s2">return </span><span class="s1">from</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return function </span><span class="s1">mergedDataFn() {</span>
    <span class="s2">return </span><span class="s1">extend(isFunction(to) ? to.call(</span><span class="s2">this, this</span><span class="s1">) : to</span><span class="s2">, </span><span class="s1">isFunction(from) ? from.call(</span><span class="s2">this, this</span><span class="s1">) : from)</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">mergeInject(to</span><span class="s2">, </span><span class="s1">from) {</span>
  <span class="s2">return </span><span class="s1">mergeObjectOptions(normalizeInject(to)</span><span class="s2">, </span><span class="s1">normalizeInject(from))</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">normalizeInject(raw) {</span>
  <span class="s2">if </span><span class="s1">(isArray(raw)) {</span>
    <span class="s2">const </span><span class="s1">res = {}</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; raw.length</span><span class="s2">; </span><span class="s1">i++) {</span>
      <span class="s1">res[raw[i]] = raw[i]</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">res</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">raw</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">mergeAsArray(to</span><span class="s2">, </span><span class="s1">from) {</span>
  <span class="s2">return </span><span class="s1">to ? [...</span><span class="s2">new </span><span class="s1">Set([].concat(to</span><span class="s2">, </span><span class="s1">from))] : from</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">mergeObjectOptions(to</span><span class="s2">, </span><span class="s1">from) {</span>
  <span class="s2">return </span><span class="s1">to ? extend(extend(</span><span class="s0">/* @__PURE__ */ </span><span class="s1">Object.create(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">, </span><span class="s1">to)</span><span class="s2">, </span><span class="s1">from) : from</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">mergeWatchOptions(to</span><span class="s2">, </span><span class="s1">from) {</span>
  <span class="s2">if </span><span class="s1">(!to)</span>
    <span class="s2">return </span><span class="s1">from</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(!from)</span>
    <span class="s2">return </span><span class="s1">to</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">merged = extend(</span><span class="s0">/* @__PURE__ */ </span><span class="s1">Object.create(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">, </span><span class="s1">to)</span><span class="s2">;</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">from) {</span>
    <span class="s1">merged[key] = mergeAsArray(to[key]</span><span class="s2">, </span><span class="s1">from[key])</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">merged</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">initProps(instance</span><span class="s2">, </span><span class="s1">rawProps</span><span class="s2">, </span><span class="s1">isStateful</span><span class="s2">, </span><span class="s1">isSSR = </span><span class="s2">false</span><span class="s1">) {</span>
  <span class="s2">const </span><span class="s1">props = {}</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">attrs = {}</span><span class="s2">;</span>
  <span class="s1">def(attrs</span><span class="s2">, </span><span class="s1">InternalObjectKey</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">instance.propsDefaults = </span><span class="s0">/* @__PURE__ */ </span><span class="s1">Object.create(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">setFullProps(instance</span><span class="s2">, </span><span class="s1">rawProps</span><span class="s2">, </span><span class="s1">props</span><span class="s2">, </span><span class="s1">attrs)</span><span class="s2">;</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">instance.propsOptions[</span><span class="s4">0</span><span class="s1">]) {</span>
    <span class="s2">if </span><span class="s1">(!(key </span><span class="s2">in </span><span class="s1">props)) {</span>
      <span class="s1">props[key] = </span><span class="s2">void </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s1">validateProps(rawProps || {}</span><span class="s2">, </span><span class="s1">props</span><span class="s2">, </span><span class="s1">instance)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(isStateful) {</span>
    <span class="s1">instance.props = isSSR ? props : shallowReactive(props)</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s2">if </span><span class="s1">(!instance.type.props) {</span>
      <span class="s1">instance.props = attrs</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">instance.props = props</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">instance.attrs = attrs</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isInHmrContext(instance) {</span>
  <span class="s2">while </span><span class="s1">(instance) {</span>
    <span class="s2">if </span><span class="s1">(instance.type.__hmrId)</span>
      <span class="s2">return true;</span>
    <span class="s1">instance = instance.parent</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">updateProps(instance</span><span class="s2">, </span><span class="s1">rawProps</span><span class="s2">, </span><span class="s1">rawPrevProps</span><span class="s2">, </span><span class="s1">optimized) {</span>
  <span class="s2">const </span><span class="s1">{ props</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">, </span><span class="s1">vnode: { patchFlag } } = instance</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">rawCurrentProps = toRaw(props)</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">[options] = instance.propsOptions</span><span class="s2">;</span>
  <span class="s2">let </span><span class="s1">hasAttrsChanged = </span><span class="s2">false;</span>
  <span class="s2">if </span><span class="s1">(</span>
    <span class="s0">// always force full diff in dev</span>
    <span class="s0">// - #1942 if hmr is enabled with sfc component</span>
    <span class="s0">// - vite#872 non-sfc component used by sfc component</span>
    <span class="s1">!isInHmrContext(instance) &amp;&amp; (optimized || patchFlag &gt; </span><span class="s4">0</span><span class="s1">) &amp;&amp; !(patchFlag &amp; </span><span class="s4">16</span><span class="s1">)</span>
  <span class="s1">) {</span>
    <span class="s2">if </span><span class="s1">(patchFlag &amp; </span><span class="s4">8</span><span class="s1">) {</span>
      <span class="s2">const </span><span class="s1">propsToUpdate = instance.vnode.dynamicProps</span><span class="s2">;</span>
      <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; propsToUpdate.length</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s2">let </span><span class="s1">key = propsToUpdate[i]</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(isEmitListener(instance.emitsOptions</span><span class="s2">, </span><span class="s1">key)) {</span>
          <span class="s2">continue;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">value = rawProps[key]</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(options) {</span>
          <span class="s2">if </span><span class="s1">(hasOwn(attrs</span><span class="s2">, </span><span class="s1">key)) {</span>
            <span class="s2">if </span><span class="s1">(value !== attrs[key]) {</span>
              <span class="s1">attrs[key] = value</span><span class="s2">;</span>
              <span class="s1">hasAttrsChanged = </span><span class="s2">true;</span>
            <span class="s1">}</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s2">const </span><span class="s1">camelizedKey = camelize(key)</span><span class="s2">;</span>
            <span class="s1">props[camelizedKey] = resolvePropValue(</span>
              <span class="s1">options</span><span class="s2">,</span>
              <span class="s1">rawCurrentProps</span><span class="s2">,</span>
              <span class="s1">camelizedKey</span><span class="s2">,</span>
              <span class="s1">value</span><span class="s2">,</span>
              <span class="s1">instance</span><span class="s2">,</span>
              <span class="s2">false</span>
              <span class="s0">/* isAbsent */</span>
            <span class="s1">)</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s2">if </span><span class="s1">(value !== attrs[key]) {</span>
            <span class="s1">attrs[key] = value</span><span class="s2">;</span>
            <span class="s1">hasAttrsChanged = </span><span class="s2">true;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s2">if </span><span class="s1">(setFullProps(instance</span><span class="s2">, </span><span class="s1">rawProps</span><span class="s2">, </span><span class="s1">props</span><span class="s2">, </span><span class="s1">attrs)) {</span>
      <span class="s1">hasAttrsChanged = </span><span class="s2">true;</span>
    <span class="s1">}</span>
    <span class="s2">let </span><span class="s1">kebabKey</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">rawCurrentProps) {</span>
      <span class="s2">if </span><span class="s1">(!rawProps || </span><span class="s0">// for camelCase</span>
      <span class="s1">!hasOwn(rawProps</span><span class="s2">, </span><span class="s1">key) &amp;&amp; </span><span class="s0">// it's possible the original props was passed in as kebab-case</span>
      <span class="s0">// and converted to camelCase (#955)</span>
      <span class="s1">((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps</span><span class="s2">, </span><span class="s1">kebabKey))) {</span>
        <span class="s2">if </span><span class="s1">(options) {</span>
          <span class="s2">if </span><span class="s1">(rawPrevProps &amp;&amp; </span><span class="s0">// for camelCase</span>
          <span class="s1">(rawPrevProps[key] !== </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">|| </span><span class="s0">// for kebab-case</span>
          <span class="s1">rawPrevProps[kebabKey] !== </span><span class="s2">void </span><span class="s4">0</span><span class="s1">)) {</span>
            <span class="s1">props[key] = resolvePropValue(</span>
              <span class="s1">options</span><span class="s2">,</span>
              <span class="s1">rawCurrentProps</span><span class="s2">,</span>
              <span class="s1">key</span><span class="s2">,</span>
              <span class="s2">void </span><span class="s4">0</span><span class="s2">,</span>
              <span class="s1">instance</span><span class="s2">,</span>
              <span class="s2">true</span>
              <span class="s0">/* isAbsent */</span>
            <span class="s1">)</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s2">delete </span><span class="s1">props[key]</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(attrs !== rawCurrentProps) {</span>
      <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">attrs) {</span>
        <span class="s2">if </span><span class="s1">(!rawProps || !hasOwn(rawProps</span><span class="s2">, </span><span class="s1">key) &amp;&amp; </span><span class="s2">true</span><span class="s1">) {</span>
          <span class="s2">delete </span><span class="s1">attrs[key]</span><span class="s2">;</span>
          <span class="s1">hasAttrsChanged = </span><span class="s2">true;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(hasAttrsChanged) {</span>
    <span class="s1">trigger(instance</span><span class="s2">, </span><span class="s3">&quot;set&quot;</span><span class="s2">, </span><span class="s3">&quot;$attrs&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s1">validateProps(rawProps || {}</span><span class="s2">, </span><span class="s1">props</span><span class="s2">, </span><span class="s1">instance)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">setFullProps(instance</span><span class="s2">, </span><span class="s1">rawProps</span><span class="s2">, </span><span class="s1">props</span><span class="s2">, </span><span class="s1">attrs) {</span>
  <span class="s2">const </span><span class="s1">[options</span><span class="s2">, </span><span class="s1">needCastKeys] = instance.propsOptions</span><span class="s2">;</span>
  <span class="s2">let </span><span class="s1">hasAttrsChanged = </span><span class="s2">false;</span>
  <span class="s2">let </span><span class="s1">rawCastValues</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(rawProps) {</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">key </span><span class="s2">in </span><span class="s1">rawProps) {</span>
      <span class="s2">if </span><span class="s1">(isReservedProp(key)) {</span>
        <span class="s2">continue;</span>
      <span class="s1">}</span>
      <span class="s2">const </span><span class="s1">value = rawProps[key]</span><span class="s2">;</span>
      <span class="s2">let </span><span class="s1">camelKey</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(options &amp;&amp; hasOwn(options</span><span class="s2">, </span><span class="s1">camelKey = camelize(key))) {</span>
        <span class="s2">if </span><span class="s1">(!needCastKeys || !needCastKeys.includes(camelKey)) {</span>
          <span class="s1">props[camelKey] = value</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">(rawCastValues || (rawCastValues = {}))[camelKey] = value</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!isEmitListener(instance.emitsOptions</span><span class="s2">, </span><span class="s1">key)) {</span>
        <span class="s2">if </span><span class="s1">(!(key </span><span class="s2">in </span><span class="s1">attrs) || value !== attrs[key]) {</span>
          <span class="s1">attrs[key] = value</span><span class="s2">;</span>
          <span class="s1">hasAttrsChanged = </span><span class="s2">true;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(needCastKeys) {</span>
    <span class="s2">const </span><span class="s1">rawCurrentProps = toRaw(props)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">castValues = rawCastValues || EMPTY_OBJ</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; needCastKeys.length</span><span class="s2">; </span><span class="s1">i++) {</span>
      <span class="s2">const </span><span class="s1">key = needCastKeys[i]</span><span class="s2">;</span>
      <span class="s1">props[key] = resolvePropValue(options</span><span class="s2">, </span><span class="s1">rawCurrentProps</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">castValues[key]</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s1">!hasOwn(castValues</span><span class="s2">, </span><span class="s1">key))</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">hasAttrsChanged</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">resolvePropValue(options</span><span class="s2">, </span><span class="s1">props</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s1">isAbsent) {</span>
  <span class="s2">const </span><span class="s1">opt = options[key]</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(opt != </span><span class="s2">null</span><span class="s1">) {</span>
    <span class="s2">const </span><span class="s1">hasDefault = hasOwn(opt</span><span class="s2">, </span><span class="s3">&quot;default&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(hasDefault &amp;&amp; value === </span><span class="s2">void </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s2">const </span><span class="s1">defaultValue = opt.default</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(opt.type !== Function &amp;&amp; isFunction(defaultValue)) {</span>
        <span class="s2">const </span><span class="s1">{ propsDefaults } = instance</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(key </span><span class="s2">in </span><span class="s1">propsDefaults) {</span>
          <span class="s1">value = propsDefaults[key]</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">setCurrentInstance(instance)</span><span class="s2">;</span>
          <span class="s1">value = propsDefaults[key] = defaultValue.call(</span><span class="s2">null, </span><span class="s1">props)</span><span class="s2">;</span>
          <span class="s1">unsetCurrentInstance()</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">value = defaultValue</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(opt[</span>
      <span class="s4">0</span>
      <span class="s0">/* BooleanFlags.shouldCast */</span>
    <span class="s1">]) {</span>
      <span class="s2">if </span><span class="s1">(isAbsent &amp;&amp; !hasDefault) {</span>
        <span class="s1">value = </span><span class="s2">false;</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(opt[</span>
        <span class="s4">1</span>
        <span class="s0">/* BooleanFlags.shouldCastTrue */</span>
      <span class="s1">] &amp;&amp; (value === </span><span class="s3">&quot;&quot; </span><span class="s1">|| value === hyphenate(key))) {</span>
        <span class="s1">value = </span><span class="s2">true;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">value</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">normalizePropsOptions(comp</span><span class="s2">, </span><span class="s1">appContext</span><span class="s2">, </span><span class="s1">asMixin = </span><span class="s2">false</span><span class="s1">) {</span>
  <span class="s2">const </span><span class="s1">cache = appContext.propsCache</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">cached = cache.get(comp)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(cached) {</span>
    <span class="s2">return </span><span class="s1">cached</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">const </span><span class="s1">raw = comp.props</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">normalized = {}</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">needCastKeys = []</span><span class="s2">;</span>
  <span class="s2">let </span><span class="s1">hasExtends = </span><span class="s2">false;</span>
  <span class="s2">if </span><span class="s1">(__VUE_OPTIONS_API__ &amp;&amp; !isFunction(comp)) {</span>
    <span class="s2">const </span><span class="s1">extendProps = (raw2) =&gt; {</span>
      <span class="s1">hasExtends = </span><span class="s2">true;</span>
      <span class="s2">const </span><span class="s1">[props</span><span class="s2">, </span><span class="s1">keys] = normalizePropsOptions(raw2</span><span class="s2">, </span><span class="s1">appContext</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">extend(normalized</span><span class="s2">, </span><span class="s1">props)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(keys)</span>
        <span class="s1">needCastKeys.push(...keys)</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!asMixin &amp;&amp; appContext.mixins.length) {</span>
      <span class="s1">appContext.mixins.forEach(extendProps)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(comp.extends) {</span>
      <span class="s1">extendProps(comp.extends)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(comp.mixins) {</span>
      <span class="s1">comp.mixins.forEach(extendProps)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(!raw &amp;&amp; !hasExtends) {</span>
    <span class="s2">if </span><span class="s1">(isObject(comp)) {</span>
      <span class="s1">cache.set(comp</span><span class="s2">, </span><span class="s1">EMPTY_ARR)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">EMPTY_ARR</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(isArray(raw)) {</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; raw.length</span><span class="s2">; </span><span class="s1">i++) {</span>
      <span class="s2">if </span><span class="s1">(!isString(raw[i])) {</span>
        <span class="s1">warn2(</span><span class="s3">`props must be strings when using array syntax.`</span><span class="s2">, </span><span class="s1">raw[i])</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">const </span><span class="s1">normalizedKey = camelize(raw[i])</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(validatePropName(normalizedKey)) {</span>
        <span class="s1">normalized[normalizedKey] = EMPTY_OBJ</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(raw) {</span>
    <span class="s2">if </span><span class="s1">(!isObject(raw)) {</span>
      <span class="s1">warn2(</span><span class="s3">`invalid props options`</span><span class="s2">, </span><span class="s1">raw)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">raw) {</span>
      <span class="s2">const </span><span class="s1">normalizedKey = camelize(key)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(validatePropName(normalizedKey)) {</span>
        <span class="s2">const </span><span class="s1">opt = raw[key]</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">prop = normalized[normalizedKey] = isArray(opt) || isFunction(opt) ? { type: opt } : Object.assign({}</span><span class="s2">, </span><span class="s1">opt)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(prop) {</span>
          <span class="s2">const </span><span class="s1">booleanIndex = getTypeIndex(Boolean</span><span class="s2">, </span><span class="s1">prop.type)</span><span class="s2">;</span>
          <span class="s2">const </span><span class="s1">stringIndex = getTypeIndex(String</span><span class="s2">, </span><span class="s1">prop.type)</span><span class="s2">;</span>
          <span class="s1">prop[</span>
            <span class="s4">0</span>
            <span class="s0">/* BooleanFlags.shouldCast */</span>
          <span class="s1">] = booleanIndex &gt; -</span><span class="s4">1</span><span class="s2">;</span>
          <span class="s1">prop[</span>
            <span class="s4">1</span>
            <span class="s0">/* BooleanFlags.shouldCastTrue */</span>
          <span class="s1">] = stringIndex &lt; </span><span class="s4">0 </span><span class="s1">|| booleanIndex &lt; stringIndex</span><span class="s2">;</span>
          <span class="s2">if </span><span class="s1">(booleanIndex &gt; -</span><span class="s4">1 </span><span class="s1">|| hasOwn(prop</span><span class="s2">, </span><span class="s3">&quot;default&quot;</span><span class="s1">)) {</span>
            <span class="s1">needCastKeys.push(normalizedKey)</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">const </span><span class="s1">res = [normalized</span><span class="s2">, </span><span class="s1">needCastKeys]</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(isObject(comp)) {</span>
    <span class="s1">cache.set(comp</span><span class="s2">, </span><span class="s1">res)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">res</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">validatePropName(key) {</span>
  <span class="s2">if </span><span class="s1">(key[</span><span class="s4">0</span><span class="s1">] !== </span><span class="s3">&quot;$&quot;</span><span class="s1">) {</span>
    <span class="s2">return true;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s1">warn2(</span><span class="s3">`Invalid prop name: &quot;</span><span class="s1">${key}</span><span class="s3">&quot; is a reserved property.`</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return false;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getType(ctor) {</span>
  <span class="s2">const </span><span class="s1">match = ctor &amp;&amp; ctor.toString().match(</span><span class="s4">/^\s*(function|class) (\w+)/</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s2">return </span><span class="s1">match ? match[</span><span class="s4">2</span><span class="s1">] : ctor === </span><span class="s2">null </span><span class="s1">? </span><span class="s3">&quot;null&quot; </span><span class="s1">: </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isSameType(a</span><span class="s2">, </span><span class="s1">b) {</span>
  <span class="s2">return </span><span class="s1">getType(a) === getType(b)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getTypeIndex(type</span><span class="s2">, </span><span class="s1">expectedTypes) {</span>
  <span class="s2">if </span><span class="s1">(isArray(expectedTypes)) {</span>
    <span class="s2">return </span><span class="s1">expectedTypes.findIndex((t) =&gt; isSameType(t</span><span class="s2">, </span><span class="s1">type))</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isFunction(expectedTypes)) {</span>
    <span class="s2">return </span><span class="s1">isSameType(expectedTypes</span><span class="s2">, </span><span class="s1">type) ? </span><span class="s4">0 </span><span class="s1">: -</span><span class="s4">1</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">-</span><span class="s4">1</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">validateProps(rawProps</span><span class="s2">, </span><span class="s1">props</span><span class="s2">, </span><span class="s1">instance) {</span>
  <span class="s2">const </span><span class="s1">resolvedValues = toRaw(props)</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">options = instance.propsOptions[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">;</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">options) {</span>
    <span class="s2">let </span><span class="s1">opt = options[key]</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(opt == </span><span class="s2">null</span><span class="s1">)</span>
      <span class="s2">continue;</span>
    <span class="s1">validateProp(key</span><span class="s2">, </span><span class="s1">resolvedValues[key]</span><span class="s2">, </span><span class="s1">opt</span><span class="s2">, </span><span class="s1">!hasOwn(rawProps</span><span class="s2">, </span><span class="s1">key) &amp;&amp; !hasOwn(rawProps</span><span class="s2">, </span><span class="s1">hyphenate(key)))</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">validateProp(name</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">prop</span><span class="s2">, </span><span class="s1">isAbsent) {</span>
  <span class="s2">const </span><span class="s1">{ type</span><span class="s2">, </span><span class="s1">required</span><span class="s2">, </span><span class="s1">validator } = prop</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(required &amp;&amp; isAbsent) {</span>
    <span class="s1">warn2(</span><span class="s3">'Missing required prop: &quot;' </span><span class="s1">+ name + </span><span class="s3">'&quot;'</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">return;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(value == </span><span class="s2">null </span><span class="s1">&amp;&amp; !prop.required) {</span>
    <span class="s2">return;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(type != </span><span class="s2">null </span><span class="s1">&amp;&amp; type !== </span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s2">let </span><span class="s1">isValid = </span><span class="s2">false;</span>
    <span class="s2">const </span><span class="s1">types = isArray(type) ? type : [type]</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">expectedTypes = []</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; types.length &amp;&amp; !isValid</span><span class="s2">; </span><span class="s1">i++) {</span>
      <span class="s2">const </span><span class="s1">{ valid</span><span class="s2">, </span><span class="s1">expectedType } = assertType(value</span><span class="s2">, </span><span class="s1">types[i])</span><span class="s2">;</span>
      <span class="s1">expectedTypes.push(expectedType || </span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">isValid = valid</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(!isValid) {</span>
      <span class="s1">warn2(getInvalidTypeMessage(name</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">expectedTypes))</span><span class="s2">;</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(validator &amp;&amp; !validator(value)) {</span>
    <span class="s1">warn2(</span><span class="s3">'Invalid prop: custom validator check failed for prop &quot;' </span><span class="s1">+ name + </span><span class="s3">'&quot;.'</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">isSimpleType = makeMap(</span><span class="s3">&quot;String,Number,Boolean,Function,Symbol,BigInt&quot;</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">assertType(value</span><span class="s2">, </span><span class="s1">type) {</span>
  <span class="s2">let </span><span class="s1">valid</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">expectedType = getType(type)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(isSimpleType(expectedType)) {</span>
    <span class="s2">const </span><span class="s1">t = </span><span class="s2">typeof </span><span class="s1">value</span><span class="s2">;</span>
    <span class="s1">valid = t === expectedType.toLowerCase()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!valid &amp;&amp; t === </span><span class="s3">&quot;object&quot;</span><span class="s1">) {</span>
      <span class="s1">valid = value </span><span class="s2">instanceof </span><span class="s1">type</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(expectedType === </span><span class="s3">&quot;Object&quot;</span><span class="s1">) {</span>
    <span class="s1">valid = isObject(value)</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(expectedType === </span><span class="s3">&quot;Array&quot;</span><span class="s1">) {</span>
    <span class="s1">valid = isArray(value)</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(expectedType === </span><span class="s3">&quot;null&quot;</span><span class="s1">) {</span>
    <span class="s1">valid = value === </span><span class="s2">null;</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s1">valid = value </span><span class="s2">instanceof </span><span class="s1">type</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">{</span>
    <span class="s1">valid</span><span class="s2">,</span>
    <span class="s1">expectedType</span>
  <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getInvalidTypeMessage(name</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">expectedTypes) {</span>
  <span class="s2">let </span><span class="s1">message = </span><span class="s3">`Invalid prop: type check failed for prop &quot;</span><span class="s1">${name}</span><span class="s3">&quot;. Expected </span><span class="s1">${expectedTypes.map(capitalize).join(</span><span class="s3">&quot; | &quot;</span><span class="s1">)}</span><span class="s3">`</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">expectedType = expectedTypes[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">receivedType = toRawType(value)</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">expectedValue = styleValue(value</span><span class="s2">, </span><span class="s1">expectedType)</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">receivedValue = styleValue(value</span><span class="s2">, </span><span class="s1">receivedType)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(expectedTypes.length === </span><span class="s4">1 </span><span class="s1">&amp;&amp; isExplicable(expectedType) &amp;&amp; !isBoolean(expectedType</span><span class="s2">, </span><span class="s1">receivedType)) {</span>
    <span class="s1">message += </span><span class="s3">` with value </span><span class="s1">${expectedValue}</span><span class="s3">`</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s1">message += </span><span class="s3">`, got </span><span class="s1">${receivedType} </span><span class="s3">`</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(isExplicable(receivedType)) {</span>
    <span class="s1">message += </span><span class="s3">`with value </span><span class="s1">${receivedValue}</span><span class="s3">.`</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">message</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">styleValue(value</span><span class="s2">, </span><span class="s1">type) {</span>
  <span class="s2">if </span><span class="s1">(type === </span><span class="s3">&quot;String&quot;</span><span class="s1">) {</span>
    <span class="s2">return </span><span class="s3">`&quot;</span><span class="s1">${value}</span><span class="s3">&quot;`</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(type === </span><span class="s3">&quot;Number&quot;</span><span class="s1">) {</span>
    <span class="s2">return </span><span class="s3">`</span><span class="s1">${Number(value)}</span><span class="s3">`</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s2">return </span><span class="s3">`</span><span class="s1">${value}</span><span class="s3">`</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isExplicable(type) {</span>
  <span class="s2">const </span><span class="s1">explicitTypes = [</span><span class="s3">&quot;string&quot;</span><span class="s2">, </span><span class="s3">&quot;number&quot;</span><span class="s2">, </span><span class="s3">&quot;boolean&quot;</span><span class="s1">]</span><span class="s2">;</span>
  <span class="s2">return </span><span class="s1">explicitTypes.some((elem) =&gt; type.toLowerCase() === elem)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isBoolean(...args) {</span>
  <span class="s2">return </span><span class="s1">args.some((elem) =&gt; elem.toLowerCase() === </span><span class="s3">&quot;boolean&quot;</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">isInternalKey = (key) =&gt; key[</span><span class="s4">0</span><span class="s1">] === </span><span class="s3">&quot;_&quot; </span><span class="s1">|| key === </span><span class="s3">&quot;$stable&quot;</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">normalizeSlotValue = (value) =&gt; isArray(value) ? value.map(normalizeVNode) : [normalizeVNode(value)]</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">normalizeSlot = (key</span><span class="s2">, </span><span class="s1">rawSlot</span><span class="s2">, </span><span class="s1">ctx) =&gt; {</span>
  <span class="s2">if </span><span class="s1">(rawSlot._n) {</span>
    <span class="s2">return </span><span class="s1">rawSlot</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">const </span><span class="s1">normalized = withCtx((...args) =&gt; {</span>
    <span class="s2">if </span><span class="s1">(currentInstance) {</span>
      <span class="s1">warn2(</span><span class="s3">`Slot &quot;</span><span class="s1">${key}</span><span class="s3">&quot; invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">normalizeSlotValue(rawSlot(...args))</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">, </span><span class="s1">ctx)</span><span class="s2">;</span>
  <span class="s1">normalized._c = </span><span class="s2">false;</span>
  <span class="s2">return </span><span class="s1">normalized</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">normalizeObjectSlots = (rawSlots</span><span class="s2">, </span><span class="s1">slots</span><span class="s2">, </span><span class="s1">instance) =&gt; {</span>
  <span class="s2">const </span><span class="s1">ctx = rawSlots._ctx</span><span class="s2">;</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">rawSlots) {</span>
    <span class="s2">if </span><span class="s1">(isInternalKey(key))</span>
      <span class="s2">continue;</span>
    <span class="s2">const </span><span class="s1">value = rawSlots[key]</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(isFunction(value)) {</span>
      <span class="s1">slots[key] = normalizeSlot(key</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">ctx)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(value != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s1">warn2(</span><span class="s3">`Non-function value encountered for slot &quot;</span><span class="s1">${key}</span><span class="s3">&quot;. Prefer function slots for better performance.`</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">const </span><span class="s1">normalized = normalizeSlotValue(value)</span><span class="s2">;</span>
      <span class="s1">slots[key] = () =&gt; normalized</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">normalizeVNodeSlots = (instance</span><span class="s2">, </span><span class="s1">children) =&gt; {</span>
  <span class="s2">if </span><span class="s1">(!isKeepAlive(instance.vnode) &amp;&amp; </span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s1">warn2(</span><span class="s3">`Non-function value encountered for default slot. Prefer function slots for better performance.`</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">const </span><span class="s1">normalized = normalizeSlotValue(children)</span><span class="s2">;</span>
  <span class="s1">instance.slots.default = () =&gt; normalized</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">initSlots = (instance</span><span class="s2">, </span><span class="s1">children) =&gt; {</span>
  <span class="s2">if </span><span class="s1">(instance.vnode.shapeFlag &amp; </span><span class="s4">32</span><span class="s1">) {</span>
    <span class="s2">const </span><span class="s1">type = children._</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(type) {</span>
      <span class="s1">instance.slots = toRaw(children)</span><span class="s2">;</span>
      <span class="s1">def(children</span><span class="s2">, </span><span class="s3">&quot;_&quot;</span><span class="s2">, </span><span class="s1">type)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">normalizeObjectSlots(children</span><span class="s2">, </span><span class="s1">instance.slots = {})</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s1">instance.slots = {}</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(children) {</span>
      <span class="s1">normalizeVNodeSlots(instance</span><span class="s2">, </span><span class="s1">children)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">def(instance.slots</span><span class="s2">, </span><span class="s1">InternalObjectKey</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">updateSlots = (instance</span><span class="s2">, </span><span class="s1">children</span><span class="s2">, </span><span class="s1">optimized) =&gt; {</span>
  <span class="s2">const </span><span class="s1">{ vnode</span><span class="s2">, </span><span class="s1">slots } = instance</span><span class="s2">;</span>
  <span class="s2">let </span><span class="s1">needDeletionCheck = </span><span class="s2">true;</span>
  <span class="s2">let </span><span class="s1">deletionComparisonTarget = EMPTY_OBJ</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(vnode.shapeFlag &amp; </span><span class="s4">32</span><span class="s1">) {</span>
    <span class="s2">const </span><span class="s1">type = children._</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(type) {</span>
      <span class="s2">if </span><span class="s1">(isHmrUpdating) {</span>
        <span class="s1">extend(slots</span><span class="s2">, </span><span class="s1">children)</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(optimized &amp;&amp; type === </span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s1">needDeletionCheck = </span><span class="s2">false;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">extend(slots</span><span class="s2">, </span><span class="s1">children)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!optimized &amp;&amp; type === </span><span class="s4">1</span><span class="s1">) {</span>
          <span class="s2">delete </span><span class="s1">slots._</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">needDeletionCheck = !children.$stable</span><span class="s2">;</span>
      <span class="s1">normalizeObjectSlots(children</span><span class="s2">, </span><span class="s1">slots)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">deletionComparisonTarget = children</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(children) {</span>
    <span class="s1">normalizeVNodeSlots(instance</span><span class="s2">, </span><span class="s1">children)</span><span class="s2">;</span>
    <span class="s1">deletionComparisonTarget = { </span><span class="s2">default</span><span class="s1">: </span><span class="s4">1 </span><span class="s1">}</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(needDeletionCheck) {</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">slots) {</span>
      <span class="s2">if </span><span class="s1">(!isInternalKey(key) &amp;&amp; !(key </span><span class="s2">in </span><span class="s1">deletionComparisonTarget)) {</span>
        <span class="s2">delete </span><span class="s1">slots[key]</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">createAppContext() {</span>
  <span class="s2">return </span><span class="s1">{</span>
    <span class="s1">app: </span><span class="s2">null,</span>
    <span class="s1">config: {</span>
      <span class="s1">isNativeTag: NO</span><span class="s2">,</span>
      <span class="s1">performance: </span><span class="s2">false,</span>
      <span class="s1">globalProperties: {}</span><span class="s2">,</span>
      <span class="s1">optionMergeStrategies: {}</span><span class="s2">,</span>
      <span class="s1">errorHandler: </span><span class="s2">void </span><span class="s4">0</span><span class="s2">,</span>
      <span class="s1">warnHandler: </span><span class="s2">void </span><span class="s4">0</span><span class="s2">,</span>
      <span class="s1">compilerOptions: {}</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">mixins: []</span><span class="s2">,</span>
    <span class="s1">components: {}</span><span class="s2">,</span>
    <span class="s1">directives: {}</span><span class="s2">,</span>
    <span class="s1">provides: </span><span class="s0">/* @__PURE__ */ </span><span class="s1">Object.create(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">optionsCache: </span><span class="s0">/* @__PURE__ */ </span><span class="s2">new </span><span class="s1">WeakMap()</span><span class="s2">,</span>
    <span class="s1">propsCache: </span><span class="s0">/* @__PURE__ */ </span><span class="s2">new </span><span class="s1">WeakMap()</span><span class="s2">,</span>
    <span class="s1">emitsCache: </span><span class="s0">/* @__PURE__ */ </span><span class="s2">new </span><span class="s1">WeakMap()</span>
  <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">uid$1 = </span><span class="s4">0</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">createAppAPI(render2</span><span class="s2">, </span><span class="s1">hydrate2) {</span>
  <span class="s2">return function </span><span class="s1">createApp2(rootComponent</span><span class="s2">, </span><span class="s1">rootProps = </span><span class="s2">null</span><span class="s1">) {</span>
    <span class="s2">if </span><span class="s1">(!isFunction(rootComponent)) {</span>
      <span class="s1">rootComponent = Object.assign({}</span><span class="s2">, </span><span class="s1">rootComponent)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(rootProps != </span><span class="s2">null </span><span class="s1">&amp;&amp; !isObject(rootProps)) {</span>
      <span class="s1">warn2(</span><span class="s3">`root props passed to app.mount() must be an object.`</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">rootProps = </span><span class="s2">null;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">context = createAppContext()</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">installedPlugins = </span><span class="s0">/* @__PURE__ */ </span><span class="s2">new </span><span class="s1">Set()</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">isMounted = </span><span class="s2">false;</span>
    <span class="s2">const </span><span class="s1">app = context.app = {</span>
      <span class="s1">_uid: uid$1++</span><span class="s2">,</span>
      <span class="s1">_component: rootComponent</span><span class="s2">,</span>
      <span class="s1">_props: rootProps</span><span class="s2">,</span>
      <span class="s1">_container: </span><span class="s2">null,</span>
      <span class="s1">_context: context</span><span class="s2">,</span>
      <span class="s1">_instance: </span><span class="s2">null,</span>
      <span class="s1">version</span><span class="s2">,</span>
      <span class="s1">get config() {</span>
        <span class="s2">return </span><span class="s1">context.config</span><span class="s2">;</span>
      <span class="s1">}</span><span class="s2">,</span>
      <span class="s1">set config(v) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
          <span class="s1">warn2(</span><span class="s3">`app.config cannot be replaced. Modify individual options instead.`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span><span class="s2">,</span>
      <span class="s1">use(plugin</span><span class="s2">, </span><span class="s1">...options) {</span>
        <span class="s2">if </span><span class="s1">(installedPlugins.has(plugin)) {</span>
          <span class="s1">warn2(</span><span class="s3">`Plugin has already been applied to target app.`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(plugin &amp;&amp; isFunction(plugin.install)) {</span>
          <span class="s1">installedPlugins.add(plugin)</span><span class="s2">;</span>
          <span class="s1">plugin.install(app</span><span class="s2">, </span><span class="s1">...options)</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isFunction(plugin)) {</span>
          <span class="s1">installedPlugins.add(plugin)</span><span class="s2">;</span>
          <span class="s1">plugin(app</span><span class="s2">, </span><span class="s1">...options)</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
          <span class="s1">warn2(</span><span class="s3">`A plugin must either be a function or an object with an &quot;install&quot; function.`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">app</span><span class="s2">;</span>
      <span class="s1">}</span><span class="s2">,</span>
      <span class="s1">mixin(mixin) {</span>
        <span class="s2">if </span><span class="s1">(__VUE_OPTIONS_API__) {</span>
          <span class="s2">if </span><span class="s1">(!context.mixins.includes(mixin)) {</span>
            <span class="s1">context.mixins.push(mixin)</span><span class="s2">;</span>
          <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
            <span class="s1">warn2(</span><span class="s3">&quot;Mixin has already been applied to target app&quot; </span><span class="s1">+ (mixin.name ? </span><span class="s3">`: </span><span class="s1">${mixin.name}</span><span class="s3">` </span><span class="s1">: </span><span class="s3">&quot;&quot;</span><span class="s1">))</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
          <span class="s1">warn2(</span><span class="s3">&quot;Mixins are only available in builds supporting Options API&quot;</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">app</span><span class="s2">;</span>
      <span class="s1">}</span><span class="s2">,</span>
      <span class="s1">component(name</span><span class="s2">, </span><span class="s1">component) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
          <span class="s1">validateComponentName(name</span><span class="s2">, </span><span class="s1">context.config)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(!component) {</span>
          <span class="s2">return </span><span class="s1">context.components[name]</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(context.components[name]) {</span>
          <span class="s1">warn2(</span><span class="s3">`Component &quot;</span><span class="s1">${name}</span><span class="s3">&quot; has already been registered in target app.`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">context.components[name] = component</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">app</span><span class="s2">;</span>
      <span class="s1">}</span><span class="s2">,</span>
      <span class="s1">directive(name</span><span class="s2">, </span><span class="s1">directive) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
          <span class="s1">validateDirectiveName(name)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(!directive) {</span>
          <span class="s2">return </span><span class="s1">context.directives[name]</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(context.directives[name]) {</span>
          <span class="s1">warn2(</span><span class="s3">`Directive &quot;</span><span class="s1">${name}</span><span class="s3">&quot; has already been registered in target app.`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">context.directives[name] = directive</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">app</span><span class="s2">;</span>
      <span class="s1">}</span><span class="s2">,</span>
      <span class="s1">mount(rootContainer</span><span class="s2">, </span><span class="s1">isHydrate</span><span class="s2">, </span><span class="s1">isSVG) {</span>
        <span class="s2">if </span><span class="s1">(!isMounted) {</span>
          <span class="s2">if </span><span class="s1">(rootContainer.__vue_app__) {</span>
            <span class="s1">warn2(</span><span class="s3">`There is already an app instance mounted on the host container. 
 If you want to mount another app on the same host container, you need to unmount the previous app by calling </span><span class="s2">\`</span><span class="s3">app.unmount()</span><span class="s2">\` </span><span class="s3">first.`</span><span class="s1">)</span><span class="s2">;</span>
          <span class="s1">}</span>
          <span class="s2">const </span><span class="s1">vnode = createVNode(rootComponent</span><span class="s2">, </span><span class="s1">rootProps)</span><span class="s2">;</span>
          <span class="s1">vnode.appContext = context</span><span class="s2">;</span>
          <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
            <span class="s1">context.reload = () =&gt; {</span>
              <span class="s1">render2(cloneVNode(vnode)</span><span class="s2">, </span><span class="s1">rootContainer</span><span class="s2">, </span><span class="s1">isSVG)</span><span class="s2">;</span>
            <span class="s1">}</span><span class="s2">;</span>
          <span class="s1">}</span>
          <span class="s2">if </span><span class="s1">(isHydrate &amp;&amp; hydrate2) {</span>
            <span class="s1">hydrate2(vnode</span><span class="s2">, </span><span class="s1">rootContainer)</span><span class="s2">;</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">render2(vnode</span><span class="s2">, </span><span class="s1">rootContainer</span><span class="s2">, </span><span class="s1">isSVG)</span><span class="s2">;</span>
          <span class="s1">}</span>
          <span class="s1">isMounted = </span><span class="s2">true;</span>
          <span class="s1">app._container = rootContainer</span><span class="s2">;</span>
          <span class="s1">rootContainer.__vue_app__ = app</span><span class="s2">;</span>
          <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
            <span class="s1">app._instance = vnode.component</span><span class="s2">;</span>
            <span class="s1">devtoolsInitApp(app</span><span class="s2">, </span><span class="s1">version)</span><span class="s2">;</span>
          <span class="s1">}</span>
          <span class="s2">return </span><span class="s1">getExposeProxy(vnode.component) || vnode.component.proxy</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
          <span class="s1">warn2(</span><span class="s3">`App has already been mounted. 
If you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. </span><span class="s2">\`</span><span class="s3">const createMyApp = () =&gt; createApp(App)</span><span class="s2">\`</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span><span class="s2">,</span>
      <span class="s1">unmount() {</span>
        <span class="s2">if </span><span class="s1">(isMounted) {</span>
          <span class="s1">render2(</span><span class="s2">null, </span><span class="s1">app._container)</span><span class="s2">;</span>
          <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
            <span class="s1">app._instance = </span><span class="s2">null;</span>
            <span class="s1">devtoolsUnmountApp(app)</span><span class="s2">;</span>
          <span class="s1">}</span>
          <span class="s2">delete </span><span class="s1">app._container.__vue_app__</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
          <span class="s1">warn2(</span><span class="s3">`Cannot unmount an app that is not mounted.`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span><span class="s2">,</span>
      <span class="s1">provide(key</span><span class="s2">, </span><span class="s1">value) {</span>
        <span class="s2">if </span><span class="s1">(key </span><span class="s2">in </span><span class="s1">context.provides) {</span>
          <span class="s1">warn2(</span><span class="s3">`App already provides property with key &quot;</span><span class="s1">${String(key)}</span><span class="s3">&quot;. It will be overwritten with the new value.`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">context.provides[key] = value</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">app</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">app</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">setRef(rawRef</span><span class="s2">, </span><span class="s1">oldRawRef</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">isUnmount = </span><span class="s2">false</span><span class="s1">) {</span>
  <span class="s2">if </span><span class="s1">(isArray(rawRef)) {</span>
    <span class="s1">rawRef.forEach((r</span><span class="s2">, </span><span class="s1">i) =&gt; setRef(r</span><span class="s2">, </span><span class="s1">oldRawRef &amp;&amp; (isArray(oldRawRef) ? oldRawRef[i] : oldRawRef)</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">isUnmount))</span><span class="s2">;</span>
    <span class="s2">return;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(isAsyncWrapper(vnode) &amp;&amp; !isUnmount) {</span>
    <span class="s2">return;</span>
  <span class="s1">}</span>
  <span class="s2">const </span><span class="s1">refValue = vnode.shapeFlag &amp; </span><span class="s4">4 </span><span class="s1">? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">value = isUnmount ? </span><span class="s2">null </span><span class="s1">: refValue</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">{ i: owner</span><span class="s2">, </span><span class="s1">r: ref2 } = rawRef</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(!owner) {</span>
    <span class="s1">warn2(</span><span class="s3">`Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function.`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">return;</span>
  <span class="s1">}</span>
  <span class="s2">const </span><span class="s1">oldRef = oldRawRef &amp;&amp; oldRawRef.r</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">setupState = owner.setupState</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(oldRef != </span><span class="s2">null </span><span class="s1">&amp;&amp; oldRef !== ref2) {</span>
    <span class="s2">if </span><span class="s1">(isString(oldRef)) {</span>
      <span class="s1">refs[oldRef] = </span><span class="s2">null;</span>
      <span class="s2">if </span><span class="s1">(hasOwn(setupState</span><span class="s2">, </span><span class="s1">oldRef)) {</span>
        <span class="s1">setupState[oldRef] = </span><span class="s2">null;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isRef(oldRef)) {</span>
      <span class="s1">oldRef.value = </span><span class="s2">null;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(isFunction(ref2)) {</span>
    <span class="s1">callWithErrorHandling(ref2</span><span class="s2">, </span><span class="s1">owner</span><span class="s2">, </span><span class="s4">12</span><span class="s2">, </span><span class="s1">[value</span><span class="s2">, </span><span class="s1">refs])</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s2">const </span><span class="s1">_isString = isString(ref2)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">_isRef = isRef(ref2)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(_isString || _isRef) {</span>
      <span class="s2">const </span><span class="s1">doSet = () =&gt; {</span>
        <span class="s2">if </span><span class="s1">(rawRef.f) {</span>
          <span class="s2">const </span><span class="s1">existing = _isString ? hasOwn(setupState</span><span class="s2">, </span><span class="s1">ref2) ? setupState[ref2] : refs[ref2] : ref2.value</span><span class="s2">;</span>
          <span class="s2">if </span><span class="s1">(isUnmount) {</span>
            <span class="s1">isArray(existing) &amp;&amp; remove(existing</span><span class="s2">, </span><span class="s1">refValue)</span><span class="s2">;</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s2">if </span><span class="s1">(!isArray(existing)) {</span>
              <span class="s2">if </span><span class="s1">(_isString) {</span>
                <span class="s1">refs[ref2] = [refValue]</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(hasOwn(setupState</span><span class="s2">, </span><span class="s1">ref2)) {</span>
                  <span class="s1">setupState[ref2] = refs[ref2]</span><span class="s2">;</span>
                <span class="s1">}</span>
              <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">ref2.value = [refValue]</span><span class="s2">;</span>
                <span class="s2">if </span><span class="s1">(rawRef.k)</span>
                  <span class="s1">refs[rawRef.k] = ref2.value</span><span class="s2">;</span>
              <span class="s1">}</span>
            <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!existing.includes(refValue)) {</span>
              <span class="s1">existing.push(refValue)</span><span class="s2">;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(_isString) {</span>
          <span class="s1">refs[ref2] = value</span><span class="s2">;</span>
          <span class="s2">if </span><span class="s1">(hasOwn(setupState</span><span class="s2">, </span><span class="s1">ref2)) {</span>
            <span class="s1">setupState[ref2] = value</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(_isRef) {</span>
          <span class="s1">ref2.value = value</span><span class="s2">;</span>
          <span class="s2">if </span><span class="s1">(rawRef.k)</span>
            <span class="s1">refs[rawRef.k] = value</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
          <span class="s1">warn2(</span><span class="s3">&quot;Invalid template ref type:&quot;</span><span class="s2">, </span><span class="s1">ref2</span><span class="s2">, </span><span class="s3">`(</span><span class="s1">${</span><span class="s2">typeof </span><span class="s1">ref2}</span><span class="s3">)`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(value) {</span>
        <span class="s1">doSet.id = -</span><span class="s4">1</span><span class="s2">;</span>
        <span class="s1">queuePostRenderEffect(doSet</span><span class="s2">, </span><span class="s1">parentSuspense)</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">doSet()</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
      <span class="s1">warn2(</span><span class="s3">&quot;Invalid template ref type:&quot;</span><span class="s2">, </span><span class="s1">ref2</span><span class="s2">, </span><span class="s3">`(</span><span class="s1">${</span><span class="s2">typeof </span><span class="s1">ref2}</span><span class="s3">)`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">hasMismatch = </span><span class="s2">false;</span>
<span class="s2">var </span><span class="s1">isSVGContainer = (container) =&gt; </span><span class="s4">/svg/</span><span class="s1">.test(container.namespaceURI) &amp;&amp; container.tagName !== </span><span class="s3">&quot;foreignObject&quot;</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">isComment = (node) =&gt; node.nodeType === </span><span class="s4">8</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">createHydrationFunctions(rendererInternals) {</span>
  <span class="s2">const </span><span class="s1">{ mt: mountComponent</span><span class="s2">, </span><span class="s1">p: patch</span><span class="s2">, </span><span class="s1">o: { patchProp: patchProp2</span><span class="s2">, </span><span class="s1">createText</span><span class="s2">, </span><span class="s1">nextSibling</span><span class="s2">, </span><span class="s1">parentNode</span><span class="s2">, </span><span class="s1">remove: remove2</span><span class="s2">, </span><span class="s1">insert</span><span class="s2">, </span><span class="s1">createComment } } = rendererInternals</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">hydrate2 = (vnode</span><span class="s2">, </span><span class="s1">container) =&gt; {</span>
    <span class="s2">if </span><span class="s1">(!container.hasChildNodes()) {</span>
      <span class="s1">warn2(</span><span class="s3">`Attempting to hydrate existing markup but container is empty. Performing full mount instead.`</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">patch(</span><span class="s2">null, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">container)</span><span class="s2">;</span>
      <span class="s1">flushPostFlushCbs()</span><span class="s2">;</span>
      <span class="s1">container._vnode = vnode</span><span class="s2">;</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s1">hasMismatch = </span><span class="s2">false;</span>
    <span class="s1">hydrateNode(container.firstChild</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, null, null, null</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">flushPostFlushCbs()</span><span class="s2">;</span>
    <span class="s1">container._vnode = vnode</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(hasMismatch &amp;&amp; </span><span class="s2">true</span><span class="s1">) {</span>
      <span class="s1">console.error(</span><span class="s3">`Hydration completed but contains mismatches.`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">hydrateNode = (node</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized = </span><span class="s2">false</span><span class="s1">) =&gt; {</span>
    <span class="s2">const </span><span class="s1">isFragmentStart = isComment(node) &amp;&amp; node.data === </span><span class="s3">&quot;[&quot;</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">onMismatch = () =&gt; handleMismatch(node</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">isFragmentStart)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">{ type</span><span class="s2">, </span><span class="s1">ref: ref2</span><span class="s2">, </span><span class="s1">shapeFlag</span><span class="s2">, </span><span class="s1">patchFlag } = vnode</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">domType = node.nodeType</span><span class="s2">;</span>
    <span class="s1">vnode.el = node</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(patchFlag === -</span><span class="s4">2</span><span class="s1">) {</span>
      <span class="s1">optimized = </span><span class="s2">false;</span>
      <span class="s1">vnode.dynamicChildren = </span><span class="s2">null;</span>
    <span class="s1">}</span>
    <span class="s2">let </span><span class="s1">nextNode = </span><span class="s2">null;</span>
    <span class="s2">switch </span><span class="s1">(type) {</span>
      <span class="s2">case </span><span class="s1">Text:</span>
        <span class="s2">if </span><span class="s1">(domType !== </span><span class="s4">3</span><span class="s1">) {</span>
          <span class="s2">if </span><span class="s1">(vnode.children === </span><span class="s3">&quot;&quot;</span><span class="s1">) {</span>
            <span class="s1">insert(vnode.el = createText(</span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">parentNode(node)</span><span class="s2">, </span><span class="s1">node)</span><span class="s2">;</span>
            <span class="s1">nextNode = node</span><span class="s2">;</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">nextNode = onMismatch()</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s2">if </span><span class="s1">(node.data !== vnode.children) {</span>
            <span class="s1">hasMismatch = </span><span class="s2">true;</span>
            <span class="s1">warn2(</span><span class="s3">`Hydration text mismatch: 
- Client: </span><span class="s1">${JSON.stringify(node.data)}</span>
<span class="s3">- Server: </span><span class="s1">${JSON.stringify(vnode.children)}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">node.data = vnode.children</span><span class="s2">;</span>
          <span class="s1">}</span>
          <span class="s1">nextNode = nextSibling(node)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">break;</span>
      <span class="s2">case </span><span class="s1">Comment:</span>
        <span class="s2">if </span><span class="s1">(domType !== </span><span class="s4">8 </span><span class="s1">|| isFragmentStart) {</span>
          <span class="s1">nextNode = onMismatch()</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">nextNode = nextSibling(node)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">break;</span>
      <span class="s2">case </span><span class="s1">Static:</span>
        <span class="s2">if </span><span class="s1">(isFragmentStart) {</span>
          <span class="s1">node = nextSibling(node)</span><span class="s2">;</span>
          <span class="s1">domType = node.nodeType</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(domType === </span><span class="s4">1 </span><span class="s1">|| domType === </span><span class="s4">3</span><span class="s1">) {</span>
          <span class="s1">nextNode = node</span><span class="s2">;</span>
          <span class="s2">const </span><span class="s1">needToAdoptContent = !vnode.children.length</span><span class="s2">;</span>
          <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; vnode.staticCount</span><span class="s2">; </span><span class="s1">i++) {</span>
            <span class="s2">if </span><span class="s1">(needToAdoptContent)</span>
              <span class="s1">vnode.children += nextNode.nodeType === </span><span class="s4">1 </span><span class="s1">? nextNode.outerHTML : nextNode.data</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(i === vnode.staticCount - </span><span class="s4">1</span><span class="s1">) {</span>
              <span class="s1">vnode.anchor = nextNode</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">nextNode = nextSibling(nextNode)</span><span class="s2">;</span>
          <span class="s1">}</span>
          <span class="s2">return </span><span class="s1">isFragmentStart ? nextSibling(nextNode) : nextNode</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">onMismatch()</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">break;</span>
      <span class="s2">case </span><span class="s1">Fragment:</span>
        <span class="s2">if </span><span class="s1">(!isFragmentStart) {</span>
          <span class="s1">nextNode = onMismatch()</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">nextNode = hydrateFragment(node</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">break;</span>
      <span class="s2">default</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">(shapeFlag &amp; </span><span class="s4">1</span><span class="s1">) {</span>
          <span class="s2">if </span><span class="s1">(domType !== </span><span class="s4">1 </span><span class="s1">|| vnode.type.toLowerCase() !== node.tagName.toLowerCase()) {</span>
            <span class="s1">nextNode = onMismatch()</span><span class="s2">;</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">nextNode = hydrateElement(node</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(shapeFlag &amp; </span><span class="s4">6</span><span class="s1">) {</span>
          <span class="s1">vnode.slotScopeIds = slotScopeIds</span><span class="s2">;</span>
          <span class="s2">const </span><span class="s1">container = parentNode(node)</span><span class="s2">;</span>
          <span class="s1">mountComponent(vnode</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, null, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVGContainer(container)</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
          <span class="s1">nextNode = isFragmentStart ? locateClosingAsyncAnchor(node) : nextSibling(node)</span><span class="s2">;</span>
          <span class="s2">if </span><span class="s1">(nextNode &amp;&amp; isComment(nextNode) &amp;&amp; nextNode.data === </span><span class="s3">&quot;teleport end&quot;</span><span class="s1">) {</span>
            <span class="s1">nextNode = nextSibling(nextNode)</span><span class="s2">;</span>
          <span class="s1">}</span>
          <span class="s2">if </span><span class="s1">(isAsyncWrapper(vnode)) {</span>
            <span class="s2">let </span><span class="s1">subTree</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(isFragmentStart) {</span>
              <span class="s1">subTree = createVNode(Fragment)</span><span class="s2">;</span>
              <span class="s1">subTree.anchor = nextNode ? nextNode.previousSibling : container.lastChild</span><span class="s2">;</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
              <span class="s1">subTree = node.nodeType === </span><span class="s4">3 </span><span class="s1">? createTextVNode(</span><span class="s3">&quot;&quot;</span><span class="s1">) : createVNode(</span><span class="s3">&quot;div&quot;</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">subTree.el = node</span><span class="s2">;</span>
            <span class="s1">vnode.component.subTree = subTree</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(shapeFlag &amp; </span><span class="s4">64</span><span class="s1">) {</span>
          <span class="s2">if </span><span class="s1">(domType !== </span><span class="s4">8</span><span class="s1">) {</span>
            <span class="s1">nextNode = onMismatch()</span><span class="s2">;</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">nextNode = vnode.type.hydrate(node</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized</span><span class="s2">, </span><span class="s1">rendererInternals</span><span class="s2">, </span><span class="s1">hydrateChildren)</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(shapeFlag &amp; </span><span class="s4">128</span><span class="s1">) {</span>
          <span class="s1">nextNode = vnode.type.hydrate(node</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVGContainer(parentNode(node))</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized</span><span class="s2">, </span><span class="s1">rendererInternals</span><span class="s2">, </span><span class="s1">hydrateNode)</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
          <span class="s1">warn2(</span><span class="s3">&quot;Invalid HostVNode type:&quot;</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s3">`(</span><span class="s1">${</span><span class="s2">typeof </span><span class="s1">type}</span><span class="s3">)`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(ref2 != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">setRef(ref2</span><span class="s2">, null, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">vnode)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">nextNode</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">hydrateElement = (el</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized) =&gt; {</span>
    <span class="s1">optimized = optimized || !!vnode.dynamicChildren</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">{ type</span><span class="s2">, </span><span class="s1">props</span><span class="s2">, </span><span class="s1">patchFlag</span><span class="s2">, </span><span class="s1">shapeFlag</span><span class="s2">, </span><span class="s1">dirs } = vnode</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">forcePatchValue = type === </span><span class="s3">&quot;input&quot; </span><span class="s1">&amp;&amp; dirs || type === </span><span class="s3">&quot;option&quot;</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(dirs) {</span>
        <span class="s1">invokeDirectiveHook(vnode</span><span class="s2">, null, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s3">&quot;created&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(props) {</span>
        <span class="s2">if </span><span class="s1">(forcePatchValue || !optimized || patchFlag &amp; (</span><span class="s4">16 </span><span class="s1">| </span><span class="s4">32</span><span class="s1">)) {</span>
          <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">props) {</span>
            <span class="s2">if </span><span class="s1">(forcePatchValue &amp;&amp; key.endsWith(</span><span class="s3">&quot;value&quot;</span><span class="s1">) || isOn(key) &amp;&amp; !isReservedProp(key)) {</span>
              <span class="s1">patchProp2(el</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, null, </span><span class="s1">props[key]</span><span class="s2">, false, void </span><span class="s4">0</span><span class="s2">, </span><span class="s1">parentComponent)</span><span class="s2">;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(props.onClick) {</span>
          <span class="s1">patchProp2(el</span><span class="s2">, </span><span class="s3">&quot;onClick&quot;</span><span class="s2">, null, </span><span class="s1">props.onClick</span><span class="s2">, false, void </span><span class="s4">0</span><span class="s2">, </span><span class="s1">parentComponent)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">let </span><span class="s1">vnodeHooks</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(vnodeHooks = props &amp;&amp; props.onVnodeBeforeMount) {</span>
        <span class="s1">invokeVNodeHook(vnodeHooks</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">vnode)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(dirs) {</span>
        <span class="s1">invokeDirectiveHook(vnode</span><span class="s2">, null, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s3">&quot;beforeMount&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">((vnodeHooks = props &amp;&amp; props.onVnodeMounted) || dirs) {</span>
        <span class="s1">queueEffectWithSuspense(() =&gt; {</span>
          <span class="s1">vnodeHooks &amp;&amp; invokeVNodeHook(vnodeHooks</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">vnode)</span><span class="s2">;</span>
          <span class="s1">dirs &amp;&amp; invokeDirectiveHook(vnode</span><span class="s2">, null, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s3">&quot;mounted&quot;</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">, </span><span class="s1">parentSuspense)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(shapeFlag &amp; </span><span class="s4">16 </span><span class="s1">&amp;&amp; </span><span class="s0">// skip if element has innerHTML / textContent</span>
      <span class="s1">!(props &amp;&amp; (props.innerHTML || props.textContent))) {</span>
        <span class="s2">let </span><span class="s1">next = hydrateChildren(el.firstChild</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">el</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">hasWarned2 = </span><span class="s2">false;</span>
        <span class="s2">while </span><span class="s1">(next) {</span>
          <span class="s1">hasMismatch = </span><span class="s2">true;</span>
          <span class="s2">if </span><span class="s1">(!hasWarned2) {</span>
            <span class="s1">warn2(</span><span class="s3">`Hydration children mismatch in &lt;</span><span class="s1">${vnode.type}</span><span class="s3">&gt;: server rendered element contains more child nodes than client vdom.`</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">hasWarned2 = </span><span class="s2">true;</span>
          <span class="s1">}</span>
          <span class="s2">const </span><span class="s1">cur = next</span><span class="s2">;</span>
          <span class="s1">next = next.nextSibling</span><span class="s2">;</span>
          <span class="s1">remove2(cur)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(shapeFlag &amp; </span><span class="s4">8</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(el.textContent !== vnode.children) {</span>
          <span class="s1">hasMismatch = </span><span class="s2">true;</span>
          <span class="s1">warn2(</span><span class="s3">`Hydration text content mismatch in &lt;</span><span class="s1">${vnode.type}</span><span class="s3">&gt;: 
- Client: </span><span class="s1">${el.textContent}</span>
<span class="s3">- Server: </span><span class="s1">${vnode.children}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
          <span class="s1">el.textContent = vnode.children</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">el.nextSibling</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">hydrateChildren = (node</span><span class="s2">, </span><span class="s1">parentVNode</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized) =&gt; {</span>
    <span class="s1">optimized = optimized || !!parentVNode.dynamicChildren</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">children = parentVNode.children</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">l = children.length</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">hasWarned2 = </span><span class="s2">false;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; l</span><span class="s2">; </span><span class="s1">i++) {</span>
      <span class="s2">const </span><span class="s1">vnode = optimized ? children[i] : children[i] = normalizeVNode(children[i])</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(node) {</span>
        <span class="s1">node = hydrateNode(node</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(vnode.type === Text &amp;&amp; !vnode.children) {</span>
        <span class="s2">continue;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">hasMismatch = </span><span class="s2">true;</span>
        <span class="s2">if </span><span class="s1">(!hasWarned2) {</span>
          <span class="s1">warn2(</span><span class="s3">`Hydration children mismatch in &lt;</span><span class="s1">${container.tagName.toLowerCase()}</span><span class="s3">&gt;: server rendered element contains fewer child nodes than client vdom.`</span><span class="s1">)</span><span class="s2">;</span>
          <span class="s1">hasWarned2 = </span><span class="s2">true;</span>
        <span class="s1">}</span>
        <span class="s1">patch(</span><span class="s2">null, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, null, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVGContainer(container)</span><span class="s2">, </span><span class="s1">slotScopeIds)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">node</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">hydrateFragment = (node</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized) =&gt; {</span>
    <span class="s2">const </span><span class="s1">{ slotScopeIds: fragmentSlotScopeIds } = vnode</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(fragmentSlotScopeIds) {</span>
      <span class="s1">slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">container = parentNode(node)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">next = hydrateChildren(nextSibling(node)</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(next &amp;&amp; isComment(next) &amp;&amp; next.data === </span><span class="s3">&quot;]&quot;</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s1">nextSibling(vnode.anchor = next)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">hasMismatch = </span><span class="s2">true;</span>
      <span class="s1">insert(vnode.anchor = createComment(</span><span class="s3">`]`</span><span class="s1">)</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">next)</span><span class="s2">;</span>
      <span class="s2">return </span><span class="s1">next</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">handleMismatch = (node</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">isFragment) =&gt; {</span>
    <span class="s1">hasMismatch = </span><span class="s2">true;</span>
    <span class="s1">warn2(</span><span class="s3">`Hydration node mismatch: 
- Client vnode:`</span><span class="s2">, </span><span class="s1">vnode.type</span><span class="s2">, </span><span class="s3">`</span>
<span class="s3">- Server rendered DOM:`</span><span class="s2">, </span><span class="s1">node</span><span class="s2">, </span><span class="s1">node.nodeType === </span><span class="s4">3 </span><span class="s1">? </span><span class="s3">`(text)` </span><span class="s1">: isComment(node) &amp;&amp; node.data === </span><span class="s3">&quot;[&quot; </span><span class="s1">? </span><span class="s3">`(start of fragment)` </span><span class="s1">: </span><span class="s3">``</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">vnode.el = </span><span class="s2">null;</span>
    <span class="s2">if </span><span class="s1">(isFragment) {</span>
      <span class="s2">const </span><span class="s1">end = locateClosingAsyncAnchor(node)</span><span class="s2">;</span>
      <span class="s2">while </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s2">const </span><span class="s1">next2 = nextSibling(node)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(next2 &amp;&amp; next2 !== end) {</span>
          <span class="s1">remove2(next2)</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s2">break;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">next = nextSibling(node)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">container = parentNode(node)</span><span class="s2">;</span>
    <span class="s1">remove2(node)</span><span class="s2">;</span>
    <span class="s1">patch(</span><span class="s2">null, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">next</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVGContainer(container)</span><span class="s2">, </span><span class="s1">slotScopeIds)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">next</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">locateClosingAsyncAnchor = (node) =&gt; {</span>
    <span class="s2">let </span><span class="s1">match = </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s2">while </span><span class="s1">(node) {</span>
      <span class="s1">node = nextSibling(node)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(node &amp;&amp; isComment(node)) {</span>
        <span class="s2">if </span><span class="s1">(node.data === </span><span class="s3">&quot;[&quot;</span><span class="s1">)</span>
          <span class="s1">match++</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(node.data === </span><span class="s3">&quot;]&quot;</span><span class="s1">) {</span>
          <span class="s2">if </span><span class="s1">(match === </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s2">return </span><span class="s1">nextSibling(node)</span><span class="s2">;</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">match--</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">node</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">return </span><span class="s1">[hydrate2</span><span class="s2">, </span><span class="s1">hydrateNode]</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">supported</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">perf</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">startMeasure(instance</span><span class="s2">, </span><span class="s1">type) {</span>
  <span class="s2">if </span><span class="s1">(instance.appContext.config.performance &amp;&amp; isSupported()) {</span>
    <span class="s1">perf.mark(</span><span class="s3">`vue-</span><span class="s1">${type}</span><span class="s3">-</span><span class="s1">${instance.uid}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s1">devtoolsPerfStart(instance</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">isSupported() ? perf.now() : Date.now())</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">endMeasure(instance</span><span class="s2">, </span><span class="s1">type) {</span>
  <span class="s2">if </span><span class="s1">(instance.appContext.config.performance &amp;&amp; isSupported()) {</span>
    <span class="s2">const </span><span class="s1">startTag = </span><span class="s3">`vue-</span><span class="s1">${type}</span><span class="s3">-</span><span class="s1">${instance.uid}</span><span class="s3">`</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">endTag = startTag + </span><span class="s3">`:end`</span><span class="s2">;</span>
    <span class="s1">perf.mark(endTag)</span><span class="s2">;</span>
    <span class="s1">perf.measure(</span><span class="s3">`&lt;</span><span class="s1">${formatComponentName(instance</span><span class="s2">, </span><span class="s1">instance.type)}</span><span class="s3">&gt; </span><span class="s1">${type}</span><span class="s3">`</span><span class="s2">, </span><span class="s1">startTag</span><span class="s2">, </span><span class="s1">endTag)</span><span class="s2">;</span>
    <span class="s1">perf.clearMarks(startTag)</span><span class="s2">;</span>
    <span class="s1">perf.clearMarks(endTag)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s1">devtoolsPerfEnd(instance</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">isSupported() ? perf.now() : Date.now())</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isSupported() {</span>
  <span class="s2">if </span><span class="s1">(supported !== </span><span class="s2">void </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s2">return </span><span class="s1">supported</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">window !== </span><span class="s3">&quot;undefined&quot; </span><span class="s1">&amp;&amp; window.performance) {</span>
    <span class="s1">supported = </span><span class="s2">true;</span>
    <span class="s1">perf = window.performance</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s1">supported = </span><span class="s2">false;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">supported</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">initFeatureFlags() {</span>
  <span class="s2">const </span><span class="s1">needWarn = []</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">__VUE_OPTIONS_API__ !== </span><span class="s3">&quot;boolean&quot;</span><span class="s1">) {</span>
    <span class="s1">needWarn.push(</span><span class="s3">`__VUE_OPTIONS_API__`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">getGlobalThis().__VUE_OPTIONS_API__ = </span><span class="s2">true;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">__VUE_PROD_DEVTOOLS__ !== </span><span class="s3">&quot;boolean&quot;</span><span class="s1">) {</span>
    <span class="s1">needWarn.push(</span><span class="s3">`__VUE_PROD_DEVTOOLS__`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">getGlobalThis().__VUE_PROD_DEVTOOLS__ = </span><span class="s2">false;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(needWarn.length) {</span>
    <span class="s2">const </span><span class="s1">multi = needWarn.length &gt; </span><span class="s4">1</span><span class="s2">;</span>
    <span class="s1">console.warn(</span><span class="s3">`Feature flag</span><span class="s1">${multi ? </span><span class="s3">`s` </span><span class="s1">: </span><span class="s3">``</span><span class="s1">} ${needWarn.join(</span><span class="s3">&quot;, &quot;</span><span class="s1">)} ${multi ? </span><span class="s3">`are` </span><span class="s1">: </span><span class="s3">`is`</span><span class="s1">} </span><span class="s3">not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle. 
 
For more details, see https://link.vuejs.org/feature-flags.`</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">queuePostRenderEffect = queueEffectWithSuspense</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">createRenderer(options) {</span>
  <span class="s2">return </span><span class="s1">baseCreateRenderer(options)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createHydrationRenderer(options) {</span>
  <span class="s2">return </span><span class="s1">baseCreateRenderer(options</span><span class="s2">, </span><span class="s1">createHydrationFunctions)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">baseCreateRenderer(options</span><span class="s2">, </span><span class="s1">createHydrationFns) {</span>
  <span class="s1">{</span>
    <span class="s1">initFeatureFlags()</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">const </span><span class="s1">target = getGlobalThis()</span><span class="s2">;</span>
  <span class="s1">target.__VUE__ = </span><span class="s2">true;</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s1">setDevtoolsHook(target.__VUE_DEVTOOLS_GLOBAL_HOOK__</span><span class="s2">, </span><span class="s1">target)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">const </span><span class="s1">{ insert: hostInsert</span><span class="s2">, </span><span class="s1">remove: hostRemove</span><span class="s2">, </span><span class="s1">patchProp: hostPatchProp</span><span class="s2">, </span><span class="s1">createElement: hostCreateElement</span><span class="s2">, </span><span class="s1">createText: hostCreateText</span><span class="s2">, </span><span class="s1">createComment: hostCreateComment</span><span class="s2">, </span><span class="s1">setText: hostSetText</span><span class="s2">, </span><span class="s1">setElementText: hostSetElementText</span><span class="s2">, </span><span class="s1">parentNode: hostParentNode</span><span class="s2">, </span><span class="s1">nextSibling: hostNextSibling</span><span class="s2">, </span><span class="s1">setScopeId: hostSetScopeId = NOOP</span><span class="s2">, </span><span class="s1">insertStaticContent: hostInsertStaticContent } = options</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">patch = (n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor = </span><span class="s2">null, </span><span class="s1">parentComponent = </span><span class="s2">null, </span><span class="s1">parentSuspense = </span><span class="s2">null, </span><span class="s1">isSVG = </span><span class="s2">false, </span><span class="s1">slotScopeIds = </span><span class="s2">null, </span><span class="s1">optimized = isHmrUpdating ? </span><span class="s2">false </span><span class="s1">: !!n2.dynamicChildren) =&gt; {</span>
    <span class="s2">if </span><span class="s1">(n1 === n2) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(n1 &amp;&amp; !isSameVNodeType(n1</span><span class="s2">, </span><span class="s1">n2)) {</span>
      <span class="s1">anchor = getNextHostNode(n1)</span><span class="s2">;</span>
      <span class="s1">unmount(n1</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">n1 = </span><span class="s2">null;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(n2.patchFlag === -</span><span class="s4">2</span><span class="s1">) {</span>
      <span class="s1">optimized = </span><span class="s2">false;</span>
      <span class="s1">n2.dynamicChildren = </span><span class="s2">null;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">{ type</span><span class="s2">, </span><span class="s1">ref: ref2</span><span class="s2">, </span><span class="s1">shapeFlag } = n2</span><span class="s2">;</span>
    <span class="s2">switch </span><span class="s1">(type) {</span>
      <span class="s2">case </span><span class="s1">Text:</span>
        <span class="s1">processText(n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor)</span><span class="s2">;</span>
        <span class="s2">break;</span>
      <span class="s2">case </span><span class="s1">Comment:</span>
        <span class="s1">processCommentNode(n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor)</span><span class="s2">;</span>
        <span class="s2">break;</span>
      <span class="s2">case </span><span class="s1">Static:</span>
        <span class="s2">if </span><span class="s1">(n1 == </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s1">mountStaticNode(n2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">isSVG)</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
          <span class="s1">patchStaticNode(n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">isSVG)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">break;</span>
      <span class="s2">case </span><span class="s1">Fragment:</span>
        <span class="s1">processFragment(n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
        <span class="s2">break;</span>
      <span class="s2">default</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">(shapeFlag &amp; </span><span class="s4">1</span><span class="s1">) {</span>
          <span class="s1">processElement(n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(shapeFlag &amp; </span><span class="s4">6</span><span class="s1">) {</span>
          <span class="s1">processComponent(n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(shapeFlag &amp; </span><span class="s4">64</span><span class="s1">) {</span>
          <span class="s1">type.process(n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized</span><span class="s2">, </span><span class="s1">internals)</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(shapeFlag &amp; </span><span class="s4">128</span><span class="s1">) {</span>
          <span class="s1">type.process(n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized</span><span class="s2">, </span><span class="s1">internals)</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
          <span class="s1">warn2(</span><span class="s3">&quot;Invalid VNode type:&quot;</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s3">`(</span><span class="s1">${</span><span class="s2">typeof </span><span class="s1">type}</span><span class="s3">)`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(ref2 != </span><span class="s2">null </span><span class="s1">&amp;&amp; parentComponent) {</span>
      <span class="s1">setRef(ref2</span><span class="s2">, </span><span class="s1">n1 &amp;&amp; n1.ref</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">n2 || n1</span><span class="s2">, </span><span class="s1">!n2)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">processText = (n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor) =&gt; {</span>
    <span class="s2">if </span><span class="s1">(n1 == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">hostInsert(n2.el = hostCreateText(n2.children)</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">const </span><span class="s1">el = n2.el = n1.el</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(n2.children !== n1.children) {</span>
        <span class="s1">hostSetText(el</span><span class="s2">, </span><span class="s1">n2.children)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">processCommentNode = (n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor) =&gt; {</span>
    <span class="s2">if </span><span class="s1">(n1 == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">hostInsert(n2.el = hostCreateComment(n2.children || </span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">n2.el = n1.el</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">mountStaticNode = (n2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">isSVG) =&gt; {</span>
    <span class="s1">[n2.el</span><span class="s2">, </span><span class="s1">n2.anchor] = hostInsertStaticContent(n2.children</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">n2.el</span><span class="s2">, </span><span class="s1">n2.anchor)</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">patchStaticNode = (n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">isSVG) =&gt; {</span>
    <span class="s2">if </span><span class="s1">(n2.children !== n1.children) {</span>
      <span class="s2">const </span><span class="s1">anchor = hostNextSibling(n1.anchor)</span><span class="s2">;</span>
      <span class="s1">removeStaticNode(n1)</span><span class="s2">;</span>
      <span class="s1">[n2.el</span><span class="s2">, </span><span class="s1">n2.anchor] = hostInsertStaticContent(n2.children</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">isSVG)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">n2.el = n1.el</span><span class="s2">;</span>
      <span class="s1">n2.anchor = n1.anchor</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">moveStaticNode = ({ el</span><span class="s2">, </span><span class="s1">anchor }</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">nextSibling) =&gt; {</span>
    <span class="s2">let </span><span class="s1">next</span><span class="s2">;</span>
    <span class="s2">while </span><span class="s1">(el &amp;&amp; el !== anchor) {</span>
      <span class="s1">next = hostNextSibling(el)</span><span class="s2">;</span>
      <span class="s1">hostInsert(el</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">nextSibling)</span><span class="s2">;</span>
      <span class="s1">el = next</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hostInsert(anchor</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">nextSibling)</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">removeStaticNode = ({ el</span><span class="s2">, </span><span class="s1">anchor }) =&gt; {</span>
    <span class="s2">let </span><span class="s1">next</span><span class="s2">;</span>
    <span class="s2">while </span><span class="s1">(el &amp;&amp; el !== anchor) {</span>
      <span class="s1">next = hostNextSibling(el)</span><span class="s2">;</span>
      <span class="s1">hostRemove(el)</span><span class="s2">;</span>
      <span class="s1">el = next</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hostRemove(anchor)</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">processElement = (n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized) =&gt; {</span>
    <span class="s1">isSVG = isSVG || n2.type === </span><span class="s3">&quot;svg&quot;</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(n1 == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">mountElement(n2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">patchElement(n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">mountElement = (vnode</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized) =&gt; {</span>
    <span class="s2">let </span><span class="s1">el</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">vnodeHook</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">{ type</span><span class="s2">, </span><span class="s1">props</span><span class="s2">, </span><span class="s1">shapeFlag</span><span class="s2">, </span><span class="s1">transition</span><span class="s2">, </span><span class="s1">dirs } = vnode</span><span class="s2">;</span>
    <span class="s1">el = vnode.el = hostCreateElement(vnode.type</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">props &amp;&amp; props.is</span><span class="s2">, </span><span class="s1">props)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(shapeFlag &amp; </span><span class="s4">8</span><span class="s1">) {</span>
      <span class="s1">hostSetElementText(el</span><span class="s2">, </span><span class="s1">vnode.children)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(shapeFlag &amp; </span><span class="s4">16</span><span class="s1">) {</span>
      <span class="s1">mountChildren(vnode.children</span><span class="s2">, </span><span class="s1">el</span><span class="s2">, null, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG &amp;&amp; type !== </span><span class="s3">&quot;foreignObject&quot;</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(dirs) {</span>
      <span class="s1">invokeDirectiveHook(vnode</span><span class="s2">, null, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s3">&quot;created&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">setScopeId(el</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">vnode.scopeId</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">parentComponent)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(props) {</span>
      <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">props) {</span>
        <span class="s2">if </span><span class="s1">(key !== </span><span class="s3">&quot;value&quot; </span><span class="s1">&amp;&amp; !isReservedProp(key)) {</span>
          <span class="s1">hostPatchProp(el</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, null, </span><span class="s1">props[key]</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">vnode.children</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">unmountChildren)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s3">&quot;value&quot; </span><span class="s2">in </span><span class="s1">props) {</span>
        <span class="s1">hostPatchProp(el</span><span class="s2">, </span><span class="s3">&quot;value&quot;</span><span class="s2">, null, </span><span class="s1">props.value)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(vnodeHook = props.onVnodeBeforeMount) {</span>
        <span class="s1">invokeVNodeHook(vnodeHook</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">vnode)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
      <span class="s1">Object.defineProperty(el</span><span class="s2">, </span><span class="s3">&quot;__vnode&quot;</span><span class="s2">, </span><span class="s1">{</span>
        <span class="s1">value: vnode</span><span class="s2">,</span>
        <span class="s1">enumerable: </span><span class="s2">false</span>
      <span class="s1">})</span><span class="s2">;</span>
      <span class="s1">Object.defineProperty(el</span><span class="s2">, </span><span class="s3">&quot;__vueParentComponent&quot;</span><span class="s2">, </span><span class="s1">{</span>
        <span class="s1">value: parentComponent</span><span class="s2">,</span>
        <span class="s1">enumerable: </span><span class="s2">false</span>
      <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(dirs) {</span>
      <span class="s1">invokeDirectiveHook(vnode</span><span class="s2">, null, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s3">&quot;beforeMount&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">needCallTransitionHooks = (!parentSuspense || parentSuspense &amp;&amp; !parentSuspense.pendingBranch) &amp;&amp; transition &amp;&amp; !transition.persisted</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(needCallTransitionHooks) {</span>
      <span class="s1">transition.beforeEnter(el)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hostInsert(el</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">((vnodeHook = props &amp;&amp; props.onVnodeMounted) || needCallTransitionHooks || dirs) {</span>
      <span class="s1">queuePostRenderEffect(() =&gt; {</span>
        <span class="s1">vnodeHook &amp;&amp; invokeVNodeHook(vnodeHook</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">vnode)</span><span class="s2">;</span>
        <span class="s1">needCallTransitionHooks &amp;&amp; transition.enter(el)</span><span class="s2">;</span>
        <span class="s1">dirs &amp;&amp; invokeDirectiveHook(vnode</span><span class="s2">, null, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s3">&quot;mounted&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span><span class="s2">, </span><span class="s1">parentSuspense)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">setScopeId = (el</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">scopeId</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">parentComponent) =&gt; {</span>
    <span class="s2">if </span><span class="s1">(scopeId) {</span>
      <span class="s1">hostSetScopeId(el</span><span class="s2">, </span><span class="s1">scopeId)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(slotScopeIds) {</span>
      <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; slotScopeIds.length</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s1">hostSetScopeId(el</span><span class="s2">, </span><span class="s1">slotScopeIds[i])</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(parentComponent) {</span>
      <span class="s2">let </span><span class="s1">subTree = parentComponent.subTree</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(subTree.patchFlag &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp; subTree.patchFlag &amp; </span><span class="s4">2048</span><span class="s1">) {</span>
        <span class="s1">subTree = filterSingleRoot(subTree.children) || subTree</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(vnode === subTree) {</span>
        <span class="s2">const </span><span class="s1">parentVNode = parentComponent.vnode</span><span class="s2">;</span>
        <span class="s1">setScopeId(el</span><span class="s2">, </span><span class="s1">parentVNode</span><span class="s2">, </span><span class="s1">parentVNode.scopeId</span><span class="s2">, </span><span class="s1">parentVNode.slotScopeIds</span><span class="s2">, </span><span class="s1">parentComponent.parent)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">mountChildren = (children</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized</span><span class="s2">, </span><span class="s1">start = </span><span class="s4">0</span><span class="s1">) =&gt; {</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = start</span><span class="s2">; </span><span class="s1">i &lt; children.length</span><span class="s2">; </span><span class="s1">i++) {</span>
      <span class="s2">const </span><span class="s1">child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i])</span><span class="s2">;</span>
      <span class="s1">patch(</span><span class="s2">null, </span><span class="s1">child</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">patchElement = (n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized) =&gt; {</span>
    <span class="s2">const </span><span class="s1">el = n2.el = n1.el</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">{ patchFlag</span><span class="s2">, </span><span class="s1">dynamicChildren</span><span class="s2">, </span><span class="s1">dirs } = n2</span><span class="s2">;</span>
    <span class="s1">patchFlag |= n1.patchFlag &amp; </span><span class="s4">16</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">oldProps = n1.props || EMPTY_OBJ</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">newProps = n2.props || EMPTY_OBJ</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">vnodeHook</span><span class="s2">;</span>
    <span class="s1">parentComponent &amp;&amp; toggleRecurse(parentComponent</span><span class="s2">, false</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(vnodeHook = newProps.onVnodeBeforeUpdate) {</span>
      <span class="s1">invokeVNodeHook(vnodeHook</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">n1)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(dirs) {</span>
      <span class="s1">invokeDirectiveHook(n2</span><span class="s2">, </span><span class="s1">n1</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s3">&quot;beforeUpdate&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">parentComponent &amp;&amp; toggleRecurse(parentComponent</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(isHmrUpdating) {</span>
      <span class="s1">patchFlag = </span><span class="s4">0</span><span class="s2">;</span>
      <span class="s1">optimized = </span><span class="s2">false;</span>
      <span class="s1">dynamicChildren = </span><span class="s2">null;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">areChildrenSVG = isSVG &amp;&amp; n2.type !== </span><span class="s3">&quot;foreignObject&quot;</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(dynamicChildren) {</span>
      <span class="s1">patchBlockChildren(n1.dynamicChildren</span><span class="s2">, </span><span class="s1">dynamicChildren</span><span class="s2">, </span><span class="s1">el</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">areChildrenSVG</span><span class="s2">, </span><span class="s1">slotScopeIds)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(parentComponent &amp;&amp; parentComponent.type.__hmrId) {</span>
        <span class="s1">traverseStaticChildren(n1</span><span class="s2">, </span><span class="s1">n2)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!optimized) {</span>
      <span class="s1">patchChildren(n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">el</span><span class="s2">, null, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">areChildrenSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, false</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(patchFlag &gt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(patchFlag &amp; </span><span class="s4">16</span><span class="s1">) {</span>
        <span class="s1">patchProps(el</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">oldProps</span><span class="s2">, </span><span class="s1">newProps</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG)</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(patchFlag &amp; </span><span class="s4">2</span><span class="s1">) {</span>
          <span class="s2">if </span><span class="s1">(oldProps.class !== newProps.class) {</span>
            <span class="s1">hostPatchProp(el</span><span class="s2">, </span><span class="s3">&quot;class&quot;</span><span class="s2">, null, </span><span class="s1">newProps.class</span><span class="s2">, </span><span class="s1">isSVG)</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(patchFlag &amp; </span><span class="s4">4</span><span class="s1">) {</span>
          <span class="s1">hostPatchProp(el</span><span class="s2">, </span><span class="s3">&quot;style&quot;</span><span class="s2">, </span><span class="s1">oldProps.style</span><span class="s2">, </span><span class="s1">newProps.style</span><span class="s2">, </span><span class="s1">isSVG)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(patchFlag &amp; </span><span class="s4">8</span><span class="s1">) {</span>
          <span class="s2">const </span><span class="s1">propsToUpdate = n2.dynamicProps</span><span class="s2">;</span>
          <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; propsToUpdate.length</span><span class="s2">; </span><span class="s1">i++) {</span>
            <span class="s2">const </span><span class="s1">key = propsToUpdate[i]</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">prev = oldProps[key]</span><span class="s2">;</span>
            <span class="s2">const </span><span class="s1">next = newProps[key]</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(next !== prev || key === </span><span class="s3">&quot;value&quot;</span><span class="s1">) {</span>
              <span class="s1">hostPatchProp(el</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">prev</span><span class="s2">, </span><span class="s1">next</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">n1.children</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">unmountChildren)</span><span class="s2">;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(patchFlag &amp; </span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(n1.children !== n2.children) {</span>
          <span class="s1">hostSetElementText(el</span><span class="s2">, </span><span class="s1">n2.children)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!optimized &amp;&amp; dynamicChildren == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">patchProps(el</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">oldProps</span><span class="s2">, </span><span class="s1">newProps</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">((vnodeHook = newProps.onVnodeUpdated) || dirs) {</span>
      <span class="s1">queuePostRenderEffect(() =&gt; {</span>
        <span class="s1">vnodeHook &amp;&amp; invokeVNodeHook(vnodeHook</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">n1)</span><span class="s2">;</span>
        <span class="s1">dirs &amp;&amp; invokeDirectiveHook(n2</span><span class="s2">, </span><span class="s1">n1</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s3">&quot;updated&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span><span class="s2">, </span><span class="s1">parentSuspense)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">patchBlockChildren = (oldChildren</span><span class="s2">, </span><span class="s1">newChildren</span><span class="s2">, </span><span class="s1">fallbackContainer</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds) =&gt; {</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; newChildren.length</span><span class="s2">; </span><span class="s1">i++) {</span>
      <span class="s2">const </span><span class="s1">oldVNode = oldChildren[i]</span><span class="s2">;</span>
      <span class="s2">const </span><span class="s1">newVNode = newChildren[i]</span><span class="s2">;</span>
      <span class="s2">const </span><span class="s1">container = (</span>
        <span class="s0">// oldVNode may be an errored async setup() component inside Suspense</span>
        <span class="s0">// which will not have a mounted element</span>
        <span class="s1">oldVNode.el &amp;&amp; </span><span class="s0">// - In the case of a Fragment, we need to provide the actual parent</span>
        <span class="s0">// of the Fragment itself so it can move its children.</span>
        <span class="s1">(oldVNode.type === Fragment || </span><span class="s0">// - In the case of different nodes, there is going to be a replacement</span>
        <span class="s0">// which also requires the correct parent container</span>
        <span class="s1">!isSameVNodeType(oldVNode</span><span class="s2">, </span><span class="s1">newVNode) || </span><span class="s0">// - In the case of a component, it could contain anything.</span>
        <span class="s1">oldVNode.shapeFlag &amp; (</span><span class="s4">6 </span><span class="s1">| </span><span class="s4">64</span><span class="s1">)) ? hostParentNode(oldVNode.el) : (</span>
          <span class="s0">// In other cases, the parent container is not actually used so we</span>
          <span class="s0">// just pass the block element here to avoid a DOM parentNode call.</span>
          <span class="s1">fallbackContainer</span>
        <span class="s1">)</span>
      <span class="s1">)</span><span class="s2">;</span>
      <span class="s1">patch(oldVNode</span><span class="s2">, </span><span class="s1">newVNode</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, null, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">patchProps = (el</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">oldProps</span><span class="s2">, </span><span class="s1">newProps</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG) =&gt; {</span>
    <span class="s2">if </span><span class="s1">(oldProps !== newProps) {</span>
      <span class="s2">if </span><span class="s1">(oldProps !== EMPTY_OBJ) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">oldProps) {</span>
          <span class="s2">if </span><span class="s1">(!isReservedProp(key) &amp;&amp; !(key </span><span class="s2">in </span><span class="s1">newProps)) {</span>
            <span class="s1">hostPatchProp(el</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">oldProps[key]</span><span class="s2">, null, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">vnode.children</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">unmountChildren)</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">newProps) {</span>
        <span class="s2">if </span><span class="s1">(isReservedProp(key))</span>
          <span class="s2">continue;</span>
        <span class="s2">const </span><span class="s1">next = newProps[key]</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">prev = oldProps[key]</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(next !== prev &amp;&amp; key !== </span><span class="s3">&quot;value&quot;</span><span class="s1">) {</span>
          <span class="s1">hostPatchProp(el</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">prev</span><span class="s2">, </span><span class="s1">next</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">vnode.children</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">unmountChildren)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s3">&quot;value&quot; </span><span class="s2">in </span><span class="s1">newProps) {</span>
        <span class="s1">hostPatchProp(el</span><span class="s2">, </span><span class="s3">&quot;value&quot;</span><span class="s2">, </span><span class="s1">oldProps.value</span><span class="s2">, </span><span class="s1">newProps.value)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">processFragment = (n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized) =&gt; {</span>
    <span class="s2">const </span><span class="s1">fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText(</span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText(</span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">{ patchFlag</span><span class="s2">, </span><span class="s1">dynamicChildren</span><span class="s2">, </span><span class="s1">slotScopeIds: fragmentSlotScopeIds } = n2</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(</span>
      <span class="s0">// #5523 dev root fragment may inherit directives</span>
      <span class="s1">isHmrUpdating || patchFlag &amp; </span><span class="s4">2048</span>
    <span class="s1">) {</span>
      <span class="s1">patchFlag = </span><span class="s4">0</span><span class="s2">;</span>
      <span class="s1">optimized = </span><span class="s2">false;</span>
      <span class="s1">dynamicChildren = </span><span class="s2">null;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(fragmentSlotScopeIds) {</span>
      <span class="s1">slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(n1 == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">hostInsert(fragmentStartAnchor</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor)</span><span class="s2">;</span>
      <span class="s1">hostInsert(fragmentEndAnchor</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor)</span><span class="s2">;</span>
      <span class="s1">mountChildren(n2.children</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">fragmentEndAnchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(patchFlag &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp; patchFlag &amp; </span><span class="s4">64 </span><span class="s1">&amp;&amp; dynamicChildren &amp;&amp; </span><span class="s0">// #2715 the previous fragment could've been a BAILed one as a result</span>
      <span class="s0">// of renderSlot() with no valid children</span>
      <span class="s1">n1.dynamicChildren) {</span>
        <span class="s1">patchBlockChildren(n1.dynamicChildren</span><span class="s2">, </span><span class="s1">dynamicChildren</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(parentComponent &amp;&amp; parentComponent.type.__hmrId) {</span>
          <span class="s1">traverseStaticChildren(n1</span><span class="s2">, </span><span class="s1">n2)</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span>
          <span class="s0">// #2080 if the stable fragment has a key, it's a &lt;template v-for&gt; that may</span>
          <span class="s0">//  get moved around. Make sure all root level vnodes inherit el.</span>
          <span class="s0">// #2134 or if it's a component root, it may also get moved around</span>
          <span class="s0">// as the component is being moved.</span>
          <span class="s1">n2.key != </span><span class="s2">null </span><span class="s1">|| parentComponent &amp;&amp; n2 === parentComponent.subTree</span>
        <span class="s1">) {</span>
          <span class="s1">traverseStaticChildren(</span>
            <span class="s1">n1</span><span class="s2">,</span>
            <span class="s1">n2</span><span class="s2">,</span>
            <span class="s2">true</span>
            <span class="s0">/* shallow */</span>
          <span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">patchChildren(n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">fragmentEndAnchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">processComponent = (n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized) =&gt; {</span>
    <span class="s1">n2.slotScopeIds = slotScopeIds</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(n1 == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(n2.shapeFlag &amp; </span><span class="s4">512</span><span class="s1">) {</span>
        <span class="s1">parentComponent.ctx.activate(n2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">mountComponent(n2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">updateComponent(n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">mountComponent = (initialVNode</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">optimized) =&gt; {</span>
    <span class="s2">const </span><span class="s1">instance = initialVNode.component = createComponentInstance(initialVNode</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(instance.type.__hmrId) {</span>
      <span class="s1">registerHMR(instance)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
      <span class="s1">pushWarningContext(initialVNode)</span><span class="s2">;</span>
      <span class="s1">startMeasure(instance</span><span class="s2">, </span><span class="s3">`mount`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(isKeepAlive(initialVNode)) {</span>
      <span class="s1">instance.ctx.renderer = internals</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s1">startMeasure(instance</span><span class="s2">, </span><span class="s3">`init`</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s1">setupComponent(instance)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s1">endMeasure(instance</span><span class="s2">, </span><span class="s3">`init`</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(instance.asyncDep) {</span>
      <span class="s1">parentSuspense &amp;&amp; parentSuspense.registerDep(instance</span><span class="s2">, </span><span class="s1">setupRenderEffect)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(!initialVNode.el) {</span>
        <span class="s2">const </span><span class="s1">placeholder = instance.subTree = createVNode(Comment)</span><span class="s2">;</span>
        <span class="s1">processCommentNode(</span><span class="s2">null, </span><span class="s1">placeholder</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s1">setupRenderEffect(instance</span><span class="s2">, </span><span class="s1">initialVNode</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
      <span class="s1">popWarningContext()</span><span class="s2">;</span>
      <span class="s1">endMeasure(instance</span><span class="s2">, </span><span class="s3">`mount`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">updateComponent = (n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">optimized) =&gt; {</span>
    <span class="s2">const </span><span class="s1">instance = n2.component = n1.component</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(shouldUpdateComponent(n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">optimized)) {</span>
      <span class="s2">if </span><span class="s1">(instance.asyncDep &amp;&amp; !instance.asyncResolved) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
          <span class="s1">pushWarningContext(n2)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">updateComponentPreRender(instance</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
          <span class="s1">popWarningContext()</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">return;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">instance.next = n2</span><span class="s2">;</span>
        <span class="s1">invalidateJob(instance.update)</span><span class="s2">;</span>
        <span class="s1">instance.update()</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">n2.el = n1.el</span><span class="s2">;</span>
      <span class="s1">instance.vnode = n2</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">setupRenderEffect = (instance</span><span class="s2">, </span><span class="s1">initialVNode</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">optimized) =&gt; {</span>
    <span class="s2">const </span><span class="s1">componentUpdateFn = () =&gt; {</span>
      <span class="s2">if </span><span class="s1">(!instance.isMounted) {</span>
        <span class="s2">let </span><span class="s1">vnodeHook</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">{ el</span><span class="s2">, </span><span class="s1">props } = initialVNode</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">{ bm</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">parent } = instance</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">isAsyncWrapperVNode = isAsyncWrapper(initialVNode)</span><span class="s2">;</span>
        <span class="s1">toggleRecurse(instance</span><span class="s2">, false</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(bm) {</span>
          <span class="s1">invokeArrayFns(bm)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(!isAsyncWrapperVNode &amp;&amp; (vnodeHook = props &amp;&amp; props.onVnodeBeforeMount)) {</span>
          <span class="s1">invokeVNodeHook(vnodeHook</span><span class="s2">, </span><span class="s1">parent</span><span class="s2">, </span><span class="s1">initialVNode)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">toggleRecurse(instance</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(el &amp;&amp; hydrateNode) {</span>
          <span class="s2">const </span><span class="s1">hydrateSubTree = () =&gt; {</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
              <span class="s1">startMeasure(instance</span><span class="s2">, </span><span class="s3">`render`</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">instance.subTree = renderComponentRoot(instance)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
              <span class="s1">endMeasure(instance</span><span class="s2">, </span><span class="s3">`render`</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
              <span class="s1">startMeasure(instance</span><span class="s2">, </span><span class="s3">`hydrate`</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">hydrateNode(el</span><span class="s2">, </span><span class="s1">instance.subTree</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, null</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
              <span class="s1">endMeasure(instance</span><span class="s2">, </span><span class="s3">`hydrate`</span><span class="s1">)</span><span class="s2">;</span>
            <span class="s1">}</span>
          <span class="s1">}</span><span class="s2">;</span>
          <span class="s2">if </span><span class="s1">(isAsyncWrapperVNode) {</span>
            <span class="s1">initialVNode.type.__asyncLoader().then(</span>
              <span class="s0">// note: we are moving the render call into an async callback,</span>
              <span class="s0">// which means it won't track dependencies - but it's ok because</span>
              <span class="s0">// a server-rendered async wrapper is already in resolved state</span>
              <span class="s0">// and it will never need to change.</span>
              <span class="s1">() =&gt; !instance.isUnmounted &amp;&amp; hydrateSubTree()</span>
            <span class="s1">)</span><span class="s2">;</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">hydrateSubTree()</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
            <span class="s1">startMeasure(instance</span><span class="s2">, </span><span class="s3">`render`</span><span class="s1">)</span><span class="s2">;</span>
          <span class="s1">}</span>
          <span class="s2">const </span><span class="s1">subTree = instance.subTree = renderComponentRoot(instance)</span><span class="s2">;</span>
          <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
            <span class="s1">endMeasure(instance</span><span class="s2">, </span><span class="s3">`render`</span><span class="s1">)</span><span class="s2">;</span>
          <span class="s1">}</span>
          <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
            <span class="s1">startMeasure(instance</span><span class="s2">, </span><span class="s3">`patch`</span><span class="s1">)</span><span class="s2">;</span>
          <span class="s1">}</span>
          <span class="s1">patch(</span><span class="s2">null, </span><span class="s1">subTree</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG)</span><span class="s2">;</span>
          <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
            <span class="s1">endMeasure(instance</span><span class="s2">, </span><span class="s3">`patch`</span><span class="s1">)</span><span class="s2">;</span>
          <span class="s1">}</span>
          <span class="s1">initialVNode.el = subTree.el</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(m) {</span>
          <span class="s1">queuePostRenderEffect(m</span><span class="s2">, </span><span class="s1">parentSuspense)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(!isAsyncWrapperVNode &amp;&amp; (vnodeHook = props &amp;&amp; props.onVnodeMounted)) {</span>
          <span class="s2">const </span><span class="s1">scopedInitialVNode = initialVNode</span><span class="s2">;</span>
          <span class="s1">queuePostRenderEffect(() =&gt; invokeVNodeHook(vnodeHook</span><span class="s2">, </span><span class="s1">parent</span><span class="s2">, </span><span class="s1">scopedInitialVNode)</span><span class="s2">, </span><span class="s1">parentSuspense)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(initialVNode.shapeFlag &amp; </span><span class="s4">256 </span><span class="s1">|| parent &amp;&amp; isAsyncWrapper(parent.vnode) &amp;&amp; parent.vnode.shapeFlag &amp; </span><span class="s4">256</span><span class="s1">) {</span>
          <span class="s1">instance.a &amp;&amp; queuePostRenderEffect(instance.a</span><span class="s2">, </span><span class="s1">parentSuspense)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">instance.isMounted = </span><span class="s2">true;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
          <span class="s1">devtoolsComponentAdded(instance)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">initialVNode = container = anchor = </span><span class="s2">null;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">let </span><span class="s1">{ next</span><span class="s2">, </span><span class="s1">bu</span><span class="s2">, </span><span class="s1">u</span><span class="s2">, </span><span class="s1">parent</span><span class="s2">, </span><span class="s1">vnode } = instance</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">originNext = next</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">vnodeHook</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
          <span class="s1">pushWarningContext(next || instance.vnode)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">toggleRecurse(instance</span><span class="s2">, false</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(next) {</span>
          <span class="s1">next.el = vnode.el</span><span class="s2">;</span>
          <span class="s1">updateComponentPreRender(instance</span><span class="s2">, </span><span class="s1">next</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">next = vnode</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(bu) {</span>
          <span class="s1">invokeArrayFns(bu)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(vnodeHook = next.props &amp;&amp; next.props.onVnodeBeforeUpdate) {</span>
          <span class="s1">invokeVNodeHook(vnodeHook</span><span class="s2">, </span><span class="s1">parent</span><span class="s2">, </span><span class="s1">next</span><span class="s2">, </span><span class="s1">vnode)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">toggleRecurse(instance</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
          <span class="s1">startMeasure(instance</span><span class="s2">, </span><span class="s3">`render`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">nextTree = renderComponentRoot(instance)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
          <span class="s1">endMeasure(instance</span><span class="s2">, </span><span class="s3">`render`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">prevTree = instance.subTree</span><span class="s2">;</span>
        <span class="s1">instance.subTree = nextTree</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
          <span class="s1">startMeasure(instance</span><span class="s2">, </span><span class="s3">`patch`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">patch(</span>
          <span class="s1">prevTree</span><span class="s2">,</span>
          <span class="s1">nextTree</span><span class="s2">,</span>
          <span class="s0">// parent may have changed if it's in a teleport</span>
          <span class="s1">hostParentNode(prevTree.el)</span><span class="s2">,</span>
          <span class="s0">// anchor may have changed if it's in a fragment</span>
          <span class="s1">getNextHostNode(prevTree)</span><span class="s2">,</span>
          <span class="s1">instance</span><span class="s2">,</span>
          <span class="s1">parentSuspense</span><span class="s2">,</span>
          <span class="s1">isSVG</span>
        <span class="s1">)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
          <span class="s1">endMeasure(instance</span><span class="s2">, </span><span class="s3">`patch`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">next.el = nextTree.el</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(originNext === </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s1">updateHOCHostEl(instance</span><span class="s2">, </span><span class="s1">nextTree.el)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(u) {</span>
          <span class="s1">queuePostRenderEffect(u</span><span class="s2">, </span><span class="s1">parentSuspense)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(vnodeHook = next.props &amp;&amp; next.props.onVnodeUpdated) {</span>
          <span class="s1">queuePostRenderEffect(() =&gt; invokeVNodeHook(vnodeHook</span><span class="s2">, </span><span class="s1">parent</span><span class="s2">, </span><span class="s1">next</span><span class="s2">, </span><span class="s1">vnode)</span><span class="s2">, </span><span class="s1">parentSuspense)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
          <span class="s1">devtoolsComponentUpdated(instance)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
          <span class="s1">popWarningContext()</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">effect2 = instance.effect = </span><span class="s2">new </span><span class="s1">ReactiveEffect(</span>
      <span class="s1">componentUpdateFn</span><span class="s2">,</span>
      <span class="s1">() =&gt; queueJob(update)</span><span class="s2">,</span>
      <span class="s1">instance.scope</span>
      <span class="s0">// track it in component's effect scope</span>
    <span class="s1">)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">update = instance.update = () =&gt; effect2.run()</span><span class="s2">;</span>
    <span class="s1">update.id = instance.uid</span><span class="s2">;</span>
    <span class="s1">toggleRecurse(instance</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
      <span class="s1">effect2.onTrack = instance.rtc ? (e) =&gt; invokeArrayFns(instance.rtc</span><span class="s2">, </span><span class="s1">e) : </span><span class="s2">void </span><span class="s4">0</span><span class="s2">;</span>
      <span class="s1">effect2.onTrigger = instance.rtg ? (e) =&gt; invokeArrayFns(instance.rtg</span><span class="s2">, </span><span class="s1">e) : </span><span class="s2">void </span><span class="s4">0</span><span class="s2">;</span>
      <span class="s1">update.ownerInstance = instance</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">update()</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">updateComponentPreRender = (instance</span><span class="s2">, </span><span class="s1">nextVNode</span><span class="s2">, </span><span class="s1">optimized) =&gt; {</span>
    <span class="s1">nextVNode.component = instance</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">prevProps = instance.vnode.props</span><span class="s2">;</span>
    <span class="s1">instance.vnode = nextVNode</span><span class="s2">;</span>
    <span class="s1">instance.next = </span><span class="s2">null;</span>
    <span class="s1">updateProps(instance</span><span class="s2">, </span><span class="s1">nextVNode.props</span><span class="s2">, </span><span class="s1">prevProps</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
    <span class="s1">updateSlots(instance</span><span class="s2">, </span><span class="s1">nextVNode.children</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
    <span class="s1">pauseTracking()</span><span class="s2">;</span>
    <span class="s1">flushPreFlushCbs()</span><span class="s2">;</span>
    <span class="s1">resetTracking()</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">patchChildren = (n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized = </span><span class="s2">false</span><span class="s1">) =&gt; {</span>
    <span class="s2">const </span><span class="s1">c1 = n1 &amp;&amp; n1.children</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">prevShapeFlag = n1 ? n1.shapeFlag : </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">c2 = n2.children</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">{ patchFlag</span><span class="s2">, </span><span class="s1">shapeFlag } = n2</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(patchFlag &gt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(patchFlag &amp; </span><span class="s4">128</span><span class="s1">) {</span>
        <span class="s1">patchKeyedChildren(c1</span><span class="s2">, </span><span class="s1">c2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
        <span class="s2">return;</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(patchFlag &amp; </span><span class="s4">256</span><span class="s1">) {</span>
        <span class="s1">patchUnkeyedChildren(c1</span><span class="s2">, </span><span class="s1">c2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
        <span class="s2">return;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(shapeFlag &amp; </span><span class="s4">8</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(prevShapeFlag &amp; </span><span class="s4">16</span><span class="s1">) {</span>
        <span class="s1">unmountChildren(c1</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(c2 !== c1) {</span>
        <span class="s1">hostSetElementText(container</span><span class="s2">, </span><span class="s1">c2)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(prevShapeFlag &amp; </span><span class="s4">16</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(shapeFlag &amp; </span><span class="s4">16</span><span class="s1">) {</span>
          <span class="s1">patchKeyedChildren(c1</span><span class="s2">, </span><span class="s1">c2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">unmountChildren(c1</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(prevShapeFlag &amp; </span><span class="s4">8</span><span class="s1">) {</span>
          <span class="s1">hostSetElementText(container</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(shapeFlag &amp; </span><span class="s4">16</span><span class="s1">) {</span>
          <span class="s1">mountChildren(c2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">patchUnkeyedChildren = (c1</span><span class="s2">, </span><span class="s1">c2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized) =&gt; {</span>
    <span class="s1">c1 = c1 || EMPTY_ARR</span><span class="s2">;</span>
    <span class="s1">c2 = c2 || EMPTY_ARR</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">oldLength = c1.length</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">newLength = c2.length</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">commonLength = Math.min(oldLength</span><span class="s2">, </span><span class="s1">newLength)</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">i</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; commonLength</span><span class="s2">; </span><span class="s1">i++) {</span>
      <span class="s2">const </span><span class="s1">nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i])</span><span class="s2">;</span>
      <span class="s1">patch(c1[i]</span><span class="s2">, </span><span class="s1">nextChild</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, null, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(oldLength &gt; newLength) {</span>
      <span class="s1">unmountChildren(c1</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, true, false, </span><span class="s1">commonLength)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">mountChildren(c2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized</span><span class="s2">, </span><span class="s1">commonLength)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">patchKeyedChildren = (c1</span><span class="s2">, </span><span class="s1">c2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">parentAnchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized) =&gt; {</span>
    <span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">l2 = c2.length</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">e1 = c1.length - </span><span class="s4">1</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">e2 = l2 - </span><span class="s4">1</span><span class="s2">;</span>
    <span class="s2">while </span><span class="s1">(i &lt;= e1 &amp;&amp; i &lt;= e2) {</span>
      <span class="s2">const </span><span class="s1">n1 = c1[i]</span><span class="s2">;</span>
      <span class="s2">const </span><span class="s1">n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i])</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(isSameVNodeType(n1</span><span class="s2">, </span><span class="s1">n2)) {</span>
        <span class="s1">patch(n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, null, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">break;</span>
      <span class="s1">}</span>
      <span class="s1">i++</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">while </span><span class="s1">(i &lt;= e1 &amp;&amp; i &lt;= e2) {</span>
      <span class="s2">const </span><span class="s1">n1 = c1[e1]</span><span class="s2">;</span>
      <span class="s2">const </span><span class="s1">n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2])</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(isSameVNodeType(n1</span><span class="s2">, </span><span class="s1">n2)) {</span>
        <span class="s1">patch(n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, null, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">break;</span>
      <span class="s1">}</span>
      <span class="s1">e1--</span><span class="s2">;</span>
      <span class="s1">e2--</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(i &gt; e1) {</span>
      <span class="s2">if </span><span class="s1">(i &lt;= e2) {</span>
        <span class="s2">const </span><span class="s1">nextPos = e2 + </span><span class="s4">1</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">anchor = nextPos &lt; l2 ? c2[nextPos].el : parentAnchor</span><span class="s2">;</span>
        <span class="s2">while </span><span class="s1">(i &lt;= e2) {</span>
          <span class="s1">patch(</span><span class="s2">null, </span><span class="s1">c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i])</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
          <span class="s1">i++</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(i &gt; e2) {</span>
      <span class="s2">while </span><span class="s1">(i &lt;= e1) {</span>
        <span class="s1">unmount(c1[i]</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">i++</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">const </span><span class="s1">s1 = i</span><span class="s2">;</span>
      <span class="s2">const </span><span class="s1">s2 = i</span><span class="s2">;</span>
      <span class="s2">const </span><span class="s1">keyToNewIndexMap = </span><span class="s0">/* @__PURE__ */ </span><span class="s2">new </span><span class="s1">Map()</span><span class="s2">;</span>
      <span class="s2">for </span><span class="s1">(i = s2</span><span class="s2">; </span><span class="s1">i &lt;= e2</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s2">const </span><span class="s1">nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i])</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(nextChild.key != </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s2">if </span><span class="s1">(keyToNewIndexMap.has(nextChild.key)) {</span>
            <span class="s1">warn2(</span><span class="s3">`Duplicate keys found during update:`</span><span class="s2">, </span><span class="s1">JSON.stringify(nextChild.key)</span><span class="s2">, </span><span class="s3">`Make sure keys are unique.`</span><span class="s1">)</span><span class="s2">;</span>
          <span class="s1">}</span>
          <span class="s1">keyToNewIndexMap.set(nextChild.key</span><span class="s2">, </span><span class="s1">i)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">let </span><span class="s1">j</span><span class="s2">;</span>
      <span class="s2">let </span><span class="s1">patched = </span><span class="s4">0</span><span class="s2">;</span>
      <span class="s2">const </span><span class="s1">toBePatched = e2 - s2 + </span><span class="s4">1</span><span class="s2">;</span>
      <span class="s2">let </span><span class="s1">moved = </span><span class="s2">false;</span>
      <span class="s2">let </span><span class="s1">maxNewIndexSoFar = </span><span class="s4">0</span><span class="s2">;</span>
      <span class="s2">const </span><span class="s1">newIndexToOldIndexMap = </span><span class="s2">new </span><span class="s1">Array(toBePatched)</span><span class="s2">;</span>
      <span class="s2">for </span><span class="s1">(i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; toBePatched</span><span class="s2">; </span><span class="s1">i++)</span>
        <span class="s1">newIndexToOldIndexMap[i] = </span><span class="s4">0</span><span class="s2">;</span>
      <span class="s2">for </span><span class="s1">(i = s1</span><span class="s2">; </span><span class="s1">i &lt;= e1</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s2">const </span><span class="s1">prevChild = c1[i]</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(patched &gt;= toBePatched) {</span>
          <span class="s1">unmount(prevChild</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
          <span class="s2">continue;</span>
        <span class="s1">}</span>
        <span class="s2">let </span><span class="s1">newIndex</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(prevChild.key != </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s1">newIndex = keyToNewIndexMap.get(prevChild.key)</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s2">for </span><span class="s1">(j = s2</span><span class="s2">; </span><span class="s1">j &lt;= e2</span><span class="s2">; </span><span class="s1">j++) {</span>
            <span class="s2">if </span><span class="s1">(newIndexToOldIndexMap[j - s2] === </span><span class="s4">0 </span><span class="s1">&amp;&amp; isSameVNodeType(prevChild</span><span class="s2">, </span><span class="s1">c2[j])) {</span>
              <span class="s1">newIndex = j</span><span class="s2">;</span>
              <span class="s2">break;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(newIndex === </span><span class="s2">void </span><span class="s4">0</span><span class="s1">) {</span>
          <span class="s1">unmount(prevChild</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">newIndexToOldIndexMap[newIndex - s2] = i + </span><span class="s4">1</span><span class="s2">;</span>
          <span class="s2">if </span><span class="s1">(newIndex &gt;= maxNewIndexSoFar) {</span>
            <span class="s1">maxNewIndexSoFar = newIndex</span><span class="s2">;</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">moved = </span><span class="s2">true;</span>
          <span class="s1">}</span>
          <span class="s1">patch(prevChild</span><span class="s2">, </span><span class="s1">c2[newIndex]</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, null, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
          <span class="s1">patched++</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">const </span><span class="s1">increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR</span><span class="s2">;</span>
      <span class="s1">j = increasingNewIndexSequence.length - </span><span class="s4">1</span><span class="s2">;</span>
      <span class="s2">for </span><span class="s1">(i = toBePatched - </span><span class="s4">1</span><span class="s2">; </span><span class="s1">i &gt;= </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i--) {</span>
        <span class="s2">const </span><span class="s1">nextIndex = s2 + i</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">nextChild = c2[nextIndex]</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">anchor = nextIndex + </span><span class="s4">1 </span><span class="s1">&lt; l2 ? c2[nextIndex + </span><span class="s4">1</span><span class="s1">].el : parentAnchor</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(newIndexToOldIndexMap[i] === </span><span class="s4">0</span><span class="s1">) {</span>
          <span class="s1">patch(</span><span class="s2">null, </span><span class="s1">nextChild</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(moved) {</span>
          <span class="s2">if </span><span class="s1">(j &lt; </span><span class="s4">0 </span><span class="s1">|| i !== increasingNewIndexSequence[j]) {</span>
            <span class="s1">move(</span>
              <span class="s1">nextChild</span><span class="s2">,</span>
              <span class="s1">container</span><span class="s2">,</span>
              <span class="s1">anchor</span><span class="s2">,</span>
              <span class="s4">2</span>
              <span class="s0">/* MoveType.REORDER */</span>
            <span class="s1">)</span><span class="s2">;</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">j--</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">move = (vnode</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">moveType</span><span class="s2">, </span><span class="s1">parentSuspense = </span><span class="s2">null</span><span class="s1">) =&gt; {</span>
    <span class="s2">const </span><span class="s1">{ el</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">transition</span><span class="s2">, </span><span class="s1">children</span><span class="s2">, </span><span class="s1">shapeFlag } = vnode</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(shapeFlag &amp; </span><span class="s4">6</span><span class="s1">) {</span>
      <span class="s1">move(vnode.component.subTree</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">moveType)</span><span class="s2">;</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(shapeFlag &amp; </span><span class="s4">128</span><span class="s1">) {</span>
      <span class="s1">vnode.suspense.move(container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">moveType)</span><span class="s2">;</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(shapeFlag &amp; </span><span class="s4">64</span><span class="s1">) {</span>
      <span class="s1">type.move(vnode</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">internals)</span><span class="s2">;</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(type === Fragment) {</span>
      <span class="s1">hostInsert(el</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor)</span><span class="s2">;</span>
      <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; children.length</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s1">move(children[i]</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">moveType)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s1">hostInsert(vnode.anchor</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor)</span><span class="s2">;</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(type === Static) {</span>
      <span class="s1">moveStaticNode(vnode</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor)</span><span class="s2">;</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">needTransition = moveType !== </span><span class="s4">2 </span><span class="s1">&amp;&amp; shapeFlag &amp; </span><span class="s4">1 </span><span class="s1">&amp;&amp; transition</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(needTransition) {</span>
      <span class="s2">if </span><span class="s1">(moveType === </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">transition.beforeEnter(el)</span><span class="s2">;</span>
        <span class="s1">hostInsert(el</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor)</span><span class="s2">;</span>
        <span class="s1">queuePostRenderEffect(() =&gt; transition.enter(el)</span><span class="s2">, </span><span class="s1">parentSuspense)</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">const </span><span class="s1">{ leave</span><span class="s2">, </span><span class="s1">delayLeave</span><span class="s2">, </span><span class="s1">afterLeave } = transition</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">remove3 = () =&gt; hostInsert(el</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor)</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">performLeave = () =&gt; {</span>
          <span class="s1">leave(el</span><span class="s2">, </span><span class="s1">() =&gt; {</span>
            <span class="s1">remove3()</span><span class="s2">;</span>
            <span class="s1">afterLeave &amp;&amp; afterLeave()</span><span class="s2">;</span>
          <span class="s1">})</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(delayLeave) {</span>
          <span class="s1">delayLeave(el</span><span class="s2">, </span><span class="s1">remove3</span><span class="s2">, </span><span class="s1">performLeave)</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">performLeave()</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">hostInsert(el</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">unmount = (vnode</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">doRemove = </span><span class="s2">false, </span><span class="s1">optimized = </span><span class="s2">false</span><span class="s1">) =&gt; {</span>
    <span class="s2">const </span><span class="s1">{ type</span><span class="s2">, </span><span class="s1">props</span><span class="s2">, </span><span class="s1">ref: ref2</span><span class="s2">, </span><span class="s1">children</span><span class="s2">, </span><span class="s1">dynamicChildren</span><span class="s2">, </span><span class="s1">shapeFlag</span><span class="s2">, </span><span class="s1">patchFlag</span><span class="s2">, </span><span class="s1">dirs } = vnode</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(ref2 != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">setRef(ref2</span><span class="s2">, null, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(shapeFlag &amp; </span><span class="s4">256</span><span class="s1">) {</span>
      <span class="s1">parentComponent.ctx.deactivate(vnode)</span><span class="s2">;</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">shouldInvokeDirs = shapeFlag &amp; </span><span class="s4">1 </span><span class="s1">&amp;&amp; dirs</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">shouldInvokeVnodeHook = !isAsyncWrapper(vnode)</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">vnodeHook</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(shouldInvokeVnodeHook &amp;&amp; (vnodeHook = props &amp;&amp; props.onVnodeBeforeUnmount)) {</span>
      <span class="s1">invokeVNodeHook(vnodeHook</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">vnode)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(shapeFlag &amp; </span><span class="s4">6</span><span class="s1">) {</span>
      <span class="s1">unmountComponent(vnode.component</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">doRemove)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(shapeFlag &amp; </span><span class="s4">128</span><span class="s1">) {</span>
        <span class="s1">vnode.suspense.unmount(parentSuspense</span><span class="s2">, </span><span class="s1">doRemove)</span><span class="s2">;</span>
        <span class="s2">return;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(shouldInvokeDirs) {</span>
        <span class="s1">invokeDirectiveHook(vnode</span><span class="s2">, null, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s3">&quot;beforeUnmount&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(shapeFlag &amp; </span><span class="s4">64</span><span class="s1">) {</span>
        <span class="s1">vnode.type.remove(vnode</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">optimized</span><span class="s2">, </span><span class="s1">internals</span><span class="s2">, </span><span class="s1">doRemove)</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(dynamicChildren &amp;&amp; </span><span class="s0">// #1153: fast path should not be taken for non-stable (v-for) fragments</span>
      <span class="s1">(type !== Fragment || patchFlag &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp; patchFlag &amp; </span><span class="s4">64</span><span class="s1">)) {</span>
        <span class="s1">unmountChildren(dynamicChildren</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, false, true</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(type === Fragment &amp;&amp; patchFlag &amp; (</span><span class="s4">128 </span><span class="s1">| </span><span class="s4">256</span><span class="s1">) || !optimized &amp;&amp; shapeFlag &amp; </span><span class="s4">16</span><span class="s1">) {</span>
        <span class="s1">unmountChildren(children</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(doRemove) {</span>
        <span class="s1">remove2(vnode)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(shouldInvokeVnodeHook &amp;&amp; (vnodeHook = props &amp;&amp; props.onVnodeUnmounted) || shouldInvokeDirs) {</span>
      <span class="s1">queuePostRenderEffect(() =&gt; {</span>
        <span class="s1">vnodeHook &amp;&amp; invokeVNodeHook(vnodeHook</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">vnode)</span><span class="s2">;</span>
        <span class="s1">shouldInvokeDirs &amp;&amp; invokeDirectiveHook(vnode</span><span class="s2">, null, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s3">&quot;unmounted&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span><span class="s2">, </span><span class="s1">parentSuspense)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">remove2 = (vnode) =&gt; {</span>
    <span class="s2">const </span><span class="s1">{ type</span><span class="s2">, </span><span class="s1">el</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">transition } = vnode</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(type === Fragment) {</span>
      <span class="s2">if </span><span class="s1">(vnode.patchFlag &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp; vnode.patchFlag &amp; </span><span class="s4">2048 </span><span class="s1">&amp;&amp; transition &amp;&amp; !transition.persisted) {</span>
        <span class="s1">vnode.children.forEach((child) =&gt; {</span>
          <span class="s2">if </span><span class="s1">(child.type === Comment) {</span>
            <span class="s1">hostRemove(child.el)</span><span class="s2">;</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">remove2(child)</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">})</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">removeFragment(el</span><span class="s2">, </span><span class="s1">anchor)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(type === Static) {</span>
      <span class="s1">removeStaticNode(vnode)</span><span class="s2">;</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">performRemove = () =&gt; {</span>
      <span class="s1">hostRemove(el)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(transition &amp;&amp; !transition.persisted &amp;&amp; transition.afterLeave) {</span>
        <span class="s1">transition.afterLeave()</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(vnode.shapeFlag &amp; </span><span class="s4">1 </span><span class="s1">&amp;&amp; transition &amp;&amp; !transition.persisted) {</span>
      <span class="s2">const </span><span class="s1">{ leave</span><span class="s2">, </span><span class="s1">delayLeave } = transition</span><span class="s2">;</span>
      <span class="s2">const </span><span class="s1">performLeave = () =&gt; leave(el</span><span class="s2">, </span><span class="s1">performRemove)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(delayLeave) {</span>
        <span class="s1">delayLeave(vnode.el</span><span class="s2">, </span><span class="s1">performRemove</span><span class="s2">, </span><span class="s1">performLeave)</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">performLeave()</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">performRemove()</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">removeFragment = (cur</span><span class="s2">, </span><span class="s1">end) =&gt; {</span>
    <span class="s2">let </span><span class="s1">next</span><span class="s2">;</span>
    <span class="s2">while </span><span class="s1">(cur !== end) {</span>
      <span class="s1">next = hostNextSibling(cur)</span><span class="s2">;</span>
      <span class="s1">hostRemove(cur)</span><span class="s2">;</span>
      <span class="s1">cur = next</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">hostRemove(end)</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">unmountComponent = (instance</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">doRemove) =&gt; {</span>
    <span class="s2">if </span><span class="s1">(instance.type.__hmrId) {</span>
      <span class="s1">unregisterHMR(instance)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">{ bum</span><span class="s2">, </span><span class="s1">scope</span><span class="s2">, </span><span class="s1">update</span><span class="s2">, </span><span class="s1">subTree</span><span class="s2">, </span><span class="s1">um } = instance</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(bum) {</span>
      <span class="s1">invokeArrayFns(bum)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">scope.stop()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(update) {</span>
      <span class="s1">update.active = </span><span class="s2">false;</span>
      <span class="s1">unmount(subTree</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">doRemove)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(um) {</span>
      <span class="s1">queuePostRenderEffect(um</span><span class="s2">, </span><span class="s1">parentSuspense)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">queuePostRenderEffect(() =&gt; {</span>
      <span class="s1">instance.isUnmounted = </span><span class="s2">true;</span>
    <span class="s1">}</span><span class="s2">, </span><span class="s1">parentSuspense)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(parentSuspense &amp;&amp; parentSuspense.pendingBranch &amp;&amp; !parentSuspense.isUnmounted &amp;&amp; instance.asyncDep &amp;&amp; !instance.asyncResolved &amp;&amp; instance.suspenseId === parentSuspense.pendingId) {</span>
      <span class="s1">parentSuspense.deps--</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(parentSuspense.deps === </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">parentSuspense.resolve()</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
      <span class="s1">devtoolsComponentRemoved(instance)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">unmountChildren = (children</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">doRemove = </span><span class="s2">false, </span><span class="s1">optimized = </span><span class="s2">false, </span><span class="s1">start = </span><span class="s4">0</span><span class="s1">) =&gt; {</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = start</span><span class="s2">; </span><span class="s1">i &lt; children.length</span><span class="s2">; </span><span class="s1">i++) {</span>
      <span class="s1">unmount(children[i]</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">doRemove</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">getNextHostNode = (vnode) =&gt; {</span>
    <span class="s2">if </span><span class="s1">(vnode.shapeFlag &amp; </span><span class="s4">6</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s1">getNextHostNode(vnode.component.subTree)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(vnode.shapeFlag &amp; </span><span class="s4">128</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s1">vnode.suspense.next()</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">hostNextSibling(vnode.anchor || vnode.el)</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">render2 = (vnode</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">isSVG) =&gt; {</span>
    <span class="s2">if </span><span class="s1">(vnode == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(container._vnode) {</span>
        <span class="s1">unmount(container._vnode</span><span class="s2">, null, null, true</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">patch(container._vnode || </span><span class="s2">null, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, null, null, null, </span><span class="s1">isSVG)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">flushPreFlushCbs()</span><span class="s2">;</span>
    <span class="s1">flushPostFlushCbs()</span><span class="s2">;</span>
    <span class="s1">container._vnode = vnode</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">internals = {</span>
    <span class="s1">p: patch</span><span class="s2">,</span>
    <span class="s1">um: unmount</span><span class="s2">,</span>
    <span class="s1">m: move</span><span class="s2">,</span>
    <span class="s1">r: remove2</span><span class="s2">,</span>
    <span class="s1">mt: mountComponent</span><span class="s2">,</span>
    <span class="s1">mc: mountChildren</span><span class="s2">,</span>
    <span class="s1">pc: patchChildren</span><span class="s2">,</span>
    <span class="s1">pbc: patchBlockChildren</span><span class="s2">,</span>
    <span class="s1">n: getNextHostNode</span><span class="s2">,</span>
    <span class="s1">o: options</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">let </span><span class="s1">hydrate2</span><span class="s2">;</span>
  <span class="s2">let </span><span class="s1">hydrateNode</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(createHydrationFns) {</span>
    <span class="s1">[hydrate2</span><span class="s2">, </span><span class="s1">hydrateNode] = createHydrationFns(internals)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">{</span>
    <span class="s1">render: render2</span><span class="s2">,</span>
    <span class="s1">hydrate: hydrate2</span><span class="s2">,</span>
    <span class="s1">createApp: createAppAPI(render2</span><span class="s2">, </span><span class="s1">hydrate2)</span>
  <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">toggleRecurse({ effect: effect2</span><span class="s2">, </span><span class="s1">update }</span><span class="s2">, </span><span class="s1">allowed) {</span>
  <span class="s1">effect2.allowRecurse = update.allowRecurse = allowed</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">traverseStaticChildren(n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">shallow = </span><span class="s2">false</span><span class="s1">) {</span>
  <span class="s2">const </span><span class="s1">ch1 = n1.children</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">ch2 = n2.children</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(isArray(ch1) &amp;&amp; isArray(ch2)) {</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; ch1.length</span><span class="s2">; </span><span class="s1">i++) {</span>
      <span class="s2">const </span><span class="s1">c1 = ch1[i]</span><span class="s2">;</span>
      <span class="s2">let </span><span class="s1">c2 = ch2[i]</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(c2.shapeFlag &amp; </span><span class="s4">1 </span><span class="s1">&amp;&amp; !c2.dynamicChildren) {</span>
        <span class="s2">if </span><span class="s1">(c2.patchFlag &lt;= </span><span class="s4">0 </span><span class="s1">|| c2.patchFlag === </span><span class="s4">32</span><span class="s1">) {</span>
          <span class="s1">c2 = ch2[i] = cloneIfMounted(ch2[i])</span><span class="s2">;</span>
          <span class="s1">c2.el = c1.el</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(!shallow)</span>
          <span class="s1">traverseStaticChildren(c1</span><span class="s2">, </span><span class="s1">c2)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(c2.type === Text) {</span>
        <span class="s1">c2.el = c1.el</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(c2.type === Comment &amp;&amp; !c2.el) {</span>
        <span class="s1">c2.el = c1.el</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getSequence(arr) {</span>
  <span class="s2">const </span><span class="s1">p2 = arr.slice()</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">result = [</span><span class="s4">0</span><span class="s1">]</span><span class="s2">;</span>
  <span class="s2">let </span><span class="s1">i</span><span class="s2">, </span><span class="s1">j</span><span class="s2">, </span><span class="s1">u</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">c</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">len = arr.length</span><span class="s2">;</span>
  <span class="s2">for </span><span class="s1">(i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; len</span><span class="s2">; </span><span class="s1">i++) {</span>
    <span class="s2">const </span><span class="s1">arrI = arr[i]</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(arrI !== </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s1">j = result[result.length - </span><span class="s4">1</span><span class="s1">]</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(arr[j] &lt; arrI) {</span>
        <span class="s1">p2[i] = j</span><span class="s2">;</span>
        <span class="s1">result.push(i)</span><span class="s2">;</span>
        <span class="s2">continue;</span>
      <span class="s1">}</span>
      <span class="s1">u = </span><span class="s4">0</span><span class="s2">;</span>
      <span class="s1">v = result.length - </span><span class="s4">1</span><span class="s2">;</span>
      <span class="s2">while </span><span class="s1">(u &lt; v) {</span>
        <span class="s1">c = u + v &gt;&gt; </span><span class="s4">1</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(arr[result[c]] &lt; arrI) {</span>
          <span class="s1">u = c + </span><span class="s4">1</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">v = c</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(arrI &lt; arr[result[u]]) {</span>
        <span class="s2">if </span><span class="s1">(u &gt; </span><span class="s4">0</span><span class="s1">) {</span>
          <span class="s1">p2[i] = result[u - </span><span class="s4">1</span><span class="s1">]</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">result[u] = i</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">u = result.length</span><span class="s2">;</span>
  <span class="s1">v = result[u - </span><span class="s4">1</span><span class="s1">]</span><span class="s2">;</span>
  <span class="s2">while </span><span class="s1">(u-- &gt; </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s1">result[u] = v</span><span class="s2">;</span>
    <span class="s1">v = p2[v]</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">result</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">isTeleport = (type) =&gt; type.__isTeleport</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">isTeleportDisabled = (props) =&gt; props &amp;&amp; (props.disabled || props.disabled === </span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">isTargetSVG = (target) =&gt; </span><span class="s2">typeof </span><span class="s1">SVGElement !== </span><span class="s3">&quot;undefined&quot; </span><span class="s1">&amp;&amp; target </span><span class="s2">instanceof </span><span class="s1">SVGElement</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">resolveTarget = (props</span><span class="s2">, </span><span class="s1">select) =&gt; {</span>
  <span class="s2">const </span><span class="s1">targetSelector = props &amp;&amp; props.to</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(isString(targetSelector)) {</span>
    <span class="s2">if </span><span class="s1">(!select) {</span>
      <span class="s1">warn2(</span><span class="s3">`Current renderer does not support string target for Teleports. (missing querySelector renderer option)`</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">return null;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">const </span><span class="s1">target = select(targetSelector)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(!target) {</span>
        <span class="s1">warn2(</span><span class="s3">`Failed to locate Teleport target with selector &quot;</span><span class="s1">${targetSelector}</span><span class="s3">&quot;. Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.`</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">target</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s2">if </span><span class="s1">(!targetSelector &amp;&amp; !isTeleportDisabled(props)) {</span>
      <span class="s1">warn2(</span><span class="s3">`Invalid Teleport target: </span><span class="s1">${targetSelector}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">targetSelector</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">TeleportImpl = {</span>
  <span class="s1">__isTeleport: </span><span class="s2">true,</span>
  <span class="s1">process(n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized</span><span class="s2">, </span><span class="s1">internals) {</span>
    <span class="s2">const </span><span class="s1">{ mc: mountChildren</span><span class="s2">, </span><span class="s1">pc: patchChildren</span><span class="s2">, </span><span class="s1">pbc: patchBlockChildren</span><span class="s2">, </span><span class="s1">o: { insert</span><span class="s2">, </span><span class="s1">querySelector</span><span class="s2">, </span><span class="s1">createText</span><span class="s2">, </span><span class="s1">createComment } } = internals</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">disabled = isTeleportDisabled(n2.props)</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">{ shapeFlag</span><span class="s2">, </span><span class="s1">children</span><span class="s2">, </span><span class="s1">dynamicChildren } = n2</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(isHmrUpdating) {</span>
      <span class="s1">optimized = </span><span class="s2">false;</span>
      <span class="s1">dynamicChildren = </span><span class="s2">null;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(n1 == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s2">const </span><span class="s1">placeholder = n2.el = </span><span class="s2">true </span><span class="s1">? createComment(</span><span class="s3">&quot;teleport start&quot;</span><span class="s1">) : createText(</span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">const </span><span class="s1">mainAnchor = n2.anchor = </span><span class="s2">true </span><span class="s1">? createComment(</span><span class="s3">&quot;teleport end&quot;</span><span class="s1">) : createText(</span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">insert(placeholder</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor)</span><span class="s2">;</span>
      <span class="s1">insert(mainAnchor</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">anchor)</span><span class="s2">;</span>
      <span class="s2">const </span><span class="s1">target = n2.target = resolveTarget(n2.props</span><span class="s2">, </span><span class="s1">querySelector)</span><span class="s2">;</span>
      <span class="s2">const </span><span class="s1">targetAnchor = n2.targetAnchor = createText(</span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(target) {</span>
        <span class="s1">insert(targetAnchor</span><span class="s2">, </span><span class="s1">target)</span><span class="s2">;</span>
        <span class="s1">isSVG = isSVG || isTargetSVG(target)</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!disabled) {</span>
        <span class="s1">warn2(</span><span class="s3">&quot;Invalid Teleport target on mount:&quot;</span><span class="s2">, </span><span class="s1">target</span><span class="s2">, </span><span class="s3">`(</span><span class="s1">${</span><span class="s2">typeof </span><span class="s1">target}</span><span class="s3">)`</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">const </span><span class="s1">mount = (container2</span><span class="s2">, </span><span class="s1">anchor2) =&gt; {</span>
        <span class="s2">if </span><span class="s1">(shapeFlag &amp; </span><span class="s4">16</span><span class="s1">) {</span>
          <span class="s1">mountChildren(children</span><span class="s2">, </span><span class="s1">container2</span><span class="s2">, </span><span class="s1">anchor2</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(disabled) {</span>
        <span class="s1">mount(container</span><span class="s2">, </span><span class="s1">mainAnchor)</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(target) {</span>
        <span class="s1">mount(target</span><span class="s2">, </span><span class="s1">targetAnchor)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">n2.el = n1.el</span><span class="s2">;</span>
      <span class="s2">const </span><span class="s1">mainAnchor = n2.anchor = n1.anchor</span><span class="s2">;</span>
      <span class="s2">const </span><span class="s1">target = n2.target = n1.target</span><span class="s2">;</span>
      <span class="s2">const </span><span class="s1">targetAnchor = n2.targetAnchor = n1.targetAnchor</span><span class="s2">;</span>
      <span class="s2">const </span><span class="s1">wasDisabled = isTeleportDisabled(n1.props)</span><span class="s2">;</span>
      <span class="s2">const </span><span class="s1">currentContainer = wasDisabled ? container : target</span><span class="s2">;</span>
      <span class="s2">const </span><span class="s1">currentAnchor = wasDisabled ? mainAnchor : targetAnchor</span><span class="s2">;</span>
      <span class="s1">isSVG = isSVG || isTargetSVG(target)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(dynamicChildren) {</span>
        <span class="s1">patchBlockChildren(n1.dynamicChildren</span><span class="s2">, </span><span class="s1">dynamicChildren</span><span class="s2">, </span><span class="s1">currentContainer</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds)</span><span class="s2">;</span>
        <span class="s1">traverseStaticChildren(n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!optimized) {</span>
        <span class="s1">patchChildren(n1</span><span class="s2">, </span><span class="s1">n2</span><span class="s2">, </span><span class="s1">currentContainer</span><span class="s2">, </span><span class="s1">currentAnchor</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, false</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(disabled) {</span>
        <span class="s2">if </span><span class="s1">(!wasDisabled) {</span>
          <span class="s1">moveTeleport(</span>
            <span class="s1">n2</span><span class="s2">,</span>
            <span class="s1">container</span><span class="s2">,</span>
            <span class="s1">mainAnchor</span><span class="s2">,</span>
            <span class="s1">internals</span><span class="s2">,</span>
            <span class="s4">1</span>
            <span class="s0">/* TeleportMoveTypes.TOGGLE */</span>
          <span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">if </span><span class="s1">((n2.props &amp;&amp; n2.props.to) !== (n1.props &amp;&amp; n1.props.to)) {</span>
          <span class="s2">const </span><span class="s1">nextTarget = n2.target = resolveTarget(n2.props</span><span class="s2">, </span><span class="s1">querySelector)</span><span class="s2">;</span>
          <span class="s2">if </span><span class="s1">(nextTarget) {</span>
            <span class="s1">moveTeleport(</span>
              <span class="s1">n2</span><span class="s2">,</span>
              <span class="s1">nextTarget</span><span class="s2">,</span>
              <span class="s2">null,</span>
              <span class="s1">internals</span><span class="s2">,</span>
              <span class="s4">0</span>
              <span class="s0">/* TeleportMoveTypes.TARGET_CHANGE */</span>
            <span class="s1">)</span><span class="s2">;</span>
          <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
            <span class="s1">warn2(</span><span class="s3">&quot;Invalid Teleport target on update:&quot;</span><span class="s2">, </span><span class="s1">target</span><span class="s2">, </span><span class="s3">`(</span><span class="s1">${</span><span class="s2">typeof </span><span class="s1">target}</span><span class="s3">)`</span><span class="s1">)</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(wasDisabled) {</span>
          <span class="s1">moveTeleport(</span>
            <span class="s1">n2</span><span class="s2">,</span>
            <span class="s1">target</span><span class="s2">,</span>
            <span class="s1">targetAnchor</span><span class="s2">,</span>
            <span class="s1">internals</span><span class="s2">,</span>
            <span class="s4">1</span>
            <span class="s0">/* TeleportMoveTypes.TOGGLE */</span>
          <span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">updateCssVars(n2)</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">,</span>
  <span class="s1">remove(vnode</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">optimized</span><span class="s2">, </span><span class="s1">{ um: unmount</span><span class="s2">, </span><span class="s1">o: { remove: hostRemove } }</span><span class="s2">, </span><span class="s1">doRemove) {</span>
    <span class="s2">const </span><span class="s1">{ shapeFlag</span><span class="s2">, </span><span class="s1">children</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">targetAnchor</span><span class="s2">, </span><span class="s1">target</span><span class="s2">, </span><span class="s1">props } = vnode</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(target) {</span>
      <span class="s1">hostRemove(targetAnchor)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(doRemove || !isTeleportDisabled(props)) {</span>
      <span class="s1">hostRemove(anchor)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(shapeFlag &amp; </span><span class="s4">16</span><span class="s1">) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; children.length</span><span class="s2">; </span><span class="s1">i++) {</span>
          <span class="s2">const </span><span class="s1">child = children[i]</span><span class="s2">;</span>
          <span class="s1">unmount(child</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, true, </span><span class="s1">!!child.dynamicChildren)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">,</span>
  <span class="s1">move: moveTeleport</span><span class="s2">,</span>
  <span class="s1">hydrate: hydrateTeleport</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">moveTeleport(vnode</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">parentAnchor</span><span class="s2">, </span><span class="s1">{ o: { insert }</span><span class="s2">, </span><span class="s1">m: move }</span><span class="s2">, </span><span class="s1">moveType = </span><span class="s4">2</span><span class="s1">) {</span>
  <span class="s2">if </span><span class="s1">(moveType === </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s1">insert(vnode.targetAnchor</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">parentAnchor)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">const </span><span class="s1">{ el</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">shapeFlag</span><span class="s2">, </span><span class="s1">children</span><span class="s2">, </span><span class="s1">props } = vnode</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">isReorder = moveType === </span><span class="s4">2</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(isReorder) {</span>
    <span class="s1">insert(el</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">parentAnchor)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(!isReorder || isTeleportDisabled(props)) {</span>
    <span class="s2">if </span><span class="s1">(shapeFlag &amp; </span><span class="s4">16</span><span class="s1">) {</span>
      <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; children.length</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s1">move(</span>
          <span class="s1">children[i]</span><span class="s2">,</span>
          <span class="s1">container</span><span class="s2">,</span>
          <span class="s1">parentAnchor</span><span class="s2">,</span>
          <span class="s4">2</span>
          <span class="s0">/* MoveType.REORDER */</span>
        <span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(isReorder) {</span>
    <span class="s1">insert(anchor</span><span class="s2">, </span><span class="s1">container</span><span class="s2">, </span><span class="s1">parentAnchor)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">hydrateTeleport(node</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized</span><span class="s2">, </span><span class="s1">{ o: { nextSibling</span><span class="s2">, </span><span class="s1">parentNode</span><span class="s2">, </span><span class="s1">querySelector } }</span><span class="s2">, </span><span class="s1">hydrateChildren) {</span>
  <span class="s2">const </span><span class="s1">target = vnode.target = resolveTarget(vnode.props</span><span class="s2">, </span><span class="s1">querySelector)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(target) {</span>
    <span class="s2">const </span><span class="s1">targetNode = target._lpa || target.firstChild</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(vnode.shapeFlag &amp; </span><span class="s4">16</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(isTeleportDisabled(vnode.props)) {</span>
        <span class="s1">vnode.anchor = hydrateChildren(nextSibling(node)</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">parentNode(node)</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
        <span class="s1">vnode.targetAnchor = targetNode</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">vnode.anchor = nextSibling(node)</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">targetAnchor = targetNode</span><span class="s2">;</span>
        <span class="s2">while </span><span class="s1">(targetAnchor) {</span>
          <span class="s1">targetAnchor = nextSibling(targetAnchor)</span><span class="s2">;</span>
          <span class="s2">if </span><span class="s1">(targetAnchor &amp;&amp; targetAnchor.nodeType === </span><span class="s4">8 </span><span class="s1">&amp;&amp; targetAnchor.data === </span><span class="s3">&quot;teleport anchor&quot;</span><span class="s1">) {</span>
            <span class="s1">vnode.targetAnchor = targetAnchor</span><span class="s2">;</span>
            <span class="s1">target._lpa = vnode.targetAnchor &amp;&amp; nextSibling(vnode.targetAnchor)</span><span class="s2">;</span>
            <span class="s2">break;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">hydrateChildren(targetNode</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">target</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">slotScopeIds</span><span class="s2">, </span><span class="s1">optimized)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">updateCssVars(vnode)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">vnode.anchor &amp;&amp; nextSibling(vnode.anchor)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">Teleport = TeleportImpl</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">updateCssVars(vnode) {</span>
  <span class="s2">const </span><span class="s1">ctx = vnode.ctx</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(ctx &amp;&amp; ctx.ut) {</span>
    <span class="s2">let </span><span class="s1">node = vnode.children[</span><span class="s4">0</span><span class="s1">].el</span><span class="s2">;</span>
    <span class="s2">while </span><span class="s1">(node !== vnode.targetAnchor) {</span>
      <span class="s2">if </span><span class="s1">(node.nodeType === </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">node.setAttribute(</span><span class="s3">&quot;data-v-owner&quot;</span><span class="s2">, </span><span class="s1">ctx.uid)</span><span class="s2">;</span>
      <span class="s1">node = node.nextSibling</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">ctx.ut()</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">Fragment = Symbol(</span><span class="s2">true </span><span class="s1">? </span><span class="s3">&quot;Fragment&quot; </span><span class="s1">: </span><span class="s2">void </span><span class="s4">0</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">Text = Symbol(</span><span class="s2">true </span><span class="s1">? </span><span class="s3">&quot;Text&quot; </span><span class="s1">: </span><span class="s2">void </span><span class="s4">0</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">Comment = Symbol(</span><span class="s2">true </span><span class="s1">? </span><span class="s3">&quot;Comment&quot; </span><span class="s1">: </span><span class="s2">void </span><span class="s4">0</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">Static = Symbol(</span><span class="s2">true </span><span class="s1">? </span><span class="s3">&quot;Static&quot; </span><span class="s1">: </span><span class="s2">void </span><span class="s4">0</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">blockStack = []</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">currentBlock = </span><span class="s2">null;</span>
<span class="s2">function </span><span class="s1">openBlock(disableTracking = </span><span class="s2">false</span><span class="s1">) {</span>
  <span class="s1">blockStack.push(currentBlock = disableTracking ? </span><span class="s2">null </span><span class="s1">: [])</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">closeBlock() {</span>
  <span class="s1">blockStack.pop()</span><span class="s2">;</span>
  <span class="s1">currentBlock = blockStack[blockStack.length - </span><span class="s4">1</span><span class="s1">] || </span><span class="s2">null;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">isBlockTreeEnabled = </span><span class="s4">1</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">setBlockTracking(value) {</span>
  <span class="s1">isBlockTreeEnabled += value</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">setupBlock(vnode) {</span>
  <span class="s1">vnode.dynamicChildren = isBlockTreeEnabled &gt; </span><span class="s4">0 </span><span class="s1">? currentBlock || EMPTY_ARR : </span><span class="s2">null;</span>
  <span class="s1">closeBlock()</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(isBlockTreeEnabled &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp; currentBlock) {</span>
    <span class="s1">currentBlock.push(vnode)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">vnode</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createElementBlock(type</span><span class="s2">, </span><span class="s1">props</span><span class="s2">, </span><span class="s1">children</span><span class="s2">, </span><span class="s1">patchFlag</span><span class="s2">, </span><span class="s1">dynamicProps</span><span class="s2">, </span><span class="s1">shapeFlag) {</span>
  <span class="s2">return </span><span class="s1">setupBlock(createBaseVNode(</span>
    <span class="s1">type</span><span class="s2">,</span>
    <span class="s1">props</span><span class="s2">,</span>
    <span class="s1">children</span><span class="s2">,</span>
    <span class="s1">patchFlag</span><span class="s2">,</span>
    <span class="s1">dynamicProps</span><span class="s2">,</span>
    <span class="s1">shapeFlag</span><span class="s2">,</span>
    <span class="s2">true</span>
    <span class="s0">/* isBlock */</span>
  <span class="s1">))</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createBlock(type</span><span class="s2">, </span><span class="s1">props</span><span class="s2">, </span><span class="s1">children</span><span class="s2">, </span><span class="s1">patchFlag</span><span class="s2">, </span><span class="s1">dynamicProps) {</span>
  <span class="s2">return </span><span class="s1">setupBlock(createVNode(</span>
    <span class="s1">type</span><span class="s2">,</span>
    <span class="s1">props</span><span class="s2">,</span>
    <span class="s1">children</span><span class="s2">,</span>
    <span class="s1">patchFlag</span><span class="s2">,</span>
    <span class="s1">dynamicProps</span><span class="s2">,</span>
    <span class="s2">true</span>
    <span class="s0">/* isBlock: prevent a block from tracking itself */</span>
  <span class="s1">))</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isVNode(value) {</span>
  <span class="s2">return </span><span class="s1">value ? value.__v_isVNode === </span><span class="s2">true </span><span class="s1">: </span><span class="s2">false;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isSameVNodeType(n1</span><span class="s2">, </span><span class="s1">n2) {</span>
  <span class="s2">if </span><span class="s1">(n2.shapeFlag &amp; </span><span class="s4">6 </span><span class="s1">&amp;&amp; hmrDirtyComponents.has(n2.type)) {</span>
    <span class="s1">n1.shapeFlag &amp;= ~</span><span class="s4">256</span><span class="s2">;</span>
    <span class="s1">n2.shapeFlag &amp;= ~</span><span class="s4">512</span><span class="s2">;</span>
    <span class="s2">return false;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">n1.type === n2.type &amp;&amp; n1.key === n2.key</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">vnodeArgsTransformer</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">transformVNodeArgs(transformer) {</span>
  <span class="s1">vnodeArgsTransformer = transformer</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">createVNodeWithArgsTransform = (...args) =&gt; {</span>
  <span class="s2">return </span><span class="s1">_createVNode(...vnodeArgsTransformer ? vnodeArgsTransformer(args</span><span class="s2">, </span><span class="s1">currentRenderingInstance) : args)</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">InternalObjectKey = </span><span class="s3">`__vInternal`</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">normalizeKey = ({ key }) =&gt; key != </span><span class="s2">null </span><span class="s1">? key : </span><span class="s2">null;</span>
<span class="s2">var </span><span class="s1">normalizeRef = ({ ref: ref2</span><span class="s2">, </span><span class="s1">ref_key</span><span class="s2">, </span><span class="s1">ref_for }) =&gt; {</span>
  <span class="s2">return </span><span class="s1">ref2 != </span><span class="s2">null </span><span class="s1">? isString(ref2) || isRef(ref2) || isFunction(ref2) ? { i: currentRenderingInstance</span><span class="s2">, </span><span class="s1">r: ref2</span><span class="s2">, </span><span class="s1">k: ref_key</span><span class="s2">, </span><span class="s1">f: !!ref_for } : ref2 : </span><span class="s2">null;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">createBaseVNode(type</span><span class="s2">, </span><span class="s1">props = </span><span class="s2">null, </span><span class="s1">children = </span><span class="s2">null, </span><span class="s1">patchFlag = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">dynamicProps = </span><span class="s2">null, </span><span class="s1">shapeFlag = type === Fragment ? </span><span class="s4">0 </span><span class="s1">: </span><span class="s4">1</span><span class="s2">, </span><span class="s1">isBlockNode = </span><span class="s2">false, </span><span class="s1">needFullChildrenNormalization = </span><span class="s2">false</span><span class="s1">) {</span>
  <span class="s2">const </span><span class="s1">vnode = {</span>
    <span class="s1">__v_isVNode: </span><span class="s2">true,</span>
    <span class="s1">__v_skip: </span><span class="s2">true,</span>
    <span class="s1">type</span><span class="s2">,</span>
    <span class="s1">props</span><span class="s2">,</span>
    <span class="s1">key: props &amp;&amp; normalizeKey(props)</span><span class="s2">,</span>
    <span class="s1">ref: props &amp;&amp; normalizeRef(props)</span><span class="s2">,</span>
    <span class="s1">scopeId: currentScopeId</span><span class="s2">,</span>
    <span class="s1">slotScopeIds: </span><span class="s2">null,</span>
    <span class="s1">children</span><span class="s2">,</span>
    <span class="s1">component: </span><span class="s2">null,</span>
    <span class="s1">suspense: </span><span class="s2">null,</span>
    <span class="s1">ssContent: </span><span class="s2">null,</span>
    <span class="s1">ssFallback: </span><span class="s2">null,</span>
    <span class="s1">dirs: </span><span class="s2">null,</span>
    <span class="s1">transition: </span><span class="s2">null,</span>
    <span class="s1">el: </span><span class="s2">null,</span>
    <span class="s1">anchor: </span><span class="s2">null,</span>
    <span class="s1">target: </span><span class="s2">null,</span>
    <span class="s1">targetAnchor: </span><span class="s2">null,</span>
    <span class="s1">staticCount: </span><span class="s4">0</span><span class="s2">,</span>
    <span class="s1">shapeFlag</span><span class="s2">,</span>
    <span class="s1">patchFlag</span><span class="s2">,</span>
    <span class="s1">dynamicProps</span><span class="s2">,</span>
    <span class="s1">dynamicChildren: </span><span class="s2">null,</span>
    <span class="s1">appContext: </span><span class="s2">null,</span>
    <span class="s1">ctx: currentRenderingInstance</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(needFullChildrenNormalization) {</span>
    <span class="s1">normalizeChildren(vnode</span><span class="s2">, </span><span class="s1">children)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(shapeFlag &amp; </span><span class="s4">128</span><span class="s1">) {</span>
      <span class="s1">type.normalize(vnode)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(children) {</span>
    <span class="s1">vnode.shapeFlag |= isString(children) ? </span><span class="s4">8 </span><span class="s1">: </span><span class="s4">16</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(vnode.key !== vnode.key) {</span>
    <span class="s1">warn2(</span><span class="s3">`VNode created with invalid key (NaN). VNode type:`</span><span class="s2">, </span><span class="s1">vnode.type)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(isBlockTreeEnabled &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp; </span><span class="s0">// avoid a block node from tracking itself</span>
  <span class="s1">!isBlockNode &amp;&amp; </span><span class="s0">// has current parent block</span>
  <span class="s1">currentBlock &amp;&amp; </span><span class="s0">// presence of a patch flag indicates this node needs patching on updates.</span>
  <span class="s0">// component nodes also should always be patched, because even if the</span>
  <span class="s0">// component doesn't need to update, it needs to persist the instance on to</span>
  <span class="s0">// the next vnode so that it can be properly unmounted later.</span>
  <span class="s1">(vnode.patchFlag &gt; </span><span class="s4">0 </span><span class="s1">|| shapeFlag &amp; </span><span class="s4">6</span><span class="s1">) &amp;&amp; </span><span class="s0">// the EVENTS flag is only for hydration and if it is the only flag, the</span>
  <span class="s0">// vnode should not be considered dynamic due to handler caching.</span>
  <span class="s1">vnode.patchFlag !== </span><span class="s4">32</span><span class="s1">) {</span>
    <span class="s1">currentBlock.push(vnode)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">vnode</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">createVNode = </span><span class="s2">true </span><span class="s1">? createVNodeWithArgsTransform : _createVNode</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">_createVNode(type</span><span class="s2">, </span><span class="s1">props = </span><span class="s2">null, </span><span class="s1">children = </span><span class="s2">null, </span><span class="s1">patchFlag = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">dynamicProps = </span><span class="s2">null, </span><span class="s1">isBlockNode = </span><span class="s2">false</span><span class="s1">) {</span>
  <span class="s2">if </span><span class="s1">(!type || type === NULL_DYNAMIC_COMPONENT) {</span>
    <span class="s2">if </span><span class="s1">(!type) {</span>
      <span class="s1">warn2(</span><span class="s3">`Invalid vnode type when creating vnode: </span><span class="s1">${type}</span><span class="s3">.`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">type = Comment</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(isVNode(type)) {</span>
    <span class="s2">const </span><span class="s1">cloned = cloneVNode(</span>
      <span class="s1">type</span><span class="s2">,</span>
      <span class="s1">props</span><span class="s2">,</span>
      <span class="s2">true</span>
      <span class="s0">/* mergeRef: true */</span>
    <span class="s1">)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(children) {</span>
      <span class="s1">normalizeChildren(cloned</span><span class="s2">, </span><span class="s1">children)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(isBlockTreeEnabled &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp; !isBlockNode &amp;&amp; currentBlock) {</span>
      <span class="s2">if </span><span class="s1">(cloned.shapeFlag &amp; </span><span class="s4">6</span><span class="s1">) {</span>
        <span class="s1">currentBlock[currentBlock.indexOf(type)] = cloned</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">currentBlock.push(cloned)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">cloned.patchFlag |= -</span><span class="s4">2</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">cloned</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(isClassComponent(type)) {</span>
    <span class="s1">type = type.__vccOpts</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(props) {</span>
    <span class="s1">props = guardReactiveProps(props)</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">{ </span><span class="s2">class</span><span class="s1">: klass</span><span class="s2">, </span><span class="s1">style } = props</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(klass &amp;&amp; !isString(klass)) {</span>
      <span class="s1">props.class = normalizeClass(klass)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(isObject(style)) {</span>
      <span class="s2">if </span><span class="s1">(isProxy(style) &amp;&amp; !isArray(style)) {</span>
        <span class="s1">style = extend({}</span><span class="s2">, </span><span class="s1">style)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s1">props.style = normalizeStyle(style)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">const </span><span class="s1">shapeFlag = isString(type) ? </span><span class="s4">1 </span><span class="s1">: isSuspense(type) ? </span><span class="s4">128 </span><span class="s1">: isTeleport(type) ? </span><span class="s4">64 </span><span class="s1">: isObject(type) ? </span><span class="s4">4 </span><span class="s1">: isFunction(type) ? </span><span class="s4">2 </span><span class="s1">: </span><span class="s4">0</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(shapeFlag &amp; </span><span class="s4">4 </span><span class="s1">&amp;&amp; isProxy(type)) {</span>
    <span class="s1">type = toRaw(type)</span><span class="s2">;</span>
    <span class="s1">warn2(</span><span class="s3">`Vue received a Component which was made a reactive object. This can lead to unnecessary performance overhead, and should be avoided by marking the component with </span><span class="s2">\`</span><span class="s3">markRaw</span><span class="s2">\` </span><span class="s3">or using </span><span class="s2">\`</span><span class="s3">shallowRef</span><span class="s2">\` </span><span class="s3">instead of </span><span class="s2">\`</span><span class="s3">ref</span><span class="s2">\`</span><span class="s3">.`</span><span class="s2">, </span><span class="s3">`</span>
<span class="s3">Component that was made reactive: `</span><span class="s2">, </span><span class="s1">type)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">createBaseVNode(type</span><span class="s2">, </span><span class="s1">props</span><span class="s2">, </span><span class="s1">children</span><span class="s2">, </span><span class="s1">patchFlag</span><span class="s2">, </span><span class="s1">dynamicProps</span><span class="s2">, </span><span class="s1">shapeFlag</span><span class="s2">, </span><span class="s1">isBlockNode</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">guardReactiveProps(props) {</span>
  <span class="s2">if </span><span class="s1">(!props)</span>
    <span class="s2">return null;</span>
  <span class="s2">return </span><span class="s1">isProxy(props) || InternalObjectKey </span><span class="s2">in </span><span class="s1">props ? extend({}</span><span class="s2">, </span><span class="s1">props) : props</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">cloneVNode(vnode</span><span class="s2">, </span><span class="s1">extraProps</span><span class="s2">, </span><span class="s1">mergeRef = </span><span class="s2">false</span><span class="s1">) {</span>
  <span class="s2">const </span><span class="s1">{ props</span><span class="s2">, </span><span class="s1">ref: ref2</span><span class="s2">, </span><span class="s1">patchFlag</span><span class="s2">, </span><span class="s1">children } = vnode</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">mergedProps = extraProps ? mergeProps(props || {}</span><span class="s2">, </span><span class="s1">extraProps) : props</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">cloned = {</span>
    <span class="s1">__v_isVNode: </span><span class="s2">true,</span>
    <span class="s1">__v_skip: </span><span class="s2">true,</span>
    <span class="s1">type: vnode.type</span><span class="s2">,</span>
    <span class="s1">props: mergedProps</span><span class="s2">,</span>
    <span class="s1">key: mergedProps &amp;&amp; normalizeKey(mergedProps)</span><span class="s2">,</span>
    <span class="s1">ref: extraProps &amp;&amp; extraProps.ref ? (</span>
      <span class="s0">// #2078 in the case of &lt;component :is=&quot;vnode&quot; ref=&quot;extra&quot;/&gt;</span>
      <span class="s0">// if the vnode itself already has a ref, cloneVNode will need to merge</span>
      <span class="s0">// the refs so the single vnode can be set on multiple refs</span>
      <span class="s1">mergeRef &amp;&amp; ref2 ? isArray(ref2) ? ref2.concat(normalizeRef(extraProps)) : [ref2</span><span class="s2">, </span><span class="s1">normalizeRef(extraProps)] : normalizeRef(extraProps)</span>
    <span class="s1">) : ref2</span><span class="s2">,</span>
    <span class="s1">scopeId: vnode.scopeId</span><span class="s2">,</span>
    <span class="s1">slotScopeIds: vnode.slotScopeIds</span><span class="s2">,</span>
    <span class="s1">children: patchFlag === -</span><span class="s4">1 </span><span class="s1">&amp;&amp; isArray(children) ? children.map(deepCloneVNode) : children</span><span class="s2">,</span>
    <span class="s1">target: vnode.target</span><span class="s2">,</span>
    <span class="s1">targetAnchor: vnode.targetAnchor</span><span class="s2">,</span>
    <span class="s1">staticCount: vnode.staticCount</span><span class="s2">,</span>
    <span class="s1">shapeFlag: vnode.shapeFlag</span><span class="s2">,</span>
    <span class="s0">// if the vnode is cloned with extra props, we can no longer assume its</span>
    <span class="s0">// existing patch flag to be reliable and need to add the FULL_PROPS flag.</span>
    <span class="s0">// note: preserve flag for fragments since they use the flag for children</span>
    <span class="s0">// fast paths only.</span>
    <span class="s1">patchFlag: extraProps &amp;&amp; vnode.type !== Fragment ? patchFlag === -</span><span class="s4">1 </span><span class="s1">? </span><span class="s4">16 </span><span class="s1">: patchFlag | </span><span class="s4">16 </span><span class="s1">: patchFlag</span><span class="s2">,</span>
    <span class="s1">dynamicProps: vnode.dynamicProps</span><span class="s2">,</span>
    <span class="s1">dynamicChildren: vnode.dynamicChildren</span><span class="s2">,</span>
    <span class="s1">appContext: vnode.appContext</span><span class="s2">,</span>
    <span class="s1">dirs: vnode.dirs</span><span class="s2">,</span>
    <span class="s1">transition: vnode.transition</span><span class="s2">,</span>
    <span class="s0">// These should technically only be non-null on mounted VNodes. However,</span>
    <span class="s0">// they *should* be copied for kept-alive vnodes. So we just always copy</span>
    <span class="s0">// them since them being non-null during a mount doesn't affect the logic as</span>
    <span class="s0">// they will simply be overwritten.</span>
    <span class="s1">component: vnode.component</span><span class="s2">,</span>
    <span class="s1">suspense: vnode.suspense</span><span class="s2">,</span>
    <span class="s1">ssContent: vnode.ssContent &amp;&amp; cloneVNode(vnode.ssContent)</span><span class="s2">,</span>
    <span class="s1">ssFallback: vnode.ssFallback &amp;&amp; cloneVNode(vnode.ssFallback)</span><span class="s2">,</span>
    <span class="s1">el: vnode.el</span><span class="s2">,</span>
    <span class="s1">anchor: vnode.anchor</span><span class="s2">,</span>
    <span class="s1">ctx: vnode.ctx</span><span class="s2">,</span>
    <span class="s1">ce: vnode.ce</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">return </span><span class="s1">cloned</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">deepCloneVNode(vnode) {</span>
  <span class="s2">const </span><span class="s1">cloned = cloneVNode(vnode)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(isArray(vnode.children)) {</span>
    <span class="s1">cloned.children = vnode.children.map(deepCloneVNode)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">cloned</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createTextVNode(text = </span><span class="s3">&quot; &quot;</span><span class="s2">, </span><span class="s1">flag = </span><span class="s4">0</span><span class="s1">) {</span>
  <span class="s2">return </span><span class="s1">createVNode(Text</span><span class="s2">, null, </span><span class="s1">text</span><span class="s2">, </span><span class="s1">flag)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createStaticVNode(content</span><span class="s2">, </span><span class="s1">numberOfNodes) {</span>
  <span class="s2">const </span><span class="s1">vnode = createVNode(Static</span><span class="s2">, null, </span><span class="s1">content)</span><span class="s2">;</span>
  <span class="s1">vnode.staticCount = numberOfNodes</span><span class="s2">;</span>
  <span class="s2">return </span><span class="s1">vnode</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createCommentVNode(text = </span><span class="s3">&quot;&quot;</span><span class="s2">, </span><span class="s1">asBlock = </span><span class="s2">false</span><span class="s1">) {</span>
  <span class="s2">return </span><span class="s1">asBlock ? (openBlock()</span><span class="s2">, </span><span class="s1">createBlock(Comment</span><span class="s2">, null, </span><span class="s1">text)) : createVNode(Comment</span><span class="s2">, null, </span><span class="s1">text)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">normalizeVNode(child) {</span>
  <span class="s2">if </span><span class="s1">(child == </span><span class="s2">null </span><span class="s1">|| </span><span class="s2">typeof </span><span class="s1">child === </span><span class="s3">&quot;boolean&quot;</span><span class="s1">) {</span>
    <span class="s2">return </span><span class="s1">createVNode(Comment)</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isArray(child)) {</span>
    <span class="s2">return </span><span class="s1">createVNode(</span>
      <span class="s1">Fragment</span><span class="s2">,</span>
      <span class="s2">null,</span>
      <span class="s0">// #3666, avoid reference pollution when reusing vnode</span>
      <span class="s1">child.slice()</span>
    <span class="s1">)</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">child === </span><span class="s3">&quot;object&quot;</span><span class="s1">) {</span>
    <span class="s2">return </span><span class="s1">cloneIfMounted(child)</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s2">return </span><span class="s1">createVNode(Text</span><span class="s2">, null, </span><span class="s1">String(child))</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">cloneIfMounted(child) {</span>
  <span class="s2">return </span><span class="s1">child.el === </span><span class="s2">null </span><span class="s1">&amp;&amp; child.patchFlag !== -</span><span class="s4">1 </span><span class="s1">|| child.memo ? child : cloneVNode(child)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">normalizeChildren(vnode</span><span class="s2">, </span><span class="s1">children) {</span>
  <span class="s2">let </span><span class="s1">type = </span><span class="s4">0</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">{ shapeFlag } = vnode</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(children == </span><span class="s2">null</span><span class="s1">) {</span>
    <span class="s1">children = </span><span class="s2">null;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isArray(children)) {</span>
    <span class="s1">type = </span><span class="s4">16</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">children === </span><span class="s3">&quot;object&quot;</span><span class="s1">) {</span>
    <span class="s2">if </span><span class="s1">(shapeFlag &amp; (</span><span class="s4">1 </span><span class="s1">| </span><span class="s4">64</span><span class="s1">)) {</span>
      <span class="s2">const </span><span class="s1">slot = children.default</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(slot) {</span>
        <span class="s1">slot._c &amp;&amp; (slot._d = </span><span class="s2">false</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">normalizeChildren(vnode</span><span class="s2">, </span><span class="s1">slot())</span><span class="s2">;</span>
        <span class="s1">slot._c &amp;&amp; (slot._d = </span><span class="s2">true</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">return;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">type = </span><span class="s4">32</span><span class="s2">;</span>
      <span class="s2">const </span><span class="s1">slotFlag = children._</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(!slotFlag &amp;&amp; !(InternalObjectKey </span><span class="s2">in </span><span class="s1">children)) {</span>
        <span class="s1">children._ctx = currentRenderingInstance</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(slotFlag === </span><span class="s4">3 </span><span class="s1">&amp;&amp; currentRenderingInstance) {</span>
        <span class="s2">if </span><span class="s1">(currentRenderingInstance.slots._ === </span><span class="s4">1</span><span class="s1">) {</span>
          <span class="s1">children._ = </span><span class="s4">1</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">children._ = </span><span class="s4">2</span><span class="s2">;</span>
          <span class="s1">vnode.patchFlag |= </span><span class="s4">1024</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isFunction(children)) {</span>
    <span class="s1">children = { </span><span class="s2">default</span><span class="s1">: children</span><span class="s2">, </span><span class="s1">_ctx: currentRenderingInstance }</span><span class="s2">;</span>
    <span class="s1">type = </span><span class="s4">32</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s1">children = String(children)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(shapeFlag &amp; </span><span class="s4">64</span><span class="s1">) {</span>
      <span class="s1">type = </span><span class="s4">16</span><span class="s2">;</span>
      <span class="s1">children = [createTextVNode(children)]</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">type = </span><span class="s4">8</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">vnode.children = children</span><span class="s2">;</span>
  <span class="s1">vnode.shapeFlag |= type</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">mergeProps(...args) {</span>
  <span class="s2">const </span><span class="s1">ret = {}</span><span class="s2">;</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; args.length</span><span class="s2">; </span><span class="s1">i++) {</span>
    <span class="s2">const </span><span class="s1">toMerge = args[i]</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">toMerge) {</span>
      <span class="s2">if </span><span class="s1">(key === </span><span class="s3">&quot;class&quot;</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(ret.class !== toMerge.class) {</span>
          <span class="s1">ret.class = normalizeClass([ret.class</span><span class="s2">, </span><span class="s1">toMerge.class])</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(key === </span><span class="s3">&quot;style&quot;</span><span class="s1">) {</span>
        <span class="s1">ret.style = normalizeStyle([ret.style</span><span class="s2">, </span><span class="s1">toMerge.style])</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isOn(key)) {</span>
        <span class="s2">const </span><span class="s1">existing = ret[key]</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">incoming = toMerge[key]</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(incoming &amp;&amp; existing !== incoming &amp;&amp; !(isArray(existing) &amp;&amp; existing.includes(incoming))) {</span>
          <span class="s1">ret[key] = existing ? [].concat(existing</span><span class="s2">, </span><span class="s1">incoming) : incoming</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(key !== </span><span class="s3">&quot;&quot;</span><span class="s1">) {</span>
        <span class="s1">ret[key] = toMerge[key]</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">ret</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">invokeVNodeHook(hook</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">prevVNode = </span><span class="s2">null</span><span class="s1">) {</span>
  <span class="s1">callWithAsyncErrorHandling(hook</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s1">[</span>
    <span class="s1">vnode</span><span class="s2">,</span>
    <span class="s1">prevVNode</span>
  <span class="s1">])</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">emptyAppContext = createAppContext()</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">uid = </span><span class="s4">0</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">createComponentInstance(vnode</span><span class="s2">, </span><span class="s1">parent</span><span class="s2">, </span><span class="s1">suspense) {</span>
  <span class="s2">const </span><span class="s1">type = vnode.type</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">instance = {</span>
    <span class="s1">uid: uid++</span><span class="s2">,</span>
    <span class="s1">vnode</span><span class="s2">,</span>
    <span class="s1">type</span><span class="s2">,</span>
    <span class="s1">parent</span><span class="s2">,</span>
    <span class="s1">appContext</span><span class="s2">,</span>
    <span class="s1">root: </span><span class="s2">null,</span>
    <span class="s1">next: </span><span class="s2">null,</span>
    <span class="s1">subTree: </span><span class="s2">null,</span>
    <span class="s1">effect: </span><span class="s2">null,</span>
    <span class="s1">update: </span><span class="s2">null,</span>
    <span class="s1">scope: </span><span class="s2">new </span><span class="s1">EffectScope(</span>
      <span class="s2">true</span>
      <span class="s0">/* detached */</span>
    <span class="s1">)</span><span class="s2">,</span>
    <span class="s1">render: </span><span class="s2">null,</span>
    <span class="s1">proxy: </span><span class="s2">null,</span>
    <span class="s1">exposed: </span><span class="s2">null,</span>
    <span class="s1">exposeProxy: </span><span class="s2">null,</span>
    <span class="s1">withProxy: </span><span class="s2">null,</span>
    <span class="s1">provides: parent ? parent.provides : Object.create(appContext.provides)</span><span class="s2">,</span>
    <span class="s1">accessCache: </span><span class="s2">null,</span>
    <span class="s1">renderCache: []</span><span class="s2">,</span>
    <span class="s0">// local resolved assets</span>
    <span class="s1">components: </span><span class="s2">null,</span>
    <span class="s1">directives: </span><span class="s2">null,</span>
    <span class="s0">// resolved props and emits options</span>
    <span class="s1">propsOptions: normalizePropsOptions(type</span><span class="s2">, </span><span class="s1">appContext)</span><span class="s2">,</span>
    <span class="s1">emitsOptions: normalizeEmitsOptions(type</span><span class="s2">, </span><span class="s1">appContext)</span><span class="s2">,</span>
    <span class="s0">// emit</span>
    <span class="s1">emit: </span><span class="s2">null,</span>
    <span class="s1">emitted: </span><span class="s2">null,</span>
    <span class="s0">// props default value</span>
    <span class="s1">propsDefaults: EMPTY_OBJ</span><span class="s2">,</span>
    <span class="s0">// inheritAttrs</span>
    <span class="s1">inheritAttrs: type.inheritAttrs</span><span class="s2">,</span>
    <span class="s0">// state</span>
    <span class="s1">ctx: EMPTY_OBJ</span><span class="s2">,</span>
    <span class="s1">data: EMPTY_OBJ</span><span class="s2">,</span>
    <span class="s1">props: EMPTY_OBJ</span><span class="s2">,</span>
    <span class="s1">attrs: EMPTY_OBJ</span><span class="s2">,</span>
    <span class="s1">slots: EMPTY_OBJ</span><span class="s2">,</span>
    <span class="s1">refs: EMPTY_OBJ</span><span class="s2">,</span>
    <span class="s1">setupState: EMPTY_OBJ</span><span class="s2">,</span>
    <span class="s1">setupContext: </span><span class="s2">null,</span>
    <span class="s0">// suspense related</span>
    <span class="s1">suspense</span><span class="s2">,</span>
    <span class="s1">suspenseId: suspense ? suspense.pendingId : </span><span class="s4">0</span><span class="s2">,</span>
    <span class="s1">asyncDep: </span><span class="s2">null,</span>
    <span class="s1">asyncResolved: </span><span class="s2">false,</span>
    <span class="s0">// lifecycle hooks</span>
    <span class="s0">// not using enums here because it results in computed properties</span>
    <span class="s1">isMounted: </span><span class="s2">false,</span>
    <span class="s1">isUnmounted: </span><span class="s2">false,</span>
    <span class="s1">isDeactivated: </span><span class="s2">false,</span>
    <span class="s1">bc: </span><span class="s2">null,</span>
    <span class="s1">c: </span><span class="s2">null,</span>
    <span class="s1">bm: </span><span class="s2">null,</span>
    <span class="s1">m: </span><span class="s2">null,</span>
    <span class="s1">bu: </span><span class="s2">null,</span>
    <span class="s1">u: </span><span class="s2">null,</span>
    <span class="s1">um: </span><span class="s2">null,</span>
    <span class="s1">bum: </span><span class="s2">null,</span>
    <span class="s1">da: </span><span class="s2">null,</span>
    <span class="s1">a: </span><span class="s2">null,</span>
    <span class="s1">rtg: </span><span class="s2">null,</span>
    <span class="s1">rtc: </span><span class="s2">null,</span>
    <span class="s1">ec: </span><span class="s2">null,</span>
    <span class="s1">sp: </span><span class="s2">null</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s1">instance.ctx = createDevRenderContext(instance)</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s1">instance.ctx = { _: instance }</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s1">instance.root = parent ? parent.root : instance</span><span class="s2">;</span>
  <span class="s1">instance.emit = emit.bind(</span><span class="s2">null, </span><span class="s1">instance)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(vnode.ce) {</span>
    <span class="s1">vnode.ce(instance)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">instance</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">currentInstance = </span><span class="s2">null;</span>
<span class="s2">var </span><span class="s1">getCurrentInstance = () =&gt; currentInstance || currentRenderingInstance</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">setCurrentInstance = (instance) =&gt; {</span>
  <span class="s1">currentInstance = instance</span><span class="s2">;</span>
  <span class="s1">instance.scope.on()</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">unsetCurrentInstance = () =&gt; {</span>
  <span class="s1">currentInstance &amp;&amp; currentInstance.scope.off()</span><span class="s2">;</span>
  <span class="s1">currentInstance = </span><span class="s2">null;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">isBuiltInTag = makeMap(</span><span class="s3">&quot;slot,component&quot;</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">validateComponentName(name</span><span class="s2">, </span><span class="s1">config) {</span>
  <span class="s2">const </span><span class="s1">appIsNativeTag = config.isNativeTag || NO</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(isBuiltInTag(name) || appIsNativeTag(name)) {</span>
    <span class="s1">warn2(</span><span class="s3">&quot;Do not use built-in or reserved HTML elements as component id: &quot; </span><span class="s1">+ name)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isStatefulComponent(instance) {</span>
  <span class="s2">return </span><span class="s1">instance.vnode.shapeFlag &amp; </span><span class="s4">4</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">isInSSRComponentSetup = </span><span class="s2">false;</span>
<span class="s2">function </span><span class="s1">setupComponent(instance</span><span class="s2">, </span><span class="s1">isSSR = </span><span class="s2">false</span><span class="s1">) {</span>
  <span class="s1">isInSSRComponentSetup = isSSR</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">{ props</span><span class="s2">, </span><span class="s1">children } = instance.vnode</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">isStateful = isStatefulComponent(instance)</span><span class="s2">;</span>
  <span class="s1">initProps(instance</span><span class="s2">, </span><span class="s1">props</span><span class="s2">, </span><span class="s1">isStateful</span><span class="s2">, </span><span class="s1">isSSR)</span><span class="s2">;</span>
  <span class="s1">initSlots(instance</span><span class="s2">, </span><span class="s1">children)</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">setupResult = isStateful ? setupStatefulComponent(instance</span><span class="s2">, </span><span class="s1">isSSR) : </span><span class="s2">void </span><span class="s4">0</span><span class="s2">;</span>
  <span class="s1">isInSSRComponentSetup = </span><span class="s2">false;</span>
  <span class="s2">return </span><span class="s1">setupResult</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">setupStatefulComponent(instance</span><span class="s2">, </span><span class="s1">isSSR) {</span>
  <span class="s2">var </span><span class="s1">_a2</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">Component = instance.type</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s2">if </span><span class="s1">(Component.name) {</span>
      <span class="s1">validateComponentName(Component.name</span><span class="s2">, </span><span class="s1">instance.appContext.config)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(Component.components) {</span>
      <span class="s2">const </span><span class="s1">names = Object.keys(Component.components)</span><span class="s2">;</span>
      <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; names.length</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s1">validateComponentName(names[i]</span><span class="s2">, </span><span class="s1">instance.appContext.config)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(Component.directives) {</span>
      <span class="s2">const </span><span class="s1">names = Object.keys(Component.directives)</span><span class="s2">;</span>
      <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; names.length</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s1">validateDirectiveName(names[i])</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(Component.compilerOptions &amp;&amp; isRuntimeOnly()) {</span>
      <span class="s1">warn2(</span><span class="s3">`&quot;compilerOptions&quot; is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">instance.accessCache = </span><span class="s0">/* @__PURE__ */ </span><span class="s1">Object.create(</span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">instance.proxy = markRaw(</span><span class="s2">new </span><span class="s1">Proxy(instance.ctx</span><span class="s2">, </span><span class="s1">PublicInstanceProxyHandlers))</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s1">exposePropsOnRenderContext(instance)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">const </span><span class="s1">{ setup } = Component</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(setup) {</span>
    <span class="s2">const </span><span class="s1">setupContext = instance.setupContext = setup.length &gt; </span><span class="s4">1 </span><span class="s1">? createSetupContext(instance) : </span><span class="s2">null;</span>
    <span class="s1">setCurrentInstance(instance)</span><span class="s2">;</span>
    <span class="s1">pauseTracking()</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">setupResult = callWithErrorHandling(setup</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">[</span><span class="s2">true </span><span class="s1">? shallowReadonly(instance.props) : instance.props</span><span class="s2">, </span><span class="s1">setupContext])</span><span class="s2">;</span>
    <span class="s1">resetTracking()</span><span class="s2">;</span>
    <span class="s1">unsetCurrentInstance()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(isPromise(setupResult)) {</span>
      <span class="s1">setupResult.then(unsetCurrentInstance</span><span class="s2">, </span><span class="s1">unsetCurrentInstance)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(isSSR) {</span>
        <span class="s2">return </span><span class="s1">setupResult.then((resolvedResult) =&gt; {</span>
          <span class="s1">handleSetupResult(instance</span><span class="s2">, </span><span class="s1">resolvedResult</span><span class="s2">, </span><span class="s1">isSSR)</span><span class="s2">;</span>
        <span class="s1">}).catch((e) =&gt; {</span>
          <span class="s1">handleError(</span>
            <span class="s1">e</span><span class="s2">,</span>
            <span class="s1">instance</span><span class="s2">,</span>
            <span class="s4">0</span>
            <span class="s0">/* ErrorCodes.SETUP_FUNCTION */</span>
          <span class="s1">)</span><span class="s2">;</span>
        <span class="s1">})</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">instance.asyncDep = setupResult</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!instance.suspense) {</span>
          <span class="s2">const </span><span class="s1">name = (_a2 = Component.name) !== </span><span class="s2">null </span><span class="s1">&amp;&amp; _a2 !== </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">? _a2 : </span><span class="s3">&quot;Anonymous&quot;</span><span class="s2">;</span>
          <span class="s1">warn2(</span><span class="s3">`Component &lt;</span><span class="s1">${name}</span><span class="s3">&gt;: setup function returned a promise, but no &lt;Suspense&gt; boundary was found in the parent component tree. A component with async setup() must be nested in a &lt;Suspense&gt; in order to be rendered.`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">handleSetupResult(instance</span><span class="s2">, </span><span class="s1">setupResult</span><span class="s2">, </span><span class="s1">isSSR)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s1">finishComponentSetup(instance</span><span class="s2">, </span><span class="s1">isSSR)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">handleSetupResult(instance</span><span class="s2">, </span><span class="s1">setupResult</span><span class="s2">, </span><span class="s1">isSSR) {</span>
  <span class="s2">if </span><span class="s1">(isFunction(setupResult)) {</span>
    <span class="s2">if </span><span class="s1">(instance.type.__ssrInlineRender) {</span>
      <span class="s1">instance.ssrRender = setupResult</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">instance.render = setupResult</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isObject(setupResult)) {</span>
    <span class="s2">if </span><span class="s1">(isVNode(setupResult)) {</span>
      <span class="s1">warn2(</span><span class="s3">`setup() should not return VNodes directly - return a render function instead.`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
      <span class="s1">instance.devtoolsRawSetupState = setupResult</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">instance.setupState = proxyRefs(setupResult)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
      <span class="s1">exposeSetupStateOnRenderContext(instance)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(setupResult !== </span><span class="s2">void </span><span class="s4">0</span><span class="s1">) {</span>
    <span class="s1">warn2(</span><span class="s3">`setup() should return an object. Received: </span><span class="s1">${setupResult === </span><span class="s2">null </span><span class="s1">? </span><span class="s3">&quot;null&quot; </span><span class="s1">: </span><span class="s2">typeof </span><span class="s1">setupResult}</span><span class="s3">`</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s1">finishComponentSetup(instance</span><span class="s2">, </span><span class="s1">isSSR)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">compile</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">installWithProxy</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">registerRuntimeCompiler(_compile) {</span>
  <span class="s1">compile = _compile</span><span class="s2">;</span>
  <span class="s1">installWithProxy = (i) =&gt; {</span>
    <span class="s2">if </span><span class="s1">(i.render._rc) {</span>
      <span class="s1">i.withProxy = </span><span class="s2">new </span><span class="s1">Proxy(i.ctx</span><span class="s2">, </span><span class="s1">RuntimeCompiledPublicInstanceProxyHandlers)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">isRuntimeOnly = () =&gt; !compile</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">finishComponentSetup(instance</span><span class="s2">, </span><span class="s1">isSSR</span><span class="s2">, </span><span class="s1">skipOptions) {</span>
  <span class="s2">const </span><span class="s1">Component = instance.type</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(!instance.render) {</span>
    <span class="s2">if </span><span class="s1">(!isSSR &amp;&amp; compile &amp;&amp; !Component.render) {</span>
      <span class="s2">const </span><span class="s1">template = Component.template || resolveMergedOptions(instance).template</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(template) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
          <span class="s1">startMeasure(instance</span><span class="s2">, </span><span class="s3">`compile`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">{ isCustomElement</span><span class="s2">, </span><span class="s1">compilerOptions } = instance.appContext.config</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">{ delimiters</span><span class="s2">, </span><span class="s1">compilerOptions: componentCompilerOptions } = Component</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">finalCompilerOptions = extend(extend({</span>
          <span class="s1">isCustomElement</span><span class="s2">,</span>
          <span class="s1">delimiters</span>
        <span class="s1">}</span><span class="s2">, </span><span class="s1">compilerOptions)</span><span class="s2">, </span><span class="s1">componentCompilerOptions)</span><span class="s2">;</span>
        <span class="s1">Component.render = compile(template</span><span class="s2">, </span><span class="s1">finalCompilerOptions)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
          <span class="s1">endMeasure(instance</span><span class="s2">, </span><span class="s3">`compile`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">instance.render = Component.render || NOOP</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(installWithProxy) {</span>
      <span class="s1">installWithProxy(instance)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(__VUE_OPTIONS_API__ &amp;&amp; </span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s1">setCurrentInstance(instance)</span><span class="s2">;</span>
    <span class="s1">pauseTracking()</span><span class="s2">;</span>
    <span class="s1">applyOptions(instance)</span><span class="s2">;</span>
    <span class="s1">resetTracking()</span><span class="s2">;</span>
    <span class="s1">unsetCurrentInstance()</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(!Component.render &amp;&amp; instance.render === NOOP &amp;&amp; !isSSR) {</span>
    <span class="s2">if </span><span class="s1">(!compile &amp;&amp; Component.template) {</span>
      <span class="s1">warn2(</span>
        <span class="s3">`Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias &quot;vue&quot; to &quot;vue/dist/vue.esm-bundler.js&quot;.`</span>
        <span class="s0">/* should not happen */</span>
      <span class="s1">)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">warn2(</span><span class="s3">`Component is missing template or render function.`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createAttrsProxy(instance) {</span>
  <span class="s2">return new </span><span class="s1">Proxy(instance.attrs</span><span class="s2">, true </span><span class="s1">? {</span>
    <span class="s1">get(target</span><span class="s2">, </span><span class="s1">key) {</span>
      <span class="s1">markAttrsAccessed()</span><span class="s2">;</span>
      <span class="s1">track(instance</span><span class="s2">, </span><span class="s3">&quot;get&quot;</span><span class="s2">, </span><span class="s3">&quot;$attrs&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">return </span><span class="s1">target[key]</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">set() {</span>
      <span class="s1">warn2(</span><span class="s3">`setupContext.attrs is readonly.`</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">return false;</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">deleteProperty() {</span>
      <span class="s1">warn2(</span><span class="s3">`setupContext.attrs is readonly.`</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">return false;</span>
    <span class="s1">}</span>
  <span class="s1">} : {</span>
    <span class="s1">get(target</span><span class="s2">, </span><span class="s1">key) {</span>
      <span class="s1">track(instance</span><span class="s2">, </span><span class="s3">&quot;get&quot;</span><span class="s2">, </span><span class="s3">&quot;$attrs&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">return </span><span class="s1">target[key]</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">})</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createSetupContext(instance) {</span>
  <span class="s2">const </span><span class="s1">expose = (exposed) =&gt; {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(instance.exposed) {</span>
        <span class="s1">warn2(</span><span class="s3">`expose() should be called only once per setup().`</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(exposed != </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">let </span><span class="s1">exposedType = </span><span class="s2">typeof </span><span class="s1">exposed</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(exposedType === </span><span class="s3">&quot;object&quot;</span><span class="s1">) {</span>
          <span class="s2">if </span><span class="s1">(isArray(exposed)) {</span>
            <span class="s1">exposedType = </span><span class="s3">&quot;array&quot;</span><span class="s2">;</span>
          <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isRef(exposed)) {</span>
            <span class="s1">exposedType = </span><span class="s3">&quot;ref&quot;</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(exposedType !== </span><span class="s3">&quot;object&quot;</span><span class="s1">) {</span>
          <span class="s1">warn2(</span><span class="s3">`expose() should be passed a plain object, received </span><span class="s1">${exposedType}</span><span class="s3">.`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">instance.exposed = exposed || {}</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">let </span><span class="s1">attrs</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s2">return </span><span class="s1">Object.freeze({</span>
      <span class="s1">get attrs() {</span>
        <span class="s2">return </span><span class="s1">attrs || (attrs = createAttrsProxy(instance))</span><span class="s2">;</span>
      <span class="s1">}</span><span class="s2">,</span>
      <span class="s1">get slots() {</span>
        <span class="s2">return </span><span class="s1">shallowReadonly(instance.slots)</span><span class="s2">;</span>
      <span class="s1">}</span><span class="s2">,</span>
      <span class="s1">get emit() {</span>
        <span class="s2">return </span><span class="s1">(event</span><span class="s2">, </span><span class="s1">...args) =&gt; instance.emit(event</span><span class="s2">, </span><span class="s1">...args)</span><span class="s2">;</span>
      <span class="s1">}</span><span class="s2">,</span>
      <span class="s1">expose</span>
    <span class="s1">})</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s2">return </span><span class="s1">{</span>
      <span class="s1">get attrs() {</span>
        <span class="s2">return </span><span class="s1">attrs || (attrs = createAttrsProxy(instance))</span><span class="s2">;</span>
      <span class="s1">}</span><span class="s2">,</span>
      <span class="s1">slots: instance.slots</span><span class="s2">,</span>
      <span class="s1">emit: instance.emit</span><span class="s2">,</span>
      <span class="s1">expose</span>
    <span class="s1">}</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getExposeProxy(instance) {</span>
  <span class="s2">if </span><span class="s1">(instance.exposed) {</span>
    <span class="s2">return </span><span class="s1">instance.exposeProxy || (instance.exposeProxy = </span><span class="s2">new </span><span class="s1">Proxy(proxyRefs(markRaw(instance.exposed))</span><span class="s2">, </span><span class="s1">{</span>
      <span class="s1">get(target</span><span class="s2">, </span><span class="s1">key) {</span>
        <span class="s2">if </span><span class="s1">(key </span><span class="s2">in </span><span class="s1">target) {</span>
          <span class="s2">return </span><span class="s1">target[key]</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(key </span><span class="s2">in </span><span class="s1">publicPropertiesMap) {</span>
          <span class="s2">return </span><span class="s1">publicPropertiesMap[key](instance)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span><span class="s2">,</span>
      <span class="s1">has(target</span><span class="s2">, </span><span class="s1">key) {</span>
        <span class="s2">return </span><span class="s1">key </span><span class="s2">in </span><span class="s1">target || key </span><span class="s2">in </span><span class="s1">publicPropertiesMap</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}))</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">classifyRE = </span><span class="s4">/(?:^|[-_])(\w)/g</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">classify = (str) =&gt; str.replace(classifyRE</span><span class="s2">, </span><span class="s1">(c) =&gt; c.toUpperCase()).replace(</span><span class="s4">/[-_]/g</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">getComponentName(Component</span><span class="s2">, </span><span class="s1">includeInferred = </span><span class="s2">true</span><span class="s1">) {</span>
  <span class="s2">return </span><span class="s1">isFunction(Component) ? Component.displayName || Component.name : Component.name || includeInferred &amp;&amp; Component.__name</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">formatComponentName(instance</span><span class="s2">, </span><span class="s1">Component</span><span class="s2">, </span><span class="s1">isRoot = </span><span class="s2">false</span><span class="s1">) {</span>
  <span class="s2">let </span><span class="s1">name = getComponentName(Component)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(!name &amp;&amp; Component.__file) {</span>
    <span class="s2">const </span><span class="s1">match = Component.__file.match(</span><span class="s4">/([^/\\]+)\.\w+$/</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(match) {</span>
      <span class="s1">name = match[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(!name &amp;&amp; instance &amp;&amp; instance.parent) {</span>
    <span class="s2">const </span><span class="s1">inferFromRegistry = (registry) =&gt; {</span>
      <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">registry) {</span>
        <span class="s2">if </span><span class="s1">(registry[key] === Component) {</span>
          <span class="s2">return </span><span class="s1">key</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s1">name = inferFromRegistry(instance.components || instance.parent.type.components) || inferFromRegistry(instance.appContext.components)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">name ? classify(name) : isRoot ? </span><span class="s3">`App` </span><span class="s1">: </span><span class="s3">`Anonymous`</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isClassComponent(value) {</span>
  <span class="s2">return </span><span class="s1">isFunction(value) &amp;&amp; </span><span class="s3">&quot;__vccOpts&quot; </span><span class="s2">in </span><span class="s1">value</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">computed2 = (getterOrOptions</span><span class="s2">, </span><span class="s1">debugOptions) =&gt; {</span>
  <span class="s2">return </span><span class="s1">computed(getterOrOptions</span><span class="s2">, </span><span class="s1">debugOptions</span><span class="s2">, </span><span class="s1">isInSSRComponentSetup)</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">warnRuntimeUsage = (method) =&gt; warn2(</span><span class="s3">`</span><span class="s1">${method}</span><span class="s3">() is a compiler-hint helper that is only usable inside &lt;script setup&gt; of a single file component. Its arguments should be compiled away and passing it at runtime has no effect.`</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">defineProps() {</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s1">warnRuntimeUsage(</span><span class="s3">`defineProps`</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return null;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">defineEmits() {</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s1">warnRuntimeUsage(</span><span class="s3">`defineEmits`</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return null;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">defineExpose(exposed) {</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s1">warnRuntimeUsage(</span><span class="s3">`defineExpose`</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">withDefaults(props</span><span class="s2">, </span><span class="s1">defaults) {</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s1">warnRuntimeUsage(</span><span class="s3">`withDefaults`</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return null;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">useSlots() {</span>
  <span class="s2">return </span><span class="s1">getContext().slots</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">useAttrs() {</span>
  <span class="s2">return </span><span class="s1">getContext().attrs</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getContext() {</span>
  <span class="s2">const </span><span class="s1">i = getCurrentInstance()</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(!i) {</span>
    <span class="s1">warn2(</span><span class="s3">`useContext() called without active instance.`</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">i.setupContext || (i.setupContext = createSetupContext(i))</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">mergeDefaults(raw</span><span class="s2">, </span><span class="s1">defaults) {</span>
  <span class="s2">const </span><span class="s1">props = isArray(raw) ? raw.reduce((normalized</span><span class="s2">, </span><span class="s1">p2) =&gt; (normalized[p2] = {}</span><span class="s2">, </span><span class="s1">normalized)</span><span class="s2">, </span><span class="s1">{}) : raw</span><span class="s2">;</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">defaults) {</span>
    <span class="s2">const </span><span class="s1">opt = props[key]</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(opt) {</span>
      <span class="s2">if </span><span class="s1">(isArray(opt) || isFunction(opt)) {</span>
        <span class="s1">props[key] = { type: opt</span><span class="s2">, default</span><span class="s1">: defaults[key] }</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">opt.default = defaults[key]</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(opt === </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">props[key] = { </span><span class="s2">default</span><span class="s1">: defaults[key] }</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
      <span class="s1">warn2(</span><span class="s3">`props default key &quot;</span><span class="s1">${key}</span><span class="s3">&quot; has no corresponding declaration.`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">props</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createPropsRestProxy(props</span><span class="s2">, </span><span class="s1">excludedKeys) {</span>
  <span class="s2">const </span><span class="s1">ret = {}</span><span class="s2">;</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">props) {</span>
    <span class="s2">if </span><span class="s1">(!excludedKeys.includes(key)) {</span>
      <span class="s1">Object.defineProperty(ret</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">{</span>
        <span class="s1">enumerable: </span><span class="s2">true,</span>
        <span class="s1">get: () =&gt; props[key]</span>
      <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">ret</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">withAsyncContext(getAwaitable) {</span>
  <span class="s2">const </span><span class="s1">ctx = getCurrentInstance()</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(!ctx) {</span>
    <span class="s1">warn2(</span><span class="s3">`withAsyncContext called without active current instance. This is likely a bug.`</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">let </span><span class="s1">awaitable = getAwaitable()</span><span class="s2">;</span>
  <span class="s1">unsetCurrentInstance()</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(isPromise(awaitable)) {</span>
    <span class="s1">awaitable = awaitable.catch((e) =&gt; {</span>
      <span class="s1">setCurrentInstance(ctx)</span><span class="s2">;</span>
      <span class="s2">throw </span><span class="s1">e</span><span class="s2">;</span>
    <span class="s1">})</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">[awaitable</span><span class="s2">, </span><span class="s1">() =&gt; setCurrentInstance(ctx)]</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">h(type</span><span class="s2">, </span><span class="s1">propsOrChildren</span><span class="s2">, </span><span class="s1">children) {</span>
  <span class="s2">const </span><span class="s1">l = arguments.length</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(l === </span><span class="s4">2</span><span class="s1">) {</span>
    <span class="s2">if </span><span class="s1">(isObject(propsOrChildren) &amp;&amp; !isArray(propsOrChildren)) {</span>
      <span class="s2">if </span><span class="s1">(isVNode(propsOrChildren)) {</span>
        <span class="s2">return </span><span class="s1">createVNode(type</span><span class="s2">, null, </span><span class="s1">[propsOrChildren])</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">createVNode(type</span><span class="s2">, </span><span class="s1">propsOrChildren)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">return </span><span class="s1">createVNode(type</span><span class="s2">, null, </span><span class="s1">propsOrChildren)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s2">if </span><span class="s1">(l &gt; </span><span class="s4">3</span><span class="s1">) {</span>
      <span class="s1">children = Array.prototype.slice.call(arguments</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(l === </span><span class="s4">3 </span><span class="s1">&amp;&amp; isVNode(children)) {</span>
      <span class="s1">children = [children]</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">createVNode(type</span><span class="s2">, </span><span class="s1">propsOrChildren</span><span class="s2">, </span><span class="s1">children)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">ssrContextKey = Symbol(</span><span class="s2">true </span><span class="s1">? </span><span class="s3">`ssrContext` </span><span class="s1">: </span><span class="s3">``</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">useSSRContext = () =&gt; {</span>
  <span class="s1">{</span>
    <span class="s2">const </span><span class="s1">ctx = inject(ssrContextKey)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!ctx) {</span>
      <span class="s1">warn2(</span><span class="s3">`Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build.`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">ctx</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">isShallow2(value) {</span>
  <span class="s2">return </span><span class="s1">!!(value &amp;&amp; value[</span>
    <span class="s3">&quot;__v_isShallow&quot;</span>
    <span class="s0">/* ReactiveFlags.IS_SHALLOW */</span>
  <span class="s1">])</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">initCustomFormatter() {</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">window === </span><span class="s3">&quot;undefined&quot;</span><span class="s1">) {</span>
    <span class="s2">return;</span>
  <span class="s1">}</span>
  <span class="s2">const </span><span class="s1">vueStyle = { style: </span><span class="s3">&quot;color:#3ba776&quot; </span><span class="s1">}</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">numberStyle = { style: </span><span class="s3">&quot;color:#0b1bc9&quot; </span><span class="s1">}</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">stringStyle = { style: </span><span class="s3">&quot;color:#b62e24&quot; </span><span class="s1">}</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">keywordStyle = { style: </span><span class="s3">&quot;color:#9d288c&quot; </span><span class="s1">}</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">formatter = {</span>
    <span class="s1">header(obj) {</span>
      <span class="s2">if </span><span class="s1">(!isObject(obj)) {</span>
        <span class="s2">return null;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(obj.__isVue) {</span>
        <span class="s2">return </span><span class="s1">[</span><span class="s3">&quot;div&quot;</span><span class="s2">, </span><span class="s1">vueStyle</span><span class="s2">, </span><span class="s3">`VueInstance`</span><span class="s1">]</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isRef(obj)) {</span>
        <span class="s2">return </span><span class="s1">[</span>
          <span class="s3">&quot;div&quot;</span><span class="s2">,</span>
          <span class="s1">{}</span><span class="s2">,</span>
          <span class="s1">[</span><span class="s3">&quot;span&quot;</span><span class="s2">, </span><span class="s1">vueStyle</span><span class="s2">, </span><span class="s1">genRefFlag(obj)]</span><span class="s2">,</span>
          <span class="s3">&quot;&lt;&quot;</span><span class="s2">,</span>
          <span class="s1">formatValue(obj.value)</span><span class="s2">,</span>
          <span class="s3">`&gt;`</span>
        <span class="s1">]</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isReactive(obj)) {</span>
        <span class="s2">return </span><span class="s1">[</span>
          <span class="s3">&quot;div&quot;</span><span class="s2">,</span>
          <span class="s1">{}</span><span class="s2">,</span>
          <span class="s1">[</span><span class="s3">&quot;span&quot;</span><span class="s2">, </span><span class="s1">vueStyle</span><span class="s2">, </span><span class="s1">isShallow2(obj) ? </span><span class="s3">&quot;ShallowReactive&quot; </span><span class="s1">: </span><span class="s3">&quot;Reactive&quot;</span><span class="s1">]</span><span class="s2">,</span>
          <span class="s3">&quot;&lt;&quot;</span><span class="s2">,</span>
          <span class="s1">formatValue(obj)</span><span class="s2">,</span>
          <span class="s3">`&gt;</span><span class="s1">${isReadonly(obj) ? </span><span class="s3">` (readonly)` </span><span class="s1">: </span><span class="s3">``</span><span class="s1">}</span><span class="s3">`</span>
        <span class="s1">]</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isReadonly(obj)) {</span>
        <span class="s2">return </span><span class="s1">[</span>
          <span class="s3">&quot;div&quot;</span><span class="s2">,</span>
          <span class="s1">{}</span><span class="s2">,</span>
          <span class="s1">[</span><span class="s3">&quot;span&quot;</span><span class="s2">, </span><span class="s1">vueStyle</span><span class="s2">, </span><span class="s1">isShallow2(obj) ? </span><span class="s3">&quot;ShallowReadonly&quot; </span><span class="s1">: </span><span class="s3">&quot;Readonly&quot;</span><span class="s1">]</span><span class="s2">,</span>
          <span class="s3">&quot;&lt;&quot;</span><span class="s2">,</span>
          <span class="s1">formatValue(obj)</span><span class="s2">,</span>
          <span class="s3">&quot;&gt;&quot;</span>
        <span class="s1">]</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">return null;</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">hasBody(obj) {</span>
      <span class="s2">return </span><span class="s1">obj &amp;&amp; obj.__isVue</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">body(obj) {</span>
      <span class="s2">if </span><span class="s1">(obj &amp;&amp; obj.__isVue) {</span>
        <span class="s2">return </span><span class="s1">[</span>
          <span class="s3">&quot;div&quot;</span><span class="s2">,</span>
          <span class="s1">{}</span><span class="s2">,</span>
          <span class="s1">...formatInstance(obj.$)</span>
        <span class="s1">]</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">function </span><span class="s1">formatInstance(instance) {</span>
    <span class="s2">const </span><span class="s1">blocks = []</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(instance.type.props &amp;&amp; instance.props) {</span>
      <span class="s1">blocks.push(createInstanceBlock(</span><span class="s3">&quot;props&quot;</span><span class="s2">, </span><span class="s1">toRaw(instance.props)))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(instance.setupState !== EMPTY_OBJ) {</span>
      <span class="s1">blocks.push(createInstanceBlock(</span><span class="s3">&quot;setup&quot;</span><span class="s2">, </span><span class="s1">instance.setupState))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(instance.data !== EMPTY_OBJ) {</span>
      <span class="s1">blocks.push(createInstanceBlock(</span><span class="s3">&quot;data&quot;</span><span class="s2">, </span><span class="s1">toRaw(instance.data)))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">computed3 = extractKeys(instance</span><span class="s2">, </span><span class="s3">&quot;computed&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(computed3) {</span>
      <span class="s1">blocks.push(createInstanceBlock(</span><span class="s3">&quot;computed&quot;</span><span class="s2">, </span><span class="s1">computed3))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">injected = extractKeys(instance</span><span class="s2">, </span><span class="s3">&quot;inject&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(injected) {</span>
      <span class="s1">blocks.push(createInstanceBlock(</span><span class="s3">&quot;injected&quot;</span><span class="s2">, </span><span class="s1">injected))</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">blocks.push([</span>
      <span class="s3">&quot;div&quot;</span><span class="s2">,</span>
      <span class="s1">{}</span><span class="s2">,</span>
      <span class="s1">[</span>
        <span class="s3">&quot;span&quot;</span><span class="s2">,</span>
        <span class="s1">{</span>
          <span class="s1">style: keywordStyle.style + </span><span class="s3">&quot;;opacity:0.66&quot;</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s3">&quot;$ (internal): &quot;</span>
      <span class="s1">]</span><span class="s2">,</span>
      <span class="s1">[</span><span class="s3">&quot;object&quot;</span><span class="s2">, </span><span class="s1">{ object: instance }]</span>
    <span class="s1">])</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">blocks</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">createInstanceBlock(type</span><span class="s2">, </span><span class="s1">target) {</span>
    <span class="s1">target = extend({}</span><span class="s2">, </span><span class="s1">target)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!Object.keys(target).length) {</span>
      <span class="s2">return </span><span class="s1">[</span><span class="s3">&quot;span&quot;</span><span class="s2">, </span><span class="s1">{}]</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">[</span>
      <span class="s3">&quot;div&quot;</span><span class="s2">,</span>
      <span class="s1">{ style: </span><span class="s3">&quot;line-height:1.25em;margin-bottom:0.6em&quot; </span><span class="s1">}</span><span class="s2">,</span>
      <span class="s1">[</span>
        <span class="s3">&quot;div&quot;</span><span class="s2">,</span>
        <span class="s1">{</span>
          <span class="s1">style: </span><span class="s3">&quot;color:#476582&quot;</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">type</span>
      <span class="s1">]</span><span class="s2">,</span>
      <span class="s1">[</span>
        <span class="s3">&quot;div&quot;</span><span class="s2">,</span>
        <span class="s1">{</span>
          <span class="s1">style: </span><span class="s3">&quot;padding-left:1.25em&quot;</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">...Object.keys(target).map((key) =&gt; {</span>
          <span class="s2">return </span><span class="s1">[</span>
            <span class="s3">&quot;div&quot;</span><span class="s2">,</span>
            <span class="s1">{}</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;span&quot;</span><span class="s2">, </span><span class="s1">keywordStyle</span><span class="s2">, </span><span class="s1">key + </span><span class="s3">&quot;: &quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">formatValue(target[key]</span><span class="s2">, false</span><span class="s1">)</span>
          <span class="s1">]</span><span class="s2">;</span>
        <span class="s1">})</span>
      <span class="s1">]</span>
    <span class="s1">]</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">formatValue(v</span><span class="s2">, </span><span class="s1">asRaw = </span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">v === </span><span class="s3">&quot;number&quot;</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s1">[</span><span class="s3">&quot;span&quot;</span><span class="s2">, </span><span class="s1">numberStyle</span><span class="s2">, </span><span class="s1">v]</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">v === </span><span class="s3">&quot;string&quot;</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s1">[</span><span class="s3">&quot;span&quot;</span><span class="s2">, </span><span class="s1">stringStyle</span><span class="s2">, </span><span class="s1">JSON.stringify(v)]</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">v === </span><span class="s3">&quot;boolean&quot;</span><span class="s1">) {</span>
      <span class="s2">return </span><span class="s1">[</span><span class="s3">&quot;span&quot;</span><span class="s2">, </span><span class="s1">keywordStyle</span><span class="s2">, </span><span class="s1">v]</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isObject(v)) {</span>
      <span class="s2">return </span><span class="s1">[</span><span class="s3">&quot;object&quot;</span><span class="s2">, </span><span class="s1">{ object: asRaw ? toRaw(v) : v }]</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">return </span><span class="s1">[</span><span class="s3">&quot;span&quot;</span><span class="s2">, </span><span class="s1">stringStyle</span><span class="s2">, </span><span class="s1">String(v)]</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">extractKeys(instance</span><span class="s2">, </span><span class="s1">type) {</span>
    <span class="s2">const </span><span class="s1">Comp = instance.type</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(isFunction(Comp)) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">extracted = {}</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">instance.ctx) {</span>
      <span class="s2">if </span><span class="s1">(isKeyOfType(Comp</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">type)) {</span>
        <span class="s1">extracted[key] = instance.ctx[key]</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">extracted</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">isKeyOfType(Comp</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">type) {</span>
    <span class="s2">const </span><span class="s1">opts = Comp[type]</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(isArray(opts) &amp;&amp; opts.includes(key) || isObject(opts) &amp;&amp; key </span><span class="s2">in </span><span class="s1">opts) {</span>
      <span class="s2">return true;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(Comp.extends &amp;&amp; isKeyOfType(Comp.extends</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">type)) {</span>
      <span class="s2">return true;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(Comp.mixins &amp;&amp; Comp.mixins.some((m) =&gt; isKeyOfType(m</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">type))) {</span>
      <span class="s2">return true;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">function </span><span class="s1">genRefFlag(v) {</span>
    <span class="s2">if </span><span class="s1">(isShallow2(v)) {</span>
      <span class="s2">return </span><span class="s3">`ShallowRef`</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(v.effect) {</span>
      <span class="s2">return </span><span class="s3">`ComputedRef`</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s3">`Ref`</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(window.devtoolsFormatters) {</span>
    <span class="s1">window.devtoolsFormatters.push(formatter)</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s1">window.devtoolsFormatters = [formatter]</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">withMemo(memo</span><span class="s2">, </span><span class="s1">render2</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">index) {</span>
  <span class="s2">const </span><span class="s1">cached = cache[index]</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(cached &amp;&amp; isMemoSame(cached</span><span class="s2">, </span><span class="s1">memo)) {</span>
    <span class="s2">return </span><span class="s1">cached</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">const </span><span class="s1">ret = render2()</span><span class="s2">;</span>
  <span class="s1">ret.memo = memo.slice()</span><span class="s2">;</span>
  <span class="s2">return </span><span class="s1">cache[index] = ret</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isMemoSame(cached</span><span class="s2">, </span><span class="s1">memo) {</span>
  <span class="s2">const </span><span class="s1">prev = cached.memo</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(prev.length != memo.length) {</span>
    <span class="s2">return false;</span>
  <span class="s1">}</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; prev.length</span><span class="s2">; </span><span class="s1">i++) {</span>
    <span class="s2">if </span><span class="s1">(hasChanged(prev[i]</span><span class="s2">, </span><span class="s1">memo[i])) {</span>
      <span class="s2">return false;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(isBlockTreeEnabled &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp; currentBlock) {</span>
    <span class="s1">currentBlock.push(cached)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return true;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">version = </span><span class="s3">&quot;3.2.47&quot;</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">_ssrUtils = {</span>
  <span class="s1">createComponentInstance</span><span class="s2">,</span>
  <span class="s1">setupComponent</span><span class="s2">,</span>
  <span class="s1">renderComponentRoot</span><span class="s2">,</span>
  <span class="s1">setCurrentRenderingInstance</span><span class="s2">,</span>
  <span class="s1">isVNode</span><span class="s2">,</span>
  <span class="s1">normalizeVNode</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">ssrUtils = _ssrUtils</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">resolveFilter = </span><span class="s2">null;</span>
<span class="s2">var </span><span class="s1">compatUtils = </span><span class="s2">null;</span>

<span class="s0">// node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js</span>
<span class="s2">var </span><span class="s1">svgNS = </span><span class="s3">&quot;http://www.w3.org/2000/svg&quot;</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">doc = </span><span class="s2">typeof </span><span class="s1">document !== </span><span class="s3">&quot;undefined&quot; </span><span class="s1">? document : </span><span class="s2">null;</span>
<span class="s2">var </span><span class="s1">templateContainer = doc &amp;&amp; doc.createElement(</span><span class="s3">&quot;template&quot;</span><span class="s1">)</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">nodeOps = {</span>
  <span class="s1">insert: (child</span><span class="s2">, </span><span class="s1">parent</span><span class="s2">, </span><span class="s1">anchor) =&gt; {</span>
    <span class="s1">parent.insertBefore(child</span><span class="s2">, </span><span class="s1">anchor || </span><span class="s2">null</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">,</span>
  <span class="s1">remove: (child) =&gt; {</span>
    <span class="s2">const </span><span class="s1">parent = child.parentNode</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(parent) {</span>
      <span class="s1">parent.removeChild(child)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">,</span>
  <span class="s1">createElement: (tag</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">is</span><span class="s2">, </span><span class="s1">props) =&gt; {</span>
    <span class="s2">const </span><span class="s1">el = isSVG ? doc.createElementNS(svgNS</span><span class="s2">, </span><span class="s1">tag) : doc.createElement(tag</span><span class="s2">, </span><span class="s1">is ? { is } : </span><span class="s2">void </span><span class="s4">0</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(tag === </span><span class="s3">&quot;select&quot; </span><span class="s1">&amp;&amp; props &amp;&amp; props.multiple != </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">el.setAttribute(</span><span class="s3">&quot;multiple&quot;</span><span class="s2">, </span><span class="s1">props.multiple)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">el</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">,</span>
  <span class="s1">createText: (text) =&gt; doc.createTextNode(text)</span><span class="s2">,</span>
  <span class="s1">createComment: (text) =&gt; doc.createComment(text)</span><span class="s2">,</span>
  <span class="s1">setText: (node</span><span class="s2">, </span><span class="s1">text) =&gt; {</span>
    <span class="s1">node.nodeValue = text</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">,</span>
  <span class="s1">setElementText: (el</span><span class="s2">, </span><span class="s1">text) =&gt; {</span>
    <span class="s1">el.textContent = text</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">,</span>
  <span class="s1">parentNode: (node) =&gt; node.parentNode</span><span class="s2">,</span>
  <span class="s1">nextSibling: (node) =&gt; node.nextSibling</span><span class="s2">,</span>
  <span class="s1">querySelector: (selector) =&gt; doc.querySelector(selector)</span><span class="s2">,</span>
  <span class="s1">setScopeId(el</span><span class="s2">, </span><span class="s1">id) {</span>
    <span class="s1">el.setAttribute(id</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">,</span>
  <span class="s0">// __UNSAFE__</span>
  <span class="s0">// Reason: innerHTML.</span>
  <span class="s0">// Static content here can only come from compiled templates.</span>
  <span class="s0">// As long as the user only uses trusted templates, this is safe.</span>
  <span class="s1">insertStaticContent(content</span><span class="s2">, </span><span class="s1">parent</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end) {</span>
    <span class="s2">const </span><span class="s1">before = anchor ? anchor.previousSibling : parent.lastChild</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(start &amp;&amp; (start === end || start.nextSibling)) {</span>
      <span class="s2">while </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s1">parent.insertBefore(start.cloneNode(</span><span class="s2">true</span><span class="s1">)</span><span class="s2">, </span><span class="s1">anchor)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(start === end || !(start = start.nextSibling))</span>
          <span class="s2">break;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">templateContainer.innerHTML = isSVG ? </span><span class="s3">`&lt;svg&gt;</span><span class="s1">${content}</span><span class="s3">&lt;/svg&gt;` </span><span class="s1">: content</span><span class="s2">;</span>
      <span class="s2">const </span><span class="s1">template = templateContainer.content</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(isSVG) {</span>
        <span class="s2">const </span><span class="s1">wrapper = template.firstChild</span><span class="s2">;</span>
        <span class="s2">while </span><span class="s1">(wrapper.firstChild) {</span>
          <span class="s1">template.appendChild(wrapper.firstChild)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">template.removeChild(wrapper)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s1">parent.insertBefore(template</span><span class="s2">, </span><span class="s1">anchor)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">[</span>
      <span class="s0">// first</span>
      <span class="s1">before ? before.nextSibling : parent.firstChild</span><span class="s2">,</span>
      <span class="s0">// last</span>
      <span class="s1">anchor ? anchor.previousSibling : parent.lastChild</span>
    <span class="s1">]</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">patchClass(el</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">isSVG) {</span>
  <span class="s2">const </span><span class="s1">transitionClasses = el._vtc</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(transitionClasses) {</span>
    <span class="s1">value = (value ? [value</span><span class="s2">, </span><span class="s1">...transitionClasses] : [...transitionClasses]).join(</span><span class="s3">&quot; &quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(value == </span><span class="s2">null</span><span class="s1">) {</span>
    <span class="s1">el.removeAttribute(</span><span class="s3">&quot;class&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isSVG) {</span>
    <span class="s1">el.setAttribute(</span><span class="s3">&quot;class&quot;</span><span class="s2">, </span><span class="s1">value)</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s1">el.className = value</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">patchStyle(el</span><span class="s2">, </span><span class="s1">prev</span><span class="s2">, </span><span class="s1">next) {</span>
  <span class="s2">const </span><span class="s1">style = el.style</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">isCssString = isString(next)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(next &amp;&amp; !isCssString) {</span>
    <span class="s2">if </span><span class="s1">(prev &amp;&amp; !isString(prev)) {</span>
      <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">prev) {</span>
        <span class="s2">if </span><span class="s1">(next[key] == </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s1">setStyle(style</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">next) {</span>
      <span class="s1">setStyle(style</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">next[key])</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s2">const </span><span class="s1">currentDisplay = style.display</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(isCssString) {</span>
      <span class="s2">if </span><span class="s1">(prev !== next) {</span>
        <span class="s1">style.cssText = next</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(prev) {</span>
      <span class="s1">el.removeAttribute(</span><span class="s3">&quot;style&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s3">&quot;_vod&quot; </span><span class="s2">in </span><span class="s1">el) {</span>
      <span class="s1">style.display = currentDisplay</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">semicolonRE = </span><span class="s4">/[^\\];\s*$/</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">importantRE = </span><span class="s4">/\s*!important$/</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">setStyle(style</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">val) {</span>
  <span class="s2">if </span><span class="s1">(isArray(val)) {</span>
    <span class="s1">val.forEach((v) =&gt; setStyle(style</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">v))</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s2">if </span><span class="s1">(val == </span><span class="s2">null</span><span class="s1">)</span>
      <span class="s1">val = </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(semicolonRE.test(val)) {</span>
        <span class="s1">warn2(</span><span class="s3">`Unexpected semicolon at the end of '</span><span class="s1">${name}</span><span class="s3">' style value: '</span><span class="s1">${val}</span><span class="s3">'`</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(name.startsWith(</span><span class="s3">&quot;--&quot;</span><span class="s1">)) {</span>
      <span class="s1">style.setProperty(name</span><span class="s2">, </span><span class="s1">val)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">const </span><span class="s1">prefixed = autoPrefix(style</span><span class="s2">, </span><span class="s1">name)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(importantRE.test(val)) {</span>
        <span class="s1">style.setProperty(hyphenate(prefixed)</span><span class="s2">, </span><span class="s1">val.replace(importantRE</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s3">&quot;important&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">style[prefixed] = val</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">prefixes = [</span><span class="s3">&quot;Webkit&quot;</span><span class="s2">, </span><span class="s3">&quot;Moz&quot;</span><span class="s2">, </span><span class="s3">&quot;ms&quot;</span><span class="s1">]</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">prefixCache = {}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">autoPrefix(style</span><span class="s2">, </span><span class="s1">rawName) {</span>
  <span class="s2">const </span><span class="s1">cached = prefixCache[rawName]</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(cached) {</span>
    <span class="s2">return </span><span class="s1">cached</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">let </span><span class="s1">name = camelize(rawName)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(name !== </span><span class="s3">&quot;filter&quot; </span><span class="s1">&amp;&amp; name </span><span class="s2">in </span><span class="s1">style) {</span>
    <span class="s2">return </span><span class="s1">prefixCache[rawName] = name</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s1">name = capitalize(name)</span><span class="s2">;</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; prefixes.length</span><span class="s2">; </span><span class="s1">i++) {</span>
    <span class="s2">const </span><span class="s1">prefixed = prefixes[i] + name</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(prefixed </span><span class="s2">in </span><span class="s1">style) {</span>
      <span class="s2">return </span><span class="s1">prefixCache[rawName] = prefixed</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">rawName</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">xlinkNS = </span><span class="s3">&quot;http://www.w3.org/1999/xlink&quot;</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">patchAttr(el</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">isSVG</span><span class="s2">, </span><span class="s1">instance) {</span>
  <span class="s2">if </span><span class="s1">(isSVG &amp;&amp; key.startsWith(</span><span class="s3">&quot;xlink:&quot;</span><span class="s1">)) {</span>
    <span class="s2">if </span><span class="s1">(value == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">el.removeAttributeNS(xlinkNS</span><span class="s2">, </span><span class="s1">key.slice(</span><span class="s4">6</span><span class="s2">, </span><span class="s1">key.length))</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">el.setAttributeNS(xlinkNS</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s2">const </span><span class="s1">isBoolean2 = isSpecialBooleanAttr(key)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(value == </span><span class="s2">null </span><span class="s1">|| isBoolean2 &amp;&amp; !includeBooleanAttr(value)) {</span>
      <span class="s1">el.removeAttribute(key)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">el.setAttribute(key</span><span class="s2">, </span><span class="s1">isBoolean2 ? </span><span class="s3">&quot;&quot; </span><span class="s1">: value)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">patchDOMProp(el</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">prevChildren</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">unmountChildren) {</span>
  <span class="s2">if </span><span class="s1">(key === </span><span class="s3">&quot;innerHTML&quot; </span><span class="s1">|| key === </span><span class="s3">&quot;textContent&quot;</span><span class="s1">) {</span>
    <span class="s2">if </span><span class="s1">(prevChildren) {</span>
      <span class="s1">unmountChildren(prevChildren</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">el[key] = value == </span><span class="s2">null </span><span class="s1">? </span><span class="s3">&quot;&quot; </span><span class="s1">: value</span><span class="s2">;</span>
    <span class="s2">return;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(key === </span><span class="s3">&quot;value&quot; </span><span class="s1">&amp;&amp; el.tagName !== </span><span class="s3">&quot;PROGRESS&quot; </span><span class="s1">&amp;&amp; </span><span class="s0">// custom elements may use _value internally</span>
  <span class="s1">!el.tagName.includes(</span><span class="s3">&quot;-&quot;</span><span class="s1">)) {</span>
    <span class="s1">el._value = value</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">newValue = value == </span><span class="s2">null </span><span class="s1">? </span><span class="s3">&quot;&quot; </span><span class="s1">: value</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(el.value !== newValue || </span><span class="s0">// #4956: always set for OPTION elements because its value falls back to</span>
    <span class="s0">// textContent if no value attribute is present. And setting .value for</span>
    <span class="s0">// OPTION has no side effect</span>
    <span class="s1">el.tagName === </span><span class="s3">&quot;OPTION&quot;</span><span class="s1">) {</span>
      <span class="s1">el.value = newValue</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(value == </span><span class="s2">null</span><span class="s1">) {</span>
      <span class="s1">el.removeAttribute(key)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return;</span>
  <span class="s1">}</span>
  <span class="s2">let </span><span class="s1">needRemove = </span><span class="s2">false;</span>
  <span class="s2">if </span><span class="s1">(value === </span><span class="s3">&quot;&quot; </span><span class="s1">|| value == </span><span class="s2">null</span><span class="s1">) {</span>
    <span class="s2">const </span><span class="s1">type = </span><span class="s2">typeof </span><span class="s1">el[key]</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(type === </span><span class="s3">&quot;boolean&quot;</span><span class="s1">) {</span>
      <span class="s1">value = includeBooleanAttr(value)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(value == </span><span class="s2">null </span><span class="s1">&amp;&amp; type === </span><span class="s3">&quot;string&quot;</span><span class="s1">) {</span>
      <span class="s1">value = </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
      <span class="s1">needRemove = </span><span class="s2">true;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(type === </span><span class="s3">&quot;number&quot;</span><span class="s1">) {</span>
      <span class="s1">value = </span><span class="s4">0</span><span class="s2">;</span>
      <span class="s1">needRemove = </span><span class="s2">true;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">try </span><span class="s1">{</span>
    <span class="s1">el[key] = value</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">catch </span><span class="s1">(e) {</span>
    <span class="s2">if </span><span class="s1">(!needRemove) {</span>
      <span class="s1">warn2(</span><span class="s3">`Failed setting prop &quot;</span><span class="s1">${key}</span><span class="s3">&quot; on &lt;</span><span class="s1">${el.tagName.toLowerCase()}</span><span class="s3">&gt;: value </span><span class="s1">${value} </span><span class="s3">is invalid.`</span><span class="s2">, </span><span class="s1">e)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">needRemove &amp;&amp; el.removeAttribute(key)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">addEventListener(el</span><span class="s2">, </span><span class="s1">event</span><span class="s2">, </span><span class="s1">handler</span><span class="s2">, </span><span class="s1">options) {</span>
  <span class="s1">el.addEventListener(event</span><span class="s2">, </span><span class="s1">handler</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">removeEventListener(el</span><span class="s2">, </span><span class="s1">event</span><span class="s2">, </span><span class="s1">handler</span><span class="s2">, </span><span class="s1">options) {</span>
  <span class="s1">el.removeEventListener(event</span><span class="s2">, </span><span class="s1">handler</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">patchEvent(el</span><span class="s2">, </span><span class="s1">rawName</span><span class="s2">, </span><span class="s1">prevValue</span><span class="s2">, </span><span class="s1">nextValue</span><span class="s2">, </span><span class="s1">instance = </span><span class="s2">null</span><span class="s1">) {</span>
  <span class="s2">const </span><span class="s1">invokers = el._vei || (el._vei = {})</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">existingInvoker = invokers[rawName]</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(nextValue &amp;&amp; existingInvoker) {</span>
    <span class="s1">existingInvoker.value = nextValue</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s2">const </span><span class="s1">[name</span><span class="s2">, </span><span class="s1">options] = parseName(rawName)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(nextValue) {</span>
      <span class="s2">const </span><span class="s1">invoker = invokers[rawName] = createInvoker(nextValue</span><span class="s2">, </span><span class="s1">instance)</span><span class="s2">;</span>
      <span class="s1">addEventListener(el</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">invoker</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(existingInvoker) {</span>
      <span class="s1">removeEventListener(el</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">existingInvoker</span><span class="s2">, </span><span class="s1">options)</span><span class="s2">;</span>
      <span class="s1">invokers[rawName] = </span><span class="s2">void </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">optionsModifierRE = </span><span class="s4">/(?:Once|Passive|Capture)$/</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">parseName(name) {</span>
  <span class="s2">let </span><span class="s1">options</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(optionsModifierRE.test(name)) {</span>
    <span class="s1">options = {}</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">m</span><span class="s2">;</span>
    <span class="s2">while </span><span class="s1">(m = name.match(optionsModifierRE)) {</span>
      <span class="s1">name = name.slice(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">name.length - m[</span><span class="s4">0</span><span class="s1">].length)</span><span class="s2">;</span>
      <span class="s1">options[m[</span><span class="s4">0</span><span class="s1">].toLowerCase()] = </span><span class="s2">true;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">const </span><span class="s1">event = name[</span><span class="s4">2</span><span class="s1">] === </span><span class="s3">&quot;:&quot; </span><span class="s1">? name.slice(</span><span class="s4">3</span><span class="s1">) : hyphenate(name.slice(</span><span class="s4">2</span><span class="s1">))</span><span class="s2">;</span>
  <span class="s2">return </span><span class="s1">[event</span><span class="s2">, </span><span class="s1">options]</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">cachedNow = </span><span class="s4">0</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">p = Promise.resolve()</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">getNow = () =&gt; cachedNow || (p.then(() =&gt; cachedNow = </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">cachedNow = Date.now())</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">createInvoker(initialValue</span><span class="s2">, </span><span class="s1">instance) {</span>
  <span class="s2">const </span><span class="s1">invoker = (e) =&gt; {</span>
    <span class="s2">if </span><span class="s1">(!e._vts) {</span>
      <span class="s1">e._vts = Date.now()</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(e._vts &lt;= invoker.attached) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s1">callWithAsyncErrorHandling(patchStopImmediatePropagation(e</span><span class="s2">, </span><span class="s1">invoker.value)</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s1">[e])</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s1">invoker.value = initialValue</span><span class="s2">;</span>
  <span class="s1">invoker.attached = getNow()</span><span class="s2">;</span>
  <span class="s2">return </span><span class="s1">invoker</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">patchStopImmediatePropagation(e</span><span class="s2">, </span><span class="s1">value) {</span>
  <span class="s2">if </span><span class="s1">(isArray(value)) {</span>
    <span class="s2">const </span><span class="s1">originalStop = e.stopImmediatePropagation</span><span class="s2">;</span>
    <span class="s1">e.stopImmediatePropagation = () =&gt; {</span>
      <span class="s1">originalStop.call(e)</span><span class="s2">;</span>
      <span class="s1">e._stopped = </span><span class="s2">true;</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">value.map((fn) =&gt; (e2) =&gt; !e2._stopped &amp;&amp; fn &amp;&amp; fn(e2))</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s2">return </span><span class="s1">value</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">nativeOnRE = </span><span class="s4">/^on[a-z]/</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">patchProp = (el</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">prevValue</span><span class="s2">, </span><span class="s1">nextValue</span><span class="s2">, </span><span class="s1">isSVG = </span><span class="s2">false, </span><span class="s1">prevChildren</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">unmountChildren) =&gt; {</span>
  <span class="s2">if </span><span class="s1">(key === </span><span class="s3">&quot;class&quot;</span><span class="s1">) {</span>
    <span class="s1">patchClass(el</span><span class="s2">, </span><span class="s1">nextValue</span><span class="s2">, </span><span class="s1">isSVG)</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(key === </span><span class="s3">&quot;style&quot;</span><span class="s1">) {</span>
    <span class="s1">patchStyle(el</span><span class="s2">, </span><span class="s1">prevValue</span><span class="s2">, </span><span class="s1">nextValue)</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isOn(key)) {</span>
    <span class="s2">if </span><span class="s1">(!isModelListener(key)) {</span>
      <span class="s1">patchEvent(el</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">prevValue</span><span class="s2">, </span><span class="s1">nextValue</span><span class="s2">, </span><span class="s1">parentComponent)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(key[</span><span class="s4">0</span><span class="s1">] === </span><span class="s3">&quot;.&quot; </span><span class="s1">? (key = key.slice(</span><span class="s4">1</span><span class="s1">)</span><span class="s2">, true</span><span class="s1">) : key[</span><span class="s4">0</span><span class="s1">] === </span><span class="s3">&quot;^&quot; </span><span class="s1">? (key = key.slice(</span><span class="s4">1</span><span class="s1">)</span><span class="s2">, false</span><span class="s1">) : shouldSetAsProp(el</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">nextValue</span><span class="s2">, </span><span class="s1">isSVG)) {</span>
    <span class="s1">patchDOMProp(el</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">nextValue</span><span class="s2">, </span><span class="s1">prevChildren</span><span class="s2">, </span><span class="s1">parentComponent</span><span class="s2">, </span><span class="s1">parentSuspense</span><span class="s2">, </span><span class="s1">unmountChildren)</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s2">if </span><span class="s1">(key === </span><span class="s3">&quot;true-value&quot;</span><span class="s1">) {</span>
      <span class="s1">el._trueValue = nextValue</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(key === </span><span class="s3">&quot;false-value&quot;</span><span class="s1">) {</span>
      <span class="s1">el._falseValue = nextValue</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">patchAttr(el</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">nextValue</span><span class="s2">, </span><span class="s1">isSVG)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">shouldSetAsProp(el</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">isSVG) {</span>
  <span class="s2">if </span><span class="s1">(isSVG) {</span>
    <span class="s2">if </span><span class="s1">(key === </span><span class="s3">&quot;innerHTML&quot; </span><span class="s1">|| key === </span><span class="s3">&quot;textContent&quot;</span><span class="s1">) {</span>
      <span class="s2">return true;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(key </span><span class="s2">in </span><span class="s1">el &amp;&amp; nativeOnRE.test(key) &amp;&amp; isFunction(value)) {</span>
      <span class="s2">return true;</span>
    <span class="s1">}</span>
    <span class="s2">return false;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(key === </span><span class="s3">&quot;spellcheck&quot; </span><span class="s1">|| key === </span><span class="s3">&quot;draggable&quot; </span><span class="s1">|| key === </span><span class="s3">&quot;translate&quot;</span><span class="s1">) {</span>
    <span class="s2">return false;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(key === </span><span class="s3">&quot;form&quot;</span><span class="s1">) {</span>
    <span class="s2">return false;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(key === </span><span class="s3">&quot;list&quot; </span><span class="s1">&amp;&amp; el.tagName === </span><span class="s3">&quot;INPUT&quot;</span><span class="s1">) {</span>
    <span class="s2">return false;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(key === </span><span class="s3">&quot;type&quot; </span><span class="s1">&amp;&amp; el.tagName === </span><span class="s3">&quot;TEXTAREA&quot;</span><span class="s1">) {</span>
    <span class="s2">return false;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(nativeOnRE.test(key) &amp;&amp; isString(value)) {</span>
    <span class="s2">return false;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">key </span><span class="s2">in </span><span class="s1">el</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">defineCustomElement(options</span><span class="s2">, </span><span class="s1">hydrate2) {</span>
  <span class="s2">const </span><span class="s1">Comp = defineComponent(options)</span><span class="s2">;</span>
  <span class="s2">class </span><span class="s1">VueCustomElement </span><span class="s2">extends </span><span class="s1">VueElement {</span>
    <span class="s1">constructor(initialProps) {</span>
      <span class="s2">super</span><span class="s1">(Comp</span><span class="s2">, </span><span class="s1">initialProps</span><span class="s2">, </span><span class="s1">hydrate2)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">VueCustomElement.def = Comp</span><span class="s2">;</span>
  <span class="s2">return </span><span class="s1">VueCustomElement</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">defineSSRCustomElement = (options) =&gt; {</span>
  <span class="s2">return </span><span class="s1">defineCustomElement(options</span><span class="s2">, </span><span class="s1">hydrate)</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">BaseClass = </span><span class="s2">typeof </span><span class="s1">HTMLElement !== </span><span class="s3">&quot;undefined&quot; </span><span class="s1">? HTMLElement : </span><span class="s2">class </span><span class="s1">{</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">VueElement = </span><span class="s2">class extends </span><span class="s1">BaseClass {</span>
  <span class="s1">constructor(_def</span><span class="s2">, </span><span class="s1">_props = {}</span><span class="s2">, </span><span class="s1">hydrate2) {</span>
    <span class="s2">super</span><span class="s1">()</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">._def = _def</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">._props = _props</span><span class="s2">;</span>
    <span class="s2">this</span><span class="s1">._instance = </span><span class="s2">null;</span>
    <span class="s2">this</span><span class="s1">._connected = </span><span class="s2">false;</span>
    <span class="s2">this</span><span class="s1">._resolved = </span><span class="s2">false;</span>
    <span class="s2">this</span><span class="s1">._numberProps = </span><span class="s2">null;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.shadowRoot &amp;&amp; hydrate2) {</span>
      <span class="s1">hydrate2(</span><span class="s2">this</span><span class="s1">._createVNode()</span><span class="s2">, this</span><span class="s1">.shadowRoot)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.shadowRoot) {</span>
        <span class="s1">warn2(</span><span class="s3">`Custom element has pre-rendered declarative shadow root but is not defined as hydratable. Use </span><span class="s2">\`</span><span class="s3">defineSSRCustomElement</span><span class="s2">\`</span><span class="s3">.`</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">this</span><span class="s1">.attachShadow({ mode: </span><span class="s3">&quot;open&quot; </span><span class="s1">})</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">._def.__asyncLoader) {</span>
        <span class="s2">this</span><span class="s1">._resolveProps(</span><span class="s2">this</span><span class="s1">._def)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">connectedCallback() {</span>
    <span class="s2">this</span><span class="s1">._connected = </span><span class="s2">true;</span>
    <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">._instance) {</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">._resolved) {</span>
        <span class="s2">this</span><span class="s1">._update()</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">this</span><span class="s1">._resolveDef()</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">disconnectedCallback() {</span>
    <span class="s2">this</span><span class="s1">._connected = </span><span class="s2">false;</span>
    <span class="s1">nextTick(() =&gt; {</span>
      <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">._connected) {</span>
        <span class="s1">render(</span><span class="s2">null, this</span><span class="s1">.shadowRoot)</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">._instance = </span><span class="s2">null;</span>
      <span class="s1">}</span>
    <span class="s1">})</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s5">/**</span>
   <span class="s5">* resolve inner component definition (handle possible async component)</span>
   <span class="s5">*/</span>
  <span class="s1">_resolveDef() {</span>
    <span class="s2">this</span><span class="s1">._resolved = </span><span class="s2">true;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; </span><span class="s2">this</span><span class="s1">.attributes.length</span><span class="s2">; </span><span class="s1">i++) {</span>
      <span class="s2">this</span><span class="s1">._setAttr(</span><span class="s2">this</span><span class="s1">.attributes[i].name)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">new </span><span class="s1">MutationObserver((mutations) =&gt; {</span>
      <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">m of mutations) {</span>
        <span class="s2">this</span><span class="s1">._setAttr(m.attributeName)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}).observe(</span><span class="s2">this, </span><span class="s1">{ attributes: </span><span class="s2">true </span><span class="s1">})</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">resolve2 = (def2</span><span class="s2">, </span><span class="s1">isAsync = </span><span class="s2">false</span><span class="s1">) =&gt; {</span>
      <span class="s2">const </span><span class="s1">{ props</span><span class="s2">, </span><span class="s1">styles } = def2</span><span class="s2">;</span>
      <span class="s2">let </span><span class="s1">numberProps</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(props &amp;&amp; !isArray(props)) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">props) {</span>
          <span class="s2">const </span><span class="s1">opt = props[key]</span><span class="s2">;</span>
          <span class="s2">if </span><span class="s1">(opt === Number || opt &amp;&amp; opt.type === Number) {</span>
            <span class="s2">if </span><span class="s1">(key </span><span class="s2">in this</span><span class="s1">._props) {</span>
              <span class="s2">this</span><span class="s1">._props[key] = toNumber(</span><span class="s2">this</span><span class="s1">._props[key])</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">(numberProps || (numberProps = </span><span class="s0">/* @__PURE__ */ </span><span class="s1">Object.create(</span><span class="s2">null</span><span class="s1">)))[camelize(key)] = </span><span class="s2">true;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">this</span><span class="s1">._numberProps = numberProps</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(isAsync) {</span>
        <span class="s2">this</span><span class="s1">._resolveProps(def2)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">this</span><span class="s1">._applyStyles(styles)</span><span class="s2">;</span>
      <span class="s2">this</span><span class="s1">._update()</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">asyncDef = </span><span class="s2">this</span><span class="s1">._def.__asyncLoader</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(asyncDef) {</span>
      <span class="s1">asyncDef().then((def2) =&gt; resolve2(def2</span><span class="s2">, true</span><span class="s1">))</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">resolve2(</span><span class="s2">this</span><span class="s1">._def)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">_resolveProps(def2) {</span>
    <span class="s2">const </span><span class="s1">{ props } = def2</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">declaredPropKeys = isArray(props) ? props : Object.keys(props || {})</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key of Object.keys(</span><span class="s2">this</span><span class="s1">)) {</span>
      <span class="s2">if </span><span class="s1">(key[</span><span class="s4">0</span><span class="s1">] !== </span><span class="s3">&quot;_&quot; </span><span class="s1">&amp;&amp; declaredPropKeys.includes(key)) {</span>
        <span class="s2">this</span><span class="s1">._setProp(key</span><span class="s2">, this</span><span class="s1">[key]</span><span class="s2">, true, false</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key of declaredPropKeys.map(camelize)) {</span>
      <span class="s1">Object.defineProperty(</span><span class="s2">this, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">{</span>
        <span class="s1">get() {</span>
          <span class="s2">return this</span><span class="s1">._getProp(key)</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">set(val) {</span>
          <span class="s2">this</span><span class="s1">._setProp(key</span><span class="s2">, </span><span class="s1">val)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">_setAttr(key) {</span>
    <span class="s2">let </span><span class="s1">value = </span><span class="s2">this</span><span class="s1">.getAttribute(key)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">camelKey = camelize(key)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">._numberProps &amp;&amp; </span><span class="s2">this</span><span class="s1">._numberProps[camelKey]) {</span>
      <span class="s1">value = toNumber(value)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">this</span><span class="s1">._setProp(camelKey</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, false</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s5">/**</span>
   <span class="s5">* </span><span class="s6">@internal</span>
   <span class="s5">*/</span>
  <span class="s1">_getProp(key) {</span>
    <span class="s2">return this</span><span class="s1">._props[key]</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s5">/**</span>
   <span class="s5">* </span><span class="s6">@internal</span>
   <span class="s5">*/</span>
  <span class="s1">_setProp(key</span><span class="s2">, </span><span class="s1">val</span><span class="s2">, </span><span class="s1">shouldReflect = </span><span class="s2">true, </span><span class="s1">shouldUpdate = </span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s2">if </span><span class="s1">(val !== </span><span class="s2">this</span><span class="s1">._props[key]) {</span>
      <span class="s2">this</span><span class="s1">._props[key] = val</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(shouldUpdate &amp;&amp; </span><span class="s2">this</span><span class="s1">._instance) {</span>
        <span class="s2">this</span><span class="s1">._update()</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(shouldReflect) {</span>
        <span class="s2">if </span><span class="s1">(val === </span><span class="s2">true</span><span class="s1">) {</span>
          <span class="s2">this</span><span class="s1">.setAttribute(hyphenate(key)</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">val === </span><span class="s3">&quot;string&quot; </span><span class="s1">|| </span><span class="s2">typeof </span><span class="s1">val === </span><span class="s3">&quot;number&quot;</span><span class="s1">) {</span>
          <span class="s2">this</span><span class="s1">.setAttribute(hyphenate(key)</span><span class="s2">, </span><span class="s1">val + </span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!val) {</span>
          <span class="s2">this</span><span class="s1">.removeAttribute(hyphenate(key))</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">_update() {</span>
    <span class="s1">render(</span><span class="s2">this</span><span class="s1">._createVNode()</span><span class="s2">, this</span><span class="s1">.shadowRoot)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s1">_createVNode() {</span>
    <span class="s2">const </span><span class="s1">vnode = createVNode(</span><span class="s2">this</span><span class="s1">._def</span><span class="s2">, </span><span class="s1">extend({}</span><span class="s2">, this</span><span class="s1">._props))</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">._instance) {</span>
      <span class="s1">vnode.ce = (instance) =&gt; {</span>
        <span class="s2">this</span><span class="s1">._instance = instance</span><span class="s2">;</span>
        <span class="s1">instance.isCE = </span><span class="s2">true;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
          <span class="s1">instance.ceReload = (newStyles) =&gt; {</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">._styles) {</span>
              <span class="s2">this</span><span class="s1">._styles.forEach((s) =&gt; </span><span class="s2">this</span><span class="s1">.shadowRoot.removeChild(s))</span><span class="s2">;</span>
              <span class="s2">this</span><span class="s1">._styles.length = </span><span class="s4">0</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s2">this</span><span class="s1">._applyStyles(newStyles)</span><span class="s2">;</span>
            <span class="s2">this</span><span class="s1">._instance = </span><span class="s2">null;</span>
            <span class="s2">this</span><span class="s1">._update()</span><span class="s2">;</span>
          <span class="s1">}</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">dispatch = (event</span><span class="s2">, </span><span class="s1">args) =&gt; {</span>
          <span class="s2">this</span><span class="s1">.dispatchEvent(</span><span class="s2">new </span><span class="s1">CustomEvent(event</span><span class="s2">, </span><span class="s1">{</span>
            <span class="s1">detail: args</span>
          <span class="s1">}))</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">;</span>
        <span class="s1">instance.emit = (event</span><span class="s2">, </span><span class="s1">...args) =&gt; {</span>
          <span class="s1">dispatch(event</span><span class="s2">, </span><span class="s1">args)</span><span class="s2">;</span>
          <span class="s2">if </span><span class="s1">(hyphenate(event) !== event) {</span>
            <span class="s1">dispatch(hyphenate(event)</span><span class="s2">, </span><span class="s1">args)</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span><span class="s2">;</span>
        <span class="s2">let </span><span class="s1">parent = </span><span class="s2">this;</span>
        <span class="s2">while </span><span class="s1">(parent = parent &amp;&amp; (parent.parentNode || parent.host)) {</span>
          <span class="s2">if </span><span class="s1">(parent </span><span class="s2">instanceof </span><span class="s1">VueElement) {</span>
            <span class="s1">instance.parent = parent._instance</span><span class="s2">;</span>
            <span class="s1">instance.provides = parent._instance.provides</span><span class="s2">;</span>
            <span class="s2">break;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">vnode</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s1">_applyStyles(styles) {</span>
    <span class="s2">if </span><span class="s1">(styles) {</span>
      <span class="s1">styles.forEach((css) =&gt; {</span>
        <span class="s2">const </span><span class="s1">s = document.createElement(</span><span class="s3">&quot;style&quot;</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">s.textContent = css</span><span class="s2">;</span>
        <span class="s2">this</span><span class="s1">.shadowRoot.appendChild(s)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
          <span class="s1">(</span><span class="s2">this</span><span class="s1">._styles || (</span><span class="s2">this</span><span class="s1">._styles = [])).push(s)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">useCssModule(name = </span><span class="s3">&quot;$style&quot;</span><span class="s1">) {</span>
  <span class="s1">{</span>
    <span class="s2">const </span><span class="s1">instance = getCurrentInstance()</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!instance) {</span>
      <span class="s1">warn2(</span><span class="s3">`useCssModule must be called inside setup()`</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">return </span><span class="s1">EMPTY_OBJ</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">modules = instance.type.__cssModules</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!modules) {</span>
      <span class="s1">warn2(</span><span class="s3">`Current instance does not have CSS modules injected.`</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">return </span><span class="s1">EMPTY_OBJ</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">mod = modules[name]</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!mod) {</span>
      <span class="s1">warn2(</span><span class="s3">`Current instance does not have CSS module named &quot;</span><span class="s1">${name}</span><span class="s3">&quot;.`</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s2">return </span><span class="s1">EMPTY_OBJ</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">mod</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">useCssVars(getter) {</span>
  <span class="s2">const </span><span class="s1">instance = getCurrentInstance()</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(!instance) {</span>
    <span class="s1">warn2(</span><span class="s3">`useCssVars is called without current active component instance.`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">return;</span>
  <span class="s1">}</span>
  <span class="s2">const </span><span class="s1">updateTeleports = instance.ut = (vars = getter(instance.proxy)) =&gt; {</span>
    <span class="s1">Array.from(document.querySelectorAll(</span><span class="s3">`[data-v-owner=&quot;</span><span class="s1">${instance.uid}</span><span class="s3">&quot;]`</span><span class="s1">)).forEach((node) =&gt; setVarsOnNode(node</span><span class="s2">, </span><span class="s1">vars))</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">setVars = () =&gt; {</span>
    <span class="s2">const </span><span class="s1">vars = getter(instance.proxy)</span><span class="s2">;</span>
    <span class="s1">setVarsOnVNode(instance.subTree</span><span class="s2">, </span><span class="s1">vars)</span><span class="s2">;</span>
    <span class="s1">updateTeleports(vars)</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s1">watchPostEffect(setVars)</span><span class="s2">;</span>
  <span class="s1">onMounted(() =&gt; {</span>
    <span class="s2">const </span><span class="s1">ob = </span><span class="s2">new </span><span class="s1">MutationObserver(setVars)</span><span class="s2">;</span>
    <span class="s1">ob.observe(instance.subTree.el.parentNode</span><span class="s2">, </span><span class="s1">{ childList: </span><span class="s2">true </span><span class="s1">})</span><span class="s2">;</span>
    <span class="s1">onUnmounted(() =&gt; ob.disconnect())</span><span class="s2">;</span>
  <span class="s1">})</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">setVarsOnVNode(vnode</span><span class="s2">, </span><span class="s1">vars) {</span>
  <span class="s2">if </span><span class="s1">(vnode.shapeFlag &amp; </span><span class="s4">128</span><span class="s1">) {</span>
    <span class="s2">const </span><span class="s1">suspense = vnode.suspense</span><span class="s2">;</span>
    <span class="s1">vnode = suspense.activeBranch</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(suspense.pendingBranch &amp;&amp; !suspense.isHydrating) {</span>
      <span class="s1">suspense.effects.push(() =&gt; {</span>
        <span class="s1">setVarsOnVNode(suspense.activeBranch</span><span class="s2">, </span><span class="s1">vars)</span><span class="s2">;</span>
      <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">while </span><span class="s1">(vnode.component) {</span>
    <span class="s1">vnode = vnode.component.subTree</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(vnode.shapeFlag &amp; </span><span class="s4">1 </span><span class="s1">&amp;&amp; vnode.el) {</span>
    <span class="s1">setVarsOnNode(vnode.el</span><span class="s2">, </span><span class="s1">vars)</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(vnode.type === Fragment) {</span>
    <span class="s1">vnode.children.forEach((c) =&gt; setVarsOnVNode(c</span><span class="s2">, </span><span class="s1">vars))</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(vnode.type === Static) {</span>
    <span class="s2">let </span><span class="s1">{ el</span><span class="s2">, </span><span class="s1">anchor } = vnode</span><span class="s2">;</span>
    <span class="s2">while </span><span class="s1">(el) {</span>
      <span class="s1">setVarsOnNode(el</span><span class="s2">, </span><span class="s1">vars)</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(el === anchor)</span>
        <span class="s2">break;</span>
      <span class="s1">el = el.nextSibling</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">setVarsOnNode(el</span><span class="s2">, </span><span class="s1">vars) {</span>
  <span class="s2">if </span><span class="s1">(el.nodeType === </span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s2">const </span><span class="s1">style = el.style</span><span class="s2">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">vars) {</span>
      <span class="s1">style.setProperty(</span><span class="s3">`--</span><span class="s1">${key}</span><span class="s3">`</span><span class="s2">, </span><span class="s1">vars[key])</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">TRANSITION = </span><span class="s3">&quot;transition&quot;</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">ANIMATION = </span><span class="s3">&quot;animation&quot;</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">Transition = (props</span><span class="s2">, </span><span class="s1">{ slots }) =&gt; h(BaseTransition</span><span class="s2">, </span><span class="s1">resolveTransitionProps(props)</span><span class="s2">, </span><span class="s1">slots)</span><span class="s2">;</span>
<span class="s1">Transition.displayName = </span><span class="s3">&quot;Transition&quot;</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">DOMTransitionPropsValidators = {</span>
  <span class="s1">name: String</span><span class="s2">,</span>
  <span class="s1">type: String</span><span class="s2">,</span>
  <span class="s1">css: {</span>
    <span class="s1">type: Boolean</span><span class="s2">,</span>
    <span class="s2">default</span><span class="s1">: </span><span class="s2">true</span>
  <span class="s1">}</span><span class="s2">,</span>
  <span class="s1">duration: [String</span><span class="s2">, </span><span class="s1">Number</span><span class="s2">, </span><span class="s1">Object]</span><span class="s2">,</span>
  <span class="s1">enterFromClass: String</span><span class="s2">,</span>
  <span class="s1">enterActiveClass: String</span><span class="s2">,</span>
  <span class="s1">enterToClass: String</span><span class="s2">,</span>
  <span class="s1">appearFromClass: String</span><span class="s2">,</span>
  <span class="s1">appearActiveClass: String</span><span class="s2">,</span>
  <span class="s1">appearToClass: String</span><span class="s2">,</span>
  <span class="s1">leaveFromClass: String</span><span class="s2">,</span>
  <span class="s1">leaveActiveClass: String</span><span class="s2">,</span>
  <span class="s1">leaveToClass: String</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">TransitionPropsValidators = Transition.props = extend({}</span><span class="s2">, </span><span class="s1">BaseTransition.props</span><span class="s2">, </span><span class="s1">DOMTransitionPropsValidators)</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">callHook2 = (hook</span><span class="s2">, </span><span class="s1">args = []) =&gt; {</span>
  <span class="s2">if </span><span class="s1">(isArray(hook)) {</span>
    <span class="s1">hook.forEach((h2) =&gt; h2(...args))</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(hook) {</span>
    <span class="s1">hook(...args)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">hasExplicitCallback = (hook) =&gt; {</span>
  <span class="s2">return </span><span class="s1">hook ? isArray(hook) ? hook.some((h2) =&gt; h2.length &gt; </span><span class="s4">1</span><span class="s1">) : hook.length &gt; </span><span class="s4">1 </span><span class="s1">: </span><span class="s2">false;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">resolveTransitionProps(rawProps) {</span>
  <span class="s2">const </span><span class="s1">baseProps = {}</span><span class="s2">;</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">rawProps) {</span>
    <span class="s2">if </span><span class="s1">(!(key </span><span class="s2">in </span><span class="s1">DOMTransitionPropsValidators)) {</span>
      <span class="s1">baseProps[key] = rawProps[key]</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(rawProps.css === </span><span class="s2">false</span><span class="s1">) {</span>
    <span class="s2">return </span><span class="s1">baseProps</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">const </span><span class="s1">{ name = </span><span class="s3">&quot;v&quot;</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">duration</span><span class="s2">, </span><span class="s1">enterFromClass = </span><span class="s3">`</span><span class="s1">${name}</span><span class="s3">-enter-from`</span><span class="s2">, </span><span class="s1">enterActiveClass = </span><span class="s3">`</span><span class="s1">${name}</span><span class="s3">-enter-active`</span><span class="s2">, </span><span class="s1">enterToClass = </span><span class="s3">`</span><span class="s1">${name}</span><span class="s3">-enter-to`</span><span class="s2">, </span><span class="s1">appearFromClass = enterFromClass</span><span class="s2">, </span><span class="s1">appearActiveClass = enterActiveClass</span><span class="s2">, </span><span class="s1">appearToClass = enterToClass</span><span class="s2">, </span><span class="s1">leaveFromClass = </span><span class="s3">`</span><span class="s1">${name}</span><span class="s3">-leave-from`</span><span class="s2">, </span><span class="s1">leaveActiveClass = </span><span class="s3">`</span><span class="s1">${name}</span><span class="s3">-leave-active`</span><span class="s2">, </span><span class="s1">leaveToClass = </span><span class="s3">`</span><span class="s1">${name}</span><span class="s3">-leave-to` </span><span class="s1">} = rawProps</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">durations = normalizeDuration(duration)</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">enterDuration = durations &amp;&amp; durations[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">leaveDuration = durations &amp;&amp; durations[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">{ onBeforeEnter</span><span class="s2">, </span><span class="s1">onEnter</span><span class="s2">, </span><span class="s1">onEnterCancelled</span><span class="s2">, </span><span class="s1">onLeave</span><span class="s2">, </span><span class="s1">onLeaveCancelled</span><span class="s2">, </span><span class="s1">onBeforeAppear = onBeforeEnter</span><span class="s2">, </span><span class="s1">onAppear = onEnter</span><span class="s2">, </span><span class="s1">onAppearCancelled = onEnterCancelled } = baseProps</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">finishEnter = (el</span><span class="s2">, </span><span class="s1">isAppear</span><span class="s2">, </span><span class="s1">done) =&gt; {</span>
    <span class="s1">removeTransitionClass(el</span><span class="s2">, </span><span class="s1">isAppear ? appearToClass : enterToClass)</span><span class="s2">;</span>
    <span class="s1">removeTransitionClass(el</span><span class="s2">, </span><span class="s1">isAppear ? appearActiveClass : enterActiveClass)</span><span class="s2">;</span>
    <span class="s1">done &amp;&amp; done()</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">finishLeave = (el</span><span class="s2">, </span><span class="s1">done) =&gt; {</span>
    <span class="s1">el._isLeaving = </span><span class="s2">false;</span>
    <span class="s1">removeTransitionClass(el</span><span class="s2">, </span><span class="s1">leaveFromClass)</span><span class="s2">;</span>
    <span class="s1">removeTransitionClass(el</span><span class="s2">, </span><span class="s1">leaveToClass)</span><span class="s2">;</span>
    <span class="s1">removeTransitionClass(el</span><span class="s2">, </span><span class="s1">leaveActiveClass)</span><span class="s2">;</span>
    <span class="s1">done &amp;&amp; done()</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">makeEnterHook = (isAppear) =&gt; {</span>
    <span class="s2">return </span><span class="s1">(el</span><span class="s2">, </span><span class="s1">done) =&gt; {</span>
      <span class="s2">const </span><span class="s1">hook = isAppear ? onAppear : onEnter</span><span class="s2">;</span>
      <span class="s2">const </span><span class="s1">resolve2 = () =&gt; finishEnter(el</span><span class="s2">, </span><span class="s1">isAppear</span><span class="s2">, </span><span class="s1">done)</span><span class="s2">;</span>
      <span class="s1">callHook2(hook</span><span class="s2">, </span><span class="s1">[el</span><span class="s2">, </span><span class="s1">resolve2])</span><span class="s2">;</span>
      <span class="s1">nextFrame(() =&gt; {</span>
        <span class="s1">removeTransitionClass(el</span><span class="s2">, </span><span class="s1">isAppear ? appearFromClass : enterFromClass)</span><span class="s2">;</span>
        <span class="s1">addTransitionClass(el</span><span class="s2">, </span><span class="s1">isAppear ? appearToClass : enterToClass)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!hasExplicitCallback(hook)) {</span>
          <span class="s1">whenTransitionEnds(el</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">enterDuration</span><span class="s2">, </span><span class="s1">resolve2)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">return </span><span class="s1">extend(baseProps</span><span class="s2">, </span><span class="s1">{</span>
    <span class="s1">onBeforeEnter(el) {</span>
      <span class="s1">callHook2(onBeforeEnter</span><span class="s2">, </span><span class="s1">[el])</span><span class="s2">;</span>
      <span class="s1">addTransitionClass(el</span><span class="s2">, </span><span class="s1">enterFromClass)</span><span class="s2">;</span>
      <span class="s1">addTransitionClass(el</span><span class="s2">, </span><span class="s1">enterActiveClass)</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">onBeforeAppear(el) {</span>
      <span class="s1">callHook2(onBeforeAppear</span><span class="s2">, </span><span class="s1">[el])</span><span class="s2">;</span>
      <span class="s1">addTransitionClass(el</span><span class="s2">, </span><span class="s1">appearFromClass)</span><span class="s2">;</span>
      <span class="s1">addTransitionClass(el</span><span class="s2">, </span><span class="s1">appearActiveClass)</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">onEnter: makeEnterHook(</span><span class="s2">false</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">onAppear: makeEnterHook(</span><span class="s2">true</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">onLeave(el</span><span class="s2">, </span><span class="s1">done) {</span>
      <span class="s1">el._isLeaving = </span><span class="s2">true;</span>
      <span class="s2">const </span><span class="s1">resolve2 = () =&gt; finishLeave(el</span><span class="s2">, </span><span class="s1">done)</span><span class="s2">;</span>
      <span class="s1">addTransitionClass(el</span><span class="s2">, </span><span class="s1">leaveFromClass)</span><span class="s2">;</span>
      <span class="s1">forceReflow()</span><span class="s2">;</span>
      <span class="s1">addTransitionClass(el</span><span class="s2">, </span><span class="s1">leaveActiveClass)</span><span class="s2">;</span>
      <span class="s1">nextFrame(() =&gt; {</span>
        <span class="s2">if </span><span class="s1">(!el._isLeaving) {</span>
          <span class="s2">return;</span>
        <span class="s1">}</span>
        <span class="s1">removeTransitionClass(el</span><span class="s2">, </span><span class="s1">leaveFromClass)</span><span class="s2">;</span>
        <span class="s1">addTransitionClass(el</span><span class="s2">, </span><span class="s1">leaveToClass)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(!hasExplicitCallback(onLeave)) {</span>
          <span class="s1">whenTransitionEnds(el</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">leaveDuration</span><span class="s2">, </span><span class="s1">resolve2)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">})</span><span class="s2">;</span>
      <span class="s1">callHook2(onLeave</span><span class="s2">, </span><span class="s1">[el</span><span class="s2">, </span><span class="s1">resolve2])</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">onEnterCancelled(el) {</span>
      <span class="s1">finishEnter(el</span><span class="s2">, false</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">callHook2(onEnterCancelled</span><span class="s2">, </span><span class="s1">[el])</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">onAppearCancelled(el) {</span>
      <span class="s1">finishEnter(el</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">callHook2(onAppearCancelled</span><span class="s2">, </span><span class="s1">[el])</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">onLeaveCancelled(el) {</span>
      <span class="s1">finishLeave(el)</span><span class="s2">;</span>
      <span class="s1">callHook2(onLeaveCancelled</span><span class="s2">, </span><span class="s1">[el])</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">})</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">normalizeDuration(duration) {</span>
  <span class="s2">if </span><span class="s1">(duration == </span><span class="s2">null</span><span class="s1">) {</span>
    <span class="s2">return null;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isObject(duration)) {</span>
    <span class="s2">return </span><span class="s1">[NumberOf(duration.enter)</span><span class="s2">, </span><span class="s1">NumberOf(duration.leave)]</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s2">const </span><span class="s1">n = NumberOf(duration)</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">[n</span><span class="s2">, </span><span class="s1">n]</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">NumberOf(val) {</span>
  <span class="s2">const </span><span class="s1">res = toNumber(val)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s1">assertNumber(res</span><span class="s2">, </span><span class="s3">&quot;&lt;transition&gt; explicit duration&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">res</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">addTransitionClass(el</span><span class="s2">, </span><span class="s1">cls) {</span>
  <span class="s1">cls.split(</span><span class="s4">/\s+/</span><span class="s1">).forEach((c) =&gt; c &amp;&amp; el.classList.add(c))</span><span class="s2">;</span>
  <span class="s1">(el._vtc || (el._vtc = </span><span class="s0">/* @__PURE__ */ </span><span class="s2">new </span><span class="s1">Set())).add(cls)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">removeTransitionClass(el</span><span class="s2">, </span><span class="s1">cls) {</span>
  <span class="s1">cls.split(</span><span class="s4">/\s+/</span><span class="s1">).forEach((c) =&gt; c &amp;&amp; el.classList.remove(c))</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">{ _vtc } = el</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(_vtc) {</span>
    <span class="s1">_vtc.delete(cls)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!_vtc.size) {</span>
      <span class="s1">el._vtc = </span><span class="s2">void </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">nextFrame(cb) {</span>
  <span class="s1">requestAnimationFrame(() =&gt; {</span>
    <span class="s1">requestAnimationFrame(cb)</span><span class="s2">;</span>
  <span class="s1">})</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">endId = </span><span class="s4">0</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">whenTransitionEnds(el</span><span class="s2">, </span><span class="s1">expectedType</span><span class="s2">, </span><span class="s1">explicitTimeout</span><span class="s2">, </span><span class="s1">resolve2) {</span>
  <span class="s2">const </span><span class="s1">id = el._endId = ++endId</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">resolveIfNotStale = () =&gt; {</span>
    <span class="s2">if </span><span class="s1">(id === el._endId) {</span>
      <span class="s1">resolve2()</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(explicitTimeout) {</span>
    <span class="s2">return </span><span class="s1">setTimeout(resolveIfNotStale</span><span class="s2">, </span><span class="s1">explicitTimeout)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">const </span><span class="s1">{ type</span><span class="s2">, </span><span class="s1">timeout</span><span class="s2">, </span><span class="s1">propCount } = getTransitionInfo(el</span><span class="s2">, </span><span class="s1">expectedType)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(!type) {</span>
    <span class="s2">return </span><span class="s1">resolve2()</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">const </span><span class="s1">endEvent = type + </span><span class="s3">&quot;end&quot;</span><span class="s2">;</span>
  <span class="s2">let </span><span class="s1">ended = </span><span class="s4">0</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">end = () =&gt; {</span>
    <span class="s1">el.removeEventListener(endEvent</span><span class="s2">, </span><span class="s1">onEnd)</span><span class="s2">;</span>
    <span class="s1">resolveIfNotStale()</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">onEnd = (e) =&gt; {</span>
    <span class="s2">if </span><span class="s1">(e.target === el &amp;&amp; ++ended &gt;= propCount) {</span>
      <span class="s1">end()</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s1">setTimeout(() =&gt; {</span>
    <span class="s2">if </span><span class="s1">(ended &lt; propCount) {</span>
      <span class="s1">end()</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">, </span><span class="s1">timeout + </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">el.addEventListener(endEvent</span><span class="s2">, </span><span class="s1">onEnd)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getTransitionInfo(el</span><span class="s2">, </span><span class="s1">expectedType) {</span>
  <span class="s2">const </span><span class="s1">styles = window.getComputedStyle(el)</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">getStyleProperties = (key) =&gt; (styles[key] || </span><span class="s3">&quot;&quot;</span><span class="s1">).split(</span><span class="s3">&quot;, &quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">transitionDelays = getStyleProperties(</span><span class="s3">`</span><span class="s1">${TRANSITION}</span><span class="s3">Delay`</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">transitionDurations = getStyleProperties(</span><span class="s3">`</span><span class="s1">${TRANSITION}</span><span class="s3">Duration`</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">transitionTimeout = getTimeout(transitionDelays</span><span class="s2">, </span><span class="s1">transitionDurations)</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">animationDelays = getStyleProperties(</span><span class="s3">`</span><span class="s1">${ANIMATION}</span><span class="s3">Delay`</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">animationDurations = getStyleProperties(</span><span class="s3">`</span><span class="s1">${ANIMATION}</span><span class="s3">Duration`</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">animationTimeout = getTimeout(animationDelays</span><span class="s2">, </span><span class="s1">animationDurations)</span><span class="s2">;</span>
  <span class="s2">let </span><span class="s1">type = </span><span class="s2">null;</span>
  <span class="s2">let </span><span class="s1">timeout = </span><span class="s4">0</span><span class="s2">;</span>
  <span class="s2">let </span><span class="s1">propCount = </span><span class="s4">0</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(expectedType === TRANSITION) {</span>
    <span class="s2">if </span><span class="s1">(transitionTimeout &gt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s1">type = TRANSITION</span><span class="s2">;</span>
      <span class="s1">timeout = transitionTimeout</span><span class="s2">;</span>
      <span class="s1">propCount = transitionDurations.length</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(expectedType === ANIMATION) {</span>
    <span class="s2">if </span><span class="s1">(animationTimeout &gt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s1">type = ANIMATION</span><span class="s2">;</span>
      <span class="s1">timeout = animationTimeout</span><span class="s2">;</span>
      <span class="s1">propCount = animationDurations.length</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
    <span class="s1">timeout = Math.max(transitionTimeout</span><span class="s2">, </span><span class="s1">animationTimeout)</span><span class="s2">;</span>
    <span class="s1">type = timeout &gt; </span><span class="s4">0 </span><span class="s1">? transitionTimeout &gt; animationTimeout ? TRANSITION : ANIMATION : </span><span class="s2">null;</span>
    <span class="s1">propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : </span><span class="s4">0</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">const </span><span class="s1">hasTransform = type === TRANSITION &amp;&amp; </span><span class="s4">/\b(transform|all)(,|$)/</span><span class="s1">.test(getStyleProperties(</span><span class="s3">`</span><span class="s1">${TRANSITION}</span><span class="s3">Property`</span><span class="s1">).toString())</span><span class="s2">;</span>
  <span class="s2">return </span><span class="s1">{</span>
    <span class="s1">type</span><span class="s2">,</span>
    <span class="s1">timeout</span><span class="s2">,</span>
    <span class="s1">propCount</span><span class="s2">,</span>
    <span class="s1">hasTransform</span>
  <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getTimeout(delays</span><span class="s2">, </span><span class="s1">durations) {</span>
  <span class="s2">while </span><span class="s1">(delays.length &lt; durations.length) {</span>
    <span class="s1">delays = delays.concat(delays)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">Math.max(...durations.map((d</span><span class="s2">, </span><span class="s1">i) =&gt; toMs(d) + toMs(delays[i])))</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">toMs(s) {</span>
  <span class="s2">return </span><span class="s1">Number(s.slice(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">).replace(</span><span class="s3">&quot;,&quot;</span><span class="s2">, </span><span class="s3">&quot;.&quot;</span><span class="s1">)) * </span><span class="s4">1e3</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">forceReflow() {</span>
  <span class="s2">return </span><span class="s1">document.body.offsetHeight</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">positionMap = </span><span class="s0">/* @__PURE__ */ </span><span class="s2">new </span><span class="s1">WeakMap()</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">newPositionMap = </span><span class="s0">/* @__PURE__ */ </span><span class="s2">new </span><span class="s1">WeakMap()</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">TransitionGroupImpl = {</span>
  <span class="s1">name: </span><span class="s3">&quot;TransitionGroup&quot;</span><span class="s2">,</span>
  <span class="s1">props: extend({}</span><span class="s2">, </span><span class="s1">TransitionPropsValidators</span><span class="s2">, </span><span class="s1">{</span>
    <span class="s1">tag: String</span><span class="s2">,</span>
    <span class="s1">moveClass: String</span>
  <span class="s1">})</span><span class="s2">,</span>
  <span class="s1">setup(props</span><span class="s2">, </span><span class="s1">{ slots }) {</span>
    <span class="s2">const </span><span class="s1">instance = getCurrentInstance()</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">state = useTransitionState()</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">prevChildren</span><span class="s2">;</span>
    <span class="s2">let </span><span class="s1">children</span><span class="s2">;</span>
    <span class="s1">onUpdated(() =&gt; {</span>
      <span class="s2">if </span><span class="s1">(!prevChildren.length) {</span>
        <span class="s2">return;</span>
      <span class="s1">}</span>
      <span class="s2">const </span><span class="s1">moveClass = props.moveClass || </span><span class="s3">`</span><span class="s1">${props.name || </span><span class="s3">&quot;v&quot;</span><span class="s1">}</span><span class="s3">-move`</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(!hasCSSTransform(prevChildren[</span><span class="s4">0</span><span class="s1">].el</span><span class="s2">, </span><span class="s1">instance.vnode.el</span><span class="s2">, </span><span class="s1">moveClass)) {</span>
        <span class="s2">return;</span>
      <span class="s1">}</span>
      <span class="s1">prevChildren.forEach(callPendingCbs)</span><span class="s2">;</span>
      <span class="s1">prevChildren.forEach(recordPosition)</span><span class="s2">;</span>
      <span class="s2">const </span><span class="s1">movedChildren = prevChildren.filter(applyTranslation)</span><span class="s2">;</span>
      <span class="s1">forceReflow()</span><span class="s2">;</span>
      <span class="s1">movedChildren.forEach((c) =&gt; {</span>
        <span class="s2">const </span><span class="s1">el = c.el</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">style = el.style</span><span class="s2">;</span>
        <span class="s1">addTransitionClass(el</span><span class="s2">, </span><span class="s1">moveClass)</span><span class="s2">;</span>
        <span class="s1">style.transform = style.webkitTransform = style.transitionDuration = </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">cb = el._moveCb = (e) =&gt; {</span>
          <span class="s2">if </span><span class="s1">(e &amp;&amp; e.target !== el) {</span>
            <span class="s2">return;</span>
          <span class="s1">}</span>
          <span class="s2">if </span><span class="s1">(!e || </span><span class="s4">/transform$/</span><span class="s1">.test(e.propertyName)) {</span>
            <span class="s1">el.removeEventListener(</span><span class="s3">&quot;transitionend&quot;</span><span class="s2">, </span><span class="s1">cb)</span><span class="s2">;</span>
            <span class="s1">el._moveCb = </span><span class="s2">null;</span>
            <span class="s1">removeTransitionClass(el</span><span class="s2">, </span><span class="s1">moveClass)</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span><span class="s2">;</span>
        <span class="s1">el.addEventListener(</span><span class="s3">&quot;transitionend&quot;</span><span class="s2">, </span><span class="s1">cb)</span><span class="s2">;</span>
      <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">})</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">() =&gt; {</span>
      <span class="s2">const </span><span class="s1">rawProps = toRaw(props)</span><span class="s2">;</span>
      <span class="s2">const </span><span class="s1">cssTransitionProps = resolveTransitionProps(rawProps)</span><span class="s2">;</span>
      <span class="s2">let </span><span class="s1">tag = rawProps.tag || Fragment</span><span class="s2">;</span>
      <span class="s1">prevChildren = children</span><span class="s2">;</span>
      <span class="s1">children = slots.default ? getTransitionRawChildren(slots.default()) : []</span><span class="s2">;</span>
      <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; children.length</span><span class="s2">; </span><span class="s1">i++) {</span>
        <span class="s2">const </span><span class="s1">child = children[i]</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(child.key != </span><span class="s2">null</span><span class="s1">) {</span>
          <span class="s1">setTransitionHooks(child</span><span class="s2">, </span><span class="s1">resolveTransitionHooks(child</span><span class="s2">, </span><span class="s1">cssTransitionProps</span><span class="s2">, </span><span class="s1">state</span><span class="s2">, </span><span class="s1">instance))</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
          <span class="s1">warn2(</span><span class="s3">`&lt;TransitionGroup&gt; children must be keyed.`</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(prevChildren) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; prevChildren.length</span><span class="s2">; </span><span class="s1">i++) {</span>
          <span class="s2">const </span><span class="s1">child = prevChildren[i]</span><span class="s2">;</span>
          <span class="s1">setTransitionHooks(child</span><span class="s2">, </span><span class="s1">resolveTransitionHooks(child</span><span class="s2">, </span><span class="s1">cssTransitionProps</span><span class="s2">, </span><span class="s1">state</span><span class="s2">, </span><span class="s1">instance))</span><span class="s2">;</span>
          <span class="s1">positionMap.set(child</span><span class="s2">, </span><span class="s1">child.el.getBoundingClientRect())</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">return </span><span class="s1">createVNode(tag</span><span class="s2">, null, </span><span class="s1">children)</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">removeMode = (props) =&gt; </span><span class="s2">delete </span><span class="s1">props.mode</span><span class="s2">;</span>
<span class="s1">removeMode(TransitionGroupImpl.props)</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">TransitionGroup = TransitionGroupImpl</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">callPendingCbs(c) {</span>
  <span class="s2">const </span><span class="s1">el = c.el</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(el._moveCb) {</span>
    <span class="s1">el._moveCb()</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(el._enterCb) {</span>
    <span class="s1">el._enterCb()</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">recordPosition(c) {</span>
  <span class="s1">newPositionMap.set(c</span><span class="s2">, </span><span class="s1">c.el.getBoundingClientRect())</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">applyTranslation(c) {</span>
  <span class="s2">const </span><span class="s1">oldPos = positionMap.get(c)</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">newPos = newPositionMap.get(c)</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">dx = oldPos.left - newPos.left</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">dy = oldPos.top - newPos.top</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(dx || dy) {</span>
    <span class="s2">const </span><span class="s1">s = c.el.style</span><span class="s2">;</span>
    <span class="s1">s.transform = s.webkitTransform = </span><span class="s3">`translate(</span><span class="s1">${dx}</span><span class="s3">px,</span><span class="s1">${dy}</span><span class="s3">px)`</span><span class="s2">;</span>
    <span class="s1">s.transitionDuration = </span><span class="s3">&quot;0s&quot;</span><span class="s2">;</span>
    <span class="s2">return </span><span class="s1">c</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">hasCSSTransform(el</span><span class="s2">, </span><span class="s1">root</span><span class="s2">, </span><span class="s1">moveClass) {</span>
  <span class="s2">const </span><span class="s1">clone = el.cloneNode()</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(el._vtc) {</span>
    <span class="s1">el._vtc.forEach((cls) =&gt; {</span>
      <span class="s1">cls.split(</span><span class="s4">/\s+/</span><span class="s1">).forEach((c) =&gt; c &amp;&amp; clone.classList.remove(c))</span><span class="s2">;</span>
    <span class="s1">})</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s1">moveClass.split(</span><span class="s4">/\s+/</span><span class="s1">).forEach((c) =&gt; c &amp;&amp; clone.classList.add(c))</span><span class="s2">;</span>
  <span class="s1">clone.style.display = </span><span class="s3">&quot;none&quot;</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">container = root.nodeType === </span><span class="s4">1 </span><span class="s1">? root : root.parentNode</span><span class="s2">;</span>
  <span class="s1">container.appendChild(clone)</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">{ hasTransform } = getTransitionInfo(clone)</span><span class="s2">;</span>
  <span class="s1">container.removeChild(clone)</span><span class="s2">;</span>
  <span class="s2">return </span><span class="s1">hasTransform</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">getModelAssigner = (vnode) =&gt; {</span>
  <span class="s2">const </span><span class="s1">fn = vnode.props[</span><span class="s3">&quot;onUpdate:modelValue&quot;</span><span class="s1">] || </span><span class="s2">false;</span>
  <span class="s2">return </span><span class="s1">isArray(fn) ? (value) =&gt; invokeArrayFns(fn</span><span class="s2">, </span><span class="s1">value) : fn</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">onCompositionStart(e) {</span>
  <span class="s1">e.target.composing = </span><span class="s2">true;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">onCompositionEnd(e) {</span>
  <span class="s2">const </span><span class="s1">target = e.target</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(target.composing) {</span>
    <span class="s1">target.composing = </span><span class="s2">false;</span>
    <span class="s1">target.dispatchEvent(</span><span class="s2">new </span><span class="s1">Event(</span><span class="s3">&quot;input&quot;</span><span class="s1">))</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">vModelText = {</span>
  <span class="s1">created(el</span><span class="s2">, </span><span class="s1">{ modifiers: { lazy</span><span class="s2">, </span><span class="s1">trim</span><span class="s2">, </span><span class="s1">number } }</span><span class="s2">, </span><span class="s1">vnode) {</span>
    <span class="s1">el._assign = getModelAssigner(vnode)</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">castToNumber = number || vnode.props &amp;&amp; vnode.props.type === </span><span class="s3">&quot;number&quot;</span><span class="s2">;</span>
    <span class="s1">addEventListener(el</span><span class="s2">, </span><span class="s1">lazy ? </span><span class="s3">&quot;change&quot; </span><span class="s1">: </span><span class="s3">&quot;input&quot;</span><span class="s2">, </span><span class="s1">(e) =&gt; {</span>
      <span class="s2">if </span><span class="s1">(e.target.composing)</span>
        <span class="s2">return;</span>
      <span class="s2">let </span><span class="s1">domValue = el.value</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(trim) {</span>
        <span class="s1">domValue = domValue.trim()</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(castToNumber) {</span>
        <span class="s1">domValue = looseToNumber(domValue)</span><span class="s2">;</span>
      <span class="s1">}</span>
      <span class="s1">el._assign(domValue)</span><span class="s2">;</span>
    <span class="s1">})</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(trim) {</span>
      <span class="s1">addEventListener(el</span><span class="s2">, </span><span class="s3">&quot;change&quot;</span><span class="s2">, </span><span class="s1">() =&gt; {</span>
        <span class="s1">el.value = el.value.trim()</span><span class="s2">;</span>
      <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(!lazy) {</span>
      <span class="s1">addEventListener(el</span><span class="s2">, </span><span class="s3">&quot;compositionstart&quot;</span><span class="s2">, </span><span class="s1">onCompositionStart)</span><span class="s2">;</span>
      <span class="s1">addEventListener(el</span><span class="s2">, </span><span class="s3">&quot;compositionend&quot;</span><span class="s2">, </span><span class="s1">onCompositionEnd)</span><span class="s2">;</span>
      <span class="s1">addEventListener(el</span><span class="s2">, </span><span class="s3">&quot;change&quot;</span><span class="s2">, </span><span class="s1">onCompositionEnd)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">,</span>
  <span class="s0">// set value on mounted so it's after min/max for type=&quot;range&quot;</span>
  <span class="s1">mounted(el</span><span class="s2">, </span><span class="s1">{ value }) {</span>
    <span class="s1">el.value = value == </span><span class="s2">null </span><span class="s1">? </span><span class="s3">&quot;&quot; </span><span class="s1">: value</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">,</span>
  <span class="s1">beforeUpdate(el</span><span class="s2">, </span><span class="s1">{ value</span><span class="s2">, </span><span class="s1">modifiers: { lazy</span><span class="s2">, </span><span class="s1">trim</span><span class="s2">, </span><span class="s1">number } }</span><span class="s2">, </span><span class="s1">vnode) {</span>
    <span class="s1">el._assign = getModelAssigner(vnode)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(el.composing)</span>
      <span class="s2">return;</span>
    <span class="s2">if </span><span class="s1">(document.activeElement === el &amp;&amp; el.type !== </span><span class="s3">&quot;range&quot;</span><span class="s1">) {</span>
      <span class="s2">if </span><span class="s1">(lazy) {</span>
        <span class="s2">return;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(trim &amp;&amp; el.value.trim() === value) {</span>
        <span class="s2">return;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">((number || el.type === </span><span class="s3">&quot;number&quot;</span><span class="s1">) &amp;&amp; looseToNumber(el.value) === value) {</span>
        <span class="s2">return;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">newValue = value == </span><span class="s2">null </span><span class="s1">? </span><span class="s3">&quot;&quot; </span><span class="s1">: value</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(el.value !== newValue) {</span>
      <span class="s1">el.value = newValue</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">vModelCheckbox = {</span>
  <span class="s0">// #4096 array checkboxes need to be deep traversed</span>
  <span class="s1">deep: </span><span class="s2">true,</span>
  <span class="s1">created(el</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">vnode) {</span>
    <span class="s1">el._assign = getModelAssigner(vnode)</span><span class="s2">;</span>
    <span class="s1">addEventListener(el</span><span class="s2">, </span><span class="s3">&quot;change&quot;</span><span class="s2">, </span><span class="s1">() =&gt; {</span>
      <span class="s2">const </span><span class="s1">modelValue = el._modelValue</span><span class="s2">;</span>
      <span class="s2">const </span><span class="s1">elementValue = getValue(el)</span><span class="s2">;</span>
      <span class="s2">const </span><span class="s1">checked = el.checked</span><span class="s2">;</span>
      <span class="s2">const </span><span class="s1">assign = el._assign</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(isArray(modelValue)) {</span>
        <span class="s2">const </span><span class="s1">index = looseIndexOf(modelValue</span><span class="s2">, </span><span class="s1">elementValue)</span><span class="s2">;</span>
        <span class="s2">const </span><span class="s1">found = index !== -</span><span class="s4">1</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(checked &amp;&amp; !found) {</span>
          <span class="s1">assign(modelValue.concat(elementValue))</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!checked &amp;&amp; found) {</span>
          <span class="s2">const </span><span class="s1">filtered = [...modelValue]</span><span class="s2">;</span>
          <span class="s1">filtered.splice(index</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
          <span class="s1">assign(filtered)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isSet(modelValue)) {</span>
        <span class="s2">const </span><span class="s1">cloned = </span><span class="s2">new </span><span class="s1">Set(modelValue)</span><span class="s2">;</span>
        <span class="s2">if </span><span class="s1">(checked) {</span>
          <span class="s1">cloned.add(elementValue)</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">cloned.delete(elementValue)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s1">assign(cloned)</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">assign(getCheckboxValue(el</span><span class="s2">, </span><span class="s1">checked))</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">})</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">,</span>
  <span class="s0">// set initial checked on mount to wait for true-value/false-value</span>
  <span class="s1">mounted: setChecked</span><span class="s2">,</span>
  <span class="s1">beforeUpdate(el</span><span class="s2">, </span><span class="s1">binding</span><span class="s2">, </span><span class="s1">vnode) {</span>
    <span class="s1">el._assign = getModelAssigner(vnode)</span><span class="s2">;</span>
    <span class="s1">setChecked(el</span><span class="s2">, </span><span class="s1">binding</span><span class="s2">, </span><span class="s1">vnode)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">setChecked(el</span><span class="s2">, </span><span class="s1">{ value</span><span class="s2">, </span><span class="s1">oldValue }</span><span class="s2">, </span><span class="s1">vnode) {</span>
  <span class="s1">el._modelValue = value</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(isArray(value)) {</span>
    <span class="s1">el.checked = looseIndexOf(value</span><span class="s2">, </span><span class="s1">vnode.props.value) &gt; -</span><span class="s4">1</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isSet(value)) {</span>
    <span class="s1">el.checked = value.has(vnode.props.value)</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(value !== oldValue) {</span>
    <span class="s1">el.checked = looseEqual(value</span><span class="s2">, </span><span class="s1">getCheckboxValue(el</span><span class="s2">, true</span><span class="s1">))</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">vModelRadio = {</span>
  <span class="s1">created(el</span><span class="s2">, </span><span class="s1">{ value }</span><span class="s2">, </span><span class="s1">vnode) {</span>
    <span class="s1">el.checked = looseEqual(value</span><span class="s2">, </span><span class="s1">vnode.props.value)</span><span class="s2">;</span>
    <span class="s1">el._assign = getModelAssigner(vnode)</span><span class="s2">;</span>
    <span class="s1">addEventListener(el</span><span class="s2">, </span><span class="s3">&quot;change&quot;</span><span class="s2">, </span><span class="s1">() =&gt; {</span>
      <span class="s1">el._assign(getValue(el))</span><span class="s2">;</span>
    <span class="s1">})</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">,</span>
  <span class="s1">beforeUpdate(el</span><span class="s2">, </span><span class="s1">{ value</span><span class="s2">, </span><span class="s1">oldValue }</span><span class="s2">, </span><span class="s1">vnode) {</span>
    <span class="s1">el._assign = getModelAssigner(vnode)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(value !== oldValue) {</span>
      <span class="s1">el.checked = looseEqual(value</span><span class="s2">, </span><span class="s1">vnode.props.value)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">vModelSelect = {</span>
  <span class="s0">// &lt;select multiple&gt; value need to be deep traversed</span>
  <span class="s1">deep: </span><span class="s2">true,</span>
  <span class="s1">created(el</span><span class="s2">, </span><span class="s1">{ value</span><span class="s2">, </span><span class="s1">modifiers: { number } }</span><span class="s2">, </span><span class="s1">vnode) {</span>
    <span class="s2">const </span><span class="s1">isSetModel = isSet(value)</span><span class="s2">;</span>
    <span class="s1">addEventListener(el</span><span class="s2">, </span><span class="s3">&quot;change&quot;</span><span class="s2">, </span><span class="s1">() =&gt; {</span>
      <span class="s2">const </span><span class="s1">selectedVal = Array.prototype.filter.call(el.options</span><span class="s2">, </span><span class="s1">(o) =&gt; o.selected).map((o) =&gt; number ? looseToNumber(getValue(o)) : getValue(o))</span><span class="s2">;</span>
      <span class="s1">el._assign(el.multiple ? isSetModel ? </span><span class="s2">new </span><span class="s1">Set(selectedVal) : selectedVal : selectedVal[</span><span class="s4">0</span><span class="s1">])</span><span class="s2">;</span>
    <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">el._assign = getModelAssigner(vnode)</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">,</span>
  <span class="s0">// set value in mounted &amp; updated because &lt;select&gt; relies on its children</span>
  <span class="s0">// &lt;option&gt;s.</span>
  <span class="s1">mounted(el</span><span class="s2">, </span><span class="s1">{ value }) {</span>
    <span class="s1">setSelected(el</span><span class="s2">, </span><span class="s1">value)</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">,</span>
  <span class="s1">beforeUpdate(el</span><span class="s2">, </span><span class="s1">_binding</span><span class="s2">, </span><span class="s1">vnode) {</span>
    <span class="s1">el._assign = getModelAssigner(vnode)</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">,</span>
  <span class="s1">updated(el</span><span class="s2">, </span><span class="s1">{ value }) {</span>
    <span class="s1">setSelected(el</span><span class="s2">, </span><span class="s1">value)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">setSelected(el</span><span class="s2">, </span><span class="s1">value) {</span>
  <span class="s2">const </span><span class="s1">isMultiple = el.multiple</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(isMultiple &amp;&amp; !isArray(value) &amp;&amp; !isSet(value)) {</span>
    <span class="s1">warn2(</span><span class="s3">`&lt;select multiple v-model&gt; expects an Array or Set value for its binding, but got </span><span class="s1">${Object.prototype.toString.call(value).slice(</span><span class="s4">8</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)}</span><span class="s3">.`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s2">return;</span>
  <span class="s1">}</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">l = el.options.length</span><span class="s2">; </span><span class="s1">i &lt; l</span><span class="s2">; </span><span class="s1">i++) {</span>
    <span class="s2">const </span><span class="s1">option = el.options[i]</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">optionValue = getValue(option)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(isMultiple) {</span>
      <span class="s2">if </span><span class="s1">(isArray(value)) {</span>
        <span class="s1">option.selected = looseIndexOf(value</span><span class="s2">, </span><span class="s1">optionValue) &gt; -</span><span class="s4">1</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">option.selected = value.has(optionValue)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">if </span><span class="s1">(looseEqual(getValue(option)</span><span class="s2">, </span><span class="s1">value)) {</span>
        <span class="s2">if </span><span class="s1">(el.selectedIndex !== i)</span>
          <span class="s1">el.selectedIndex = i</span><span class="s2">;</span>
        <span class="s2">return;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(!isMultiple &amp;&amp; el.selectedIndex !== -</span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s1">el.selectedIndex = -</span><span class="s4">1</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getValue(el) {</span>
  <span class="s2">return </span><span class="s3">&quot;_value&quot; </span><span class="s2">in </span><span class="s1">el ? el._value : el.value</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getCheckboxValue(el</span><span class="s2">, </span><span class="s1">checked) {</span>
  <span class="s2">const </span><span class="s1">key = checked ? </span><span class="s3">&quot;_trueValue&quot; </span><span class="s1">: </span><span class="s3">&quot;_falseValue&quot;</span><span class="s2">;</span>
  <span class="s2">return </span><span class="s1">key </span><span class="s2">in </span><span class="s1">el ? el[key] : checked</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">vModelDynamic = {</span>
  <span class="s1">created(el</span><span class="s2">, </span><span class="s1">binding</span><span class="s2">, </span><span class="s1">vnode) {</span>
    <span class="s1">callModelHook(el</span><span class="s2">, </span><span class="s1">binding</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, null, </span><span class="s3">&quot;created&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">,</span>
  <span class="s1">mounted(el</span><span class="s2">, </span><span class="s1">binding</span><span class="s2">, </span><span class="s1">vnode) {</span>
    <span class="s1">callModelHook(el</span><span class="s2">, </span><span class="s1">binding</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, null, </span><span class="s3">&quot;mounted&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">,</span>
  <span class="s1">beforeUpdate(el</span><span class="s2">, </span><span class="s1">binding</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">prevVNode) {</span>
    <span class="s1">callModelHook(el</span><span class="s2">, </span><span class="s1">binding</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">prevVNode</span><span class="s2">, </span><span class="s3">&quot;beforeUpdate&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">,</span>
  <span class="s1">updated(el</span><span class="s2">, </span><span class="s1">binding</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">prevVNode) {</span>
    <span class="s1">callModelHook(el</span><span class="s2">, </span><span class="s1">binding</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">prevVNode</span><span class="s2">, </span><span class="s3">&quot;updated&quot;</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">resolveDynamicModel(tagName</span><span class="s2">, </span><span class="s1">type) {</span>
  <span class="s2">switch </span><span class="s1">(tagName) {</span>
    <span class="s2">case </span><span class="s3">&quot;SELECT&quot;</span><span class="s1">:</span>
      <span class="s2">return </span><span class="s1">vModelSelect</span><span class="s2">;</span>
    <span class="s2">case </span><span class="s3">&quot;TEXTAREA&quot;</span><span class="s1">:</span>
      <span class="s2">return </span><span class="s1">vModelText</span><span class="s2">;</span>
    <span class="s2">default</span><span class="s1">:</span>
      <span class="s2">switch </span><span class="s1">(type) {</span>
        <span class="s2">case </span><span class="s3">&quot;checkbox&quot;</span><span class="s1">:</span>
          <span class="s2">return </span><span class="s1">vModelCheckbox</span><span class="s2">;</span>
        <span class="s2">case </span><span class="s3">&quot;radio&quot;</span><span class="s1">:</span>
          <span class="s2">return </span><span class="s1">vModelRadio</span><span class="s2">;</span>
        <span class="s2">default</span><span class="s1">:</span>
          <span class="s2">return </span><span class="s1">vModelText</span><span class="s2">;</span>
      <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">callModelHook(el</span><span class="s2">, </span><span class="s1">binding</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">prevVNode</span><span class="s2">, </span><span class="s1">hook) {</span>
  <span class="s2">const </span><span class="s1">modelToUse = resolveDynamicModel(el.tagName</span><span class="s2">, </span><span class="s1">vnode.props &amp;&amp; vnode.props.type)</span><span class="s2">;</span>
  <span class="s2">const </span><span class="s1">fn = modelToUse[hook]</span><span class="s2">;</span>
  <span class="s1">fn &amp;&amp; fn(el</span><span class="s2">, </span><span class="s1">binding</span><span class="s2">, </span><span class="s1">vnode</span><span class="s2">, </span><span class="s1">prevVNode)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">initVModelForSSR() {</span>
  <span class="s1">vModelText.getSSRProps = ({ value }) =&gt; ({ value })</span><span class="s2">;</span>
  <span class="s1">vModelRadio.getSSRProps = ({ value }</span><span class="s2">, </span><span class="s1">vnode) =&gt; {</span>
    <span class="s2">if </span><span class="s1">(vnode.props &amp;&amp; looseEqual(vnode.props.value</span><span class="s2">, </span><span class="s1">value)) {</span>
      <span class="s2">return </span><span class="s1">{ checked: </span><span class="s2">true </span><span class="s1">}</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s1">vModelCheckbox.getSSRProps = ({ value }</span><span class="s2">, </span><span class="s1">vnode) =&gt; {</span>
    <span class="s2">if </span><span class="s1">(isArray(value)) {</span>
      <span class="s2">if </span><span class="s1">(vnode.props &amp;&amp; looseIndexOf(value</span><span class="s2">, </span><span class="s1">vnode.props.value) &gt; -</span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">{ checked: </span><span class="s2">true </span><span class="s1">}</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(isSet(value)) {</span>
      <span class="s2">if </span><span class="s1">(vnode.props &amp;&amp; value.has(vnode.props.value)) {</span>
        <span class="s2">return </span><span class="s1">{ checked: </span><span class="s2">true </span><span class="s1">}</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(value) {</span>
      <span class="s2">return </span><span class="s1">{ checked: </span><span class="s2">true </span><span class="s1">}</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s1">vModelDynamic.getSSRProps = (binding</span><span class="s2">, </span><span class="s1">vnode) =&gt; {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">vnode.type !== </span><span class="s3">&quot;string&quot;</span><span class="s1">) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">modelToUse = resolveDynamicModel(</span>
      <span class="s0">// resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase</span>
      <span class="s1">vnode.type.toUpperCase()</span><span class="s2">,</span>
      <span class="s1">vnode.props &amp;&amp; vnode.props.type</span>
    <span class="s1">)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(modelToUse.getSSRProps) {</span>
      <span class="s2">return </span><span class="s1">modelToUse.getSSRProps(binding</span><span class="s2">, </span><span class="s1">vnode)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">systemModifiers = [</span><span class="s3">&quot;ctrl&quot;</span><span class="s2">, </span><span class="s3">&quot;shift&quot;</span><span class="s2">, </span><span class="s3">&quot;alt&quot;</span><span class="s2">, </span><span class="s3">&quot;meta&quot;</span><span class="s1">]</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">modifierGuards = {</span>
  <span class="s1">stop: (e) =&gt; e.stopPropagation()</span><span class="s2">,</span>
  <span class="s1">prevent: (e) =&gt; e.preventDefault()</span><span class="s2">,</span>
  <span class="s1">self: (e) =&gt; e.target !== e.currentTarget</span><span class="s2">,</span>
  <span class="s1">ctrl: (e) =&gt; !e.ctrlKey</span><span class="s2">,</span>
  <span class="s1">shift: (e) =&gt; !e.shiftKey</span><span class="s2">,</span>
  <span class="s1">alt: (e) =&gt; !e.altKey</span><span class="s2">,</span>
  <span class="s1">meta: (e) =&gt; !e.metaKey</span><span class="s2">,</span>
  <span class="s1">left: (e) =&gt; </span><span class="s3">&quot;button&quot; </span><span class="s2">in </span><span class="s1">e &amp;&amp; e.button !== </span><span class="s4">0</span><span class="s2">,</span>
  <span class="s1">middle: (e) =&gt; </span><span class="s3">&quot;button&quot; </span><span class="s2">in </span><span class="s1">e &amp;&amp; e.button !== </span><span class="s4">1</span><span class="s2">,</span>
  <span class="s1">right: (e) =&gt; </span><span class="s3">&quot;button&quot; </span><span class="s2">in </span><span class="s1">e &amp;&amp; e.button !== </span><span class="s4">2</span><span class="s2">,</span>
  <span class="s1">exact: (e</span><span class="s2">, </span><span class="s1">modifiers) =&gt; systemModifiers.some((m) =&gt; e[</span><span class="s3">`</span><span class="s1">${m}</span><span class="s3">Key`</span><span class="s1">] &amp;&amp; !modifiers.includes(m))</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">withModifiers = (fn</span><span class="s2">, </span><span class="s1">modifiers) =&gt; {</span>
  <span class="s2">return </span><span class="s1">(event</span><span class="s2">, </span><span class="s1">...args) =&gt; {</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; modifiers.length</span><span class="s2">; </span><span class="s1">i++) {</span>
      <span class="s2">const </span><span class="s1">guard = modifierGuards[modifiers[i]]</span><span class="s2">;</span>
      <span class="s2">if </span><span class="s1">(guard &amp;&amp; guard(event</span><span class="s2">, </span><span class="s1">modifiers))</span>
        <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">fn(event</span><span class="s2">, </span><span class="s1">...args)</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">keyNames = {</span>
  <span class="s1">esc: </span><span class="s3">&quot;escape&quot;</span><span class="s2">,</span>
  <span class="s1">space: </span><span class="s3">&quot; &quot;</span><span class="s2">,</span>
  <span class="s1">up: </span><span class="s3">&quot;arrow-up&quot;</span><span class="s2">,</span>
  <span class="s1">left: </span><span class="s3">&quot;arrow-left&quot;</span><span class="s2">,</span>
  <span class="s1">right: </span><span class="s3">&quot;arrow-right&quot;</span><span class="s2">,</span>
  <span class="s1">down: </span><span class="s3">&quot;arrow-down&quot;</span><span class="s2">,</span>
  <span class="s2">delete</span><span class="s1">: </span><span class="s3">&quot;backspace&quot;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">withKeys = (fn</span><span class="s2">, </span><span class="s1">modifiers) =&gt; {</span>
  <span class="s2">return </span><span class="s1">(event) =&gt; {</span>
    <span class="s2">if </span><span class="s1">(!(</span><span class="s3">&quot;key&quot; </span><span class="s2">in </span><span class="s1">event)) {</span>
      <span class="s2">return;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">eventKey = hyphenate(event.key)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(modifiers.some((k) =&gt; k === eventKey || keyNames[k] === eventKey)) {</span>
      <span class="s2">return </span><span class="s1">fn(event)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">vShow = {</span>
  <span class="s1">beforeMount(el</span><span class="s2">, </span><span class="s1">{ value }</span><span class="s2">, </span><span class="s1">{ transition }) {</span>
    <span class="s1">el._vod = el.style.display === </span><span class="s3">&quot;none&quot; </span><span class="s1">? </span><span class="s3">&quot;&quot; </span><span class="s1">: el.style.display</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(transition &amp;&amp; value) {</span>
      <span class="s1">transition.beforeEnter(el)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">setDisplay(el</span><span class="s2">, </span><span class="s1">value)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">,</span>
  <span class="s1">mounted(el</span><span class="s2">, </span><span class="s1">{ value }</span><span class="s2">, </span><span class="s1">{ transition }) {</span>
    <span class="s2">if </span><span class="s1">(transition &amp;&amp; value) {</span>
      <span class="s1">transition.enter(el)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">,</span>
  <span class="s1">updated(el</span><span class="s2">, </span><span class="s1">{ value</span><span class="s2">, </span><span class="s1">oldValue }</span><span class="s2">, </span><span class="s1">{ transition }) {</span>
    <span class="s2">if </span><span class="s1">(!value === !oldValue)</span>
      <span class="s2">return;</span>
    <span class="s2">if </span><span class="s1">(transition) {</span>
      <span class="s2">if </span><span class="s1">(value) {</span>
        <span class="s1">transition.beforeEnter(el)</span><span class="s2">;</span>
        <span class="s1">setDisplay(el</span><span class="s2">, true</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">transition.enter(el)</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">transition.leave(el</span><span class="s2">, </span><span class="s1">() =&gt; {</span>
          <span class="s1">setDisplay(el</span><span class="s2">, false</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">})</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">setDisplay(el</span><span class="s2">, </span><span class="s1">value)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">,</span>
  <span class="s1">beforeUnmount(el</span><span class="s2">, </span><span class="s1">{ value }) {</span>
    <span class="s1">setDisplay(el</span><span class="s2">, </span><span class="s1">value)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">setDisplay(el</span><span class="s2">, </span><span class="s1">value) {</span>
  <span class="s1">el.style.display = value ? el._vod : </span><span class="s3">&quot;none&quot;</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">initVShowForSSR() {</span>
  <span class="s1">vShow.getSSRProps = ({ value }) =&gt; {</span>
    <span class="s2">if </span><span class="s1">(!value) {</span>
      <span class="s2">return </span><span class="s1">{ style: { display: </span><span class="s3">&quot;none&quot; </span><span class="s1">} }</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">rendererOptions = extend({ patchProp }</span><span class="s2">, </span><span class="s1">nodeOps)</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">renderer</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">enabledHydration = </span><span class="s2">false;</span>
<span class="s2">function </span><span class="s1">ensureRenderer() {</span>
  <span class="s2">return </span><span class="s1">renderer || (renderer = createRenderer(rendererOptions))</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">ensureHydrationRenderer() {</span>
  <span class="s1">renderer = enabledHydration ? renderer : createHydrationRenderer(rendererOptions)</span><span class="s2">;</span>
  <span class="s1">enabledHydration = </span><span class="s2">true;</span>
  <span class="s2">return </span><span class="s1">renderer</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">render = (...args) =&gt; {</span>
  <span class="s1">ensureRenderer().render(...args)</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">hydrate = (...args) =&gt; {</span>
  <span class="s1">ensureHydrationRenderer().hydrate(...args)</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">createApp = (...args) =&gt; {</span>
  <span class="s2">const </span><span class="s1">app = ensureRenderer().createApp(...args)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s1">injectNativeTagCheck(app)</span><span class="s2">;</span>
    <span class="s1">injectCompilerOptionsCheck(app)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">const </span><span class="s1">{ mount } = app</span><span class="s2">;</span>
  <span class="s1">app.mount = (containerOrSelector) =&gt; {</span>
    <span class="s2">const </span><span class="s1">container = normalizeContainer(containerOrSelector)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!container)</span>
      <span class="s2">return;</span>
    <span class="s2">const </span><span class="s1">component = app._component</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!isFunction(component) &amp;&amp; !component.render &amp;&amp; !component.template) {</span>
      <span class="s1">component.template = container.innerHTML</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">container.innerHTML = </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">proxy = mount(container</span><span class="s2">, false, </span><span class="s1">container </span><span class="s2">instanceof </span><span class="s1">SVGElement)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(container </span><span class="s2">instanceof </span><span class="s1">Element) {</span>
      <span class="s1">container.removeAttribute(</span><span class="s3">&quot;v-cloak&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">container.setAttribute(</span><span class="s3">&quot;data-v-app&quot;</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">proxy</span><span class="s2">;</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">return </span><span class="s1">app</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">var </span><span class="s1">createSSRApp = (...args) =&gt; {</span>
  <span class="s2">const </span><span class="s1">app = ensureHydrationRenderer().createApp(...args)</span><span class="s2">;</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s1">injectNativeTagCheck(app)</span><span class="s2">;</span>
    <span class="s1">injectCompilerOptionsCheck(app)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">const </span><span class="s1">{ mount } = app</span><span class="s2">;</span>
  <span class="s1">app.mount = (containerOrSelector) =&gt; {</span>
    <span class="s2">const </span><span class="s1">container = normalizeContainer(containerOrSelector)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(container) {</span>
      <span class="s2">return </span><span class="s1">mount(container</span><span class="s2">, true, </span><span class="s1">container </span><span class="s2">instanceof </span><span class="s1">SVGElement)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s2">return </span><span class="s1">app</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">function </span><span class="s1">injectNativeTagCheck(app) {</span>
  <span class="s1">Object.defineProperty(app.config</span><span class="s2">, </span><span class="s3">&quot;isNativeTag&quot;</span><span class="s2">, </span><span class="s1">{</span>
    <span class="s1">value: (tag) =&gt; isHTMLTag(tag) || isSVGTag(tag)</span><span class="s2">,</span>
    <span class="s1">writable: </span><span class="s2">false</span>
  <span class="s1">})</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">injectCompilerOptionsCheck(app) {</span>
  <span class="s2">if </span><span class="s1">(isRuntimeOnly()) {</span>
    <span class="s2">const </span><span class="s1">isCustomElement = app.config.isCustomElement</span><span class="s2">;</span>
    <span class="s1">Object.defineProperty(app.config</span><span class="s2">, </span><span class="s3">&quot;isCustomElement&quot;</span><span class="s2">, </span><span class="s1">{</span>
      <span class="s1">get() {</span>
        <span class="s2">return </span><span class="s1">isCustomElement</span><span class="s2">;</span>
      <span class="s1">}</span><span class="s2">,</span>
      <span class="s1">set() {</span>
        <span class="s1">warn2(</span><span class="s3">`The </span><span class="s2">\`</span><span class="s3">isCustomElement</span><span class="s2">\` </span><span class="s3">config option is deprecated. Use </span><span class="s2">\`</span><span class="s3">compilerOptions.isCustomElement</span><span class="s2">\` </span><span class="s3">instead.`</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">})</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">compilerOptions = app.config.compilerOptions</span><span class="s2">;</span>
    <span class="s2">const </span><span class="s1">msg = </span><span class="s3">`The </span><span class="s2">\`</span><span class="s3">compilerOptions</span><span class="s2">\` </span><span class="s3">config option is only respected when using a build of Vue.js that includes the runtime compiler (aka &quot;full build&quot;). Since you are using the runtime-only build, </span><span class="s2">\`</span><span class="s3">compilerOptions</span><span class="s2">\` </span><span class="s3">must be passed to </span><span class="s2">\`</span><span class="s3">@vue/compiler-dom</span><span class="s2">\` </span><span class="s3">in the build setup instead. 
- For vue-loader: pass it via vue-loader's </span><span class="s2">\`</span><span class="s3">compilerOptions</span><span class="s2">\` </span><span class="s3">loader option. 
- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader 
- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-dom`</span><span class="s2">;</span>
    <span class="s1">Object.defineProperty(app.config</span><span class="s2">, </span><span class="s3">&quot;compilerOptions&quot;</span><span class="s2">, </span><span class="s1">{</span>
      <span class="s1">get() {</span>
        <span class="s1">warn2(msg)</span><span class="s2">;</span>
        <span class="s2">return </span><span class="s1">compilerOptions</span><span class="s2">;</span>
      <span class="s1">}</span><span class="s2">,</span>
      <span class="s1">set() {</span>
        <span class="s1">warn2(msg)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">})</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">normalizeContainer(container) {</span>
  <span class="s2">if </span><span class="s1">(isString(container)) {</span>
    <span class="s2">const </span><span class="s1">res = document.querySelector(container)</span><span class="s2">;</span>
    <span class="s2">if </span><span class="s1">(!res) {</span>
      <span class="s1">warn2(</span><span class="s3">`Failed to mount app: mount target selector &quot;</span><span class="s1">${container}</span><span class="s3">&quot; returned null.`</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">res</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(window.ShadowRoot &amp;&amp; container </span><span class="s2">instanceof </span><span class="s1">window.ShadowRoot &amp;&amp; container.mode === </span><span class="s3">&quot;closed&quot;</span><span class="s1">) {</span>
    <span class="s1">warn2(</span><span class="s3">`mounting on a ShadowRoot with </span><span class="s2">\`</span><span class="s3">{mode: &quot;closed&quot;}</span><span class="s2">\` </span><span class="s3">may lead to unpredictable bugs`</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">container</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">ssrDirectiveInitialized = </span><span class="s2">false;</span>
<span class="s2">var </span><span class="s1">initDirectivesForSSR = () =&gt; {</span>
  <span class="s2">if </span><span class="s1">(!ssrDirectiveInitialized) {</span>
    <span class="s1">ssrDirectiveInitialized = </span><span class="s2">true;</span>
    <span class="s1">initVModelForSSR()</span><span class="s2">;</span>
    <span class="s1">initVShowForSSR()</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">// node_modules/vue/dist/vue.runtime.esm-bundler.js</span>
<span class="s2">function </span><span class="s1">initDev() {</span>
  <span class="s1">{</span>
    <span class="s1">initCustomFormatter()</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
  <span class="s1">initDev()</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s2">var </span><span class="s1">compile2 = () =&gt; {</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s1">warn2(</span>
      <span class="s3">`Runtime compilation is not supported in this build of Vue. Configure your bundler to alias &quot;vue&quot; to &quot;vue/dist/vue.esm-bundler.js&quot;.`</span>
      <span class="s0">/* should not happen */</span>
    <span class="s1">)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s2">export </span><span class="s1">{</span>
  <span class="s1">BaseTransition</span><span class="s2">,</span>
  <span class="s1">Comment</span><span class="s2">,</span>
  <span class="s1">EffectScope</span><span class="s2">,</span>
  <span class="s1">Fragment</span><span class="s2">,</span>
  <span class="s1">KeepAlive</span><span class="s2">,</span>
  <span class="s1">ReactiveEffect</span><span class="s2">,</span>
  <span class="s1">Static</span><span class="s2">,</span>
  <span class="s1">Suspense</span><span class="s2">,</span>
  <span class="s1">Teleport</span><span class="s2">,</span>
  <span class="s1">Text</span><span class="s2">,</span>
  <span class="s1">Transition</span><span class="s2">,</span>
  <span class="s1">TransitionGroup</span><span class="s2">,</span>
  <span class="s1">VueElement</span><span class="s2">,</span>
  <span class="s1">assertNumber</span><span class="s2">,</span>
  <span class="s1">callWithAsyncErrorHandling</span><span class="s2">,</span>
  <span class="s1">callWithErrorHandling</span><span class="s2">,</span>
  <span class="s1">camelize</span><span class="s2">,</span>
  <span class="s1">capitalize</span><span class="s2">,</span>
  <span class="s1">cloneVNode</span><span class="s2">,</span>
  <span class="s1">compatUtils</span><span class="s2">,</span>
  <span class="s1">compile2 as compile</span><span class="s2">,</span>
  <span class="s1">computed2 as computed</span><span class="s2">,</span>
  <span class="s1">createApp</span><span class="s2">,</span>
  <span class="s1">createBlock</span><span class="s2">,</span>
  <span class="s1">createCommentVNode</span><span class="s2">,</span>
  <span class="s1">createElementBlock</span><span class="s2">,</span>
  <span class="s1">createBaseVNode as createElementVNode</span><span class="s2">,</span>
  <span class="s1">createHydrationRenderer</span><span class="s2">,</span>
  <span class="s1">createPropsRestProxy</span><span class="s2">,</span>
  <span class="s1">createRenderer</span><span class="s2">,</span>
  <span class="s1">createSSRApp</span><span class="s2">,</span>
  <span class="s1">createSlots</span><span class="s2">,</span>
  <span class="s1">createStaticVNode</span><span class="s2">,</span>
  <span class="s1">createTextVNode</span><span class="s2">,</span>
  <span class="s1">createVNode</span><span class="s2">,</span>
  <span class="s1">customRef</span><span class="s2">,</span>
  <span class="s1">defineAsyncComponent</span><span class="s2">,</span>
  <span class="s1">defineComponent</span><span class="s2">,</span>
  <span class="s1">defineCustomElement</span><span class="s2">,</span>
  <span class="s1">defineEmits</span><span class="s2">,</span>
  <span class="s1">defineExpose</span><span class="s2">,</span>
  <span class="s1">defineProps</span><span class="s2">,</span>
  <span class="s1">defineSSRCustomElement</span><span class="s2">,</span>
  <span class="s1">devtools</span><span class="s2">,</span>
  <span class="s1">effect</span><span class="s2">,</span>
  <span class="s1">effectScope</span><span class="s2">,</span>
  <span class="s1">getCurrentInstance</span><span class="s2">,</span>
  <span class="s1">getCurrentScope</span><span class="s2">,</span>
  <span class="s1">getTransitionRawChildren</span><span class="s2">,</span>
  <span class="s1">guardReactiveProps</span><span class="s2">,</span>
  <span class="s1">h</span><span class="s2">,</span>
  <span class="s1">handleError</span><span class="s2">,</span>
  <span class="s1">hydrate</span><span class="s2">,</span>
  <span class="s1">initCustomFormatter</span><span class="s2">,</span>
  <span class="s1">initDirectivesForSSR</span><span class="s2">,</span>
  <span class="s1">inject</span><span class="s2">,</span>
  <span class="s1">isMemoSame</span><span class="s2">,</span>
  <span class="s1">isProxy</span><span class="s2">,</span>
  <span class="s1">isReactive</span><span class="s2">,</span>
  <span class="s1">isReadonly</span><span class="s2">,</span>
  <span class="s1">isRef</span><span class="s2">,</span>
  <span class="s1">isRuntimeOnly</span><span class="s2">,</span>
  <span class="s1">isShallow</span><span class="s2">,</span>
  <span class="s1">isVNode</span><span class="s2">,</span>
  <span class="s1">markRaw</span><span class="s2">,</span>
  <span class="s1">mergeDefaults</span><span class="s2">,</span>
  <span class="s1">mergeProps</span><span class="s2">,</span>
  <span class="s1">nextTick</span><span class="s2">,</span>
  <span class="s1">normalizeClass</span><span class="s2">,</span>
  <span class="s1">normalizeProps</span><span class="s2">,</span>
  <span class="s1">normalizeStyle</span><span class="s2">,</span>
  <span class="s1">onActivated</span><span class="s2">,</span>
  <span class="s1">onBeforeMount</span><span class="s2">,</span>
  <span class="s1">onBeforeUnmount</span><span class="s2">,</span>
  <span class="s1">onBeforeUpdate</span><span class="s2">,</span>
  <span class="s1">onDeactivated</span><span class="s2">,</span>
  <span class="s1">onErrorCaptured</span><span class="s2">,</span>
  <span class="s1">onMounted</span><span class="s2">,</span>
  <span class="s1">onRenderTracked</span><span class="s2">,</span>
  <span class="s1">onRenderTriggered</span><span class="s2">,</span>
  <span class="s1">onScopeDispose</span><span class="s2">,</span>
  <span class="s1">onServerPrefetch</span><span class="s2">,</span>
  <span class="s1">onUnmounted</span><span class="s2">,</span>
  <span class="s1">onUpdated</span><span class="s2">,</span>
  <span class="s1">openBlock</span><span class="s2">,</span>
  <span class="s1">popScopeId</span><span class="s2">,</span>
  <span class="s1">provide</span><span class="s2">,</span>
  <span class="s1">proxyRefs</span><span class="s2">,</span>
  <span class="s1">pushScopeId</span><span class="s2">,</span>
  <span class="s1">queuePostFlushCb</span><span class="s2">,</span>
  <span class="s1">reactive</span><span class="s2">,</span>
  <span class="s1">readonly</span><span class="s2">,</span>
  <span class="s1">ref</span><span class="s2">,</span>
  <span class="s1">registerRuntimeCompiler</span><span class="s2">,</span>
  <span class="s1">render</span><span class="s2">,</span>
  <span class="s1">renderList</span><span class="s2">,</span>
  <span class="s1">renderSlot</span><span class="s2">,</span>
  <span class="s1">resolveComponent</span><span class="s2">,</span>
  <span class="s1">resolveDirective</span><span class="s2">,</span>
  <span class="s1">resolveDynamicComponent</span><span class="s2">,</span>
  <span class="s1">resolveFilter</span><span class="s2">,</span>
  <span class="s1">resolveTransitionHooks</span><span class="s2">,</span>
  <span class="s1">setBlockTracking</span><span class="s2">,</span>
  <span class="s1">setDevtoolsHook</span><span class="s2">,</span>
  <span class="s1">setTransitionHooks</span><span class="s2">,</span>
  <span class="s1">shallowReactive</span><span class="s2">,</span>
  <span class="s1">shallowReadonly</span><span class="s2">,</span>
  <span class="s1">shallowRef</span><span class="s2">,</span>
  <span class="s1">ssrContextKey</span><span class="s2">,</span>
  <span class="s1">ssrUtils</span><span class="s2">,</span>
  <span class="s1">stop</span><span class="s2">,</span>
  <span class="s1">toDisplayString</span><span class="s2">,</span>
  <span class="s1">toHandlerKey</span><span class="s2">,</span>
  <span class="s1">toHandlers</span><span class="s2">,</span>
  <span class="s1">toRaw</span><span class="s2">,</span>
  <span class="s1">toRef</span><span class="s2">,</span>
  <span class="s1">toRefs</span><span class="s2">,</span>
  <span class="s1">transformVNodeArgs</span><span class="s2">,</span>
  <span class="s1">triggerRef</span><span class="s2">,</span>
  <span class="s1">unref</span><span class="s2">,</span>
  <span class="s1">useAttrs</span><span class="s2">,</span>
  <span class="s1">useCssModule</span><span class="s2">,</span>
  <span class="s1">useCssVars</span><span class="s2">,</span>
  <span class="s1">useSSRContext</span><span class="s2">,</span>
  <span class="s1">useSlots</span><span class="s2">,</span>
  <span class="s1">useTransitionState</span><span class="s2">,</span>
  <span class="s1">vModelCheckbox</span><span class="s2">,</span>
  <span class="s1">vModelDynamic</span><span class="s2">,</span>
  <span class="s1">vModelRadio</span><span class="s2">,</span>
  <span class="s1">vModelSelect</span><span class="s2">,</span>
  <span class="s1">vModelText</span><span class="s2">,</span>
  <span class="s1">vShow</span><span class="s2">,</span>
  <span class="s1">version</span><span class="s2">,</span>
  <span class="s1">warn2 as warn</span><span class="s2">,</span>
  <span class="s1">watch</span><span class="s2">,</span>
  <span class="s1">watchEffect</span><span class="s2">,</span>
  <span class="s1">watchPostEffect</span><span class="s2">,</span>
  <span class="s1">watchSyncEffect</span><span class="s2">,</span>
  <span class="s1">withAsyncContext</span><span class="s2">,</span>
  <span class="s1">withCtx</span><span class="s2">,</span>
  <span class="s1">withDefaults</span><span class="s2">,</span>
  <span class="s1">withDirectives</span><span class="s2">,</span>
  <span class="s1">withKeys</span><span class="s2">,</span>
  <span class="s1">withMemo</span><span class="s2">,</span>
  <span class="s1">withModifiers</span><span class="s2">,</span>
  <span class="s1">withScopeId</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s0">//# sourceMappingURL=vue.js.map</span>
</pre>
</body>
</html>