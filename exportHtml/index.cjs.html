<html>
<head>
<title>index.cjs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #6a8759;}
.s1 { color: #cc7832;}
.s2 { color: #a9b7c6;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
.s5 { color: #629755; font-style: italic;}
.s6 { color: #629755; font-weight: bold; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
index.cjs</font>
</center></td></tr></table>
<pre><span class="s0">'use strict'</span><span class="s1">;</span>

<span class="s2">Object.defineProperty(exports</span><span class="s1">, </span><span class="s0">'__esModule'</span><span class="s1">, </span><span class="s2">{ value: </span><span class="s1">true </span><span class="s2">})</span><span class="s1">;</span>

<span class="s1">const </span><span class="s2">fs = require(</span><span class="s0">'node:fs'</span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">vite = require(</span><span class="s0">'vite'</span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">node_module = require(</span><span class="s0">'node:module'</span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">path = require(</span><span class="s0">'node:path'</span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">node_crypto = require(</span><span class="s0">'node:crypto'</span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">require$$0 = require(</span><span class="s0">'tty'</span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">require$$1 = require(</span><span class="s0">'util'</span><span class="s2">)</span><span class="s1">;</span>

<span class="s1">function </span><span class="s2">resolveCompiler(root) {</span>
  <span class="s1">const </span><span class="s2">compiler = tryResolveCompiler(root) || tryResolveCompiler()</span><span class="s1">;</span>
  <span class="s1">if </span><span class="s2">(!compiler) {</span>
    <span class="s1">throw new </span><span class="s2">Error(</span>
      <span class="s0">`Failed to resolve vue/compiler-sfc. 
@vitejs/plugin-vue requires vue (&gt;=3.2.25) to be present in the dependency tree.`</span>
    <span class="s2">)</span><span class="s1">;</span>
  <span class="s2">}</span>
  <span class="s1">return </span><span class="s2">compiler</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">tryResolveCompiler(root) {</span>
  <span class="s1">const </span><span class="s2">vueMeta = tryRequire(</span><span class="s0">&quot;vue/package.json&quot;</span><span class="s1">, </span><span class="s2">root)</span><span class="s1">;</span>
  <span class="s1">if </span><span class="s2">(vueMeta &amp;&amp; vueMeta.version.split(</span><span class="s0">&quot;.&quot;</span><span class="s2">)[</span><span class="s3">0</span><span class="s2">] &gt;= </span><span class="s3">3</span><span class="s2">) {</span>
    <span class="s1">return </span><span class="s2">tryRequire(</span><span class="s0">&quot;vue/compiler-sfc&quot;</span><span class="s1">, </span><span class="s2">root)</span><span class="s1">;</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">const </span><span class="s2">_require = node_module.createRequire((</span><span class="s1">typeof </span><span class="s2">document === </span><span class="s0">'undefined' </span><span class="s2">? </span><span class="s1">new </span><span class="s2">(require(</span><span class="s0">'u' </span><span class="s2">+ </span><span class="s0">'rl'</span><span class="s2">).URL)(</span><span class="s0">'file:' </span><span class="s2">+ __filename).href : (document.currentScript &amp;&amp; document.currentScript.src || </span><span class="s1">new </span><span class="s2">URL(</span><span class="s0">'index.cjs'</span><span class="s1">, </span><span class="s2">document.baseURI).href)))</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">tryRequire(id</span><span class="s1">, </span><span class="s2">from) {</span>
  <span class="s1">try </span><span class="s2">{</span>
    <span class="s1">return </span><span class="s2">from ? _require(_require.resolve(id</span><span class="s1">, </span><span class="s2">{ paths: [from] })) : _require(id)</span><span class="s1">;</span>
  <span class="s2">} </span><span class="s1">catch </span><span class="s2">(e) {</span>
  <span class="s2">}</span>
<span class="s2">}</span>

<span class="s1">function </span><span class="s2">parseVueRequest(id) {</span>
  <span class="s1">const </span><span class="s2">[filename</span><span class="s1">, </span><span class="s2">rawQuery] = id.split(</span><span class="s0">`?`</span><span class="s1">, </span><span class="s3">2</span><span class="s2">)</span><span class="s1">;</span>
  <span class="s1">const </span><span class="s2">query = Object.fromEntries(</span><span class="s1">new </span><span class="s2">URLSearchParams(rawQuery))</span><span class="s1">;</span>
  <span class="s1">if </span><span class="s2">(query.vue != </span><span class="s1">null</span><span class="s2">) {</span>
    <span class="s2">query.vue = </span><span class="s1">true;</span>
  <span class="s2">}</span>
  <span class="s1">if </span><span class="s2">(query.index != </span><span class="s1">null</span><span class="s2">) {</span>
    <span class="s2">query.index = Number(query.index)</span><span class="s1">;</span>
  <span class="s2">}</span>
  <span class="s1">if </span><span class="s2">(query.raw != </span><span class="s1">null</span><span class="s2">) {</span>
    <span class="s2">query.raw = </span><span class="s1">true;</span>
  <span class="s2">}</span>
  <span class="s1">if </span><span class="s2">(query.url != </span><span class="s1">null</span><span class="s2">) {</span>
    <span class="s2">query.url = </span><span class="s1">true;</span>
  <span class="s2">}</span>
  <span class="s1">if </span><span class="s2">(query.scoped != </span><span class="s1">null</span><span class="s2">) {</span>
    <span class="s2">query.scoped = </span><span class="s1">true;</span>
  <span class="s2">}</span>
  <span class="s1">return </span><span class="s2">{</span>
    <span class="s2">filename</span><span class="s1">,</span>
    <span class="s2">query</span>
  <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s1">function </span><span class="s2">slash(path) {</span>
	<span class="s1">const </span><span class="s2">isExtendedLengthPath = </span><span class="s3">/^\\\\\?\\/</span><span class="s2">.test(path)</span><span class="s1">;</span>

	<span class="s1">if </span><span class="s2">(isExtendedLengthPath) {</span>
		<span class="s1">return </span><span class="s2">path</span><span class="s1">;</span>
	<span class="s2">}</span>

	<span class="s1">return </span><span class="s2">path.replace(</span><span class="s3">/\\/g</span><span class="s1">, </span><span class="s0">'/'</span><span class="s2">)</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s1">const </span><span class="s2">cache = </span><span class="s4">/* @__PURE__ */ </span><span class="s1">new </span><span class="s2">Map()</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">prevCache = </span><span class="s4">/* @__PURE__ */ </span><span class="s1">new </span><span class="s2">Map()</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">createDescriptor(filename</span><span class="s1">, </span><span class="s2">source</span><span class="s1">, </span><span class="s2">{ root</span><span class="s1">, </span><span class="s2">isProduction</span><span class="s1">, </span><span class="s2">sourceMap</span><span class="s1">, </span><span class="s2">compiler }) {</span>
  <span class="s1">const </span><span class="s2">{ descriptor</span><span class="s1">, </span><span class="s2">errors } = compiler.parse(source</span><span class="s1">, </span><span class="s2">{</span>
    <span class="s2">filename</span><span class="s1">,</span>
    <span class="s2">sourceMap</span>
  <span class="s2">})</span><span class="s1">;</span>
  <span class="s1">const </span><span class="s2">normalizedPath = slash(path.normalize(path.relative(root</span><span class="s1">, </span><span class="s2">filename)))</span><span class="s1">;</span>
  <span class="s2">descriptor.id = getHash(normalizedPath + (isProduction ? source : </span><span class="s0">&quot;&quot;</span><span class="s2">))</span><span class="s1">;</span>
  <span class="s2">cache.set(filename</span><span class="s1">, </span><span class="s2">descriptor)</span><span class="s1">;</span>
  <span class="s1">return </span><span class="s2">{ descriptor</span><span class="s1">, </span><span class="s2">errors }</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">getPrevDescriptor(filename) {</span>
  <span class="s1">return </span><span class="s2">prevCache.get(filename)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">setPrevDescriptor(filename</span><span class="s1">, </span><span class="s2">entry) {</span>
  <span class="s2">prevCache.set(filename</span><span class="s1">, </span><span class="s2">entry)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">getDescriptor(filename</span><span class="s1">, </span><span class="s2">options</span><span class="s1">, </span><span class="s2">createIfNotFound = </span><span class="s1">true</span><span class="s2">) {</span>
  <span class="s1">if </span><span class="s2">(cache.has(filename)) {</span>
    <span class="s1">return </span><span class="s2">cache.get(filename)</span><span class="s1">;</span>
  <span class="s2">}</span>
  <span class="s1">if </span><span class="s2">(createIfNotFound) {</span>
    <span class="s1">const </span><span class="s2">{ descriptor</span><span class="s1">, </span><span class="s2">errors } = createDescriptor(</span>
      <span class="s2">filename</span><span class="s1">,</span>
      <span class="s2">fs.readFileSync(filename</span><span class="s1">, </span><span class="s0">&quot;utf-8&quot;</span><span class="s2">)</span><span class="s1">,</span>
      <span class="s2">options</span>
    <span class="s2">)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(errors.length) {</span>
      <span class="s1">throw </span><span class="s2">errors[</span><span class="s3">0</span><span class="s2">]</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">descriptor</span><span class="s1">;</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">getSrcDescriptor(filename</span><span class="s1">, </span><span class="s2">query) {</span>
  <span class="s1">if </span><span class="s2">(query.scoped) {</span>
    <span class="s1">return </span><span class="s2">cache.get(</span><span class="s0">`</span><span class="s2">${filename}</span><span class="s0">?src=</span><span class="s2">${query.src}</span><span class="s0">`</span><span class="s2">)</span><span class="s1">;</span>
  <span class="s2">}</span>
  <span class="s1">return </span><span class="s2">cache.get(filename)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">setSrcDescriptor(filename</span><span class="s1">, </span><span class="s2">entry</span><span class="s1">, </span><span class="s2">scoped) {</span>
  <span class="s1">if </span><span class="s2">(scoped) {</span>
    <span class="s2">cache.set(</span><span class="s0">`</span><span class="s2">${filename}</span><span class="s0">?src=</span><span class="s2">${entry.id}</span><span class="s0">`</span><span class="s1">, </span><span class="s2">entry)</span><span class="s1">;</span>
    <span class="s1">return;</span>
  <span class="s2">}</span>
  <span class="s2">cache.set(filename</span><span class="s1">, </span><span class="s2">entry)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">getHash(text) {</span>
  <span class="s1">return </span><span class="s2">node_crypto.createHash(</span><span class="s0">&quot;sha256&quot;</span><span class="s2">).update(text).digest(</span><span class="s0">&quot;hex&quot;</span><span class="s2">).substring(</span><span class="s3">0</span><span class="s1">, </span><span class="s3">8</span><span class="s2">)</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s1">function </span><span class="s2">createRollupError(id</span><span class="s1">, </span><span class="s2">error) {</span>
  <span class="s1">const </span><span class="s2">{ message</span><span class="s1">, </span><span class="s2">name</span><span class="s1">, </span><span class="s2">stack } = error</span><span class="s1">;</span>
  <span class="s1">const </span><span class="s2">rollupError = {</span>
    <span class="s2">id</span><span class="s1">,</span>
    <span class="s2">plugin: </span><span class="s0">&quot;vue&quot;</span><span class="s1">,</span>
    <span class="s2">message</span><span class="s1">,</span>
    <span class="s2">name</span><span class="s1">,</span>
    <span class="s2">stack</span>
  <span class="s2">}</span><span class="s1">;</span>
  <span class="s1">if </span><span class="s2">(</span><span class="s0">&quot;code&quot; </span><span class="s1">in </span><span class="s2">error &amp;&amp; error.loc) {</span>
    <span class="s2">rollupError.loc = {</span>
      <span class="s2">file: id</span><span class="s1">,</span>
      <span class="s2">line: error.loc.start.line</span><span class="s1">,</span>
      <span class="s2">column: error.loc.start.column</span>
    <span class="s2">}</span><span class="s1">;</span>
  <span class="s2">}</span>
  <span class="s1">return </span><span class="s2">rollupError</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s2">async </span><span class="s1">function </span><span class="s2">transformTemplateAsModule(code</span><span class="s1">, </span><span class="s2">descriptor</span><span class="s1">, </span><span class="s2">options</span><span class="s1">, </span><span class="s2">pluginContext</span><span class="s1">, </span><span class="s2">ssr) {</span>
  <span class="s1">const </span><span class="s2">result = compile(code</span><span class="s1">, </span><span class="s2">descriptor</span><span class="s1">, </span><span class="s2">options</span><span class="s1">, </span><span class="s2">pluginContext</span><span class="s1">, </span><span class="s2">ssr)</span><span class="s1">;</span>
  <span class="s1">let </span><span class="s2">returnCode = result.code</span><span class="s1">;</span>
  <span class="s1">if </span><span class="s2">(options.devServer &amp;&amp; options.devServer.config.server.hmr !== </span><span class="s1">false </span><span class="s2">&amp;&amp; !ssr &amp;&amp; !options.isProduction) {</span>
    <span class="s2">returnCode += </span><span class="s0">`</span>
<span class="s0">import.meta.hot.accept(({ render }) =&gt; { 
      __VUE_HMR_RUNTIME__.rerender(</span><span class="s2">${JSON.stringify(descriptor.id)}</span><span class="s0">, render) 
    })`</span><span class="s1">;</span>
  <span class="s2">}</span>
  <span class="s1">return </span><span class="s2">{</span>
    <span class="s2">code: returnCode</span><span class="s1">,</span>
    <span class="s2">map: result.map</span>
  <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">transformTemplateInMain(code</span><span class="s1">, </span><span class="s2">descriptor</span><span class="s1">, </span><span class="s2">options</span><span class="s1">, </span><span class="s2">pluginContext</span><span class="s1">, </span><span class="s2">ssr) {</span>
  <span class="s1">const </span><span class="s2">result = compile(code</span><span class="s1">, </span><span class="s2">descriptor</span><span class="s1">, </span><span class="s2">options</span><span class="s1">, </span><span class="s2">pluginContext</span><span class="s1">, </span><span class="s2">ssr)</span><span class="s1">;</span>
  <span class="s1">return </span><span class="s2">{</span>
    <span class="s2">...result</span><span class="s1">,</span>
    <span class="s2">code: result.code.replace(</span>
      <span class="s3">/\nexport (function|const) (render|ssrRender)/</span><span class="s1">,</span>
      <span class="s0">&quot;</span><span class="s1">\n</span><span class="s0">$1 _sfc_$2&quot;</span>
    <span class="s2">)</span>
  <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">compile(code</span><span class="s1">, </span><span class="s2">descriptor</span><span class="s1">, </span><span class="s2">options</span><span class="s1">, </span><span class="s2">pluginContext</span><span class="s1">, </span><span class="s2">ssr) {</span>
  <span class="s1">const </span><span class="s2">filename = descriptor.filename</span><span class="s1">;</span>
  <span class="s1">const </span><span class="s2">result = options.compiler.compileTemplate({</span>
    <span class="s2">...resolveTemplateCompilerOptions(descriptor</span><span class="s1">, </span><span class="s2">options</span><span class="s1">, </span><span class="s2">ssr)</span><span class="s1">,</span>
    <span class="s2">source: code</span>
  <span class="s2">})</span><span class="s1">;</span>
  <span class="s1">if </span><span class="s2">(result.errors.length) {</span>
    <span class="s2">result.errors.forEach(</span>
      <span class="s2">(error) =&gt; pluginContext.error(</span>
        <span class="s1">typeof </span><span class="s2">error === </span><span class="s0">&quot;string&quot; </span><span class="s2">? { id: filename</span><span class="s1">, </span><span class="s2">message: error } : createRollupError(filename</span><span class="s1">, </span><span class="s2">error)</span>
      <span class="s2">)</span>
    <span class="s2">)</span><span class="s1">;</span>
  <span class="s2">}</span>
  <span class="s1">if </span><span class="s2">(result.tips.length) {</span>
    <span class="s2">result.tips.forEach(</span>
      <span class="s2">(tip) =&gt; pluginContext.warn({</span>
        <span class="s2">id: filename</span><span class="s1">,</span>
        <span class="s2">message: tip</span>
      <span class="s2">})</span>
    <span class="s2">)</span><span class="s1">;</span>
  <span class="s2">}</span>
  <span class="s1">return </span><span class="s2">result</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">resolveTemplateCompilerOptions(descriptor</span><span class="s1">, </span><span class="s2">options</span><span class="s1">, </span><span class="s2">ssr) {</span>
  <span class="s1">const </span><span class="s2">block = descriptor.template</span><span class="s1">;</span>
  <span class="s1">if </span><span class="s2">(!block) {</span>
    <span class="s1">return;</span>
  <span class="s2">}</span>
  <span class="s1">const </span><span class="s2">resolvedScript = getResolvedScript(descriptor</span><span class="s1">, </span><span class="s2">ssr)</span><span class="s1">;</span>
  <span class="s1">const </span><span class="s2">hasScoped = descriptor.styles.some((s) =&gt; s.scoped)</span><span class="s1">;</span>
  <span class="s1">const </span><span class="s2">{ id</span><span class="s1">, </span><span class="s2">filename</span><span class="s1">, </span><span class="s2">cssVars } = descriptor</span><span class="s1">;</span>
  <span class="s1">let </span><span class="s2">transformAssetUrls = options.template?.transformAssetUrls</span><span class="s1">;</span>
  <span class="s1">let </span><span class="s2">assetUrlOptions</span><span class="s1">;</span>
  <span class="s1">if </span><span class="s2">(options.devServer) {</span>
    <span class="s1">if </span><span class="s2">(filename.startsWith(options.root)) {</span>
      <span class="s1">const </span><span class="s2">devBase = options.devServer.config.base</span><span class="s1">;</span>
      <span class="s2">assetUrlOptions = {</span>
        <span class="s2">base: (options.devServer.config.server?.origin ?? </span><span class="s0">&quot;&quot;</span><span class="s2">) + devBase + slash(path.relative(options.root</span><span class="s1">, </span><span class="s2">path.dirname(filename)))</span>
      <span class="s2">}</span><span class="s1">;</span>
    <span class="s2">}</span>
  <span class="s2">} </span><span class="s1">else if </span><span class="s2">(transformAssetUrls !== </span><span class="s1">false</span><span class="s2">) {</span>
    <span class="s2">assetUrlOptions = {</span>
      <span class="s2">includeAbsolute: </span><span class="s1">true</span>
    <span class="s2">}</span><span class="s1">;</span>
  <span class="s2">}</span>
  <span class="s1">if </span><span class="s2">(transformAssetUrls &amp;&amp; </span><span class="s1">typeof </span><span class="s2">transformAssetUrls === </span><span class="s0">&quot;object&quot;</span><span class="s2">) {</span>
    <span class="s1">if </span><span class="s2">(Object.values(transformAssetUrls).some((val) =&gt; Array.isArray(val))) {</span>
      <span class="s2">transformAssetUrls = {</span>
        <span class="s2">...assetUrlOptions</span><span class="s1">,</span>
        <span class="s2">tags: transformAssetUrls</span>
      <span class="s2">}</span><span class="s1">;</span>
    <span class="s2">} </span><span class="s1">else </span><span class="s2">{</span>
      <span class="s2">transformAssetUrls = { ...assetUrlOptions</span><span class="s1">, </span><span class="s2">...transformAssetUrls }</span><span class="s1">;</span>
    <span class="s2">}</span>
  <span class="s2">} </span><span class="s1">else </span><span class="s2">{</span>
    <span class="s2">transformAssetUrls = assetUrlOptions</span><span class="s1">;</span>
  <span class="s2">}</span>
  <span class="s1">let </span><span class="s2">preprocessOptions = block.lang &amp;&amp; options.template?.preprocessOptions</span><span class="s1">;</span>
  <span class="s1">if </span><span class="s2">(block.lang === </span><span class="s0">&quot;pug&quot;</span><span class="s2">) {</span>
    <span class="s2">preprocessOptions = {</span>
      <span class="s2">doctype: </span><span class="s0">&quot;html&quot;</span><span class="s1">,</span>
      <span class="s2">...preprocessOptions</span>
    <span class="s2">}</span><span class="s1">;</span>
  <span class="s2">}</span>
  <span class="s1">const </span><span class="s2">expressionPlugins = options.template?.compilerOptions?.expressionPlugins || []</span><span class="s1">;</span>
  <span class="s1">const </span><span class="s2">lang = descriptor.scriptSetup?.lang || descriptor.script?.lang</span><span class="s1">;</span>
  <span class="s1">if </span><span class="s2">(lang &amp;&amp; </span><span class="s3">/tsx?$/</span><span class="s2">.test(lang) &amp;&amp; !expressionPlugins.includes(</span><span class="s0">&quot;typescript&quot;</span><span class="s2">)) {</span>
    <span class="s2">expressionPlugins.push(</span><span class="s0">&quot;typescript&quot;</span><span class="s2">)</span><span class="s1">;</span>
  <span class="s2">}</span>
  <span class="s1">return </span><span class="s2">{</span>
    <span class="s2">...options.template</span><span class="s1">,</span>
    <span class="s2">id</span><span class="s1">,</span>
    <span class="s2">filename</span><span class="s1">,</span>
    <span class="s2">scoped: hasScoped</span><span class="s1">,</span>
    <span class="s2">slotted: descriptor.slotted</span><span class="s1">,</span>
    <span class="s2">isProd: options.isProduction</span><span class="s1">,</span>
    <span class="s2">inMap: block.src ? </span><span class="s1">void </span><span class="s3">0 </span><span class="s2">: block.map</span><span class="s1">,</span>
    <span class="s2">ssr</span><span class="s1">,</span>
    <span class="s2">ssrCssVars: cssVars</span><span class="s1">,</span>
    <span class="s2">transformAssetUrls</span><span class="s1">,</span>
    <span class="s2">preprocessLang: block.lang</span><span class="s1">,</span>
    <span class="s2">preprocessOptions</span><span class="s1">,</span>
    <span class="s2">compilerOptions: {</span>
      <span class="s2">...options.template?.compilerOptions</span><span class="s1">,</span>
      <span class="s2">scopeId: hasScoped ? </span><span class="s0">`data-v-</span><span class="s2">${id}</span><span class="s0">` </span><span class="s2">: </span><span class="s1">void </span><span class="s3">0</span><span class="s1">,</span>
      <span class="s2">bindingMetadata: resolvedScript ? resolvedScript.bindings : </span><span class="s1">void </span><span class="s3">0</span><span class="s1">,</span>
      <span class="s2">expressionPlugins</span><span class="s1">,</span>
      <span class="s2">sourceMap: options.sourceMap</span>
    <span class="s2">}</span>
  <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s1">const </span><span class="s2">clientCache = </span><span class="s4">/* @__PURE__ */ </span><span class="s1">new </span><span class="s2">WeakMap()</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">ssrCache = </span><span class="s4">/* @__PURE__ */ </span><span class="s1">new </span><span class="s2">WeakMap()</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">getResolvedScript(descriptor</span><span class="s1">, </span><span class="s2">ssr) {</span>
  <span class="s1">return </span><span class="s2">(ssr ? ssrCache : clientCache).get(descriptor)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">setResolvedScript(descriptor</span><span class="s1">, </span><span class="s2">script</span><span class="s1">, </span><span class="s2">ssr) {</span>
  <span class="s2">(ssr ? ssrCache : clientCache).set(descriptor</span><span class="s1">, </span><span class="s2">script)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">isUseInlineTemplate(descriptor</span><span class="s1">, </span><span class="s2">isProd) {</span>
  <span class="s1">return </span><span class="s2">isProd &amp;&amp; !!descriptor.scriptSetup &amp;&amp; !descriptor.template?.src</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">resolveScript(descriptor</span><span class="s1">, </span><span class="s2">options</span><span class="s1">, </span><span class="s2">ssr) {</span>
  <span class="s1">if </span><span class="s2">(!descriptor.script &amp;&amp; !descriptor.scriptSetup) {</span>
    <span class="s1">return null;</span>
  <span class="s2">}</span>
  <span class="s1">const </span><span class="s2">cacheToUse = ssr ? ssrCache : clientCache</span><span class="s1">;</span>
  <span class="s1">const </span><span class="s2">cached = cacheToUse.get(descriptor)</span><span class="s1">;</span>
  <span class="s1">if </span><span class="s2">(cached) {</span>
    <span class="s1">return </span><span class="s2">cached</span><span class="s1">;</span>
  <span class="s2">}</span>
  <span class="s1">let </span><span class="s2">resolved = </span><span class="s1">null;</span>
  <span class="s2">resolved = options.compiler.compileScript(descriptor</span><span class="s1">, </span><span class="s2">{</span>
    <span class="s2">...options.script</span><span class="s1">,</span>
    <span class="s2">id: descriptor.id</span><span class="s1">,</span>
    <span class="s2">isProd: options.isProduction</span><span class="s1">,</span>
    <span class="s2">inlineTemplate: isUseInlineTemplate(descriptor</span><span class="s1">, </span><span class="s2">!options.devServer)</span><span class="s1">,</span>
    <span class="s2">reactivityTransform: options.reactivityTransform !== </span><span class="s1">false,</span>
    <span class="s2">templateOptions: resolveTemplateCompilerOptions(descriptor</span><span class="s1">, </span><span class="s2">options</span><span class="s1">, </span><span class="s2">ssr)</span><span class="s1">,</span>
    <span class="s2">sourceMap: options.sourceMap</span>
  <span class="s2">})</span><span class="s1">;</span>
  <span class="s2">cacheToUse.set(descriptor</span><span class="s1">, </span><span class="s2">resolved)</span><span class="s1">;</span>
  <span class="s1">return </span><span class="s2">resolved</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s1">const </span><span class="s2">comma = </span><span class="s0">','</span><span class="s2">.charCodeAt(</span><span class="s3">0</span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">semicolon = </span><span class="s0">';'</span><span class="s2">.charCodeAt(</span><span class="s3">0</span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">chars = </span><span class="s0">'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">intToChar = </span><span class="s1">new </span><span class="s2">Uint8Array(</span><span class="s3">64</span><span class="s2">)</span><span class="s1">; </span><span class="s4">// 64 possible chars.</span>
<span class="s1">const </span><span class="s2">charToInt = </span><span class="s1">new </span><span class="s2">Uint8Array(</span><span class="s3">128</span><span class="s2">)</span><span class="s1">; </span><span class="s4">// z is 122 in ASCII</span>
<span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s3">0</span><span class="s1">; </span><span class="s2">i &lt; chars.length</span><span class="s1">; </span><span class="s2">i++) {</span>
    <span class="s1">const </span><span class="s2">c = chars.charCodeAt(i)</span><span class="s1">;</span>
    <span class="s2">intToChar[i] = c</span><span class="s1">;</span>
    <span class="s2">charToInt[c] = i</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s4">// Provide a fallback for older environments.</span>
<span class="s1">const </span><span class="s2">td = </span><span class="s1">typeof </span><span class="s2">TextDecoder !== </span><span class="s0">'undefined'</span>
    <span class="s2">? </span><span class="s4">/* #__PURE__ */ </span><span class="s1">new </span><span class="s2">TextDecoder()</span>
    <span class="s2">: </span><span class="s1">typeof </span><span class="s2">Buffer !== </span><span class="s0">'undefined'</span>
        <span class="s2">? {</span>
            <span class="s2">decode(buf) {</span>
                <span class="s1">const </span><span class="s2">out = Buffer.from(buf.buffer</span><span class="s1">, </span><span class="s2">buf.byteOffset</span><span class="s1">, </span><span class="s2">buf.byteLength)</span><span class="s1">;</span>
                <span class="s1">return </span><span class="s2">out.toString()</span><span class="s1">;</span>
            <span class="s2">}</span><span class="s1">,</span>
        <span class="s2">}</span>
        <span class="s2">: {</span>
            <span class="s2">decode(buf) {</span>
                <span class="s1">let </span><span class="s2">out = </span><span class="s0">''</span><span class="s1">;</span>
                <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s3">0</span><span class="s1">; </span><span class="s2">i &lt; buf.length</span><span class="s1">; </span><span class="s2">i++) {</span>
                    <span class="s2">out += String.fromCharCode(buf[i])</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">return </span><span class="s2">out</span><span class="s1">;</span>
            <span class="s2">}</span><span class="s1">,</span>
        <span class="s2">}</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">decode(mappings) {</span>
    <span class="s1">const </span><span class="s2">state = </span><span class="s1">new </span><span class="s2">Int32Array(</span><span class="s3">5</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">decoded = []</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">index = </span><span class="s3">0</span><span class="s1">;</span>
    <span class="s1">do </span><span class="s2">{</span>
        <span class="s1">const </span><span class="s2">semi = indexOf(mappings</span><span class="s1">, </span><span class="s2">index)</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">line = []</span><span class="s1">;</span>
        <span class="s1">let </span><span class="s2">sorted = </span><span class="s1">true;</span>
        <span class="s1">let </span><span class="s2">lastCol = </span><span class="s3">0</span><span class="s1">;</span>
        <span class="s2">state[</span><span class="s3">0</span><span class="s2">] = </span><span class="s3">0</span><span class="s1">;</span>
        <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = index</span><span class="s1">; </span><span class="s2">i &lt; semi</span><span class="s1">; </span><span class="s2">i++) {</span>
            <span class="s1">let </span><span class="s2">seg</span><span class="s1">;</span>
            <span class="s2">i = decodeInteger(mappings</span><span class="s1">, </span><span class="s2">i</span><span class="s1">, </span><span class="s2">state</span><span class="s1">, </span><span class="s3">0</span><span class="s2">)</span><span class="s1">; </span><span class="s4">// genColumn</span>
            <span class="s1">const </span><span class="s2">col = state[</span><span class="s3">0</span><span class="s2">]</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(col &lt; lastCol)</span>
                <span class="s2">sorted = </span><span class="s1">false;</span>
            <span class="s2">lastCol = col</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(hasMoreVlq(mappings</span><span class="s1">, </span><span class="s2">i</span><span class="s1">, </span><span class="s2">semi)) {</span>
                <span class="s2">i = decodeInteger(mappings</span><span class="s1">, </span><span class="s2">i</span><span class="s1">, </span><span class="s2">state</span><span class="s1">, </span><span class="s3">1</span><span class="s2">)</span><span class="s1">; </span><span class="s4">// sourcesIndex</span>
                <span class="s2">i = decodeInteger(mappings</span><span class="s1">, </span><span class="s2">i</span><span class="s1">, </span><span class="s2">state</span><span class="s1">, </span><span class="s3">2</span><span class="s2">)</span><span class="s1">; </span><span class="s4">// sourceLine</span>
                <span class="s2">i = decodeInteger(mappings</span><span class="s1">, </span><span class="s2">i</span><span class="s1">, </span><span class="s2">state</span><span class="s1">, </span><span class="s3">3</span><span class="s2">)</span><span class="s1">; </span><span class="s4">// sourceColumn</span>
                <span class="s1">if </span><span class="s2">(hasMoreVlq(mappings</span><span class="s1">, </span><span class="s2">i</span><span class="s1">, </span><span class="s2">semi)) {</span>
                    <span class="s2">i = decodeInteger(mappings</span><span class="s1">, </span><span class="s2">i</span><span class="s1">, </span><span class="s2">state</span><span class="s1">, </span><span class="s3">4</span><span class="s2">)</span><span class="s1">; </span><span class="s4">// namesIndex</span>
                    <span class="s2">seg = [col</span><span class="s1">, </span><span class="s2">state[</span><span class="s3">1</span><span class="s2">]</span><span class="s1">, </span><span class="s2">state[</span><span class="s3">2</span><span class="s2">]</span><span class="s1">, </span><span class="s2">state[</span><span class="s3">3</span><span class="s2">]</span><span class="s1">, </span><span class="s2">state[</span><span class="s3">4</span><span class="s2">]]</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s2">seg = [col</span><span class="s1">, </span><span class="s2">state[</span><span class="s3">1</span><span class="s2">]</span><span class="s1">, </span><span class="s2">state[</span><span class="s3">2</span><span class="s2">]</span><span class="s1">, </span><span class="s2">state[</span><span class="s3">3</span><span class="s2">]]</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s2">seg = [col]</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s2">line.push(seg)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(!sorted)</span>
            <span class="s2">sort(line)</span><span class="s1">;</span>
        <span class="s2">decoded.push(line)</span><span class="s1">;</span>
        <span class="s2">index = semi + </span><span class="s3">1</span><span class="s1">;</span>
    <span class="s2">} </span><span class="s1">while </span><span class="s2">(index &lt;= mappings.length)</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">decoded</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">indexOf(mappings</span><span class="s1">, </span><span class="s2">index) {</span>
    <span class="s1">const </span><span class="s2">idx = mappings.indexOf(</span><span class="s0">';'</span><span class="s1">, </span><span class="s2">index)</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">idx === -</span><span class="s3">1 </span><span class="s2">? mappings.length : idx</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">decodeInteger(mappings</span><span class="s1">, </span><span class="s2">pos</span><span class="s1">, </span><span class="s2">state</span><span class="s1">, </span><span class="s2">j) {</span>
    <span class="s1">let </span><span class="s2">value = </span><span class="s3">0</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">shift = </span><span class="s3">0</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">integer = </span><span class="s3">0</span><span class="s1">;</span>
    <span class="s1">do </span><span class="s2">{</span>
        <span class="s1">const </span><span class="s2">c = mappings.charCodeAt(pos++)</span><span class="s1">;</span>
        <span class="s2">integer = charToInt[c]</span><span class="s1">;</span>
        <span class="s2">value |= (integer &amp; </span><span class="s3">31</span><span class="s2">) &lt;&lt; shift</span><span class="s1">;</span>
        <span class="s2">shift += </span><span class="s3">5</span><span class="s1">;</span>
    <span class="s2">} </span><span class="s1">while </span><span class="s2">(integer &amp; </span><span class="s3">32</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">shouldNegate = value &amp; </span><span class="s3">1</span><span class="s1">;</span>
    <span class="s2">value &gt;&gt;&gt;= </span><span class="s3">1</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(shouldNegate) {</span>
        <span class="s2">value = -</span><span class="s3">0x80000000 </span><span class="s2">| -value</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s2">state[j] += value</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">pos</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">hasMoreVlq(mappings</span><span class="s1">, </span><span class="s2">i</span><span class="s1">, </span><span class="s2">length) {</span>
    <span class="s1">if </span><span class="s2">(i &gt;= length)</span>
        <span class="s1">return false;</span>
    <span class="s1">return </span><span class="s2">mappings.charCodeAt(i) !== comma</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">sort(line) {</span>
    <span class="s2">line.sort(sortComparator$1)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">sortComparator$1(a</span><span class="s1">, </span><span class="s2">b) {</span>
    <span class="s1">return </span><span class="s2">a[</span><span class="s3">0</span><span class="s2">] - b[</span><span class="s3">0</span><span class="s2">]</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">encode(decoded) {</span>
    <span class="s1">const </span><span class="s2">state = </span><span class="s1">new </span><span class="s2">Int32Array(</span><span class="s3">5</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">bufLength = </span><span class="s3">1024 </span><span class="s2">* </span><span class="s3">16</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">subLength = bufLength - </span><span class="s3">36</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">buf = </span><span class="s1">new </span><span class="s2">Uint8Array(bufLength)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">sub = buf.subarray(</span><span class="s3">0</span><span class="s1">, </span><span class="s2">subLength)</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">pos = </span><span class="s3">0</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">out = </span><span class="s0">''</span><span class="s1">;</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s3">0</span><span class="s1">; </span><span class="s2">i &lt; decoded.length</span><span class="s1">; </span><span class="s2">i++) {</span>
        <span class="s1">const </span><span class="s2">line = decoded[i]</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(i &gt; </span><span class="s3">0</span><span class="s2">) {</span>
            <span class="s1">if </span><span class="s2">(pos === bufLength) {</span>
                <span class="s2">out += td.decode(buf)</span><span class="s1">;</span>
                <span class="s2">pos = </span><span class="s3">0</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s2">buf[pos++] = semicolon</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(line.length === </span><span class="s3">0</span><span class="s2">)</span>
            <span class="s1">continue;</span>
        <span class="s2">state[</span><span class="s3">0</span><span class="s2">] = </span><span class="s3">0</span><span class="s1">;</span>
        <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">j = </span><span class="s3">0</span><span class="s1">; </span><span class="s2">j &lt; line.length</span><span class="s1">; </span><span class="s2">j++) {</span>
            <span class="s1">const </span><span class="s2">segment = line[j]</span><span class="s1">;</span>
            <span class="s4">// We can push up to 5 ints, each int can take at most 7 chars, and we</span>
            <span class="s4">// may push a comma.</span>
            <span class="s1">if </span><span class="s2">(pos &gt; subLength) {</span>
                <span class="s2">out += td.decode(sub)</span><span class="s1">;</span>
                <span class="s2">buf.copyWithin(</span><span class="s3">0</span><span class="s1">, </span><span class="s2">subLength</span><span class="s1">, </span><span class="s2">pos)</span><span class="s1">;</span>
                <span class="s2">pos -= subLength</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">if </span><span class="s2">(j &gt; </span><span class="s3">0</span><span class="s2">)</span>
                <span class="s2">buf[pos++] = comma</span><span class="s1">;</span>
            <span class="s2">pos = encodeInteger(buf</span><span class="s1">, </span><span class="s2">pos</span><span class="s1">, </span><span class="s2">state</span><span class="s1">, </span><span class="s2">segment</span><span class="s1">, </span><span class="s3">0</span><span class="s2">)</span><span class="s1">; </span><span class="s4">// genColumn</span>
            <span class="s1">if </span><span class="s2">(segment.length === </span><span class="s3">1</span><span class="s2">)</span>
                <span class="s1">continue;</span>
            <span class="s2">pos = encodeInteger(buf</span><span class="s1">, </span><span class="s2">pos</span><span class="s1">, </span><span class="s2">state</span><span class="s1">, </span><span class="s2">segment</span><span class="s1">, </span><span class="s3">1</span><span class="s2">)</span><span class="s1">; </span><span class="s4">// sourcesIndex</span>
            <span class="s2">pos = encodeInteger(buf</span><span class="s1">, </span><span class="s2">pos</span><span class="s1">, </span><span class="s2">state</span><span class="s1">, </span><span class="s2">segment</span><span class="s1">, </span><span class="s3">2</span><span class="s2">)</span><span class="s1">; </span><span class="s4">// sourceLine</span>
            <span class="s2">pos = encodeInteger(buf</span><span class="s1">, </span><span class="s2">pos</span><span class="s1">, </span><span class="s2">state</span><span class="s1">, </span><span class="s2">segment</span><span class="s1">, </span><span class="s3">3</span><span class="s2">)</span><span class="s1">; </span><span class="s4">// sourceColumn</span>
            <span class="s1">if </span><span class="s2">(segment.length === </span><span class="s3">4</span><span class="s2">)</span>
                <span class="s1">continue;</span>
            <span class="s2">pos = encodeInteger(buf</span><span class="s1">, </span><span class="s2">pos</span><span class="s1">, </span><span class="s2">state</span><span class="s1">, </span><span class="s2">segment</span><span class="s1">, </span><span class="s3">4</span><span class="s2">)</span><span class="s1">; </span><span class="s4">// namesIndex</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">out + td.decode(buf.subarray(</span><span class="s3">0</span><span class="s1">, </span><span class="s2">pos))</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">encodeInteger(buf</span><span class="s1">, </span><span class="s2">pos</span><span class="s1">, </span><span class="s2">state</span><span class="s1">, </span><span class="s2">segment</span><span class="s1">, </span><span class="s2">j) {</span>
    <span class="s1">const </span><span class="s2">next = segment[j]</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">num = next - state[j]</span><span class="s1">;</span>
    <span class="s2">state[j] = next</span><span class="s1">;</span>
    <span class="s2">num = num &lt; </span><span class="s3">0 </span><span class="s2">? (-num &lt;&lt; </span><span class="s3">1</span><span class="s2">) | </span><span class="s3">1 </span><span class="s2">: num &lt;&lt; </span><span class="s3">1</span><span class="s1">;</span>
    <span class="s1">do </span><span class="s2">{</span>
        <span class="s1">let </span><span class="s2">clamped = num &amp; </span><span class="s3">0b011111</span><span class="s1">;</span>
        <span class="s2">num &gt;&gt;&gt;= </span><span class="s3">5</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(num &gt; </span><span class="s3">0</span><span class="s2">)</span>
            <span class="s2">clamped |= </span><span class="s3">0b100000</span><span class="s1">;</span>
        <span class="s2">buf[pos++] = intToChar[clamped]</span><span class="s1">;</span>
    <span class="s2">} </span><span class="s1">while </span><span class="s2">(num &gt; </span><span class="s3">0</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">pos</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s4">// Matches the scheme of a URL, eg &quot;http://&quot;</span>
<span class="s1">const </span><span class="s2">schemeRegex = </span><span class="s3">/^[\w+.-]+:\/\//</span><span class="s1">;</span>
<span class="s5">/**</span>
 <span class="s5">* Matches the parts of a URL:</span>
 <span class="s5">* 1. Scheme, including &quot;:&quot;, guaranteed.</span>
 <span class="s5">* 2. User/password, including &quot;@&quot;, optional.</span>
 <span class="s5">* 3. Host, guaranteed.</span>
 <span class="s5">* 4. Port, including &quot;:&quot;, optional.</span>
 <span class="s5">* 5. Path, including &quot;/&quot;, optional.</span>
 <span class="s5">* 6. Query, including &quot;?&quot;, optional.</span>
 <span class="s5">* 7. Hash, including &quot;#&quot;, optional.</span>
 <span class="s5">*/</span>
<span class="s1">const </span><span class="s2">urlRegex = </span><span class="s3">/^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/</span><span class="s1">;</span>
<span class="s5">/**</span>
 <span class="s5">* File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start</span>
 <span class="s5">* with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).</span>
 <span class="s5">*</span>
 <span class="s5">* 1. Host, optional.</span>
 <span class="s5">* 2. Path, which may include &quot;/&quot;, guaranteed.</span>
 <span class="s5">* 3. Query, including &quot;?&quot;, optional.</span>
 <span class="s5">* 4. Hash, including &quot;#&quot;, optional.</span>
 <span class="s5">*/</span>
<span class="s1">const </span><span class="s2">fileRegex = </span><span class="s3">/^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i</span><span class="s1">;</span>
<span class="s1">var </span><span class="s2">UrlType</span><span class="s1">;</span>
<span class="s2">(</span><span class="s1">function </span><span class="s2">(UrlType) {</span>
    <span class="s2">UrlType[UrlType[</span><span class="s0">&quot;Empty&quot;</span><span class="s2">] = </span><span class="s3">1</span><span class="s2">] = </span><span class="s0">&quot;Empty&quot;</span><span class="s1">;</span>
    <span class="s2">UrlType[UrlType[</span><span class="s0">&quot;Hash&quot;</span><span class="s2">] = </span><span class="s3">2</span><span class="s2">] = </span><span class="s0">&quot;Hash&quot;</span><span class="s1">;</span>
    <span class="s2">UrlType[UrlType[</span><span class="s0">&quot;Query&quot;</span><span class="s2">] = </span><span class="s3">3</span><span class="s2">] = </span><span class="s0">&quot;Query&quot;</span><span class="s1">;</span>
    <span class="s2">UrlType[UrlType[</span><span class="s0">&quot;RelativePath&quot;</span><span class="s2">] = </span><span class="s3">4</span><span class="s2">] = </span><span class="s0">&quot;RelativePath&quot;</span><span class="s1">;</span>
    <span class="s2">UrlType[UrlType[</span><span class="s0">&quot;AbsolutePath&quot;</span><span class="s2">] = </span><span class="s3">5</span><span class="s2">] = </span><span class="s0">&quot;AbsolutePath&quot;</span><span class="s1">;</span>
    <span class="s2">UrlType[UrlType[</span><span class="s0">&quot;SchemeRelative&quot;</span><span class="s2">] = </span><span class="s3">6</span><span class="s2">] = </span><span class="s0">&quot;SchemeRelative&quot;</span><span class="s1">;</span>
    <span class="s2">UrlType[UrlType[</span><span class="s0">&quot;Absolute&quot;</span><span class="s2">] = </span><span class="s3">7</span><span class="s2">] = </span><span class="s0">&quot;Absolute&quot;</span><span class="s1">;</span>
<span class="s2">})(UrlType || (UrlType = {}))</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">isAbsoluteUrl(input) {</span>
    <span class="s1">return </span><span class="s2">schemeRegex.test(input)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">isSchemeRelativeUrl(input) {</span>
    <span class="s1">return </span><span class="s2">input.startsWith(</span><span class="s0">'//'</span><span class="s2">)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">isAbsolutePath(input) {</span>
    <span class="s1">return </span><span class="s2">input.startsWith(</span><span class="s0">'/'</span><span class="s2">)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">isFileUrl(input) {</span>
    <span class="s1">return </span><span class="s2">input.startsWith(</span><span class="s0">'file:'</span><span class="s2">)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">isRelative(input) {</span>
    <span class="s1">return </span><span class="s3">/^[.?#]/</span><span class="s2">.test(input)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">parseAbsoluteUrl(input) {</span>
    <span class="s1">const </span><span class="s2">match = urlRegex.exec(input)</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">makeUrl(match[</span><span class="s3">1</span><span class="s2">]</span><span class="s1">, </span><span class="s2">match[</span><span class="s3">2</span><span class="s2">] || </span><span class="s0">''</span><span class="s1">, </span><span class="s2">match[</span><span class="s3">3</span><span class="s2">]</span><span class="s1">, </span><span class="s2">match[</span><span class="s3">4</span><span class="s2">] || </span><span class="s0">''</span><span class="s1">, </span><span class="s2">match[</span><span class="s3">5</span><span class="s2">] || </span><span class="s0">'/'</span><span class="s1">, </span><span class="s2">match[</span><span class="s3">6</span><span class="s2">] || </span><span class="s0">''</span><span class="s1">, </span><span class="s2">match[</span><span class="s3">7</span><span class="s2">] || </span><span class="s0">''</span><span class="s2">)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">parseFileUrl(input) {</span>
    <span class="s1">const </span><span class="s2">match = fileRegex.exec(input)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">path = match[</span><span class="s3">2</span><span class="s2">]</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">makeUrl(</span><span class="s0">'file:'</span><span class="s1">, </span><span class="s0">''</span><span class="s1">, </span><span class="s2">match[</span><span class="s3">1</span><span class="s2">] || </span><span class="s0">''</span><span class="s1">, </span><span class="s0">''</span><span class="s1">, </span><span class="s2">isAbsolutePath(path) ? path : </span><span class="s0">'/' </span><span class="s2">+ path</span><span class="s1">, </span><span class="s2">match[</span><span class="s3">3</span><span class="s2">] || </span><span class="s0">''</span><span class="s1">, </span><span class="s2">match[</span><span class="s3">4</span><span class="s2">] || </span><span class="s0">''</span><span class="s2">)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">makeUrl(scheme</span><span class="s1">, </span><span class="s2">user</span><span class="s1">, </span><span class="s2">host</span><span class="s1">, </span><span class="s2">port</span><span class="s1">, </span><span class="s2">path</span><span class="s1">, </span><span class="s2">query</span><span class="s1">, </span><span class="s2">hash) {</span>
    <span class="s1">return </span><span class="s2">{</span>
        <span class="s2">scheme</span><span class="s1">,</span>
        <span class="s2">user</span><span class="s1">,</span>
        <span class="s2">host</span><span class="s1">,</span>
        <span class="s2">port</span><span class="s1">,</span>
        <span class="s2">path</span><span class="s1">,</span>
        <span class="s2">query</span><span class="s1">,</span>
        <span class="s2">hash</span><span class="s1">,</span>
        <span class="s2">type: UrlType.Absolute</span><span class="s1">,</span>
    <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">parseUrl(input) {</span>
    <span class="s1">if </span><span class="s2">(isSchemeRelativeUrl(input)) {</span>
        <span class="s1">const </span><span class="s2">url = parseAbsoluteUrl(</span><span class="s0">'http:' </span><span class="s2">+ input)</span><span class="s1">;</span>
        <span class="s2">url.scheme = </span><span class="s0">''</span><span class="s1">;</span>
        <span class="s2">url.type = UrlType.SchemeRelative</span><span class="s1">;</span>
        <span class="s1">return </span><span class="s2">url</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(isAbsolutePath(input)) {</span>
        <span class="s1">const </span><span class="s2">url = parseAbsoluteUrl(</span><span class="s0">'http://foo.com' </span><span class="s2">+ input)</span><span class="s1">;</span>
        <span class="s2">url.scheme = </span><span class="s0">''</span><span class="s1">;</span>
        <span class="s2">url.host = </span><span class="s0">''</span><span class="s1">;</span>
        <span class="s2">url.type = UrlType.AbsolutePath</span><span class="s1">;</span>
        <span class="s1">return </span><span class="s2">url</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(isFileUrl(input))</span>
        <span class="s1">return </span><span class="s2">parseFileUrl(input)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(isAbsoluteUrl(input))</span>
        <span class="s1">return </span><span class="s2">parseAbsoluteUrl(input)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">url = parseAbsoluteUrl(</span><span class="s0">'http://foo.com/' </span><span class="s2">+ input)</span><span class="s1">;</span>
    <span class="s2">url.scheme = </span><span class="s0">''</span><span class="s1">;</span>
    <span class="s2">url.host = </span><span class="s0">''</span><span class="s1">;</span>
    <span class="s2">url.type = input</span>
        <span class="s2">? input.startsWith(</span><span class="s0">'?'</span><span class="s2">)</span>
            <span class="s2">? UrlType.Query</span>
            <span class="s2">: input.startsWith(</span><span class="s0">'#'</span><span class="s2">)</span>
                <span class="s2">? UrlType.Hash</span>
                <span class="s2">: UrlType.RelativePath</span>
        <span class="s2">: UrlType.Empty</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">url</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">stripPathFilename(path) {</span>
    <span class="s4">// If a path ends with a parent directory &quot;..&quot;, then it's a relative path with excess parent</span>
    <span class="s4">// paths. It's not a file, so we can't strip it.</span>
    <span class="s1">if </span><span class="s2">(path.endsWith(</span><span class="s0">'/..'</span><span class="s2">))</span>
        <span class="s1">return </span><span class="s2">path</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">index = path.lastIndexOf(</span><span class="s0">'/'</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">path.slice(</span><span class="s3">0</span><span class="s1">, </span><span class="s2">index + </span><span class="s3">1</span><span class="s2">)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">mergePaths(url</span><span class="s1">, </span><span class="s2">base) {</span>
    <span class="s2">normalizePath(base</span><span class="s1">, </span><span class="s2">base.type)</span><span class="s1">;</span>
    <span class="s4">// If the path is just a &quot;/&quot;, then it was an empty path to begin with (remember, we're a relative</span>
    <span class="s4">// path).</span>
    <span class="s1">if </span><span class="s2">(url.path === </span><span class="s0">'/'</span><span class="s2">) {</span>
        <span class="s2">url.path = base.path</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s4">// Resolution happens relative to the base path's directory, not the file.</span>
        <span class="s2">url.path = stripPathFilename(base.path) + url.path</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s5">/**</span>
 <span class="s5">* The path can have empty directories &quot;//&quot;, unneeded parents &quot;foo/..&quot;, or current directory</span>
 <span class="s5">* &quot;foo/.&quot;. We need to normalize to a standard representation.</span>
 <span class="s5">*/</span>
<span class="s1">function </span><span class="s2">normalizePath(url</span><span class="s1">, </span><span class="s2">type) {</span>
    <span class="s1">const </span><span class="s2">rel = type &lt;= UrlType.RelativePath</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">pieces = url.path.split(</span><span class="s0">'/'</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s4">// We need to preserve the first piece always, so that we output a leading slash. The item at</span>
    <span class="s4">// pieces[0] is an empty string.</span>
    <span class="s1">let </span><span class="s2">pointer = </span><span class="s3">1</span><span class="s1">;</span>
    <span class="s4">// Positive is the number of real directories we've output, used for popping a parent directory.</span>
    <span class="s4">// Eg, &quot;foo/bar/..&quot; will have a positive 2, and we can decrement to be left with just &quot;foo&quot;.</span>
    <span class="s1">let </span><span class="s2">positive = </span><span class="s3">0</span><span class="s1">;</span>
    <span class="s4">// We need to keep a trailing slash if we encounter an empty directory (eg, splitting &quot;foo/&quot; will</span>
    <span class="s4">// generate `[&quot;foo&quot;, &quot;&quot;]` pieces). And, if we pop a parent directory. But once we encounter a</span>
    <span class="s4">// real directory, we won't need to append, unless the other conditions happen again.</span>
    <span class="s1">let </span><span class="s2">addTrailingSlash = </span><span class="s1">false;</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s3">1</span><span class="s1">; </span><span class="s2">i &lt; pieces.length</span><span class="s1">; </span><span class="s2">i++) {</span>
        <span class="s1">const </span><span class="s2">piece = pieces[i]</span><span class="s1">;</span>
        <span class="s4">// An empty directory, could be a trailing slash, or just a double &quot;//&quot; in the path.</span>
        <span class="s1">if </span><span class="s2">(!piece) {</span>
            <span class="s2">addTrailingSlash = </span><span class="s1">true;</span>
            <span class="s1">continue;</span>
        <span class="s2">}</span>
        <span class="s4">// If we encounter a real directory, then we don't need to append anymore.</span>
        <span class="s2">addTrailingSlash = </span><span class="s1">false;</span>
        <span class="s4">// A current directory, which we can always drop.</span>
        <span class="s1">if </span><span class="s2">(piece === </span><span class="s0">'.'</span><span class="s2">)</span>
            <span class="s1">continue;</span>
        <span class="s4">// A parent directory, we need to see if there are any real directories we can pop. Else, we</span>
        <span class="s4">// have an excess of parents, and we'll need to keep the &quot;..&quot;.</span>
        <span class="s1">if </span><span class="s2">(piece === </span><span class="s0">'..'</span><span class="s2">) {</span>
            <span class="s1">if </span><span class="s2">(positive) {</span>
                <span class="s2">addTrailingSlash = </span><span class="s1">true;</span>
                <span class="s2">positive--</span><span class="s1">;</span>
                <span class="s2">pointer--</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(rel) {</span>
                <span class="s4">// If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute</span>
                <span class="s4">// URL, protocol relative URL, or an absolute path, we don't need to keep excess.</span>
                <span class="s2">pieces[pointer++] = piece</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">continue;</span>
        <span class="s2">}</span>
        <span class="s4">// We've encountered a real directory. Move it to the next insertion pointer, which accounts for</span>
        <span class="s4">// any popped or dropped directories.</span>
        <span class="s2">pieces[pointer++] = piece</span><span class="s1">;</span>
        <span class="s2">positive++</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">let </span><span class="s2">path = </span><span class="s0">''</span><span class="s1">;</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s3">1</span><span class="s1">; </span><span class="s2">i &lt; pointer</span><span class="s1">; </span><span class="s2">i++) {</span>
        <span class="s2">path += </span><span class="s0">'/' </span><span class="s2">+ pieces[i]</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(!path || (addTrailingSlash &amp;&amp; !path.endsWith(</span><span class="s0">'/..'</span><span class="s2">))) {</span>
        <span class="s2">path += </span><span class="s0">'/'</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s2">url.path = path</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s5">/**</span>
 <span class="s5">* Attempts to resolve `input` URL/path relative to `base`.</span>
 <span class="s5">*/</span>
<span class="s1">function </span><span class="s2">resolve$1(input</span><span class="s1">, </span><span class="s2">base) {</span>
    <span class="s1">if </span><span class="s2">(!input &amp;&amp; !base)</span>
        <span class="s1">return </span><span class="s0">''</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">url = parseUrl(input)</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">inputType = url.type</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(base &amp;&amp; inputType !== UrlType.Absolute) {</span>
        <span class="s1">const </span><span class="s2">baseUrl = parseUrl(base)</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">baseType = baseUrl.type</span><span class="s1">;</span>
        <span class="s1">switch </span><span class="s2">(inputType) {</span>
            <span class="s1">case </span><span class="s2">UrlType.Empty:</span>
                <span class="s2">url.hash = baseUrl.hash</span><span class="s1">;</span>
            <span class="s4">// fall through</span>
            <span class="s1">case </span><span class="s2">UrlType.Hash:</span>
                <span class="s2">url.query = baseUrl.query</span><span class="s1">;</span>
            <span class="s4">// fall through</span>
            <span class="s1">case </span><span class="s2">UrlType.Query:</span>
            <span class="s1">case </span><span class="s2">UrlType.RelativePath:</span>
                <span class="s2">mergePaths(url</span><span class="s1">, </span><span class="s2">baseUrl)</span><span class="s1">;</span>
            <span class="s4">// fall through</span>
            <span class="s1">case </span><span class="s2">UrlType.AbsolutePath:</span>
                <span class="s4">// The host, user, and port are joined, you can't copy one without the others.</span>
                <span class="s2">url.user = baseUrl.user</span><span class="s1">;</span>
                <span class="s2">url.host = baseUrl.host</span><span class="s1">;</span>
                <span class="s2">url.port = baseUrl.port</span><span class="s1">;</span>
            <span class="s4">// fall through</span>
            <span class="s1">case </span><span class="s2">UrlType.SchemeRelative:</span>
                <span class="s4">// The input doesn't have a schema at least, so we need to copy at least that over.</span>
                <span class="s2">url.scheme = baseUrl.scheme</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(baseType &gt; inputType)</span>
            <span class="s2">inputType = baseType</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s2">normalizePath(url</span><span class="s1">, </span><span class="s2">inputType)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">queryHash = url.query + url.hash</span><span class="s1">;</span>
    <span class="s1">switch </span><span class="s2">(inputType) {</span>
        <span class="s4">// This is impossible, because of the empty checks at the start of the function.</span>
        <span class="s4">// case UrlType.Empty:</span>
        <span class="s1">case </span><span class="s2">UrlType.Hash:</span>
        <span class="s1">case </span><span class="s2">UrlType.Query:</span>
            <span class="s1">return </span><span class="s2">queryHash</span><span class="s1">;</span>
        <span class="s1">case </span><span class="s2">UrlType.RelativePath: {</span>
            <span class="s4">// The first char is always a &quot;/&quot;, and we need it to be relative.</span>
            <span class="s1">const </span><span class="s2">path = url.path.slice(</span><span class="s3">1</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(!path)</span>
                <span class="s1">return </span><span class="s2">queryHash || </span><span class="s0">'.'</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(isRelative(base || input) &amp;&amp; !isRelative(path)) {</span>
                <span class="s4">// If base started with a leading &quot;.&quot;, or there is no base and input started with a &quot;.&quot;,</span>
                <span class="s4">// then we need to ensure that the relative path starts with a &quot;.&quot;. We don't know if</span>
                <span class="s4">// relative starts with a &quot;..&quot;, though, so check before prepending.</span>
                <span class="s1">return </span><span class="s0">'./' </span><span class="s2">+ path + queryHash</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">return </span><span class="s2">path + queryHash</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">case </span><span class="s2">UrlType.AbsolutePath:</span>
            <span class="s1">return </span><span class="s2">url.path + queryHash</span><span class="s1">;</span>
        <span class="s1">default</span><span class="s2">:</span>
            <span class="s1">return </span><span class="s2">url.scheme + </span><span class="s0">'//' </span><span class="s2">+ url.user + url.host + url.port + url.path + queryHash</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>

<span class="s1">function </span><span class="s2">resolve(input</span><span class="s1">, </span><span class="s2">base) {</span>
    <span class="s4">// The base is always treated as a directory, if it's not empty.</span>
    <span class="s4">// https://github.com/mozilla/source-map/blob/8cb3ee57/lib/util.js#L327</span>
    <span class="s4">// https://github.com/chromium/chromium/blob/da4adbb3/third_party/blink/renderer/devtools/front_end/sdk/SourceMap.js#L400-L401</span>
    <span class="s1">if </span><span class="s2">(base &amp;&amp; !base.endsWith(</span><span class="s0">'/'</span><span class="s2">))</span>
        <span class="s2">base += </span><span class="s0">'/'</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">resolve$1(input</span><span class="s1">, </span><span class="s2">base)</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s5">/**</span>
 <span class="s5">* Removes everything after the last &quot;/&quot;, but leaves the slash.</span>
 <span class="s5">*/</span>
<span class="s1">function </span><span class="s2">stripFilename(path) {</span>
    <span class="s1">if </span><span class="s2">(!path)</span>
        <span class="s1">return </span><span class="s0">''</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">index = path.lastIndexOf(</span><span class="s0">'/'</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">path.slice(</span><span class="s3">0</span><span class="s1">, </span><span class="s2">index + </span><span class="s3">1</span><span class="s2">)</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s1">const </span><span class="s2">COLUMN$1 = </span><span class="s3">0</span><span class="s1">;</span>

<span class="s1">function </span><span class="s2">maybeSort(mappings</span><span class="s1">, </span><span class="s2">owned) {</span>
    <span class="s1">const </span><span class="s2">unsortedIndex = nextUnsortedSegmentLine(mappings</span><span class="s1">, </span><span class="s3">0</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(unsortedIndex === mappings.length)</span>
        <span class="s1">return </span><span class="s2">mappings</span><span class="s1">;</span>
    <span class="s4">// If we own the array (meaning we parsed it from JSON), then we're free to directly mutate it. If</span>
    <span class="s4">// not, we do not want to modify the consumer's input array.</span>
    <span class="s1">if </span><span class="s2">(!owned)</span>
        <span class="s2">mappings = mappings.slice()</span><span class="s1">;</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = unsortedIndex</span><span class="s1">; </span><span class="s2">i &lt; mappings.length</span><span class="s1">; </span><span class="s2">i = nextUnsortedSegmentLine(mappings</span><span class="s1">, </span><span class="s2">i + </span><span class="s3">1</span><span class="s2">)) {</span>
        <span class="s2">mappings[i] = sortSegments(mappings[i]</span><span class="s1">, </span><span class="s2">owned)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">mappings</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">nextUnsortedSegmentLine(mappings</span><span class="s1">, </span><span class="s2">start) {</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = start</span><span class="s1">; </span><span class="s2">i &lt; mappings.length</span><span class="s1">; </span><span class="s2">i++) {</span>
        <span class="s1">if </span><span class="s2">(!isSorted(mappings[i]))</span>
            <span class="s1">return </span><span class="s2">i</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">mappings.length</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">isSorted(line) {</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">j = </span><span class="s3">1</span><span class="s1">; </span><span class="s2">j &lt; line.length</span><span class="s1">; </span><span class="s2">j++) {</span>
        <span class="s1">if </span><span class="s2">(line[j][COLUMN$1] &lt; line[j - </span><span class="s3">1</span><span class="s2">][COLUMN$1]) {</span>
            <span class="s1">return false;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">return true;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">sortSegments(line</span><span class="s1">, </span><span class="s2">owned) {</span>
    <span class="s1">if </span><span class="s2">(!owned)</span>
        <span class="s2">line = line.slice()</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">line.sort(sortComparator)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">sortComparator(a</span><span class="s1">, </span><span class="s2">b) {</span>
    <span class="s1">return </span><span class="s2">a[COLUMN$1] - b[COLUMN$1]</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">memoizedState() {</span>
    <span class="s1">return </span><span class="s2">{</span>
        <span class="s2">lastKey: -</span><span class="s3">1</span><span class="s1">,</span>
        <span class="s2">lastNeedle: -</span><span class="s3">1</span><span class="s1">,</span>
        <span class="s2">lastIndex: -</span><span class="s3">1</span><span class="s1">,</span>
    <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s5">/**</span>
 <span class="s5">* Returns the decoded (array of lines of segments) form of the SourceMap's mappings field.</span>
 <span class="s5">*/</span>
<span class="s1">let </span><span class="s2">decodedMappings</span><span class="s1">;</span>
<span class="s5">/**</span>
 <span class="s5">* Iterates each mapping in generated position order.</span>
 <span class="s5">*/</span>
<span class="s1">let </span><span class="s2">eachMapping</span><span class="s1">;</span>
<span class="s1">class </span><span class="s2">TraceMap {</span>
    <span class="s2">constructor(map</span><span class="s1">, </span><span class="s2">mapUrl) {</span>
        <span class="s1">const </span><span class="s2">isString = </span><span class="s1">typeof </span><span class="s2">map === </span><span class="s0">'string'</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(!isString &amp;&amp; map._decodedMemo)</span>
            <span class="s1">return </span><span class="s2">map</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">parsed = (isString ? JSON.parse(map) : map)</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">{ version</span><span class="s1">, </span><span class="s2">file</span><span class="s1">, </span><span class="s2">names</span><span class="s1">, </span><span class="s2">sourceRoot</span><span class="s1">, </span><span class="s2">sources</span><span class="s1">, </span><span class="s2">sourcesContent } = parsed</span><span class="s1">;</span>
        <span class="s1">this</span><span class="s2">.version = version</span><span class="s1">;</span>
        <span class="s1">this</span><span class="s2">.file = file</span><span class="s1">;</span>
        <span class="s1">this</span><span class="s2">.names = names</span><span class="s1">;</span>
        <span class="s1">this</span><span class="s2">.sourceRoot = sourceRoot</span><span class="s1">;</span>
        <span class="s1">this</span><span class="s2">.sources = sources</span><span class="s1">;</span>
        <span class="s1">this</span><span class="s2">.sourcesContent = sourcesContent</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">from = resolve(sourceRoot || </span><span class="s0">''</span><span class="s1">, </span><span class="s2">stripFilename(mapUrl))</span><span class="s1">;</span>
        <span class="s1">this</span><span class="s2">.resolvedSources = sources.map((s) =&gt; resolve(s || </span><span class="s0">''</span><span class="s1">, </span><span class="s2">from))</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">{ mappings } = parsed</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(</span><span class="s1">typeof </span><span class="s2">mappings === </span><span class="s0">'string'</span><span class="s2">) {</span>
            <span class="s1">this</span><span class="s2">._encoded = mappings</span><span class="s1">;</span>
            <span class="s1">this</span><span class="s2">._decoded = undefined</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s1">this</span><span class="s2">._encoded = undefined</span><span class="s1">;</span>
            <span class="s1">this</span><span class="s2">._decoded = maybeSort(mappings</span><span class="s1">, </span><span class="s2">isString)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">this</span><span class="s2">._decodedMemo = memoizedState()</span><span class="s1">;</span>
        <span class="s1">this</span><span class="s2">._bySources = undefined</span><span class="s1">;</span>
        <span class="s1">this</span><span class="s2">._bySourceMemos = undefined</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s2">(() =&gt; {</span>
    <span class="s2">decodedMappings = (map) =&gt; {</span>
        <span class="s1">return </span><span class="s2">(map._decoded || (map._decoded = decode(map._encoded)))</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s2">eachMapping = (map</span><span class="s1">, </span><span class="s2">cb) =&gt; {</span>
        <span class="s1">const </span><span class="s2">decoded = decodedMappings(map)</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">{ names</span><span class="s1">, </span><span class="s2">resolvedSources } = map</span><span class="s1">;</span>
        <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s3">0</span><span class="s1">; </span><span class="s2">i &lt; decoded.length</span><span class="s1">; </span><span class="s2">i++) {</span>
            <span class="s1">const </span><span class="s2">line = decoded[i]</span><span class="s1">;</span>
            <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">j = </span><span class="s3">0</span><span class="s1">; </span><span class="s2">j &lt; line.length</span><span class="s1">; </span><span class="s2">j++) {</span>
                <span class="s1">const </span><span class="s2">seg = line[j]</span><span class="s1">;</span>
                <span class="s1">const </span><span class="s2">generatedLine = i + </span><span class="s3">1</span><span class="s1">;</span>
                <span class="s1">const </span><span class="s2">generatedColumn = seg[</span><span class="s3">0</span><span class="s2">]</span><span class="s1">;</span>
                <span class="s1">let </span><span class="s2">source = </span><span class="s1">null;</span>
                <span class="s1">let </span><span class="s2">originalLine = </span><span class="s1">null;</span>
                <span class="s1">let </span><span class="s2">originalColumn = </span><span class="s1">null;</span>
                <span class="s1">let </span><span class="s2">name = </span><span class="s1">null;</span>
                <span class="s1">if </span><span class="s2">(seg.length !== </span><span class="s3">1</span><span class="s2">) {</span>
                    <span class="s2">source = resolvedSources[seg[</span><span class="s3">1</span><span class="s2">]]</span><span class="s1">;</span>
                    <span class="s2">originalLine = seg[</span><span class="s3">2</span><span class="s2">] + </span><span class="s3">1</span><span class="s1">;</span>
                    <span class="s2">originalColumn = seg[</span><span class="s3">3</span><span class="s2">]</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">if </span><span class="s2">(seg.length === </span><span class="s3">5</span><span class="s2">)</span>
                    <span class="s2">name = names[seg[</span><span class="s3">4</span><span class="s2">]]</span><span class="s1">;</span>
                <span class="s2">cb({</span>
                    <span class="s2">generatedLine</span><span class="s1">,</span>
                    <span class="s2">generatedColumn</span><span class="s1">,</span>
                    <span class="s2">source</span><span class="s1">,</span>
                    <span class="s2">originalLine</span><span class="s1">,</span>
                    <span class="s2">originalColumn</span><span class="s1">,</span>
                    <span class="s2">name</span><span class="s1">,</span>
                <span class="s2">})</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
<span class="s2">})()</span><span class="s1">;</span>

<span class="s5">/**</span>
 <span class="s5">* Gets the index associated with `key` in the backing array, if it is already present.</span>
 <span class="s5">*/</span>
<span class="s1">let </span><span class="s2">get</span><span class="s1">;</span>
<span class="s5">/**</span>
 <span class="s5">* Puts `key` into the backing array, if it is not already present. Returns</span>
 <span class="s5">* the index of the `key` in the backing array.</span>
 <span class="s5">*/</span>
<span class="s1">let </span><span class="s2">put</span><span class="s1">;</span>
<span class="s5">/**</span>
 <span class="s5">* SetArray acts like a `Set` (allowing only one occurrence of a string `key`), but provides the</span>
 <span class="s5">* index of the `key` in the backing array.</span>
 <span class="s5">*</span>
 <span class="s5">* This is designed to allow synchronizing a second array with the contents of the backing array,</span>
 <span class="s5">* like how in a sourcemap `sourcesContent[i]` is the source content associated with `source[i]`,</span>
 <span class="s5">* and there are never duplicates.</span>
 <span class="s5">*/</span>
<span class="s1">class </span><span class="s2">SetArray {</span>
    <span class="s2">constructor() {</span>
        <span class="s1">this</span><span class="s2">._indexes = { __proto__: </span><span class="s1">null </span><span class="s2">}</span><span class="s1">;</span>
        <span class="s1">this</span><span class="s2">.array = []</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s2">(() =&gt; {</span>
    <span class="s2">get = (strarr</span><span class="s1">, </span><span class="s2">key) =&gt; strarr._indexes[key]</span><span class="s1">;</span>
    <span class="s2">put = (strarr</span><span class="s1">, </span><span class="s2">key) =&gt; {</span>
        <span class="s4">// The key may or may not be present. If it is present, it's a number.</span>
        <span class="s1">const </span><span class="s2">index = get(strarr</span><span class="s1">, </span><span class="s2">key)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(index !== undefined)</span>
            <span class="s1">return </span><span class="s2">index</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">{ array</span><span class="s1">, </span><span class="s2">_indexes: indexes } = strarr</span><span class="s1">;</span>
        <span class="s1">return </span><span class="s2">(indexes[key] = array.push(key) - </span><span class="s3">1</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">;</span>
<span class="s2">})()</span><span class="s1">;</span>

<span class="s1">const </span><span class="s2">COLUMN = </span><span class="s3">0</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">SOURCES_INDEX = </span><span class="s3">1</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">SOURCE_LINE = </span><span class="s3">2</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">SOURCE_COLUMN = </span><span class="s3">3</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">NAMES_INDEX = </span><span class="s3">4</span><span class="s1">;</span>

<span class="s1">const </span><span class="s2">NO_NAME = -</span><span class="s3">1</span><span class="s1">;</span>
<span class="s5">/**</span>
 <span class="s5">* A high-level API to associate a generated position with an original source position. Line is</span>
 <span class="s5">* 1-based, but column is 0-based, due to legacy behavior in `source-map` library.</span>
 <span class="s5">*/</span>
<span class="s1">let </span><span class="s2">addMapping</span><span class="s1">;</span>
<span class="s5">/**</span>
 <span class="s5">* Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects</span>
 <span class="s5">* a sourcemap, or to JSON.stringify.</span>
 <span class="s5">*/</span>
<span class="s1">let </span><span class="s2">toDecodedMap</span><span class="s1">;</span>
<span class="s5">/**</span>
 <span class="s5">* Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects</span>
 <span class="s5">* a sourcemap, or to JSON.stringify.</span>
 <span class="s5">*/</span>
<span class="s1">let </span><span class="s2">toEncodedMap</span><span class="s1">;</span>
<span class="s5">/**</span>
 <span class="s5">* Constructs a new GenMapping, using the already present mappings of the input.</span>
 <span class="s5">*/</span>
<span class="s1">let </span><span class="s2">fromMap</span><span class="s1">;</span>
<span class="s4">// This split declaration is only so that terser can elminiate the static initialization block.</span>
<span class="s1">let </span><span class="s2">addSegmentInternal</span><span class="s1">;</span>
<span class="s5">/**</span>
 <span class="s5">* Provides the state to generate a sourcemap.</span>
 <span class="s5">*/</span>
<span class="s1">class </span><span class="s2">GenMapping {</span>
    <span class="s2">constructor({ file</span><span class="s1">, </span><span class="s2">sourceRoot } = {}) {</span>
        <span class="s1">this</span><span class="s2">._names = </span><span class="s1">new </span><span class="s2">SetArray()</span><span class="s1">;</span>
        <span class="s1">this</span><span class="s2">._sources = </span><span class="s1">new </span><span class="s2">SetArray()</span><span class="s1">;</span>
        <span class="s1">this</span><span class="s2">._sourcesContent = []</span><span class="s1">;</span>
        <span class="s1">this</span><span class="s2">._mappings = []</span><span class="s1">;</span>
        <span class="s1">this</span><span class="s2">.file = file</span><span class="s1">;</span>
        <span class="s1">this</span><span class="s2">.sourceRoot = sourceRoot</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s2">(() =&gt; {</span>
    <span class="s2">addMapping = (map</span><span class="s1">, </span><span class="s2">mapping) =&gt; {</span>
        <span class="s1">return </span><span class="s2">addMappingInternal(</span><span class="s1">false, </span><span class="s2">map</span><span class="s1">, </span><span class="s2">mapping)</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s2">toDecodedMap = (map) =&gt; {</span>
        <span class="s1">const </span><span class="s2">{ file</span><span class="s1">, </span><span class="s2">sourceRoot</span><span class="s1">, </span><span class="s2">_mappings: mappings</span><span class="s1">, </span><span class="s2">_sources: sources</span><span class="s1">, </span><span class="s2">_sourcesContent: sourcesContent</span><span class="s1">, </span><span class="s2">_names: names</span><span class="s1">, </span><span class="s2">} = map</span><span class="s1">;</span>
        <span class="s2">removeEmptyFinalLines(mappings)</span><span class="s1">;</span>
        <span class="s1">return </span><span class="s2">{</span>
            <span class="s2">version: </span><span class="s3">3</span><span class="s1">,</span>
            <span class="s2">file: file || undefined</span><span class="s1">,</span>
            <span class="s2">names: names.array</span><span class="s1">,</span>
            <span class="s2">sourceRoot: sourceRoot || undefined</span><span class="s1">,</span>
            <span class="s2">sources: sources.array</span><span class="s1">,</span>
            <span class="s2">sourcesContent</span><span class="s1">,</span>
            <span class="s2">mappings</span><span class="s1">,</span>
        <span class="s2">}</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s2">toEncodedMap = (map) =&gt; {</span>
        <span class="s1">const </span><span class="s2">decoded = toDecodedMap(map)</span><span class="s1">;</span>
        <span class="s1">return </span><span class="s2">Object.assign(Object.assign({}</span><span class="s1">, </span><span class="s2">decoded)</span><span class="s1">, </span><span class="s2">{ mappings: encode(decoded.mappings) })</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s2">fromMap = (input) =&gt; {</span>
        <span class="s1">const </span><span class="s2">map = </span><span class="s1">new </span><span class="s2">TraceMap(input)</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">gen = </span><span class="s1">new </span><span class="s2">GenMapping({ file: map.file</span><span class="s1">, </span><span class="s2">sourceRoot: map.sourceRoot })</span><span class="s1">;</span>
        <span class="s2">putAll(gen._names</span><span class="s1">, </span><span class="s2">map.names)</span><span class="s1">;</span>
        <span class="s2">putAll(gen._sources</span><span class="s1">, </span><span class="s2">map.sources)</span><span class="s1">;</span>
        <span class="s2">gen._sourcesContent = map.sourcesContent || map.sources.map(() =&gt; </span><span class="s1">null</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">gen._mappings = decodedMappings(map)</span><span class="s1">;</span>
        <span class="s1">return </span><span class="s2">gen</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s4">// Internal helpers</span>
    <span class="s2">addSegmentInternal = (skipable</span><span class="s1">, </span><span class="s2">map</span><span class="s1">, </span><span class="s2">genLine</span><span class="s1">, </span><span class="s2">genColumn</span><span class="s1">, </span><span class="s2">source</span><span class="s1">, </span><span class="s2">sourceLine</span><span class="s1">, </span><span class="s2">sourceColumn</span><span class="s1">, </span><span class="s2">name</span><span class="s1">, </span><span class="s2">content) =&gt; {</span>
        <span class="s1">const </span><span class="s2">{ _mappings: mappings</span><span class="s1">, </span><span class="s2">_sources: sources</span><span class="s1">, </span><span class="s2">_sourcesContent: sourcesContent</span><span class="s1">, </span><span class="s2">_names: names</span><span class="s1">, </span><span class="s2">} = map</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">line = getLine(mappings</span><span class="s1">, </span><span class="s2">genLine)</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">index = getColumnIndex(line</span><span class="s1">, </span><span class="s2">genColumn)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(!source) {</span>
            <span class="s1">if </span><span class="s2">(skipable &amp;&amp; skipSourceless(line</span><span class="s1">, </span><span class="s2">index))</span>
                <span class="s1">return;</span>
            <span class="s1">return </span><span class="s2">insert(line</span><span class="s1">, </span><span class="s2">index</span><span class="s1">, </span><span class="s2">[genColumn])</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">const </span><span class="s2">sourcesIndex = put(sources</span><span class="s1">, </span><span class="s2">source)</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">namesIndex = name ? put(names</span><span class="s1">, </span><span class="s2">name) : NO_NAME</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(sourcesIndex === sourcesContent.length)</span>
            <span class="s2">sourcesContent[sourcesIndex] = content !== </span><span class="s1">null </span><span class="s2">&amp;&amp; content !== </span><span class="s1">void </span><span class="s3">0 </span><span class="s2">? content : </span><span class="s1">null;</span>
        <span class="s1">if </span><span class="s2">(skipable &amp;&amp; skipSource(line</span><span class="s1">, </span><span class="s2">index</span><span class="s1">, </span><span class="s2">sourcesIndex</span><span class="s1">, </span><span class="s2">sourceLine</span><span class="s1">, </span><span class="s2">sourceColumn</span><span class="s1">, </span><span class="s2">namesIndex)) {</span>
            <span class="s1">return;</span>
        <span class="s2">}</span>
        <span class="s1">return </span><span class="s2">insert(line</span><span class="s1">, </span><span class="s2">index</span><span class="s1">, </span><span class="s2">name</span>
            <span class="s2">? [genColumn</span><span class="s1">, </span><span class="s2">sourcesIndex</span><span class="s1">, </span><span class="s2">sourceLine</span><span class="s1">, </span><span class="s2">sourceColumn</span><span class="s1">, </span><span class="s2">namesIndex]</span>
            <span class="s2">: [genColumn</span><span class="s1">, </span><span class="s2">sourcesIndex</span><span class="s1">, </span><span class="s2">sourceLine</span><span class="s1">, </span><span class="s2">sourceColumn])</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">;</span>
<span class="s2">})()</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">getLine(mappings</span><span class="s1">, </span><span class="s2">index) {</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = mappings.length</span><span class="s1">; </span><span class="s2">i &lt;= index</span><span class="s1">; </span><span class="s2">i++) {</span>
        <span class="s2">mappings[i] = []</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">mappings[index]</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">getColumnIndex(line</span><span class="s1">, </span><span class="s2">genColumn) {</span>
    <span class="s1">let </span><span class="s2">index = line.length</span><span class="s1">;</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = index - </span><span class="s3">1</span><span class="s1">; </span><span class="s2">i &gt;= </span><span class="s3">0</span><span class="s1">; </span><span class="s2">index = i--) {</span>
        <span class="s1">const </span><span class="s2">current = line[i]</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(genColumn &gt;= current[COLUMN])</span>
            <span class="s1">break;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">index</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">insert(array</span><span class="s1">, </span><span class="s2">index</span><span class="s1">, </span><span class="s2">value) {</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = array.length</span><span class="s1">; </span><span class="s2">i &gt; index</span><span class="s1">; </span><span class="s2">i--) {</span>
        <span class="s2">array[i] = array[i - </span><span class="s3">1</span><span class="s2">]</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s2">array[index] = value</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">removeEmptyFinalLines(mappings) {</span>
    <span class="s1">const </span><span class="s2">{ length } = mappings</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">len = length</span><span class="s1">;</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = len - </span><span class="s3">1</span><span class="s1">; </span><span class="s2">i &gt;= </span><span class="s3">0</span><span class="s1">; </span><span class="s2">len = i</span><span class="s1">, </span><span class="s2">i--) {</span>
        <span class="s1">if </span><span class="s2">(mappings[i].length &gt; </span><span class="s3">0</span><span class="s2">)</span>
            <span class="s1">break;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(len &lt; length)</span>
        <span class="s2">mappings.length = len</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">putAll(strarr</span><span class="s1">, </span><span class="s2">array) {</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s3">0</span><span class="s1">; </span><span class="s2">i &lt; array.length</span><span class="s1">; </span><span class="s2">i++)</span>
        <span class="s2">put(strarr</span><span class="s1">, </span><span class="s2">array[i])</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">skipSourceless(line</span><span class="s1">, </span><span class="s2">index) {</span>
    <span class="s4">// The start of a line is already sourceless, so adding a sourceless segment to the beginning</span>
    <span class="s4">// doesn't generate any useful information.</span>
    <span class="s1">if </span><span class="s2">(index === </span><span class="s3">0</span><span class="s2">)</span>
        <span class="s1">return true;</span>
    <span class="s1">const </span><span class="s2">prev = line[index - </span><span class="s3">1</span><span class="s2">]</span><span class="s1">;</span>
    <span class="s4">// If the previous segment is also sourceless, then adding another sourceless segment doesn't</span>
    <span class="s4">// genrate any new information. Else, this segment will end the source/named segment and point to</span>
    <span class="s4">// a sourceless position, which is useful.</span>
    <span class="s1">return </span><span class="s2">prev.length === </span><span class="s3">1</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">skipSource(line</span><span class="s1">, </span><span class="s2">index</span><span class="s1">, </span><span class="s2">sourcesIndex</span><span class="s1">, </span><span class="s2">sourceLine</span><span class="s1">, </span><span class="s2">sourceColumn</span><span class="s1">, </span><span class="s2">namesIndex) {</span>
    <span class="s4">// A source/named segment at the start of a line gives position at that genColumn</span>
    <span class="s1">if </span><span class="s2">(index === </span><span class="s3">0</span><span class="s2">)</span>
        <span class="s1">return false;</span>
    <span class="s1">const </span><span class="s2">prev = line[index - </span><span class="s3">1</span><span class="s2">]</span><span class="s1">;</span>
    <span class="s4">// If the previous segment is sourceless, then we're transitioning to a source.</span>
    <span class="s1">if </span><span class="s2">(prev.length === </span><span class="s3">1</span><span class="s2">)</span>
        <span class="s1">return false;</span>
    <span class="s4">// If the previous segment maps to the exact same source position, then this segment doesn't</span>
    <span class="s4">// provide any new position information.</span>
    <span class="s1">return </span><span class="s2">(sourcesIndex === prev[SOURCES_INDEX] &amp;&amp;</span>
        <span class="s2">sourceLine === prev[SOURCE_LINE] &amp;&amp;</span>
        <span class="s2">sourceColumn === prev[SOURCE_COLUMN] &amp;&amp;</span>
        <span class="s2">namesIndex === (prev.length === </span><span class="s3">5 </span><span class="s2">? prev[NAMES_INDEX] : NO_NAME))</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">addMappingInternal(skipable</span><span class="s1">, </span><span class="s2">map</span><span class="s1">, </span><span class="s2">mapping) {</span>
    <span class="s1">const </span><span class="s2">{ generated</span><span class="s1">, </span><span class="s2">source</span><span class="s1">, </span><span class="s2">original</span><span class="s1">, </span><span class="s2">name</span><span class="s1">, </span><span class="s2">content } = mapping</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(!source) {</span>
        <span class="s1">return </span><span class="s2">addSegmentInternal(skipable</span><span class="s1">, </span><span class="s2">map</span><span class="s1">, </span><span class="s2">generated.line - </span><span class="s3">1</span><span class="s1">, </span><span class="s2">generated.column</span><span class="s1">, null, null, null, null, null</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">s = source</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">addSegmentInternal(skipable</span><span class="s1">, </span><span class="s2">map</span><span class="s1">, </span><span class="s2">generated.line - </span><span class="s3">1</span><span class="s1">, </span><span class="s2">generated.column</span><span class="s1">, </span><span class="s2">s</span><span class="s1">, </span><span class="s2">original.line - </span><span class="s3">1</span><span class="s1">, </span><span class="s2">original.column</span><span class="s1">, </span><span class="s2">name</span><span class="s1">, </span><span class="s2">content)</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s1">function </span><span class="s2">getDefaultExportFromCjs (x) {</span>
	<span class="s1">return </span><span class="s2">x &amp;&amp; x.__esModule &amp;&amp; Object.prototype.hasOwnProperty.call(x</span><span class="s1">, </span><span class="s0">'default'</span><span class="s2">) ? x[</span><span class="s0">'default'</span><span class="s2">] : x</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s1">var </span><span class="s2">srcExports = {}</span><span class="s1">;</span>
<span class="s1">var </span><span class="s2">src = {</span>
  <span class="s2">get exports(){ </span><span class="s1">return </span><span class="s2">srcExports</span><span class="s1">; </span><span class="s2">}</span><span class="s1">,</span>
  <span class="s2">set exports(v){ srcExports = v</span><span class="s1">; </span><span class="s2">}</span><span class="s1">,</span>
<span class="s2">}</span><span class="s1">;</span>

<span class="s1">var </span><span class="s2">browserExports = {}</span><span class="s1">;</span>
<span class="s1">var </span><span class="s2">browser = {</span>
  <span class="s2">get exports(){ </span><span class="s1">return </span><span class="s2">browserExports</span><span class="s1">; </span><span class="s2">}</span><span class="s1">,</span>
  <span class="s2">set exports(v){ browserExports = v</span><span class="s1">; </span><span class="s2">}</span><span class="s1">,</span>
<span class="s2">}</span><span class="s1">;</span>

<span class="s5">/**</span>
 <span class="s5">* Helpers.</span>
 <span class="s5">*/</span>

<span class="s1">var </span><span class="s2">ms</span><span class="s1">;</span>
<span class="s1">var </span><span class="s2">hasRequiredMs</span><span class="s1">;</span>

<span class="s1">function </span><span class="s2">requireMs () {</span>
	<span class="s1">if </span><span class="s2">(hasRequiredMs) </span><span class="s1">return </span><span class="s2">ms</span><span class="s1">;</span>
	<span class="s2">hasRequiredMs = </span><span class="s3">1</span><span class="s1">;</span>
	<span class="s1">var </span><span class="s2">s = </span><span class="s3">1000</span><span class="s1">;</span>
	<span class="s1">var </span><span class="s2">m = s * </span><span class="s3">60</span><span class="s1">;</span>
	<span class="s1">var </span><span class="s2">h = m * </span><span class="s3">60</span><span class="s1">;</span>
	<span class="s1">var </span><span class="s2">d = h * </span><span class="s3">24</span><span class="s1">;</span>
	<span class="s1">var </span><span class="s2">w = d * </span><span class="s3">7</span><span class="s1">;</span>
	<span class="s1">var </span><span class="s2">y = d * </span><span class="s3">365.25</span><span class="s1">;</span>

	<span class="s5">/**</span>
	 <span class="s5">* Parse or format the given `val`.</span>
	 <span class="s5">*</span>
	 <span class="s5">* Options:</span>
	 <span class="s5">*</span>
	 <span class="s5">*  - `long` verbose formatting [false]</span>
	 <span class="s5">*</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{String|Number} val</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Object} [options]</span>
	 <span class="s5">* </span><span class="s6">@throws </span><span class="s5">{Error} throw an error if val is not a non-empty string or a number</span>
	 <span class="s5">* </span><span class="s6">@return </span><span class="s5">{String|Number}</span>
	 <span class="s5">* </span><span class="s6">@api </span><span class="s5">public</span>
	 <span class="s5">*/</span>

	<span class="s2">ms = </span><span class="s1">function</span><span class="s2">(val</span><span class="s1">, </span><span class="s2">options) {</span>
	  <span class="s2">options = options || {}</span><span class="s1">;</span>
	  <span class="s1">var </span><span class="s2">type = </span><span class="s1">typeof </span><span class="s2">val</span><span class="s1">;</span>
	  <span class="s1">if </span><span class="s2">(type === </span><span class="s0">'string' </span><span class="s2">&amp;&amp; val.length &gt; </span><span class="s3">0</span><span class="s2">) {</span>
	    <span class="s1">return </span><span class="s2">parse(val)</span><span class="s1">;</span>
	  <span class="s2">} </span><span class="s1">else if </span><span class="s2">(type === </span><span class="s0">'number' </span><span class="s2">&amp;&amp; isFinite(val)) {</span>
	    <span class="s1">return </span><span class="s2">options.long ? fmtLong(val) : fmtShort(val)</span><span class="s1">;</span>
	  <span class="s2">}</span>
	  <span class="s1">throw new </span><span class="s2">Error(</span>
	    <span class="s0">'val is not a non-empty string or a valid number. val=' </span><span class="s2">+</span>
	      <span class="s2">JSON.stringify(val)</span>
	  <span class="s2">)</span><span class="s1">;</span>
	<span class="s2">}</span><span class="s1">;</span>

	<span class="s5">/**</span>
	 <span class="s5">* Parse the given `str` and return milliseconds.</span>
	 <span class="s5">*</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{String} str</span>
	 <span class="s5">* </span><span class="s6">@return </span><span class="s5">{Number}</span>
	 <span class="s5">* </span><span class="s6">@api </span><span class="s5">private</span>
	 <span class="s5">*/</span>

	<span class="s1">function </span><span class="s2">parse(str) {</span>
	  <span class="s2">str = String(str)</span><span class="s1">;</span>
	  <span class="s1">if </span><span class="s2">(str.length &gt; </span><span class="s3">100</span><span class="s2">) {</span>
	    <span class="s1">return;</span>
	  <span class="s2">}</span>
	  <span class="s1">var </span><span class="s2">match = </span><span class="s3">/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i</span><span class="s2">.exec(</span>
	    <span class="s2">str</span>
	  <span class="s2">)</span><span class="s1">;</span>
	  <span class="s1">if </span><span class="s2">(!match) {</span>
	    <span class="s1">return;</span>
	  <span class="s2">}</span>
	  <span class="s1">var </span><span class="s2">n = parseFloat(match[</span><span class="s3">1</span><span class="s2">])</span><span class="s1">;</span>
	  <span class="s1">var </span><span class="s2">type = (match[</span><span class="s3">2</span><span class="s2">] || </span><span class="s0">'ms'</span><span class="s2">).toLowerCase()</span><span class="s1">;</span>
	  <span class="s1">switch </span><span class="s2">(type) {</span>
	    <span class="s1">case </span><span class="s0">'years'</span><span class="s2">:</span>
	    <span class="s1">case </span><span class="s0">'year'</span><span class="s2">:</span>
	    <span class="s1">case </span><span class="s0">'yrs'</span><span class="s2">:</span>
	    <span class="s1">case </span><span class="s0">'yr'</span><span class="s2">:</span>
	    <span class="s1">case </span><span class="s0">'y'</span><span class="s2">:</span>
	      <span class="s1">return </span><span class="s2">n * y</span><span class="s1">;</span>
	    <span class="s1">case </span><span class="s0">'weeks'</span><span class="s2">:</span>
	    <span class="s1">case </span><span class="s0">'week'</span><span class="s2">:</span>
	    <span class="s1">case </span><span class="s0">'w'</span><span class="s2">:</span>
	      <span class="s1">return </span><span class="s2">n * w</span><span class="s1">;</span>
	    <span class="s1">case </span><span class="s0">'days'</span><span class="s2">:</span>
	    <span class="s1">case </span><span class="s0">'day'</span><span class="s2">:</span>
	    <span class="s1">case </span><span class="s0">'d'</span><span class="s2">:</span>
	      <span class="s1">return </span><span class="s2">n * d</span><span class="s1">;</span>
	    <span class="s1">case </span><span class="s0">'hours'</span><span class="s2">:</span>
	    <span class="s1">case </span><span class="s0">'hour'</span><span class="s2">:</span>
	    <span class="s1">case </span><span class="s0">'hrs'</span><span class="s2">:</span>
	    <span class="s1">case </span><span class="s0">'hr'</span><span class="s2">:</span>
	    <span class="s1">case </span><span class="s0">'h'</span><span class="s2">:</span>
	      <span class="s1">return </span><span class="s2">n * h</span><span class="s1">;</span>
	    <span class="s1">case </span><span class="s0">'minutes'</span><span class="s2">:</span>
	    <span class="s1">case </span><span class="s0">'minute'</span><span class="s2">:</span>
	    <span class="s1">case </span><span class="s0">'mins'</span><span class="s2">:</span>
	    <span class="s1">case </span><span class="s0">'min'</span><span class="s2">:</span>
	    <span class="s1">case </span><span class="s0">'m'</span><span class="s2">:</span>
	      <span class="s1">return </span><span class="s2">n * m</span><span class="s1">;</span>
	    <span class="s1">case </span><span class="s0">'seconds'</span><span class="s2">:</span>
	    <span class="s1">case </span><span class="s0">'second'</span><span class="s2">:</span>
	    <span class="s1">case </span><span class="s0">'secs'</span><span class="s2">:</span>
	    <span class="s1">case </span><span class="s0">'sec'</span><span class="s2">:</span>
	    <span class="s1">case </span><span class="s0">'s'</span><span class="s2">:</span>
	      <span class="s1">return </span><span class="s2">n * s</span><span class="s1">;</span>
	    <span class="s1">case </span><span class="s0">'milliseconds'</span><span class="s2">:</span>
	    <span class="s1">case </span><span class="s0">'millisecond'</span><span class="s2">:</span>
	    <span class="s1">case </span><span class="s0">'msecs'</span><span class="s2">:</span>
	    <span class="s1">case </span><span class="s0">'msec'</span><span class="s2">:</span>
	    <span class="s1">case </span><span class="s0">'ms'</span><span class="s2">:</span>
	      <span class="s1">return </span><span class="s2">n</span><span class="s1">;</span>
	    <span class="s1">default</span><span class="s2">:</span>
	      <span class="s1">return </span><span class="s2">undefined</span><span class="s1">;</span>
	  <span class="s2">}</span>
	<span class="s2">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* Short format for `ms`.</span>
	 <span class="s5">*</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Number} ms</span>
	 <span class="s5">* </span><span class="s6">@return </span><span class="s5">{String}</span>
	 <span class="s5">* </span><span class="s6">@api </span><span class="s5">private</span>
	 <span class="s5">*/</span>

	<span class="s1">function </span><span class="s2">fmtShort(ms) {</span>
	  <span class="s1">var </span><span class="s2">msAbs = Math.abs(ms)</span><span class="s1">;</span>
	  <span class="s1">if </span><span class="s2">(msAbs &gt;= d) {</span>
	    <span class="s1">return </span><span class="s2">Math.round(ms / d) + </span><span class="s0">'d'</span><span class="s1">;</span>
	  <span class="s2">}</span>
	  <span class="s1">if </span><span class="s2">(msAbs &gt;= h) {</span>
	    <span class="s1">return </span><span class="s2">Math.round(ms / h) + </span><span class="s0">'h'</span><span class="s1">;</span>
	  <span class="s2">}</span>
	  <span class="s1">if </span><span class="s2">(msAbs &gt;= m) {</span>
	    <span class="s1">return </span><span class="s2">Math.round(ms / m) + </span><span class="s0">'m'</span><span class="s1">;</span>
	  <span class="s2">}</span>
	  <span class="s1">if </span><span class="s2">(msAbs &gt;= s) {</span>
	    <span class="s1">return </span><span class="s2">Math.round(ms / s) + </span><span class="s0">'s'</span><span class="s1">;</span>
	  <span class="s2">}</span>
	  <span class="s1">return </span><span class="s2">ms + </span><span class="s0">'ms'</span><span class="s1">;</span>
	<span class="s2">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* Long format for `ms`.</span>
	 <span class="s5">*</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Number} ms</span>
	 <span class="s5">* </span><span class="s6">@return </span><span class="s5">{String}</span>
	 <span class="s5">* </span><span class="s6">@api </span><span class="s5">private</span>
	 <span class="s5">*/</span>

	<span class="s1">function </span><span class="s2">fmtLong(ms) {</span>
	  <span class="s1">var </span><span class="s2">msAbs = Math.abs(ms)</span><span class="s1">;</span>
	  <span class="s1">if </span><span class="s2">(msAbs &gt;= d) {</span>
	    <span class="s1">return </span><span class="s2">plural(ms</span><span class="s1">, </span><span class="s2">msAbs</span><span class="s1">, </span><span class="s2">d</span><span class="s1">, </span><span class="s0">'day'</span><span class="s2">)</span><span class="s1">;</span>
	  <span class="s2">}</span>
	  <span class="s1">if </span><span class="s2">(msAbs &gt;= h) {</span>
	    <span class="s1">return </span><span class="s2">plural(ms</span><span class="s1">, </span><span class="s2">msAbs</span><span class="s1">, </span><span class="s2">h</span><span class="s1">, </span><span class="s0">'hour'</span><span class="s2">)</span><span class="s1">;</span>
	  <span class="s2">}</span>
	  <span class="s1">if </span><span class="s2">(msAbs &gt;= m) {</span>
	    <span class="s1">return </span><span class="s2">plural(ms</span><span class="s1">, </span><span class="s2">msAbs</span><span class="s1">, </span><span class="s2">m</span><span class="s1">, </span><span class="s0">'minute'</span><span class="s2">)</span><span class="s1">;</span>
	  <span class="s2">}</span>
	  <span class="s1">if </span><span class="s2">(msAbs &gt;= s) {</span>
	    <span class="s1">return </span><span class="s2">plural(ms</span><span class="s1">, </span><span class="s2">msAbs</span><span class="s1">, </span><span class="s2">s</span><span class="s1">, </span><span class="s0">'second'</span><span class="s2">)</span><span class="s1">;</span>
	  <span class="s2">}</span>
	  <span class="s1">return </span><span class="s2">ms + </span><span class="s0">' ms'</span><span class="s1">;</span>
	<span class="s2">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* Pluralization helper.</span>
	 <span class="s5">*/</span>

	<span class="s1">function </span><span class="s2">plural(ms</span><span class="s1">, </span><span class="s2">msAbs</span><span class="s1">, </span><span class="s2">n</span><span class="s1">, </span><span class="s2">name) {</span>
	  <span class="s1">var </span><span class="s2">isPlural = msAbs &gt;= n * </span><span class="s3">1.5</span><span class="s1">;</span>
	  <span class="s1">return </span><span class="s2">Math.round(ms / n) + </span><span class="s0">' ' </span><span class="s2">+ name + (isPlural ? </span><span class="s0">'s' </span><span class="s2">: </span><span class="s0">''</span><span class="s2">)</span><span class="s1">;</span>
	<span class="s2">}</span>
	<span class="s1">return </span><span class="s2">ms</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s1">var </span><span class="s2">common</span><span class="s1">;</span>
<span class="s1">var </span><span class="s2">hasRequiredCommon</span><span class="s1">;</span>

<span class="s1">function </span><span class="s2">requireCommon () {</span>
	<span class="s1">if </span><span class="s2">(hasRequiredCommon) </span><span class="s1">return </span><span class="s2">common</span><span class="s1">;</span>
	<span class="s2">hasRequiredCommon = </span><span class="s3">1</span><span class="s1">;</span>
	<span class="s5">/**</span>
	 <span class="s5">* This is the common logic for both the Node.js and web browser</span>
	 <span class="s5">* implementations of `debug()`.</span>
	 <span class="s5">*/</span>

	<span class="s1">function </span><span class="s2">setup(env) {</span>
		<span class="s2">createDebug.debug = createDebug</span><span class="s1">;</span>
		<span class="s2">createDebug.default = createDebug</span><span class="s1">;</span>
		<span class="s2">createDebug.coerce = coerce</span><span class="s1">;</span>
		<span class="s2">createDebug.disable = disable</span><span class="s1">;</span>
		<span class="s2">createDebug.enable = enable</span><span class="s1">;</span>
		<span class="s2">createDebug.enabled = enabled</span><span class="s1">;</span>
		<span class="s2">createDebug.humanize = requireMs()</span><span class="s1">;</span>
		<span class="s2">createDebug.destroy = destroy</span><span class="s1">;</span>

		<span class="s2">Object.keys(env).forEach(key =&gt; {</span>
			<span class="s2">createDebug[key] = env[key]</span><span class="s1">;</span>
		<span class="s2">})</span><span class="s1">;</span>

		<span class="s5">/**</span>
		<span class="s5">* The currently active debug mode names, and names to skip.</span>
		<span class="s5">*/</span>

		<span class="s2">createDebug.names = []</span><span class="s1">;</span>
		<span class="s2">createDebug.skips = []</span><span class="s1">;</span>

		<span class="s5">/**</span>
		<span class="s5">* Map of special &quot;%n&quot; handling functions, for the debug &quot;format&quot; argument.</span>
		<span class="s5">*</span>
		<span class="s5">* Valid key names are a single, lower or upper-case letter, i.e. &quot;n&quot; and &quot;N&quot;.</span>
		<span class="s5">*/</span>
		<span class="s2">createDebug.formatters = {}</span><span class="s1">;</span>

		<span class="s5">/**</span>
		<span class="s5">* Selects a color for a debug namespace</span>
		<span class="s5">* </span><span class="s6">@param </span><span class="s5">{String} namespace The namespace string for the debug instance to be colored</span>
		<span class="s5">* </span><span class="s6">@return </span><span class="s5">{Number|String} An ANSI color code for the given namespace</span>
		<span class="s5">* </span><span class="s6">@api </span><span class="s5">private</span>
		<span class="s5">*/</span>
		<span class="s1">function </span><span class="s2">selectColor(namespace) {</span>
			<span class="s1">let </span><span class="s2">hash = </span><span class="s3">0</span><span class="s1">;</span>

			<span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s3">0</span><span class="s1">; </span><span class="s2">i &lt; namespace.length</span><span class="s1">; </span><span class="s2">i++) {</span>
				<span class="s2">hash = ((hash &lt;&lt; </span><span class="s3">5</span><span class="s2">) - hash) + namespace.charCodeAt(i)</span><span class="s1">;</span>
				<span class="s2">hash |= </span><span class="s3">0</span><span class="s1">; </span><span class="s4">// Convert to 32bit integer</span>
			<span class="s2">}</span>

			<span class="s1">return </span><span class="s2">createDebug.colors[Math.abs(hash) % createDebug.colors.length]</span><span class="s1">;</span>
		<span class="s2">}</span>
		<span class="s2">createDebug.selectColor = selectColor</span><span class="s1">;</span>

		<span class="s5">/**</span>
		<span class="s5">* Create a debugger with the given `namespace`.</span>
		<span class="s5">*</span>
		<span class="s5">* </span><span class="s6">@param </span><span class="s5">{String} namespace</span>
		<span class="s5">* </span><span class="s6">@return </span><span class="s5">{Function}</span>
		<span class="s5">* </span><span class="s6">@api </span><span class="s5">public</span>
		<span class="s5">*/</span>
		<span class="s1">function </span><span class="s2">createDebug(namespace) {</span>
			<span class="s1">let </span><span class="s2">prevTime</span><span class="s1">;</span>
			<span class="s1">let </span><span class="s2">enableOverride = </span><span class="s1">null;</span>
			<span class="s1">let </span><span class="s2">namespacesCache</span><span class="s1">;</span>
			<span class="s1">let </span><span class="s2">enabledCache</span><span class="s1">;</span>

			<span class="s1">function </span><span class="s2">debug(...args) {</span>
				<span class="s4">// Disabled?</span>
				<span class="s1">if </span><span class="s2">(!debug.enabled) {</span>
					<span class="s1">return;</span>
				<span class="s2">}</span>

				<span class="s1">const </span><span class="s2">self = debug</span><span class="s1">;</span>

				<span class="s4">// Set `diff` timestamp</span>
				<span class="s1">const </span><span class="s2">curr = Number(</span><span class="s1">new </span><span class="s2">Date())</span><span class="s1">;</span>
				<span class="s1">const </span><span class="s2">ms = curr - (prevTime || curr)</span><span class="s1">;</span>
				<span class="s2">self.diff = ms</span><span class="s1">;</span>
				<span class="s2">self.prev = prevTime</span><span class="s1">;</span>
				<span class="s2">self.curr = curr</span><span class="s1">;</span>
				<span class="s2">prevTime = curr</span><span class="s1">;</span>

				<span class="s2">args[</span><span class="s3">0</span><span class="s2">] = createDebug.coerce(args[</span><span class="s3">0</span><span class="s2">])</span><span class="s1">;</span>

				<span class="s1">if </span><span class="s2">(</span><span class="s1">typeof </span><span class="s2">args[</span><span class="s3">0</span><span class="s2">] !== </span><span class="s0">'string'</span><span class="s2">) {</span>
					<span class="s4">// Anything else let's inspect with %O</span>
					<span class="s2">args.unshift(</span><span class="s0">'%O'</span><span class="s2">)</span><span class="s1">;</span>
				<span class="s2">}</span>

				<span class="s4">// Apply any `formatters` transformations</span>
				<span class="s1">let </span><span class="s2">index = </span><span class="s3">0</span><span class="s1">;</span>
				<span class="s2">args[</span><span class="s3">0</span><span class="s2">] = args[</span><span class="s3">0</span><span class="s2">].replace(</span><span class="s3">/%([a-zA-Z%])/g</span><span class="s1">, </span><span class="s2">(match</span><span class="s1">, </span><span class="s2">format) =&gt; {</span>
					<span class="s4">// If we encounter an escaped % then don't increase the array index</span>
					<span class="s1">if </span><span class="s2">(match === </span><span class="s0">'%%'</span><span class="s2">) {</span>
						<span class="s1">return </span><span class="s0">'%'</span><span class="s1">;</span>
					<span class="s2">}</span>
					<span class="s2">index++</span><span class="s1">;</span>
					<span class="s1">const </span><span class="s2">formatter = createDebug.formatters[format]</span><span class="s1">;</span>
					<span class="s1">if </span><span class="s2">(</span><span class="s1">typeof </span><span class="s2">formatter === </span><span class="s0">'function'</span><span class="s2">) {</span>
						<span class="s1">const </span><span class="s2">val = args[index]</span><span class="s1">;</span>
						<span class="s2">match = formatter.call(self</span><span class="s1">, </span><span class="s2">val)</span><span class="s1">;</span>

						<span class="s4">// Now we need to remove `args[index]` since it's inlined in the `format`</span>
						<span class="s2">args.splice(index</span><span class="s1">, </span><span class="s3">1</span><span class="s2">)</span><span class="s1">;</span>
						<span class="s2">index--</span><span class="s1">;</span>
					<span class="s2">}</span>
					<span class="s1">return </span><span class="s2">match</span><span class="s1">;</span>
				<span class="s2">})</span><span class="s1">;</span>

				<span class="s4">// Apply env-specific formatting (colors, etc.)</span>
				<span class="s2">createDebug.formatArgs.call(self</span><span class="s1">, </span><span class="s2">args)</span><span class="s1">;</span>

				<span class="s1">const </span><span class="s2">logFn = self.log || createDebug.log</span><span class="s1">;</span>
				<span class="s2">logFn.apply(self</span><span class="s1">, </span><span class="s2">args)</span><span class="s1">;</span>
			<span class="s2">}</span>

			<span class="s2">debug.namespace = namespace</span><span class="s1">;</span>
			<span class="s2">debug.useColors = createDebug.useColors()</span><span class="s1">;</span>
			<span class="s2">debug.color = createDebug.selectColor(namespace)</span><span class="s1">;</span>
			<span class="s2">debug.extend = extend</span><span class="s1">;</span>
			<span class="s2">debug.destroy = createDebug.destroy</span><span class="s1">; </span><span class="s4">// XXX Temporary. Will be removed in the next major release.</span>

			<span class="s2">Object.defineProperty(debug</span><span class="s1">, </span><span class="s0">'enabled'</span><span class="s1">, </span><span class="s2">{</span>
				<span class="s2">enumerable: </span><span class="s1">true,</span>
				<span class="s2">configurable: </span><span class="s1">false,</span>
				<span class="s2">get: () =&gt; {</span>
					<span class="s1">if </span><span class="s2">(enableOverride !== </span><span class="s1">null</span><span class="s2">) {</span>
						<span class="s1">return </span><span class="s2">enableOverride</span><span class="s1">;</span>
					<span class="s2">}</span>
					<span class="s1">if </span><span class="s2">(namespacesCache !== createDebug.namespaces) {</span>
						<span class="s2">namespacesCache = createDebug.namespaces</span><span class="s1">;</span>
						<span class="s2">enabledCache = createDebug.enabled(namespace)</span><span class="s1">;</span>
					<span class="s2">}</span>

					<span class="s1">return </span><span class="s2">enabledCache</span><span class="s1">;</span>
				<span class="s2">}</span><span class="s1">,</span>
				<span class="s2">set: v =&gt; {</span>
					<span class="s2">enableOverride = v</span><span class="s1">;</span>
				<span class="s2">}</span>
			<span class="s2">})</span><span class="s1">;</span>

			<span class="s4">// Env-specific initialization logic for debug instances</span>
			<span class="s1">if </span><span class="s2">(</span><span class="s1">typeof </span><span class="s2">createDebug.init === </span><span class="s0">'function'</span><span class="s2">) {</span>
				<span class="s2">createDebug.init(debug)</span><span class="s1">;</span>
			<span class="s2">}</span>

			<span class="s1">return </span><span class="s2">debug</span><span class="s1">;</span>
		<span class="s2">}</span>

		<span class="s1">function </span><span class="s2">extend(namespace</span><span class="s1">, </span><span class="s2">delimiter) {</span>
			<span class="s1">const </span><span class="s2">newDebug = createDebug(</span><span class="s1">this</span><span class="s2">.namespace + (</span><span class="s1">typeof </span><span class="s2">delimiter === </span><span class="s0">'undefined' </span><span class="s2">? </span><span class="s0">':' </span><span class="s2">: delimiter) + namespace)</span><span class="s1">;</span>
			<span class="s2">newDebug.log = </span><span class="s1">this</span><span class="s2">.log</span><span class="s1">;</span>
			<span class="s1">return </span><span class="s2">newDebug</span><span class="s1">;</span>
		<span class="s2">}</span>

		<span class="s5">/**</span>
		<span class="s5">* Enables a debug mode by namespaces. This can include modes</span>
		<span class="s5">* separated by a colon and wildcards.</span>
		<span class="s5">*</span>
		<span class="s5">* </span><span class="s6">@param </span><span class="s5">{String} namespaces</span>
		<span class="s5">* </span><span class="s6">@api </span><span class="s5">public</span>
		<span class="s5">*/</span>
		<span class="s1">function </span><span class="s2">enable(namespaces) {</span>
			<span class="s2">createDebug.save(namespaces)</span><span class="s1">;</span>
			<span class="s2">createDebug.namespaces = namespaces</span><span class="s1">;</span>

			<span class="s2">createDebug.names = []</span><span class="s1">;</span>
			<span class="s2">createDebug.skips = []</span><span class="s1">;</span>

			<span class="s1">let </span><span class="s2">i</span><span class="s1">;</span>
			<span class="s1">const </span><span class="s2">split = (</span><span class="s1">typeof </span><span class="s2">namespaces === </span><span class="s0">'string' </span><span class="s2">? namespaces : </span><span class="s0">''</span><span class="s2">).split(</span><span class="s3">/[\s,]+/</span><span class="s2">)</span><span class="s1">;</span>
			<span class="s1">const </span><span class="s2">len = split.length</span><span class="s1">;</span>

			<span class="s1">for </span><span class="s2">(i = </span><span class="s3">0</span><span class="s1">; </span><span class="s2">i &lt; len</span><span class="s1">; </span><span class="s2">i++) {</span>
				<span class="s1">if </span><span class="s2">(!split[i]) {</span>
					<span class="s4">// ignore empty strings</span>
					<span class="s1">continue;</span>
				<span class="s2">}</span>

				<span class="s2">namespaces = split[i].replace(</span><span class="s3">/\*/g</span><span class="s1">, </span><span class="s0">'.*?'</span><span class="s2">)</span><span class="s1">;</span>

				<span class="s1">if </span><span class="s2">(namespaces[</span><span class="s3">0</span><span class="s2">] === </span><span class="s0">'-'</span><span class="s2">) {</span>
					<span class="s2">createDebug.skips.push(</span><span class="s1">new </span><span class="s2">RegExp(</span><span class="s0">'^' </span><span class="s2">+ namespaces.slice(</span><span class="s3">1</span><span class="s2">) + </span><span class="s0">'$'</span><span class="s2">))</span><span class="s1">;</span>
				<span class="s2">} </span><span class="s1">else </span><span class="s2">{</span>
					<span class="s2">createDebug.names.push(</span><span class="s1">new </span><span class="s2">RegExp(</span><span class="s0">'^' </span><span class="s2">+ namespaces + </span><span class="s0">'$'</span><span class="s2">))</span><span class="s1">;</span>
				<span class="s2">}</span>
			<span class="s2">}</span>
		<span class="s2">}</span>

		<span class="s5">/**</span>
		<span class="s5">* Disable debug output.</span>
		<span class="s5">*</span>
		<span class="s5">* </span><span class="s6">@return </span><span class="s5">{String} namespaces</span>
		<span class="s5">* </span><span class="s6">@api </span><span class="s5">public</span>
		<span class="s5">*/</span>
		<span class="s1">function </span><span class="s2">disable() {</span>
			<span class="s1">const </span><span class="s2">namespaces = [</span>
				<span class="s2">...createDebug.names.map(toNamespace)</span><span class="s1">,</span>
				<span class="s2">...createDebug.skips.map(toNamespace).map(namespace =&gt; </span><span class="s0">'-' </span><span class="s2">+ namespace)</span>
			<span class="s2">].join(</span><span class="s0">','</span><span class="s2">)</span><span class="s1">;</span>
			<span class="s2">createDebug.enable(</span><span class="s0">''</span><span class="s2">)</span><span class="s1">;</span>
			<span class="s1">return </span><span class="s2">namespaces</span><span class="s1">;</span>
		<span class="s2">}</span>

		<span class="s5">/**</span>
		<span class="s5">* Returns true if the given mode name is enabled, false otherwise.</span>
		<span class="s5">*</span>
		<span class="s5">* </span><span class="s6">@param </span><span class="s5">{String} name</span>
		<span class="s5">* </span><span class="s6">@return </span><span class="s5">{Boolean}</span>
		<span class="s5">* </span><span class="s6">@api </span><span class="s5">public</span>
		<span class="s5">*/</span>
		<span class="s1">function </span><span class="s2">enabled(name) {</span>
			<span class="s1">if </span><span class="s2">(name[name.length - </span><span class="s3">1</span><span class="s2">] === </span><span class="s0">'*'</span><span class="s2">) {</span>
				<span class="s1">return true;</span>
			<span class="s2">}</span>

			<span class="s1">let </span><span class="s2">i</span><span class="s1">;</span>
			<span class="s1">let </span><span class="s2">len</span><span class="s1">;</span>

			<span class="s1">for </span><span class="s2">(i = </span><span class="s3">0</span><span class="s1">, </span><span class="s2">len = createDebug.skips.length</span><span class="s1">; </span><span class="s2">i &lt; len</span><span class="s1">; </span><span class="s2">i++) {</span>
				<span class="s1">if </span><span class="s2">(createDebug.skips[i].test(name)) {</span>
					<span class="s1">return false;</span>
				<span class="s2">}</span>
			<span class="s2">}</span>

			<span class="s1">for </span><span class="s2">(i = </span><span class="s3">0</span><span class="s1">, </span><span class="s2">len = createDebug.names.length</span><span class="s1">; </span><span class="s2">i &lt; len</span><span class="s1">; </span><span class="s2">i++) {</span>
				<span class="s1">if </span><span class="s2">(createDebug.names[i].test(name)) {</span>
					<span class="s1">return true;</span>
				<span class="s2">}</span>
			<span class="s2">}</span>

			<span class="s1">return false;</span>
		<span class="s2">}</span>

		<span class="s5">/**</span>
		<span class="s5">* Convert regexp to namespace</span>
		<span class="s5">*</span>
		<span class="s5">* </span><span class="s6">@param </span><span class="s5">{RegExp} regxep</span>
		<span class="s5">* </span><span class="s6">@return </span><span class="s5">{String} namespace</span>
		<span class="s5">* </span><span class="s6">@api </span><span class="s5">private</span>
		<span class="s5">*/</span>
		<span class="s1">function </span><span class="s2">toNamespace(regexp) {</span>
			<span class="s1">return </span><span class="s2">regexp.toString()</span>
				<span class="s2">.substring(</span><span class="s3">2</span><span class="s1">, </span><span class="s2">regexp.toString().length - </span><span class="s3">2</span><span class="s2">)</span>
				<span class="s2">.replace(</span><span class="s3">/\.\*\?$/</span><span class="s1">, </span><span class="s0">'*'</span><span class="s2">)</span><span class="s1">;</span>
		<span class="s2">}</span>

		<span class="s5">/**</span>
		<span class="s5">* Coerce `val`.</span>
		<span class="s5">*</span>
		<span class="s5">* </span><span class="s6">@param </span><span class="s5">{Mixed} val</span>
		<span class="s5">* </span><span class="s6">@return </span><span class="s5">{Mixed}</span>
		<span class="s5">* </span><span class="s6">@api </span><span class="s5">private</span>
		<span class="s5">*/</span>
		<span class="s1">function </span><span class="s2">coerce(val) {</span>
			<span class="s1">if </span><span class="s2">(val </span><span class="s1">instanceof </span><span class="s2">Error) {</span>
				<span class="s1">return </span><span class="s2">val.stack || val.message</span><span class="s1">;</span>
			<span class="s2">}</span>
			<span class="s1">return </span><span class="s2">val</span><span class="s1">;</span>
		<span class="s2">}</span>

		<span class="s5">/**</span>
		<span class="s5">* XXX DO NOT USE. This is a temporary stub function.</span>
		<span class="s5">* XXX It WILL be removed in the next major release.</span>
		<span class="s5">*/</span>
		<span class="s1">function </span><span class="s2">destroy() {</span>
			<span class="s2">console.warn(</span><span class="s0">'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'</span><span class="s2">)</span><span class="s1">;</span>
		<span class="s2">}</span>

		<span class="s2">createDebug.enable(createDebug.load())</span><span class="s1">;</span>

		<span class="s1">return </span><span class="s2">createDebug</span><span class="s1">;</span>
	<span class="s2">}</span>

	<span class="s2">common = setup</span><span class="s1">;</span>
	<span class="s1">return </span><span class="s2">common</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s4">/* eslint-env browser */</span>

<span class="s1">var </span><span class="s2">hasRequiredBrowser</span><span class="s1">;</span>

<span class="s1">function </span><span class="s2">requireBrowser () {</span>
	<span class="s1">if </span><span class="s2">(hasRequiredBrowser) </span><span class="s1">return </span><span class="s2">browserExports</span><span class="s1">;</span>
	<span class="s2">hasRequiredBrowser = </span><span class="s3">1</span><span class="s1">;</span>
	<span class="s2">(</span><span class="s1">function </span><span class="s2">(module</span><span class="s1">, </span><span class="s2">exports) {</span>
		<span class="s5">/**</span>
		 <span class="s5">* This is the web browser implementation of `debug()`.</span>
		 <span class="s5">*/</span>

		<span class="s2">exports.formatArgs = formatArgs</span><span class="s1">;</span>
		<span class="s2">exports.save = save</span><span class="s1">;</span>
		<span class="s2">exports.load = load</span><span class="s1">;</span>
		<span class="s2">exports.useColors = useColors</span><span class="s1">;</span>
		<span class="s2">exports.storage = localstorage()</span><span class="s1">;</span>
		<span class="s2">exports.destroy = (() =&gt; {</span>
			<span class="s1">let </span><span class="s2">warned = </span><span class="s1">false;</span>

			<span class="s1">return </span><span class="s2">() =&gt; {</span>
				<span class="s1">if </span><span class="s2">(!warned) {</span>
					<span class="s2">warned = </span><span class="s1">true;</span>
					<span class="s2">console.warn(</span><span class="s0">'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'</span><span class="s2">)</span><span class="s1">;</span>
				<span class="s2">}</span>
			<span class="s2">}</span><span class="s1">;</span>
		<span class="s2">})()</span><span class="s1">;</span>

		<span class="s5">/**</span>
		 <span class="s5">* Colors.</span>
		 <span class="s5">*/</span>

		<span class="s2">exports.colors = [</span>
			<span class="s0">'#0000CC'</span><span class="s1">,</span>
			<span class="s0">'#0000FF'</span><span class="s1">,</span>
			<span class="s0">'#0033CC'</span><span class="s1">,</span>
			<span class="s0">'#0033FF'</span><span class="s1">,</span>
			<span class="s0">'#0066CC'</span><span class="s1">,</span>
			<span class="s0">'#0066FF'</span><span class="s1">,</span>
			<span class="s0">'#0099CC'</span><span class="s1">,</span>
			<span class="s0">'#0099FF'</span><span class="s1">,</span>
			<span class="s0">'#00CC00'</span><span class="s1">,</span>
			<span class="s0">'#00CC33'</span><span class="s1">,</span>
			<span class="s0">'#00CC66'</span><span class="s1">,</span>
			<span class="s0">'#00CC99'</span><span class="s1">,</span>
			<span class="s0">'#00CCCC'</span><span class="s1">,</span>
			<span class="s0">'#00CCFF'</span><span class="s1">,</span>
			<span class="s0">'#3300CC'</span><span class="s1">,</span>
			<span class="s0">'#3300FF'</span><span class="s1">,</span>
			<span class="s0">'#3333CC'</span><span class="s1">,</span>
			<span class="s0">'#3333FF'</span><span class="s1">,</span>
			<span class="s0">'#3366CC'</span><span class="s1">,</span>
			<span class="s0">'#3366FF'</span><span class="s1">,</span>
			<span class="s0">'#3399CC'</span><span class="s1">,</span>
			<span class="s0">'#3399FF'</span><span class="s1">,</span>
			<span class="s0">'#33CC00'</span><span class="s1">,</span>
			<span class="s0">'#33CC33'</span><span class="s1">,</span>
			<span class="s0">'#33CC66'</span><span class="s1">,</span>
			<span class="s0">'#33CC99'</span><span class="s1">,</span>
			<span class="s0">'#33CCCC'</span><span class="s1">,</span>
			<span class="s0">'#33CCFF'</span><span class="s1">,</span>
			<span class="s0">'#6600CC'</span><span class="s1">,</span>
			<span class="s0">'#6600FF'</span><span class="s1">,</span>
			<span class="s0">'#6633CC'</span><span class="s1">,</span>
			<span class="s0">'#6633FF'</span><span class="s1">,</span>
			<span class="s0">'#66CC00'</span><span class="s1">,</span>
			<span class="s0">'#66CC33'</span><span class="s1">,</span>
			<span class="s0">'#9900CC'</span><span class="s1">,</span>
			<span class="s0">'#9900FF'</span><span class="s1">,</span>
			<span class="s0">'#9933CC'</span><span class="s1">,</span>
			<span class="s0">'#9933FF'</span><span class="s1">,</span>
			<span class="s0">'#99CC00'</span><span class="s1">,</span>
			<span class="s0">'#99CC33'</span><span class="s1">,</span>
			<span class="s0">'#CC0000'</span><span class="s1">,</span>
			<span class="s0">'#CC0033'</span><span class="s1">,</span>
			<span class="s0">'#CC0066'</span><span class="s1">,</span>
			<span class="s0">'#CC0099'</span><span class="s1">,</span>
			<span class="s0">'#CC00CC'</span><span class="s1">,</span>
			<span class="s0">'#CC00FF'</span><span class="s1">,</span>
			<span class="s0">'#CC3300'</span><span class="s1">,</span>
			<span class="s0">'#CC3333'</span><span class="s1">,</span>
			<span class="s0">'#CC3366'</span><span class="s1">,</span>
			<span class="s0">'#CC3399'</span><span class="s1">,</span>
			<span class="s0">'#CC33CC'</span><span class="s1">,</span>
			<span class="s0">'#CC33FF'</span><span class="s1">,</span>
			<span class="s0">'#CC6600'</span><span class="s1">,</span>
			<span class="s0">'#CC6633'</span><span class="s1">,</span>
			<span class="s0">'#CC9900'</span><span class="s1">,</span>
			<span class="s0">'#CC9933'</span><span class="s1">,</span>
			<span class="s0">'#CCCC00'</span><span class="s1">,</span>
			<span class="s0">'#CCCC33'</span><span class="s1">,</span>
			<span class="s0">'#FF0000'</span><span class="s1">,</span>
			<span class="s0">'#FF0033'</span><span class="s1">,</span>
			<span class="s0">'#FF0066'</span><span class="s1">,</span>
			<span class="s0">'#FF0099'</span><span class="s1">,</span>
			<span class="s0">'#FF00CC'</span><span class="s1">,</span>
			<span class="s0">'#FF00FF'</span><span class="s1">,</span>
			<span class="s0">'#FF3300'</span><span class="s1">,</span>
			<span class="s0">'#FF3333'</span><span class="s1">,</span>
			<span class="s0">'#FF3366'</span><span class="s1">,</span>
			<span class="s0">'#FF3399'</span><span class="s1">,</span>
			<span class="s0">'#FF33CC'</span><span class="s1">,</span>
			<span class="s0">'#FF33FF'</span><span class="s1">,</span>
			<span class="s0">'#FF6600'</span><span class="s1">,</span>
			<span class="s0">'#FF6633'</span><span class="s1">,</span>
			<span class="s0">'#FF9900'</span><span class="s1">,</span>
			<span class="s0">'#FF9933'</span><span class="s1">,</span>
			<span class="s0">'#FFCC00'</span><span class="s1">,</span>
			<span class="s0">'#FFCC33'</span>
		<span class="s2">]</span><span class="s1">;</span>

		<span class="s5">/**</span>
		 <span class="s5">* Currently only WebKit-based Web Inspectors, Firefox &gt;= v31,</span>
		 <span class="s5">* and the Firebug extension (any Firefox version) are known</span>
		 <span class="s5">* to support &quot;%c&quot; CSS customizations.</span>
		 <span class="s5">*</span>
		 <span class="s5">* TODO: add a `localStorage` variable to explicitly enable/disable colors</span>
		 <span class="s5">*/</span>

		<span class="s4">// eslint-disable-next-line complexity</span>
		<span class="s1">function </span><span class="s2">useColors() {</span>
			<span class="s4">// NB: In an Electron preload script, document will be defined but not fully</span>
			<span class="s4">// initialized. Since we know we're in Chrome, we'll just detect this case</span>
			<span class="s4">// explicitly</span>
			<span class="s1">if </span><span class="s2">(</span><span class="s1">typeof </span><span class="s2">window !== </span><span class="s0">'undefined' </span><span class="s2">&amp;&amp; window.process &amp;&amp; (window.process.type === </span><span class="s0">'renderer' </span><span class="s2">|| window.process.__nwjs)) {</span>
				<span class="s1">return true;</span>
			<span class="s2">}</span>

			<span class="s4">// Internet Explorer and Edge do not support colors.</span>
			<span class="s1">if </span><span class="s2">(</span><span class="s1">typeof </span><span class="s2">navigator !== </span><span class="s0">'undefined' </span><span class="s2">&amp;&amp; navigator.userAgent &amp;&amp; navigator.userAgent.toLowerCase().match(</span><span class="s3">/(edge|trident)\/(\d+)/</span><span class="s2">)) {</span>
				<span class="s1">return false;</span>
			<span class="s2">}</span>

			<span class="s4">// Is webkit? http://stackoverflow.com/a/16459606/376773</span>
			<span class="s4">// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632</span>
			<span class="s1">return </span><span class="s2">(</span><span class="s1">typeof </span><span class="s2">document !== </span><span class="s0">'undefined' </span><span class="s2">&amp;&amp; document.documentElement &amp;&amp; document.documentElement.style &amp;&amp; document.documentElement.style.WebkitAppearance) ||</span>
				<span class="s4">// Is firebug? http://stackoverflow.com/a/398120/376773</span>
				<span class="s2">(</span><span class="s1">typeof </span><span class="s2">window !== </span><span class="s0">'undefined' </span><span class="s2">&amp;&amp; window.console &amp;&amp; (window.console.firebug || (window.console.exception &amp;&amp; window.console.table))) ||</span>
				<span class="s4">// Is firefox &gt;= v31?</span>
				<span class="s4">// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages</span>
				<span class="s2">(</span><span class="s1">typeof </span><span class="s2">navigator !== </span><span class="s0">'undefined' </span><span class="s2">&amp;&amp; navigator.userAgent &amp;&amp; navigator.userAgent.toLowerCase().match(</span><span class="s3">/firefox\/(\d+)/</span><span class="s2">) &amp;&amp; parseInt(RegExp.$1</span><span class="s1">, </span><span class="s3">10</span><span class="s2">) &gt;= </span><span class="s3">31</span><span class="s2">) ||</span>
				<span class="s4">// Double check webkit in userAgent just in case we are in a worker</span>
				<span class="s2">(</span><span class="s1">typeof </span><span class="s2">navigator !== </span><span class="s0">'undefined' </span><span class="s2">&amp;&amp; navigator.userAgent &amp;&amp; navigator.userAgent.toLowerCase().match(</span><span class="s3">/applewebkit\/(\d+)/</span><span class="s2">))</span><span class="s1">;</span>
		<span class="s2">}</span>

		<span class="s5">/**</span>
		 <span class="s5">* Colorize log arguments if enabled.</span>
		 <span class="s5">*</span>
		 <span class="s5">* </span><span class="s6">@api </span><span class="s5">public</span>
		 <span class="s5">*/</span>

		<span class="s1">function </span><span class="s2">formatArgs(args) {</span>
			<span class="s2">args[</span><span class="s3">0</span><span class="s2">] = (</span><span class="s1">this</span><span class="s2">.useColors ? </span><span class="s0">'%c' </span><span class="s2">: </span><span class="s0">''</span><span class="s2">) +</span>
				<span class="s1">this</span><span class="s2">.namespace +</span>
				<span class="s2">(</span><span class="s1">this</span><span class="s2">.useColors ? </span><span class="s0">' %c' </span><span class="s2">: </span><span class="s0">' '</span><span class="s2">) +</span>
				<span class="s2">args[</span><span class="s3">0</span><span class="s2">] +</span>
				<span class="s2">(</span><span class="s1">this</span><span class="s2">.useColors ? </span><span class="s0">'%c ' </span><span class="s2">: </span><span class="s0">' '</span><span class="s2">) +</span>
				<span class="s0">'+' </span><span class="s2">+ module.exports.humanize(</span><span class="s1">this</span><span class="s2">.diff)</span><span class="s1">;</span>

			<span class="s1">if </span><span class="s2">(!</span><span class="s1">this</span><span class="s2">.useColors) {</span>
				<span class="s1">return;</span>
			<span class="s2">}</span>

			<span class="s1">const </span><span class="s2">c = </span><span class="s0">'color: ' </span><span class="s2">+ </span><span class="s1">this</span><span class="s2">.color</span><span class="s1">;</span>
			<span class="s2">args.splice(</span><span class="s3">1</span><span class="s1">, </span><span class="s3">0</span><span class="s1">, </span><span class="s2">c</span><span class="s1">, </span><span class="s0">'color: inherit'</span><span class="s2">)</span><span class="s1">;</span>

			<span class="s4">// The final &quot;%c&quot; is somewhat tricky, because there could be other</span>
			<span class="s4">// arguments passed either before or after the %c, so we need to</span>
			<span class="s4">// figure out the correct index to insert the CSS into</span>
			<span class="s1">let </span><span class="s2">index = </span><span class="s3">0</span><span class="s1">;</span>
			<span class="s1">let </span><span class="s2">lastC = </span><span class="s3">0</span><span class="s1">;</span>
			<span class="s2">args[</span><span class="s3">0</span><span class="s2">].replace(</span><span class="s3">/%[a-zA-Z%]/g</span><span class="s1">, </span><span class="s2">match =&gt; {</span>
				<span class="s1">if </span><span class="s2">(match === </span><span class="s0">'%%'</span><span class="s2">) {</span>
					<span class="s1">return;</span>
				<span class="s2">}</span>
				<span class="s2">index++</span><span class="s1">;</span>
				<span class="s1">if </span><span class="s2">(match === </span><span class="s0">'%c'</span><span class="s2">) {</span>
					<span class="s4">// We only are interested in the *last* %c</span>
					<span class="s4">// (the user may have provided their own)</span>
					<span class="s2">lastC = index</span><span class="s1">;</span>
				<span class="s2">}</span>
			<span class="s2">})</span><span class="s1">;</span>

			<span class="s2">args.splice(lastC</span><span class="s1">, </span><span class="s3">0</span><span class="s1">, </span><span class="s2">c)</span><span class="s1">;</span>
		<span class="s2">}</span>

		<span class="s5">/**</span>
		 <span class="s5">* Invokes `console.debug()` when available.</span>
		 <span class="s5">* No-op when `console.debug` is not a &quot;function&quot;.</span>
		 <span class="s5">* If `console.debug` is not available, falls back</span>
		 <span class="s5">* to `console.log`.</span>
		 <span class="s5">*</span>
		 <span class="s5">* </span><span class="s6">@api </span><span class="s5">public</span>
		 <span class="s5">*/</span>
		<span class="s2">exports.log = console.debug || console.log || (() =&gt; {})</span><span class="s1">;</span>

		<span class="s5">/**</span>
		 <span class="s5">* Save `namespaces`.</span>
		 <span class="s5">*</span>
		 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{String} namespaces</span>
		 <span class="s5">* </span><span class="s6">@api </span><span class="s5">private</span>
		 <span class="s5">*/</span>
		<span class="s1">function </span><span class="s2">save(namespaces) {</span>
			<span class="s1">try </span><span class="s2">{</span>
				<span class="s1">if </span><span class="s2">(namespaces) {</span>
					<span class="s2">exports.storage.setItem(</span><span class="s0">'debug'</span><span class="s1">, </span><span class="s2">namespaces)</span><span class="s1">;</span>
				<span class="s2">} </span><span class="s1">else </span><span class="s2">{</span>
					<span class="s2">exports.storage.removeItem(</span><span class="s0">'debug'</span><span class="s2">)</span><span class="s1">;</span>
				<span class="s2">}</span>
			<span class="s2">} </span><span class="s1">catch </span><span class="s2">(error) {</span>
				<span class="s4">// Swallow</span>
				<span class="s4">// XXX (@Qix-) should we be logging these?</span>
			<span class="s2">}</span>
		<span class="s2">}</span>

		<span class="s5">/**</span>
		 <span class="s5">* Load `namespaces`.</span>
		 <span class="s5">*</span>
		 <span class="s5">* </span><span class="s6">@return </span><span class="s5">{String} returns the previously persisted debug modes</span>
		 <span class="s5">* </span><span class="s6">@api </span><span class="s5">private</span>
		 <span class="s5">*/</span>
		<span class="s1">function </span><span class="s2">load() {</span>
			<span class="s1">let </span><span class="s2">r</span><span class="s1">;</span>
			<span class="s1">try </span><span class="s2">{</span>
				<span class="s2">r = exports.storage.getItem(</span><span class="s0">'debug'</span><span class="s2">)</span><span class="s1">;</span>
			<span class="s2">} </span><span class="s1">catch </span><span class="s2">(error) {</span>
				<span class="s4">// Swallow</span>
				<span class="s4">// XXX (@Qix-) should we be logging these?</span>
			<span class="s2">}</span>

			<span class="s4">// If debug isn't set in LS, and we're in Electron, try to load $DEBUG</span>
			<span class="s1">if </span><span class="s2">(!r &amp;&amp; </span><span class="s1">typeof </span><span class="s2">process !== </span><span class="s0">'undefined' </span><span class="s2">&amp;&amp; </span><span class="s0">'env' </span><span class="s1">in </span><span class="s2">process) {</span>
				<span class="s2">r = process.env.DEBUG</span><span class="s1">;</span>
			<span class="s2">}</span>

			<span class="s1">return </span><span class="s2">r</span><span class="s1">;</span>
		<span class="s2">}</span>

		<span class="s5">/**</span>
		 <span class="s5">* Localstorage attempts to return the localstorage.</span>
		 <span class="s5">*</span>
		 <span class="s5">* This is necessary because safari throws</span>
		 <span class="s5">* when a user disables cookies/localstorage</span>
		 <span class="s5">* and you attempt to access it.</span>
		 <span class="s5">*</span>
		 <span class="s5">* </span><span class="s6">@return </span><span class="s5">{LocalStorage}</span>
		 <span class="s5">* </span><span class="s6">@api </span><span class="s5">private</span>
		 <span class="s5">*/</span>

		<span class="s1">function </span><span class="s2">localstorage() {</span>
			<span class="s1">try </span><span class="s2">{</span>
				<span class="s4">// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context</span>
				<span class="s4">// The Browser also has localStorage in the global context.</span>
				<span class="s1">return </span><span class="s2">localStorage</span><span class="s1">;</span>
			<span class="s2">} </span><span class="s1">catch </span><span class="s2">(error) {</span>
				<span class="s4">// Swallow</span>
				<span class="s4">// XXX (@Qix-) should we be logging these?</span>
			<span class="s2">}</span>
		<span class="s2">}</span>

		<span class="s2">module.exports = requireCommon()(exports)</span><span class="s1">;</span>

		<span class="s1">const </span><span class="s2">{formatters} = module.exports</span><span class="s1">;</span>

		<span class="s5">/**</span>
		 <span class="s5">* Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.</span>
		 <span class="s5">*/</span>

		<span class="s2">formatters.j = </span><span class="s1">function </span><span class="s2">(v) {</span>
			<span class="s1">try </span><span class="s2">{</span>
				<span class="s1">return </span><span class="s2">JSON.stringify(v)</span><span class="s1">;</span>
			<span class="s2">} </span><span class="s1">catch </span><span class="s2">(error) {</span>
				<span class="s1">return </span><span class="s0">'[UnexpectedJSONParseError]: ' </span><span class="s2">+ error.message</span><span class="s1">;</span>
			<span class="s2">}</span>
		<span class="s2">}</span><span class="s1">;</span>
<span class="s2">} (browser</span><span class="s1">, </span><span class="s2">browserExports))</span><span class="s1">;</span>
	<span class="s1">return </span><span class="s2">browserExports</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s1">var </span><span class="s2">nodeExports = {}</span><span class="s1">;</span>
<span class="s1">var </span><span class="s2">node = {</span>
  <span class="s2">get exports(){ </span><span class="s1">return </span><span class="s2">nodeExports</span><span class="s1">; </span><span class="s2">}</span><span class="s1">,</span>
  <span class="s2">set exports(v){ nodeExports = v</span><span class="s1">; </span><span class="s2">}</span><span class="s1">,</span>
<span class="s2">}</span><span class="s1">;</span>

<span class="s5">/**</span>
 <span class="s5">* Module dependencies.</span>
 <span class="s5">*/</span>

<span class="s1">var </span><span class="s2">hasRequiredNode</span><span class="s1">;</span>

<span class="s1">function </span><span class="s2">requireNode () {</span>
	<span class="s1">if </span><span class="s2">(hasRequiredNode) </span><span class="s1">return </span><span class="s2">nodeExports</span><span class="s1">;</span>
	<span class="s2">hasRequiredNode = </span><span class="s3">1</span><span class="s1">;</span>
	<span class="s2">(</span><span class="s1">function </span><span class="s2">(module</span><span class="s1">, </span><span class="s2">exports) {</span>
		<span class="s1">const </span><span class="s2">tty = require$$0</span><span class="s1">;</span>
		<span class="s1">const </span><span class="s2">util = require$$1</span><span class="s1">;</span>

		<span class="s5">/**</span>
		 <span class="s5">* This is the Node.js implementation of `debug()`.</span>
		 <span class="s5">*/</span>

		<span class="s2">exports.init = init</span><span class="s1">;</span>
		<span class="s2">exports.log = log</span><span class="s1">;</span>
		<span class="s2">exports.formatArgs = formatArgs</span><span class="s1">;</span>
		<span class="s2">exports.save = save</span><span class="s1">;</span>
		<span class="s2">exports.load = load</span><span class="s1">;</span>
		<span class="s2">exports.useColors = useColors</span><span class="s1">;</span>
		<span class="s2">exports.destroy = util.deprecate(</span>
			<span class="s2">() =&gt; {}</span><span class="s1">,</span>
			<span class="s0">'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'</span>
		<span class="s2">)</span><span class="s1">;</span>

		<span class="s5">/**</span>
		 <span class="s5">* Colors.</span>
		 <span class="s5">*/</span>

		<span class="s2">exports.colors = [</span><span class="s3">6</span><span class="s1">, </span><span class="s3">2</span><span class="s1">, </span><span class="s3">3</span><span class="s1">, </span><span class="s3">4</span><span class="s1">, </span><span class="s3">5</span><span class="s1">, </span><span class="s3">1</span><span class="s2">]</span><span class="s1">;</span>

		<span class="s1">try </span><span class="s2">{</span>
			<span class="s4">// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)</span>
			<span class="s4">// eslint-disable-next-line import/no-extraneous-dependencies</span>
			<span class="s1">const </span><span class="s2">supportsColor = require(</span><span class="s0">'supports-color'</span><span class="s2">)</span><span class="s1">;</span>

			<span class="s1">if </span><span class="s2">(supportsColor &amp;&amp; (supportsColor.stderr || supportsColor).level &gt;= </span><span class="s3">2</span><span class="s2">) {</span>
				<span class="s2">exports.colors = [</span>
					<span class="s3">20</span><span class="s1">,</span>
					<span class="s3">21</span><span class="s1">,</span>
					<span class="s3">26</span><span class="s1">,</span>
					<span class="s3">27</span><span class="s1">,</span>
					<span class="s3">32</span><span class="s1">,</span>
					<span class="s3">33</span><span class="s1">,</span>
					<span class="s3">38</span><span class="s1">,</span>
					<span class="s3">39</span><span class="s1">,</span>
					<span class="s3">40</span><span class="s1">,</span>
					<span class="s3">41</span><span class="s1">,</span>
					<span class="s3">42</span><span class="s1">,</span>
					<span class="s3">43</span><span class="s1">,</span>
					<span class="s3">44</span><span class="s1">,</span>
					<span class="s3">45</span><span class="s1">,</span>
					<span class="s3">56</span><span class="s1">,</span>
					<span class="s3">57</span><span class="s1">,</span>
					<span class="s3">62</span><span class="s1">,</span>
					<span class="s3">63</span><span class="s1">,</span>
					<span class="s3">68</span><span class="s1">,</span>
					<span class="s3">69</span><span class="s1">,</span>
					<span class="s3">74</span><span class="s1">,</span>
					<span class="s3">75</span><span class="s1">,</span>
					<span class="s3">76</span><span class="s1">,</span>
					<span class="s3">77</span><span class="s1">,</span>
					<span class="s3">78</span><span class="s1">,</span>
					<span class="s3">79</span><span class="s1">,</span>
					<span class="s3">80</span><span class="s1">,</span>
					<span class="s3">81</span><span class="s1">,</span>
					<span class="s3">92</span><span class="s1">,</span>
					<span class="s3">93</span><span class="s1">,</span>
					<span class="s3">98</span><span class="s1">,</span>
					<span class="s3">99</span><span class="s1">,</span>
					<span class="s3">112</span><span class="s1">,</span>
					<span class="s3">113</span><span class="s1">,</span>
					<span class="s3">128</span><span class="s1">,</span>
					<span class="s3">129</span><span class="s1">,</span>
					<span class="s3">134</span><span class="s1">,</span>
					<span class="s3">135</span><span class="s1">,</span>
					<span class="s3">148</span><span class="s1">,</span>
					<span class="s3">149</span><span class="s1">,</span>
					<span class="s3">160</span><span class="s1">,</span>
					<span class="s3">161</span><span class="s1">,</span>
					<span class="s3">162</span><span class="s1">,</span>
					<span class="s3">163</span><span class="s1">,</span>
					<span class="s3">164</span><span class="s1">,</span>
					<span class="s3">165</span><span class="s1">,</span>
					<span class="s3">166</span><span class="s1">,</span>
					<span class="s3">167</span><span class="s1">,</span>
					<span class="s3">168</span><span class="s1">,</span>
					<span class="s3">169</span><span class="s1">,</span>
					<span class="s3">170</span><span class="s1">,</span>
					<span class="s3">171</span><span class="s1">,</span>
					<span class="s3">172</span><span class="s1">,</span>
					<span class="s3">173</span><span class="s1">,</span>
					<span class="s3">178</span><span class="s1">,</span>
					<span class="s3">179</span><span class="s1">,</span>
					<span class="s3">184</span><span class="s1">,</span>
					<span class="s3">185</span><span class="s1">,</span>
					<span class="s3">196</span><span class="s1">,</span>
					<span class="s3">197</span><span class="s1">,</span>
					<span class="s3">198</span><span class="s1">,</span>
					<span class="s3">199</span><span class="s1">,</span>
					<span class="s3">200</span><span class="s1">,</span>
					<span class="s3">201</span><span class="s1">,</span>
					<span class="s3">202</span><span class="s1">,</span>
					<span class="s3">203</span><span class="s1">,</span>
					<span class="s3">204</span><span class="s1">,</span>
					<span class="s3">205</span><span class="s1">,</span>
					<span class="s3">206</span><span class="s1">,</span>
					<span class="s3">207</span><span class="s1">,</span>
					<span class="s3">208</span><span class="s1">,</span>
					<span class="s3">209</span><span class="s1">,</span>
					<span class="s3">214</span><span class="s1">,</span>
					<span class="s3">215</span><span class="s1">,</span>
					<span class="s3">220</span><span class="s1">,</span>
					<span class="s3">221</span>
				<span class="s2">]</span><span class="s1">;</span>
			<span class="s2">}</span>
		<span class="s2">} </span><span class="s1">catch </span><span class="s2">(error) {</span>
			<span class="s4">// Swallow - we only care if `supports-color` is available; it doesn't have to be.</span>
		<span class="s2">}</span>

		<span class="s5">/**</span>
		 <span class="s5">* Build up the default `inspectOpts` object from the environment variables.</span>
		 <span class="s5">*</span>
		 <span class="s5">*   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js</span>
		 <span class="s5">*/</span>

		<span class="s2">exports.inspectOpts = Object.keys(process.env).filter(key =&gt; {</span>
			<span class="s1">return </span><span class="s3">/^debug_/i</span><span class="s2">.test(key)</span><span class="s1">;</span>
		<span class="s2">}).reduce((obj</span><span class="s1">, </span><span class="s2">key) =&gt; {</span>
			<span class="s4">// Camel-case</span>
			<span class="s1">const </span><span class="s2">prop = key</span>
				<span class="s2">.substring(</span><span class="s3">6</span><span class="s2">)</span>
				<span class="s2">.toLowerCase()</span>
				<span class="s2">.replace(</span><span class="s3">/_([a-z])/g</span><span class="s1">, </span><span class="s2">(_</span><span class="s1">, </span><span class="s2">k) =&gt; {</span>
					<span class="s1">return </span><span class="s2">k.toUpperCase()</span><span class="s1">;</span>
				<span class="s2">})</span><span class="s1">;</span>

			<span class="s4">// Coerce string value into JS value</span>
			<span class="s1">let </span><span class="s2">val = process.env[key]</span><span class="s1">;</span>
			<span class="s1">if </span><span class="s2">(</span><span class="s3">/^(yes|on|true|enabled)$/i</span><span class="s2">.test(val)) {</span>
				<span class="s2">val = </span><span class="s1">true;</span>
			<span class="s2">} </span><span class="s1">else if </span><span class="s2">(</span><span class="s3">/^(no|off|false|disabled)$/i</span><span class="s2">.test(val)) {</span>
				<span class="s2">val = </span><span class="s1">false;</span>
			<span class="s2">} </span><span class="s1">else if </span><span class="s2">(val === </span><span class="s0">'null'</span><span class="s2">) {</span>
				<span class="s2">val = </span><span class="s1">null;</span>
			<span class="s2">} </span><span class="s1">else </span><span class="s2">{</span>
				<span class="s2">val = Number(val)</span><span class="s1">;</span>
			<span class="s2">}</span>

			<span class="s2">obj[prop] = val</span><span class="s1">;</span>
			<span class="s1">return </span><span class="s2">obj</span><span class="s1">;</span>
		<span class="s2">}</span><span class="s1">, </span><span class="s2">{})</span><span class="s1">;</span>

		<span class="s5">/**</span>
		 <span class="s5">* Is stdout a TTY? Colored output is enabled when `true`.</span>
		 <span class="s5">*/</span>

		<span class="s1">function </span><span class="s2">useColors() {</span>
			<span class="s1">return </span><span class="s0">'colors' </span><span class="s1">in </span><span class="s2">exports.inspectOpts ?</span>
				<span class="s2">Boolean(exports.inspectOpts.colors) :</span>
				<span class="s2">tty.isatty(process.stderr.fd)</span><span class="s1">;</span>
		<span class="s2">}</span>

		<span class="s5">/**</span>
		 <span class="s5">* Adds ANSI color escape codes if enabled.</span>
		 <span class="s5">*</span>
		 <span class="s5">* </span><span class="s6">@api </span><span class="s5">public</span>
		 <span class="s5">*/</span>

		<span class="s1">function </span><span class="s2">formatArgs(args) {</span>
			<span class="s1">const </span><span class="s2">{namespace: name</span><span class="s1">, </span><span class="s2">useColors} = </span><span class="s1">this;</span>

			<span class="s1">if </span><span class="s2">(useColors) {</span>
				<span class="s1">const </span><span class="s2">c = </span><span class="s1">this</span><span class="s2">.color</span><span class="s1">;</span>
				<span class="s1">const </span><span class="s2">colorCode = </span><span class="s0">'</span><span class="s1">\u001B</span><span class="s0">[3' </span><span class="s2">+ (c &lt; </span><span class="s3">8 </span><span class="s2">? c : </span><span class="s0">'8;5;' </span><span class="s2">+ c)</span><span class="s1">;</span>
				<span class="s1">const </span><span class="s2">prefix = </span><span class="s0">`  </span><span class="s2">${colorCode}</span><span class="s0">;1m</span><span class="s2">${name} </span><span class="s1">\u001B</span><span class="s0">[0m`</span><span class="s1">;</span>

				<span class="s2">args[</span><span class="s3">0</span><span class="s2">] = prefix + args[</span><span class="s3">0</span><span class="s2">].split(</span><span class="s0">'</span><span class="s1">\n</span><span class="s0">'</span><span class="s2">).join(</span><span class="s0">'</span><span class="s1">\n</span><span class="s0">' </span><span class="s2">+ prefix)</span><span class="s1">;</span>
				<span class="s2">args.push(colorCode + </span><span class="s0">'m+' </span><span class="s2">+ module.exports.humanize(</span><span class="s1">this</span><span class="s2">.diff) + </span><span class="s0">'</span><span class="s1">\u001B</span><span class="s0">[0m'</span><span class="s2">)</span><span class="s1">;</span>
			<span class="s2">} </span><span class="s1">else </span><span class="s2">{</span>
				<span class="s2">args[</span><span class="s3">0</span><span class="s2">] = getDate() + name + </span><span class="s0">' ' </span><span class="s2">+ args[</span><span class="s3">0</span><span class="s2">]</span><span class="s1">;</span>
			<span class="s2">}</span>
		<span class="s2">}</span>

		<span class="s1">function </span><span class="s2">getDate() {</span>
			<span class="s1">if </span><span class="s2">(exports.inspectOpts.hideDate) {</span>
				<span class="s1">return </span><span class="s0">''</span><span class="s1">;</span>
			<span class="s2">}</span>
			<span class="s1">return new </span><span class="s2">Date().toISOString() + </span><span class="s0">' '</span><span class="s1">;</span>
		<span class="s2">}</span>

		<span class="s5">/**</span>
		 <span class="s5">* Invokes `util.format()` with the specified arguments and writes to stderr.</span>
		 <span class="s5">*/</span>

		<span class="s1">function </span><span class="s2">log(...args) {</span>
			<span class="s1">return </span><span class="s2">process.stderr.write(util.format(...args) + </span><span class="s0">'</span><span class="s1">\n</span><span class="s0">'</span><span class="s2">)</span><span class="s1">;</span>
		<span class="s2">}</span>

		<span class="s5">/**</span>
		 <span class="s5">* Save `namespaces`.</span>
		 <span class="s5">*</span>
		 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{String} namespaces</span>
		 <span class="s5">* </span><span class="s6">@api </span><span class="s5">private</span>
		 <span class="s5">*/</span>
		<span class="s1">function </span><span class="s2">save(namespaces) {</span>
			<span class="s1">if </span><span class="s2">(namespaces) {</span>
				<span class="s2">process.env.DEBUG = namespaces</span><span class="s1">;</span>
			<span class="s2">} </span><span class="s1">else </span><span class="s2">{</span>
				<span class="s4">// If you set a process.env field to null or undefined, it gets cast to the</span>
				<span class="s4">// string 'null' or 'undefined'. Just delete instead.</span>
				<span class="s1">delete </span><span class="s2">process.env.DEBUG</span><span class="s1">;</span>
			<span class="s2">}</span>
		<span class="s2">}</span>

		<span class="s5">/**</span>
		 <span class="s5">* Load `namespaces`.</span>
		 <span class="s5">*</span>
		 <span class="s5">* </span><span class="s6">@return </span><span class="s5">{String} returns the previously persisted debug modes</span>
		 <span class="s5">* </span><span class="s6">@api </span><span class="s5">private</span>
		 <span class="s5">*/</span>

		<span class="s1">function </span><span class="s2">load() {</span>
			<span class="s1">return </span><span class="s2">process.env.DEBUG</span><span class="s1">;</span>
		<span class="s2">}</span>

		<span class="s5">/**</span>
		 <span class="s5">* Init logic for `debug` instances.</span>
		 <span class="s5">*</span>
		 <span class="s5">* Create a new `inspectOpts` object in case `useColors` is set</span>
		 <span class="s5">* differently for a particular `debug` instance.</span>
		 <span class="s5">*/</span>

		<span class="s1">function </span><span class="s2">init(debug) {</span>
			<span class="s2">debug.inspectOpts = {}</span><span class="s1">;</span>

			<span class="s1">const </span><span class="s2">keys = Object.keys(exports.inspectOpts)</span><span class="s1">;</span>
			<span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s3">0</span><span class="s1">; </span><span class="s2">i &lt; keys.length</span><span class="s1">; </span><span class="s2">i++) {</span>
				<span class="s2">debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]]</span><span class="s1">;</span>
			<span class="s2">}</span>
		<span class="s2">}</span>

		<span class="s2">module.exports = requireCommon()(exports)</span><span class="s1">;</span>

		<span class="s1">const </span><span class="s2">{formatters} = module.exports</span><span class="s1">;</span>

		<span class="s5">/**</span>
		 <span class="s5">* Map %o to `util.inspect()`, all on a single line.</span>
		 <span class="s5">*/</span>

		<span class="s2">formatters.o = </span><span class="s1">function </span><span class="s2">(v) {</span>
			<span class="s1">this</span><span class="s2">.inspectOpts.colors = </span><span class="s1">this</span><span class="s2">.useColors</span><span class="s1">;</span>
			<span class="s1">return </span><span class="s2">util.inspect(v</span><span class="s1">, this</span><span class="s2">.inspectOpts)</span>
				<span class="s2">.split(</span><span class="s0">'</span><span class="s1">\n</span><span class="s0">'</span><span class="s2">)</span>
				<span class="s2">.map(str =&gt; str.trim())</span>
				<span class="s2">.join(</span><span class="s0">' '</span><span class="s2">)</span><span class="s1">;</span>
		<span class="s2">}</span><span class="s1">;</span>

		<span class="s5">/**</span>
		 <span class="s5">* Map %O to `util.inspect()`, allowing multiple lines if needed.</span>
		 <span class="s5">*/</span>

		<span class="s2">formatters.O = </span><span class="s1">function </span><span class="s2">(v) {</span>
			<span class="s1">this</span><span class="s2">.inspectOpts.colors = </span><span class="s1">this</span><span class="s2">.useColors</span><span class="s1">;</span>
			<span class="s1">return </span><span class="s2">util.inspect(v</span><span class="s1">, this</span><span class="s2">.inspectOpts)</span><span class="s1">;</span>
		<span class="s2">}</span><span class="s1">;</span>
<span class="s2">} (node</span><span class="s1">, </span><span class="s2">nodeExports))</span><span class="s1">;</span>
	<span class="s1">return </span><span class="s2">nodeExports</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s5">/**</span>
 <span class="s5">* Detect Electron renderer / nwjs process, which is node, but we should</span>
 <span class="s5">* treat as a browser.</span>
 <span class="s5">*/</span>

<span class="s2">(</span><span class="s1">function </span><span class="s2">(module) {</span>
	<span class="s1">if </span><span class="s2">(</span><span class="s1">typeof </span><span class="s2">process === </span><span class="s0">'undefined' </span><span class="s2">|| process.type === </span><span class="s0">'renderer' </span><span class="s2">|| process.browser === </span><span class="s1">true </span><span class="s2">|| process.__nwjs) {</span>
		<span class="s2">module.exports = requireBrowser()</span><span class="s1">;</span>
	<span class="s2">} </span><span class="s1">else </span><span class="s2">{</span>
		<span class="s2">module.exports = requireNode()</span><span class="s1">;</span>
	<span class="s2">}</span>
<span class="s2">} (src))</span><span class="s1">;</span>

<span class="s1">const </span><span class="s2">_debug = </span><span class="s4">/*@__PURE__*/</span><span class="s2">getDefaultExportFromCjs(srcExports)</span><span class="s1">;</span>

<span class="s1">const </span><span class="s2">debug = _debug(</span><span class="s0">&quot;vite:hmr&quot;</span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">directRequestRE = </span><span class="s3">/(?:\?|&amp;)direct\b/</span><span class="s1">;</span>
<span class="s2">async </span><span class="s1">function </span><span class="s2">handleHotUpdate({ file</span><span class="s1">, </span><span class="s2">modules</span><span class="s1">, </span><span class="s2">read</span><span class="s1">, </span><span class="s2">server }</span><span class="s1">, </span><span class="s2">options) {</span>
  <span class="s1">const </span><span class="s2">prevDescriptor = getDescriptor(file</span><span class="s1">, </span><span class="s2">options</span><span class="s1">, false</span><span class="s2">)</span><span class="s1">;</span>
  <span class="s1">if </span><span class="s2">(!prevDescriptor) {</span>
    <span class="s1">return;</span>
  <span class="s2">}</span>
  <span class="s2">setPrevDescriptor(file</span><span class="s1">, </span><span class="s2">prevDescriptor)</span><span class="s1">;</span>
  <span class="s1">const </span><span class="s2">content = </span><span class="s1">await </span><span class="s2">read()</span><span class="s1">;</span>
  <span class="s1">const </span><span class="s2">{ descriptor } = createDescriptor(file</span><span class="s1">, </span><span class="s2">content</span><span class="s1">, </span><span class="s2">options)</span><span class="s1">;</span>
  <span class="s1">let </span><span class="s2">needRerender = </span><span class="s1">false;</span>
  <span class="s1">const </span><span class="s2">affectedModules = </span><span class="s4">/* @__PURE__ */ </span><span class="s1">new </span><span class="s2">Set()</span><span class="s1">;</span>
  <span class="s1">const </span><span class="s2">mainModule = modules.filter((m) =&gt; !</span><span class="s3">/type=/</span><span class="s2">.test(m.url) || </span><span class="s3">/type=script/</span><span class="s2">.test(m.url)).sort((m1</span><span class="s1">, </span><span class="s2">m2) =&gt; {</span>
    <span class="s1">return </span><span class="s2">m1.url.length - m2.url.length</span><span class="s1">;</span>
  <span class="s2">})[</span><span class="s3">0</span><span class="s2">]</span><span class="s1">;</span>
  <span class="s1">const </span><span class="s2">templateModule = modules.find((m) =&gt; </span><span class="s3">/type=template/</span><span class="s2">.test(m.url))</span><span class="s1">;</span>
  <span class="s1">const </span><span class="s2">scriptChanged = hasScriptChanged(prevDescriptor</span><span class="s1">, </span><span class="s2">descriptor)</span><span class="s1">;</span>
  <span class="s1">if </span><span class="s2">(scriptChanged) {</span>
    <span class="s1">let </span><span class="s2">scriptModule</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(descriptor.scriptSetup?.lang &amp;&amp; !descriptor.scriptSetup.src || descriptor.script?.lang &amp;&amp; !descriptor.script.src) {</span>
      <span class="s1">const </span><span class="s2">scriptModuleRE = </span><span class="s1">new </span><span class="s2">RegExp(</span>
        <span class="s0">`type=script.*&amp;lang.</span><span class="s2">${descriptor.scriptSetup?.lang || descriptor.script?.lang}</span><span class="s0">$`</span>
      <span class="s2">)</span><span class="s1">;</span>
      <span class="s2">scriptModule = modules.find((m) =&gt; scriptModuleRE.test(m.url))</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s2">affectedModules.add(scriptModule || mainModule)</span><span class="s1">;</span>
  <span class="s2">}</span>
  <span class="s1">if </span><span class="s2">(!isEqualBlock(descriptor.template</span><span class="s1">, </span><span class="s2">prevDescriptor.template)) {</span>
    <span class="s1">if </span><span class="s2">(!scriptChanged) {</span>
      <span class="s2">setResolvedScript(</span>
        <span class="s2">descriptor</span><span class="s1">,</span>
        <span class="s2">getResolvedScript(prevDescriptor</span><span class="s1">, false</span><span class="s2">)</span><span class="s1">,</span>
        <span class="s1">false</span>
      <span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s2">affectedModules.add(templateModule)</span><span class="s1">;</span>
    <span class="s2">needRerender = </span><span class="s1">true;</span>
  <span class="s2">}</span>
  <span class="s1">let </span><span class="s2">didUpdateStyle = </span><span class="s1">false;</span>
  <span class="s1">const </span><span class="s2">prevStyles = prevDescriptor.styles || []</span><span class="s1">;</span>
  <span class="s1">const </span><span class="s2">nextStyles = descriptor.styles || []</span><span class="s1">;</span>
  <span class="s1">if </span><span class="s2">(prevDescriptor.cssVars.join(</span><span class="s0">&quot;&quot;</span><span class="s2">) !== descriptor.cssVars.join(</span><span class="s0">&quot;&quot;</span><span class="s2">)) {</span>
    <span class="s2">affectedModules.add(mainModule)</span><span class="s1">;</span>
  <span class="s2">}</span>
  <span class="s1">if </span><span class="s2">(prevStyles.some((s) =&gt; s.scoped) !== nextStyles.some((s) =&gt; s.scoped)) {</span>
    <span class="s2">affectedModules.add(templateModule)</span><span class="s1">;</span>
    <span class="s2">affectedModules.add(mainModule)</span><span class="s1">;</span>
  <span class="s2">}</span>
  <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s3">0</span><span class="s1">; </span><span class="s2">i &lt; nextStyles.length</span><span class="s1">; </span><span class="s2">i++) {</span>
    <span class="s1">const </span><span class="s2">prev = prevStyles[i]</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">next = nextStyles[i]</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(!prev || !isEqualBlock(prev</span><span class="s1">, </span><span class="s2">next)) {</span>
      <span class="s2">didUpdateStyle = </span><span class="s1">true;</span>
      <span class="s1">const </span><span class="s2">mod = modules.find(</span>
        <span class="s2">(m) =&gt; m.url.includes(</span><span class="s0">`type=style&amp;index=</span><span class="s2">${i}</span><span class="s0">`</span><span class="s2">) &amp;&amp; m.url.endsWith(</span><span class="s0">`.</span><span class="s2">${next.lang || </span><span class="s0">&quot;css&quot;</span><span class="s2">}</span><span class="s0">`</span><span class="s2">) &amp;&amp; !directRequestRE.test(m.url)</span>
      <span class="s2">)</span><span class="s1">;</span>
      <span class="s1">if </span><span class="s2">(mod) {</span>
        <span class="s2">affectedModules.add(mod)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(mod.url.includes(</span><span class="s0">&quot;&amp;inline&quot;</span><span class="s2">)) {</span>
          <span class="s2">affectedModules.add(mainModule)</span><span class="s1">;</span>
        <span class="s2">}</span>
      <span class="s2">} </span><span class="s1">else </span><span class="s2">{</span>
        <span class="s2">affectedModules.add(mainModule)</span><span class="s1">;</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
  <span class="s2">}</span>
  <span class="s1">if </span><span class="s2">(prevStyles.length &gt; nextStyles.length) {</span>
    <span class="s2">affectedModules.add(mainModule)</span><span class="s1">;</span>
  <span class="s2">}</span>
  <span class="s1">const </span><span class="s2">prevCustoms = prevDescriptor.customBlocks || []</span><span class="s1">;</span>
  <span class="s1">const </span><span class="s2">nextCustoms = descriptor.customBlocks || []</span><span class="s1">;</span>
  <span class="s1">if </span><span class="s2">(prevCustoms.length !== nextCustoms.length) {</span>
    <span class="s2">affectedModules.add(mainModule)</span><span class="s1">;</span>
  <span class="s2">} </span><span class="s1">else </span><span class="s2">{</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s3">0</span><span class="s1">; </span><span class="s2">i &lt; nextCustoms.length</span><span class="s1">; </span><span class="s2">i++) {</span>
      <span class="s1">const </span><span class="s2">prev = prevCustoms[i]</span><span class="s1">;</span>
      <span class="s1">const </span><span class="s2">next = nextCustoms[i]</span><span class="s1">;</span>
      <span class="s1">if </span><span class="s2">(!prev || !isEqualBlock(prev</span><span class="s1">, </span><span class="s2">next)) {</span>
        <span class="s1">const </span><span class="s2">mod = modules.find(</span>
          <span class="s2">(m) =&gt; m.url.includes(</span><span class="s0">`type=</span><span class="s2">${prev.type}</span><span class="s0">&amp;index=</span><span class="s2">${i}</span><span class="s0">`</span><span class="s2">)</span>
        <span class="s2">)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(mod) {</span>
          <span class="s2">affectedModules.add(mod)</span><span class="s1">;</span>
        <span class="s2">} </span><span class="s1">else </span><span class="s2">{</span>
          <span class="s2">affectedModules.add(mainModule)</span><span class="s1">;</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
  <span class="s2">}</span>
  <span class="s1">const </span><span class="s2">updateType = []</span><span class="s1">;</span>
  <span class="s1">if </span><span class="s2">(needRerender) {</span>
    <span class="s2">updateType.push(</span><span class="s0">`template`</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(!templateModule) {</span>
      <span class="s2">affectedModules.add(mainModule)</span><span class="s1">;</span>
    <span class="s2">} </span><span class="s1">else if </span><span class="s2">(mainModule &amp;&amp; !affectedModules.has(mainModule)) {</span>
      <span class="s1">const </span><span class="s2">styleImporters = [...mainModule.importers].filter(</span>
        <span class="s2">(m) =&gt; vite.isCSSRequest(m.url)</span>
      <span class="s2">)</span><span class="s1">;</span>
      <span class="s2">styleImporters.forEach((m) =&gt; affectedModules.add(m))</span><span class="s1">;</span>
    <span class="s2">}</span>
  <span class="s2">}</span>
  <span class="s1">if </span><span class="s2">(didUpdateStyle) {</span>
    <span class="s2">updateType.push(</span><span class="s0">`style`</span><span class="s2">)</span><span class="s1">;</span>
  <span class="s2">}</span>
  <span class="s1">if </span><span class="s2">(updateType.length) {</span>
    <span class="s2">debug(</span><span class="s0">`[vue:update(</span><span class="s2">${updateType.join(</span><span class="s0">&quot;&amp;&quot;</span><span class="s2">)}</span><span class="s0">)] </span><span class="s2">${file}</span><span class="s0">`</span><span class="s2">)</span><span class="s1">;</span>
  <span class="s2">}</span>
  <span class="s1">return </span><span class="s2">[...affectedModules].filter(Boolean)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">isEqualBlock(a</span><span class="s1">, </span><span class="s2">b) {</span>
  <span class="s1">if </span><span class="s2">(!a &amp;&amp; !b)</span>
    <span class="s1">return true;</span>
  <span class="s1">if </span><span class="s2">(!a || !b)</span>
    <span class="s1">return false;</span>
  <span class="s1">if </span><span class="s2">(a.src &amp;&amp; b.src &amp;&amp; a.src === b.src)</span>
    <span class="s1">return true;</span>
  <span class="s1">if </span><span class="s2">(a.content !== b.content)</span>
    <span class="s1">return false;</span>
  <span class="s1">const </span><span class="s2">keysA = Object.keys(a.attrs)</span><span class="s1">;</span>
  <span class="s1">const </span><span class="s2">keysB = Object.keys(b.attrs)</span><span class="s1">;</span>
  <span class="s1">if </span><span class="s2">(keysA.length !== keysB.length) {</span>
    <span class="s1">return false;</span>
  <span class="s2">}</span>
  <span class="s1">return </span><span class="s2">keysA.every((key) =&gt; a.attrs[key] === b.attrs[key])</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">isOnlyTemplateChanged(prev</span><span class="s1">, </span><span class="s2">next) {</span>
  <span class="s1">return </span><span class="s2">!hasScriptChanged(prev</span><span class="s1">, </span><span class="s2">next) &amp;&amp; prev.styles.length === next.styles.length &amp;&amp; prev.styles.every((s</span><span class="s1">, </span><span class="s2">i) =&gt; isEqualBlock(s</span><span class="s1">, </span><span class="s2">next.styles[i])) &amp;&amp; prev.customBlocks.length === next.customBlocks.length &amp;&amp; prev.customBlocks.every((s</span><span class="s1">, </span><span class="s2">i) =&gt; isEqualBlock(s</span><span class="s1">, </span><span class="s2">next.customBlocks[i]))</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">hasScriptChanged(prev</span><span class="s1">, </span><span class="s2">next) {</span>
  <span class="s1">if </span><span class="s2">(!isEqualBlock(prev.script</span><span class="s1">, </span><span class="s2">next.script)) {</span>
    <span class="s1">return true;</span>
  <span class="s2">}</span>
  <span class="s1">if </span><span class="s2">(!isEqualBlock(prev.scriptSetup</span><span class="s1">, </span><span class="s2">next.scriptSetup)) {</span>
    <span class="s1">return true;</span>
  <span class="s2">}</span>
  <span class="s1">const </span><span class="s2">prevResolvedScript = getResolvedScript(prev</span><span class="s1">, false</span><span class="s2">)</span><span class="s1">;</span>
  <span class="s1">const </span><span class="s2">prevImports = prevResolvedScript?.imports</span><span class="s1">;</span>
  <span class="s1">if </span><span class="s2">(prevImports) {</span>
    <span class="s1">return </span><span class="s2">!next.template || next.shouldForceReload(prevImports)</span><span class="s1">;</span>
  <span class="s2">}</span>
  <span class="s1">return false;</span>
<span class="s2">}</span>

<span class="s1">const </span><span class="s2">EXPORT_HELPER_ID = </span><span class="s0">&quot;</span><span class="s1">\0</span><span class="s0">plugin-vue:export-helper&quot;</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">helperCode = </span><span class="s0">`</span>
<span class="s0">export default (sfc, props) =&gt; { 
  const target = sfc.__vccOpts || sfc; 
  for (const [key, val] of props) { 
    target[key] = val; 
  } 
  return target; 
} 
`</span><span class="s1">;</span>

<span class="s2">async </span><span class="s1">function </span><span class="s2">transformMain(code</span><span class="s1">, </span><span class="s2">filename</span><span class="s1">, </span><span class="s2">options</span><span class="s1">, </span><span class="s2">pluginContext</span><span class="s1">, </span><span class="s2">ssr</span><span class="s1">, </span><span class="s2">asCustomElement) {</span>
  <span class="s1">const </span><span class="s2">{ devServer</span><span class="s1">, </span><span class="s2">isProduction</span><span class="s1">, </span><span class="s2">devToolsEnabled } = options</span><span class="s1">;</span>
  <span class="s1">const </span><span class="s2">prevDescriptor = getPrevDescriptor(filename)</span><span class="s1">;</span>
  <span class="s1">const </span><span class="s2">{ descriptor</span><span class="s1">, </span><span class="s2">errors } = createDescriptor(filename</span><span class="s1">, </span><span class="s2">code</span><span class="s1">, </span><span class="s2">options)</span><span class="s1">;</span>
  <span class="s1">if </span><span class="s2">(errors.length) {</span>
    <span class="s2">errors.forEach(</span>
      <span class="s2">(error) =&gt; pluginContext.error(createRollupError(filename</span><span class="s1">, </span><span class="s2">error))</span>
    <span class="s2">)</span><span class="s1">;</span>
    <span class="s1">return null;</span>
  <span class="s2">}</span>
  <span class="s1">const </span><span class="s2">attachedProps = []</span><span class="s1">;</span>
  <span class="s1">const </span><span class="s2">hasScoped = descriptor.styles.some((s) =&gt; s.scoped)</span><span class="s1">;</span>
  <span class="s1">const </span><span class="s2">{ code: scriptCode</span><span class="s1">, </span><span class="s2">map: scriptMap } = </span><span class="s1">await </span><span class="s2">genScriptCode(</span>
    <span class="s2">descriptor</span><span class="s1">,</span>
    <span class="s2">options</span><span class="s1">,</span>
    <span class="s2">pluginContext</span><span class="s1">,</span>
    <span class="s2">ssr</span>
  <span class="s2">)</span><span class="s1">;</span>
  <span class="s1">const </span><span class="s2">hasTemplateImport = descriptor.template &amp;&amp; !isUseInlineTemplate(descriptor</span><span class="s1">, </span><span class="s2">!devServer)</span><span class="s1">;</span>
  <span class="s1">let </span><span class="s2">templateCode = </span><span class="s0">&quot;&quot;</span><span class="s1">;</span>
  <span class="s1">let </span><span class="s2">templateMap = </span><span class="s1">void </span><span class="s3">0</span><span class="s1">;</span>
  <span class="s1">if </span><span class="s2">(hasTemplateImport) {</span>
    <span class="s2">({ code: templateCode</span><span class="s1">, </span><span class="s2">map: templateMap } = </span><span class="s1">await </span><span class="s2">genTemplateCode(</span>
      <span class="s2">descriptor</span><span class="s1">,</span>
      <span class="s2">options</span><span class="s1">,</span>
      <span class="s2">pluginContext</span><span class="s1">,</span>
      <span class="s2">ssr</span>
    <span class="s2">))</span><span class="s1">;</span>
  <span class="s2">}</span>
  <span class="s1">if </span><span class="s2">(hasTemplateImport) {</span>
    <span class="s2">attachedProps.push(</span>
      <span class="s2">ssr ? [</span><span class="s0">&quot;ssrRender&quot;</span><span class="s1">, </span><span class="s0">&quot;_sfc_ssrRender&quot;</span><span class="s2">] : [</span><span class="s0">&quot;render&quot;</span><span class="s1">, </span><span class="s0">&quot;_sfc_render&quot;</span><span class="s2">]</span>
    <span class="s2">)</span><span class="s1">;</span>
  <span class="s2">} </span><span class="s1">else </span><span class="s2">{</span>
    <span class="s1">if </span><span class="s2">(prevDescriptor &amp;&amp; !isEqualBlock(descriptor.template</span><span class="s1">, </span><span class="s2">prevDescriptor.template)) {</span>
      <span class="s2">attachedProps.push([ssr ? </span><span class="s0">&quot;ssrRender&quot; </span><span class="s2">: </span><span class="s0">&quot;render&quot;</span><span class="s1">, </span><span class="s0">&quot;() =&gt; {}&quot;</span><span class="s2">])</span><span class="s1">;</span>
    <span class="s2">}</span>
  <span class="s2">}</span>
  <span class="s1">const </span><span class="s2">stylesCode = </span><span class="s1">await </span><span class="s2">genStyleCode(</span>
    <span class="s2">descriptor</span><span class="s1">,</span>
    <span class="s2">pluginContext</span><span class="s1">,</span>
    <span class="s2">asCustomElement</span><span class="s1">,</span>
    <span class="s2">attachedProps</span>
  <span class="s2">)</span><span class="s1">;</span>
  <span class="s1">const </span><span class="s2">customBlocksCode = </span><span class="s1">await </span><span class="s2">genCustomBlockCode(descriptor</span><span class="s1">, </span><span class="s2">pluginContext)</span><span class="s1">;</span>
  <span class="s1">const </span><span class="s2">output = [</span>
    <span class="s2">scriptCode</span><span class="s1">,</span>
    <span class="s2">templateCode</span><span class="s1">,</span>
    <span class="s2">stylesCode</span><span class="s1">,</span>
    <span class="s2">customBlocksCode</span>
  <span class="s2">]</span><span class="s1">;</span>
  <span class="s1">if </span><span class="s2">(hasScoped) {</span>
    <span class="s2">attachedProps.push([</span><span class="s0">`__scopeId`</span><span class="s1">, </span><span class="s2">JSON.stringify(</span><span class="s0">`data-v-</span><span class="s2">${descriptor.id}</span><span class="s0">`</span><span class="s2">)])</span><span class="s1">;</span>
  <span class="s2">}</span>
  <span class="s1">if </span><span class="s2">(devToolsEnabled || devServer &amp;&amp; !isProduction) {</span>
    <span class="s2">attachedProps.push([</span>
      <span class="s0">`__file`</span><span class="s1">,</span>
      <span class="s2">JSON.stringify(isProduction ? path.basename(filename) : filename)</span>
    <span class="s2">])</span><span class="s1">;</span>
  <span class="s2">}</span>
  <span class="s1">if </span><span class="s2">(devServer &amp;&amp; devServer.config.server.hmr !== </span><span class="s1">false </span><span class="s2">&amp;&amp; !ssr &amp;&amp; !isProduction) {</span>
    <span class="s2">output.push(</span><span class="s0">`_sfc_main.__hmrId = </span><span class="s2">${JSON.stringify(descriptor.id)}</span><span class="s0">`</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">output.push(</span>
      <span class="s0">`typeof __VUE_HMR_RUNTIME__ !== 'undefined' &amp;&amp; __VUE_HMR_RUNTIME__.createRecord(_sfc_main.__hmrId, _sfc_main)`</span>
    <span class="s2">)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(prevDescriptor &amp;&amp; isOnlyTemplateChanged(prevDescriptor</span><span class="s1">, </span><span class="s2">descriptor)) {</span>
      <span class="s2">output.push(</span><span class="s0">`export const _rerender_only = true`</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s2">output.push(</span>
      <span class="s0">`import.meta.hot.accept(mod =&gt; {`</span><span class="s1">,</span>
      <span class="s0">`  if (!mod) return`</span><span class="s1">,</span>
      <span class="s0">`  const { default: updated, _rerender_only } = mod`</span><span class="s1">,</span>
      <span class="s0">`  if (_rerender_only) {`</span><span class="s1">,</span>
      <span class="s0">`    __VUE_HMR_RUNTIME__.rerender(updated.__hmrId, updated.render)`</span><span class="s1">,</span>
      <span class="s0">`  } else {`</span><span class="s1">,</span>
      <span class="s0">`    __VUE_HMR_RUNTIME__.reload(updated.__hmrId, updated)`</span><span class="s1">,</span>
      <span class="s0">`  }`</span><span class="s1">,</span>
      <span class="s0">`})`</span>
    <span class="s2">)</span><span class="s1">;</span>
  <span class="s2">}</span>
  <span class="s1">if </span><span class="s2">(ssr) {</span>
    <span class="s1">const </span><span class="s2">normalizedFilename = vite.normalizePath(</span>
      <span class="s2">path.relative(options.root</span><span class="s1">, </span><span class="s2">filename)</span>
    <span class="s2">)</span><span class="s1">;</span>
    <span class="s2">output.push(</span>
      <span class="s0">`import { useSSRContext as __vite_useSSRContext } from 'vue'`</span><span class="s1">,</span>
      <span class="s0">`const _sfc_setup = _sfc_main.setup`</span><span class="s1">,</span>
      <span class="s0">`_sfc_main.setup = (props, ctx) =&gt; {`</span><span class="s1">,</span>
      <span class="s0">`  const ssrContext = __vite_useSSRContext()`</span><span class="s1">,</span>
      <span class="s0">`  ;(ssrContext.modules || (ssrContext.modules = new Set())).add(</span><span class="s2">${JSON.stringify(</span>
        <span class="s2">normalizedFilename</span>
      <span class="s2">)}</span><span class="s0">)`</span><span class="s1">,</span>
      <span class="s0">`  return _sfc_setup ? _sfc_setup(props, ctx) : undefined`</span><span class="s1">,</span>
      <span class="s0">`}`</span>
    <span class="s2">)</span><span class="s1">;</span>
  <span class="s2">}</span>
  <span class="s1">let </span><span class="s2">resolvedMap = </span><span class="s1">void </span><span class="s3">0</span><span class="s1">;</span>
  <span class="s1">if </span><span class="s2">(options.sourceMap) {</span>
    <span class="s1">if </span><span class="s2">(scriptMap &amp;&amp; templateMap) {</span>
      <span class="s1">const </span><span class="s2">gen = fromMap(</span>
        <span class="s4">// version property of result.map is declared as string</span>
        <span class="s4">// but actually it is `3`</span>
        <span class="s2">scriptMap</span>
      <span class="s2">)</span><span class="s1">;</span>
      <span class="s1">const </span><span class="s2">tracer = </span><span class="s1">new </span><span class="s2">TraceMap(</span>
        <span class="s4">// same above</span>
        <span class="s2">templateMap</span>
      <span class="s2">)</span><span class="s1">;</span>
      <span class="s1">const </span><span class="s2">offset = (scriptCode.match(</span><span class="s3">/\r?\n/g</span><span class="s2">)?.length ?? </span><span class="s3">0</span><span class="s2">) + </span><span class="s3">1</span><span class="s1">;</span>
      <span class="s2">eachMapping(tracer</span><span class="s1">, </span><span class="s2">(m) =&gt; {</span>
        <span class="s1">if </span><span class="s2">(m.source == </span><span class="s1">null</span><span class="s2">)</span>
          <span class="s1">return;</span>
        <span class="s2">addMapping(gen</span><span class="s1">, </span><span class="s2">{</span>
          <span class="s2">source: m.source</span><span class="s1">,</span>
          <span class="s2">original: { line: m.originalLine</span><span class="s1">, </span><span class="s2">column: m.originalColumn }</span><span class="s1">,</span>
          <span class="s2">generated: {</span>
            <span class="s2">line: m.generatedLine + offset</span><span class="s1">,</span>
            <span class="s2">column: m.generatedColumn</span>
          <span class="s2">}</span>
        <span class="s2">})</span><span class="s1">;</span>
      <span class="s2">})</span><span class="s1">;</span>
      <span class="s2">resolvedMap = toEncodedMap(gen)</span><span class="s1">;</span>
      <span class="s2">resolvedMap.sourcesContent = templateMap.sourcesContent</span><span class="s1">;</span>
    <span class="s2">} </span><span class="s1">else </span><span class="s2">{</span>
      <span class="s2">resolvedMap = scriptMap ?? templateMap</span><span class="s1">;</span>
    <span class="s2">}</span>
  <span class="s2">}</span>
  <span class="s1">if </span><span class="s2">(!attachedProps.length) {</span>
    <span class="s2">output.push(</span><span class="s0">`export default _sfc_main`</span><span class="s2">)</span><span class="s1">;</span>
  <span class="s2">} </span><span class="s1">else </span><span class="s2">{</span>
    <span class="s2">output.push(</span>
      <span class="s0">`import _export_sfc from '</span><span class="s2">${EXPORT_HELPER_ID}</span><span class="s0">'`</span><span class="s1">,</span>
      <span class="s0">`export default /*#__PURE__*/_export_sfc(_sfc_main, [</span><span class="s2">${attachedProps.map(([key</span><span class="s1">, </span><span class="s2">val]) =&gt; </span><span class="s0">`['</span><span class="s2">${key}</span><span class="s0">',</span><span class="s2">${val}</span><span class="s0">]`</span><span class="s2">).join(</span><span class="s0">&quot;,&quot;</span><span class="s2">)}</span><span class="s0">])`</span>
    <span class="s2">)</span><span class="s1">;</span>
  <span class="s2">}</span>
  <span class="s1">let </span><span class="s2">resolvedCode = output.join(</span><span class="s0">&quot;</span><span class="s1">\n</span><span class="s0">&quot;</span><span class="s2">)</span><span class="s1">;</span>
  <span class="s1">const </span><span class="s2">lang = descriptor.scriptSetup?.lang || descriptor.script?.lang</span><span class="s1">;</span>
  <span class="s1">if </span><span class="s2">(lang &amp;&amp; </span><span class="s3">/tsx?$/</span><span class="s2">.test(lang) &amp;&amp; !descriptor.script?.src) {</span>
    <span class="s1">const </span><span class="s2">{ code: code2</span><span class="s1">, </span><span class="s2">map } = </span><span class="s1">await </span><span class="s2">vite.transformWithEsbuild(</span>
      <span class="s2">resolvedCode</span><span class="s1">,</span>
      <span class="s2">filename</span><span class="s1">,</span>
      <span class="s2">{</span>
        <span class="s2">loader: </span><span class="s0">&quot;ts&quot;</span><span class="s1">,</span>
        <span class="s2">target: </span><span class="s0">&quot;esnext&quot;</span><span class="s1">,</span>
        <span class="s2">sourcemap: options.sourceMap</span>
      <span class="s2">}</span><span class="s1">,</span>
      <span class="s2">resolvedMap</span>
    <span class="s2">)</span><span class="s1">;</span>
    <span class="s2">resolvedCode = code2</span><span class="s1">;</span>
    <span class="s2">resolvedMap = resolvedMap ? map : resolvedMap</span><span class="s1">;</span>
  <span class="s2">}</span>
  <span class="s1">return </span><span class="s2">{</span>
    <span class="s2">code: resolvedCode</span><span class="s1">,</span>
    <span class="s2">map: resolvedMap || {</span>
      <span class="s2">mappings: </span><span class="s0">&quot;&quot;</span>
    <span class="s2">}</span><span class="s1">,</span>
    <span class="s2">meta: {</span>
      <span class="s2">vite: {</span>
        <span class="s2">lang: descriptor.script?.lang || descriptor.scriptSetup?.lang || </span><span class="s0">&quot;js&quot;</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
  <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s2">async </span><span class="s1">function </span><span class="s2">genTemplateCode(descriptor</span><span class="s1">, </span><span class="s2">options</span><span class="s1">, </span><span class="s2">pluginContext</span><span class="s1">, </span><span class="s2">ssr) {</span>
  <span class="s1">const </span><span class="s2">template = descriptor.template</span><span class="s1">;</span>
  <span class="s1">const </span><span class="s2">hasScoped = descriptor.styles.some((style) =&gt; style.scoped)</span><span class="s1">;</span>
  <span class="s1">if </span><span class="s2">(!template.lang &amp;&amp; !template.src) {</span>
    <span class="s1">return </span><span class="s2">transformTemplateInMain(</span>
      <span class="s2">template.content</span><span class="s1">,</span>
      <span class="s2">descriptor</span><span class="s1">,</span>
      <span class="s2">options</span><span class="s1">,</span>
      <span class="s2">pluginContext</span><span class="s1">,</span>
      <span class="s2">ssr</span>
    <span class="s2">)</span><span class="s1">;</span>
  <span class="s2">} </span><span class="s1">else </span><span class="s2">{</span>
    <span class="s1">if </span><span class="s2">(template.src) {</span>
      <span class="s1">await </span><span class="s2">linkSrcToDescriptor(</span>
        <span class="s2">template.src</span><span class="s1">,</span>
        <span class="s2">descriptor</span><span class="s1">,</span>
        <span class="s2">pluginContext</span><span class="s1">,</span>
        <span class="s2">hasScoped</span>
      <span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">src = template.src || descriptor.filename</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">srcQuery = template.src ? hasScoped ? </span><span class="s0">`&amp;src=</span><span class="s2">${descriptor.id}</span><span class="s0">` </span><span class="s2">: </span><span class="s0">&quot;&amp;src=true&quot; </span><span class="s2">: </span><span class="s0">&quot;&quot;</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">scopedQuery = hasScoped ? </span><span class="s0">`&amp;scoped=</span><span class="s2">${descriptor.id}</span><span class="s0">` </span><span class="s2">: </span><span class="s0">``</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">attrsQuery = attrsToQuery(template.attrs</span><span class="s1">, </span><span class="s0">&quot;js&quot;</span><span class="s1">, true</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">query = </span><span class="s0">`?vue&amp;type=template</span><span class="s2">${srcQuery}${scopedQuery}${attrsQuery}</span><span class="s0">`</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">request = JSON.stringify(src + query)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">renderFnName = ssr ? </span><span class="s0">&quot;ssrRender&quot; </span><span class="s2">: </span><span class="s0">&quot;render&quot;</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">{</span>
      <span class="s2">code: </span><span class="s0">`import { </span><span class="s2">${renderFnName} </span><span class="s0">as _sfc_</span><span class="s2">${renderFnName} </span><span class="s0">} from </span><span class="s2">${request}</span><span class="s0">`</span><span class="s1">,</span>
      <span class="s2">map: </span><span class="s1">void </span><span class="s3">0</span>
    <span class="s2">}</span><span class="s1">;</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s2">async </span><span class="s1">function </span><span class="s2">genScriptCode(descriptor</span><span class="s1">, </span><span class="s2">options</span><span class="s1">, </span><span class="s2">pluginContext</span><span class="s1">, </span><span class="s2">ssr) {</span>
  <span class="s1">let </span><span class="s2">scriptCode = </span><span class="s0">`const _sfc_main = {}`</span><span class="s1">;</span>
  <span class="s1">let </span><span class="s2">map</span><span class="s1">;</span>
  <span class="s1">const </span><span class="s2">script = resolveScript(descriptor</span><span class="s1">, </span><span class="s2">options</span><span class="s1">, </span><span class="s2">ssr)</span><span class="s1">;</span>
  <span class="s1">if </span><span class="s2">(script) {</span>
    <span class="s1">if </span><span class="s2">((!script.lang || script.lang === </span><span class="s0">&quot;ts&quot; </span><span class="s2">&amp;&amp; options.devServer) &amp;&amp; !script.src) {</span>
      <span class="s1">const </span><span class="s2">userPlugins = options.script?.babelParserPlugins || []</span><span class="s1">;</span>
      <span class="s1">const </span><span class="s2">defaultPlugins = script.lang === </span><span class="s0">&quot;ts&quot; </span><span class="s2">? userPlugins.includes(</span><span class="s0">&quot;decorators&quot;</span><span class="s2">) ? [</span><span class="s0">&quot;typescript&quot;</span><span class="s2">] : [</span><span class="s0">&quot;typescript&quot;</span><span class="s1">, </span><span class="s0">&quot;decorators-legacy&quot;</span><span class="s2">] : []</span><span class="s1">;</span>
      <span class="s2">scriptCode = options.compiler.rewriteDefault(</span>
        <span class="s2">script.content</span><span class="s1">,</span>
        <span class="s0">&quot;_sfc_main&quot;</span><span class="s1">,</span>
        <span class="s2">[...defaultPlugins</span><span class="s1">, </span><span class="s2">...userPlugins]</span>
      <span class="s2">)</span><span class="s1">;</span>
      <span class="s2">map = script.map</span><span class="s1">;</span>
    <span class="s2">} </span><span class="s1">else </span><span class="s2">{</span>
      <span class="s1">if </span><span class="s2">(script.src) {</span>
        <span class="s1">await </span><span class="s2">linkSrcToDescriptor(script.src</span><span class="s1">, </span><span class="s2">descriptor</span><span class="s1">, </span><span class="s2">pluginContext</span><span class="s1">, false</span><span class="s2">)</span><span class="s1">;</span>
      <span class="s2">}</span>
      <span class="s1">const </span><span class="s2">src = script.src || descriptor.filename</span><span class="s1">;</span>
      <span class="s1">const </span><span class="s2">langFallback = script.src &amp;&amp; path.extname(src).slice(</span><span class="s3">1</span><span class="s2">) || </span><span class="s0">&quot;js&quot;</span><span class="s1">;</span>
      <span class="s1">const </span><span class="s2">attrsQuery = attrsToQuery(script.attrs</span><span class="s1">, </span><span class="s2">langFallback)</span><span class="s1">;</span>
      <span class="s1">const </span><span class="s2">srcQuery = script.src ? </span><span class="s0">`&amp;src=true` </span><span class="s2">: </span><span class="s0">``</span><span class="s1">;</span>
      <span class="s1">const </span><span class="s2">query = </span><span class="s0">`?vue&amp;type=script</span><span class="s2">${srcQuery}${attrsQuery}</span><span class="s0">`</span><span class="s1">;</span>
      <span class="s1">const </span><span class="s2">request = JSON.stringify(src + query)</span><span class="s1">;</span>
      <span class="s2">scriptCode = </span><span class="s0">`import _sfc_main from </span><span class="s2">${request}</span>
<span class="s0">export * from </span><span class="s2">${request}</span><span class="s0">`</span><span class="s1">;</span>
    <span class="s2">}</span>
  <span class="s2">}</span>
  <span class="s1">return </span><span class="s2">{</span>
    <span class="s2">code: scriptCode</span><span class="s1">,</span>
    <span class="s2">map</span>
  <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s2">async </span><span class="s1">function </span><span class="s2">genStyleCode(descriptor</span><span class="s1">, </span><span class="s2">pluginContext</span><span class="s1">, </span><span class="s2">asCustomElement</span><span class="s1">, </span><span class="s2">attachedProps) {</span>
  <span class="s1">let </span><span class="s2">stylesCode = </span><span class="s0">``</span><span class="s1">;</span>
  <span class="s1">let </span><span class="s2">cssModulesMap</span><span class="s1">;</span>
  <span class="s1">if </span><span class="s2">(descriptor.styles.length) {</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s3">0</span><span class="s1">; </span><span class="s2">i &lt; descriptor.styles.length</span><span class="s1">; </span><span class="s2">i++) {</span>
      <span class="s1">const </span><span class="s2">style = descriptor.styles[i]</span><span class="s1">;</span>
      <span class="s1">if </span><span class="s2">(style.src) {</span>
        <span class="s1">await </span><span class="s2">linkSrcToDescriptor(</span>
          <span class="s2">style.src</span><span class="s1">,</span>
          <span class="s2">descriptor</span><span class="s1">,</span>
          <span class="s2">pluginContext</span><span class="s1">,</span>
          <span class="s2">style.scoped</span>
        <span class="s2">)</span><span class="s1">;</span>
      <span class="s2">}</span>
      <span class="s1">const </span><span class="s2">src = style.src || descriptor.filename</span><span class="s1">;</span>
      <span class="s1">const </span><span class="s2">attrsQuery = attrsToQuery(style.attrs</span><span class="s1">, </span><span class="s0">&quot;css&quot;</span><span class="s2">)</span><span class="s1">;</span>
      <span class="s1">const </span><span class="s2">srcQuery = style.src ? style.scoped ? </span><span class="s0">`&amp;src=</span><span class="s2">${descriptor.id}</span><span class="s0">` </span><span class="s2">: </span><span class="s0">&quot;&amp;src=true&quot; </span><span class="s2">: </span><span class="s0">&quot;&quot;</span><span class="s1">;</span>
      <span class="s1">const </span><span class="s2">directQuery = asCustomElement ? </span><span class="s0">`&amp;inline` </span><span class="s2">: </span><span class="s0">``</span><span class="s1">;</span>
      <span class="s1">const </span><span class="s2">scopedQuery = style.scoped ? </span><span class="s0">`&amp;scoped=</span><span class="s2">${descriptor.id}</span><span class="s0">` </span><span class="s2">: </span><span class="s0">``</span><span class="s1">;</span>
      <span class="s1">const </span><span class="s2">query = </span><span class="s0">`?vue&amp;type=style&amp;index=</span><span class="s2">${i}${srcQuery}${directQuery}${scopedQuery}</span><span class="s0">`</span><span class="s1">;</span>
      <span class="s1">const </span><span class="s2">styleRequest = src + query + attrsQuery</span><span class="s1">;</span>
      <span class="s1">if </span><span class="s2">(style.module) {</span>
        <span class="s1">if </span><span class="s2">(asCustomElement) {</span>
          <span class="s1">throw new </span><span class="s2">Error(</span>
            <span class="s0">`&lt;style module&gt; is not supported in custom elements mode.`</span>
          <span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">const </span><span class="s2">[importCode</span><span class="s1">, </span><span class="s2">nameMap] = genCSSModulesCode(</span>
          <span class="s2">i</span><span class="s1">,</span>
          <span class="s2">styleRequest</span><span class="s1">,</span>
          <span class="s2">style.module</span>
        <span class="s2">)</span><span class="s1">;</span>
        <span class="s2">stylesCode += importCode</span><span class="s1">;</span>
        <span class="s2">Object.assign(cssModulesMap || (cssModulesMap = {})</span><span class="s1">, </span><span class="s2">nameMap)</span><span class="s1">;</span>
      <span class="s2">} </span><span class="s1">else </span><span class="s2">{</span>
        <span class="s1">if </span><span class="s2">(asCustomElement) {</span>
          <span class="s2">stylesCode += </span><span class="s0">`</span>
<span class="s0">import _style_</span><span class="s2">${i} </span><span class="s0">from </span><span class="s2">${JSON.stringify(</span>
            <span class="s2">styleRequest</span>
          <span class="s2">)}</span><span class="s0">`</span><span class="s1">;</span>
        <span class="s2">} </span><span class="s1">else </span><span class="s2">{</span>
          <span class="s2">stylesCode += </span><span class="s0">`</span>
<span class="s0">import </span><span class="s2">${JSON.stringify(styleRequest)}</span><span class="s0">`</span><span class="s1">;</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(asCustomElement) {</span>
      <span class="s2">attachedProps.push([</span>
        <span class="s0">`styles`</span><span class="s1">,</span>
        <span class="s0">`[</span><span class="s2">${descriptor.styles.map((_</span><span class="s1">, </span><span class="s2">i) =&gt; </span><span class="s0">`_style_</span><span class="s2">${i}</span><span class="s0">`</span><span class="s2">).join(</span><span class="s0">&quot;,&quot;</span><span class="s2">)}</span><span class="s0">]`</span>
      <span class="s2">])</span><span class="s1">;</span>
    <span class="s2">}</span>
  <span class="s2">}</span>
  <span class="s1">if </span><span class="s2">(cssModulesMap) {</span>
    <span class="s1">const </span><span class="s2">mappingCode = Object.entries(cssModulesMap).reduce(</span>
      <span class="s2">(code</span><span class="s1">, </span><span class="s2">[key</span><span class="s1">, </span><span class="s2">value]) =&gt; code + </span><span class="s0">`&quot;</span><span class="s2">${key}</span><span class="s0">&quot;:</span><span class="s2">${value}</span><span class="s0">, 
`</span><span class="s1">,</span>
      <span class="s0">&quot;{</span><span class="s1">\n</span><span class="s0">&quot;</span>
    <span class="s2">) + </span><span class="s0">&quot;}&quot;</span><span class="s1">;</span>
    <span class="s2">stylesCode += </span><span class="s0">`</span>
<span class="s0">const cssModules = </span><span class="s2">${mappingCode}</span><span class="s0">`</span><span class="s1">;</span>
    <span class="s2">attachedProps.push([</span><span class="s0">`__cssModules`</span><span class="s1">, </span><span class="s0">`cssModules`</span><span class="s2">])</span><span class="s1">;</span>
  <span class="s2">}</span>
  <span class="s1">return </span><span class="s2">stylesCode</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">genCSSModulesCode(index</span><span class="s1">, </span><span class="s2">request</span><span class="s1">, </span><span class="s2">moduleName) {</span>
  <span class="s1">const </span><span class="s2">styleVar = </span><span class="s0">`style</span><span class="s2">${index}</span><span class="s0">`</span><span class="s1">;</span>
  <span class="s1">const </span><span class="s2">exposedName = </span><span class="s1">typeof </span><span class="s2">moduleName === </span><span class="s0">&quot;string&quot; </span><span class="s2">? moduleName : </span><span class="s0">&quot;$style&quot;</span><span class="s1">;</span>
  <span class="s1">const </span><span class="s2">moduleRequest = request.replace(</span><span class="s3">/\.(\w+)$/</span><span class="s1">, </span><span class="s0">&quot;.module.$1&quot;</span><span class="s2">)</span><span class="s1">;</span>
  <span class="s1">return </span><span class="s2">[</span>
    <span class="s0">`</span>
<span class="s0">import </span><span class="s2">${styleVar} </span><span class="s0">from </span><span class="s2">${JSON.stringify(moduleRequest)}</span><span class="s0">`</span><span class="s1">,</span>
    <span class="s2">{ [exposedName]: styleVar }</span>
  <span class="s2">]</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s2">async </span><span class="s1">function </span><span class="s2">genCustomBlockCode(descriptor</span><span class="s1">, </span><span class="s2">pluginContext) {</span>
  <span class="s1">let </span><span class="s2">code = </span><span class="s0">&quot;&quot;</span><span class="s1">;</span>
  <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">index = </span><span class="s3">0</span><span class="s1">; </span><span class="s2">index &lt; descriptor.customBlocks.length</span><span class="s1">; </span><span class="s2">index++) {</span>
    <span class="s1">const </span><span class="s2">block = descriptor.customBlocks[index]</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(block.src) {</span>
      <span class="s1">await </span><span class="s2">linkSrcToDescriptor(block.src</span><span class="s1">, </span><span class="s2">descriptor</span><span class="s1">, </span><span class="s2">pluginContext</span><span class="s1">, false</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">src = block.src || descriptor.filename</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">attrsQuery = attrsToQuery(block.attrs</span><span class="s1">, </span><span class="s2">block.type)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">srcQuery = block.src ? </span><span class="s0">`&amp;src=true` </span><span class="s2">: </span><span class="s0">``</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">query = </span><span class="s0">`?vue&amp;type=</span><span class="s2">${block.type}</span><span class="s0">&amp;index=</span><span class="s2">${index}${srcQuery}${attrsQuery}</span><span class="s0">`</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">request = JSON.stringify(src + query)</span><span class="s1">;</span>
    <span class="s2">code += </span><span class="s0">`import block</span><span class="s2">${index} </span><span class="s0">from </span><span class="s2">${request}</span>
<span class="s0">`</span><span class="s1">;</span>
    <span class="s2">code += </span><span class="s0">`if (typeof block</span><span class="s2">${index} </span><span class="s0">=== 'function') block</span><span class="s2">${index}</span><span class="s0">(_sfc_main) 
`</span><span class="s1">;</span>
  <span class="s2">}</span>
  <span class="s1">return </span><span class="s2">code</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s2">async </span><span class="s1">function </span><span class="s2">linkSrcToDescriptor(src</span><span class="s1">, </span><span class="s2">descriptor</span><span class="s1">, </span><span class="s2">pluginContext</span><span class="s1">, </span><span class="s2">scoped) {</span>
  <span class="s1">const </span><span class="s2">srcFile = (</span><span class="s1">await </span><span class="s2">pluginContext.resolve(src</span><span class="s1">, </span><span class="s2">descriptor.filename))?.id || src</span><span class="s1">;</span>
  <span class="s2">setSrcDescriptor(srcFile.replace(</span><span class="s3">/\?.*$/</span><span class="s1">, </span><span class="s0">&quot;&quot;</span><span class="s2">)</span><span class="s1">, </span><span class="s2">descriptor</span><span class="s1">, </span><span class="s2">scoped)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">const </span><span class="s2">ignoreList = [</span><span class="s0">&quot;id&quot;</span><span class="s1">, </span><span class="s0">&quot;index&quot;</span><span class="s1">, </span><span class="s0">&quot;src&quot;</span><span class="s1">, </span><span class="s0">&quot;type&quot;</span><span class="s1">, </span><span class="s0">&quot;lang&quot;</span><span class="s1">, </span><span class="s0">&quot;module&quot;</span><span class="s1">, </span><span class="s0">&quot;scoped&quot;</span><span class="s2">]</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">attrsToQuery(attrs</span><span class="s1">, </span><span class="s2">langFallback</span><span class="s1">, </span><span class="s2">forceLangFallback = </span><span class="s1">false</span><span class="s2">) {</span>
  <span class="s1">let </span><span class="s2">query = </span><span class="s0">``</span><span class="s1">;</span>
  <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">name </span><span class="s1">in </span><span class="s2">attrs) {</span>
    <span class="s1">const </span><span class="s2">value = attrs[name]</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(!ignoreList.includes(name)) {</span>
      <span class="s2">query += </span><span class="s0">`&amp;</span><span class="s2">${encodeURIComponent(name)}${value ? </span><span class="s0">`=</span><span class="s2">${encodeURIComponent(value)}</span><span class="s0">` </span><span class="s2">: </span><span class="s0">``</span><span class="s2">}</span><span class="s0">`</span><span class="s1">;</span>
    <span class="s2">}</span>
  <span class="s2">}</span>
  <span class="s1">if </span><span class="s2">(langFallback || attrs.lang) {</span>
    <span class="s2">query += </span><span class="s0">`lang` </span><span class="s1">in </span><span class="s2">attrs ? forceLangFallback ? </span><span class="s0">`&amp;lang.</span><span class="s2">${langFallback}</span><span class="s0">` </span><span class="s2">: </span><span class="s0">`&amp;lang.</span><span class="s2">${attrs.lang}</span><span class="s0">` </span><span class="s2">: </span><span class="s0">`&amp;lang.</span><span class="s2">${langFallback}</span><span class="s0">`</span><span class="s1">;</span>
  <span class="s2">}</span>
  <span class="s1">return </span><span class="s2">query</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s2">async </span><span class="s1">function </span><span class="s2">transformStyle(code</span><span class="s1">, </span><span class="s2">descriptor</span><span class="s1">, </span><span class="s2">index</span><span class="s1">, </span><span class="s2">options</span><span class="s1">, </span><span class="s2">pluginContext</span><span class="s1">, </span><span class="s2">filename) {</span>
  <span class="s1">const </span><span class="s2">block = descriptor.styles[index]</span><span class="s1">;</span>
  <span class="s1">const </span><span class="s2">result = </span><span class="s1">await </span><span class="s2">options.compiler.compileStyleAsync({</span>
    <span class="s2">...options.style</span><span class="s1">,</span>
    <span class="s2">filename: descriptor.filename</span><span class="s1">,</span>
    <span class="s2">id: </span><span class="s0">`data-v-</span><span class="s2">${descriptor.id}</span><span class="s0">`</span><span class="s1">,</span>
    <span class="s2">isProd: options.isProduction</span><span class="s1">,</span>
    <span class="s2">source: code</span><span class="s1">,</span>
    <span class="s2">scoped: block.scoped</span><span class="s1">,</span>
    <span class="s2">...options.cssDevSourcemap ? {</span>
      <span class="s2">postcssOptions: {</span>
        <span class="s2">map: {</span>
          <span class="s2">from: filename</span><span class="s1">,</span>
          <span class="s2">inline: </span><span class="s1">false,</span>
          <span class="s2">annotation: </span><span class="s1">false</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
    <span class="s2">} : {}</span>
  <span class="s2">})</span><span class="s1">;</span>
  <span class="s1">if </span><span class="s2">(result.errors.length) {</span>
    <span class="s2">result.errors.forEach((error) =&gt; {</span>
      <span class="s1">if </span><span class="s2">(error.line &amp;&amp; error.column) {</span>
        <span class="s2">error.loc = {</span>
          <span class="s2">file: descriptor.filename</span><span class="s1">,</span>
          <span class="s2">line: error.line + block.loc.start.line</span><span class="s1">,</span>
          <span class="s2">column: error.column</span>
        <span class="s2">}</span><span class="s1">;</span>
      <span class="s2">}</span>
      <span class="s2">pluginContext.error(error)</span><span class="s1">;</span>
    <span class="s2">})</span><span class="s1">;</span>
    <span class="s1">return null;</span>
  <span class="s2">}</span>
  <span class="s1">const </span><span class="s2">map = result.map ? </span><span class="s1">await </span><span class="s2">vite.formatPostcssSourceMap(</span>
    <span class="s4">// version property of result.map is declared as string</span>
    <span class="s4">// but actually it is a number</span>
    <span class="s2">result.map</span><span class="s1">,</span>
    <span class="s2">filename</span>
  <span class="s2">) : { mappings: </span><span class="s0">&quot;&quot; </span><span class="s2">}</span><span class="s1">;</span>
  <span class="s1">return </span><span class="s2">{</span>
    <span class="s2">code: result.code</span><span class="s1">,</span>
    <span class="s2">map</span>
  <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s1">function </span><span class="s2">vuePlugin(rawOptions = {}) {</span>
  <span class="s1">const </span><span class="s2">{</span>
    <span class="s2">include = </span><span class="s3">/\.vue$/</span><span class="s1">,</span>
    <span class="s2">exclude</span><span class="s1">,</span>
    <span class="s2">customElement = </span><span class="s3">/\.ce\.vue$/</span><span class="s1">,</span>
    <span class="s2">reactivityTransform = </span><span class="s1">false</span>
  <span class="s2">} = rawOptions</span><span class="s1">;</span>
  <span class="s1">const </span><span class="s2">filter = vite.createFilter(include</span><span class="s1">, </span><span class="s2">exclude)</span><span class="s1">;</span>
  <span class="s1">const </span><span class="s2">customElementFilter = </span><span class="s1">typeof </span><span class="s2">customElement === </span><span class="s0">&quot;boolean&quot; </span><span class="s2">? () =&gt; customElement : vite.createFilter(customElement)</span><span class="s1">;</span>
  <span class="s1">const </span><span class="s2">refTransformFilter = reactivityTransform === </span><span class="s1">false </span><span class="s2">? () =&gt; </span><span class="s1">false </span><span class="s2">: reactivityTransform === </span><span class="s1">true </span><span class="s2">? vite.createFilter(</span><span class="s3">/\.(j|t)sx?$/</span><span class="s1">, </span><span class="s3">/node_modules/</span><span class="s2">) : vite.createFilter(reactivityTransform)</span><span class="s1">;</span>
  <span class="s1">let </span><span class="s2">options = {</span>
    <span class="s2">isProduction: process.env.NODE_ENV === </span><span class="s0">&quot;production&quot;</span><span class="s1">,</span>
    <span class="s2">compiler: </span><span class="s1">null,</span>
    <span class="s4">// to be set in buildStart</span>
    <span class="s2">...rawOptions</span><span class="s1">,</span>
    <span class="s2">include</span><span class="s1">,</span>
    <span class="s2">exclude</span><span class="s1">,</span>
    <span class="s2">customElement</span><span class="s1">,</span>
    <span class="s2">reactivityTransform</span><span class="s1">,</span>
    <span class="s2">root: process.cwd()</span><span class="s1">,</span>
    <span class="s2">sourceMap: </span><span class="s1">true,</span>
    <span class="s2">cssDevSourcemap: </span><span class="s1">false,</span>
    <span class="s2">devToolsEnabled: process.env.NODE_ENV !== </span><span class="s0">&quot;production&quot;</span>
  <span class="s2">}</span><span class="s1">;</span>
  <span class="s1">return </span><span class="s2">{</span>
    <span class="s2">name: </span><span class="s0">&quot;vite:vue&quot;</span><span class="s1">,</span>
    <span class="s2">handleHotUpdate(ctx) {</span>
      <span class="s1">if </span><span class="s2">(!filter(ctx.file)) {</span>
        <span class="s1">return;</span>
      <span class="s2">}</span>
      <span class="s1">return </span><span class="s2">handleHotUpdate(ctx</span><span class="s1">, </span><span class="s2">options)</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">,</span>
    <span class="s2">config(config) {</span>
      <span class="s1">return </span><span class="s2">{</span>
        <span class="s2">resolve: {</span>
          <span class="s2">dedupe: config.build?.ssr ? [] : [</span><span class="s0">&quot;vue&quot;</span><span class="s2">]</span>
        <span class="s2">}</span><span class="s1">,</span>
        <span class="s2">define: {</span>
          <span class="s2">__VUE_OPTIONS_API__: config.define?.__VUE_OPTIONS_API__ ?? </span><span class="s1">true,</span>
          <span class="s2">__VUE_PROD_DEVTOOLS__: config.define?.__VUE_PROD_DEVTOOLS__ ?? </span><span class="s1">false</span>
        <span class="s2">}</span><span class="s1">,</span>
        <span class="s2">ssr: {</span>
          <span class="s2">external: config.legacy?.buildSsrCjsExternalHeuristics ? [</span><span class="s0">&quot;vue&quot;</span><span class="s1">, </span><span class="s0">&quot;@vue/server-renderer&quot;</span><span class="s2">] : []</span>
        <span class="s2">}</span>
      <span class="s2">}</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">,</span>
    <span class="s2">configResolved(config) {</span>
      <span class="s2">options = {</span>
        <span class="s2">...options</span><span class="s1">,</span>
        <span class="s2">root: config.root</span><span class="s1">,</span>
        <span class="s2">sourceMap: config.command === </span><span class="s0">&quot;build&quot; </span><span class="s2">? !!config.build.sourcemap : </span><span class="s1">true,</span>
        <span class="s2">cssDevSourcemap: config.css?.devSourcemap ?? </span><span class="s1">false,</span>
        <span class="s2">isProduction: config.isProduction</span><span class="s1">,</span>
        <span class="s2">devToolsEnabled: !!config.define.__VUE_PROD_DEVTOOLS__ || !config.isProduction</span>
      <span class="s2">}</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">,</span>
    <span class="s2">configureServer(server) {</span>
      <span class="s2">options.devServer = server</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">,</span>
    <span class="s2">buildStart() {</span>
      <span class="s2">options.compiler = options.compiler || resolveCompiler(options.root)</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">,</span>
    <span class="s2">async resolveId(id) {</span>
      <span class="s1">if </span><span class="s2">(id === EXPORT_HELPER_ID) {</span>
        <span class="s1">return </span><span class="s2">id</span><span class="s1">;</span>
      <span class="s2">}</span>
      <span class="s1">if </span><span class="s2">(parseVueRequest(id).query.vue) {</span>
        <span class="s1">return </span><span class="s2">id</span><span class="s1">;</span>
      <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">,</span>
    <span class="s2">load(id</span><span class="s1">, </span><span class="s2">opt) {</span>
      <span class="s1">const </span><span class="s2">ssr = opt?.ssr === </span><span class="s1">true;</span>
      <span class="s1">if </span><span class="s2">(id === EXPORT_HELPER_ID) {</span>
        <span class="s1">return </span><span class="s2">helperCode</span><span class="s1">;</span>
      <span class="s2">}</span>
      <span class="s1">const </span><span class="s2">{ filename</span><span class="s1">, </span><span class="s2">query } = parseVueRequest(id)</span><span class="s1">;</span>
      <span class="s1">if </span><span class="s2">(query.vue) {</span>
        <span class="s1">if </span><span class="s2">(query.src) {</span>
          <span class="s1">return </span><span class="s2">fs.readFileSync(filename</span><span class="s1">, </span><span class="s0">&quot;utf-8&quot;</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">const </span><span class="s2">descriptor = getDescriptor(filename</span><span class="s1">, </span><span class="s2">options)</span><span class="s1">;</span>
        <span class="s1">let </span><span class="s2">block</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(query.type === </span><span class="s0">&quot;script&quot;</span><span class="s2">) {</span>
          <span class="s2">block = getResolvedScript(descriptor</span><span class="s1">, </span><span class="s2">ssr)</span><span class="s1">;</span>
        <span class="s2">} </span><span class="s1">else if </span><span class="s2">(query.type === </span><span class="s0">&quot;template&quot;</span><span class="s2">) {</span>
          <span class="s2">block = descriptor.template</span><span class="s1">;</span>
        <span class="s2">} </span><span class="s1">else if </span><span class="s2">(query.type === </span><span class="s0">&quot;style&quot;</span><span class="s2">) {</span>
          <span class="s2">block = descriptor.styles[query.index]</span><span class="s1">;</span>
        <span class="s2">} </span><span class="s1">else if </span><span class="s2">(query.index != </span><span class="s1">null</span><span class="s2">) {</span>
          <span class="s2">block = descriptor.customBlocks[query.index]</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(block) {</span>
          <span class="s1">return </span><span class="s2">{</span>
            <span class="s2">code: block.content</span><span class="s1">,</span>
            <span class="s2">map: block.map</span>
          <span class="s2">}</span><span class="s1">;</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">,</span>
    <span class="s2">transform(code</span><span class="s1">, </span><span class="s2">id</span><span class="s1">, </span><span class="s2">opt) {</span>
      <span class="s1">const </span><span class="s2">ssr = opt?.ssr === </span><span class="s1">true;</span>
      <span class="s1">const </span><span class="s2">{ filename</span><span class="s1">, </span><span class="s2">query } = parseVueRequest(id)</span><span class="s1">;</span>
      <span class="s1">if </span><span class="s2">(query.raw || query.url) {</span>
        <span class="s1">return;</span>
      <span class="s2">}</span>
      <span class="s1">if </span><span class="s2">(!filter(filename) &amp;&amp; !query.vue) {</span>
        <span class="s1">if </span><span class="s2">(!query.vue &amp;&amp; refTransformFilter(filename) &amp;&amp; options.compiler.shouldTransformRef(code)) {</span>
          <span class="s1">return </span><span class="s2">options.compiler.transformRef(code</span><span class="s1">, </span><span class="s2">{</span>
            <span class="s2">filename</span><span class="s1">,</span>
            <span class="s2">sourceMap: </span><span class="s1">true</span>
          <span class="s2">})</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">return;</span>
      <span class="s2">}</span>
      <span class="s1">if </span><span class="s2">(!query.vue) {</span>
        <span class="s1">return </span><span class="s2">transformMain(</span>
          <span class="s2">code</span><span class="s1">,</span>
          <span class="s2">filename</span><span class="s1">,</span>
          <span class="s2">options</span><span class="s1">,</span>
          <span class="s1">this,</span>
          <span class="s2">ssr</span><span class="s1">,</span>
          <span class="s2">customElementFilter(filename)</span>
        <span class="s2">)</span><span class="s1">;</span>
      <span class="s2">} </span><span class="s1">else </span><span class="s2">{</span>
        <span class="s1">const </span><span class="s2">descriptor = query.src ? getSrcDescriptor(filename</span><span class="s1">, </span><span class="s2">query) : getDescriptor(filename</span><span class="s1">, </span><span class="s2">options)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(query.type === </span><span class="s0">&quot;template&quot;</span><span class="s2">) {</span>
          <span class="s1">return </span><span class="s2">transformTemplateAsModule(code</span><span class="s1">, </span><span class="s2">descriptor</span><span class="s1">, </span><span class="s2">options</span><span class="s1">, this, </span><span class="s2">ssr)</span><span class="s1">;</span>
        <span class="s2">} </span><span class="s1">else if </span><span class="s2">(query.type === </span><span class="s0">&quot;style&quot;</span><span class="s2">) {</span>
          <span class="s1">return </span><span class="s2">transformStyle(</span>
            <span class="s2">code</span><span class="s1">,</span>
            <span class="s2">descriptor</span><span class="s1">,</span>
            <span class="s2">Number(query.index)</span><span class="s1">,</span>
            <span class="s2">options</span><span class="s1">,</span>
            <span class="s1">this,</span>
            <span class="s2">filename</span>
          <span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
  <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s2">module.exports = vuePlugin</span><span class="s1">;</span>
<span class="s2">module.exports.default = vuePlugin</span><span class="s1">;</span>
<span class="s2">module.exports.parseVueRequest = parseVueRequest</span><span class="s1">;</span></pre>
</body>
</html>