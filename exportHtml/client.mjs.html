<html>
<head>
<title>client.mjs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
client.mjs</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s2">'@vite/env'</span><span class="s0">;</span>

<span class="s0">const </span><span class="s1">base$1 = __BASE__ || </span><span class="s2">'/'</span><span class="s0">;</span>
<span class="s3">// set :host styles to make playwright detect the element as visible</span>
<span class="s0">const </span><span class="s1">template = </span><span class="s3">/*html*/ </span><span class="s2">`</span>
<span class="s2">&lt;style&gt; 
:host { 
  position: fixed; 
  top: 0; 
  left: 0; 
  width: 100%; 
  height: 100%; 
  z-index: 99999; 
  --monospace: 'SFMono-Regular', Consolas, 
  'Liberation Mono', Menlo, Courier, monospace; 
  --red: #ff5555; 
  --yellow: #e2aa53; 
  --purple: #cfa4ff; 
  --cyan: #2dd9da; 
  --dim: #c9c9c9; 
 
  --window-background: #181818; 
  --window-color: #d8d8d8; 
} 
 
.backdrop { 
  position: fixed; 
  z-index: 99999; 
  top: 0; 
  left: 0; 
  width: 100%; 
  height: 100%; 
  overflow-y: scroll; 
  margin: 0; 
  background: rgba(0, 0, 0, 0.66); 
} 
 
.window { 
  font-family: var(--monospace); 
  line-height: 1.5; 
  width: 800px; 
  color: var(--window-color); 
  margin: 30px auto; 
  padding: 25px 40px; 
  position: relative; 
  background: var(--window-background); 
  border-radius: 6px 6px 8px 8px; 
  box-shadow: 0 19px 38px rgba(0,0,0,0.30), 0 15px 12px rgba(0,0,0,0.22); 
  overflow: hidden; 
  border-top: 8px solid var(--red); 
  direction: ltr; 
  text-align: left; 
} 
 
pre { 
  font-family: var(--monospace); 
  font-size: 16px; 
  margin-top: 0; 
  margin-bottom: 1em; 
  overflow-x: scroll; 
  scrollbar-width: none; 
} 
 
pre::-webkit-scrollbar { 
  display: none; 
} 
 
.message { 
  line-height: 1.3; 
  font-weight: 600; 
  white-space: pre-wrap; 
} 
 
.message-body { 
  color: var(--red); 
} 
 
.plugin { 
  color: var(--purple); 
} 
 
.file { 
  color: var(--cyan); 
  margin-bottom: 0; 
  white-space: pre-wrap; 
  word-break: break-all; 
} 
 
.frame { 
  color: var(--yellow); 
} 
 
.stack { 
  font-size: 13px; 
  color: var(--dim); 
} 
 
.tip { 
  font-size: 13px; 
  color: #999; 
  border-top: 1px dotted #999; 
  padding-top: 13px; 
} 
 
code { 
  font-size: 13px; 
  font-family: var(--monospace); 
  color: var(--yellow); 
} 
 
.file-link { 
  text-decoration: underline; 
  cursor: pointer; 
} 
&lt;/style&gt; 
&lt;div class=&quot;backdrop&quot; part=&quot;backdrop&quot;&gt; 
  &lt;div class=&quot;window&quot; part=&quot;window&quot;&gt; 
    &lt;pre class=&quot;message&quot; part=&quot;message&quot;&gt;&lt;span class=&quot;plugin&quot; part=&quot;plugin&quot;&gt;&lt;/span&gt;&lt;span class=&quot;message-body&quot; part=&quot;message-body&quot;&gt;&lt;/span&gt;&lt;/pre&gt; 
    &lt;pre class=&quot;file&quot; part=&quot;file&quot;&gt;&lt;/pre&gt; 
    &lt;pre class=&quot;frame&quot; part=&quot;frame&quot;&gt;&lt;/pre&gt; 
    &lt;pre class=&quot;stack&quot; part=&quot;stack&quot;&gt;&lt;/pre&gt; 
    &lt;div class=&quot;tip&quot; part=&quot;tip&quot;&gt; 
      Click outside or fix the code to dismiss.&lt;br&gt; 
      You can also disable this overlay by setting 
      &lt;code part=&quot;config-option-name&quot;&gt;server.hmr.overlay&lt;/code&gt; to &lt;code part=&quot;config-option-value&quot;&gt;false&lt;/code&gt; in &lt;code part=&quot;config-file-name&quot;&gt;vite.config.js.&lt;/code&gt; 
    &lt;/div&gt; 
  &lt;/div&gt; 
&lt;/div&gt; 
`</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">fileRE = </span><span class="s4">/(?:[a-zA-Z]:\\|\/).*?:\d+:\d+/g</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">codeframeRE = </span><span class="s4">/^(?:&gt;?\s+\d+\s+\|.*|\s+\|\s*\^.*)\r?\n/gm</span><span class="s0">;</span>
<span class="s3">// Allow `ErrorOverlay` to extend `HTMLElement` even in environments where</span>
<span class="s3">// `HTMLElement` was not originally defined.</span>
<span class="s0">const </span><span class="s1">{ HTMLElement = </span><span class="s0">class </span><span class="s1">{</span>
<span class="s1">} } = globalThis</span><span class="s0">;</span>
<span class="s0">class </span><span class="s1">ErrorOverlay </span><span class="s0">extends </span><span class="s1">HTMLElement {</span>
    <span class="s1">constructor(err</span><span class="s0">, </span><span class="s1">links = </span><span class="s0">true</span><span class="s1">) {</span>
        <span class="s0">var </span><span class="s1">_a</span><span class="s0">;</span>
        <span class="s0">super</span><span class="s1">()</span><span class="s0">;</span>
        <span class="s0">this</span><span class="s1">.root = </span><span class="s0">this</span><span class="s1">.attachShadow({ mode: </span><span class="s2">'open' </span><span class="s1">})</span><span class="s0">;</span>
        <span class="s0">this</span><span class="s1">.root.innerHTML = template</span><span class="s0">;</span>
        <span class="s1">codeframeRE.lastIndex = </span><span class="s4">0</span><span class="s0">;</span>
        <span class="s0">const </span><span class="s1">hasFrame = err.frame &amp;&amp; codeframeRE.test(err.frame)</span><span class="s0">;</span>
        <span class="s0">const </span><span class="s1">message = hasFrame</span>
            <span class="s1">? err.message.replace(codeframeRE</span><span class="s0">, </span><span class="s2">''</span><span class="s1">)</span>
            <span class="s1">: err.message</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(err.plugin) {</span>
            <span class="s0">this</span><span class="s1">.text(</span><span class="s2">'.plugin'</span><span class="s0">, </span><span class="s2">`[plugin:</span><span class="s1">${err.plugin}</span><span class="s2">] `</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">this</span><span class="s1">.text(</span><span class="s2">'.message-body'</span><span class="s0">, </span><span class="s1">message.trim())</span><span class="s0">;</span>
        <span class="s0">const </span><span class="s1">[file] = (((_a = err.loc) === </span><span class="s0">null </span><span class="s1">|| _a === </span><span class="s0">void </span><span class="s4">0 </span><span class="s1">? </span><span class="s0">void </span><span class="s4">0 </span><span class="s1">: _a.file) || err.id || </span><span class="s2">'unknown file'</span><span class="s1">).split(</span><span class="s2">`?`</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(err.loc) {</span>
            <span class="s0">this</span><span class="s1">.text(</span><span class="s2">'.file'</span><span class="s0">, </span><span class="s2">`</span><span class="s1">${file}</span><span class="s2">:</span><span class="s1">${err.loc.line}</span><span class="s2">:</span><span class="s1">${err.loc.column}</span><span class="s2">`</span><span class="s0">, </span><span class="s1">links)</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">else if </span><span class="s1">(err.id) {</span>
            <span class="s0">this</span><span class="s1">.text(</span><span class="s2">'.file'</span><span class="s0">, </span><span class="s1">file)</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(hasFrame) {</span>
            <span class="s0">this</span><span class="s1">.text(</span><span class="s2">'.frame'</span><span class="s0">, </span><span class="s1">err.frame.trim())</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">this</span><span class="s1">.text(</span><span class="s2">'.stack'</span><span class="s0">, </span><span class="s1">err.stack</span><span class="s0">, </span><span class="s1">links)</span><span class="s0">;</span>
        <span class="s0">this</span><span class="s1">.root.querySelector(</span><span class="s2">'.window'</span><span class="s1">).addEventListener(</span><span class="s2">'click'</span><span class="s0">, </span><span class="s1">(e) =&gt; {</span>
            <span class="s1">e.stopPropagation()</span><span class="s0">;</span>
        <span class="s1">})</span><span class="s0">;</span>
        <span class="s0">this</span><span class="s1">.addEventListener(</span><span class="s2">'click'</span><span class="s0">, </span><span class="s1">() =&gt; {</span>
            <span class="s0">this</span><span class="s1">.close()</span><span class="s0">;</span>
        <span class="s1">})</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s1">text(selector</span><span class="s0">, </span><span class="s1">text</span><span class="s0">, </span><span class="s1">linkFiles = </span><span class="s0">false</span><span class="s1">) {</span>
        <span class="s0">const </span><span class="s1">el = </span><span class="s0">this</span><span class="s1">.root.querySelector(selector)</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(!linkFiles) {</span>
            <span class="s1">el.textContent = text</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">else </span><span class="s1">{</span>
            <span class="s0">let </span><span class="s1">curIndex = </span><span class="s4">0</span><span class="s0">;</span>
            <span class="s0">let </span><span class="s1">match</span><span class="s0">;</span>
            <span class="s1">fileRE.lastIndex = </span><span class="s4">0</span><span class="s0">;</span>
            <span class="s0">while </span><span class="s1">((match = fileRE.exec(text))) {</span>
                <span class="s0">const </span><span class="s1">{ </span><span class="s4">0</span><span class="s1">: file</span><span class="s0">, </span><span class="s1">index } = match</span><span class="s0">;</span>
                <span class="s0">if </span><span class="s1">(index != </span><span class="s0">null</span><span class="s1">) {</span>
                    <span class="s0">const </span><span class="s1">frag = text.slice(curIndex</span><span class="s0">, </span><span class="s1">index)</span><span class="s0">;</span>
                    <span class="s1">el.appendChild(document.createTextNode(frag))</span><span class="s0">;</span>
                    <span class="s0">const </span><span class="s1">link = document.createElement(</span><span class="s2">'a'</span><span class="s1">)</span><span class="s0">;</span>
                    <span class="s1">link.textContent = file</span><span class="s0">;</span>
                    <span class="s1">link.className = </span><span class="s2">'file-link'</span><span class="s0">;</span>
                    <span class="s1">link.onclick = () =&gt; {</span>
                        <span class="s1">fetch(</span><span class="s2">`</span><span class="s1">${base$1}</span><span class="s2">__open-in-editor?file=` </span><span class="s1">+ encodeURIComponent(file))</span><span class="s0">;</span>
                    <span class="s1">}</span><span class="s0">;</span>
                    <span class="s1">el.appendChild(link)</span><span class="s0">;</span>
                    <span class="s1">curIndex += frag.length + file.length</span><span class="s0">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">close() {</span>
        <span class="s0">var </span><span class="s1">_a</span><span class="s0">;</span>
        <span class="s1">(_a = </span><span class="s0">this</span><span class="s1">.parentNode) === </span><span class="s0">null </span><span class="s1">|| _a === </span><span class="s0">void </span><span class="s4">0 </span><span class="s1">? </span><span class="s0">void </span><span class="s4">0 </span><span class="s1">: _a.removeChild(</span><span class="s0">this</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">const </span><span class="s1">overlayId = </span><span class="s2">'vite-error-overlay'</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">{ customElements } = globalThis</span><span class="s0">; </span><span class="s3">// Ensure `customElements` is defined before the next line.</span>
<span class="s0">if </span><span class="s1">(customElements &amp;&amp; !customElements.get(overlayId)) {</span>
    <span class="s1">customElements.define(overlayId</span><span class="s0">, </span><span class="s1">ErrorOverlay)</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s1">console.debug(</span><span class="s2">'[vite] connecting...'</span><span class="s1">)</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">importMetaUrl = </span><span class="s0">new </span><span class="s1">URL(</span><span class="s0">import</span><span class="s1">.meta.url)</span><span class="s0">;</span>
<span class="s3">// use server configuration, then fallback to inference</span>
<span class="s0">const </span><span class="s1">serverHost = __SERVER_HOST__</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">socketProtocol = __HMR_PROTOCOL__ || (importMetaUrl.protocol === </span><span class="s2">'https:' </span><span class="s1">? </span><span class="s2">'wss' </span><span class="s1">: </span><span class="s2">'ws'</span><span class="s1">)</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">hmrPort = __HMR_PORT__</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">socketHost = </span><span class="s2">`</span><span class="s1">${__HMR_HOSTNAME__ || importMetaUrl.hostname}</span><span class="s2">:</span><span class="s1">${hmrPort || importMetaUrl.port}${__HMR_BASE__}</span><span class="s2">`</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">directSocketHost = __HMR_DIRECT_TARGET__</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">base = __BASE__ || </span><span class="s2">'/'</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">messageBuffer = []</span><span class="s0">;</span>
<span class="s0">let </span><span class="s1">socket</span><span class="s0">;</span>
<span class="s0">try </span><span class="s1">{</span>
    <span class="s0">let </span><span class="s1">fallback</span><span class="s0">;</span>
    <span class="s3">// only use fallback when port is inferred to prevent confusion</span>
    <span class="s0">if </span><span class="s1">(!hmrPort) {</span>
        <span class="s1">fallback = () =&gt; {</span>
            <span class="s3">// fallback to connecting directly to the hmr server</span>
            <span class="s3">// for servers which does not support proxying websocket</span>
            <span class="s1">socket = setupWebSocket(socketProtocol</span><span class="s0">, </span><span class="s1">directSocketHost</span><span class="s0">, </span><span class="s1">() =&gt; {</span>
                <span class="s0">const </span><span class="s1">currentScriptHostURL = </span><span class="s0">new </span><span class="s1">URL(</span><span class="s0">import</span><span class="s1">.meta.url)</span><span class="s0">;</span>
                <span class="s0">const </span><span class="s1">currentScriptHost = currentScriptHostURL.host +</span>
                    <span class="s1">currentScriptHostURL.pathname.replace(</span><span class="s4">/@vite\/client$/</span><span class="s0">, </span><span class="s2">''</span><span class="s1">)</span><span class="s0">;</span>
                <span class="s1">console.error(</span><span class="s2">'[vite] failed to connect to websocket.</span><span class="s0">\n</span><span class="s2">' </span><span class="s1">+</span>
                    <span class="s2">'your current setup:</span><span class="s0">\n</span><span class="s2">' </span><span class="s1">+</span>
                    <span class="s2">`  (browser) </span><span class="s1">${currentScriptHost} </span><span class="s2">&lt;--[HTTP]--&gt; </span><span class="s1">${serverHost} </span><span class="s2">(server)</span><span class="s0">\n</span><span class="s2">` </span><span class="s1">+</span>
                    <span class="s2">`  (browser) </span><span class="s1">${socketHost} </span><span class="s2">&lt;--[WebSocket (failing)]--&gt; </span><span class="s1">${directSocketHost} </span><span class="s2">(server)</span><span class="s0">\n</span><span class="s2">` </span><span class="s1">+</span>
                    <span class="s2">'Check out your Vite / network configuration and https://vitejs.dev/config/server-options.html#server-hmr .'</span><span class="s1">)</span><span class="s0">;</span>
            <span class="s1">})</span><span class="s0">;</span>
            <span class="s1">socket.addEventListener(</span><span class="s2">'open'</span><span class="s0">, </span><span class="s1">() =&gt; {</span>
                <span class="s1">console.info(</span><span class="s2">'[vite] Direct websocket connection fallback. Check out https://vitejs.dev/config/server-options.html#server-hmr to remove the previous connection error.'</span><span class="s1">)</span><span class="s0">;</span>
            <span class="s1">}</span><span class="s0">, </span><span class="s1">{ once: </span><span class="s0">true </span><span class="s1">})</span><span class="s0">;</span>
        <span class="s1">}</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s1">socket = setupWebSocket(socketProtocol</span><span class="s0">, </span><span class="s1">socketHost</span><span class="s0">, </span><span class="s1">fallback)</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">catch </span><span class="s1">(error) {</span>
    <span class="s1">console.error(</span><span class="s2">`[vite] failed to connect to websocket (</span><span class="s1">${error}</span><span class="s2">). `</span><span class="s1">)</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">setupWebSocket(protocol</span><span class="s0">, </span><span class="s1">hostAndPath</span><span class="s0">, </span><span class="s1">onCloseWithoutOpen) {</span>
    <span class="s0">const </span><span class="s1">socket = </span><span class="s0">new </span><span class="s1">WebSocket(</span><span class="s2">`</span><span class="s1">${protocol}</span><span class="s2">://</span><span class="s1">${hostAndPath}</span><span class="s2">`</span><span class="s0">, </span><span class="s2">'vite-hmr'</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s0">let </span><span class="s1">isOpened = </span><span class="s0">false;</span>
    <span class="s1">socket.addEventListener(</span><span class="s2">'open'</span><span class="s0">, </span><span class="s1">() =&gt; {</span>
        <span class="s1">isOpened = </span><span class="s0">true;</span>
    <span class="s1">}</span><span class="s0">, </span><span class="s1">{ once: </span><span class="s0">true </span><span class="s1">})</span><span class="s0">;</span>
    <span class="s3">// Listen for messages</span>
    <span class="s1">socket.addEventListener(</span><span class="s2">'message'</span><span class="s0">, </span><span class="s1">async ({ data }) =&gt; {</span>
        <span class="s1">handleMessage(JSON.parse(data))</span><span class="s0">;</span>
    <span class="s1">})</span><span class="s0">;</span>
    <span class="s3">// ping server</span>
    <span class="s1">socket.addEventListener(</span><span class="s2">'close'</span><span class="s0">, </span><span class="s1">async ({ wasClean }) =&gt; {</span>
        <span class="s0">if </span><span class="s1">(wasClean)</span>
            <span class="s0">return;</span>
        <span class="s0">if </span><span class="s1">(!isOpened &amp;&amp; onCloseWithoutOpen) {</span>
            <span class="s1">onCloseWithoutOpen()</span><span class="s0">;</span>
            <span class="s0">return;</span>
        <span class="s1">}</span>
        <span class="s1">console.log(</span><span class="s2">`[vite] server connection lost. polling for restart...`</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s0">await </span><span class="s1">waitForSuccessfulPing(protocol</span><span class="s0">, </span><span class="s1">hostAndPath)</span><span class="s0">;</span>
        <span class="s1">location.reload()</span><span class="s0">;</span>
    <span class="s1">})</span><span class="s0">;</span>
    <span class="s0">return </span><span class="s1">socket</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">warnFailedFetch(err</span><span class="s0">, </span><span class="s1">path) {</span>
    <span class="s0">if </span><span class="s1">(!err.message.match(</span><span class="s2">'fetch'</span><span class="s1">)) {</span>
        <span class="s1">console.error(err)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s1">console.error(</span><span class="s2">`[hmr] Failed to reload </span><span class="s1">${path}</span><span class="s2">. ` </span><span class="s1">+</span>
        <span class="s2">`This could be due to syntax errors or importing non-existent ` </span><span class="s1">+</span>
        <span class="s2">`modules. (see errors above)`</span><span class="s1">)</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">cleanUrl(pathname) {</span>
    <span class="s0">const </span><span class="s1">url = </span><span class="s0">new </span><span class="s1">URL(pathname</span><span class="s0">, </span><span class="s1">location.toString())</span><span class="s0">;</span>
    <span class="s1">url.searchParams.delete(</span><span class="s2">'direct'</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s0">return </span><span class="s1">url.pathname + url.search</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">let </span><span class="s1">isFirstUpdate = </span><span class="s0">true;</span>
<span class="s0">const </span><span class="s1">outdatedLinkTags = </span><span class="s0">new </span><span class="s1">WeakSet()</span><span class="s0">;</span>
<span class="s1">async </span><span class="s0">function </span><span class="s1">handleMessage(payload) {</span>
    <span class="s0">switch </span><span class="s1">(payload.type) {</span>
        <span class="s0">case </span><span class="s2">'connected'</span><span class="s1">:</span>
            <span class="s1">console.debug(</span><span class="s2">`[vite] connected.`</span><span class="s1">)</span><span class="s0">;</span>
            <span class="s1">sendMessageBuffer()</span><span class="s0">;</span>
            <span class="s3">// proxy(nginx, docker) hmr ws maybe caused timeout,</span>
            <span class="s3">// so send ping package let ws keep alive.</span>
            <span class="s1">setInterval(() =&gt; {</span>
                <span class="s0">if </span><span class="s1">(socket.readyState === socket.OPEN) {</span>
                    <span class="s1">socket.send(</span><span class="s2">'{&quot;type&quot;:&quot;ping&quot;}'</span><span class="s1">)</span><span class="s0">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span><span class="s0">, </span><span class="s1">__HMR_TIMEOUT__)</span><span class="s0">;</span>
            <span class="s0">break;</span>
        <span class="s0">case </span><span class="s2">'update'</span><span class="s1">:</span>
            <span class="s1">notifyListeners(</span><span class="s2">'vite:beforeUpdate'</span><span class="s0">, </span><span class="s1">payload)</span><span class="s0">;</span>
            <span class="s3">// if this is the first update and there's already an error overlay, it</span>
            <span class="s3">// means the page opened with existing server compile error and the whole</span>
            <span class="s3">// module script failed to load (since one of the nested imports is 500).</span>
            <span class="s3">// in this case a normal update won't work and a full reload is needed.</span>
            <span class="s0">if </span><span class="s1">(isFirstUpdate &amp;&amp; hasErrorOverlay()) {</span>
                <span class="s1">window.location.reload()</span><span class="s0">;</span>
                <span class="s0">return;</span>
            <span class="s1">}</span>
            <span class="s0">else </span><span class="s1">{</span>
                <span class="s1">clearErrorOverlay()</span><span class="s0">;</span>
                <span class="s1">isFirstUpdate = </span><span class="s0">false;</span>
            <span class="s1">}</span>
            <span class="s0">await </span><span class="s1">Promise.all(payload.updates.map(async (update) =&gt; {</span>
                <span class="s0">if </span><span class="s1">(update.type === </span><span class="s2">'js-update'</span><span class="s1">) {</span>
                    <span class="s0">return </span><span class="s1">queueUpdate(fetchUpdate(update))</span><span class="s0">;</span>
                <span class="s1">}</span>
                <span class="s3">// css-update</span>
                <span class="s3">// this is only sent when a css file referenced with &lt;link&gt; is updated</span>
                <span class="s0">const </span><span class="s1">{ path</span><span class="s0">, </span><span class="s1">timestamp } = update</span><span class="s0">;</span>
                <span class="s0">const </span><span class="s1">searchUrl = cleanUrl(path)</span><span class="s0">;</span>
                <span class="s3">// can't use querySelector with `[href*=]` here since the link may be</span>
                <span class="s3">// using relative paths so we need to use link.href to grab the full</span>
                <span class="s3">// URL for the include check.</span>
                <span class="s0">const </span><span class="s1">el = Array.from(document.querySelectorAll(</span><span class="s2">'link'</span><span class="s1">)).find((e) =&gt; !outdatedLinkTags.has(e) &amp;&amp; cleanUrl(e.href).includes(searchUrl))</span><span class="s0">;</span>
                <span class="s0">if </span><span class="s1">(!el) {</span>
                    <span class="s0">return;</span>
                <span class="s1">}</span>
                <span class="s0">const </span><span class="s1">newPath = </span><span class="s2">`</span><span class="s1">${base}${searchUrl.slice(</span><span class="s4">1</span><span class="s1">)}${searchUrl.includes(</span><span class="s2">'?'</span><span class="s1">) ? </span><span class="s2">'&amp;' </span><span class="s1">: </span><span class="s2">'?'</span><span class="s1">}</span><span class="s2">t=</span><span class="s1">${timestamp}</span><span class="s2">`</span><span class="s0">;</span>
                <span class="s3">// rather than swapping the href on the existing tag, we will</span>
                <span class="s3">// create a new link tag. Once the new stylesheet has loaded we</span>
                <span class="s3">// will remove the existing link tag. This removes a Flash Of</span>
                <span class="s3">// Unstyled Content that can occur when swapping out the tag href</span>
                <span class="s3">// directly, as the new stylesheet has not yet been loaded.</span>
                <span class="s0">return new </span><span class="s1">Promise((resolve) =&gt; {</span>
                    <span class="s0">const </span><span class="s1">newLinkTag = el.cloneNode()</span><span class="s0">;</span>
                    <span class="s1">newLinkTag.href = </span><span class="s0">new </span><span class="s1">URL(newPath</span><span class="s0">, </span><span class="s1">el.href).href</span><span class="s0">;</span>
                    <span class="s0">const </span><span class="s1">removeOldEl = () =&gt; {</span>
                        <span class="s1">el.remove()</span><span class="s0">;</span>
                        <span class="s1">console.debug(</span><span class="s2">`[vite] css hot updated: </span><span class="s1">${searchUrl}</span><span class="s2">`</span><span class="s1">)</span><span class="s0">;</span>
                        <span class="s1">resolve()</span><span class="s0">;</span>
                    <span class="s1">}</span><span class="s0">;</span>
                    <span class="s1">newLinkTag.addEventListener(</span><span class="s2">'load'</span><span class="s0">, </span><span class="s1">removeOldEl)</span><span class="s0">;</span>
                    <span class="s1">newLinkTag.addEventListener(</span><span class="s2">'error'</span><span class="s0">, </span><span class="s1">removeOldEl)</span><span class="s0">;</span>
                    <span class="s1">outdatedLinkTags.add(el)</span><span class="s0">;</span>
                    <span class="s1">el.after(newLinkTag)</span><span class="s0">;</span>
                <span class="s1">})</span><span class="s0">;</span>
            <span class="s1">}))</span><span class="s0">;</span>
            <span class="s1">notifyListeners(</span><span class="s2">'vite:afterUpdate'</span><span class="s0">, </span><span class="s1">payload)</span><span class="s0">;</span>
            <span class="s0">break;</span>
        <span class="s0">case </span><span class="s2">'custom'</span><span class="s1">: {</span>
            <span class="s1">notifyListeners(payload.event</span><span class="s0">, </span><span class="s1">payload.data)</span><span class="s0">;</span>
            <span class="s0">break;</span>
        <span class="s1">}</span>
        <span class="s0">case </span><span class="s2">'full-reload'</span><span class="s1">:</span>
            <span class="s1">notifyListeners(</span><span class="s2">'vite:beforeFullReload'</span><span class="s0">, </span><span class="s1">payload)</span><span class="s0">;</span>
            <span class="s0">if </span><span class="s1">(payload.path &amp;&amp; payload.path.endsWith(</span><span class="s2">'.html'</span><span class="s1">)) {</span>
                <span class="s3">// if html file is edited, only reload the page if the browser is</span>
                <span class="s3">// currently on that page.</span>
                <span class="s0">const </span><span class="s1">pagePath = decodeURI(location.pathname)</span><span class="s0">;</span>
                <span class="s0">const </span><span class="s1">payloadPath = base + payload.path.slice(</span><span class="s4">1</span><span class="s1">)</span><span class="s0">;</span>
                <span class="s0">if </span><span class="s1">(pagePath === payloadPath ||</span>
                    <span class="s1">payload.path === </span><span class="s2">'/index.html' </span><span class="s1">||</span>
                    <span class="s1">(pagePath.endsWith(</span><span class="s2">'/'</span><span class="s1">) &amp;&amp; pagePath + </span><span class="s2">'index.html' </span><span class="s1">=== payloadPath)) {</span>
                    <span class="s1">location.reload()</span><span class="s0">;</span>
                <span class="s1">}</span>
                <span class="s0">return;</span>
            <span class="s1">}</span>
            <span class="s0">else </span><span class="s1">{</span>
                <span class="s1">location.reload()</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s0">break;</span>
        <span class="s0">case </span><span class="s2">'prune'</span><span class="s1">:</span>
            <span class="s1">notifyListeners(</span><span class="s2">'vite:beforePrune'</span><span class="s0">, </span><span class="s1">payload)</span><span class="s0">;</span>
            <span class="s3">// After an HMR update, some modules are no longer imported on the page</span>
            <span class="s3">// but they may have left behind side effects that need to be cleaned up</span>
            <span class="s3">// (.e.g style injections)</span>
            <span class="s3">// TODO Trigger their dispose callbacks.</span>
            <span class="s1">payload.paths.forEach((path) =&gt; {</span>
                <span class="s0">const </span><span class="s1">fn = pruneMap.get(path)</span><span class="s0">;</span>
                <span class="s0">if </span><span class="s1">(fn) {</span>
                    <span class="s1">fn(dataMap.get(path))</span><span class="s0">;</span>
                <span class="s1">}</span>
            <span class="s1">})</span><span class="s0">;</span>
            <span class="s0">break;</span>
        <span class="s0">case </span><span class="s2">'error'</span><span class="s1">: {</span>
            <span class="s1">notifyListeners(</span><span class="s2">'vite:error'</span><span class="s0">, </span><span class="s1">payload)</span><span class="s0">;</span>
            <span class="s0">const </span><span class="s1">err = payload.err</span><span class="s0">;</span>
            <span class="s0">if </span><span class="s1">(enableOverlay) {</span>
                <span class="s1">createErrorOverlay(err)</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s0">else </span><span class="s1">{</span>
                <span class="s1">console.error(</span><span class="s2">`[vite] Internal Server Error</span><span class="s0">\n</span><span class="s1">${err.message}</span><span class="s0">\n</span><span class="s1">${err.stack}</span><span class="s2">`</span><span class="s1">)</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s0">break;</span>
        <span class="s1">}</span>
        <span class="s0">default</span><span class="s1">: {</span>
            <span class="s0">const </span><span class="s1">check = payload</span><span class="s0">;</span>
            <span class="s0">return </span><span class="s1">check</span><span class="s0">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">notifyListeners(event</span><span class="s0">, </span><span class="s1">data) {</span>
    <span class="s0">const </span><span class="s1">cbs = customListenersMap.get(event)</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(cbs) {</span>
        <span class="s1">cbs.forEach((cb) =&gt; cb(data))</span><span class="s0">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">const </span><span class="s1">enableOverlay = __HMR_ENABLE_OVERLAY__</span><span class="s0">;</span>
<span class="s0">function </span><span class="s1">createErrorOverlay(err) {</span>
    <span class="s0">if </span><span class="s1">(!enableOverlay)</span>
        <span class="s0">return;</span>
    <span class="s1">clearErrorOverlay()</span><span class="s0">;</span>
    <span class="s1">document.body.appendChild(</span><span class="s0">new </span><span class="s1">ErrorOverlay(err))</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">clearErrorOverlay() {</span>
    <span class="s1">document</span>
        <span class="s1">.querySelectorAll(overlayId)</span>
        <span class="s1">.forEach((n) =&gt; n.close())</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">hasErrorOverlay() {</span>
    <span class="s0">return </span><span class="s1">document.querySelectorAll(overlayId).length</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">let </span><span class="s1">pending = </span><span class="s0">false;</span>
<span class="s0">let </span><span class="s1">queued = []</span><span class="s0">;</span>
<span class="s5">/**</span>
 <span class="s5">* buffer multiple hot updates triggered by the same src change</span>
 <span class="s5">* so that they are invoked in the same order they were sent.</span>
 <span class="s5">* (otherwise the order may be inconsistent because of the http request round trip)</span>
 <span class="s5">*/</span>
<span class="s1">async </span><span class="s0">function </span><span class="s1">queueUpdate(p) {</span>
    <span class="s1">queued.push(p)</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(!pending) {</span>
        <span class="s1">pending = </span><span class="s0">true;</span>
        <span class="s0">await </span><span class="s1">Promise.resolve()</span><span class="s0">;</span>
        <span class="s1">pending = </span><span class="s0">false;</span>
        <span class="s0">const </span><span class="s1">loading = [...queued]</span><span class="s0">;</span>
        <span class="s1">queued = []</span><span class="s0">;</span>
        <span class="s1">(</span><span class="s0">await </span><span class="s1">Promise.all(loading)).forEach((fn) =&gt; fn &amp;&amp; fn())</span><span class="s0">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s0">function </span><span class="s1">waitForSuccessfulPing(socketProtocol</span><span class="s0">, </span><span class="s1">hostAndPath</span><span class="s0">, </span><span class="s1">ms = </span><span class="s4">1000</span><span class="s1">) {</span>
    <span class="s0">const </span><span class="s1">pingHostProtocol = socketProtocol === </span><span class="s2">'wss' </span><span class="s1">? </span><span class="s2">'https' </span><span class="s1">: </span><span class="s2">'http'</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">ping = async () =&gt; {</span>
        <span class="s3">// A fetch on a websocket URL will return a successful promise with status 400,</span>
        <span class="s3">// but will reject a networking error.</span>
        <span class="s3">// When running on middleware mode, it returns status 426, and an cors error happens if mode is not no-cors</span>
        <span class="s0">try </span><span class="s1">{</span>
            <span class="s0">await </span><span class="s1">fetch(</span><span class="s2">`</span><span class="s1">${pingHostProtocol}</span><span class="s2">://</span><span class="s1">${hostAndPath}</span><span class="s2">`</span><span class="s0">, </span><span class="s1">{</span>
                <span class="s1">mode: </span><span class="s2">'no-cors'</span><span class="s0">,</span>
            <span class="s1">})</span><span class="s0">;</span>
            <span class="s0">return true;</span>
        <span class="s1">}</span>
        <span class="s0">catch </span><span class="s1">{ }</span>
        <span class="s0">return false;</span>
    <span class="s1">}</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(</span><span class="s0">await </span><span class="s1">ping()) {</span>
        <span class="s0">return;</span>
    <span class="s1">}</span>
    <span class="s0">await </span><span class="s1">wait(ms)</span><span class="s0">;</span>
    <span class="s3">// eslint-disable-next-line no-constant-condition</span>
    <span class="s0">while </span><span class="s1">(</span><span class="s0">true</span><span class="s1">) {</span>
        <span class="s0">if </span><span class="s1">(document.visibilityState === </span><span class="s2">'visible'</span><span class="s1">) {</span>
            <span class="s0">if </span><span class="s1">(</span><span class="s0">await </span><span class="s1">ping()) {</span>
                <span class="s0">break;</span>
            <span class="s1">}</span>
            <span class="s0">await </span><span class="s1">wait(ms)</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">else </span><span class="s1">{</span>
            <span class="s0">await </span><span class="s1">waitForWindowShow()</span><span class="s0">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">wait(ms) {</span>
    <span class="s0">return new </span><span class="s1">Promise((resolve) =&gt; setTimeout(resolve</span><span class="s0">, </span><span class="s1">ms))</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">waitForWindowShow() {</span>
    <span class="s0">return new </span><span class="s1">Promise((resolve) =&gt; {</span>
        <span class="s0">const </span><span class="s1">onChange = async () =&gt; {</span>
            <span class="s0">if </span><span class="s1">(document.visibilityState === </span><span class="s2">'visible'</span><span class="s1">) {</span>
                <span class="s1">resolve()</span><span class="s0">;</span>
                <span class="s1">document.removeEventListener(</span><span class="s2">'visibilitychange'</span><span class="s0">, </span><span class="s1">onChange)</span><span class="s0">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span><span class="s0">;</span>
        <span class="s1">document.addEventListener(</span><span class="s2">'visibilitychange'</span><span class="s0">, </span><span class="s1">onChange)</span><span class="s0">;</span>
    <span class="s1">})</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">const </span><span class="s1">sheetsMap = </span><span class="s0">new </span><span class="s1">Map()</span><span class="s0">;</span>
<span class="s3">// collect existing style elements that may have been inserted during SSR</span>
<span class="s3">// to avoid FOUC or duplicate styles</span>
<span class="s1">document.querySelectorAll(</span><span class="s2">'style[data-vite-dev-id]'</span><span class="s1">).forEach((el) =&gt; {</span>
    <span class="s1">sheetsMap.set(el.getAttribute(</span><span class="s2">'data-vite-dev-id'</span><span class="s1">)</span><span class="s0">, </span><span class="s1">el)</span><span class="s0">;</span>
<span class="s1">})</span><span class="s0">;</span>
<span class="s3">// all css imports should be inserted at the same position</span>
<span class="s3">// because after build it will be a single css file</span>
<span class="s0">let </span><span class="s1">lastInsertedStyle</span><span class="s0">;</span>
<span class="s0">function </span><span class="s1">updateStyle(id</span><span class="s0">, </span><span class="s1">content) {</span>
    <span class="s0">let </span><span class="s1">style = sheetsMap.get(id)</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(!style) {</span>
        <span class="s1">style = document.createElement(</span><span class="s2">'style'</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s1">style.setAttribute(</span><span class="s2">'type'</span><span class="s0">, </span><span class="s2">'text/css'</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s1">style.setAttribute(</span><span class="s2">'data-vite-dev-id'</span><span class="s0">, </span><span class="s1">id)</span><span class="s0">;</span>
        <span class="s1">style.textContent = content</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(!lastInsertedStyle) {</span>
            <span class="s1">document.head.appendChild(style)</span><span class="s0">;</span>
            <span class="s3">// reset lastInsertedStyle after async</span>
            <span class="s3">// because dynamically imported css will be splitted into a different file</span>
            <span class="s1">setTimeout(() =&gt; {</span>
                <span class="s1">lastInsertedStyle = undefined</span><span class="s0">;</span>
            <span class="s1">}</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">else </span><span class="s1">{</span>
            <span class="s1">lastInsertedStyle.insertAdjacentElement(</span><span class="s2">'afterend'</span><span class="s0">, </span><span class="s1">style)</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s1">lastInsertedStyle = style</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">else </span><span class="s1">{</span>
        <span class="s1">style.textContent = content</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s1">sheetsMap.set(id</span><span class="s0">, </span><span class="s1">style)</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">removeStyle(id) {</span>
    <span class="s0">const </span><span class="s1">style = sheetsMap.get(id)</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(style) {</span>
        <span class="s1">document.head.removeChild(style)</span><span class="s0">;</span>
        <span class="s1">sheetsMap.delete(id)</span><span class="s0">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s0">function </span><span class="s1">fetchUpdate({ path</span><span class="s0">, </span><span class="s1">acceptedPath</span><span class="s0">, </span><span class="s1">timestamp</span><span class="s0">, </span><span class="s1">explicitImportRequired</span><span class="s0">, </span><span class="s1">}) {</span>
    <span class="s0">const </span><span class="s1">mod = hotModulesMap.get(path)</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(!mod) {</span>
        <span class="s3">// In a code-splitting project,</span>
        <span class="s3">// it is common that the hot-updating module is not loaded yet.</span>
        <span class="s3">// https://github.com/vitejs/vite/issues/721</span>
        <span class="s0">return;</span>
    <span class="s1">}</span>
    <span class="s0">let </span><span class="s1">fetchedModule</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">isSelfUpdate = path === acceptedPath</span><span class="s0">;</span>
    <span class="s3">// determine the qualified callbacks before we re-import the modules</span>
    <span class="s0">const </span><span class="s1">qualifiedCallbacks = mod.callbacks.filter(({ deps }) =&gt; deps.includes(acceptedPath))</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(isSelfUpdate || qualifiedCallbacks.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s0">const </span><span class="s1">disposer = disposeMap.get(acceptedPath)</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(disposer)</span>
            <span class="s0">await </span><span class="s1">disposer(dataMap.get(acceptedPath))</span><span class="s0">;</span>
        <span class="s0">const </span><span class="s1">[acceptedPathWithoutQuery</span><span class="s0">, </span><span class="s1">query] = acceptedPath.split(</span><span class="s2">`?`</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s0">try </span><span class="s1">{</span>
            <span class="s1">fetchedModule = </span><span class="s0">await import</span><span class="s1">(</span>
            <span class="s3">/* @vite-ignore */</span>
            <span class="s1">base +</span>
                <span class="s1">acceptedPathWithoutQuery.slice(</span><span class="s4">1</span><span class="s1">) +</span>
                <span class="s2">`?</span><span class="s1">${explicitImportRequired ? </span><span class="s2">'import&amp;' </span><span class="s1">: </span><span class="s2">''</span><span class="s1">}</span><span class="s2">t=</span><span class="s1">${timestamp}${query ? </span><span class="s2">`&amp;</span><span class="s1">${query}</span><span class="s2">` </span><span class="s1">: </span><span class="s2">''</span><span class="s1">}</span><span class="s2">`</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">catch </span><span class="s1">(e) {</span>
            <span class="s1">warnFailedFetch(e</span><span class="s0">, </span><span class="s1">acceptedPath)</span><span class="s0">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">() =&gt; {</span>
        <span class="s0">for </span><span class="s1">(</span><span class="s0">const </span><span class="s1">{ deps</span><span class="s0">, </span><span class="s1">fn } of qualifiedCallbacks) {</span>
            <span class="s1">fn(deps.map((dep) =&gt; (dep === acceptedPath ? fetchedModule : undefined)))</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">const </span><span class="s1">loggedPath = isSelfUpdate ? path : </span><span class="s2">`</span><span class="s1">${acceptedPath} </span><span class="s2">via </span><span class="s1">${path}</span><span class="s2">`</span><span class="s0">;</span>
        <span class="s1">console.debug(</span><span class="s2">`[vite] hot updated: </span><span class="s1">${loggedPath}</span><span class="s2">`</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s1">}</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">sendMessageBuffer() {</span>
    <span class="s0">if </span><span class="s1">(socket.readyState === </span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s1">messageBuffer.forEach((msg) =&gt; socket.send(msg))</span><span class="s0">;</span>
        <span class="s1">messageBuffer.length = </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">const </span><span class="s1">hotModulesMap = </span><span class="s0">new </span><span class="s1">Map()</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">disposeMap = </span><span class="s0">new </span><span class="s1">Map()</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">pruneMap = </span><span class="s0">new </span><span class="s1">Map()</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">dataMap = </span><span class="s0">new </span><span class="s1">Map()</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">customListenersMap = </span><span class="s0">new </span><span class="s1">Map()</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">ctxToListenersMap = </span><span class="s0">new </span><span class="s1">Map()</span><span class="s0">;</span>
<span class="s0">function </span><span class="s1">createHotContext(ownerPath) {</span>
    <span class="s0">if </span><span class="s1">(!dataMap.has(ownerPath)) {</span>
        <span class="s1">dataMap.set(ownerPath</span><span class="s0">, </span><span class="s1">{})</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s3">// when a file is hot updated, a new context is created</span>
    <span class="s3">// clear its stale callbacks</span>
    <span class="s0">const </span><span class="s1">mod = hotModulesMap.get(ownerPath)</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(mod) {</span>
        <span class="s1">mod.callbacks = []</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s3">// clear stale custom event listeners</span>
    <span class="s0">const </span><span class="s1">staleListeners = ctxToListenersMap.get(ownerPath)</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(staleListeners) {</span>
        <span class="s0">for </span><span class="s1">(</span><span class="s0">const </span><span class="s1">[event</span><span class="s0">, </span><span class="s1">staleFns] of staleListeners) {</span>
            <span class="s0">const </span><span class="s1">listeners = customListenersMap.get(event)</span><span class="s0">;</span>
            <span class="s0">if </span><span class="s1">(listeners) {</span>
                <span class="s1">customListenersMap.set(event</span><span class="s0">, </span><span class="s1">listeners.filter((l) =&gt; !staleFns.includes(l)))</span><span class="s0">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">const </span><span class="s1">newListeners = </span><span class="s0">new </span><span class="s1">Map()</span><span class="s0">;</span>
    <span class="s1">ctxToListenersMap.set(ownerPath</span><span class="s0">, </span><span class="s1">newListeners)</span><span class="s0">;</span>
    <span class="s0">function </span><span class="s1">acceptDeps(deps</span><span class="s0">, </span><span class="s1">callback = () =&gt; { }) {</span>
        <span class="s0">const </span><span class="s1">mod = hotModulesMap.get(ownerPath) || {</span>
            <span class="s1">id: ownerPath</span><span class="s0">,</span>
            <span class="s1">callbacks: []</span><span class="s0">,</span>
        <span class="s1">}</span><span class="s0">;</span>
        <span class="s1">mod.callbacks.push({</span>
            <span class="s1">deps</span><span class="s0">,</span>
            <span class="s1">fn: callback</span><span class="s0">,</span>
        <span class="s1">})</span><span class="s0">;</span>
        <span class="s1">hotModulesMap.set(ownerPath</span><span class="s0">, </span><span class="s1">mod)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">const </span><span class="s1">hot = {</span>
        <span class="s1">get data() {</span>
            <span class="s0">return </span><span class="s1">dataMap.get(ownerPath)</span><span class="s0">;</span>
        <span class="s1">}</span><span class="s0">,</span>
        <span class="s1">accept(deps</span><span class="s0">, </span><span class="s1">callback) {</span>
            <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">deps === </span><span class="s2">'function' </span><span class="s1">|| !deps) {</span>
                <span class="s3">// self-accept: hot.accept(() =&gt; {})</span>
                <span class="s1">acceptDeps([ownerPath]</span><span class="s0">, </span><span class="s1">([mod]) =&gt; deps === </span><span class="s0">null </span><span class="s1">|| deps === </span><span class="s0">void </span><span class="s4">0 </span><span class="s1">? </span><span class="s0">void </span><span class="s4">0 </span><span class="s1">: deps(mod))</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s0">else if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">deps === </span><span class="s2">'string'</span><span class="s1">) {</span>
                <span class="s3">// explicit deps</span>
                <span class="s1">acceptDeps([deps]</span><span class="s0">, </span><span class="s1">([mod]) =&gt; callback === </span><span class="s0">null </span><span class="s1">|| callback === </span><span class="s0">void </span><span class="s4">0 </span><span class="s1">? </span><span class="s0">void </span><span class="s4">0 </span><span class="s1">: callback(mod))</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s0">else if </span><span class="s1">(Array.isArray(deps)) {</span>
                <span class="s1">acceptDeps(deps</span><span class="s0">, </span><span class="s1">callback)</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s0">else </span><span class="s1">{</span>
                <span class="s0">throw new </span><span class="s1">Error(</span><span class="s2">`invalid hot.accept() usage.`</span><span class="s1">)</span><span class="s0">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span><span class="s0">,</span>
        <span class="s3">// export names (first arg) are irrelevant on the client side, they're</span>
        <span class="s3">// extracted in the server for propagation</span>
        <span class="s1">acceptExports(_</span><span class="s0">, </span><span class="s1">callback) {</span>
            <span class="s1">acceptDeps([ownerPath]</span><span class="s0">, </span><span class="s1">([mod]) =&gt; callback === </span><span class="s0">null </span><span class="s1">|| callback === </span><span class="s0">void </span><span class="s4">0 </span><span class="s1">? </span><span class="s0">void </span><span class="s4">0 </span><span class="s1">: callback(mod))</span><span class="s0">;</span>
        <span class="s1">}</span><span class="s0">,</span>
        <span class="s1">dispose(cb) {</span>
            <span class="s1">disposeMap.set(ownerPath</span><span class="s0">, </span><span class="s1">cb)</span><span class="s0">;</span>
        <span class="s1">}</span><span class="s0">,</span>
        <span class="s1">prune(cb) {</span>
            <span class="s1">pruneMap.set(ownerPath</span><span class="s0">, </span><span class="s1">cb)</span><span class="s0">;</span>
        <span class="s1">}</span><span class="s0">,</span>
        <span class="s3">// Kept for backward compatibility (#11036)</span>
        <span class="s3">// @ts-expect-error untyped</span>
        <span class="s3">// eslint-disable-next-line @typescript-eslint/no-empty-function</span>
        <span class="s1">decline() { }</span><span class="s0">,</span>
        <span class="s3">// tell the server to re-perform hmr propagation from this module as root</span>
        <span class="s1">invalidate(message) {</span>
            <span class="s1">notifyListeners(</span><span class="s2">'vite:invalidate'</span><span class="s0">, </span><span class="s1">{ path: ownerPath</span><span class="s0">, </span><span class="s1">message })</span><span class="s0">;</span>
            <span class="s0">this</span><span class="s1">.send(</span><span class="s2">'vite:invalidate'</span><span class="s0">, </span><span class="s1">{ path: ownerPath</span><span class="s0">, </span><span class="s1">message })</span><span class="s0">;</span>
            <span class="s1">console.debug(</span><span class="s2">`[vite] invalidate </span><span class="s1">${ownerPath}${message ? </span><span class="s2">`: </span><span class="s1">${message}</span><span class="s2">` </span><span class="s1">: </span><span class="s2">''</span><span class="s1">}</span><span class="s2">`</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s1">}</span><span class="s0">,</span>
        <span class="s3">// custom events</span>
        <span class="s1">on(event</span><span class="s0">, </span><span class="s1">cb) {</span>
            <span class="s0">const </span><span class="s1">addToMap = (map) =&gt; {</span>
                <span class="s0">const </span><span class="s1">existing = map.get(event) || []</span><span class="s0">;</span>
                <span class="s1">existing.push(cb)</span><span class="s0">;</span>
                <span class="s1">map.set(event</span><span class="s0">, </span><span class="s1">existing)</span><span class="s0">;</span>
            <span class="s1">}</span><span class="s0">;</span>
            <span class="s1">addToMap(customListenersMap)</span><span class="s0">;</span>
            <span class="s1">addToMap(newListeners)</span><span class="s0">;</span>
        <span class="s1">}</span><span class="s0">,</span>
        <span class="s1">send(event</span><span class="s0">, </span><span class="s1">data) {</span>
            <span class="s1">messageBuffer.push(JSON.stringify({ type: </span><span class="s2">'custom'</span><span class="s0">, </span><span class="s1">event</span><span class="s0">, </span><span class="s1">data }))</span><span class="s0">;</span>
            <span class="s1">sendMessageBuffer()</span><span class="s0">;</span>
        <span class="s1">}</span><span class="s0">,</span>
    <span class="s1">}</span><span class="s0">;</span>
    <span class="s0">return </span><span class="s1">hot</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s5">/**</span>
 <span class="s5">* urls here are dynamic import() urls that couldn't be statically analyzed</span>
 <span class="s5">*/</span>
<span class="s0">function </span><span class="s1">injectQuery(url</span><span class="s0">, </span><span class="s1">queryToInject) {</span>
    <span class="s3">// skip urls that won't be handled by vite</span>
    <span class="s0">if </span><span class="s1">(url[</span><span class="s4">0</span><span class="s1">] !== </span><span class="s2">'.' </span><span class="s1">&amp;&amp; url[</span><span class="s4">0</span><span class="s1">] !== </span><span class="s2">'/'</span><span class="s1">) {</span>
        <span class="s0">return </span><span class="s1">url</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s3">// can't use pathname from URL since it may be relative like ../</span>
    <span class="s0">const </span><span class="s1">pathname = url.replace(</span><span class="s4">/#.*$/</span><span class="s0">, </span><span class="s2">''</span><span class="s1">).replace(</span><span class="s4">/\?.*$/</span><span class="s0">, </span><span class="s2">''</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">{ search</span><span class="s0">, </span><span class="s1">hash } = </span><span class="s0">new </span><span class="s1">URL(url</span><span class="s0">, </span><span class="s2">'http://vitejs.dev'</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s0">return </span><span class="s2">`</span><span class="s1">${pathname}</span><span class="s2">?</span><span class="s1">${queryToInject}${search ? </span><span class="s2">`&amp;` </span><span class="s1">+ search.slice(</span><span class="s4">1</span><span class="s1">) : </span><span class="s2">''</span><span class="s1">}${hash || </span><span class="s2">''</span><span class="s1">}</span><span class="s2">`</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">{ ErrorOverlay</span><span class="s0">, </span><span class="s1">createHotContext</span><span class="s0">, </span><span class="s1">injectQuery</span><span class="s0">, </span><span class="s1">removeStyle</span><span class="s0">, </span><span class="s1">updateStyle }</span><span class="s0">;</span>
<span class="s3">//# sourceMappingURL=client.mjs.map</span>
</pre>
</body>
</html>