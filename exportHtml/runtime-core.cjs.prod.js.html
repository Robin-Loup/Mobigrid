<html>
<head>
<title>runtime-core.cjs.prod.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #6a8759;}
.s1 { color: #cc7832;}
.s2 { color: #a9b7c6;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #629755; font-weight: bold; font-style: italic;}
.s5 { color: #6897bb;}
.s6 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
runtime-core.cjs.prod.js</font>
</center></td></tr></table>
<pre><span class="s0">'use strict'</span><span class="s1">;</span>

<span class="s2">Object.defineProperty(exports</span><span class="s1">, </span><span class="s0">'__esModule'</span><span class="s1">, </span><span class="s2">{ value: </span><span class="s1">true </span><span class="s2">})</span><span class="s1">;</span>

<span class="s1">var </span><span class="s2">reactivity = require(</span><span class="s0">'@vue/reactivity'</span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">var </span><span class="s2">shared = require(</span><span class="s0">'@vue/shared'</span><span class="s2">)</span><span class="s1">;</span>

<span class="s1">function </span><span class="s2">warn(msg</span><span class="s1">, </span><span class="s2">...args) {</span>
    <span class="s1">return;</span>
<span class="s2">}</span>
<span class="s3">/**</span>
 <span class="s3">* </span><span class="s4">@internal</span>
 <span class="s3">*/</span>
<span class="s1">function </span><span class="s2">assertNumber(val</span><span class="s1">, </span><span class="s2">type) {</span>
    <span class="s1">return;</span>
<span class="s2">}</span>

<span class="s1">function </span><span class="s2">callWithErrorHandling(fn</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s2">type</span><span class="s1">, </span><span class="s2">args) {</span>
    <span class="s1">let </span><span class="s2">res</span><span class="s1">;</span>
    <span class="s1">try </span><span class="s2">{</span>
        <span class="s2">res = args ? fn(...args) : fn()</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">catch </span><span class="s2">(err) {</span>
        <span class="s2">handleError(err</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s2">type)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">res</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">callWithAsyncErrorHandling(fn</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s2">type</span><span class="s1">, </span><span class="s2">args) {</span>
    <span class="s1">if </span><span class="s2">(shared.isFunction(fn)) {</span>
        <span class="s1">const </span><span class="s2">res = callWithErrorHandling(fn</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s2">type</span><span class="s1">, </span><span class="s2">args)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(res &amp;&amp; shared.isPromise(res)) {</span>
            <span class="s2">res.catch(err =&gt; {</span>
                <span class="s2">handleError(err</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s2">type)</span><span class="s1">;</span>
            <span class="s2">})</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">return </span><span class="s2">res</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">values = []</span><span class="s1">;</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s5">0</span><span class="s1">; </span><span class="s2">i &lt; fn.length</span><span class="s1">; </span><span class="s2">i++) {</span>
        <span class="s2">values.push(callWithAsyncErrorHandling(fn[i]</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s2">type</span><span class="s1">, </span><span class="s2">args))</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">values</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">handleError(err</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s2">type</span><span class="s1">, </span><span class="s2">throwInDev = </span><span class="s1">true</span><span class="s2">) {</span>
    <span class="s1">const </span><span class="s2">contextVNode = instance ? instance.vnode : </span><span class="s1">null;</span>
    <span class="s1">if </span><span class="s2">(instance) {</span>
        <span class="s1">let </span><span class="s2">cur = instance.parent</span><span class="s1">;</span>
        <span class="s6">// the exposed instance is the render proxy to keep it consistent with 2.x</span>
        <span class="s1">const </span><span class="s2">exposedInstance = instance.proxy</span><span class="s1">;</span>
        <span class="s6">// in production the hook receives only the error code</span>
        <span class="s1">const </span><span class="s2">errorInfo = type</span><span class="s1">;</span>
        <span class="s1">while </span><span class="s2">(cur) {</span>
            <span class="s1">const </span><span class="s2">errorCapturedHooks = cur.ec</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(errorCapturedHooks) {</span>
                <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s5">0</span><span class="s1">; </span><span class="s2">i &lt; errorCapturedHooks.length</span><span class="s1">; </span><span class="s2">i++) {</span>
                    <span class="s1">if </span><span class="s2">(errorCapturedHooks[i](err</span><span class="s1">, </span><span class="s2">exposedInstance</span><span class="s1">, </span><span class="s2">errorInfo) === </span><span class="s1">false</span><span class="s2">) {</span>
                        <span class="s1">return;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s2">cur = cur.parent</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s6">// app-level handling</span>
        <span class="s1">const </span><span class="s2">appErrorHandler = instance.appContext.config.errorHandler</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(appErrorHandler) {</span>
            <span class="s2">callWithErrorHandling(appErrorHandler</span><span class="s1">, null, </span><span class="s5">10 </span><span class="s6">/* ErrorCodes.APP_ERROR_HANDLER */</span><span class="s1">, </span><span class="s2">[err</span><span class="s1">, </span><span class="s2">exposedInstance</span><span class="s1">, </span><span class="s2">errorInfo])</span><span class="s1">;</span>
            <span class="s1">return;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s2">logError(err</span><span class="s1">, </span><span class="s2">type</span><span class="s1">, </span><span class="s2">contextVNode</span><span class="s1">, </span><span class="s2">throwInDev)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">logError(err</span><span class="s1">, </span><span class="s2">type</span><span class="s1">, </span><span class="s2">contextVNode</span><span class="s1">, </span><span class="s2">throwInDev = </span><span class="s1">true</span><span class="s2">) {</span>
    <span class="s2">{</span>
        <span class="s6">// recover in prod to reduce the impact on end-user</span>
        <span class="s2">console.error(err)</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>

<span class="s1">let </span><span class="s2">isFlushing = </span><span class="s1">false;</span>
<span class="s1">let </span><span class="s2">isFlushPending = </span><span class="s1">false;</span>
<span class="s1">const </span><span class="s2">queue = []</span><span class="s1">;</span>
<span class="s1">let </span><span class="s2">flushIndex = </span><span class="s5">0</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">pendingPostFlushCbs = []</span><span class="s1">;</span>
<span class="s1">let </span><span class="s2">activePostFlushCbs = </span><span class="s1">null;</span>
<span class="s1">let </span><span class="s2">postFlushIndex = </span><span class="s5">0</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">resolvedPromise = </span><span class="s6">/*#__PURE__*/ </span><span class="s2">Promise.resolve()</span><span class="s1">;</span>
<span class="s1">let </span><span class="s2">currentFlushPromise = </span><span class="s1">null;</span>
<span class="s1">function </span><span class="s2">nextTick(fn) {</span>
    <span class="s1">const </span><span class="s2">p = currentFlushPromise || resolvedPromise</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">fn ? p.then(</span><span class="s1">this </span><span class="s2">? fn.bind(</span><span class="s1">this</span><span class="s2">) : fn) : p</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s6">// #2768</span>
<span class="s6">// Use binary-search to find a suitable position in the queue,</span>
<span class="s6">// so that the queue maintains the increasing order of job's id,</span>
<span class="s6">// which can prevent the job from being skipped and also can avoid repeated patching.</span>
<span class="s1">function </span><span class="s2">findInsertionIndex(id) {</span>
    <span class="s6">// the start index should be `flushIndex + 1`</span>
    <span class="s1">let </span><span class="s2">start = flushIndex + </span><span class="s5">1</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">end = queue.length</span><span class="s1">;</span>
    <span class="s1">while </span><span class="s2">(start &lt; end) {</span>
        <span class="s1">const </span><span class="s2">middle = (start + end) &gt;&gt;&gt; </span><span class="s5">1</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">middleJobId = getId(queue[middle])</span><span class="s1">;</span>
        <span class="s2">middleJobId &lt; id ? (start = middle + </span><span class="s5">1</span><span class="s2">) : (end = middle)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">start</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">queueJob(job) {</span>
    <span class="s6">// the dedupe search uses the startIndex argument of Array.includes()</span>
    <span class="s6">// by default the search index includes the current job that is being run</span>
    <span class="s6">// so it cannot recursively trigger itself again.</span>
    <span class="s6">// if the job is a watch() callback, the search will start with a +1 index to</span>
    <span class="s6">// allow it recursively trigger itself - it is the user's responsibility to</span>
    <span class="s6">// ensure it doesn't end up in an infinite loop.</span>
    <span class="s1">if </span><span class="s2">(!queue.length ||</span>
        <span class="s2">!queue.includes(job</span><span class="s1">, </span><span class="s2">isFlushing &amp;&amp; job.allowRecurse ? flushIndex + </span><span class="s5">1 </span><span class="s2">: flushIndex)) {</span>
        <span class="s1">if </span><span class="s2">(job.id == </span><span class="s1">null</span><span class="s2">) {</span>
            <span class="s2">queue.push(job)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">queue.splice(findInsertionIndex(job.id)</span><span class="s1">, </span><span class="s5">0</span><span class="s1">, </span><span class="s2">job)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s2">queueFlush()</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">queueFlush() {</span>
    <span class="s1">if </span><span class="s2">(!isFlushing &amp;&amp; !isFlushPending) {</span>
        <span class="s2">isFlushPending = </span><span class="s1">true;</span>
        <span class="s2">currentFlushPromise = resolvedPromise.then(flushJobs)</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">invalidateJob(job) {</span>
    <span class="s1">const </span><span class="s2">i = queue.indexOf(job)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(i &gt; flushIndex) {</span>
        <span class="s2">queue.splice(i</span><span class="s1">, </span><span class="s5">1</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">queuePostFlushCb(cb) {</span>
    <span class="s1">if </span><span class="s2">(!shared.isArray(cb)) {</span>
        <span class="s1">if </span><span class="s2">(!activePostFlushCbs ||</span>
            <span class="s2">!activePostFlushCbs.includes(cb</span><span class="s1">, </span><span class="s2">cb.allowRecurse ? postFlushIndex + </span><span class="s5">1 </span><span class="s2">: postFlushIndex)) {</span>
            <span class="s2">pendingPostFlushCbs.push(cb)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s6">// if cb is an array, it is a component lifecycle hook which can only be</span>
        <span class="s6">// triggered by a job, which is already deduped in the main queue, so</span>
        <span class="s6">// we can skip duplicate check here to improve perf</span>
        <span class="s2">pendingPostFlushCbs.push(...cb)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s2">queueFlush()</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">flushPreFlushCbs(seen</span><span class="s1">, </span>
<span class="s6">// if currently flushing, skip the current job itself</span>
<span class="s2">i = isFlushing ? flushIndex + </span><span class="s5">1 </span><span class="s2">: </span><span class="s5">0</span><span class="s2">) {</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">; </span><span class="s2">i &lt; queue.length</span><span class="s1">; </span><span class="s2">i++) {</span>
        <span class="s1">const </span><span class="s2">cb = queue[i]</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(cb &amp;&amp; cb.pre) {</span>
            <span class="s2">queue.splice(i</span><span class="s1">, </span><span class="s5">1</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">i--</span><span class="s1">;</span>
            <span class="s2">cb()</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">flushPostFlushCbs(seen) {</span>
    <span class="s1">if </span><span class="s2">(pendingPostFlushCbs.length) {</span>
        <span class="s1">const </span><span class="s2">deduped = [...</span><span class="s1">new </span><span class="s2">Set(pendingPostFlushCbs)]</span><span class="s1">;</span>
        <span class="s2">pendingPostFlushCbs.length = </span><span class="s5">0</span><span class="s1">;</span>
        <span class="s6">// #1947 already has active queue, nested flushPostFlushCbs call</span>
        <span class="s1">if </span><span class="s2">(activePostFlushCbs) {</span>
            <span class="s2">activePostFlushCbs.push(...deduped)</span><span class="s1">;</span>
            <span class="s1">return;</span>
        <span class="s2">}</span>
        <span class="s2">activePostFlushCbs = deduped</span><span class="s1">;</span>
        <span class="s2">activePostFlushCbs.sort((a</span><span class="s1">, </span><span class="s2">b) =&gt; getId(a) - getId(b))</span><span class="s1">;</span>
        <span class="s1">for </span><span class="s2">(postFlushIndex = </span><span class="s5">0</span><span class="s1">; </span><span class="s2">postFlushIndex &lt; activePostFlushCbs.length</span><span class="s1">; </span><span class="s2">postFlushIndex++) {</span>
            <span class="s2">activePostFlushCbs[postFlushIndex]()</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s2">activePostFlushCbs = </span><span class="s1">null;</span>
        <span class="s2">postFlushIndex = </span><span class="s5">0</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">const </span><span class="s2">getId = (job) =&gt; job.id == </span><span class="s1">null </span><span class="s2">? Infinity : job.id</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">comparator = (a</span><span class="s1">, </span><span class="s2">b) =&gt; {</span>
    <span class="s1">const </span><span class="s2">diff = getId(a) - getId(b)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(diff === </span><span class="s5">0</span><span class="s2">) {</span>
        <span class="s1">if </span><span class="s2">(a.pre &amp;&amp; !b.pre)</span>
            <span class="s1">return </span><span class="s2">-</span><span class="s5">1</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(b.pre &amp;&amp; !a.pre)</span>
            <span class="s1">return </span><span class="s5">1</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">diff</span><span class="s1">;</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">flushJobs(seen) {</span>
    <span class="s2">isFlushPending = </span><span class="s1">false;</span>
    <span class="s2">isFlushing = </span><span class="s1">true;</span>
    <span class="s6">// Sort queue before flush.</span>
    <span class="s6">// This ensures that:</span>
    <span class="s6">// 1. Components are updated from parent to child. (because parent is always</span>
    <span class="s6">//    created before the child so its render effect will have smaller</span>
    <span class="s6">//    priority number)</span>
    <span class="s6">// 2. If a component is unmounted during a parent component's update,</span>
    <span class="s6">//    its update can be skipped.</span>
    <span class="s2">queue.sort(comparator)</span><span class="s1">;</span>
    <span class="s6">// conditional usage of checkRecursiveUpdate must be determined out of</span>
    <span class="s6">// try ... catch block since Rollup by default de-optimizes treeshaking</span>
    <span class="s6">// inside try-catch. This can leave all warning code unshaked. Although</span>
    <span class="s6">// they would get eventually shaken by a minifier like terser, some minifiers</span>
    <span class="s6">// would fail to do that (e.g. https://github.com/evanw/esbuild/issues/1610)</span>
    <span class="s1">const </span><span class="s2">check = shared.NOOP</span><span class="s1">;</span>
    <span class="s1">try </span><span class="s2">{</span>
        <span class="s1">for </span><span class="s2">(flushIndex = </span><span class="s5">0</span><span class="s1">; </span><span class="s2">flushIndex &lt; queue.length</span><span class="s1">; </span><span class="s2">flushIndex++) {</span>
            <span class="s1">const </span><span class="s2">job = queue[flushIndex]</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(job &amp;&amp; job.active !== </span><span class="s1">false</span><span class="s2">) {</span>
                <span class="s1">if </span><span class="s2">(</span><span class="s1">false </span><span class="s2">&amp;&amp; check(job)) </span><span class="s1">;</span>
                <span class="s6">// console.log(`running:`, job.id)</span>
                <span class="s2">callWithErrorHandling(job</span><span class="s1">, null, </span><span class="s5">14 </span><span class="s6">/* ErrorCodes.SCHEDULER */</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">finally </span><span class="s2">{</span>
        <span class="s2">flushIndex = </span><span class="s5">0</span><span class="s1">;</span>
        <span class="s2">queue.length = </span><span class="s5">0</span><span class="s1">;</span>
        <span class="s2">flushPostFlushCbs()</span><span class="s1">;</span>
        <span class="s2">isFlushing = </span><span class="s1">false;</span>
        <span class="s2">currentFlushPromise = </span><span class="s1">null;</span>
        <span class="s6">// some postFlushCb queued jobs!</span>
        <span class="s6">// keep flushing until it drains.</span>
        <span class="s1">if </span><span class="s2">(queue.length || pendingPostFlushCbs.length) {</span>
            <span class="s2">flushJobs()</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
<span class="s2">}</span>

<span class="s2">exports.devtools = </span><span class="s1">void </span><span class="s5">0</span><span class="s1">;</span>
<span class="s1">let </span><span class="s2">buffer = []</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">setDevtoolsHook(hook</span><span class="s1">, </span><span class="s2">target) {</span>
    <span class="s1">var </span><span class="s2">_a</span><span class="s1">, </span><span class="s2">_b</span><span class="s1">;</span>
    <span class="s2">exports.devtools = hook</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(exports.devtools) {</span>
        <span class="s2">exports.devtools.enabled = </span><span class="s1">true;</span>
        <span class="s2">buffer.forEach(({ event</span><span class="s1">, </span><span class="s2">args }) =&gt; exports.devtools.emit(event</span><span class="s1">, </span><span class="s2">...args))</span><span class="s1">;</span>
        <span class="s2">buffer = []</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(</span>
    <span class="s6">// handle late devtools injection - only do this if we are in an actual</span>
    <span class="s6">// browser environment to avoid the timer handle stalling test runner exit</span>
    <span class="s6">// (#4815)</span>
    <span class="s1">typeof </span><span class="s2">window !== </span><span class="s0">'undefined' </span><span class="s2">&amp;&amp;</span>
        <span class="s6">// some envs mock window but not fully</span>
        <span class="s2">window.HTMLElement &amp;&amp;</span>
        <span class="s6">// also exclude jsdom</span>
        <span class="s2">!((_b = (_a = window.navigator) === </span><span class="s1">null </span><span class="s2">|| _a === </span><span class="s1">void </span><span class="s5">0 </span><span class="s2">? </span><span class="s1">void </span><span class="s5">0 </span><span class="s2">: _a.userAgent) === </span><span class="s1">null </span><span class="s2">|| _b === </span><span class="s1">void </span><span class="s5">0 </span><span class="s2">? </span><span class="s1">void </span><span class="s5">0 </span><span class="s2">: _b.includes(</span><span class="s0">'jsdom'</span><span class="s2">))) {</span>
        <span class="s1">const </span><span class="s2">replay = (target.__VUE_DEVTOOLS_HOOK_REPLAY__ =</span>
            <span class="s2">target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [])</span><span class="s1">;</span>
        <span class="s2">replay.push((newHook) =&gt; {</span>
            <span class="s2">setDevtoolsHook(newHook</span><span class="s1">, </span><span class="s2">target)</span><span class="s1">;</span>
        <span class="s2">})</span><span class="s1">;</span>
        <span class="s6">// clear buffer after 3s - the user probably doesn't have devtools installed</span>
        <span class="s6">// at all, and keeping the buffer will cause memory leaks (#4738)</span>
        <span class="s2">setTimeout(() =&gt; {</span>
            <span class="s1">if </span><span class="s2">(!exports.devtools) {</span>
                <span class="s2">target.__VUE_DEVTOOLS_HOOK_REPLAY__ = </span><span class="s1">null;</span>
                <span class="s2">buffer = []</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span><span class="s1">, </span><span class="s5">3000</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s2">buffer = []</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>

<span class="s1">function </span><span class="s2">emit(instance</span><span class="s1">, </span><span class="s2">event</span><span class="s1">, </span><span class="s2">...rawArgs) {</span>
    <span class="s1">if </span><span class="s2">(instance.isUnmounted)</span>
        <span class="s1">return;</span>
    <span class="s1">const </span><span class="s2">props = instance.vnode.props || shared.EMPTY_OBJ</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">args = rawArgs</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">isModelListener = event.startsWith(</span><span class="s0">'update:'</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s6">// for v-model update:xxx events, apply modifiers on args</span>
    <span class="s1">const </span><span class="s2">modelArg = isModelListener &amp;&amp; event.slice(</span><span class="s5">7</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(modelArg &amp;&amp; modelArg </span><span class="s1">in </span><span class="s2">props) {</span>
        <span class="s1">const </span><span class="s2">modifiersKey = </span><span class="s0">`</span><span class="s2">${modelArg === </span><span class="s0">'modelValue' </span><span class="s2">? </span><span class="s0">'model' </span><span class="s2">: modelArg}</span><span class="s0">Modifiers`</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">{ number</span><span class="s1">, </span><span class="s2">trim } = props[modifiersKey] || shared.EMPTY_OBJ</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(trim) {</span>
            <span class="s2">args = rawArgs.map(a =&gt; (shared.isString(a) ? a.trim() : a))</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(number) {</span>
            <span class="s2">args = rawArgs.map(shared.looseToNumber)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">let </span><span class="s2">handlerName</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">handler = props[(handlerName = shared.toHandlerKey(event))] ||</span>
        <span class="s6">// also try camelCase event handler (#2249)</span>
        <span class="s2">props[(handlerName = shared.toHandlerKey(shared.camelize(event)))]</span><span class="s1">;</span>
    <span class="s6">// for v-model update:xxx events, also trigger kebab-case equivalent</span>
    <span class="s6">// for props passed via kebab-case</span>
    <span class="s1">if </span><span class="s2">(!handler &amp;&amp; isModelListener) {</span>
        <span class="s2">handler = props[(handlerName = shared.toHandlerKey(shared.hyphenate(event)))]</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(handler) {</span>
        <span class="s2">callWithAsyncErrorHandling(handler</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s5">6 </span><span class="s6">/* ErrorCodes.COMPONENT_EVENT_HANDLER */</span><span class="s1">, </span><span class="s2">args)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">onceHandler = props[handlerName + </span><span class="s0">`Once`</span><span class="s2">]</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(onceHandler) {</span>
        <span class="s1">if </span><span class="s2">(!instance.emitted) {</span>
            <span class="s2">instance.emitted = {}</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(instance.emitted[handlerName]) {</span>
            <span class="s1">return;</span>
        <span class="s2">}</span>
        <span class="s2">instance.emitted[handlerName] = </span><span class="s1">true;</span>
        <span class="s2">callWithAsyncErrorHandling(onceHandler</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s5">6 </span><span class="s6">/* ErrorCodes.COMPONENT_EVENT_HANDLER */</span><span class="s1">, </span><span class="s2">args)</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">normalizeEmitsOptions(comp</span><span class="s1">, </span><span class="s2">appContext</span><span class="s1">, </span><span class="s2">asMixin = </span><span class="s1">false</span><span class="s2">) {</span>
    <span class="s1">const </span><span class="s2">cache = appContext.emitsCache</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">cached = cache.get(comp)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(cached !== undefined) {</span>
        <span class="s1">return </span><span class="s2">cached</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">raw = comp.emits</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">normalized = {}</span><span class="s1">;</span>
    <span class="s6">// apply mixin/extends props</span>
    <span class="s1">let </span><span class="s2">hasExtends = </span><span class="s1">false;</span>
    <span class="s1">if </span><span class="s2">(!shared.isFunction(comp)) {</span>
        <span class="s1">const </span><span class="s2">extendEmits = (raw) =&gt; {</span>
            <span class="s1">const </span><span class="s2">normalizedFromExtend = normalizeEmitsOptions(raw</span><span class="s1">, </span><span class="s2">appContext</span><span class="s1">, true</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(normalizedFromExtend) {</span>
                <span class="s2">hasExtends = </span><span class="s1">true;</span>
                <span class="s2">shared.extend(normalized</span><span class="s1">, </span><span class="s2">normalizedFromExtend)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(!asMixin &amp;&amp; appContext.mixins.length) {</span>
            <span class="s2">appContext.mixins.forEach(extendEmits)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(comp.extends) {</span>
            <span class="s2">extendEmits(comp.extends)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(comp.mixins) {</span>
            <span class="s2">comp.mixins.forEach(extendEmits)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(!raw &amp;&amp; !hasExtends) {</span>
        <span class="s1">if </span><span class="s2">(shared.isObject(comp)) {</span>
            <span class="s2">cache.set(comp</span><span class="s1">, null</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">return null;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(shared.isArray(raw)) {</span>
        <span class="s2">raw.forEach(key =&gt; (normalized[key] = </span><span class="s1">null</span><span class="s2">))</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s2">shared.extend(normalized</span><span class="s1">, </span><span class="s2">raw)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(shared.isObject(comp)) {</span>
        <span class="s2">cache.set(comp</span><span class="s1">, </span><span class="s2">normalized)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">normalized</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s6">// Check if an incoming prop key is a declared emit event listener.</span>
<span class="s6">// e.g. With `emits: { click: null }`, props named `onClick` and `onclick` are</span>
<span class="s6">// both considered matched listeners.</span>
<span class="s1">function </span><span class="s2">isEmitListener(options</span><span class="s1">, </span><span class="s2">key) {</span>
    <span class="s1">if </span><span class="s2">(!options || !shared.isOn(key)) {</span>
        <span class="s1">return false;</span>
    <span class="s2">}</span>
    <span class="s2">key = key.slice(</span><span class="s5">2</span><span class="s2">).replace(</span><span class="s5">/Once$/</span><span class="s1">, </span><span class="s0">''</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">(shared.hasOwn(options</span><span class="s1">, </span><span class="s2">key[</span><span class="s5">0</span><span class="s2">].toLowerCase() + key.slice(</span><span class="s5">1</span><span class="s2">)) ||</span>
        <span class="s2">shared.hasOwn(options</span><span class="s1">, </span><span class="s2">shared.hyphenate(key)) ||</span>
        <span class="s2">shared.hasOwn(options</span><span class="s1">, </span><span class="s2">key))</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s3">/**</span>
 <span class="s3">* mark the current rendering instance for asset resolution (e.g.</span>
 <span class="s3">* resolveComponent, resolveDirective) during render</span>
 <span class="s3">*/</span>
<span class="s1">let </span><span class="s2">currentRenderingInstance = </span><span class="s1">null;</span>
<span class="s1">let </span><span class="s2">currentScopeId = </span><span class="s1">null;</span>
<span class="s3">/**</span>
 <span class="s3">* Note: rendering calls maybe nested. The function returns the parent rendering</span>
 <span class="s3">* instance if present, which should be restored after the render is done:</span>
 <span class="s3">*</span>
 <span class="s3">* ```js</span>
 <span class="s3">* const prev = setCurrentRenderingInstance(i)</span>
 <span class="s3">* // ...render</span>
 <span class="s3">* setCurrentRenderingInstance(prev)</span>
 <span class="s3">* ```</span>
 <span class="s3">*/</span>
<span class="s1">function </span><span class="s2">setCurrentRenderingInstance(instance) {</span>
    <span class="s1">const </span><span class="s2">prev = currentRenderingInstance</span><span class="s1">;</span>
    <span class="s2">currentRenderingInstance = instance</span><span class="s1">;</span>
    <span class="s2">currentScopeId = (instance &amp;&amp; instance.type.__scopeId) || </span><span class="s1">null;</span>
    <span class="s1">return </span><span class="s2">prev</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s3">/**</span>
 <span class="s3">* Set scope id when creating hoisted vnodes.</span>
 <span class="s3">* </span><span class="s4">@private </span><span class="s3">compiler helper</span>
 <span class="s3">*/</span>
<span class="s1">function </span><span class="s2">pushScopeId(id) {</span>
    <span class="s2">currentScopeId = id</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s3">/**</span>
 <span class="s3">* Technically we no longer need this after 3.0.8 but we need to keep the same</span>
 <span class="s3">* API for backwards compat w/ code generated by compilers.</span>
 <span class="s3">* </span><span class="s4">@private</span>
 <span class="s3">*/</span>
<span class="s1">function </span><span class="s2">popScopeId() {</span>
    <span class="s2">currentScopeId = </span><span class="s1">null;</span>
<span class="s2">}</span>
<span class="s3">/**</span>
 <span class="s3">* Only for backwards compat</span>
 <span class="s3">* </span><span class="s4">@private</span>
 <span class="s3">*/</span>
<span class="s1">const </span><span class="s2">withScopeId = (_id) =&gt; withCtx</span><span class="s1">;</span>
<span class="s3">/**</span>
 <span class="s3">* Wrap a slot function to memoize current rendering instance</span>
 <span class="s3">* </span><span class="s4">@private </span><span class="s3">compiler helper</span>
 <span class="s3">*/</span>
<span class="s1">function </span><span class="s2">withCtx(fn</span><span class="s1">, </span><span class="s2">ctx = currentRenderingInstance</span><span class="s1">, </span><span class="s2">isNonScopedSlot </span><span class="s6">// false only</span>
<span class="s2">) {</span>
    <span class="s1">if </span><span class="s2">(!ctx)</span>
        <span class="s1">return </span><span class="s2">fn</span><span class="s1">;</span>
    <span class="s6">// already normalized</span>
    <span class="s1">if </span><span class="s2">(fn._n) {</span>
        <span class="s1">return </span><span class="s2">fn</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">renderFnWithContext = (...args) =&gt; {</span>
        <span class="s6">// If a user calls a compiled slot inside a template expression (#1745), it</span>
        <span class="s6">// can mess up block tracking, so by default we disable block tracking and</span>
        <span class="s6">// force bail out when invoking a compiled slot (indicated by the ._d flag).</span>
        <span class="s6">// This isn't necessary if rendering a compiled `&lt;slot&gt;`, so we flip the</span>
        <span class="s6">// ._d flag off when invoking the wrapped fn inside `renderSlot`.</span>
        <span class="s1">if </span><span class="s2">(renderFnWithContext._d) {</span>
            <span class="s2">setBlockTracking(-</span><span class="s5">1</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">const </span><span class="s2">prevInstance = setCurrentRenderingInstance(ctx)</span><span class="s1">;</span>
        <span class="s1">let </span><span class="s2">res</span><span class="s1">;</span>
        <span class="s1">try </span><span class="s2">{</span>
            <span class="s2">res = fn(...args)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">finally </span><span class="s2">{</span>
            <span class="s2">setCurrentRenderingInstance(prevInstance)</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(renderFnWithContext._d) {</span>
                <span class="s2">setBlockTracking(</span><span class="s5">1</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">return </span><span class="s2">res</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s6">// mark normalized to avoid duplicated wrapping</span>
    <span class="s2">renderFnWithContext._n = </span><span class="s1">true;</span>
    <span class="s6">// mark this as compiled by default</span>
    <span class="s6">// this is used in vnode.ts -&gt; normalizeChildren() to set the slot</span>
    <span class="s6">// rendering flag.</span>
    <span class="s2">renderFnWithContext._c = </span><span class="s1">true;</span>
    <span class="s6">// disable block tracking by default</span>
    <span class="s2">renderFnWithContext._d = </span><span class="s1">true;</span>
    <span class="s1">return </span><span class="s2">renderFnWithContext</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s1">function </span><span class="s2">markAttrsAccessed() {</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">renderComponentRoot(instance) {</span>
    <span class="s1">const </span><span class="s2">{ type: Component</span><span class="s1">, </span><span class="s2">vnode</span><span class="s1">, </span><span class="s2">proxy</span><span class="s1">, </span><span class="s2">withProxy</span><span class="s1">, </span><span class="s2">props</span><span class="s1">, </span><span class="s2">propsOptions: [propsOptions]</span><span class="s1">, </span><span class="s2">slots</span><span class="s1">, </span><span class="s2">attrs</span><span class="s1">, </span><span class="s2">emit</span><span class="s1">, </span><span class="s2">render</span><span class="s1">, </span><span class="s2">renderCache</span><span class="s1">, </span><span class="s2">data</span><span class="s1">, </span><span class="s2">setupState</span><span class="s1">, </span><span class="s2">ctx</span><span class="s1">, </span><span class="s2">inheritAttrs } = instance</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">result</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">fallthroughAttrs</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">prev = setCurrentRenderingInstance(instance)</span><span class="s1">;</span>
    <span class="s1">try </span><span class="s2">{</span>
        <span class="s1">if </span><span class="s2">(vnode.shapeFlag &amp; </span><span class="s5">4 </span><span class="s6">/* ShapeFlags.STATEFUL_COMPONENT */</span><span class="s2">) {</span>
            <span class="s6">// withProxy is a proxy with a different `has` trap only for</span>
            <span class="s6">// runtime-compiled render functions using `with` block.</span>
            <span class="s1">const </span><span class="s2">proxyToUse = withProxy || proxy</span><span class="s1">;</span>
            <span class="s2">result = normalizeVNode(render.call(proxyToUse</span><span class="s1">, </span><span class="s2">proxyToUse</span><span class="s1">, </span><span class="s2">renderCache</span><span class="s1">, </span><span class="s2">props</span><span class="s1">, </span><span class="s2">setupState</span><span class="s1">, </span><span class="s2">data</span><span class="s1">, </span><span class="s2">ctx))</span><span class="s1">;</span>
            <span class="s2">fallthroughAttrs = attrs</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s6">// functional</span>
            <span class="s1">const </span><span class="s2">render = Component</span><span class="s1">;</span>
            <span class="s6">// in dev, mark attrs accessed if optional props (attrs === props)</span>
            <span class="s1">if </span><span class="s2">(</span><span class="s1">false </span><span class="s2">&amp;&amp; attrs === props) </span><span class="s1">;</span>
            <span class="s2">result = normalizeVNode(render.length &gt; </span><span class="s5">1</span>
                <span class="s2">? render(props</span><span class="s1">, false</span>
                    <span class="s2">? {</span>
                        <span class="s2">get attrs() {</span>
                            <span class="s2">markAttrsAccessed()</span><span class="s1">;</span>
                            <span class="s1">return </span><span class="s2">attrs</span><span class="s1">;</span>
                        <span class="s2">}</span><span class="s1">,</span>
                        <span class="s2">slots</span><span class="s1">,</span>
                        <span class="s2">emit</span>
                    <span class="s2">}</span>
                    <span class="s2">: { attrs</span><span class="s1">, </span><span class="s2">slots</span><span class="s1">, </span><span class="s2">emit })</span>
                <span class="s2">: render(props</span><span class="s1">, null </span><span class="s6">/* we know it doesn't need it */</span><span class="s2">))</span><span class="s1">;</span>
            <span class="s2">fallthroughAttrs = Component.props</span>
                <span class="s2">? attrs</span>
                <span class="s2">: getFunctionalFallthrough(attrs)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">catch </span><span class="s2">(err) {</span>
        <span class="s2">blockStack.length = </span><span class="s5">0</span><span class="s1">;</span>
        <span class="s2">handleError(err</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s5">1 </span><span class="s6">/* ErrorCodes.RENDER_FUNCTION */</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">result = createVNode(Comment)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s6">// attr merging</span>
    <span class="s6">// in dev mode, comments are preserved, and it's possible for a template</span>
    <span class="s6">// to have comments along side the root element which makes it a fragment</span>
    <span class="s1">let </span><span class="s2">root = result</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(fallthroughAttrs &amp;&amp; inheritAttrs !== </span><span class="s1">false</span><span class="s2">) {</span>
        <span class="s1">const </span><span class="s2">keys = Object.keys(fallthroughAttrs)</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">{ shapeFlag } = root</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(keys.length) {</span>
            <span class="s1">if </span><span class="s2">(shapeFlag &amp; (</span><span class="s5">1 </span><span class="s6">/* ShapeFlags.ELEMENT */ </span><span class="s2">| </span><span class="s5">6 </span><span class="s6">/* ShapeFlags.COMPONENT */</span><span class="s2">)) {</span>
                <span class="s1">if </span><span class="s2">(propsOptions &amp;&amp; keys.some(shared.isModelListener)) {</span>
                    <span class="s6">// If a v-model listener (onUpdate:xxx) has a corresponding declared</span>
                    <span class="s6">// prop, it indicates this component expects to handle v-model and</span>
                    <span class="s6">// it should not fallthrough.</span>
                    <span class="s6">// related: #1543, #1643, #1989</span>
                    <span class="s2">fallthroughAttrs = filterModelListeners(fallthroughAttrs</span><span class="s1">, </span><span class="s2">propsOptions)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s2">root = cloneVNode(root</span><span class="s1">, </span><span class="s2">fallthroughAttrs)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s6">// inherit directives</span>
    <span class="s1">if </span><span class="s2">(vnode.dirs) {</span>
        <span class="s6">// clone before mutating since the root may be a hoisted vnode</span>
        <span class="s2">root = cloneVNode(root)</span><span class="s1">;</span>
        <span class="s2">root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s6">// inherit transition data</span>
    <span class="s1">if </span><span class="s2">(vnode.transition) {</span>
        <span class="s2">root.transition = vnode.transition</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s2">{</span>
        <span class="s2">result = root</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s2">setCurrentRenderingInstance(prev)</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">result</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">filterSingleRoot(children) {</span>
    <span class="s1">let </span><span class="s2">singleRoot</span><span class="s1">;</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s5">0</span><span class="s1">; </span><span class="s2">i &lt; children.length</span><span class="s1">; </span><span class="s2">i++) {</span>
        <span class="s1">const </span><span class="s2">child = children[i]</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(isVNode(child)) {</span>
            <span class="s6">// ignore user comment</span>
            <span class="s1">if </span><span class="s2">(child.type !== Comment || child.children === </span><span class="s0">'v-if'</span><span class="s2">) {</span>
                <span class="s1">if </span><span class="s2">(singleRoot) {</span>
                    <span class="s6">// has more than 1 non-comment child, return now</span>
                    <span class="s1">return;</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s2">singleRoot = child</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s1">return;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">singleRoot</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">const </span><span class="s2">getFunctionalFallthrough = (attrs) =&gt; {</span>
    <span class="s1">let </span><span class="s2">res</span><span class="s1">;</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">key </span><span class="s1">in </span><span class="s2">attrs) {</span>
        <span class="s1">if </span><span class="s2">(key === </span><span class="s0">'class' </span><span class="s2">|| key === </span><span class="s0">'style' </span><span class="s2">|| shared.isOn(key)) {</span>
            <span class="s2">(res || (res = {}))[key] = attrs[key]</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">res</span><span class="s1">;</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">filterModelListeners = (attrs</span><span class="s1">, </span><span class="s2">props) =&gt; {</span>
    <span class="s1">const </span><span class="s2">res = {}</span><span class="s1">;</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">key </span><span class="s1">in </span><span class="s2">attrs) {</span>
        <span class="s1">if </span><span class="s2">(!shared.isModelListener(key) || !(key.slice(</span><span class="s5">9</span><span class="s2">) </span><span class="s1">in </span><span class="s2">props)) {</span>
            <span class="s2">res[key] = attrs[key]</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">res</span><span class="s1">;</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">shouldUpdateComponent(prevVNode</span><span class="s1">, </span><span class="s2">nextVNode</span><span class="s1">, </span><span class="s2">optimized) {</span>
    <span class="s1">const </span><span class="s2">{ props: prevProps</span><span class="s1">, </span><span class="s2">children: prevChildren</span><span class="s1">, </span><span class="s2">component } = prevVNode</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">{ props: nextProps</span><span class="s1">, </span><span class="s2">children: nextChildren</span><span class="s1">, </span><span class="s2">patchFlag } = nextVNode</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">emits = component.emitsOptions</span><span class="s1">;</span>
    <span class="s6">// force child update for runtime directive or transition on component vnode.</span>
    <span class="s1">if </span><span class="s2">(nextVNode.dirs || nextVNode.transition) {</span>
        <span class="s1">return true;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(optimized &amp;&amp; patchFlag &gt;= </span><span class="s5">0</span><span class="s2">) {</span>
        <span class="s1">if </span><span class="s2">(patchFlag &amp; </span><span class="s5">1024 </span><span class="s6">/* PatchFlags.DYNAMIC_SLOTS */</span><span class="s2">) {</span>
            <span class="s6">// slot content that references values that might have changed,</span>
            <span class="s6">// e.g. in a v-for</span>
            <span class="s1">return true;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(patchFlag &amp; </span><span class="s5">16 </span><span class="s6">/* PatchFlags.FULL_PROPS */</span><span class="s2">) {</span>
            <span class="s1">if </span><span class="s2">(!prevProps) {</span>
                <span class="s1">return </span><span class="s2">!!nextProps</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s6">// presence of this flag indicates props are always non-null</span>
            <span class="s1">return </span><span class="s2">hasPropsChanged(prevProps</span><span class="s1">, </span><span class="s2">nextProps</span><span class="s1">, </span><span class="s2">emits)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(patchFlag &amp; </span><span class="s5">8 </span><span class="s6">/* PatchFlags.PROPS */</span><span class="s2">) {</span>
            <span class="s1">const </span><span class="s2">dynamicProps = nextVNode.dynamicProps</span><span class="s1">;</span>
            <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s5">0</span><span class="s1">; </span><span class="s2">i &lt; dynamicProps.length</span><span class="s1">; </span><span class="s2">i++) {</span>
                <span class="s1">const </span><span class="s2">key = dynamicProps[i]</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(nextProps[key] !== prevProps[key] &amp;&amp;</span>
                    <span class="s2">!isEmitListener(emits</span><span class="s1">, </span><span class="s2">key)) {</span>
                    <span class="s1">return true;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s6">// this path is only taken by manually written render functions</span>
        <span class="s6">// so presence of any children leads to a forced update</span>
        <span class="s1">if </span><span class="s2">(prevChildren || nextChildren) {</span>
            <span class="s1">if </span><span class="s2">(!nextChildren || !nextChildren.$stable) {</span>
                <span class="s1">return true;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(prevProps === nextProps) {</span>
            <span class="s1">return false;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(!prevProps) {</span>
            <span class="s1">return </span><span class="s2">!!nextProps</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(!nextProps) {</span>
            <span class="s1">return true;</span>
        <span class="s2">}</span>
        <span class="s1">return </span><span class="s2">hasPropsChanged(prevProps</span><span class="s1">, </span><span class="s2">nextProps</span><span class="s1">, </span><span class="s2">emits)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return false;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">hasPropsChanged(prevProps</span><span class="s1">, </span><span class="s2">nextProps</span><span class="s1">, </span><span class="s2">emitsOptions) {</span>
    <span class="s1">const </span><span class="s2">nextKeys = Object.keys(nextProps)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(nextKeys.length !== Object.keys(prevProps).length) {</span>
        <span class="s1">return true;</span>
    <span class="s2">}</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s5">0</span><span class="s1">; </span><span class="s2">i &lt; nextKeys.length</span><span class="s1">; </span><span class="s2">i++) {</span>
        <span class="s1">const </span><span class="s2">key = nextKeys[i]</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(nextProps[key] !== prevProps[key] &amp;&amp;</span>
            <span class="s2">!isEmitListener(emitsOptions</span><span class="s1">, </span><span class="s2">key)) {</span>
            <span class="s1">return true;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">return false;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">updateHOCHostEl({ vnode</span><span class="s1">, </span><span class="s2">parent }</span><span class="s1">, </span><span class="s2">el </span><span class="s6">// HostNode</span>
<span class="s2">) {</span>
    <span class="s1">while </span><span class="s2">(parent &amp;&amp; parent.subTree === vnode) {</span>
        <span class="s2">(vnode = parent.vnode).el = el</span><span class="s1">;</span>
        <span class="s2">parent = parent.parent</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>

<span class="s1">const </span><span class="s2">isSuspense = (type) =&gt; type.__isSuspense</span><span class="s1">;</span>
<span class="s6">// Suspense exposes a component-like API, and is treated like a component</span>
<span class="s6">// in the compiler, but internally it's a special built-in type that hooks</span>
<span class="s6">// directly into the renderer.</span>
<span class="s1">const </span><span class="s2">SuspenseImpl = {</span>
    <span class="s2">name: </span><span class="s0">'Suspense'</span><span class="s1">,</span>
    <span class="s6">// In order to make Suspense tree-shakable, we need to avoid importing it</span>
    <span class="s6">// directly in the renderer. The renderer checks for the __isSuspense flag</span>
    <span class="s6">// on a vnode's type and calls the `process` method, passing in renderer</span>
    <span class="s6">// internals.</span>
    <span class="s2">__isSuspense: </span><span class="s1">true,</span>
    <span class="s2">process(n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized</span><span class="s1">, </span>
    <span class="s6">// platform-specific impl passed from renderer</span>
    <span class="s2">rendererInternals) {</span>
        <span class="s1">if </span><span class="s2">(n1 == </span><span class="s1">null</span><span class="s2">) {</span>
            <span class="s2">mountSuspense(n2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized</span><span class="s1">, </span><span class="s2">rendererInternals)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">patchSuspense(n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized</span><span class="s1">, </span><span class="s2">rendererInternals)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">,</span>
    <span class="s2">hydrate: hydrateSuspense</span><span class="s1">,</span>
    <span class="s2">create: createSuspenseBoundary</span><span class="s1">,</span>
    <span class="s2">normalize: normalizeSuspenseChildren</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s6">// Force-casted public typing for h and TSX props inference</span>
<span class="s1">const </span><span class="s2">Suspense = (SuspenseImpl</span>
    <span class="s2">)</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">triggerEvent(vnode</span><span class="s1">, </span><span class="s2">name) {</span>
    <span class="s1">const </span><span class="s2">eventListener = vnode.props &amp;&amp; vnode.props[name]</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(shared.isFunction(eventListener)) {</span>
        <span class="s2">eventListener()</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">mountSuspense(vnode</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized</span><span class="s1">, </span><span class="s2">rendererInternals) {</span>
    <span class="s1">const </span><span class="s2">{ p: patch</span><span class="s1">, </span><span class="s2">o: { createElement } } = rendererInternals</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">hiddenContainer = createElement(</span><span class="s0">'div'</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">suspense = (vnode.suspense = createSuspenseBoundary(vnode</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">hiddenContainer</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized</span><span class="s1">, </span><span class="s2">rendererInternals))</span><span class="s1">;</span>
    <span class="s6">// start mounting the content subtree in an off-dom container</span>
    <span class="s2">patch(</span><span class="s1">null, </span><span class="s2">(suspense.pendingBranch = vnode.ssContent)</span><span class="s1">, </span><span class="s2">hiddenContainer</span><span class="s1">, null, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">suspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds)</span><span class="s1">;</span>
    <span class="s6">// now check if we have encountered any async deps</span>
    <span class="s1">if </span><span class="s2">(suspense.deps &gt; </span><span class="s5">0</span><span class="s2">) {</span>
        <span class="s6">// has async</span>
        <span class="s6">// invoke @fallback event</span>
        <span class="s2">triggerEvent(vnode</span><span class="s1">, </span><span class="s0">'onPending'</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">triggerEvent(vnode</span><span class="s1">, </span><span class="s0">'onFallback'</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s6">// mount the fallback tree</span>
        <span class="s2">patch(</span><span class="s1">null, </span><span class="s2">vnode.ssFallback</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, null, </span><span class="s6">// fallback tree will not have suspense context</span>
        <span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds)</span><span class="s1">;</span>
        <span class="s2">setActiveBranch(suspense</span><span class="s1">, </span><span class="s2">vnode.ssFallback)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s6">// Suspense has no async deps. Just resolve.</span>
        <span class="s2">suspense.resolve()</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">patchSuspense(n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized</span><span class="s1">, </span><span class="s2">{ p: patch</span><span class="s1">, </span><span class="s2">um: unmount</span><span class="s1">, </span><span class="s2">o: { createElement } }) {</span>
    <span class="s1">const </span><span class="s2">suspense = (n2.suspense = n1.suspense)</span><span class="s1">;</span>
    <span class="s2">suspense.vnode = n2</span><span class="s1">;</span>
    <span class="s2">n2.el = n1.el</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">newBranch = n2.ssContent</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">newFallback = n2.ssFallback</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">{ activeBranch</span><span class="s1">, </span><span class="s2">pendingBranch</span><span class="s1">, </span><span class="s2">isInFallback</span><span class="s1">, </span><span class="s2">isHydrating } = suspense</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(pendingBranch) {</span>
        <span class="s2">suspense.pendingBranch = newBranch</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(isSameVNodeType(newBranch</span><span class="s1">, </span><span class="s2">pendingBranch)) {</span>
            <span class="s6">// same root type but content may have changed.</span>
            <span class="s2">patch(pendingBranch</span><span class="s1">, </span><span class="s2">newBranch</span><span class="s1">, </span><span class="s2">suspense.hiddenContainer</span><span class="s1">, null, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">suspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(suspense.deps &lt;= </span><span class="s5">0</span><span class="s2">) {</span>
                <span class="s2">suspense.resolve()</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(isInFallback) {</span>
                <span class="s2">patch(activeBranch</span><span class="s1">, </span><span class="s2">newFallback</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, null, </span><span class="s6">// fallback tree will not have suspense context</span>
                <span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
                <span class="s2">setActiveBranch(suspense</span><span class="s1">, </span><span class="s2">newFallback)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s6">// toggled before pending tree is resolved</span>
            <span class="s2">suspense.pendingId++</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(isHydrating) {</span>
                <span class="s6">// if toggled before hydration is finished, the current DOM tree is</span>
                <span class="s6">// no longer valid. set it as the active branch so it will be unmounted</span>
                <span class="s6">// when resolved</span>
                <span class="s2">suspense.isHydrating = </span><span class="s1">false;</span>
                <span class="s2">suspense.activeBranch = pendingBranch</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s2">unmount(pendingBranch</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">suspense)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s6">// increment pending ID. this is used to invalidate async callbacks</span>
            <span class="s6">// reset suspense state</span>
            <span class="s2">suspense.deps = </span><span class="s5">0</span><span class="s1">;</span>
            <span class="s6">// discard effects from pending branch</span>
            <span class="s2">suspense.effects.length = </span><span class="s5">0</span><span class="s1">;</span>
            <span class="s6">// discard previous container</span>
            <span class="s2">suspense.hiddenContainer = createElement(</span><span class="s0">'div'</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(isInFallback) {</span>
                <span class="s6">// already in fallback state</span>
                <span class="s2">patch(</span><span class="s1">null, </span><span class="s2">newBranch</span><span class="s1">, </span><span class="s2">suspense.hiddenContainer</span><span class="s1">, null, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">suspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(suspense.deps &lt;= </span><span class="s5">0</span><span class="s2">) {</span>
                    <span class="s2">suspense.resolve()</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s2">patch(activeBranch</span><span class="s1">, </span><span class="s2">newFallback</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, null, </span><span class="s6">// fallback tree will not have suspense context</span>
                    <span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
                    <span class="s2">setActiveBranch(suspense</span><span class="s1">, </span><span class="s2">newFallback)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(activeBranch &amp;&amp; isSameVNodeType(newBranch</span><span class="s1">, </span><span class="s2">activeBranch)) {</span>
                <span class="s6">// toggled &quot;back&quot; to current active branch</span>
                <span class="s2">patch(activeBranch</span><span class="s1">, </span><span class="s2">newBranch</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">suspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
                <span class="s6">// force resolve</span>
                <span class="s2">suspense.resolve(</span><span class="s1">true</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s6">// switched to a 3rd branch</span>
                <span class="s2">patch(</span><span class="s1">null, </span><span class="s2">newBranch</span><span class="s1">, </span><span class="s2">suspense.hiddenContainer</span><span class="s1">, null, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">suspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(suspense.deps &lt;= </span><span class="s5">0</span><span class="s2">) {</span>
                    <span class="s2">suspense.resolve()</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s1">if </span><span class="s2">(activeBranch &amp;&amp; isSameVNodeType(newBranch</span><span class="s1">, </span><span class="s2">activeBranch)) {</span>
            <span class="s6">// root did not change, just normal patch</span>
            <span class="s2">patch(activeBranch</span><span class="s1">, </span><span class="s2">newBranch</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">suspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
            <span class="s2">setActiveBranch(suspense</span><span class="s1">, </span><span class="s2">newBranch)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s6">// root node toggled</span>
            <span class="s6">// invoke @pending event</span>
            <span class="s2">triggerEvent(n2</span><span class="s1">, </span><span class="s0">'onPending'</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s6">// mount pending branch in off-dom container</span>
            <span class="s2">suspense.pendingBranch = newBranch</span><span class="s1">;</span>
            <span class="s2">suspense.pendingId++</span><span class="s1">;</span>
            <span class="s2">patch(</span><span class="s1">null, </span><span class="s2">newBranch</span><span class="s1">, </span><span class="s2">suspense.hiddenContainer</span><span class="s1">, null, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">suspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(suspense.deps &lt;= </span><span class="s5">0</span><span class="s2">) {</span>
                <span class="s6">// incoming branch has no async deps, resolve now.</span>
                <span class="s2">suspense.resolve()</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s1">const </span><span class="s2">{ timeout</span><span class="s1">, </span><span class="s2">pendingId } = suspense</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(timeout &gt; </span><span class="s5">0</span><span class="s2">) {</span>
                    <span class="s2">setTimeout(() =&gt; {</span>
                        <span class="s1">if </span><span class="s2">(suspense.pendingId === pendingId) {</span>
                            <span class="s2">suspense.fallback(newFallback)</span><span class="s1">;</span>
                        <span class="s2">}</span>
                    <span class="s2">}</span><span class="s1">, </span><span class="s2">timeout)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else if </span><span class="s2">(timeout === </span><span class="s5">0</span><span class="s2">) {</span>
                    <span class="s2">suspense.fallback(newFallback)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">createSuspenseBoundary(vnode</span><span class="s1">, </span><span class="s2">parent</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">hiddenContainer</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized</span><span class="s1">, </span><span class="s2">rendererInternals</span><span class="s1">, </span><span class="s2">isHydrating = </span><span class="s1">false</span><span class="s2">) {</span>
    <span class="s1">const </span><span class="s2">{ p: patch</span><span class="s1">, </span><span class="s2">m: move</span><span class="s1">, </span><span class="s2">um: unmount</span><span class="s1">, </span><span class="s2">n: next</span><span class="s1">, </span><span class="s2">o: { parentNode</span><span class="s1">, </span><span class="s2">remove } } = rendererInternals</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">timeout = vnode.props ? shared.toNumber(vnode.props.timeout) : undefined</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">suspense = {</span>
        <span class="s2">vnode</span><span class="s1">,</span>
        <span class="s2">parent</span><span class="s1">,</span>
        <span class="s2">parentComponent</span><span class="s1">,</span>
        <span class="s2">isSVG</span><span class="s1">,</span>
        <span class="s2">container</span><span class="s1">,</span>
        <span class="s2">hiddenContainer</span><span class="s1">,</span>
        <span class="s2">anchor</span><span class="s1">,</span>
        <span class="s2">deps: </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s2">pendingId: </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s2">timeout: </span><span class="s1">typeof </span><span class="s2">timeout === </span><span class="s0">'number' </span><span class="s2">? timeout : -</span><span class="s5">1</span><span class="s1">,</span>
        <span class="s2">activeBranch: </span><span class="s1">null,</span>
        <span class="s2">pendingBranch: </span><span class="s1">null,</span>
        <span class="s2">isInFallback: </span><span class="s1">true,</span>
        <span class="s2">isHydrating</span><span class="s1">,</span>
        <span class="s2">isUnmounted: </span><span class="s1">false,</span>
        <span class="s2">effects: []</span><span class="s1">,</span>
        <span class="s2">resolve(resume = </span><span class="s1">false</span><span class="s2">) {</span>
            <span class="s1">const </span><span class="s2">{ vnode</span><span class="s1">, </span><span class="s2">activeBranch</span><span class="s1">, </span><span class="s2">pendingBranch</span><span class="s1">, </span><span class="s2">pendingId</span><span class="s1">, </span><span class="s2">effects</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">container } = suspense</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(suspense.isHydrating) {</span>
                <span class="s2">suspense.isHydrating = </span><span class="s1">false;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(!resume) {</span>
                <span class="s1">const </span><span class="s2">delayEnter = activeBranch &amp;&amp;</span>
                    <span class="s2">pendingBranch.transition &amp;&amp;</span>
                    <span class="s2">pendingBranch.transition.mode === </span><span class="s0">'out-in'</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(delayEnter) {</span>
                    <span class="s2">activeBranch.transition.afterLeave = () =&gt; {</span>
                        <span class="s1">if </span><span class="s2">(pendingId === suspense.pendingId) {</span>
                            <span class="s2">move(pendingBranch</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s5">0 </span><span class="s6">/* MoveType.ENTER */</span><span class="s2">)</span><span class="s1">;</span>
                        <span class="s2">}</span>
                    <span class="s2">}</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s6">// this is initial anchor on mount</span>
                <span class="s1">let </span><span class="s2">{ anchor } = suspense</span><span class="s1">;</span>
                <span class="s6">// unmount current active tree</span>
                <span class="s1">if </span><span class="s2">(activeBranch) {</span>
                    <span class="s6">// if the fallback tree was mounted, it may have been moved</span>
                    <span class="s6">// as part of a parent suspense. get the latest anchor for insertion</span>
                    <span class="s2">anchor = next(activeBranch)</span><span class="s1">;</span>
                    <span class="s2">unmount(activeBranch</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">suspense</span><span class="s1">, true</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">if </span><span class="s2">(!delayEnter) {</span>
                    <span class="s6">// move content from off-dom container to actual container</span>
                    <span class="s2">move(pendingBranch</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s5">0 </span><span class="s6">/* MoveType.ENTER */</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s2">setActiveBranch(suspense</span><span class="s1">, </span><span class="s2">pendingBranch)</span><span class="s1">;</span>
            <span class="s2">suspense.pendingBranch = </span><span class="s1">null;</span>
            <span class="s2">suspense.isInFallback = </span><span class="s1">false;</span>
            <span class="s6">// flush buffered effects</span>
            <span class="s6">// check if there is a pending parent suspense</span>
            <span class="s1">let </span><span class="s2">parent = suspense.parent</span><span class="s1">;</span>
            <span class="s1">let </span><span class="s2">hasUnresolvedAncestor = </span><span class="s1">false;</span>
            <span class="s1">while </span><span class="s2">(parent) {</span>
                <span class="s1">if </span><span class="s2">(parent.pendingBranch) {</span>
                    <span class="s6">// found a pending parent suspense, merge buffered post jobs</span>
                    <span class="s6">// into that parent</span>
                    <span class="s2">parent.effects.push(...effects)</span><span class="s1">;</span>
                    <span class="s2">hasUnresolvedAncestor = </span><span class="s1">true;</span>
                    <span class="s1">break;</span>
                <span class="s2">}</span>
                <span class="s2">parent = parent.parent</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s6">// no pending parent suspense, flush all jobs</span>
            <span class="s1">if </span><span class="s2">(!hasUnresolvedAncestor) {</span>
                <span class="s2">queuePostFlushCb(effects)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s2">suspense.effects = []</span><span class="s1">;</span>
            <span class="s6">// invoke @resolve event</span>
            <span class="s2">triggerEvent(vnode</span><span class="s1">, </span><span class="s0">'onResolve'</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span><span class="s1">,</span>
        <span class="s2">fallback(fallbackVNode) {</span>
            <span class="s1">if </span><span class="s2">(!suspense.pendingBranch) {</span>
                <span class="s1">return;</span>
            <span class="s2">}</span>
            <span class="s1">const </span><span class="s2">{ vnode</span><span class="s1">, </span><span class="s2">activeBranch</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">isSVG } = suspense</span><span class="s1">;</span>
            <span class="s6">// invoke @fallback event</span>
            <span class="s2">triggerEvent(vnode</span><span class="s1">, </span><span class="s0">'onFallback'</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">anchor = next(activeBranch)</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">mountFallback = () =&gt; {</span>
                <span class="s1">if </span><span class="s2">(!suspense.isInFallback) {</span>
                    <span class="s1">return;</span>
                <span class="s2">}</span>
                <span class="s6">// mount the fallback tree</span>
                <span class="s2">patch(</span><span class="s1">null, </span><span class="s2">fallbackVNode</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, null, </span><span class="s6">// fallback tree will not have suspense context</span>
                <span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
                <span class="s2">setActiveBranch(suspense</span><span class="s1">, </span><span class="s2">fallbackVNode)</span><span class="s1">;</span>
            <span class="s2">}</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">delayEnter = fallbackVNode.transition &amp;&amp; fallbackVNode.transition.mode === </span><span class="s0">'out-in'</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(delayEnter) {</span>
                <span class="s2">activeBranch.transition.afterLeave = mountFallback</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s2">suspense.isInFallback = </span><span class="s1">true;</span>
            <span class="s6">// unmount current active branch</span>
            <span class="s2">unmount(activeBranch</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, null, </span><span class="s6">// no suspense so unmount hooks fire now</span>
            <span class="s1">true </span><span class="s6">// shouldRemove</span>
            <span class="s2">)</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(!delayEnter) {</span>
                <span class="s2">mountFallback()</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span><span class="s1">,</span>
        <span class="s2">move(container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">type) {</span>
            <span class="s2">suspense.activeBranch &amp;&amp;</span>
                <span class="s2">move(suspense.activeBranch</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">type)</span><span class="s1">;</span>
            <span class="s2">suspense.container = container</span><span class="s1">;</span>
        <span class="s2">}</span><span class="s1">,</span>
        <span class="s2">next() {</span>
            <span class="s1">return </span><span class="s2">suspense.activeBranch &amp;&amp; next(suspense.activeBranch)</span><span class="s1">;</span>
        <span class="s2">}</span><span class="s1">,</span>
        <span class="s2">registerDep(instance</span><span class="s1">, </span><span class="s2">setupRenderEffect) {</span>
            <span class="s1">const </span><span class="s2">isInPendingSuspense = !!suspense.pendingBranch</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(isInPendingSuspense) {</span>
                <span class="s2">suspense.deps++</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">const </span><span class="s2">hydratedEl = instance.vnode.el</span><span class="s1">;</span>
            <span class="s2">instance</span>
                <span class="s2">.asyncDep.catch(err =&gt; {</span>
                <span class="s2">handleError(err</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s5">0 </span><span class="s6">/* ErrorCodes.SETUP_FUNCTION */</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">})</span>
                <span class="s2">.then(asyncSetupResult =&gt; {</span>
                <span class="s6">// retry when the setup() promise resolves.</span>
                <span class="s6">// component may have been unmounted before resolve.</span>
                <span class="s1">if </span><span class="s2">(instance.isUnmounted ||</span>
                    <span class="s2">suspense.isUnmounted ||</span>
                    <span class="s2">suspense.pendingId !== instance.suspenseId) {</span>
                    <span class="s1">return;</span>
                <span class="s2">}</span>
                <span class="s6">// retry from this component</span>
                <span class="s2">instance.asyncResolved = </span><span class="s1">true;</span>
                <span class="s1">const </span><span class="s2">{ vnode } = instance</span><span class="s1">;</span>
                <span class="s2">handleSetupResult(instance</span><span class="s1">, </span><span class="s2">asyncSetupResult</span><span class="s1">, false</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(hydratedEl) {</span>
                    <span class="s6">// vnode may have been replaced if an update happened before the</span>
                    <span class="s6">// async dep is resolved.</span>
                    <span class="s2">vnode.el = hydratedEl</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">const </span><span class="s2">placeholder = !hydratedEl &amp;&amp; instance.subTree.el</span><span class="s1">;</span>
                <span class="s2">setupRenderEffect(instance</span><span class="s1">, </span><span class="s2">vnode</span><span class="s1">, </span>
                <span class="s6">// component may have been moved before resolve.</span>
                <span class="s6">// if this is not a hydration, instance.subTree will be the comment</span>
                <span class="s6">// placeholder.</span>
                <span class="s2">parentNode(hydratedEl || instance.subTree.el)</span><span class="s1">, </span>
                <span class="s6">// anchor will not be used if this is hydration, so only need to</span>
                <span class="s6">// consider the comment placeholder case.</span>
                <span class="s2">hydratedEl ? </span><span class="s1">null </span><span class="s2">: next(instance.subTree)</span><span class="s1">, </span><span class="s2">suspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(placeholder) {</span>
                    <span class="s2">remove(placeholder)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s2">updateHOCHostEl(instance</span><span class="s1">, </span><span class="s2">vnode.el)</span><span class="s1">;</span>
                <span class="s6">// only decrease deps count if suspense is not already resolved</span>
                <span class="s1">if </span><span class="s2">(isInPendingSuspense &amp;&amp; --suspense.deps === </span><span class="s5">0</span><span class="s2">) {</span>
                    <span class="s2">suspense.resolve()</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">})</span><span class="s1">;</span>
        <span class="s2">}</span><span class="s1">,</span>
        <span class="s2">unmount(parentSuspense</span><span class="s1">, </span><span class="s2">doRemove) {</span>
            <span class="s2">suspense.isUnmounted = </span><span class="s1">true;</span>
            <span class="s1">if </span><span class="s2">(suspense.activeBranch) {</span>
                <span class="s2">unmount(suspense.activeBranch</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">doRemove)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">if </span><span class="s2">(suspense.pendingBranch) {</span>
                <span class="s2">unmount(suspense.pendingBranch</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">doRemove)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">suspense</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">hydrateSuspense(node</span><span class="s1">, </span><span class="s2">vnode</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized</span><span class="s1">, </span><span class="s2">rendererInternals</span><span class="s1">, </span><span class="s2">hydrateNode) {</span>
    <span class="s6">/* eslint-disable no-restricted-globals */</span>
    <span class="s1">const </span><span class="s2">suspense = (vnode.suspense = createSuspenseBoundary(vnode</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">node.parentNode</span><span class="s1">, </span><span class="s2">document.createElement(</span><span class="s0">'div'</span><span class="s2">)</span><span class="s1">, null, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized</span><span class="s1">, </span><span class="s2">rendererInternals</span><span class="s1">, true </span><span class="s6">/* hydrating */</span><span class="s2">))</span><span class="s1">;</span>
    <span class="s6">// there are two possible scenarios for server-rendered suspense:</span>
    <span class="s6">// - success: ssr content should be fully resolved</span>
    <span class="s6">// - failure: ssr content should be the fallback branch.</span>
    <span class="s6">// however, on the client we don't really know if it has failed or not</span>
    <span class="s6">// attempt to hydrate the DOM assuming it has succeeded, but we still</span>
    <span class="s6">// need to construct a suspense boundary first</span>
    <span class="s1">const </span><span class="s2">result = hydrateNode(node</span><span class="s1">, </span><span class="s2">(suspense.pendingBranch = vnode.ssContent)</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">suspense</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(suspense.deps === </span><span class="s5">0</span><span class="s2">) {</span>
        <span class="s2">suspense.resolve()</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">result</span><span class="s1">;</span>
    <span class="s6">/* eslint-enable no-restricted-globals */</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">normalizeSuspenseChildren(vnode) {</span>
    <span class="s1">const </span><span class="s2">{ shapeFlag</span><span class="s1">, </span><span class="s2">children } = vnode</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">isSlotChildren = shapeFlag &amp; </span><span class="s5">32 </span><span class="s6">/* ShapeFlags.SLOTS_CHILDREN */</span><span class="s1">;</span>
    <span class="s2">vnode.ssContent = normalizeSuspenseSlot(isSlotChildren ? children.default : children)</span><span class="s1">;</span>
    <span class="s2">vnode.ssFallback = isSlotChildren</span>
        <span class="s2">? normalizeSuspenseSlot(children.fallback)</span>
        <span class="s2">: createVNode(Comment)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">normalizeSuspenseSlot(s) {</span>
    <span class="s1">let </span><span class="s2">block</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(shared.isFunction(s)) {</span>
        <span class="s1">const </span><span class="s2">trackBlock = isBlockTreeEnabled &amp;&amp; s._c</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(trackBlock) {</span>
            <span class="s6">// disableTracking: false</span>
            <span class="s6">// allow block tracking for compiled slots</span>
            <span class="s6">// (see ./componentRenderContext.ts)</span>
            <span class="s2">s._d = </span><span class="s1">false;</span>
            <span class="s2">openBlock()</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s2">s = s()</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(trackBlock) {</span>
            <span class="s2">s._d = </span><span class="s1">true;</span>
            <span class="s2">block = currentBlock</span><span class="s1">;</span>
            <span class="s2">closeBlock()</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(shared.isArray(s)) {</span>
        <span class="s1">const </span><span class="s2">singleChild = filterSingleRoot(s)</span><span class="s1">;</span>
        <span class="s2">s = singleChild</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s2">s = normalizeVNode(s)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(block &amp;&amp; !s.dynamicChildren) {</span>
        <span class="s2">s.dynamicChildren = block.filter(c =&gt; c !== s)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">s</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">queueEffectWithSuspense(fn</span><span class="s1">, </span><span class="s2">suspense) {</span>
    <span class="s1">if </span><span class="s2">(suspense &amp;&amp; suspense.pendingBranch) {</span>
        <span class="s1">if </span><span class="s2">(shared.isArray(fn)) {</span>
            <span class="s2">suspense.effects.push(...fn)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">suspense.effects.push(fn)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s2">queuePostFlushCb(fn)</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">setActiveBranch(suspense</span><span class="s1">, </span><span class="s2">branch) {</span>
    <span class="s2">suspense.activeBranch = branch</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">{ vnode</span><span class="s1">, </span><span class="s2">parentComponent } = suspense</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">el = (vnode.el = branch.el)</span><span class="s1">;</span>
    <span class="s6">// in case suspense is the root node of a component,</span>
    <span class="s6">// recursively update the HOC el</span>
    <span class="s1">if </span><span class="s2">(parentComponent &amp;&amp; parentComponent.subTree === vnode) {</span>
        <span class="s2">parentComponent.vnode.el = el</span><span class="s1">;</span>
        <span class="s2">updateHOCHostEl(parentComponent</span><span class="s1">, </span><span class="s2">el)</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>

<span class="s1">function </span><span class="s2">provide(key</span><span class="s1">, </span><span class="s2">value) {</span>
    <span class="s1">if </span><span class="s2">(!currentInstance) </span><span class="s1">;</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s1">let </span><span class="s2">provides = currentInstance.provides</span><span class="s1">;</span>
        <span class="s6">// by default an instance inherits its parent's provides object</span>
        <span class="s6">// but when it needs to provide values of its own, it creates its</span>
        <span class="s6">// own provides object using parent provides object as prototype.</span>
        <span class="s6">// this way in `inject` we can simply look up injections from direct</span>
        <span class="s6">// parent and let the prototype chain do the work.</span>
        <span class="s1">const </span><span class="s2">parentProvides = currentInstance.parent &amp;&amp; currentInstance.parent.provides</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(parentProvides === provides) {</span>
            <span class="s2">provides = currentInstance.provides = Object.create(parentProvides)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s6">// TS doesn't allow symbol as index type</span>
        <span class="s2">provides[key] = value</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">inject(key</span><span class="s1">, </span><span class="s2">defaultValue</span><span class="s1">, </span><span class="s2">treatDefaultAsFactory = </span><span class="s1">false</span><span class="s2">) {</span>
    <span class="s6">// fallback to `currentRenderingInstance` so that this can be called in</span>
    <span class="s6">// a functional component</span>
    <span class="s1">const </span><span class="s2">instance = currentInstance || currentRenderingInstance</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(instance) {</span>
        <span class="s6">// #2400</span>
        <span class="s6">// to support `app.use` plugins,</span>
        <span class="s6">// fallback to appContext's `provides` if the instance is at root</span>
        <span class="s1">const </span><span class="s2">provides = instance.parent == </span><span class="s1">null</span>
            <span class="s2">? instance.vnode.appContext &amp;&amp; instance.vnode.appContext.provides</span>
            <span class="s2">: instance.parent.provides</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(provides &amp;&amp; key </span><span class="s1">in </span><span class="s2">provides) {</span>
            <span class="s6">// TS doesn't allow symbol as index type</span>
            <span class="s1">return </span><span class="s2">provides[key]</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(arguments.length &gt; </span><span class="s5">1</span><span class="s2">) {</span>
            <span class="s1">return </span><span class="s2">treatDefaultAsFactory &amp;&amp; shared.isFunction(defaultValue)</span>
                <span class="s2">? defaultValue.call(instance.proxy)</span>
                <span class="s2">: defaultValue</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else ;</span>
    <span class="s2">}</span>
<span class="s2">}</span>

<span class="s6">// Simple effect.</span>
<span class="s1">function </span><span class="s2">watchEffect(effect</span><span class="s1">, </span><span class="s2">options) {</span>
    <span class="s1">return </span><span class="s2">doWatch(effect</span><span class="s1">, null, </span><span class="s2">options)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">watchPostEffect(effect</span><span class="s1">, </span><span class="s2">options) {</span>
    <span class="s1">return </span><span class="s2">doWatch(effect</span><span class="s1">, null, </span><span class="s2">{ flush: </span><span class="s0">'post' </span><span class="s2">})</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">watchSyncEffect(effect</span><span class="s1">, </span><span class="s2">options) {</span>
    <span class="s1">return </span><span class="s2">doWatch(effect</span><span class="s1">, null, </span><span class="s2">{ flush: </span><span class="s0">'sync' </span><span class="s2">})</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s6">// initial value for watchers to trigger on undefined initial values</span>
<span class="s1">const </span><span class="s2">INITIAL_WATCHER_VALUE = {}</span><span class="s1">;</span>
<span class="s6">// implementation</span>
<span class="s1">function </span><span class="s2">watch(source</span><span class="s1">, </span><span class="s2">cb</span><span class="s1">, </span><span class="s2">options) {</span>
    <span class="s1">return </span><span class="s2">doWatch(source</span><span class="s1">, </span><span class="s2">cb</span><span class="s1">, </span><span class="s2">options)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">doWatch(source</span><span class="s1">, </span><span class="s2">cb</span><span class="s1">, </span><span class="s2">{ immediate</span><span class="s1">, </span><span class="s2">deep</span><span class="s1">, </span><span class="s2">flush</span><span class="s1">, </span><span class="s2">onTrack</span><span class="s1">, </span><span class="s2">onTrigger } = shared.EMPTY_OBJ) {</span>
    <span class="s1">const </span><span class="s2">instance = reactivity.getCurrentScope() === (currentInstance === </span><span class="s1">null </span><span class="s2">|| currentInstance === </span><span class="s1">void </span><span class="s5">0 </span><span class="s2">? </span><span class="s1">void </span><span class="s5">0 </span><span class="s2">: currentInstance.scope) ? currentInstance : </span><span class="s1">null;</span>
    <span class="s6">// const instance = currentInstance</span>
    <span class="s1">let </span><span class="s2">getter</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">forceTrigger = </span><span class="s1">false;</span>
    <span class="s1">let </span><span class="s2">isMultiSource = </span><span class="s1">false;</span>
    <span class="s1">if </span><span class="s2">(reactivity.isRef(source)) {</span>
        <span class="s2">getter = () =&gt; source.value</span><span class="s1">;</span>
        <span class="s2">forceTrigger = reactivity.isShallow(source)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(reactivity.isReactive(source)) {</span>
        <span class="s2">getter = () =&gt; source</span><span class="s1">;</span>
        <span class="s2">deep = </span><span class="s1">true;</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(shared.isArray(source)) {</span>
        <span class="s2">isMultiSource = </span><span class="s1">true;</span>
        <span class="s2">forceTrigger = source.some(s =&gt; reactivity.isReactive(s) || reactivity.isShallow(s))</span><span class="s1">;</span>
        <span class="s2">getter = () =&gt; source.map(s =&gt; {</span>
            <span class="s1">if </span><span class="s2">(reactivity.isRef(s)) {</span>
                <span class="s1">return </span><span class="s2">s.value</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(reactivity.isReactive(s)) {</span>
                <span class="s1">return </span><span class="s2">traverse(s)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(shared.isFunction(s)) {</span>
                <span class="s1">return </span><span class="s2">callWithErrorHandling(s</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s5">2 </span><span class="s6">/* ErrorCodes.WATCH_GETTER */</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else ;</span>
        <span class="s2">})</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(shared.isFunction(source)) {</span>
        <span class="s1">if </span><span class="s2">(cb) {</span>
            <span class="s6">// getter with cb</span>
            <span class="s2">getter = () =&gt; callWithErrorHandling(source</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s5">2 </span><span class="s6">/* ErrorCodes.WATCH_GETTER */</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s6">// no cb -&gt; simple effect</span>
            <span class="s2">getter = () =&gt; {</span>
                <span class="s1">if </span><span class="s2">(instance &amp;&amp; instance.isUnmounted) {</span>
                    <span class="s1">return;</span>
                <span class="s2">}</span>
                <span class="s1">if </span><span class="s2">(cleanup) {</span>
                    <span class="s2">cleanup()</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">return </span><span class="s2">callWithAsyncErrorHandling(source</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s5">3 </span><span class="s6">/* ErrorCodes.WATCH_CALLBACK */</span><span class="s1">, </span><span class="s2">[onCleanup])</span><span class="s1">;</span>
            <span class="s2">}</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s2">getter = shared.NOOP</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(cb &amp;&amp; deep) {</span>
        <span class="s1">const </span><span class="s2">baseGetter = getter</span><span class="s1">;</span>
        <span class="s2">getter = () =&gt; traverse(baseGetter())</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">let </span><span class="s2">cleanup</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">onCleanup = (fn) =&gt; {</span>
        <span class="s2">cleanup = effect.onStop = () =&gt; {</span>
            <span class="s2">callWithErrorHandling(fn</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s5">4 </span><span class="s6">/* ErrorCodes.WATCH_CLEANUP */</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s6">// in SSR there is no need to setup an actual effect, and it should be noop</span>
    <span class="s6">// unless it's eager or sync flush</span>
    <span class="s1">let </span><span class="s2">ssrCleanup</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(isInSSRComponentSetup) {</span>
        <span class="s6">// we will also not call the invalidate callback (+ runner is not set up)</span>
        <span class="s2">onCleanup = shared.NOOP</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(!cb) {</span>
            <span class="s2">getter()</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(immediate) {</span>
            <span class="s2">callWithAsyncErrorHandling(cb</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s5">3 </span><span class="s6">/* ErrorCodes.WATCH_CALLBACK */</span><span class="s1">, </span><span class="s2">[</span>
                <span class="s2">getter()</span><span class="s1">,</span>
                <span class="s2">isMultiSource ? [] : undefined</span><span class="s1">,</span>
                <span class="s2">onCleanup</span>
            <span class="s2">])</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(flush === </span><span class="s0">'sync'</span><span class="s2">) {</span>
            <span class="s1">const </span><span class="s2">ctx = useSSRContext()</span><span class="s1">;</span>
            <span class="s2">ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = [])</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s1">return </span><span class="s2">shared.NOOP</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">let </span><span class="s2">oldValue = isMultiSource</span>
        <span class="s2">? </span><span class="s1">new </span><span class="s2">Array(source.length).fill(INITIAL_WATCHER_VALUE)</span>
        <span class="s2">: INITIAL_WATCHER_VALUE</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">job = () =&gt; {</span>
        <span class="s1">if </span><span class="s2">(!effect.active) {</span>
            <span class="s1">return;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(cb) {</span>
            <span class="s6">// watch(source, cb)</span>
            <span class="s1">const </span><span class="s2">newValue = effect.run()</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(deep ||</span>
                <span class="s2">forceTrigger ||</span>
                <span class="s2">(isMultiSource</span>
                    <span class="s2">? newValue.some((v</span><span class="s1">, </span><span class="s2">i) =&gt; shared.hasChanged(v</span><span class="s1">, </span><span class="s2">oldValue[i]))</span>
                    <span class="s2">: shared.hasChanged(newValue</span><span class="s1">, </span><span class="s2">oldValue)) ||</span>
                <span class="s2">(</span><span class="s1">false  </span><span class="s2">)) {</span>
                <span class="s6">// cleanup before running cb again</span>
                <span class="s1">if </span><span class="s2">(cleanup) {</span>
                    <span class="s2">cleanup()</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s2">callWithAsyncErrorHandling(cb</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s5">3 </span><span class="s6">/* ErrorCodes.WATCH_CALLBACK */</span><span class="s1">, </span><span class="s2">[</span>
                    <span class="s2">newValue</span><span class="s1">,</span>
                    <span class="s6">// pass undefined as the old value when it's changed for the first time</span>
                    <span class="s2">oldValue === INITIAL_WATCHER_VALUE</span>
                        <span class="s2">? undefined</span>
                        <span class="s2">: isMultiSource &amp;&amp; oldValue[</span><span class="s5">0</span><span class="s2">] === INITIAL_WATCHER_VALUE</span>
                            <span class="s2">? []</span>
                            <span class="s2">: oldValue</span><span class="s1">,</span>
                    <span class="s2">onCleanup</span>
                <span class="s2">])</span><span class="s1">;</span>
                <span class="s2">oldValue = newValue</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s6">// watchEffect</span>
            <span class="s2">effect.run()</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s6">// important: mark the job as a watcher callback so that scheduler knows</span>
    <span class="s6">// it is allowed to self-trigger (#1727)</span>
    <span class="s2">job.allowRecurse = !!cb</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">scheduler</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(flush === </span><span class="s0">'sync'</span><span class="s2">) {</span>
        <span class="s2">scheduler = job</span><span class="s1">; </span><span class="s6">// the scheduler function gets called directly</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(flush === </span><span class="s0">'post'</span><span class="s2">) {</span>
        <span class="s2">scheduler = () =&gt; queuePostRenderEffect(job</span><span class="s1">, </span><span class="s2">instance &amp;&amp; instance.suspense)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s6">// default: 'pre'</span>
        <span class="s2">job.pre = </span><span class="s1">true;</span>
        <span class="s1">if </span><span class="s2">(instance)</span>
            <span class="s2">job.id = instance.uid</span><span class="s1">;</span>
        <span class="s2">scheduler = () =&gt; queueJob(job)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">effect = </span><span class="s1">new </span><span class="s2">reactivity.ReactiveEffect(getter</span><span class="s1">, </span><span class="s2">scheduler)</span><span class="s1">;</span>
    <span class="s6">// initial run</span>
    <span class="s1">if </span><span class="s2">(cb) {</span>
        <span class="s1">if </span><span class="s2">(immediate) {</span>
            <span class="s2">job()</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">oldValue = effect.run()</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(flush === </span><span class="s0">'post'</span><span class="s2">) {</span>
        <span class="s2">queuePostRenderEffect(effect.run.bind(effect)</span><span class="s1">, </span><span class="s2">instance &amp;&amp; instance.suspense)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s2">effect.run()</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">unwatch = () =&gt; {</span>
        <span class="s2">effect.stop()</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(instance &amp;&amp; instance.scope) {</span>
            <span class="s2">shared.remove(instance.scope.effects</span><span class="s1">, </span><span class="s2">effect)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(ssrCleanup)</span>
        <span class="s2">ssrCleanup.push(unwatch)</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">unwatch</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s6">// this.$watch</span>
<span class="s1">function </span><span class="s2">instanceWatch(source</span><span class="s1">, </span><span class="s2">value</span><span class="s1">, </span><span class="s2">options) {</span>
    <span class="s1">const </span><span class="s2">publicThis = </span><span class="s1">this</span><span class="s2">.proxy</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">getter = shared.isString(source)</span>
        <span class="s2">? source.includes(</span><span class="s0">'.'</span><span class="s2">)</span>
            <span class="s2">? createPathGetter(publicThis</span><span class="s1">, </span><span class="s2">source)</span>
            <span class="s2">: () =&gt; publicThis[source]</span>
        <span class="s2">: source.bind(publicThis</span><span class="s1">, </span><span class="s2">publicThis)</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">cb</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(shared.isFunction(value)) {</span>
        <span class="s2">cb = value</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s2">cb = value.handler</span><span class="s1">;</span>
        <span class="s2">options = value</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">cur = currentInstance</span><span class="s1">;</span>
    <span class="s2">setCurrentInstance(</span><span class="s1">this</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">res = doWatch(getter</span><span class="s1">, </span><span class="s2">cb.bind(publicThis)</span><span class="s1">, </span><span class="s2">options)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(cur) {</span>
        <span class="s2">setCurrentInstance(cur)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s2">unsetCurrentInstance()</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">res</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">createPathGetter(ctx</span><span class="s1">, </span><span class="s2">path) {</span>
    <span class="s1">const </span><span class="s2">segments = path.split(</span><span class="s0">'.'</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">() =&gt; {</span>
        <span class="s1">let </span><span class="s2">cur = ctx</span><span class="s1">;</span>
        <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s5">0</span><span class="s1">; </span><span class="s2">i &lt; segments.length &amp;&amp; cur</span><span class="s1">; </span><span class="s2">i++) {</span>
            <span class="s2">cur = cur[segments[i]]</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">return </span><span class="s2">cur</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">traverse(value</span><span class="s1">, </span><span class="s2">seen) {</span>
    <span class="s1">if </span><span class="s2">(!shared.isObject(value) || value[</span><span class="s0">&quot;__v_skip&quot; </span><span class="s6">/* ReactiveFlags.SKIP */</span><span class="s2">]) {</span>
        <span class="s1">return </span><span class="s2">value</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s2">seen = seen || </span><span class="s1">new </span><span class="s2">Set()</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(seen.has(value)) {</span>
        <span class="s1">return </span><span class="s2">value</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s2">seen.add(value)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(reactivity.isRef(value)) {</span>
        <span class="s2">traverse(value.value</span><span class="s1">, </span><span class="s2">seen)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(shared.isArray(value)) {</span>
        <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s5">0</span><span class="s1">; </span><span class="s2">i &lt; value.length</span><span class="s1">; </span><span class="s2">i++) {</span>
            <span class="s2">traverse(value[i]</span><span class="s1">, </span><span class="s2">seen)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(shared.isSet(value) || shared.isMap(value)) {</span>
        <span class="s2">value.forEach((v) =&gt; {</span>
            <span class="s2">traverse(v</span><span class="s1">, </span><span class="s2">seen)</span><span class="s1">;</span>
        <span class="s2">})</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(shared.isPlainObject(value)) {</span>
        <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">key </span><span class="s1">in </span><span class="s2">value) {</span>
            <span class="s2">traverse(value[key]</span><span class="s1">, </span><span class="s2">seen)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">value</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s1">function </span><span class="s2">useTransitionState() {</span>
    <span class="s1">const </span><span class="s2">state = {</span>
        <span class="s2">isMounted: </span><span class="s1">false,</span>
        <span class="s2">isLeaving: </span><span class="s1">false,</span>
        <span class="s2">isUnmounting: </span><span class="s1">false,</span>
        <span class="s2">leavingVNodes: </span><span class="s1">new </span><span class="s2">Map()</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s2">onMounted(() =&gt; {</span>
        <span class="s2">state.isMounted = </span><span class="s1">true;</span>
    <span class="s2">})</span><span class="s1">;</span>
    <span class="s2">onBeforeUnmount(() =&gt; {</span>
        <span class="s2">state.isUnmounting = </span><span class="s1">true;</span>
    <span class="s2">})</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">state</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">const </span><span class="s2">TransitionHookValidator = [Function</span><span class="s1">, </span><span class="s2">Array]</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">BaseTransitionImpl = {</span>
    <span class="s2">name: </span><span class="s0">`BaseTransition`</span><span class="s1">,</span>
    <span class="s2">props: {</span>
        <span class="s2">mode: String</span><span class="s1">,</span>
        <span class="s2">appear: Boolean</span><span class="s1">,</span>
        <span class="s2">persisted: Boolean</span><span class="s1">,</span>
        <span class="s6">// enter</span>
        <span class="s2">onBeforeEnter: TransitionHookValidator</span><span class="s1">,</span>
        <span class="s2">onEnter: TransitionHookValidator</span><span class="s1">,</span>
        <span class="s2">onAfterEnter: TransitionHookValidator</span><span class="s1">,</span>
        <span class="s2">onEnterCancelled: TransitionHookValidator</span><span class="s1">,</span>
        <span class="s6">// leave</span>
        <span class="s2">onBeforeLeave: TransitionHookValidator</span><span class="s1">,</span>
        <span class="s2">onLeave: TransitionHookValidator</span><span class="s1">,</span>
        <span class="s2">onAfterLeave: TransitionHookValidator</span><span class="s1">,</span>
        <span class="s2">onLeaveCancelled: TransitionHookValidator</span><span class="s1">,</span>
        <span class="s6">// appear</span>
        <span class="s2">onBeforeAppear: TransitionHookValidator</span><span class="s1">,</span>
        <span class="s2">onAppear: TransitionHookValidator</span><span class="s1">,</span>
        <span class="s2">onAfterAppear: TransitionHookValidator</span><span class="s1">,</span>
        <span class="s2">onAppearCancelled: TransitionHookValidator</span>
    <span class="s2">}</span><span class="s1">,</span>
    <span class="s2">setup(props</span><span class="s1">, </span><span class="s2">{ slots }) {</span>
        <span class="s1">const </span><span class="s2">instance = getCurrentInstance()</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">state = useTransitionState()</span><span class="s1">;</span>
        <span class="s1">let </span><span class="s2">prevTransitionKey</span><span class="s1">;</span>
        <span class="s1">return </span><span class="s2">() =&gt; {</span>
            <span class="s1">const </span><span class="s2">children = slots.default &amp;&amp; getTransitionRawChildren(slots.default()</span><span class="s1">, true</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(!children || !children.length) {</span>
                <span class="s1">return;</span>
            <span class="s2">}</span>
            <span class="s1">let </span><span class="s2">child = children[</span><span class="s5">0</span><span class="s2">]</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(children.length &gt; </span><span class="s5">1</span><span class="s2">) {</span>
                <span class="s6">// locate first non-comment child</span>
                <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">c of children) {</span>
                    <span class="s1">if </span><span class="s2">(c.type !== Comment) {</span>
                        <span class="s2">child = c</span><span class="s1">;</span>
                        <span class="s1">break;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s6">// there's no need to track reactivity for these props so use the raw</span>
            <span class="s6">// props for a bit better perf</span>
            <span class="s1">const </span><span class="s2">rawProps = reactivity.toRaw(props)</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">{ mode } = rawProps</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(state.isLeaving) {</span>
                <span class="s1">return </span><span class="s2">emptyPlaceholder(child)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s6">// in the case of &lt;transition&gt;&lt;keep-alive/&gt;&lt;/transition&gt;, we need to</span>
            <span class="s6">// compare the type of the kept-alive children.</span>
            <span class="s1">const </span><span class="s2">innerChild = getKeepAliveChild(child)</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(!innerChild) {</span>
                <span class="s1">return </span><span class="s2">emptyPlaceholder(child)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">const </span><span class="s2">enterHooks = resolveTransitionHooks(innerChild</span><span class="s1">, </span><span class="s2">rawProps</span><span class="s1">, </span><span class="s2">state</span><span class="s1">, </span><span class="s2">instance)</span><span class="s1">;</span>
            <span class="s2">setTransitionHooks(innerChild</span><span class="s1">, </span><span class="s2">enterHooks)</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">oldChild = instance.subTree</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">oldInnerChild = oldChild &amp;&amp; getKeepAliveChild(oldChild)</span><span class="s1">;</span>
            <span class="s1">let </span><span class="s2">transitionKeyChanged = </span><span class="s1">false;</span>
            <span class="s1">const </span><span class="s2">{ getTransitionKey } = innerChild.type</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(getTransitionKey) {</span>
                <span class="s1">const </span><span class="s2">key = getTransitionKey()</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(prevTransitionKey === undefined) {</span>
                    <span class="s2">prevTransitionKey = key</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else if </span><span class="s2">(key !== prevTransitionKey) {</span>
                    <span class="s2">prevTransitionKey = key</span><span class="s1">;</span>
                    <span class="s2">transitionKeyChanged = </span><span class="s1">true;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s6">// handle mode</span>
            <span class="s1">if </span><span class="s2">(oldInnerChild &amp;&amp;</span>
                <span class="s2">oldInnerChild.type !== Comment &amp;&amp;</span>
                <span class="s2">(!isSameVNodeType(innerChild</span><span class="s1">, </span><span class="s2">oldInnerChild) || transitionKeyChanged)) {</span>
                <span class="s1">const </span><span class="s2">leavingHooks = resolveTransitionHooks(oldInnerChild</span><span class="s1">, </span><span class="s2">rawProps</span><span class="s1">, </span><span class="s2">state</span><span class="s1">, </span><span class="s2">instance)</span><span class="s1">;</span>
                <span class="s6">// update old tree's hooks in case of dynamic transition</span>
                <span class="s2">setTransitionHooks(oldInnerChild</span><span class="s1">, </span><span class="s2">leavingHooks)</span><span class="s1">;</span>
                <span class="s6">// switching between different views</span>
                <span class="s1">if </span><span class="s2">(mode === </span><span class="s0">'out-in'</span><span class="s2">) {</span>
                    <span class="s2">state.isLeaving = </span><span class="s1">true;</span>
                    <span class="s6">// return placeholder node and queue update when leave finishes</span>
                    <span class="s2">leavingHooks.afterLeave = () =&gt; {</span>
                        <span class="s2">state.isLeaving = </span><span class="s1">false;</span>
                        <span class="s6">// #6835</span>
                        <span class="s6">// it also needs to be updated when active is undefined</span>
                        <span class="s1">if </span><span class="s2">(instance.update.active !== </span><span class="s1">false</span><span class="s2">) {</span>
                            <span class="s2">instance.update()</span><span class="s1">;</span>
                        <span class="s2">}</span>
                    <span class="s2">}</span><span class="s1">;</span>
                    <span class="s1">return </span><span class="s2">emptyPlaceholder(child)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else if </span><span class="s2">(mode === </span><span class="s0">'in-out' </span><span class="s2">&amp;&amp; innerChild.type !== Comment) {</span>
                    <span class="s2">leavingHooks.delayLeave = (el</span><span class="s1">, </span><span class="s2">earlyRemove</span><span class="s1">, </span><span class="s2">delayedLeave) =&gt; {</span>
                        <span class="s1">const </span><span class="s2">leavingVNodesCache = getLeavingNodesForType(state</span><span class="s1">, </span><span class="s2">oldInnerChild)</span><span class="s1">;</span>
                        <span class="s2">leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild</span><span class="s1">;</span>
                        <span class="s6">// early removal callback</span>
                        <span class="s2">el._leaveCb = () =&gt; {</span>
                            <span class="s2">earlyRemove()</span><span class="s1">;</span>
                            <span class="s2">el._leaveCb = undefined</span><span class="s1">;</span>
                            <span class="s1">delete </span><span class="s2">enterHooks.delayedLeave</span><span class="s1">;</span>
                        <span class="s2">}</span><span class="s1">;</span>
                        <span class="s2">enterHooks.delayedLeave = delayedLeave</span><span class="s1">;</span>
                    <span class="s2">}</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s1">return </span><span class="s2">child</span><span class="s1">;</span>
        <span class="s2">}</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s6">// export the public type for h/tsx inference</span>
<span class="s6">// also to avoid inline import() in generated d.ts files</span>
<span class="s1">const </span><span class="s2">BaseTransition = BaseTransitionImpl</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">getLeavingNodesForType(state</span><span class="s1">, </span><span class="s2">vnode) {</span>
    <span class="s1">const </span><span class="s2">{ leavingVNodes } = state</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">leavingVNodesCache = leavingVNodes.get(vnode.type)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(!leavingVNodesCache) {</span>
        <span class="s2">leavingVNodesCache = Object.create(</span><span class="s1">null</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">leavingVNodes.set(vnode.type</span><span class="s1">, </span><span class="s2">leavingVNodesCache)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">leavingVNodesCache</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s6">// The transition hooks are attached to the vnode as vnode.transition</span>
<span class="s6">// and will be called at appropriate timing in the renderer.</span>
<span class="s1">function </span><span class="s2">resolveTransitionHooks(vnode</span><span class="s1">, </span><span class="s2">props</span><span class="s1">, </span><span class="s2">state</span><span class="s1">, </span><span class="s2">instance) {</span>
    <span class="s1">const </span><span class="s2">{ appear</span><span class="s1">, </span><span class="s2">mode</span><span class="s1">, </span><span class="s2">persisted = </span><span class="s1">false, </span><span class="s2">onBeforeEnter</span><span class="s1">, </span><span class="s2">onEnter</span><span class="s1">, </span><span class="s2">onAfterEnter</span><span class="s1">, </span><span class="s2">onEnterCancelled</span><span class="s1">, </span><span class="s2">onBeforeLeave</span><span class="s1">, </span><span class="s2">onLeave</span><span class="s1">, </span><span class="s2">onAfterLeave</span><span class="s1">, </span><span class="s2">onLeaveCancelled</span><span class="s1">, </span><span class="s2">onBeforeAppear</span><span class="s1">, </span><span class="s2">onAppear</span><span class="s1">, </span><span class="s2">onAfterAppear</span><span class="s1">, </span><span class="s2">onAppearCancelled } = props</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">key = String(vnode.key)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">leavingVNodesCache = getLeavingNodesForType(state</span><span class="s1">, </span><span class="s2">vnode)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">callHook = (hook</span><span class="s1">, </span><span class="s2">args) =&gt; {</span>
        <span class="s2">hook &amp;&amp;</span>
            <span class="s2">callWithAsyncErrorHandling(hook</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s5">9 </span><span class="s6">/* ErrorCodes.TRANSITION_HOOK */</span><span class="s1">, </span><span class="s2">args)</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">callAsyncHook = (hook</span><span class="s1">, </span><span class="s2">args) =&gt; {</span>
        <span class="s1">const </span><span class="s2">done = args[</span><span class="s5">1</span><span class="s2">]</span><span class="s1">;</span>
        <span class="s2">callHook(hook</span><span class="s1">, </span><span class="s2">args)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(shared.isArray(hook)) {</span>
            <span class="s1">if </span><span class="s2">(hook.every(hook =&gt; hook.length &lt;= </span><span class="s5">1</span><span class="s2">))</span>
                <span class="s2">done()</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(hook.length &lt;= </span><span class="s5">1</span><span class="s2">) {</span>
            <span class="s2">done()</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">hooks = {</span>
        <span class="s2">mode</span><span class="s1">,</span>
        <span class="s2">persisted</span><span class="s1">,</span>
        <span class="s2">beforeEnter(el) {</span>
            <span class="s1">let </span><span class="s2">hook = onBeforeEnter</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(!state.isMounted) {</span>
                <span class="s1">if </span><span class="s2">(appear) {</span>
                    <span class="s2">hook = onBeforeAppear || onBeforeEnter</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s1">return;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s6">// for same element (v-show)</span>
            <span class="s1">if </span><span class="s2">(el._leaveCb) {</span>
                <span class="s2">el._leaveCb(</span><span class="s1">true </span><span class="s6">/* cancelled */</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s6">// for toggled element with same key (v-if)</span>
            <span class="s1">const </span><span class="s2">leavingVNode = leavingVNodesCache[key]</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(leavingVNode &amp;&amp;</span>
                <span class="s2">isSameVNodeType(vnode</span><span class="s1">, </span><span class="s2">leavingVNode) &amp;&amp;</span>
                <span class="s2">leavingVNode.el._leaveCb) {</span>
                <span class="s6">// force early removal (not cancelled)</span>
                <span class="s2">leavingVNode.el._leaveCb()</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s2">callHook(hook</span><span class="s1">, </span><span class="s2">[el])</span><span class="s1">;</span>
        <span class="s2">}</span><span class="s1">,</span>
        <span class="s2">enter(el) {</span>
            <span class="s1">let </span><span class="s2">hook = onEnter</span><span class="s1">;</span>
            <span class="s1">let </span><span class="s2">afterHook = onAfterEnter</span><span class="s1">;</span>
            <span class="s1">let </span><span class="s2">cancelHook = onEnterCancelled</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(!state.isMounted) {</span>
                <span class="s1">if </span><span class="s2">(appear) {</span>
                    <span class="s2">hook = onAppear || onEnter</span><span class="s1">;</span>
                    <span class="s2">afterHook = onAfterAppear || onAfterEnter</span><span class="s1">;</span>
                    <span class="s2">cancelHook = onAppearCancelled || onEnterCancelled</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s1">return;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s1">let </span><span class="s2">called = </span><span class="s1">false;</span>
            <span class="s1">const </span><span class="s2">done = (el._enterCb = (cancelled) =&gt; {</span>
                <span class="s1">if </span><span class="s2">(called)</span>
                    <span class="s1">return;</span>
                <span class="s2">called = </span><span class="s1">true;</span>
                <span class="s1">if </span><span class="s2">(cancelled) {</span>
                    <span class="s2">callHook(cancelHook</span><span class="s1">, </span><span class="s2">[el])</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s2">callHook(afterHook</span><span class="s1">, </span><span class="s2">[el])</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">if </span><span class="s2">(hooks.delayedLeave) {</span>
                    <span class="s2">hooks.delayedLeave()</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s2">el._enterCb = undefined</span><span class="s1">;</span>
            <span class="s2">})</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(hook) {</span>
                <span class="s2">callAsyncHook(hook</span><span class="s1">, </span><span class="s2">[el</span><span class="s1">, </span><span class="s2">done])</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s2">done()</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span><span class="s1">,</span>
        <span class="s2">leave(el</span><span class="s1">, </span><span class="s2">remove) {</span>
            <span class="s1">const </span><span class="s2">key = String(vnode.key)</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(el._enterCb) {</span>
                <span class="s2">el._enterCb(</span><span class="s1">true </span><span class="s6">/* cancelled */</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">if </span><span class="s2">(state.isUnmounting) {</span>
                <span class="s1">return </span><span class="s2">remove()</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s2">callHook(onBeforeLeave</span><span class="s1">, </span><span class="s2">[el])</span><span class="s1">;</span>
            <span class="s1">let </span><span class="s2">called = </span><span class="s1">false;</span>
            <span class="s1">const </span><span class="s2">done = (el._leaveCb = (cancelled) =&gt; {</span>
                <span class="s1">if </span><span class="s2">(called)</span>
                    <span class="s1">return;</span>
                <span class="s2">called = </span><span class="s1">true;</span>
                <span class="s2">remove()</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(cancelled) {</span>
                    <span class="s2">callHook(onLeaveCancelled</span><span class="s1">, </span><span class="s2">[el])</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s2">callHook(onAfterLeave</span><span class="s1">, </span><span class="s2">[el])</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s2">el._leaveCb = undefined</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(leavingVNodesCache[key] === vnode) {</span>
                    <span class="s1">delete </span><span class="s2">leavingVNodesCache[key]</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">})</span><span class="s1">;</span>
            <span class="s2">leavingVNodesCache[key] = vnode</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(onLeave) {</span>
                <span class="s2">callAsyncHook(onLeave</span><span class="s1">, </span><span class="s2">[el</span><span class="s1">, </span><span class="s2">done])</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s2">done()</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span><span class="s1">,</span>
        <span class="s2">clone(vnode) {</span>
            <span class="s1">return </span><span class="s2">resolveTransitionHooks(vnode</span><span class="s1">, </span><span class="s2">props</span><span class="s1">, </span><span class="s2">state</span><span class="s1">, </span><span class="s2">instance)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">hooks</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s6">// the placeholder really only handles one special case: KeepAlive</span>
<span class="s6">// in the case of a KeepAlive in a leave phase we need to return a KeepAlive</span>
<span class="s6">// placeholder with empty content to avoid the KeepAlive instance from being</span>
<span class="s6">// unmounted.</span>
<span class="s1">function </span><span class="s2">emptyPlaceholder(vnode) {</span>
    <span class="s1">if </span><span class="s2">(isKeepAlive(vnode)) {</span>
        <span class="s2">vnode = cloneVNode(vnode)</span><span class="s1">;</span>
        <span class="s2">vnode.children = </span><span class="s1">null;</span>
        <span class="s1">return </span><span class="s2">vnode</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">getKeepAliveChild(vnode) {</span>
    <span class="s1">return </span><span class="s2">isKeepAlive(vnode)</span>
        <span class="s2">? vnode.children</span>
            <span class="s2">? vnode.children[</span><span class="s5">0</span><span class="s2">]</span>
            <span class="s2">: undefined</span>
        <span class="s2">: vnode</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">setTransitionHooks(vnode</span><span class="s1">, </span><span class="s2">hooks) {</span>
    <span class="s1">if </span><span class="s2">(vnode.shapeFlag &amp; </span><span class="s5">6 </span><span class="s6">/* ShapeFlags.COMPONENT */ </span><span class="s2">&amp;&amp; vnode.component) {</span>
        <span class="s2">setTransitionHooks(vnode.component.subTree</span><span class="s1">, </span><span class="s2">hooks)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(vnode.shapeFlag &amp; </span><span class="s5">128 </span><span class="s6">/* ShapeFlags.SUSPENSE */</span><span class="s2">) {</span>
        <span class="s2">vnode.ssContent.transition = hooks.clone(vnode.ssContent)</span><span class="s1">;</span>
        <span class="s2">vnode.ssFallback.transition = hooks.clone(vnode.ssFallback)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s2">vnode.transition = hooks</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">getTransitionRawChildren(children</span><span class="s1">, </span><span class="s2">keepComment = </span><span class="s1">false, </span><span class="s2">parentKey) {</span>
    <span class="s1">let </span><span class="s2">ret = []</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">keyedFragmentCount = </span><span class="s5">0</span><span class="s1">;</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s5">0</span><span class="s1">; </span><span class="s2">i &lt; children.length</span><span class="s1">; </span><span class="s2">i++) {</span>
        <span class="s1">let </span><span class="s2">child = children[i]</span><span class="s1">;</span>
        <span class="s6">// #5360 inherit parent key in case of &lt;template v-for&gt;</span>
        <span class="s1">const </span><span class="s2">key = parentKey == </span><span class="s1">null</span>
            <span class="s2">? child.key</span>
            <span class="s2">: String(parentKey) + String(child.key != </span><span class="s1">null </span><span class="s2">? child.key : i)</span><span class="s1">;</span>
        <span class="s6">// handle fragment children case, e.g. v-for</span>
        <span class="s1">if </span><span class="s2">(child.type === Fragment) {</span>
            <span class="s1">if </span><span class="s2">(child.patchFlag &amp; </span><span class="s5">128 </span><span class="s6">/* PatchFlags.KEYED_FRAGMENT */</span><span class="s2">)</span>
                <span class="s2">keyedFragmentCount++</span><span class="s1">;</span>
            <span class="s2">ret = ret.concat(getTransitionRawChildren(child.children</span><span class="s1">, </span><span class="s2">keepComment</span><span class="s1">, </span><span class="s2">key))</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s6">// comment placeholders should be skipped, e.g. v-if</span>
        <span class="s1">else if </span><span class="s2">(keepComment || child.type !== Comment) {</span>
            <span class="s2">ret.push(key != </span><span class="s1">null </span><span class="s2">? cloneVNode(child</span><span class="s1">, </span><span class="s2">{ key }) : child)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s6">// #1126 if a transition children list contains multiple sub fragments, these</span>
    <span class="s6">// fragments will be merged into a flat children array. Since each v-for</span>
    <span class="s6">// fragment may contain different static bindings inside, we need to de-op</span>
    <span class="s6">// these children to force full diffs to ensure correct behavior.</span>
    <span class="s1">if </span><span class="s2">(keyedFragmentCount &gt; </span><span class="s5">1</span><span class="s2">) {</span>
        <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s5">0</span><span class="s1">; </span><span class="s2">i &lt; ret.length</span><span class="s1">; </span><span class="s2">i++) {</span>
            <span class="s2">ret[i].patchFlag = -</span><span class="s5">2 </span><span class="s6">/* PatchFlags.BAIL */</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">ret</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s6">// implementation, close to no-op</span>
<span class="s1">function </span><span class="s2">defineComponent(options) {</span>
    <span class="s1">return </span><span class="s2">shared.isFunction(options) ? { setup: options</span><span class="s1">, </span><span class="s2">name: options.name } : options</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s1">const </span><span class="s2">isAsyncWrapper = (i) =&gt; !!i.type.__asyncLoader</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">defineAsyncComponent(source) {</span>
    <span class="s1">if </span><span class="s2">(shared.isFunction(source)) {</span>
        <span class="s2">source = { loader: source }</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">{ loader</span><span class="s1">, </span><span class="s2">loadingComponent</span><span class="s1">, </span><span class="s2">errorComponent</span><span class="s1">, </span><span class="s2">delay = </span><span class="s5">200</span><span class="s1">, </span><span class="s2">timeout</span><span class="s1">, </span><span class="s6">// undefined = never times out</span>
    <span class="s2">suspensible = </span><span class="s1">true, </span><span class="s2">onError: userOnError } = source</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">pendingRequest = </span><span class="s1">null;</span>
    <span class="s1">let </span><span class="s2">resolvedComp</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">retries = </span><span class="s5">0</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">retry = () =&gt; {</span>
        <span class="s2">retries++</span><span class="s1">;</span>
        <span class="s2">pendingRequest = </span><span class="s1">null;</span>
        <span class="s1">return </span><span class="s2">load()</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">load = () =&gt; {</span>
        <span class="s1">let </span><span class="s2">thisRequest</span><span class="s1">;</span>
        <span class="s1">return </span><span class="s2">(pendingRequest ||</span>
            <span class="s2">(thisRequest = pendingRequest =</span>
                <span class="s2">loader()</span>
                    <span class="s2">.catch(err =&gt; {</span>
                    <span class="s2">err = err </span><span class="s1">instanceof </span><span class="s2">Error ? err : </span><span class="s1">new </span><span class="s2">Error(String(err))</span><span class="s1">;</span>
                    <span class="s1">if </span><span class="s2">(userOnError) {</span>
                        <span class="s1">return new </span><span class="s2">Promise((resolve</span><span class="s1">, </span><span class="s2">reject) =&gt; {</span>
                            <span class="s1">const </span><span class="s2">userRetry = () =&gt; resolve(retry())</span><span class="s1">;</span>
                            <span class="s1">const </span><span class="s2">userFail = () =&gt; reject(err)</span><span class="s1">;</span>
                            <span class="s2">userOnError(err</span><span class="s1">, </span><span class="s2">userRetry</span><span class="s1">, </span><span class="s2">userFail</span><span class="s1">, </span><span class="s2">retries + </span><span class="s5">1</span><span class="s2">)</span><span class="s1">;</span>
                        <span class="s2">})</span><span class="s1">;</span>
                    <span class="s2">}</span>
                    <span class="s1">else </span><span class="s2">{</span>
                        <span class="s1">throw </span><span class="s2">err</span><span class="s1">;</span>
                    <span class="s2">}</span>
                <span class="s2">})</span>
                    <span class="s2">.then((comp) =&gt; {</span>
                    <span class="s1">if </span><span class="s2">(thisRequest !== pendingRequest &amp;&amp; pendingRequest) {</span>
                        <span class="s1">return </span><span class="s2">pendingRequest</span><span class="s1">;</span>
                    <span class="s2">}</span>
                    <span class="s6">// interop module default</span>
                    <span class="s1">if </span><span class="s2">(comp &amp;&amp;</span>
                        <span class="s2">(comp.__esModule || comp[Symbol.toStringTag] === </span><span class="s0">'Module'</span><span class="s2">)) {</span>
                        <span class="s2">comp = comp.default</span><span class="s1">;</span>
                    <span class="s2">}</span>
                    <span class="s2">resolvedComp = comp</span><span class="s1">;</span>
                    <span class="s1">return </span><span class="s2">comp</span><span class="s1">;</span>
                <span class="s2">})))</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">defineComponent({</span>
        <span class="s2">name: </span><span class="s0">'AsyncComponentWrapper'</span><span class="s1">,</span>
        <span class="s2">__asyncLoader: load</span><span class="s1">,</span>
        <span class="s2">get __asyncResolved() {</span>
            <span class="s1">return </span><span class="s2">resolvedComp</span><span class="s1">;</span>
        <span class="s2">}</span><span class="s1">,</span>
        <span class="s2">setup() {</span>
            <span class="s1">const </span><span class="s2">instance = currentInstance</span><span class="s1">;</span>
            <span class="s6">// already resolved</span>
            <span class="s1">if </span><span class="s2">(resolvedComp) {</span>
                <span class="s1">return </span><span class="s2">() =&gt; createInnerComp(resolvedComp</span><span class="s1">, </span><span class="s2">instance)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">const </span><span class="s2">onError = (err) =&gt; {</span>
                <span class="s2">pendingRequest = </span><span class="s1">null;</span>
                <span class="s2">handleError(err</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s5">13 </span><span class="s6">/* ErrorCodes.ASYNC_COMPONENT_LOADER */</span><span class="s1">, </span><span class="s2">!errorComponent </span><span class="s6">/* do not throw in dev if user provided error component */</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span><span class="s1">;</span>
            <span class="s6">// suspense-controlled or SSR.</span>
            <span class="s1">if </span><span class="s2">((suspensible &amp;&amp; instance.suspense) ||</span>
                <span class="s2">(isInSSRComponentSetup)) {</span>
                <span class="s1">return </span><span class="s2">load()</span>
                    <span class="s2">.then(comp =&gt; {</span>
                    <span class="s1">return </span><span class="s2">() =&gt; createInnerComp(comp</span><span class="s1">, </span><span class="s2">instance)</span><span class="s1">;</span>
                <span class="s2">})</span>
                    <span class="s2">.catch(err =&gt; {</span>
                    <span class="s2">onError(err)</span><span class="s1">;</span>
                    <span class="s1">return </span><span class="s2">() =&gt; errorComponent</span>
                        <span class="s2">? createVNode(errorComponent</span><span class="s1">, </span><span class="s2">{</span>
                            <span class="s2">error: err</span>
                        <span class="s2">})</span>
                        <span class="s2">: </span><span class="s1">null;</span>
                <span class="s2">})</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">const </span><span class="s2">loaded = reactivity.ref(</span><span class="s1">false</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">error = reactivity.ref()</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">delayed = reactivity.ref(!!delay)</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(delay) {</span>
                <span class="s2">setTimeout(() =&gt; {</span>
                    <span class="s2">delayed.value = </span><span class="s1">false;</span>
                <span class="s2">}</span><span class="s1">, </span><span class="s2">delay)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">if </span><span class="s2">(timeout != </span><span class="s1">null</span><span class="s2">) {</span>
                <span class="s2">setTimeout(() =&gt; {</span>
                    <span class="s1">if </span><span class="s2">(!loaded.value &amp;&amp; !error.value) {</span>
                        <span class="s1">const </span><span class="s2">err = </span><span class="s1">new </span><span class="s2">Error(</span><span class="s0">`Async component timed out after </span><span class="s2">${timeout}</span><span class="s0">ms.`</span><span class="s2">)</span><span class="s1">;</span>
                        <span class="s2">onError(err)</span><span class="s1">;</span>
                        <span class="s2">error.value = err</span><span class="s1">;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span><span class="s1">, </span><span class="s2">timeout)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s2">load()</span>
                <span class="s2">.then(() =&gt; {</span>
                <span class="s2">loaded.value = </span><span class="s1">true;</span>
                <span class="s1">if </span><span class="s2">(instance.parent &amp;&amp; isKeepAlive(instance.parent.vnode)) {</span>
                    <span class="s6">// parent is keep-alive, force update so the loaded component's</span>
                    <span class="s6">// name is taken into account</span>
                    <span class="s2">queueJob(instance.parent.update)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">})</span>
                <span class="s2">.catch(err =&gt; {</span>
                <span class="s2">onError(err)</span><span class="s1">;</span>
                <span class="s2">error.value = err</span><span class="s1">;</span>
            <span class="s2">})</span><span class="s1">;</span>
            <span class="s1">return </span><span class="s2">() =&gt; {</span>
                <span class="s1">if </span><span class="s2">(loaded.value &amp;&amp; resolvedComp) {</span>
                    <span class="s1">return </span><span class="s2">createInnerComp(resolvedComp</span><span class="s1">, </span><span class="s2">instance)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else if </span><span class="s2">(error.value &amp;&amp; errorComponent) {</span>
                    <span class="s1">return </span><span class="s2">createVNode(errorComponent</span><span class="s1">, </span><span class="s2">{</span>
                        <span class="s2">error: error.value</span>
                    <span class="s2">})</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else if </span><span class="s2">(loadingComponent &amp;&amp; !delayed.value) {</span>
                    <span class="s1">return </span><span class="s2">createVNode(loadingComponent)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">})</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">createInnerComp(comp</span><span class="s1">, </span><span class="s2">parent) {</span>
    <span class="s1">const </span><span class="s2">{ ref</span><span class="s1">, </span><span class="s2">props</span><span class="s1">, </span><span class="s2">children</span><span class="s1">, </span><span class="s2">ce } = parent.vnode</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">vnode = createVNode(comp</span><span class="s1">, </span><span class="s2">props</span><span class="s1">, </span><span class="s2">children)</span><span class="s1">;</span>
    <span class="s6">// ensure inner component inherits the async wrapper's ref owner</span>
    <span class="s2">vnode.ref = ref</span><span class="s1">;</span>
    <span class="s6">// pass the custom element callback on to the inner comp</span>
    <span class="s6">// and remove it from the async wrapper</span>
    <span class="s2">vnode.ce = ce</span><span class="s1">;</span>
    <span class="s1">delete </span><span class="s2">parent.vnode.ce</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">vnode</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s1">const </span><span class="s2">isKeepAlive = (vnode) =&gt; vnode.type.__isKeepAlive</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">KeepAliveImpl = {</span>
    <span class="s2">name: </span><span class="s0">`KeepAlive`</span><span class="s1">,</span>
    <span class="s6">// Marker for special handling inside the renderer. We are not using a ===</span>
    <span class="s6">// check directly on KeepAlive in the renderer, because importing it directly</span>
    <span class="s6">// would prevent it from being tree-shaken.</span>
    <span class="s2">__isKeepAlive: </span><span class="s1">true,</span>
    <span class="s2">props: {</span>
        <span class="s2">include: [String</span><span class="s1">, </span><span class="s2">RegExp</span><span class="s1">, </span><span class="s2">Array]</span><span class="s1">,</span>
        <span class="s2">exclude: [String</span><span class="s1">, </span><span class="s2">RegExp</span><span class="s1">, </span><span class="s2">Array]</span><span class="s1">,</span>
        <span class="s2">max: [String</span><span class="s1">, </span><span class="s2">Number]</span>
    <span class="s2">}</span><span class="s1">,</span>
    <span class="s2">setup(props</span><span class="s1">, </span><span class="s2">{ slots }) {</span>
        <span class="s1">const </span><span class="s2">instance = getCurrentInstance()</span><span class="s1">;</span>
        <span class="s6">// KeepAlive communicates with the instantiated renderer via the</span>
        <span class="s6">// ctx where the renderer passes in its internals,</span>
        <span class="s6">// and the KeepAlive instance exposes activate/deactivate implementations.</span>
        <span class="s6">// The whole point of this is to avoid importing KeepAlive directly in the</span>
        <span class="s6">// renderer to facilitate tree-shaking.</span>
        <span class="s1">const </span><span class="s2">sharedContext = instance.ctx</span><span class="s1">;</span>
        <span class="s6">// if the internal renderer is not registered, it indicates that this is server-side rendering,</span>
        <span class="s6">// for KeepAlive, we just need to render its children</span>
        <span class="s1">if </span><span class="s2">(!sharedContext.renderer) {</span>
            <span class="s1">return </span><span class="s2">() =&gt; {</span>
                <span class="s1">const </span><span class="s2">children = slots.default &amp;&amp; slots.default()</span><span class="s1">;</span>
                <span class="s1">return </span><span class="s2">children &amp;&amp; children.length === </span><span class="s5">1 </span><span class="s2">? children[</span><span class="s5">0</span><span class="s2">] : children</span><span class="s1">;</span>
            <span class="s2">}</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">const </span><span class="s2">cache = </span><span class="s1">new </span><span class="s2">Map()</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">keys = </span><span class="s1">new </span><span class="s2">Set()</span><span class="s1">;</span>
        <span class="s1">let </span><span class="s2">current = </span><span class="s1">null;</span>
        <span class="s1">const </span><span class="s2">parentSuspense = instance.suspense</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">{ renderer: { p: patch</span><span class="s1">, </span><span class="s2">m: move</span><span class="s1">, </span><span class="s2">um: _unmount</span><span class="s1">, </span><span class="s2">o: { createElement } } } = sharedContext</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">storageContainer = createElement(</span><span class="s0">'div'</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">sharedContext.activate = (vnode</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">optimized) =&gt; {</span>
            <span class="s1">const </span><span class="s2">instance = vnode.component</span><span class="s1">;</span>
            <span class="s2">move(vnode</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s5">0 </span><span class="s6">/* MoveType.ENTER */</span><span class="s1">, </span><span class="s2">parentSuspense)</span><span class="s1">;</span>
            <span class="s6">// in case props have changed</span>
            <span class="s2">patch(instance.vnode</span><span class="s1">, </span><span class="s2">vnode</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">vnode.slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
            <span class="s2">queuePostRenderEffect(() =&gt; {</span>
                <span class="s2">instance.isDeactivated = </span><span class="s1">false;</span>
                <span class="s1">if </span><span class="s2">(instance.a) {</span>
                    <span class="s2">shared.invokeArrayFns(instance.a)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">const </span><span class="s2">vnodeHook = vnode.props &amp;&amp; vnode.props.onVnodeMounted</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(vnodeHook) {</span>
                    <span class="s2">invokeVNodeHook(vnodeHook</span><span class="s1">, </span><span class="s2">instance.parent</span><span class="s1">, </span><span class="s2">vnode)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span><span class="s1">, </span><span class="s2">parentSuspense)</span><span class="s1">;</span>
        <span class="s2">}</span><span class="s1">;</span>
        <span class="s2">sharedContext.deactivate = (vnode) =&gt; {</span>
            <span class="s1">const </span><span class="s2">instance = vnode.component</span><span class="s1">;</span>
            <span class="s2">move(vnode</span><span class="s1">, </span><span class="s2">storageContainer</span><span class="s1">, null, </span><span class="s5">1 </span><span class="s6">/* MoveType.LEAVE */</span><span class="s1">, </span><span class="s2">parentSuspense)</span><span class="s1">;</span>
            <span class="s2">queuePostRenderEffect(() =&gt; {</span>
                <span class="s1">if </span><span class="s2">(instance.da) {</span>
                    <span class="s2">shared.invokeArrayFns(instance.da)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">const </span><span class="s2">vnodeHook = vnode.props &amp;&amp; vnode.props.onVnodeUnmounted</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(vnodeHook) {</span>
                    <span class="s2">invokeVNodeHook(vnodeHook</span><span class="s1">, </span><span class="s2">instance.parent</span><span class="s1">, </span><span class="s2">vnode)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s2">instance.isDeactivated = </span><span class="s1">true;</span>
            <span class="s2">}</span><span class="s1">, </span><span class="s2">parentSuspense)</span><span class="s1">;</span>
        <span class="s2">}</span><span class="s1">;</span>
        <span class="s1">function </span><span class="s2">unmount(vnode) {</span>
            <span class="s6">// reset the shapeFlag so it can be properly unmounted</span>
            <span class="s2">resetShapeFlag(vnode)</span><span class="s1">;</span>
            <span class="s2">_unmount(vnode</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, true</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">function </span><span class="s2">pruneCache(filter) {</span>
            <span class="s2">cache.forEach((vnode</span><span class="s1">, </span><span class="s2">key) =&gt; {</span>
                <span class="s1">const </span><span class="s2">name = getComponentName(vnode.type)</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(name &amp;&amp; (!filter || !filter(name))) {</span>
                    <span class="s2">pruneCacheEntry(key)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">})</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">function </span><span class="s2">pruneCacheEntry(key) {</span>
            <span class="s1">const </span><span class="s2">cached = cache.get(key)</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(!current || !isSameVNodeType(cached</span><span class="s1">, </span><span class="s2">current)) {</span>
                <span class="s2">unmount(cached)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(current) {</span>
                <span class="s6">// current active instance should no longer be kept-alive.</span>
                <span class="s6">// we can't unmount it now but it might be later, so reset its flag now.</span>
                <span class="s2">resetShapeFlag(current)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s2">cache.delete(key)</span><span class="s1">;</span>
            <span class="s2">keys.delete(key)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s6">// prune cache on include/exclude prop change</span>
        <span class="s2">watch(() =&gt; [props.include</span><span class="s1">, </span><span class="s2">props.exclude]</span><span class="s1">, </span><span class="s2">([include</span><span class="s1">, </span><span class="s2">exclude]) =&gt; {</span>
            <span class="s2">include &amp;&amp; pruneCache(name =&gt; matches(include</span><span class="s1">, </span><span class="s2">name))</span><span class="s1">;</span>
            <span class="s2">exclude &amp;&amp; pruneCache(name =&gt; !matches(exclude</span><span class="s1">, </span><span class="s2">name))</span><span class="s1">;</span>
        <span class="s2">}</span><span class="s1">, </span>
        <span class="s6">// prune post-render after `current` has been updated</span>
        <span class="s2">{ flush: </span><span class="s0">'post'</span><span class="s1">, </span><span class="s2">deep: </span><span class="s1">true </span><span class="s2">})</span><span class="s1">;</span>
        <span class="s6">// cache sub tree after render</span>
        <span class="s1">let </span><span class="s2">pendingCacheKey = </span><span class="s1">null;</span>
        <span class="s1">const </span><span class="s2">cacheSubtree = () =&gt; {</span>
            <span class="s6">// fix #1621, the pendingCacheKey could be 0</span>
            <span class="s1">if </span><span class="s2">(pendingCacheKey != </span><span class="s1">null</span><span class="s2">) {</span>
                <span class="s2">cache.set(pendingCacheKey</span><span class="s1">, </span><span class="s2">getInnerChild(instance.subTree))</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span><span class="s1">;</span>
        <span class="s2">onMounted(cacheSubtree)</span><span class="s1">;</span>
        <span class="s2">onUpdated(cacheSubtree)</span><span class="s1">;</span>
        <span class="s2">onBeforeUnmount(() =&gt; {</span>
            <span class="s2">cache.forEach(cached =&gt; {</span>
                <span class="s1">const </span><span class="s2">{ subTree</span><span class="s1">, </span><span class="s2">suspense } = instance</span><span class="s1">;</span>
                <span class="s1">const </span><span class="s2">vnode = getInnerChild(subTree)</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(cached.type === vnode.type &amp;&amp; cached.key === vnode.key) {</span>
                    <span class="s6">// current instance will be unmounted as part of keep-alive's unmount</span>
                    <span class="s2">resetShapeFlag(vnode)</span><span class="s1">;</span>
                    <span class="s6">// but invoke its deactivated hook here</span>
                    <span class="s1">const </span><span class="s2">da = vnode.component.da</span><span class="s1">;</span>
                    <span class="s2">da &amp;&amp; queuePostRenderEffect(da</span><span class="s1">, </span><span class="s2">suspense)</span><span class="s1">;</span>
                    <span class="s1">return;</span>
                <span class="s2">}</span>
                <span class="s2">unmount(cached)</span><span class="s1">;</span>
            <span class="s2">})</span><span class="s1">;</span>
        <span class="s2">})</span><span class="s1">;</span>
        <span class="s1">return </span><span class="s2">() =&gt; {</span>
            <span class="s2">pendingCacheKey = </span><span class="s1">null;</span>
            <span class="s1">if </span><span class="s2">(!slots.default) {</span>
                <span class="s1">return null;</span>
            <span class="s2">}</span>
            <span class="s1">const </span><span class="s2">children = slots.default()</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">rawVNode = children[</span><span class="s5">0</span><span class="s2">]</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(children.length &gt; </span><span class="s5">1</span><span class="s2">) {</span>
                <span class="s2">current = </span><span class="s1">null;</span>
                <span class="s1">return </span><span class="s2">children</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(!isVNode(rawVNode) ||</span>
                <span class="s2">(!(rawVNode.shapeFlag &amp; </span><span class="s5">4 </span><span class="s6">/* ShapeFlags.STATEFUL_COMPONENT */</span><span class="s2">) &amp;&amp;</span>
                    <span class="s2">!(rawVNode.shapeFlag &amp; </span><span class="s5">128 </span><span class="s6">/* ShapeFlags.SUSPENSE */</span><span class="s2">))) {</span>
                <span class="s2">current = </span><span class="s1">null;</span>
                <span class="s1">return </span><span class="s2">rawVNode</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">let </span><span class="s2">vnode = getInnerChild(rawVNode)</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">comp = vnode.type</span><span class="s1">;</span>
            <span class="s6">// for async components, name check should be based in its loaded</span>
            <span class="s6">// inner component if available</span>
            <span class="s1">const </span><span class="s2">name = getComponentName(isAsyncWrapper(vnode)</span>
                <span class="s2">? vnode.type.__asyncResolved || {}</span>
                <span class="s2">: comp)</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">{ include</span><span class="s1">, </span><span class="s2">exclude</span><span class="s1">, </span><span class="s2">max } = props</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">((include &amp;&amp; (!name || !matches(include</span><span class="s1">, </span><span class="s2">name))) ||</span>
                <span class="s2">(exclude &amp;&amp; name &amp;&amp; matches(exclude</span><span class="s1">, </span><span class="s2">name))) {</span>
                <span class="s2">current = vnode</span><span class="s1">;</span>
                <span class="s1">return </span><span class="s2">rawVNode</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">const </span><span class="s2">key = vnode.key == </span><span class="s1">null </span><span class="s2">? comp : vnode.key</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">cachedVNode = cache.get(key)</span><span class="s1">;</span>
            <span class="s6">// clone vnode if it's reused because we are going to mutate it</span>
            <span class="s1">if </span><span class="s2">(vnode.el) {</span>
                <span class="s2">vnode = cloneVNode(vnode)</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(rawVNode.shapeFlag &amp; </span><span class="s5">128 </span><span class="s6">/* ShapeFlags.SUSPENSE */</span><span class="s2">) {</span>
                    <span class="s2">rawVNode.ssContent = vnode</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s6">// #1513 it's possible for the returned vnode to be cloned due to attr</span>
            <span class="s6">// fallthrough or scopeId, so the vnode here may not be the final vnode</span>
            <span class="s6">// that is mounted. Instead of caching it directly, we store the pending</span>
            <span class="s6">// key and cache `instance.subTree` (the normalized vnode) in</span>
            <span class="s6">// beforeMount/beforeUpdate hooks.</span>
            <span class="s2">pendingCacheKey = key</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(cachedVNode) {</span>
                <span class="s6">// copy over mounted state</span>
                <span class="s2">vnode.el = cachedVNode.el</span><span class="s1">;</span>
                <span class="s2">vnode.component = cachedVNode.component</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(vnode.transition) {</span>
                    <span class="s6">// recursively update transition hooks on subTree</span>
                    <span class="s2">setTransitionHooks(vnode</span><span class="s1">, </span><span class="s2">vnode.transition)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s6">// avoid vnode being mounted as fresh</span>
                <span class="s2">vnode.shapeFlag |= </span><span class="s5">512 </span><span class="s6">/* ShapeFlags.COMPONENT_KEPT_ALIVE */</span><span class="s1">;</span>
                <span class="s6">// make this key the freshest</span>
                <span class="s2">keys.delete(key)</span><span class="s1">;</span>
                <span class="s2">keys.add(key)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s2">keys.add(key)</span><span class="s1">;</span>
                <span class="s6">// prune oldest entry</span>
                <span class="s1">if </span><span class="s2">(max &amp;&amp; keys.size &gt; parseInt(max</span><span class="s1">, </span><span class="s5">10</span><span class="s2">)) {</span>
                    <span class="s2">pruneCacheEntry(keys.values().next().value)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s6">// avoid vnode being unmounted</span>
            <span class="s2">vnode.shapeFlag |= </span><span class="s5">256 </span><span class="s6">/* ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE */</span><span class="s1">;</span>
            <span class="s2">current = vnode</span><span class="s1">;</span>
            <span class="s1">return </span><span class="s2">isSuspense(rawVNode.type) ? rawVNode : vnode</span><span class="s1">;</span>
        <span class="s2">}</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s6">// export the public type for h/tsx inference</span>
<span class="s6">// also to avoid inline import() in generated d.ts files</span>
<span class="s1">const </span><span class="s2">KeepAlive = KeepAliveImpl</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">matches(pattern</span><span class="s1">, </span><span class="s2">name) {</span>
    <span class="s1">if </span><span class="s2">(shared.isArray(pattern)) {</span>
        <span class="s1">return </span><span class="s2">pattern.some((p) =&gt; matches(p</span><span class="s1">, </span><span class="s2">name))</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(shared.isString(pattern)) {</span>
        <span class="s1">return </span><span class="s2">pattern.split(</span><span class="s0">','</span><span class="s2">).includes(name)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(shared.isRegExp(pattern)) {</span>
        <span class="s1">return </span><span class="s2">pattern.test(name)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s6">/* istanbul ignore next */</span>
    <span class="s1">return false;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">onActivated(hook</span><span class="s1">, </span><span class="s2">target) {</span>
    <span class="s2">registerKeepAliveHook(hook</span><span class="s1">, </span><span class="s0">&quot;a&quot; </span><span class="s6">/* LifecycleHooks.ACTIVATED */</span><span class="s1">, </span><span class="s2">target)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">onDeactivated(hook</span><span class="s1">, </span><span class="s2">target) {</span>
    <span class="s2">registerKeepAliveHook(hook</span><span class="s1">, </span><span class="s0">&quot;da&quot; </span><span class="s6">/* LifecycleHooks.DEACTIVATED */</span><span class="s1">, </span><span class="s2">target)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">registerKeepAliveHook(hook</span><span class="s1">, </span><span class="s2">type</span><span class="s1">, </span><span class="s2">target = currentInstance) {</span>
    <span class="s6">// cache the deactivate branch check wrapper for injected hooks so the same</span>
    <span class="s6">// hook can be properly deduped by the scheduler. &quot;__wdc&quot; stands for &quot;with</span>
    <span class="s6">// deactivation check&quot;.</span>
    <span class="s1">const </span><span class="s2">wrappedHook = hook.__wdc ||</span>
        <span class="s2">(hook.__wdc = () =&gt; {</span>
            <span class="s6">// only fire the hook if the target instance is NOT in a deactivated branch.</span>
            <span class="s1">let </span><span class="s2">current = target</span><span class="s1">;</span>
            <span class="s1">while </span><span class="s2">(current) {</span>
                <span class="s1">if </span><span class="s2">(current.isDeactivated) {</span>
                    <span class="s1">return;</span>
                <span class="s2">}</span>
                <span class="s2">current = current.parent</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">return </span><span class="s2">hook()</span><span class="s1">;</span>
        <span class="s2">})</span><span class="s1">;</span>
    <span class="s2">injectHook(type</span><span class="s1">, </span><span class="s2">wrappedHook</span><span class="s1">, </span><span class="s2">target)</span><span class="s1">;</span>
    <span class="s6">// In addition to registering it on the target instance, we walk up the parent</span>
    <span class="s6">// chain and register it on all ancestor instances that are keep-alive roots.</span>
    <span class="s6">// This avoids the need to walk the entire component tree when invoking these</span>
    <span class="s6">// hooks, and more importantly, avoids the need to track child components in</span>
    <span class="s6">// arrays.</span>
    <span class="s1">if </span><span class="s2">(target) {</span>
        <span class="s1">let </span><span class="s2">current = target.parent</span><span class="s1">;</span>
        <span class="s1">while </span><span class="s2">(current &amp;&amp; current.parent) {</span>
            <span class="s1">if </span><span class="s2">(isKeepAlive(current.parent.vnode)) {</span>
                <span class="s2">injectToKeepAliveRoot(wrappedHook</span><span class="s1">, </span><span class="s2">type</span><span class="s1">, </span><span class="s2">target</span><span class="s1">, </span><span class="s2">current)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s2">current = current.parent</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">injectToKeepAliveRoot(hook</span><span class="s1">, </span><span class="s2">type</span><span class="s1">, </span><span class="s2">target</span><span class="s1">, </span><span class="s2">keepAliveRoot) {</span>
    <span class="s6">// injectHook wraps the original for error handling, so make sure to remove</span>
    <span class="s6">// the wrapped version.</span>
    <span class="s1">const </span><span class="s2">injected = injectHook(type</span><span class="s1">, </span><span class="s2">hook</span><span class="s1">, </span><span class="s2">keepAliveRoot</span><span class="s1">, true </span><span class="s6">/* prepend */</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">onUnmounted(() =&gt; {</span>
        <span class="s2">shared.remove(keepAliveRoot[type]</span><span class="s1">, </span><span class="s2">injected)</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">, </span><span class="s2">target)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">resetShapeFlag(vnode) {</span>
    <span class="s6">// bitwise operations to remove keep alive flags</span>
    <span class="s2">vnode.shapeFlag &amp;= ~</span><span class="s5">256 </span><span class="s6">/* ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE */</span><span class="s1">;</span>
    <span class="s2">vnode.shapeFlag &amp;= ~</span><span class="s5">512 </span><span class="s6">/* ShapeFlags.COMPONENT_KEPT_ALIVE */</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">getInnerChild(vnode) {</span>
    <span class="s1">return </span><span class="s2">vnode.shapeFlag &amp; </span><span class="s5">128 </span><span class="s6">/* ShapeFlags.SUSPENSE */ </span><span class="s2">? vnode.ssContent : vnode</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s1">function </span><span class="s2">injectHook(type</span><span class="s1">, </span><span class="s2">hook</span><span class="s1">, </span><span class="s2">target = currentInstance</span><span class="s1">, </span><span class="s2">prepend = </span><span class="s1">false</span><span class="s2">) {</span>
    <span class="s1">if </span><span class="s2">(target) {</span>
        <span class="s1">const </span><span class="s2">hooks = target[type] || (target[type] = [])</span><span class="s1">;</span>
        <span class="s6">// cache the error handling wrapper for injected hooks so the same hook</span>
        <span class="s6">// can be properly deduped by the scheduler. &quot;__weh&quot; stands for &quot;with error</span>
        <span class="s6">// handling&quot;.</span>
        <span class="s1">const </span><span class="s2">wrappedHook = hook.__weh ||</span>
            <span class="s2">(hook.__weh = (...args) =&gt; {</span>
                <span class="s1">if </span><span class="s2">(target.isUnmounted) {</span>
                    <span class="s1">return;</span>
                <span class="s2">}</span>
                <span class="s6">// disable tracking inside all lifecycle hooks</span>
                <span class="s6">// since they can potentially be called inside effects.</span>
                <span class="s2">reactivity.pauseTracking()</span><span class="s1">;</span>
                <span class="s6">// Set currentInstance during hook invocation.</span>
                <span class="s6">// This assumes the hook does not synchronously trigger other hooks, which</span>
                <span class="s6">// can only be false when the user does something really funky.</span>
                <span class="s2">setCurrentInstance(target)</span><span class="s1">;</span>
                <span class="s1">const </span><span class="s2">res = callWithAsyncErrorHandling(hook</span><span class="s1">, </span><span class="s2">target</span><span class="s1">, </span><span class="s2">type</span><span class="s1">, </span><span class="s2">args)</span><span class="s1">;</span>
                <span class="s2">unsetCurrentInstance()</span><span class="s1">;</span>
                <span class="s2">reactivity.resetTracking()</span><span class="s1">;</span>
                <span class="s1">return </span><span class="s2">res</span><span class="s1">;</span>
            <span class="s2">})</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(prepend) {</span>
            <span class="s2">hooks.unshift(wrappedHook)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">hooks.push(wrappedHook)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">return </span><span class="s2">wrappedHook</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">const </span><span class="s2">createHook = (lifecycle) =&gt; (hook</span><span class="s1">, </span><span class="s2">target = currentInstance) =&gt; </span>
<span class="s6">// post-create lifecycle registrations are noops during SSR (except for serverPrefetch)</span>
<span class="s2">(!isInSSRComponentSetup || lifecycle === </span><span class="s0">&quot;sp&quot; </span><span class="s6">/* LifecycleHooks.SERVER_PREFETCH */</span><span class="s2">) &amp;&amp;</span>
    <span class="s2">injectHook(lifecycle</span><span class="s1">, </span><span class="s2">(...args) =&gt; hook(...args)</span><span class="s1">, </span><span class="s2">target)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">onBeforeMount = createHook(</span><span class="s0">&quot;bm&quot; </span><span class="s6">/* LifecycleHooks.BEFORE_MOUNT */</span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">onMounted = createHook(</span><span class="s0">&quot;m&quot; </span><span class="s6">/* LifecycleHooks.MOUNTED */</span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">onBeforeUpdate = createHook(</span><span class="s0">&quot;bu&quot; </span><span class="s6">/* LifecycleHooks.BEFORE_UPDATE */</span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">onUpdated = createHook(</span><span class="s0">&quot;u&quot; </span><span class="s6">/* LifecycleHooks.UPDATED */</span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">onBeforeUnmount = createHook(</span><span class="s0">&quot;bum&quot; </span><span class="s6">/* LifecycleHooks.BEFORE_UNMOUNT */</span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">onUnmounted = createHook(</span><span class="s0">&quot;um&quot; </span><span class="s6">/* LifecycleHooks.UNMOUNTED */</span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">onServerPrefetch = createHook(</span><span class="s0">&quot;sp&quot; </span><span class="s6">/* LifecycleHooks.SERVER_PREFETCH */</span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">onRenderTriggered = createHook(</span><span class="s0">&quot;rtg&quot; </span><span class="s6">/* LifecycleHooks.RENDER_TRIGGERED */</span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">onRenderTracked = createHook(</span><span class="s0">&quot;rtc&quot; </span><span class="s6">/* LifecycleHooks.RENDER_TRACKED */</span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">onErrorCaptured(hook</span><span class="s1">, </span><span class="s2">target = currentInstance) {</span>
    <span class="s2">injectHook(</span><span class="s0">&quot;ec&quot; </span><span class="s6">/* LifecycleHooks.ERROR_CAPTURED */</span><span class="s1">, </span><span class="s2">hook</span><span class="s1">, </span><span class="s2">target)</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s3">/**</span>
<span class="s3">Runtime helper for applying directives to a vnode. Example usage:</span>

<span class="s3">const comp = resolveComponent('comp')</span>
<span class="s3">const foo = resolveDirective('foo')</span>
<span class="s3">const bar = resolveDirective('bar')</span>

<span class="s3">return withDirectives(h(comp), [</span>
  <span class="s3">[foo, this.x],</span>
  <span class="s3">[bar, this.y]</span>
<span class="s3">])</span>
<span class="s3">*/</span>
<span class="s3">/**</span>
 <span class="s3">* Adds directives to a VNode.</span>
 <span class="s3">*/</span>
<span class="s1">function </span><span class="s2">withDirectives(vnode</span><span class="s1">, </span><span class="s2">directives) {</span>
    <span class="s1">const </span><span class="s2">internalInstance = currentRenderingInstance</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(internalInstance === </span><span class="s1">null</span><span class="s2">) {</span>
        <span class="s1">return </span><span class="s2">vnode</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">instance = getExposeProxy(internalInstance) ||</span>
        <span class="s2">internalInstance.proxy</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">bindings = vnode.dirs || (vnode.dirs = [])</span><span class="s1">;</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s5">0</span><span class="s1">; </span><span class="s2">i &lt; directives.length</span><span class="s1">; </span><span class="s2">i++) {</span>
        <span class="s1">let </span><span class="s2">[dir</span><span class="s1">, </span><span class="s2">value</span><span class="s1">, </span><span class="s2">arg</span><span class="s1">, </span><span class="s2">modifiers = shared.EMPTY_OBJ] = directives[i]</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(dir) {</span>
            <span class="s1">if </span><span class="s2">(shared.isFunction(dir)) {</span>
                <span class="s2">dir = {</span>
                    <span class="s2">mounted: dir</span><span class="s1">,</span>
                    <span class="s2">updated: dir</span>
                <span class="s2">}</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">if </span><span class="s2">(dir.deep) {</span>
                <span class="s2">traverse(value)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s2">bindings.push({</span>
                <span class="s2">dir</span><span class="s1">,</span>
                <span class="s2">instance</span><span class="s1">,</span>
                <span class="s2">value</span><span class="s1">,</span>
                <span class="s2">oldValue: </span><span class="s1">void </span><span class="s5">0</span><span class="s1">,</span>
                <span class="s2">arg</span><span class="s1">,</span>
                <span class="s2">modifiers</span>
            <span class="s2">})</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">vnode</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">invokeDirectiveHook(vnode</span><span class="s1">, </span><span class="s2">prevVNode</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s2">name) {</span>
    <span class="s1">const </span><span class="s2">bindings = vnode.dirs</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">oldBindings = prevVNode &amp;&amp; prevVNode.dirs</span><span class="s1">;</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s5">0</span><span class="s1">; </span><span class="s2">i &lt; bindings.length</span><span class="s1">; </span><span class="s2">i++) {</span>
        <span class="s1">const </span><span class="s2">binding = bindings[i]</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(oldBindings) {</span>
            <span class="s2">binding.oldValue = oldBindings[i].value</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">let </span><span class="s2">hook = binding.dir[name]</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(hook) {</span>
            <span class="s6">// disable tracking inside all lifecycle hooks</span>
            <span class="s6">// since they can potentially be called inside effects.</span>
            <span class="s2">reactivity.pauseTracking()</span><span class="s1">;</span>
            <span class="s2">callWithAsyncErrorHandling(hook</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s5">8 </span><span class="s6">/* ErrorCodes.DIRECTIVE_HOOK */</span><span class="s1">, </span><span class="s2">[</span>
                <span class="s2">vnode.el</span><span class="s1">,</span>
                <span class="s2">binding</span><span class="s1">,</span>
                <span class="s2">vnode</span><span class="s1">,</span>
                <span class="s2">prevVNode</span>
            <span class="s2">])</span><span class="s1">;</span>
            <span class="s2">reactivity.resetTracking()</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
<span class="s2">}</span>

<span class="s1">const </span><span class="s2">COMPONENTS = </span><span class="s0">'components'</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">DIRECTIVES = </span><span class="s0">'directives'</span><span class="s1">;</span>
<span class="s3">/**</span>
 <span class="s3">* </span><span class="s4">@private</span>
 <span class="s3">*/</span>
<span class="s1">function </span><span class="s2">resolveComponent(name</span><span class="s1">, </span><span class="s2">maybeSelfReference) {</span>
    <span class="s1">return </span><span class="s2">resolveAsset(COMPONENTS</span><span class="s1">, </span><span class="s2">name</span><span class="s1">, true, </span><span class="s2">maybeSelfReference) || name</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">const </span><span class="s2">NULL_DYNAMIC_COMPONENT = Symbol()</span><span class="s1">;</span>
<span class="s3">/**</span>
 <span class="s3">* </span><span class="s4">@private</span>
 <span class="s3">*/</span>
<span class="s1">function </span><span class="s2">resolveDynamicComponent(component) {</span>
    <span class="s1">if </span><span class="s2">(shared.isString(component)) {</span>
        <span class="s1">return </span><span class="s2">resolveAsset(COMPONENTS</span><span class="s1">, </span><span class="s2">component</span><span class="s1">, false</span><span class="s2">) || component</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s6">// invalid types will fallthrough to createVNode and raise warning</span>
        <span class="s1">return </span><span class="s2">(component || NULL_DYNAMIC_COMPONENT)</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s3">/**</span>
 <span class="s3">* </span><span class="s4">@private</span>
 <span class="s3">*/</span>
<span class="s1">function </span><span class="s2">resolveDirective(name) {</span>
    <span class="s1">return </span><span class="s2">resolveAsset(DIRECTIVES</span><span class="s1">, </span><span class="s2">name)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s6">// implementation</span>
<span class="s1">function </span><span class="s2">resolveAsset(type</span><span class="s1">, </span><span class="s2">name</span><span class="s1">, </span><span class="s2">warnMissing = </span><span class="s1">true, </span><span class="s2">maybeSelfReference = </span><span class="s1">false</span><span class="s2">) {</span>
    <span class="s1">const </span><span class="s2">instance = currentRenderingInstance || currentInstance</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(instance) {</span>
        <span class="s1">const </span><span class="s2">Component = instance.type</span><span class="s1">;</span>
        <span class="s6">// explicit self name has highest priority</span>
        <span class="s1">if </span><span class="s2">(type === COMPONENTS) {</span>
            <span class="s1">const </span><span class="s2">selfName = getComponentName(Component</span><span class="s1">, false </span><span class="s6">/* do not include inferred name to avoid breaking existing code */</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(selfName &amp;&amp;</span>
                <span class="s2">(selfName === name ||</span>
                    <span class="s2">selfName === shared.camelize(name) ||</span>
                    <span class="s2">selfName === shared.capitalize(shared.camelize(name)))) {</span>
                <span class="s1">return </span><span class="s2">Component</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">const </span><span class="s2">res = </span>
        <span class="s6">// local registration</span>
        <span class="s6">// check instance[type] first which is resolved for options API</span>
        <span class="s2">resolve(instance[type] || Component[type]</span><span class="s1">, </span><span class="s2">name) ||</span>
            <span class="s6">// global registration</span>
            <span class="s2">resolve(instance.appContext[type]</span><span class="s1">, </span><span class="s2">name)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(!res &amp;&amp; maybeSelfReference) {</span>
            <span class="s6">// fallback to implicit self-reference</span>
            <span class="s1">return </span><span class="s2">Component</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">return </span><span class="s2">res</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">resolve(registry</span><span class="s1">, </span><span class="s2">name) {</span>
    <span class="s1">return </span><span class="s2">(registry &amp;&amp;</span>
        <span class="s2">(registry[name] ||</span>
            <span class="s2">registry[shared.camelize(name)] ||</span>
            <span class="s2">registry[shared.capitalize(shared.camelize(name))]))</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s3">/**</span>
 <span class="s3">* Actual implementation</span>
 <span class="s3">*/</span>
<span class="s1">function </span><span class="s2">renderList(source</span><span class="s1">, </span><span class="s2">renderItem</span><span class="s1">, </span><span class="s2">cache</span><span class="s1">, </span><span class="s2">index) {</span>
    <span class="s1">let </span><span class="s2">ret</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">cached = (cache &amp;&amp; cache[index])</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(shared.isArray(source) || shared.isString(source)) {</span>
        <span class="s2">ret = </span><span class="s1">new </span><span class="s2">Array(source.length)</span><span class="s1">;</span>
        <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s5">0</span><span class="s1">, </span><span class="s2">l = source.length</span><span class="s1">; </span><span class="s2">i &lt; l</span><span class="s1">; </span><span class="s2">i++) {</span>
            <span class="s2">ret[i] = renderItem(source[i]</span><span class="s1">, </span><span class="s2">i</span><span class="s1">, </span><span class="s2">undefined</span><span class="s1">, </span><span class="s2">cached &amp;&amp; cached[i])</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(</span><span class="s1">typeof </span><span class="s2">source === </span><span class="s0">'number'</span><span class="s2">) {</span>
        <span class="s2">ret = </span><span class="s1">new </span><span class="s2">Array(source)</span><span class="s1">;</span>
        <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s5">0</span><span class="s1">; </span><span class="s2">i &lt; source</span><span class="s1">; </span><span class="s2">i++) {</span>
            <span class="s2">ret[i] = renderItem(i + </span><span class="s5">1</span><span class="s1">, </span><span class="s2">i</span><span class="s1">, </span><span class="s2">undefined</span><span class="s1">, </span><span class="s2">cached &amp;&amp; cached[i])</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(shared.isObject(source)) {</span>
        <span class="s1">if </span><span class="s2">(source[Symbol.iterator]) {</span>
            <span class="s2">ret = Array.from(source</span><span class="s1">, </span><span class="s2">(item</span><span class="s1">, </span><span class="s2">i) =&gt; renderItem(item</span><span class="s1">, </span><span class="s2">i</span><span class="s1">, </span><span class="s2">undefined</span><span class="s1">, </span><span class="s2">cached &amp;&amp; cached[i]))</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s1">const </span><span class="s2">keys = Object.keys(source)</span><span class="s1">;</span>
            <span class="s2">ret = </span><span class="s1">new </span><span class="s2">Array(keys.length)</span><span class="s1">;</span>
            <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s5">0</span><span class="s1">, </span><span class="s2">l = keys.length</span><span class="s1">; </span><span class="s2">i &lt; l</span><span class="s1">; </span><span class="s2">i++) {</span>
                <span class="s1">const </span><span class="s2">key = keys[i]</span><span class="s1">;</span>
                <span class="s2">ret[i] = renderItem(source[key]</span><span class="s1">, </span><span class="s2">key</span><span class="s1">, </span><span class="s2">i</span><span class="s1">, </span><span class="s2">cached &amp;&amp; cached[i])</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s2">ret = []</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(cache) {</span>
        <span class="s2">cache[index] = ret</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">ret</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s3">/**</span>
 <span class="s3">* Compiler runtime helper for creating dynamic slots object</span>
 <span class="s3">* </span><span class="s4">@private</span>
 <span class="s3">*/</span>
<span class="s1">function </span><span class="s2">createSlots(slots</span><span class="s1">, </span><span class="s2">dynamicSlots) {</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s5">0</span><span class="s1">; </span><span class="s2">i &lt; dynamicSlots.length</span><span class="s1">; </span><span class="s2">i++) {</span>
        <span class="s1">const </span><span class="s2">slot = dynamicSlots[i]</span><span class="s1">;</span>
        <span class="s6">// array of dynamic slot generated by &lt;template v-for=&quot;...&quot; #[...]&gt;</span>
        <span class="s1">if </span><span class="s2">(shared.isArray(slot)) {</span>
            <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">j = </span><span class="s5">0</span><span class="s1">; </span><span class="s2">j &lt; slot.length</span><span class="s1">; </span><span class="s2">j++) {</span>
                <span class="s2">slots[slot[j].name] = slot[j].fn</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(slot) {</span>
            <span class="s6">// conditional single slot generated by &lt;template v-if=&quot;...&quot; #foo&gt;</span>
            <span class="s2">slots[slot.name] = slot.key</span>
                <span class="s2">? (...args) =&gt; {</span>
                    <span class="s1">const </span><span class="s2">res = slot.fn(...args)</span><span class="s1">;</span>
                    <span class="s6">// attach branch key so each conditional branch is considered a</span>
                    <span class="s6">// different fragment</span>
                    <span class="s1">if </span><span class="s2">(res)</span>
                        <span class="s2">res.key = slot.key</span><span class="s1">;</span>
                    <span class="s1">return </span><span class="s2">res</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s2">: slot.fn</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">slots</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s3">/**</span>
 <span class="s3">* Compiler runtime helper for rendering `&lt;slot/&gt;`</span>
 <span class="s3">* </span><span class="s4">@private</span>
 <span class="s3">*/</span>
<span class="s1">function </span><span class="s2">renderSlot(slots</span><span class="s1">, </span><span class="s2">name</span><span class="s1">, </span><span class="s2">props = {}</span><span class="s1">, </span>
<span class="s6">// this is not a user-facing function, so the fallback is always generated by</span>
<span class="s6">// the compiler and guaranteed to be a function returning an array</span>
<span class="s2">fallback</span><span class="s1">, </span><span class="s2">noSlotted) {</span>
    <span class="s1">if </span><span class="s2">(currentRenderingInstance.isCE ||</span>
        <span class="s2">(currentRenderingInstance.parent &amp;&amp;</span>
            <span class="s2">isAsyncWrapper(currentRenderingInstance.parent) &amp;&amp;</span>
            <span class="s2">currentRenderingInstance.parent.isCE)) {</span>
        <span class="s1">if </span><span class="s2">(name !== </span><span class="s0">'default'</span><span class="s2">)</span>
            <span class="s2">props.name = name</span><span class="s1">;</span>
        <span class="s1">return </span><span class="s2">createVNode(</span><span class="s0">'slot'</span><span class="s1">, </span><span class="s2">props</span><span class="s1">, </span><span class="s2">fallback &amp;&amp; fallback())</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">let </span><span class="s2">slot = slots[name]</span><span class="s1">;</span>
    <span class="s6">// a compiled slot disables block tracking by default to avoid manual</span>
    <span class="s6">// invocation interfering with template-based block tracking, but in</span>
    <span class="s6">// `renderSlot` we can be sure that it's template-based so we can force</span>
    <span class="s6">// enable it.</span>
    <span class="s1">if </span><span class="s2">(slot &amp;&amp; slot._c) {</span>
        <span class="s2">slot._d = </span><span class="s1">false;</span>
    <span class="s2">}</span>
    <span class="s2">openBlock()</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">validSlotContent = slot &amp;&amp; ensureValidVNode(slot(props))</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">rendered = createBlock(Fragment</span><span class="s1">, </span><span class="s2">{</span>
        <span class="s2">key: props.key ||</span>
            <span class="s6">// slot content array of a dynamic conditional slot may have a branch</span>
            <span class="s6">// key attached in the `createSlots` helper, respect that</span>
            <span class="s2">(validSlotContent &amp;&amp; validSlotContent.key) ||</span>
            <span class="s0">`_</span><span class="s2">${name}</span><span class="s0">`</span>
    <span class="s2">}</span><span class="s1">, </span><span class="s2">validSlotContent || (fallback ? fallback() : [])</span><span class="s1">, </span><span class="s2">validSlotContent &amp;&amp; slots._ === </span><span class="s5">1 </span><span class="s6">/* SlotFlags.STABLE */</span>
        <span class="s2">? </span><span class="s5">64 </span><span class="s6">/* PatchFlags.STABLE_FRAGMENT */</span>
        <span class="s2">: -</span><span class="s5">2 </span><span class="s6">/* PatchFlags.BAIL */</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(!noSlotted &amp;&amp; rendered.scopeId) {</span>
        <span class="s2">rendered.slotScopeIds = [rendered.scopeId + </span><span class="s0">'-s'</span><span class="s2">]</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(slot &amp;&amp; slot._c) {</span>
        <span class="s2">slot._d = </span><span class="s1">true;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">rendered</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">ensureValidVNode(vnodes) {</span>
    <span class="s1">return </span><span class="s2">vnodes.some(child =&gt; {</span>
        <span class="s1">if </span><span class="s2">(!isVNode(child))</span>
            <span class="s1">return true;</span>
        <span class="s1">if </span><span class="s2">(child.type === Comment)</span>
            <span class="s1">return false;</span>
        <span class="s1">if </span><span class="s2">(child.type === Fragment &amp;&amp;</span>
            <span class="s2">!ensureValidVNode(child.children))</span>
            <span class="s1">return false;</span>
        <span class="s1">return true;</span>
    <span class="s2">})</span>
        <span class="s2">? vnodes</span>
        <span class="s2">: </span><span class="s1">null;</span>
<span class="s2">}</span>

<span class="s3">/**</span>
 <span class="s3">* For prefixing keys in v-on=&quot;obj&quot; with &quot;on&quot;</span>
 <span class="s3">* </span><span class="s4">@private</span>
 <span class="s3">*/</span>
<span class="s1">function </span><span class="s2">toHandlers(obj</span><span class="s1">, </span><span class="s2">preserveCaseIfNecessary) {</span>
    <span class="s1">const </span><span class="s2">ret = {}</span><span class="s1">;</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">key </span><span class="s1">in </span><span class="s2">obj) {</span>
        <span class="s2">ret[preserveCaseIfNecessary &amp;&amp; </span><span class="s5">/[A-Z]/</span><span class="s2">.test(key)</span>
            <span class="s2">? </span><span class="s0">`on:</span><span class="s2">${key}</span><span class="s0">`</span>
            <span class="s2">: shared.toHandlerKey(key)] = obj[key]</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">ret</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s3">/**</span>
 <span class="s3">* #2437 In Vue 3, functional components do not have a public instance proxy but</span>
 <span class="s3">* they exist in the internal parent chain. For code that relies on traversing</span>
 <span class="s3">* public $parent chains, skip functional ones and go to the parent instead.</span>
 <span class="s3">*/</span>
<span class="s1">const </span><span class="s2">getPublicInstance = (i) =&gt; {</span>
    <span class="s1">if </span><span class="s2">(!i)</span>
        <span class="s1">return null;</span>
    <span class="s1">if </span><span class="s2">(isStatefulComponent(i))</span>
        <span class="s1">return </span><span class="s2">getExposeProxy(i) || i.proxy</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">getPublicInstance(i.parent)</span><span class="s1">;</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">publicPropertiesMap = </span>
<span class="s6">// Move PURE marker to new line to workaround compiler discarding it</span>
<span class="s6">// due to type annotation</span>
<span class="s6">/*#__PURE__*/ </span><span class="s2">shared.extend(Object.create(</span><span class="s1">null</span><span class="s2">)</span><span class="s1">, </span><span class="s2">{</span>
    <span class="s2">$: i =&gt; i</span><span class="s1">,</span>
    <span class="s2">$el: i =&gt; i.vnode.el</span><span class="s1">,</span>
    <span class="s2">$data: i =&gt; i.data</span><span class="s1">,</span>
    <span class="s2">$props: i =&gt; (i.props)</span><span class="s1">,</span>
    <span class="s2">$attrs: i =&gt; (i.attrs)</span><span class="s1">,</span>
    <span class="s2">$slots: i =&gt; (i.slots)</span><span class="s1">,</span>
    <span class="s2">$refs: i =&gt; (i.refs)</span><span class="s1">,</span>
    <span class="s2">$parent: i =&gt; getPublicInstance(i.parent)</span><span class="s1">,</span>
    <span class="s2">$root: i =&gt; getPublicInstance(i.root)</span><span class="s1">,</span>
    <span class="s2">$emit: i =&gt; i.emit</span><span class="s1">,</span>
    <span class="s2">$options: i =&gt; (resolveMergedOptions(i) )</span><span class="s1">,</span>
    <span class="s2">$forceUpdate: i =&gt; i.f || (i.f = () =&gt; queueJob(i.update))</span><span class="s1">,</span>
    <span class="s2">$nextTick: i =&gt; i.n || (i.n = nextTick.bind(i.proxy))</span><span class="s1">,</span>
    <span class="s2">$watch: i =&gt; (instanceWatch.bind(i) )</span>
<span class="s2">})</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">hasSetupBinding = (state</span><span class="s1">, </span><span class="s2">key) =&gt; state !== shared.EMPTY_OBJ &amp;&amp; !state.__isScriptSetup &amp;&amp; shared.hasOwn(state</span><span class="s1">, </span><span class="s2">key)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">PublicInstanceProxyHandlers = {</span>
    <span class="s2">get({ _: instance }</span><span class="s1">, </span><span class="s2">key) {</span>
        <span class="s1">const </span><span class="s2">{ ctx</span><span class="s1">, </span><span class="s2">setupState</span><span class="s1">, </span><span class="s2">data</span><span class="s1">, </span><span class="s2">props</span><span class="s1">, </span><span class="s2">accessCache</span><span class="s1">, </span><span class="s2">type</span><span class="s1">, </span><span class="s2">appContext } = instance</span><span class="s1">;</span>
        <span class="s6">// data / props / ctx</span>
        <span class="s6">// This getter gets called for every property access on the render context</span>
        <span class="s6">// during render and is a major hotspot. The most expensive part of this</span>
        <span class="s6">// is the multiple hasOwn() calls. It's much faster to do a simple property</span>
        <span class="s6">// access on a plain object, so we use an accessCache object (with null</span>
        <span class="s6">// prototype) to memoize what access type a key corresponds to.</span>
        <span class="s1">let </span><span class="s2">normalizedProps</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(key[</span><span class="s5">0</span><span class="s2">] !== </span><span class="s0">'$'</span><span class="s2">) {</span>
            <span class="s1">const </span><span class="s2">n = accessCache[key]</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(n !== undefined) {</span>
                <span class="s1">switch </span><span class="s2">(n) {</span>
                    <span class="s1">case </span><span class="s5">1 </span><span class="s6">/* AccessTypes.SETUP */</span><span class="s2">:</span>
                        <span class="s1">return </span><span class="s2">setupState[key]</span><span class="s1">;</span>
                    <span class="s1">case </span><span class="s5">2 </span><span class="s6">/* AccessTypes.DATA */</span><span class="s2">:</span>
                        <span class="s1">return </span><span class="s2">data[key]</span><span class="s1">;</span>
                    <span class="s1">case </span><span class="s5">4 </span><span class="s6">/* AccessTypes.CONTEXT */</span><span class="s2">:</span>
                        <span class="s1">return </span><span class="s2">ctx[key]</span><span class="s1">;</span>
                    <span class="s1">case </span><span class="s5">3 </span><span class="s6">/* AccessTypes.PROPS */</span><span class="s2">:</span>
                        <span class="s1">return </span><span class="s2">props[key]</span><span class="s1">;</span>
                    <span class="s6">// default: just fallthrough</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(hasSetupBinding(setupState</span><span class="s1">, </span><span class="s2">key)) {</span>
                <span class="s2">accessCache[key] = </span><span class="s5">1 </span><span class="s6">/* AccessTypes.SETUP */</span><span class="s1">;</span>
                <span class="s1">return </span><span class="s2">setupState[key]</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(data !== shared.EMPTY_OBJ &amp;&amp; shared.hasOwn(data</span><span class="s1">, </span><span class="s2">key)) {</span>
                <span class="s2">accessCache[key] = </span><span class="s5">2 </span><span class="s6">/* AccessTypes.DATA */</span><span class="s1">;</span>
                <span class="s1">return </span><span class="s2">data[key]</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(</span>
            <span class="s6">// only cache other properties when instance has declared (thus stable)</span>
            <span class="s6">// props</span>
            <span class="s2">(normalizedProps = instance.propsOptions[</span><span class="s5">0</span><span class="s2">]) &amp;&amp;</span>
                <span class="s2">shared.hasOwn(normalizedProps</span><span class="s1">, </span><span class="s2">key)) {</span>
                <span class="s2">accessCache[key] = </span><span class="s5">3 </span><span class="s6">/* AccessTypes.PROPS */</span><span class="s1">;</span>
                <span class="s1">return </span><span class="s2">props[key]</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(ctx !== shared.EMPTY_OBJ &amp;&amp; shared.hasOwn(ctx</span><span class="s1">, </span><span class="s2">key)) {</span>
                <span class="s2">accessCache[key] = </span><span class="s5">4 </span><span class="s6">/* AccessTypes.CONTEXT */</span><span class="s1">;</span>
                <span class="s1">return </span><span class="s2">ctx[key]</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(shouldCacheAccess) {</span>
                <span class="s2">accessCache[key] = </span><span class="s5">0 </span><span class="s6">/* AccessTypes.OTHER */</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">const </span><span class="s2">publicGetter = publicPropertiesMap[key]</span><span class="s1">;</span>
        <span class="s1">let </span><span class="s2">cssModule</span><span class="s1">, </span><span class="s2">globalProperties</span><span class="s1">;</span>
        <span class="s6">// public $xxx properties</span>
        <span class="s1">if </span><span class="s2">(publicGetter) {</span>
            <span class="s1">if </span><span class="s2">(key === </span><span class="s0">'$attrs'</span><span class="s2">) {</span>
                <span class="s2">reactivity.track(instance</span><span class="s1">, </span><span class="s0">&quot;get&quot; </span><span class="s6">/* TrackOpTypes.GET */</span><span class="s1">, </span><span class="s2">key)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">return </span><span class="s2">publicGetter(instance)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(</span>
        <span class="s6">// css module (injected by vue-loader)</span>
        <span class="s2">(cssModule = type.__cssModules) &amp;&amp;</span>
            <span class="s2">(cssModule = cssModule[key])) {</span>
            <span class="s1">return </span><span class="s2">cssModule</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(ctx !== shared.EMPTY_OBJ &amp;&amp; shared.hasOwn(ctx</span><span class="s1">, </span><span class="s2">key)) {</span>
            <span class="s6">// user may set custom properties to `this` that start with `$`</span>
            <span class="s2">accessCache[key] = </span><span class="s5">4 </span><span class="s6">/* AccessTypes.CONTEXT */</span><span class="s1">;</span>
            <span class="s1">return </span><span class="s2">ctx[key]</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(</span>
        <span class="s6">// global properties</span>
        <span class="s2">((globalProperties = appContext.config.globalProperties)</span><span class="s1">,</span>
            <span class="s2">shared.hasOwn(globalProperties</span><span class="s1">, </span><span class="s2">key))) {</span>
            <span class="s2">{</span>
                <span class="s1">return </span><span class="s2">globalProperties[key]</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">else ;</span>
    <span class="s2">}</span><span class="s1">,</span>
    <span class="s2">set({ _: instance }</span><span class="s1">, </span><span class="s2">key</span><span class="s1">, </span><span class="s2">value) {</span>
        <span class="s1">const </span><span class="s2">{ data</span><span class="s1">, </span><span class="s2">setupState</span><span class="s1">, </span><span class="s2">ctx } = instance</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(hasSetupBinding(setupState</span><span class="s1">, </span><span class="s2">key)) {</span>
            <span class="s2">setupState[key] = value</span><span class="s1">;</span>
            <span class="s1">return true;</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(data !== shared.EMPTY_OBJ &amp;&amp; shared.hasOwn(data</span><span class="s1">, </span><span class="s2">key)) {</span>
            <span class="s2">data[key] = value</span><span class="s1">;</span>
            <span class="s1">return true;</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(shared.hasOwn(instance.props</span><span class="s1">, </span><span class="s2">key)) {</span>
            <span class="s1">return false;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(key[</span><span class="s5">0</span><span class="s2">] === </span><span class="s0">'$' </span><span class="s2">&amp;&amp; key.slice(</span><span class="s5">1</span><span class="s2">) </span><span class="s1">in </span><span class="s2">instance) {</span>
            <span class="s1">return false;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">{</span>
                <span class="s2">ctx[key] = value</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">return true;</span>
    <span class="s2">}</span><span class="s1">,</span>
    <span class="s2">has({ _: { data</span><span class="s1">, </span><span class="s2">setupState</span><span class="s1">, </span><span class="s2">accessCache</span><span class="s1">, </span><span class="s2">ctx</span><span class="s1">, </span><span class="s2">appContext</span><span class="s1">, </span><span class="s2">propsOptions } }</span><span class="s1">, </span><span class="s2">key) {</span>
        <span class="s1">let </span><span class="s2">normalizedProps</span><span class="s1">;</span>
        <span class="s1">return </span><span class="s2">(!!accessCache[key] ||</span>
            <span class="s2">(data !== shared.EMPTY_OBJ &amp;&amp; shared.hasOwn(data</span><span class="s1">, </span><span class="s2">key)) ||</span>
            <span class="s2">hasSetupBinding(setupState</span><span class="s1">, </span><span class="s2">key) ||</span>
            <span class="s2">((normalizedProps = propsOptions[</span><span class="s5">0</span><span class="s2">]) &amp;&amp; shared.hasOwn(normalizedProps</span><span class="s1">, </span><span class="s2">key)) ||</span>
            <span class="s2">shared.hasOwn(ctx</span><span class="s1">, </span><span class="s2">key) ||</span>
            <span class="s2">shared.hasOwn(publicPropertiesMap</span><span class="s1">, </span><span class="s2">key) ||</span>
            <span class="s2">shared.hasOwn(appContext.config.globalProperties</span><span class="s1">, </span><span class="s2">key))</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">,</span>
    <span class="s2">defineProperty(target</span><span class="s1">, </span><span class="s2">key</span><span class="s1">, </span><span class="s2">descriptor) {</span>
        <span class="s1">if </span><span class="s2">(descriptor.get != </span><span class="s1">null</span><span class="s2">) {</span>
            <span class="s6">// invalidate key cache of a getter based property #5417</span>
            <span class="s2">target._.accessCache[key] = </span><span class="s5">0</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(shared.hasOwn(descriptor</span><span class="s1">, </span><span class="s0">'value'</span><span class="s2">)) {</span>
            <span class="s1">this</span><span class="s2">.set(target</span><span class="s1">, </span><span class="s2">key</span><span class="s1">, </span><span class="s2">descriptor.value</span><span class="s1">, null</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">return </span><span class="s2">Reflect.defineProperty(target</span><span class="s1">, </span><span class="s2">key</span><span class="s1">, </span><span class="s2">descriptor)</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">RuntimeCompiledPublicInstanceProxyHandlers = </span><span class="s6">/*#__PURE__*/ </span><span class="s2">shared.extend({}</span><span class="s1">, </span><span class="s2">PublicInstanceProxyHandlers</span><span class="s1">, </span><span class="s2">{</span>
    <span class="s2">get(target</span><span class="s1">, </span><span class="s2">key) {</span>
        <span class="s6">// fast path for unscopables when using `with` block</span>
        <span class="s1">if </span><span class="s2">(key === Symbol.unscopables) {</span>
            <span class="s1">return;</span>
        <span class="s2">}</span>
        <span class="s1">return </span><span class="s2">PublicInstanceProxyHandlers.get(target</span><span class="s1">, </span><span class="s2">key</span><span class="s1">, </span><span class="s2">target)</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">,</span>
    <span class="s2">has(_</span><span class="s1">, </span><span class="s2">key) {</span>
        <span class="s1">const </span><span class="s2">has = key[</span><span class="s5">0</span><span class="s2">] !== </span><span class="s0">'_' </span><span class="s2">&amp;&amp; !shared.isGloballyWhitelisted(key)</span><span class="s1">;</span>
        <span class="s1">return </span><span class="s2">has</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">})</span><span class="s1">;</span>

<span class="s1">let </span><span class="s2">shouldCacheAccess = </span><span class="s1">true;</span>
<span class="s1">function </span><span class="s2">applyOptions(instance) {</span>
    <span class="s1">const </span><span class="s2">options = resolveMergedOptions(instance)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">publicThis = instance.proxy</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">ctx = instance.ctx</span><span class="s1">;</span>
    <span class="s6">// do not cache property access on public proxy during state initialization</span>
    <span class="s2">shouldCacheAccess = </span><span class="s1">false;</span>
    <span class="s6">// call beforeCreate first before accessing other options since</span>
    <span class="s6">// the hook may mutate resolved options (#2791)</span>
    <span class="s1">if </span><span class="s2">(options.beforeCreate) {</span>
        <span class="s2">callHook(options.beforeCreate</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s0">&quot;bc&quot; </span><span class="s6">/* LifecycleHooks.BEFORE_CREATE */</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">{ </span>
    <span class="s6">// state</span>
    <span class="s2">data: dataOptions</span><span class="s1">, </span><span class="s2">computed: computedOptions</span><span class="s1">, </span><span class="s2">methods</span><span class="s1">, </span><span class="s2">watch: watchOptions</span><span class="s1">, </span><span class="s2">provide: provideOptions</span><span class="s1">, </span><span class="s2">inject: injectOptions</span><span class="s1">, </span>
    <span class="s6">// lifecycle</span>
    <span class="s2">created</span><span class="s1">, </span><span class="s2">beforeMount</span><span class="s1">, </span><span class="s2">mounted</span><span class="s1">, </span><span class="s2">beforeUpdate</span><span class="s1">, </span><span class="s2">updated</span><span class="s1">, </span><span class="s2">activated</span><span class="s1">, </span><span class="s2">deactivated</span><span class="s1">, </span><span class="s2">beforeDestroy</span><span class="s1">, </span><span class="s2">beforeUnmount</span><span class="s1">, </span><span class="s2">destroyed</span><span class="s1">, </span><span class="s2">unmounted</span><span class="s1">, </span><span class="s2">render</span><span class="s1">, </span><span class="s2">renderTracked</span><span class="s1">, </span><span class="s2">renderTriggered</span><span class="s1">, </span><span class="s2">errorCaptured</span><span class="s1">, </span><span class="s2">serverPrefetch</span><span class="s1">, </span>
    <span class="s6">// public API</span>
    <span class="s2">expose</span><span class="s1">, </span><span class="s2">inheritAttrs</span><span class="s1">, </span>
    <span class="s6">// assets</span>
    <span class="s2">components</span><span class="s1">, </span><span class="s2">directives</span><span class="s1">, </span><span class="s2">filters } = options</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">checkDuplicateProperties = </span><span class="s1">null;</span>
    <span class="s6">// options initialization order (to be consistent with Vue 2):</span>
    <span class="s6">// - props (already done outside of this function)</span>
    <span class="s6">// - inject</span>
    <span class="s6">// - methods</span>
    <span class="s6">// - data (deferred since it relies on `this` access)</span>
    <span class="s6">// - computed</span>
    <span class="s6">// - watch (deferred since it relies on `this` access)</span>
    <span class="s1">if </span><span class="s2">(injectOptions) {</span>
        <span class="s2">resolveInjections(injectOptions</span><span class="s1">, </span><span class="s2">ctx</span><span class="s1">, </span><span class="s2">checkDuplicateProperties</span><span class="s1">, </span><span class="s2">instance.appContext.config.unwrapInjectedRef)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(methods) {</span>
        <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">key </span><span class="s1">in </span><span class="s2">methods) {</span>
            <span class="s1">const </span><span class="s2">methodHandler = methods[key]</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(shared.isFunction(methodHandler)) {</span>
                <span class="s6">// In dev mode, we use the `createRenderContext` function to define</span>
                <span class="s6">// methods to the proxy target, and those are read-only but</span>
                <span class="s6">// reconfigurable, so it needs to be redefined here</span>
                <span class="s2">{</span>
                    <span class="s2">ctx[key] = methodHandler.bind(publicThis)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(dataOptions) {</span>
        <span class="s1">const </span><span class="s2">data = dataOptions.call(publicThis</span><span class="s1">, </span><span class="s2">publicThis)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(!shared.isObject(data)) </span><span class="s1">;</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">instance.data = reactivity.reactive(data)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s6">// state initialization complete at this point - start caching access</span>
    <span class="s2">shouldCacheAccess = </span><span class="s1">true;</span>
    <span class="s1">if </span><span class="s2">(computedOptions) {</span>
        <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">key </span><span class="s1">in </span><span class="s2">computedOptions) {</span>
            <span class="s1">const </span><span class="s2">opt = computedOptions[key]</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">get = shared.isFunction(opt)</span>
                <span class="s2">? opt.bind(publicThis</span><span class="s1">, </span><span class="s2">publicThis)</span>
                <span class="s2">: shared.isFunction(opt.get)</span>
                    <span class="s2">? opt.get.bind(publicThis</span><span class="s1">, </span><span class="s2">publicThis)</span>
                    <span class="s2">: shared.NOOP</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">set = !shared.isFunction(opt) &amp;&amp; shared.isFunction(opt.set)</span>
                <span class="s2">? opt.set.bind(publicThis)</span>
                <span class="s2">: shared.NOOP</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">c = computed({</span>
                <span class="s2">get</span><span class="s1">,</span>
                <span class="s2">set</span>
            <span class="s2">})</span><span class="s1">;</span>
            <span class="s2">Object.defineProperty(ctx</span><span class="s1">, </span><span class="s2">key</span><span class="s1">, </span><span class="s2">{</span>
                <span class="s2">enumerable: </span><span class="s1">true,</span>
                <span class="s2">configurable: </span><span class="s1">true,</span>
                <span class="s2">get: () =&gt; c.value</span><span class="s1">,</span>
                <span class="s2">set: v =&gt; (c.value = v)</span>
            <span class="s2">})</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(watchOptions) {</span>
        <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">key </span><span class="s1">in </span><span class="s2">watchOptions) {</span>
            <span class="s2">createWatcher(watchOptions[key]</span><span class="s1">, </span><span class="s2">ctx</span><span class="s1">, </span><span class="s2">publicThis</span><span class="s1">, </span><span class="s2">key)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(provideOptions) {</span>
        <span class="s1">const </span><span class="s2">provides = shared.isFunction(provideOptions)</span>
            <span class="s2">? provideOptions.call(publicThis)</span>
            <span class="s2">: provideOptions</span><span class="s1">;</span>
        <span class="s2">Reflect.ownKeys(provides).forEach(key =&gt; {</span>
            <span class="s2">provide(key</span><span class="s1">, </span><span class="s2">provides[key])</span><span class="s1">;</span>
        <span class="s2">})</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(created) {</span>
        <span class="s2">callHook(created</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s0">&quot;c&quot; </span><span class="s6">/* LifecycleHooks.CREATED */</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">function </span><span class="s2">registerLifecycleHook(register</span><span class="s1">, </span><span class="s2">hook) {</span>
        <span class="s1">if </span><span class="s2">(shared.isArray(hook)) {</span>
            <span class="s2">hook.forEach(_hook =&gt; register(_hook.bind(publicThis)))</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(hook) {</span>
            <span class="s2">register(hook.bind(publicThis))</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s2">registerLifecycleHook(onBeforeMount</span><span class="s1">, </span><span class="s2">beforeMount)</span><span class="s1">;</span>
    <span class="s2">registerLifecycleHook(onMounted</span><span class="s1">, </span><span class="s2">mounted)</span><span class="s1">;</span>
    <span class="s2">registerLifecycleHook(onBeforeUpdate</span><span class="s1">, </span><span class="s2">beforeUpdate)</span><span class="s1">;</span>
    <span class="s2">registerLifecycleHook(onUpdated</span><span class="s1">, </span><span class="s2">updated)</span><span class="s1">;</span>
    <span class="s2">registerLifecycleHook(onActivated</span><span class="s1">, </span><span class="s2">activated)</span><span class="s1">;</span>
    <span class="s2">registerLifecycleHook(onDeactivated</span><span class="s1">, </span><span class="s2">deactivated)</span><span class="s1">;</span>
    <span class="s2">registerLifecycleHook(onErrorCaptured</span><span class="s1">, </span><span class="s2">errorCaptured)</span><span class="s1">;</span>
    <span class="s2">registerLifecycleHook(onRenderTracked</span><span class="s1">, </span><span class="s2">renderTracked)</span><span class="s1">;</span>
    <span class="s2">registerLifecycleHook(onRenderTriggered</span><span class="s1">, </span><span class="s2">renderTriggered)</span><span class="s1">;</span>
    <span class="s2">registerLifecycleHook(onBeforeUnmount</span><span class="s1">, </span><span class="s2">beforeUnmount)</span><span class="s1">;</span>
    <span class="s2">registerLifecycleHook(onUnmounted</span><span class="s1">, </span><span class="s2">unmounted)</span><span class="s1">;</span>
    <span class="s2">registerLifecycleHook(onServerPrefetch</span><span class="s1">, </span><span class="s2">serverPrefetch)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(shared.isArray(expose)) {</span>
        <span class="s1">if </span><span class="s2">(expose.length) {</span>
            <span class="s1">const </span><span class="s2">exposed = instance.exposed || (instance.exposed = {})</span><span class="s1">;</span>
            <span class="s2">expose.forEach(key =&gt; {</span>
                <span class="s2">Object.defineProperty(exposed</span><span class="s1">, </span><span class="s2">key</span><span class="s1">, </span><span class="s2">{</span>
                    <span class="s2">get: () =&gt; publicThis[key]</span><span class="s1">,</span>
                    <span class="s2">set: val =&gt; (publicThis[key] = val)</span>
                <span class="s2">})</span><span class="s1">;</span>
            <span class="s2">})</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(!instance.exposed) {</span>
            <span class="s2">instance.exposed = {}</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s6">// options that are handled when creating the instance but also need to be</span>
    <span class="s6">// applied from mixins</span>
    <span class="s1">if </span><span class="s2">(render &amp;&amp; instance.render === shared.NOOP) {</span>
        <span class="s2">instance.render = render</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(inheritAttrs != </span><span class="s1">null</span><span class="s2">) {</span>
        <span class="s2">instance.inheritAttrs = inheritAttrs</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s6">// asset options.</span>
    <span class="s1">if </span><span class="s2">(components)</span>
        <span class="s2">instance.components = components</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(directives)</span>
        <span class="s2">instance.directives = directives</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">resolveInjections(injectOptions</span><span class="s1">, </span><span class="s2">ctx</span><span class="s1">, </span><span class="s2">checkDuplicateProperties = shared.NOOP</span><span class="s1">, </span><span class="s2">unwrapRef = </span><span class="s1">false</span><span class="s2">) {</span>
    <span class="s1">if </span><span class="s2">(shared.isArray(injectOptions)) {</span>
        <span class="s2">injectOptions = normalizeInject(injectOptions)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">key </span><span class="s1">in </span><span class="s2">injectOptions) {</span>
        <span class="s1">const </span><span class="s2">opt = injectOptions[key]</span><span class="s1">;</span>
        <span class="s1">let </span><span class="s2">injected</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(shared.isObject(opt)) {</span>
            <span class="s1">if </span><span class="s2">(</span><span class="s0">'default' </span><span class="s1">in </span><span class="s2">opt) {</span>
                <span class="s2">injected = inject(opt.from || key</span><span class="s1">, </span><span class="s2">opt.default</span><span class="s1">, true </span><span class="s6">/* treat default function as factory */</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s2">injected = inject(opt.from || key)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">injected = inject(opt)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(reactivity.isRef(injected)) {</span>
            <span class="s6">// TODO remove the check in 3.3</span>
            <span class="s1">if </span><span class="s2">(unwrapRef) {</span>
                <span class="s2">Object.defineProperty(ctx</span><span class="s1">, </span><span class="s2">key</span><span class="s1">, </span><span class="s2">{</span>
                    <span class="s2">enumerable: </span><span class="s1">true,</span>
                    <span class="s2">configurable: </span><span class="s1">true,</span>
                    <span class="s2">get: () =&gt; injected.value</span><span class="s1">,</span>
                    <span class="s2">set: v =&gt; (injected.value = v)</span>
                <span class="s2">})</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s2">ctx[key] = injected</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">ctx[key] = injected</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">callHook(hook</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s2">type) {</span>
    <span class="s2">callWithAsyncErrorHandling(shared.isArray(hook)</span>
        <span class="s2">? hook.map(h =&gt; h.bind(instance.proxy))</span>
        <span class="s2">: hook.bind(instance.proxy)</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s2">type)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">createWatcher(raw</span><span class="s1">, </span><span class="s2">ctx</span><span class="s1">, </span><span class="s2">publicThis</span><span class="s1">, </span><span class="s2">key) {</span>
    <span class="s1">const </span><span class="s2">getter = key.includes(</span><span class="s0">'.'</span><span class="s2">)</span>
        <span class="s2">? createPathGetter(publicThis</span><span class="s1">, </span><span class="s2">key)</span>
        <span class="s2">: () =&gt; publicThis[key]</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(shared.isString(raw)) {</span>
        <span class="s1">const </span><span class="s2">handler = ctx[raw]</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(shared.isFunction(handler)) {</span>
            <span class="s2">watch(getter</span><span class="s1">, </span><span class="s2">handler)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(shared.isFunction(raw)) {</span>
        <span class="s2">watch(getter</span><span class="s1">, </span><span class="s2">raw.bind(publicThis))</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(shared.isObject(raw)) {</span>
        <span class="s1">if </span><span class="s2">(shared.isArray(raw)) {</span>
            <span class="s2">raw.forEach(r =&gt; createWatcher(r</span><span class="s1">, </span><span class="s2">ctx</span><span class="s1">, </span><span class="s2">publicThis</span><span class="s1">, </span><span class="s2">key))</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s1">const </span><span class="s2">handler = shared.isFunction(raw.handler)</span>
                <span class="s2">? raw.handler.bind(publicThis)</span>
                <span class="s2">: ctx[raw.handler]</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(shared.isFunction(handler)) {</span>
                <span class="s2">watch(getter</span><span class="s1">, </span><span class="s2">handler</span><span class="s1">, </span><span class="s2">raw)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">else ;</span>
<span class="s2">}</span>
<span class="s3">/**</span>
 <span class="s3">* Resolve merged options and cache it on the component.</span>
 <span class="s3">* This is done only once per-component since the merging does not involve</span>
 <span class="s3">* instances.</span>
 <span class="s3">*/</span>
<span class="s1">function </span><span class="s2">resolveMergedOptions(instance) {</span>
    <span class="s1">const </span><span class="s2">base = instance.type</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">{ mixins</span><span class="s1">, extends</span><span class="s2">: extendsOptions } = base</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">{ mixins: globalMixins</span><span class="s1">, </span><span class="s2">optionsCache: cache</span><span class="s1">, </span><span class="s2">config: { optionMergeStrategies } } = instance.appContext</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">cached = cache.get(base)</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">resolved</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(cached) {</span>
        <span class="s2">resolved = cached</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(!globalMixins.length &amp;&amp; !mixins &amp;&amp; !extendsOptions) {</span>
        <span class="s2">{</span>
            <span class="s2">resolved = base</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s2">resolved = {}</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(globalMixins.length) {</span>
            <span class="s2">globalMixins.forEach(m =&gt; mergeOptions(resolved</span><span class="s1">, </span><span class="s2">m</span><span class="s1">, </span><span class="s2">optionMergeStrategies</span><span class="s1">, true</span><span class="s2">))</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s2">mergeOptions(resolved</span><span class="s1">, </span><span class="s2">base</span><span class="s1">, </span><span class="s2">optionMergeStrategies)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(shared.isObject(base)) {</span>
        <span class="s2">cache.set(base</span><span class="s1">, </span><span class="s2">resolved)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">resolved</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">mergeOptions(to</span><span class="s1">, </span><span class="s2">from</span><span class="s1">, </span><span class="s2">strats</span><span class="s1">, </span><span class="s2">asMixin = </span><span class="s1">false</span><span class="s2">) {</span>
    <span class="s1">const </span><span class="s2">{ mixins</span><span class="s1">, extends</span><span class="s2">: extendsOptions } = from</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(extendsOptions) {</span>
        <span class="s2">mergeOptions(to</span><span class="s1">, </span><span class="s2">extendsOptions</span><span class="s1">, </span><span class="s2">strats</span><span class="s1">, true</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(mixins) {</span>
        <span class="s2">mixins.forEach((m) =&gt; mergeOptions(to</span><span class="s1">, </span><span class="s2">m</span><span class="s1">, </span><span class="s2">strats</span><span class="s1">, true</span><span class="s2">))</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">key </span><span class="s1">in </span><span class="s2">from) {</span>
        <span class="s1">if </span><span class="s2">(asMixin &amp;&amp; key === </span><span class="s0">'expose'</span><span class="s2">) </span><span class="s1">;</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s1">const </span><span class="s2">strat = internalOptionMergeStrats[key] || (strats &amp;&amp; strats[key])</span><span class="s1">;</span>
            <span class="s2">to[key] = strat ? strat(to[key]</span><span class="s1">, </span><span class="s2">from[key]) : from[key]</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">to</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">const </span><span class="s2">internalOptionMergeStrats = {</span>
    <span class="s2">data: mergeDataFn</span><span class="s1">,</span>
    <span class="s2">props: mergeObjectOptions</span><span class="s1">,</span>
    <span class="s2">emits: mergeObjectOptions</span><span class="s1">,</span>
    <span class="s6">// objects</span>
    <span class="s2">methods: mergeObjectOptions</span><span class="s1">,</span>
    <span class="s2">computed: mergeObjectOptions</span><span class="s1">,</span>
    <span class="s6">// lifecycle</span>
    <span class="s2">beforeCreate: mergeAsArray</span><span class="s1">,</span>
    <span class="s2">created: mergeAsArray</span><span class="s1">,</span>
    <span class="s2">beforeMount: mergeAsArray</span><span class="s1">,</span>
    <span class="s2">mounted: mergeAsArray</span><span class="s1">,</span>
    <span class="s2">beforeUpdate: mergeAsArray</span><span class="s1">,</span>
    <span class="s2">updated: mergeAsArray</span><span class="s1">,</span>
    <span class="s2">beforeDestroy: mergeAsArray</span><span class="s1">,</span>
    <span class="s2">beforeUnmount: mergeAsArray</span><span class="s1">,</span>
    <span class="s2">destroyed: mergeAsArray</span><span class="s1">,</span>
    <span class="s2">unmounted: mergeAsArray</span><span class="s1">,</span>
    <span class="s2">activated: mergeAsArray</span><span class="s1">,</span>
    <span class="s2">deactivated: mergeAsArray</span><span class="s1">,</span>
    <span class="s2">errorCaptured: mergeAsArray</span><span class="s1">,</span>
    <span class="s2">serverPrefetch: mergeAsArray</span><span class="s1">,</span>
    <span class="s6">// assets</span>
    <span class="s2">components: mergeObjectOptions</span><span class="s1">,</span>
    <span class="s2">directives: mergeObjectOptions</span><span class="s1">,</span>
    <span class="s6">// watch</span>
    <span class="s2">watch: mergeWatchOptions</span><span class="s1">,</span>
    <span class="s6">// provide / inject</span>
    <span class="s2">provide: mergeDataFn</span><span class="s1">,</span>
    <span class="s2">inject: mergeInject</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">mergeDataFn(to</span><span class="s1">, </span><span class="s2">from) {</span>
    <span class="s1">if </span><span class="s2">(!from) {</span>
        <span class="s1">return </span><span class="s2">to</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(!to) {</span>
        <span class="s1">return </span><span class="s2">from</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return function </span><span class="s2">mergedDataFn() {</span>
        <span class="s1">return </span><span class="s2">(shared.extend)(shared.isFunction(to) ? to.call(</span><span class="s1">this, this</span><span class="s2">) : to</span><span class="s1">, </span><span class="s2">shared.isFunction(from) ? from.call(</span><span class="s1">this, this</span><span class="s2">) : from)</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">mergeInject(to</span><span class="s1">, </span><span class="s2">from) {</span>
    <span class="s1">return </span><span class="s2">mergeObjectOptions(normalizeInject(to)</span><span class="s1">, </span><span class="s2">normalizeInject(from))</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">normalizeInject(raw) {</span>
    <span class="s1">if </span><span class="s2">(shared.isArray(raw)) {</span>
        <span class="s1">const </span><span class="s2">res = {}</span><span class="s1">;</span>
        <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s5">0</span><span class="s1">; </span><span class="s2">i &lt; raw.length</span><span class="s1">; </span><span class="s2">i++) {</span>
            <span class="s2">res[raw[i]] = raw[i]</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">return </span><span class="s2">res</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">raw</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">mergeAsArray(to</span><span class="s1">, </span><span class="s2">from) {</span>
    <span class="s1">return </span><span class="s2">to ? [...</span><span class="s1">new </span><span class="s2">Set([].concat(to</span><span class="s1">, </span><span class="s2">from))] : from</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">mergeObjectOptions(to</span><span class="s1">, </span><span class="s2">from) {</span>
    <span class="s1">return </span><span class="s2">to ? shared.extend(shared.extend(Object.create(</span><span class="s1">null</span><span class="s2">)</span><span class="s1">, </span><span class="s2">to)</span><span class="s1">, </span><span class="s2">from) : from</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">mergeWatchOptions(to</span><span class="s1">, </span><span class="s2">from) {</span>
    <span class="s1">if </span><span class="s2">(!to)</span>
        <span class="s1">return </span><span class="s2">from</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(!from)</span>
        <span class="s1">return </span><span class="s2">to</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">merged = shared.extend(Object.create(</span><span class="s1">null</span><span class="s2">)</span><span class="s1">, </span><span class="s2">to)</span><span class="s1">;</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">key </span><span class="s1">in </span><span class="s2">from) {</span>
        <span class="s2">merged[key] = mergeAsArray(to[key]</span><span class="s1">, </span><span class="s2">from[key])</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">merged</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s1">function </span><span class="s2">initProps(instance</span><span class="s1">, </span><span class="s2">rawProps</span><span class="s1">, </span><span class="s2">isStateful</span><span class="s1">, </span><span class="s6">// result of bitwise flag comparison</span>
<span class="s2">isSSR = </span><span class="s1">false</span><span class="s2">) {</span>
    <span class="s1">const </span><span class="s2">props = {}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">attrs = {}</span><span class="s1">;</span>
    <span class="s2">shared.def(attrs</span><span class="s1">, </span><span class="s2">InternalObjectKey</span><span class="s1">, </span><span class="s5">1</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">instance.propsDefaults = Object.create(</span><span class="s1">null</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">setFullProps(instance</span><span class="s1">, </span><span class="s2">rawProps</span><span class="s1">, </span><span class="s2">props</span><span class="s1">, </span><span class="s2">attrs)</span><span class="s1">;</span>
    <span class="s6">// ensure all declared prop keys are present</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">key </span><span class="s1">in </span><span class="s2">instance.propsOptions[</span><span class="s5">0</span><span class="s2">]) {</span>
        <span class="s1">if </span><span class="s2">(!(key </span><span class="s1">in </span><span class="s2">props)) {</span>
            <span class="s2">props[key] = undefined</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(isStateful) {</span>
        <span class="s6">// stateful</span>
        <span class="s2">instance.props = isSSR ? props : reactivity.shallowReactive(props)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s1">if </span><span class="s2">(!instance.type.props) {</span>
            <span class="s6">// functional w/ optional props, props === attrs</span>
            <span class="s2">instance.props = attrs</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s6">// functional w/ declared props</span>
            <span class="s2">instance.props = props</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s2">instance.attrs = attrs</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">updateProps(instance</span><span class="s1">, </span><span class="s2">rawProps</span><span class="s1">, </span><span class="s2">rawPrevProps</span><span class="s1">, </span><span class="s2">optimized) {</span>
    <span class="s1">const </span><span class="s2">{ props</span><span class="s1">, </span><span class="s2">attrs</span><span class="s1">, </span><span class="s2">vnode: { patchFlag } } = instance</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">rawCurrentProps = reactivity.toRaw(props)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">[options] = instance.propsOptions</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">hasAttrsChanged = </span><span class="s1">false;</span>
    <span class="s1">if </span><span class="s2">(</span>
    <span class="s6">// always force full diff in dev</span>
    <span class="s6">// - #1942 if hmr is enabled with sfc component</span>
    <span class="s6">// - vite#872 non-sfc component used by sfc component</span>
    <span class="s2">(optimized || patchFlag &gt; </span><span class="s5">0</span><span class="s2">) &amp;&amp;</span>
        <span class="s2">!(patchFlag &amp; </span><span class="s5">16 </span><span class="s6">/* PatchFlags.FULL_PROPS */</span><span class="s2">)) {</span>
        <span class="s1">if </span><span class="s2">(patchFlag &amp; </span><span class="s5">8 </span><span class="s6">/* PatchFlags.PROPS */</span><span class="s2">) {</span>
            <span class="s6">// Compiler-generated props &amp; no keys change, just set the updated</span>
            <span class="s6">// the props.</span>
            <span class="s1">const </span><span class="s2">propsToUpdate = instance.vnode.dynamicProps</span><span class="s1">;</span>
            <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s5">0</span><span class="s1">; </span><span class="s2">i &lt; propsToUpdate.length</span><span class="s1">; </span><span class="s2">i++) {</span>
                <span class="s1">let </span><span class="s2">key = propsToUpdate[i]</span><span class="s1">;</span>
                <span class="s6">// skip if the prop key is a declared emit event listener</span>
                <span class="s1">if </span><span class="s2">(isEmitListener(instance.emitsOptions</span><span class="s1">, </span><span class="s2">key)) {</span>
                    <span class="s1">continue;</span>
                <span class="s2">}</span>
                <span class="s6">// PROPS flag guarantees rawProps to be non-null</span>
                <span class="s1">const </span><span class="s2">value = rawProps[key]</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(options) {</span>
                    <span class="s6">// attr / props separation was done on init and will be consistent</span>
                    <span class="s6">// in this code path, so just check if attrs have it.</span>
                    <span class="s1">if </span><span class="s2">(shared.hasOwn(attrs</span><span class="s1">, </span><span class="s2">key)) {</span>
                        <span class="s1">if </span><span class="s2">(value !== attrs[key]) {</span>
                            <span class="s2">attrs[key] = value</span><span class="s1">;</span>
                            <span class="s2">hasAttrsChanged = </span><span class="s1">true;</span>
                        <span class="s2">}</span>
                    <span class="s2">}</span>
                    <span class="s1">else </span><span class="s2">{</span>
                        <span class="s1">const </span><span class="s2">camelizedKey = shared.camelize(key)</span><span class="s1">;</span>
                        <span class="s2">props[camelizedKey] = resolvePropValue(options</span><span class="s1">, </span><span class="s2">rawCurrentProps</span><span class="s1">, </span><span class="s2">camelizedKey</span><span class="s1">, </span><span class="s2">value</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, false </span><span class="s6">/* isAbsent */</span><span class="s2">)</span><span class="s1">;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s1">if </span><span class="s2">(value !== attrs[key]) {</span>
                        <span class="s2">attrs[key] = value</span><span class="s1">;</span>
                        <span class="s2">hasAttrsChanged = </span><span class="s1">true;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s6">// full props update.</span>
        <span class="s1">if </span><span class="s2">(setFullProps(instance</span><span class="s1">, </span><span class="s2">rawProps</span><span class="s1">, </span><span class="s2">props</span><span class="s1">, </span><span class="s2">attrs)) {</span>
            <span class="s2">hasAttrsChanged = </span><span class="s1">true;</span>
        <span class="s2">}</span>
        <span class="s6">// in case of dynamic props, check if we need to delete keys from</span>
        <span class="s6">// the props object</span>
        <span class="s1">let </span><span class="s2">kebabKey</span><span class="s1">;</span>
        <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">key </span><span class="s1">in </span><span class="s2">rawCurrentProps) {</span>
            <span class="s1">if </span><span class="s2">(!rawProps ||</span>
                <span class="s6">// for camelCase</span>
                <span class="s2">(!shared.hasOwn(rawProps</span><span class="s1">, </span><span class="s2">key) &amp;&amp;</span>
                    <span class="s6">// it's possible the original props was passed in as kebab-case</span>
                    <span class="s6">// and converted to camelCase (#955)</span>
                    <span class="s2">((kebabKey = shared.hyphenate(key)) === key || !shared.hasOwn(rawProps</span><span class="s1">, </span><span class="s2">kebabKey)))) {</span>
                <span class="s1">if </span><span class="s2">(options) {</span>
                    <span class="s1">if </span><span class="s2">(rawPrevProps &amp;&amp;</span>
                        <span class="s6">// for camelCase</span>
                        <span class="s2">(rawPrevProps[key] !== undefined ||</span>
                            <span class="s6">// for kebab-case</span>
                            <span class="s2">rawPrevProps[kebabKey] !== undefined)) {</span>
                        <span class="s2">props[key] = resolvePropValue(options</span><span class="s1">, </span><span class="s2">rawCurrentProps</span><span class="s1">, </span><span class="s2">key</span><span class="s1">, </span><span class="s2">undefined</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, true </span><span class="s6">/* isAbsent */</span><span class="s2">)</span><span class="s1">;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s1">delete </span><span class="s2">props[key]</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s6">// in the case of functional component w/o props declaration, props and</span>
        <span class="s6">// attrs point to the same object so it should already have been updated.</span>
        <span class="s1">if </span><span class="s2">(attrs !== rawCurrentProps) {</span>
            <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">key </span><span class="s1">in </span><span class="s2">attrs) {</span>
                <span class="s1">if </span><span class="s2">(!rawProps ||</span>
                    <span class="s2">(!shared.hasOwn(rawProps</span><span class="s1">, </span><span class="s2">key) &amp;&amp;</span>
                        <span class="s2">(!</span><span class="s1">false </span><span class="s2">))) {</span>
                    <span class="s1">delete </span><span class="s2">attrs[key]</span><span class="s1">;</span>
                    <span class="s2">hasAttrsChanged = </span><span class="s1">true;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s6">// trigger updates for $attrs in case it's used in component slots</span>
    <span class="s1">if </span><span class="s2">(hasAttrsChanged) {</span>
        <span class="s2">reactivity.trigger(instance</span><span class="s1">, </span><span class="s0">&quot;set&quot; </span><span class="s6">/* TriggerOpTypes.SET */</span><span class="s1">, </span><span class="s0">'$attrs'</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">setFullProps(instance</span><span class="s1">, </span><span class="s2">rawProps</span><span class="s1">, </span><span class="s2">props</span><span class="s1">, </span><span class="s2">attrs) {</span>
    <span class="s1">const </span><span class="s2">[options</span><span class="s1">, </span><span class="s2">needCastKeys] = instance.propsOptions</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">hasAttrsChanged = </span><span class="s1">false;</span>
    <span class="s1">let </span><span class="s2">rawCastValues</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(rawProps) {</span>
        <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">key </span><span class="s1">in </span><span class="s2">rawProps) {</span>
            <span class="s6">// key, ref are reserved and never passed down</span>
            <span class="s1">if </span><span class="s2">(shared.isReservedProp(key)) {</span>
                <span class="s1">continue;</span>
            <span class="s2">}</span>
            <span class="s1">const </span><span class="s2">value = rawProps[key]</span><span class="s1">;</span>
            <span class="s6">// prop option names are camelized during normalization, so to support</span>
            <span class="s6">// kebab -&gt; camel conversion here we need to camelize the key.</span>
            <span class="s1">let </span><span class="s2">camelKey</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(options &amp;&amp; shared.hasOwn(options</span><span class="s1">, </span><span class="s2">(camelKey = shared.camelize(key)))) {</span>
                <span class="s1">if </span><span class="s2">(!needCastKeys || !needCastKeys.includes(camelKey)) {</span>
                    <span class="s2">props[camelKey] = value</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s2">(rawCastValues || (rawCastValues = {}))[camelKey] = value</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(!isEmitListener(instance.emitsOptions</span><span class="s1">, </span><span class="s2">key)) {</span>
                <span class="s1">if </span><span class="s2">(!(key </span><span class="s1">in </span><span class="s2">attrs) || value !== attrs[key]) {</span>
                    <span class="s2">attrs[key] = value</span><span class="s1">;</span>
                    <span class="s2">hasAttrsChanged = </span><span class="s1">true;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(needCastKeys) {</span>
        <span class="s1">const </span><span class="s2">rawCurrentProps = reactivity.toRaw(props)</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">castValues = rawCastValues || shared.EMPTY_OBJ</span><span class="s1">;</span>
        <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s5">0</span><span class="s1">; </span><span class="s2">i &lt; needCastKeys.length</span><span class="s1">; </span><span class="s2">i++) {</span>
            <span class="s1">const </span><span class="s2">key = needCastKeys[i]</span><span class="s1">;</span>
            <span class="s2">props[key] = resolvePropValue(options</span><span class="s1">, </span><span class="s2">rawCurrentProps</span><span class="s1">, </span><span class="s2">key</span><span class="s1">, </span><span class="s2">castValues[key]</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s2">!shared.hasOwn(castValues</span><span class="s1">, </span><span class="s2">key))</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">hasAttrsChanged</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">resolvePropValue(options</span><span class="s1">, </span><span class="s2">props</span><span class="s1">, </span><span class="s2">key</span><span class="s1">, </span><span class="s2">value</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s2">isAbsent) {</span>
    <span class="s1">const </span><span class="s2">opt = options[key]</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(opt != </span><span class="s1">null</span><span class="s2">) {</span>
        <span class="s1">const </span><span class="s2">hasDefault = shared.hasOwn(opt</span><span class="s1">, </span><span class="s0">'default'</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s6">// default values</span>
        <span class="s1">if </span><span class="s2">(hasDefault &amp;&amp; value === undefined) {</span>
            <span class="s1">const </span><span class="s2">defaultValue = opt.default</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(opt.type !== Function &amp;&amp; shared.isFunction(defaultValue)) {</span>
                <span class="s1">const </span><span class="s2">{ propsDefaults } = instance</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(key </span><span class="s1">in </span><span class="s2">propsDefaults) {</span>
                    <span class="s2">value = propsDefaults[key]</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s2">setCurrentInstance(instance)</span><span class="s1">;</span>
                    <span class="s2">value = propsDefaults[key] = defaultValue.call(</span><span class="s1">null, </span><span class="s2">props)</span><span class="s1">;</span>
                    <span class="s2">unsetCurrentInstance()</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s2">value = defaultValue</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s6">// boolean casting</span>
        <span class="s1">if </span><span class="s2">(opt[</span><span class="s5">0 </span><span class="s6">/* BooleanFlags.shouldCast */</span><span class="s2">]) {</span>
            <span class="s1">if </span><span class="s2">(isAbsent &amp;&amp; !hasDefault) {</span>
                <span class="s2">value = </span><span class="s1">false;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(opt[</span><span class="s5">1 </span><span class="s6">/* BooleanFlags.shouldCastTrue */</span><span class="s2">] &amp;&amp;</span>
                <span class="s2">(value === </span><span class="s0">'' </span><span class="s2">|| value === shared.hyphenate(key))) {</span>
                <span class="s2">value = </span><span class="s1">true;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">value</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">normalizePropsOptions(comp</span><span class="s1">, </span><span class="s2">appContext</span><span class="s1">, </span><span class="s2">asMixin = </span><span class="s1">false</span><span class="s2">) {</span>
    <span class="s1">const </span><span class="s2">cache = appContext.propsCache</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">cached = cache.get(comp)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(cached) {</span>
        <span class="s1">return </span><span class="s2">cached</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">raw = comp.props</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">normalized = {}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">needCastKeys = []</span><span class="s1">;</span>
    <span class="s6">// apply mixin/extends props</span>
    <span class="s1">let </span><span class="s2">hasExtends = </span><span class="s1">false;</span>
    <span class="s1">if </span><span class="s2">(!shared.isFunction(comp)) {</span>
        <span class="s1">const </span><span class="s2">extendProps = (raw) =&gt; {</span>
            <span class="s2">hasExtends = </span><span class="s1">true;</span>
            <span class="s1">const </span><span class="s2">[props</span><span class="s1">, </span><span class="s2">keys] = normalizePropsOptions(raw</span><span class="s1">, </span><span class="s2">appContext</span><span class="s1">, true</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">shared.extend(normalized</span><span class="s1">, </span><span class="s2">props)</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(keys)</span>
                <span class="s2">needCastKeys.push(...keys)</span><span class="s1">;</span>
        <span class="s2">}</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(!asMixin &amp;&amp; appContext.mixins.length) {</span>
            <span class="s2">appContext.mixins.forEach(extendProps)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(comp.extends) {</span>
            <span class="s2">extendProps(comp.extends)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(comp.mixins) {</span>
            <span class="s2">comp.mixins.forEach(extendProps)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(!raw &amp;&amp; !hasExtends) {</span>
        <span class="s1">if </span><span class="s2">(shared.isObject(comp)) {</span>
            <span class="s2">cache.set(comp</span><span class="s1">, </span><span class="s2">shared.EMPTY_ARR)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">return </span><span class="s2">shared.EMPTY_ARR</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(shared.isArray(raw)) {</span>
        <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s5">0</span><span class="s1">; </span><span class="s2">i &lt; raw.length</span><span class="s1">; </span><span class="s2">i++) {</span>
            <span class="s1">const </span><span class="s2">normalizedKey = shared.camelize(raw[i])</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(validatePropName(normalizedKey)) {</span>
                <span class="s2">normalized[normalizedKey] = shared.EMPTY_OBJ</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(raw) {</span>
        <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">key </span><span class="s1">in </span><span class="s2">raw) {</span>
            <span class="s1">const </span><span class="s2">normalizedKey = shared.camelize(key)</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(validatePropName(normalizedKey)) {</span>
                <span class="s1">const </span><span class="s2">opt = raw[key]</span><span class="s1">;</span>
                <span class="s1">const </span><span class="s2">prop = (normalized[normalizedKey] =</span>
                    <span class="s2">shared.isArray(opt) || shared.isFunction(opt) ? { type: opt } : { ...opt })</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(prop) {</span>
                    <span class="s1">const </span><span class="s2">booleanIndex = getTypeIndex(Boolean</span><span class="s1">, </span><span class="s2">prop.type)</span><span class="s1">;</span>
                    <span class="s1">const </span><span class="s2">stringIndex = getTypeIndex(String</span><span class="s1">, </span><span class="s2">prop.type)</span><span class="s1">;</span>
                    <span class="s2">prop[</span><span class="s5">0 </span><span class="s6">/* BooleanFlags.shouldCast */</span><span class="s2">] = booleanIndex &gt; -</span><span class="s5">1</span><span class="s1">;</span>
                    <span class="s2">prop[</span><span class="s5">1 </span><span class="s6">/* BooleanFlags.shouldCastTrue */</span><span class="s2">] =</span>
                        <span class="s2">stringIndex &lt; </span><span class="s5">0 </span><span class="s2">|| booleanIndex &lt; stringIndex</span><span class="s1">;</span>
                    <span class="s6">// if the prop needs boolean casting or default value</span>
                    <span class="s1">if </span><span class="s2">(booleanIndex &gt; -</span><span class="s5">1 </span><span class="s2">|| shared.hasOwn(prop</span><span class="s1">, </span><span class="s0">'default'</span><span class="s2">)) {</span>
                        <span class="s2">needCastKeys.push(normalizedKey)</span><span class="s1">;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">res = [normalized</span><span class="s1">, </span><span class="s2">needCastKeys]</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(shared.isObject(comp)) {</span>
        <span class="s2">cache.set(comp</span><span class="s1">, </span><span class="s2">res)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">res</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">validatePropName(key) {</span>
    <span class="s1">if </span><span class="s2">(key[</span><span class="s5">0</span><span class="s2">] !== </span><span class="s0">'$'</span><span class="s2">) {</span>
        <span class="s1">return true;</span>
    <span class="s2">}</span>
    <span class="s1">return false;</span>
<span class="s2">}</span>
<span class="s6">// use function string name to check type constructors</span>
<span class="s6">// so that it works across vms / iframes.</span>
<span class="s1">function </span><span class="s2">getType(ctor) {</span>
    <span class="s1">const </span><span class="s2">match = ctor &amp;&amp; ctor.toString().match(</span><span class="s5">/^\s*(function|class) (\w+)/</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">match ? match[</span><span class="s5">2</span><span class="s2">] : ctor === </span><span class="s1">null </span><span class="s2">? </span><span class="s0">'null' </span><span class="s2">: </span><span class="s0">''</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">isSameType(a</span><span class="s1">, </span><span class="s2">b) {</span>
    <span class="s1">return </span><span class="s2">getType(a) === getType(b)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">getTypeIndex(type</span><span class="s1">, </span><span class="s2">expectedTypes) {</span>
    <span class="s1">if </span><span class="s2">(shared.isArray(expectedTypes)) {</span>
        <span class="s1">return </span><span class="s2">expectedTypes.findIndex(t =&gt; isSameType(t</span><span class="s1">, </span><span class="s2">type))</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(shared.isFunction(expectedTypes)) {</span>
        <span class="s1">return </span><span class="s2">isSameType(expectedTypes</span><span class="s1">, </span><span class="s2">type) ? </span><span class="s5">0 </span><span class="s2">: -</span><span class="s5">1</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">-</span><span class="s5">1</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s1">const </span><span class="s2">isInternalKey = (key) =&gt; key[</span><span class="s5">0</span><span class="s2">] === </span><span class="s0">'_' </span><span class="s2">|| key === </span><span class="s0">'$stable'</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">normalizeSlotValue = (value) =&gt; shared.isArray(value)</span>
    <span class="s2">? value.map(normalizeVNode)</span>
    <span class="s2">: [normalizeVNode(value)]</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">normalizeSlot = (key</span><span class="s1">, </span><span class="s2">rawSlot</span><span class="s1">, </span><span class="s2">ctx) =&gt; {</span>
    <span class="s1">if </span><span class="s2">(rawSlot._n) {</span>
        <span class="s6">// already normalized - #5353</span>
        <span class="s1">return </span><span class="s2">rawSlot</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">normalized = withCtx((...args) =&gt; {</span>
        <span class="s1">if </span><span class="s2">(</span><span class="s1">false </span><span class="s2">&amp;&amp; currentInstance) </span><span class="s1">;</span>
        <span class="s1">return </span><span class="s2">normalizeSlotValue(rawSlot(...args))</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">, </span><span class="s2">ctx)</span><span class="s1">;</span>
    <span class="s2">normalized._c = </span><span class="s1">false;</span>
    <span class="s1">return </span><span class="s2">normalized</span><span class="s1">;</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">normalizeObjectSlots = (rawSlots</span><span class="s1">, </span><span class="s2">slots</span><span class="s1">, </span><span class="s2">instance) =&gt; {</span>
    <span class="s1">const </span><span class="s2">ctx = rawSlots._ctx</span><span class="s1">;</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">key </span><span class="s1">in </span><span class="s2">rawSlots) {</span>
        <span class="s1">if </span><span class="s2">(isInternalKey(key))</span>
            <span class="s1">continue;</span>
        <span class="s1">const </span><span class="s2">value = rawSlots[key]</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(shared.isFunction(value)) {</span>
            <span class="s2">slots[key] = normalizeSlot(key</span><span class="s1">, </span><span class="s2">value</span><span class="s1">, </span><span class="s2">ctx)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(value != </span><span class="s1">null</span><span class="s2">) {</span>
            <span class="s1">const </span><span class="s2">normalized = normalizeSlotValue(value)</span><span class="s1">;</span>
            <span class="s2">slots[key] = () =&gt; normalized</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">normalizeVNodeSlots = (instance</span><span class="s1">, </span><span class="s2">children) =&gt; {</span>
    <span class="s1">const </span><span class="s2">normalized = normalizeSlotValue(children)</span><span class="s1">;</span>
    <span class="s2">instance.slots.default = () =&gt; normalized</span><span class="s1">;</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">initSlots = (instance</span><span class="s1">, </span><span class="s2">children) =&gt; {</span>
    <span class="s1">if </span><span class="s2">(instance.vnode.shapeFlag &amp; </span><span class="s5">32 </span><span class="s6">/* ShapeFlags.SLOTS_CHILDREN */</span><span class="s2">) {</span>
        <span class="s1">const </span><span class="s2">type = children._</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(type) {</span>
            <span class="s6">// users can get the shallow readonly version of the slots object through `this.$slots`,</span>
            <span class="s6">// we should avoid the proxy object polluting the slots of the internal instance</span>
            <span class="s2">instance.slots = reactivity.toRaw(children)</span><span class="s1">;</span>
            <span class="s6">// make compiler marker non-enumerable</span>
            <span class="s2">shared.def(children</span><span class="s1">, </span><span class="s0">'_'</span><span class="s1">, </span><span class="s2">type)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">normalizeObjectSlots(children</span><span class="s1">, </span><span class="s2">(instance.slots = {}))</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s2">instance.slots = {}</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(children) {</span>
            <span class="s2">normalizeVNodeSlots(instance</span><span class="s1">, </span><span class="s2">children)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s2">shared.def(instance.slots</span><span class="s1">, </span><span class="s2">InternalObjectKey</span><span class="s1">, </span><span class="s5">1</span><span class="s2">)</span><span class="s1">;</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">updateSlots = (instance</span><span class="s1">, </span><span class="s2">children</span><span class="s1">, </span><span class="s2">optimized) =&gt; {</span>
    <span class="s1">const </span><span class="s2">{ vnode</span><span class="s1">, </span><span class="s2">slots } = instance</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">needDeletionCheck = </span><span class="s1">true;</span>
    <span class="s1">let </span><span class="s2">deletionComparisonTarget = shared.EMPTY_OBJ</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(vnode.shapeFlag &amp; </span><span class="s5">32 </span><span class="s6">/* ShapeFlags.SLOTS_CHILDREN */</span><span class="s2">) {</span>
        <span class="s1">const </span><span class="s2">type = children._</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(type) {</span>
            <span class="s6">// compiled slots.</span>
            <span class="s1">if </span><span class="s2">(optimized &amp;&amp; type === </span><span class="s5">1 </span><span class="s6">/* SlotFlags.STABLE */</span><span class="s2">) {</span>
                <span class="s6">// compiled AND stable.</span>
                <span class="s6">// no need to update, and skip stale slots removal.</span>
                <span class="s2">needDeletionCheck = </span><span class="s1">false;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s6">// compiled but dynamic (v-if/v-for on slots) - update slots, but skip</span>
                <span class="s6">// normalization.</span>
                <span class="s2">shared.extend(slots</span><span class="s1">, </span><span class="s2">children)</span><span class="s1">;</span>
                <span class="s6">// #2893</span>
                <span class="s6">// when rendering the optimized slots by manually written render function,</span>
                <span class="s6">// we need to delete the `slots._` flag if necessary to make subsequent updates reliable,</span>
                <span class="s6">// i.e. let the `renderSlot` create the bailed Fragment</span>
                <span class="s1">if </span><span class="s2">(!optimized &amp;&amp; type === </span><span class="s5">1 </span><span class="s6">/* SlotFlags.STABLE */</span><span class="s2">) {</span>
                    <span class="s1">delete </span><span class="s2">slots._</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">needDeletionCheck = !children.$stable</span><span class="s1">;</span>
            <span class="s2">normalizeObjectSlots(children</span><span class="s1">, </span><span class="s2">slots)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s2">deletionComparisonTarget = children</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(children) {</span>
        <span class="s6">// non slot object children (direct value) passed to a component</span>
        <span class="s2">normalizeVNodeSlots(instance</span><span class="s1">, </span><span class="s2">children)</span><span class="s1">;</span>
        <span class="s2">deletionComparisonTarget = { </span><span class="s1">default</span><span class="s2">: </span><span class="s5">1 </span><span class="s2">}</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s6">// delete stale slots</span>
    <span class="s1">if </span><span class="s2">(needDeletionCheck) {</span>
        <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">key </span><span class="s1">in </span><span class="s2">slots) {</span>
            <span class="s1">if </span><span class="s2">(!isInternalKey(key) &amp;&amp; !(key </span><span class="s1">in </span><span class="s2">deletionComparisonTarget)) {</span>
                <span class="s1">delete </span><span class="s2">slots[key]</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
<span class="s2">}</span><span class="s1">;</span>

<span class="s1">function </span><span class="s2">createAppContext() {</span>
    <span class="s1">return </span><span class="s2">{</span>
        <span class="s2">app: </span><span class="s1">null,</span>
        <span class="s2">config: {</span>
            <span class="s2">isNativeTag: shared.NO</span><span class="s1">,</span>
            <span class="s2">performance: </span><span class="s1">false,</span>
            <span class="s2">globalProperties: {}</span><span class="s1">,</span>
            <span class="s2">optionMergeStrategies: {}</span><span class="s1">,</span>
            <span class="s2">errorHandler: undefined</span><span class="s1">,</span>
            <span class="s2">warnHandler: undefined</span><span class="s1">,</span>
            <span class="s2">compilerOptions: {}</span>
        <span class="s2">}</span><span class="s1">,</span>
        <span class="s2">mixins: []</span><span class="s1">,</span>
        <span class="s2">components: {}</span><span class="s1">,</span>
        <span class="s2">directives: {}</span><span class="s1">,</span>
        <span class="s2">provides: Object.create(</span><span class="s1">null</span><span class="s2">)</span><span class="s1">,</span>
        <span class="s2">optionsCache: </span><span class="s1">new </span><span class="s2">WeakMap()</span><span class="s1">,</span>
        <span class="s2">propsCache: </span><span class="s1">new </span><span class="s2">WeakMap()</span><span class="s1">,</span>
        <span class="s2">emitsCache: </span><span class="s1">new </span><span class="s2">WeakMap()</span>
    <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">let </span><span class="s2">uid$1 = </span><span class="s5">0</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">createAppAPI(render</span><span class="s1">, </span><span class="s2">hydrate) {</span>
    <span class="s1">return function </span><span class="s2">createApp(rootComponent</span><span class="s1">, </span><span class="s2">rootProps = </span><span class="s1">null</span><span class="s2">) {</span>
        <span class="s1">if </span><span class="s2">(!shared.isFunction(rootComponent)) {</span>
            <span class="s2">rootComponent = { ...rootComponent }</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(rootProps != </span><span class="s1">null </span><span class="s2">&amp;&amp; !shared.isObject(rootProps)) {</span>
            <span class="s2">rootProps = </span><span class="s1">null;</span>
        <span class="s2">}</span>
        <span class="s1">const </span><span class="s2">context = createAppContext()</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">installedPlugins = </span><span class="s1">new </span><span class="s2">Set()</span><span class="s1">;</span>
        <span class="s1">let </span><span class="s2">isMounted = </span><span class="s1">false;</span>
        <span class="s1">const </span><span class="s2">app = (context.app = {</span>
            <span class="s2">_uid: uid$1++</span><span class="s1">,</span>
            <span class="s2">_component: rootComponent</span><span class="s1">,</span>
            <span class="s2">_props: rootProps</span><span class="s1">,</span>
            <span class="s2">_container: </span><span class="s1">null,</span>
            <span class="s2">_context: context</span><span class="s1">,</span>
            <span class="s2">_instance: </span><span class="s1">null,</span>
            <span class="s2">version</span><span class="s1">,</span>
            <span class="s2">get config() {</span>
                <span class="s1">return </span><span class="s2">context.config</span><span class="s1">;</span>
            <span class="s2">}</span><span class="s1">,</span>
            <span class="s2">set config(v) {</span>
            <span class="s2">}</span><span class="s1">,</span>
            <span class="s2">use(plugin</span><span class="s1">, </span><span class="s2">...options) {</span>
                <span class="s1">if </span><span class="s2">(installedPlugins.has(plugin)) </span><span class="s1">;</span>
                <span class="s1">else if </span><span class="s2">(plugin &amp;&amp; shared.isFunction(plugin.install)) {</span>
                    <span class="s2">installedPlugins.add(plugin)</span><span class="s1">;</span>
                    <span class="s2">plugin.install(app</span><span class="s1">, </span><span class="s2">...options)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else if </span><span class="s2">(shared.isFunction(plugin)) {</span>
                    <span class="s2">installedPlugins.add(plugin)</span><span class="s1">;</span>
                    <span class="s2">plugin(app</span><span class="s1">, </span><span class="s2">...options)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else ;</span>
                <span class="s1">return </span><span class="s2">app</span><span class="s1">;</span>
            <span class="s2">}</span><span class="s1">,</span>
            <span class="s2">mixin(mixin) {</span>
                <span class="s2">{</span>
                    <span class="s1">if </span><span class="s2">(!context.mixins.includes(mixin)) {</span>
                        <span class="s2">context.mixins.push(mixin)</span><span class="s1">;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
                <span class="s1">return </span><span class="s2">app</span><span class="s1">;</span>
            <span class="s2">}</span><span class="s1">,</span>
            <span class="s2">component(name</span><span class="s1">, </span><span class="s2">component) {</span>
                <span class="s1">if </span><span class="s2">(!component) {</span>
                    <span class="s1">return </span><span class="s2">context.components[name]</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s2">context.components[name] = component</span><span class="s1">;</span>
                <span class="s1">return </span><span class="s2">app</span><span class="s1">;</span>
            <span class="s2">}</span><span class="s1">,</span>
            <span class="s2">directive(name</span><span class="s1">, </span><span class="s2">directive) {</span>
                <span class="s1">if </span><span class="s2">(!directive) {</span>
                    <span class="s1">return </span><span class="s2">context.directives[name]</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s2">context.directives[name] = directive</span><span class="s1">;</span>
                <span class="s1">return </span><span class="s2">app</span><span class="s1">;</span>
            <span class="s2">}</span><span class="s1">,</span>
            <span class="s2">mount(rootContainer</span><span class="s1">, </span><span class="s2">isHydrate</span><span class="s1">, </span><span class="s2">isSVG) {</span>
                <span class="s1">if </span><span class="s2">(!isMounted) {</span>
                    <span class="s1">const </span><span class="s2">vnode = createVNode(rootComponent</span><span class="s1">, </span><span class="s2">rootProps)</span><span class="s1">;</span>
                    <span class="s6">// store app context on the root VNode.</span>
                    <span class="s6">// this will be set on the root instance on initial mount.</span>
                    <span class="s2">vnode.appContext = context</span><span class="s1">;</span>
                    <span class="s1">if </span><span class="s2">(isHydrate &amp;&amp; hydrate) {</span>
                        <span class="s2">hydrate(vnode</span><span class="s1">, </span><span class="s2">rootContainer)</span><span class="s1">;</span>
                    <span class="s2">}</span>
                    <span class="s1">else </span><span class="s2">{</span>
                        <span class="s2">render(vnode</span><span class="s1">, </span><span class="s2">rootContainer</span><span class="s1">, </span><span class="s2">isSVG)</span><span class="s1">;</span>
                    <span class="s2">}</span>
                    <span class="s2">isMounted = </span><span class="s1">true;</span>
                    <span class="s2">app._container = rootContainer</span><span class="s1">;</span>
                    <span class="s2">rootContainer.__vue_app__ = app</span><span class="s1">;</span>
                    <span class="s1">return </span><span class="s2">getExposeProxy(vnode.component) || vnode.component.proxy</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span><span class="s1">,</span>
            <span class="s2">unmount() {</span>
                <span class="s1">if </span><span class="s2">(isMounted) {</span>
                    <span class="s2">render(</span><span class="s1">null, </span><span class="s2">app._container)</span><span class="s1">;</span>
                    <span class="s1">delete </span><span class="s2">app._container.__vue_app__</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span><span class="s1">,</span>
            <span class="s2">provide(key</span><span class="s1">, </span><span class="s2">value) {</span>
                <span class="s2">context.provides[key] = value</span><span class="s1">;</span>
                <span class="s1">return </span><span class="s2">app</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">})</span><span class="s1">;</span>
        <span class="s1">return </span><span class="s2">app</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s3">/**</span>
 <span class="s3">* Function for handling a template ref</span>
 <span class="s3">*/</span>
<span class="s1">function </span><span class="s2">setRef(rawRef</span><span class="s1">, </span><span class="s2">oldRawRef</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">vnode</span><span class="s1">, </span><span class="s2">isUnmount = </span><span class="s1">false</span><span class="s2">) {</span>
    <span class="s1">if </span><span class="s2">(shared.isArray(rawRef)) {</span>
        <span class="s2">rawRef.forEach((r</span><span class="s1">, </span><span class="s2">i) =&gt; setRef(r</span><span class="s1">, </span><span class="s2">oldRawRef &amp;&amp; (shared.isArray(oldRawRef) ? oldRawRef[i] : oldRawRef)</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">vnode</span><span class="s1">, </span><span class="s2">isUnmount))</span><span class="s1">;</span>
        <span class="s1">return;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(isAsyncWrapper(vnode) &amp;&amp; !isUnmount) {</span>
        <span class="s6">// when mounting async components, nothing needs to be done,</span>
        <span class="s6">// because the template ref is forwarded to inner component</span>
        <span class="s1">return;</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">refValue = vnode.shapeFlag &amp; </span><span class="s5">4 </span><span class="s6">/* ShapeFlags.STATEFUL_COMPONENT */</span>
        <span class="s2">? getExposeProxy(vnode.component) || vnode.component.proxy</span>
        <span class="s2">: vnode.el</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">value = isUnmount ? </span><span class="s1">null </span><span class="s2">: refValue</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">{ i: owner</span><span class="s1">, </span><span class="s2">r: ref } = rawRef</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">oldRef = oldRawRef &amp;&amp; oldRawRef.r</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">refs = owner.refs === shared.EMPTY_OBJ ? (owner.refs = {}) : owner.refs</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">setupState = owner.setupState</span><span class="s1">;</span>
    <span class="s6">// dynamic ref changed. unset old ref</span>
    <span class="s1">if </span><span class="s2">(oldRef != </span><span class="s1">null </span><span class="s2">&amp;&amp; oldRef !== ref) {</span>
        <span class="s1">if </span><span class="s2">(shared.isString(oldRef)) {</span>
            <span class="s2">refs[oldRef] = </span><span class="s1">null;</span>
            <span class="s1">if </span><span class="s2">(shared.hasOwn(setupState</span><span class="s1">, </span><span class="s2">oldRef)) {</span>
                <span class="s2">setupState[oldRef] = </span><span class="s1">null;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(reactivity.isRef(oldRef)) {</span>
            <span class="s2">oldRef.value = </span><span class="s1">null;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(shared.isFunction(ref)) {</span>
        <span class="s2">callWithErrorHandling(ref</span><span class="s1">, </span><span class="s2">owner</span><span class="s1">, </span><span class="s5">12 </span><span class="s6">/* ErrorCodes.FUNCTION_REF */</span><span class="s1">, </span><span class="s2">[value</span><span class="s1">, </span><span class="s2">refs])</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s1">const </span><span class="s2">_isString = shared.isString(ref)</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">_isRef = reactivity.isRef(ref)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(_isString || _isRef) {</span>
            <span class="s1">const </span><span class="s2">doSet = () =&gt; {</span>
                <span class="s1">if </span><span class="s2">(rawRef.f) {</span>
                    <span class="s1">const </span><span class="s2">existing = _isString</span>
                        <span class="s2">? shared.hasOwn(setupState</span><span class="s1">, </span><span class="s2">ref)</span>
                            <span class="s2">? setupState[ref]</span>
                            <span class="s2">: refs[ref]</span>
                        <span class="s2">: ref.value</span><span class="s1">;</span>
                    <span class="s1">if </span><span class="s2">(isUnmount) {</span>
                        <span class="s2">shared.isArray(existing) &amp;&amp; shared.remove(existing</span><span class="s1">, </span><span class="s2">refValue)</span><span class="s1">;</span>
                    <span class="s2">}</span>
                    <span class="s1">else </span><span class="s2">{</span>
                        <span class="s1">if </span><span class="s2">(!shared.isArray(existing)) {</span>
                            <span class="s1">if </span><span class="s2">(_isString) {</span>
                                <span class="s2">refs[ref] = [refValue]</span><span class="s1">;</span>
                                <span class="s1">if </span><span class="s2">(shared.hasOwn(setupState</span><span class="s1">, </span><span class="s2">ref)) {</span>
                                    <span class="s2">setupState[ref] = refs[ref]</span><span class="s1">;</span>
                                <span class="s2">}</span>
                            <span class="s2">}</span>
                            <span class="s1">else </span><span class="s2">{</span>
                                <span class="s2">ref.value = [refValue]</span><span class="s1">;</span>
                                <span class="s1">if </span><span class="s2">(rawRef.k)</span>
                                    <span class="s2">refs[rawRef.k] = ref.value</span><span class="s1">;</span>
                            <span class="s2">}</span>
                        <span class="s2">}</span>
                        <span class="s1">else if </span><span class="s2">(!existing.includes(refValue)) {</span>
                            <span class="s2">existing.push(refValue)</span><span class="s1">;</span>
                        <span class="s2">}</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
                <span class="s1">else if </span><span class="s2">(_isString) {</span>
                    <span class="s2">refs[ref] = value</span><span class="s1">;</span>
                    <span class="s1">if </span><span class="s2">(shared.hasOwn(setupState</span><span class="s1">, </span><span class="s2">ref)) {</span>
                        <span class="s2">setupState[ref] = value</span><span class="s1">;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
                <span class="s1">else if </span><span class="s2">(_isRef) {</span>
                    <span class="s2">ref.value = value</span><span class="s1">;</span>
                    <span class="s1">if </span><span class="s2">(rawRef.k)</span>
                        <span class="s2">refs[rawRef.k] = value</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else ;</span>
            <span class="s2">}</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(value) {</span>
                <span class="s2">doSet.id = -</span><span class="s5">1</span><span class="s1">;</span>
                <span class="s2">queuePostRenderEffect(doSet</span><span class="s1">, </span><span class="s2">parentSuspense)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s2">doSet()</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
<span class="s2">}</span>

<span class="s1">let </span><span class="s2">hasMismatch = </span><span class="s1">false;</span>
<span class="s1">const </span><span class="s2">isSVGContainer = (container) =&gt; </span><span class="s5">/svg/</span><span class="s2">.test(container.namespaceURI) &amp;&amp; container.tagName !== </span><span class="s0">'foreignObject'</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">isComment = (node) =&gt; node.nodeType === </span><span class="s5">8 </span><span class="s6">/* DOMNodeTypes.COMMENT */</span><span class="s1">;</span>
<span class="s6">// Note: hydration is DOM-specific</span>
<span class="s6">// But we have to place it in core due to tight coupling with core - splitting</span>
<span class="s6">// it out creates a ton of unnecessary complexity.</span>
<span class="s6">// Hydration also depends on some renderer internal logic which needs to be</span>
<span class="s6">// passed in via arguments.</span>
<span class="s1">function </span><span class="s2">createHydrationFunctions(rendererInternals) {</span>
    <span class="s1">const </span><span class="s2">{ mt: mountComponent</span><span class="s1">, </span><span class="s2">p: patch</span><span class="s1">, </span><span class="s2">o: { patchProp</span><span class="s1">, </span><span class="s2">createText</span><span class="s1">, </span><span class="s2">nextSibling</span><span class="s1">, </span><span class="s2">parentNode</span><span class="s1">, </span><span class="s2">remove</span><span class="s1">, </span><span class="s2">insert</span><span class="s1">, </span><span class="s2">createComment } } = rendererInternals</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">hydrate = (vnode</span><span class="s1">, </span><span class="s2">container) =&gt; {</span>
        <span class="s1">if </span><span class="s2">(!container.hasChildNodes()) {</span>
            <span class="s2">patch(</span><span class="s1">null, </span><span class="s2">vnode</span><span class="s1">, </span><span class="s2">container)</span><span class="s1">;</span>
            <span class="s2">flushPostFlushCbs()</span><span class="s1">;</span>
            <span class="s2">container._vnode = vnode</span><span class="s1">;</span>
            <span class="s1">return;</span>
        <span class="s2">}</span>
        <span class="s2">hasMismatch = </span><span class="s1">false;</span>
        <span class="s2">hydrateNode(container.firstChild</span><span class="s1">, </span><span class="s2">vnode</span><span class="s1">, null, null, null</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">flushPostFlushCbs()</span><span class="s1">;</span>
        <span class="s2">container._vnode = vnode</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(hasMismatch &amp;&amp; !</span><span class="s1">false</span><span class="s2">) {</span>
            <span class="s6">// this error should show up in production</span>
            <span class="s2">console.error(</span><span class="s0">`Hydration completed but contains mismatches.`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">hydrateNode = (node</span><span class="s1">, </span><span class="s2">vnode</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized = </span><span class="s1">false</span><span class="s2">) =&gt; {</span>
        <span class="s1">const </span><span class="s2">isFragmentStart = isComment(node) &amp;&amp; node.data === </span><span class="s0">'['</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">onMismatch = () =&gt; handleMismatch(node</span><span class="s1">, </span><span class="s2">vnode</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">isFragmentStart)</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">{ type</span><span class="s1">, </span><span class="s2">ref</span><span class="s1">, </span><span class="s2">shapeFlag</span><span class="s1">, </span><span class="s2">patchFlag } = vnode</span><span class="s1">;</span>
        <span class="s1">let </span><span class="s2">domType = node.nodeType</span><span class="s1">;</span>
        <span class="s2">vnode.el = node</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(patchFlag === -</span><span class="s5">2 </span><span class="s6">/* PatchFlags.BAIL */</span><span class="s2">) {</span>
            <span class="s2">optimized = </span><span class="s1">false;</span>
            <span class="s2">vnode.dynamicChildren = </span><span class="s1">null;</span>
        <span class="s2">}</span>
        <span class="s1">let </span><span class="s2">nextNode = </span><span class="s1">null;</span>
        <span class="s1">switch </span><span class="s2">(type) {</span>
            <span class="s1">case </span><span class="s2">Text:</span>
                <span class="s1">if </span><span class="s2">(domType !== </span><span class="s5">3 </span><span class="s6">/* DOMNodeTypes.TEXT */</span><span class="s2">) {</span>
                    <span class="s6">// #5728 empty text node inside a slot can cause hydration failure</span>
                    <span class="s6">// because the server rendered HTML won't contain a text node</span>
                    <span class="s1">if </span><span class="s2">(vnode.children === </span><span class="s0">''</span><span class="s2">) {</span>
                        <span class="s2">insert((vnode.el = createText(</span><span class="s0">''</span><span class="s2">))</span><span class="s1">, </span><span class="s2">parentNode(node)</span><span class="s1">, </span><span class="s2">node)</span><span class="s1">;</span>
                        <span class="s2">nextNode = node</span><span class="s1">;</span>
                    <span class="s2">}</span>
                    <span class="s1">else </span><span class="s2">{</span>
                        <span class="s2">nextNode = onMismatch()</span><span class="s1">;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s1">if </span><span class="s2">(node.data !== vnode.children) {</span>
                        <span class="s2">hasMismatch = </span><span class="s1">true;</span>
                        <span class="s2">node.data = vnode.children</span><span class="s1">;</span>
                    <span class="s2">}</span>
                    <span class="s2">nextNode = nextSibling(node)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">break;</span>
            <span class="s1">case </span><span class="s2">Comment:</span>
                <span class="s1">if </span><span class="s2">(domType !== </span><span class="s5">8 </span><span class="s6">/* DOMNodeTypes.COMMENT */ </span><span class="s2">|| isFragmentStart) {</span>
                    <span class="s2">nextNode = onMismatch()</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s2">nextNode = nextSibling(node)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">break;</span>
            <span class="s1">case </span><span class="s2">Static:</span>
                <span class="s1">if </span><span class="s2">(isFragmentStart) {</span>
                    <span class="s6">// entire template is static but SSRed as a fragment</span>
                    <span class="s2">node = nextSibling(node)</span><span class="s1">;</span>
                    <span class="s2">domType = node.nodeType</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">if </span><span class="s2">(domType === </span><span class="s5">1 </span><span class="s6">/* DOMNodeTypes.ELEMENT */ </span><span class="s2">|| domType === </span><span class="s5">3 </span><span class="s6">/* DOMNodeTypes.TEXT */</span><span class="s2">) {</span>
                    <span class="s6">// determine anchor, adopt content</span>
                    <span class="s2">nextNode = node</span><span class="s1">;</span>
                    <span class="s6">// if the static vnode has its content stripped during build,</span>
                    <span class="s6">// adopt it from the server-rendered HTML.</span>
                    <span class="s1">const </span><span class="s2">needToAdoptContent = !vnode.children.length</span><span class="s1">;</span>
                    <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s5">0</span><span class="s1">; </span><span class="s2">i &lt; vnode.staticCount</span><span class="s1">; </span><span class="s2">i++) {</span>
                        <span class="s1">if </span><span class="s2">(needToAdoptContent)</span>
                            <span class="s2">vnode.children +=</span>
                                <span class="s2">nextNode.nodeType === </span><span class="s5">1 </span><span class="s6">/* DOMNodeTypes.ELEMENT */</span>
                                    <span class="s2">? nextNode.outerHTML</span>
                                    <span class="s2">: nextNode.data</span><span class="s1">;</span>
                        <span class="s1">if </span><span class="s2">(i === vnode.staticCount - </span><span class="s5">1</span><span class="s2">) {</span>
                            <span class="s2">vnode.anchor = nextNode</span><span class="s1">;</span>
                        <span class="s2">}</span>
                        <span class="s2">nextNode = nextSibling(nextNode)</span><span class="s1">;</span>
                    <span class="s2">}</span>
                    <span class="s1">return </span><span class="s2">isFragmentStart ? nextSibling(nextNode) : nextNode</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s2">onMismatch()</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">break;</span>
            <span class="s1">case </span><span class="s2">Fragment:</span>
                <span class="s1">if </span><span class="s2">(!isFragmentStart) {</span>
                    <span class="s2">nextNode = onMismatch()</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s2">nextNode = hydrateFragment(node</span><span class="s1">, </span><span class="s2">vnode</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">break;</span>
            <span class="s1">default</span><span class="s2">:</span>
                <span class="s1">if </span><span class="s2">(shapeFlag &amp; </span><span class="s5">1 </span><span class="s6">/* ShapeFlags.ELEMENT */</span><span class="s2">) {</span>
                    <span class="s1">if </span><span class="s2">(domType !== </span><span class="s5">1 </span><span class="s6">/* DOMNodeTypes.ELEMENT */ </span><span class="s2">||</span>
                        <span class="s2">vnode.type.toLowerCase() !==</span>
                            <span class="s2">node.tagName.toLowerCase()) {</span>
                        <span class="s2">nextNode = onMismatch()</span><span class="s1">;</span>
                    <span class="s2">}</span>
                    <span class="s1">else </span><span class="s2">{</span>
                        <span class="s2">nextNode = hydrateElement(node</span><span class="s1">, </span><span class="s2">vnode</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
                <span class="s1">else if </span><span class="s2">(shapeFlag &amp; </span><span class="s5">6 </span><span class="s6">/* ShapeFlags.COMPONENT */</span><span class="s2">) {</span>
                    <span class="s6">// when setting up the render effect, if the initial vnode already</span>
                    <span class="s6">// has .el set, the component will perform hydration instead of mount</span>
                    <span class="s6">// on its sub-tree.</span>
                    <span class="s2">vnode.slotScopeIds = slotScopeIds</span><span class="s1">;</span>
                    <span class="s1">const </span><span class="s2">container = parentNode(node)</span><span class="s1">;</span>
                    <span class="s2">mountComponent(vnode</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, null, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVGContainer(container)</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
                    <span class="s6">// component may be async, so in the case of fragments we cannot rely</span>
                    <span class="s6">// on component's rendered output to determine the end of the fragment</span>
                    <span class="s6">// instead, we do a lookahead to find the end anchor node.</span>
                    <span class="s2">nextNode = isFragmentStart</span>
                        <span class="s2">? locateClosingAsyncAnchor(node)</span>
                        <span class="s2">: nextSibling(node)</span><span class="s1">;</span>
                    <span class="s6">// #4293 teleport as component root</span>
                    <span class="s1">if </span><span class="s2">(nextNode &amp;&amp;</span>
                        <span class="s2">isComment(nextNode) &amp;&amp;</span>
                        <span class="s2">nextNode.data === </span><span class="s0">'teleport end'</span><span class="s2">) {</span>
                        <span class="s2">nextNode = nextSibling(nextNode)</span><span class="s1">;</span>
                    <span class="s2">}</span>
                    <span class="s6">// #3787</span>
                    <span class="s6">// if component is async, it may get moved / unmounted before its</span>
                    <span class="s6">// inner component is loaded, so we need to give it a placeholder</span>
                    <span class="s6">// vnode that matches its adopted DOM.</span>
                    <span class="s1">if </span><span class="s2">(isAsyncWrapper(vnode)) {</span>
                        <span class="s1">let </span><span class="s2">subTree</span><span class="s1">;</span>
                        <span class="s1">if </span><span class="s2">(isFragmentStart) {</span>
                            <span class="s2">subTree = createVNode(Fragment)</span><span class="s1">;</span>
                            <span class="s2">subTree.anchor = nextNode</span>
                                <span class="s2">? nextNode.previousSibling</span>
                                <span class="s2">: container.lastChild</span><span class="s1">;</span>
                        <span class="s2">}</span>
                        <span class="s1">else </span><span class="s2">{</span>
                            <span class="s2">subTree =</span>
                                <span class="s2">node.nodeType === </span><span class="s5">3 </span><span class="s2">? createTextVNode(</span><span class="s0">''</span><span class="s2">) : createVNode(</span><span class="s0">'div'</span><span class="s2">)</span><span class="s1">;</span>
                        <span class="s2">}</span>
                        <span class="s2">subTree.el = node</span><span class="s1">;</span>
                        <span class="s2">vnode.component.subTree = subTree</span><span class="s1">;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
                <span class="s1">else if </span><span class="s2">(shapeFlag &amp; </span><span class="s5">64 </span><span class="s6">/* ShapeFlags.TELEPORT */</span><span class="s2">) {</span>
                    <span class="s1">if </span><span class="s2">(domType !== </span><span class="s5">8 </span><span class="s6">/* DOMNodeTypes.COMMENT */</span><span class="s2">) {</span>
                        <span class="s2">nextNode = onMismatch()</span><span class="s1">;</span>
                    <span class="s2">}</span>
                    <span class="s1">else </span><span class="s2">{</span>
                        <span class="s2">nextNode = vnode.type.hydrate(node</span><span class="s1">, </span><span class="s2">vnode</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized</span><span class="s1">, </span><span class="s2">rendererInternals</span><span class="s1">, </span><span class="s2">hydrateChildren)</span><span class="s1">;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
                <span class="s1">else if </span><span class="s2">(shapeFlag &amp; </span><span class="s5">128 </span><span class="s6">/* ShapeFlags.SUSPENSE */</span><span class="s2">) {</span>
                    <span class="s2">nextNode = vnode.type.hydrate(node</span><span class="s1">, </span><span class="s2">vnode</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVGContainer(parentNode(node))</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized</span><span class="s1">, </span><span class="s2">rendererInternals</span><span class="s1">, </span><span class="s2">hydrateNode)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else ;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(ref != </span><span class="s1">null</span><span class="s2">) {</span>
            <span class="s2">setRef(ref</span><span class="s1">, null, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">vnode)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">return </span><span class="s2">nextNode</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">hydrateElement = (el</span><span class="s1">, </span><span class="s2">vnode</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized) =&gt; {</span>
        <span class="s2">optimized = optimized || !!vnode.dynamicChildren</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">{ type</span><span class="s1">, </span><span class="s2">props</span><span class="s1">, </span><span class="s2">patchFlag</span><span class="s1">, </span><span class="s2">shapeFlag</span><span class="s1">, </span><span class="s2">dirs } = vnode</span><span class="s1">;</span>
        <span class="s6">// #4006 for form elements with non-string v-model value bindings</span>
        <span class="s6">// e.g. &lt;option :value=&quot;obj&quot;&gt;, &lt;input type=&quot;checkbox&quot; :true-value=&quot;1&quot;&gt;</span>
        <span class="s1">const </span><span class="s2">forcePatchValue = (type === </span><span class="s0">'input' </span><span class="s2">&amp;&amp; dirs) || type === </span><span class="s0">'option'</span><span class="s1">;</span>
        <span class="s6">// skip props &amp; children if this is hoisted static nodes</span>
        <span class="s6">// #5405 in dev, always hydrate children for HMR</span>
        <span class="s1">if </span><span class="s2">(forcePatchValue || patchFlag !== -</span><span class="s5">1 </span><span class="s6">/* PatchFlags.HOISTED */</span><span class="s2">) {</span>
            <span class="s1">if </span><span class="s2">(dirs) {</span>
                <span class="s2">invokeDirectiveHook(vnode</span><span class="s1">, null, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s0">'created'</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s6">// props</span>
            <span class="s1">if </span><span class="s2">(props) {</span>
                <span class="s1">if </span><span class="s2">(forcePatchValue ||</span>
                    <span class="s2">!optimized ||</span>
                    <span class="s2">patchFlag &amp; (</span><span class="s5">16 </span><span class="s6">/* PatchFlags.FULL_PROPS */ </span><span class="s2">| </span><span class="s5">32 </span><span class="s6">/* PatchFlags.HYDRATE_EVENTS */</span><span class="s2">)) {</span>
                    <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">key </span><span class="s1">in </span><span class="s2">props) {</span>
                        <span class="s1">if </span><span class="s2">((forcePatchValue &amp;&amp; key.endsWith(</span><span class="s0">'value'</span><span class="s2">)) ||</span>
                            <span class="s2">(shared.isOn(key) &amp;&amp; !shared.isReservedProp(key))) {</span>
                            <span class="s2">patchProp(el</span><span class="s1">, </span><span class="s2">key</span><span class="s1">, null, </span><span class="s2">props[key]</span><span class="s1">, false, </span><span class="s2">undefined</span><span class="s1">, </span><span class="s2">parentComponent)</span><span class="s1">;</span>
                        <span class="s2">}</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
                <span class="s1">else if </span><span class="s2">(props.onClick) {</span>
                    <span class="s6">// Fast path for click listeners (which is most often) to avoid</span>
                    <span class="s6">// iterating through props.</span>
                    <span class="s2">patchProp(el</span><span class="s1">, </span><span class="s0">'onClick'</span><span class="s1">, null, </span><span class="s2">props.onClick</span><span class="s1">, false, </span><span class="s2">undefined</span><span class="s1">, </span><span class="s2">parentComponent)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s6">// vnode / directive hooks</span>
            <span class="s1">let </span><span class="s2">vnodeHooks</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">((vnodeHooks = props &amp;&amp; props.onVnodeBeforeMount)) {</span>
                <span class="s2">invokeVNodeHook(vnodeHooks</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">vnode)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">if </span><span class="s2">(dirs) {</span>
                <span class="s2">invokeDirectiveHook(vnode</span><span class="s1">, null, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s0">'beforeMount'</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">if </span><span class="s2">((vnodeHooks = props &amp;&amp; props.onVnodeMounted) || dirs) {</span>
                <span class="s2">queueEffectWithSuspense(() =&gt; {</span>
                    <span class="s2">vnodeHooks &amp;&amp; invokeVNodeHook(vnodeHooks</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">vnode)</span><span class="s1">;</span>
                    <span class="s2">dirs &amp;&amp; invokeDirectiveHook(vnode</span><span class="s1">, null, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s0">'mounted'</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s2">}</span><span class="s1">, </span><span class="s2">parentSuspense)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s6">// children</span>
            <span class="s1">if </span><span class="s2">(shapeFlag &amp; </span><span class="s5">16 </span><span class="s6">/* ShapeFlags.ARRAY_CHILDREN */ </span><span class="s2">&amp;&amp;</span>
                <span class="s6">// skip if element has innerHTML / textContent</span>
                <span class="s2">!(props &amp;&amp; (props.innerHTML || props.textContent))) {</span>
                <span class="s1">let </span><span class="s2">next = hydrateChildren(el.firstChild</span><span class="s1">, </span><span class="s2">vnode</span><span class="s1">, </span><span class="s2">el</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
                <span class="s1">while </span><span class="s2">(next) {</span>
                    <span class="s2">hasMismatch = </span><span class="s1">true;</span>
                    <span class="s6">// The SSRed DOM contains more nodes than it should. Remove them.</span>
                    <span class="s1">const </span><span class="s2">cur = next</span><span class="s1">;</span>
                    <span class="s2">next = next.nextSibling</span><span class="s1">;</span>
                    <span class="s2">remove(cur)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(shapeFlag &amp; </span><span class="s5">8 </span><span class="s6">/* ShapeFlags.TEXT_CHILDREN */</span><span class="s2">) {</span>
                <span class="s1">if </span><span class="s2">(el.textContent !== vnode.children) {</span>
                    <span class="s2">hasMismatch = </span><span class="s1">true;</span>
                    <span class="s2">el.textContent = vnode.children</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">return </span><span class="s2">el.nextSibling</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">hydrateChildren = (node</span><span class="s1">, </span><span class="s2">parentVNode</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized) =&gt; {</span>
        <span class="s2">optimized = optimized || !!parentVNode.dynamicChildren</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">children = parentVNode.children</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">l = children.length</span><span class="s1">;</span>
        <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s5">0</span><span class="s1">; </span><span class="s2">i &lt; l</span><span class="s1">; </span><span class="s2">i++) {</span>
            <span class="s1">const </span><span class="s2">vnode = optimized</span>
                <span class="s2">? children[i]</span>
                <span class="s2">: (children[i] = normalizeVNode(children[i]))</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(node) {</span>
                <span class="s2">node = hydrateNode(node</span><span class="s1">, </span><span class="s2">vnode</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(vnode.type === Text &amp;&amp; !vnode.children) {</span>
                <span class="s1">continue;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s2">hasMismatch = </span><span class="s1">true;</span>
                <span class="s6">// the SSRed DOM didn't contain enough nodes. Mount the missing ones.</span>
                <span class="s2">patch(</span><span class="s1">null, </span><span class="s2">vnode</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, null, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVGContainer(container)</span><span class="s1">, </span><span class="s2">slotScopeIds)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">return </span><span class="s2">node</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">hydrateFragment = (node</span><span class="s1">, </span><span class="s2">vnode</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized) =&gt; {</span>
        <span class="s1">const </span><span class="s2">{ slotScopeIds: fragmentSlotScopeIds } = vnode</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(fragmentSlotScopeIds) {</span>
            <span class="s2">slotScopeIds = slotScopeIds</span>
                <span class="s2">? slotScopeIds.concat(fragmentSlotScopeIds)</span>
                <span class="s2">: fragmentSlotScopeIds</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">const </span><span class="s2">container = parentNode(node)</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">next = hydrateChildren(nextSibling(node)</span><span class="s1">, </span><span class="s2">vnode</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(next &amp;&amp; isComment(next) &amp;&amp; next.data === </span><span class="s0">']'</span><span class="s2">) {</span>
            <span class="s1">return </span><span class="s2">nextSibling((vnode.anchor = next))</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s6">// fragment didn't hydrate successfully, since we didn't get a end anchor</span>
            <span class="s6">// back. This should have led to node/children mismatch warnings.</span>
            <span class="s2">hasMismatch = </span><span class="s1">true;</span>
            <span class="s6">// since the anchor is missing, we need to create one and insert it</span>
            <span class="s2">insert((vnode.anchor = createComment(</span><span class="s0">`]`</span><span class="s2">))</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">next)</span><span class="s1">;</span>
            <span class="s1">return </span><span class="s2">next</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">handleMismatch = (node</span><span class="s1">, </span><span class="s2">vnode</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">isFragment) =&gt; {</span>
        <span class="s2">hasMismatch = </span><span class="s1">true;</span>
        <span class="s2">vnode.el = </span><span class="s1">null;</span>
        <span class="s1">if </span><span class="s2">(isFragment) {</span>
            <span class="s6">// remove excessive fragment nodes</span>
            <span class="s1">const </span><span class="s2">end = locateClosingAsyncAnchor(node)</span><span class="s1">;</span>
            <span class="s1">while </span><span class="s2">(</span><span class="s1">true</span><span class="s2">) {</span>
                <span class="s1">const </span><span class="s2">next = nextSibling(node)</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(next &amp;&amp; next !== end) {</span>
                    <span class="s2">remove(next)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s1">break;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">const </span><span class="s2">next = nextSibling(node)</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">container = parentNode(node)</span><span class="s1">;</span>
        <span class="s2">remove(node)</span><span class="s1">;</span>
        <span class="s2">patch(</span><span class="s1">null, </span><span class="s2">vnode</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">next</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVGContainer(container)</span><span class="s1">, </span><span class="s2">slotScopeIds)</span><span class="s1">;</span>
        <span class="s1">return </span><span class="s2">next</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">locateClosingAsyncAnchor = (node) =&gt; {</span>
        <span class="s1">let </span><span class="s2">match = </span><span class="s5">0</span><span class="s1">;</span>
        <span class="s1">while </span><span class="s2">(node) {</span>
            <span class="s2">node = nextSibling(node)</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(node &amp;&amp; isComment(node)) {</span>
                <span class="s1">if </span><span class="s2">(node.data === </span><span class="s0">'['</span><span class="s2">)</span>
                    <span class="s2">match++</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(node.data === </span><span class="s0">']'</span><span class="s2">) {</span>
                    <span class="s1">if </span><span class="s2">(match === </span><span class="s5">0</span><span class="s2">) {</span>
                        <span class="s1">return </span><span class="s2">nextSibling(node)</span><span class="s1">;</span>
                    <span class="s2">}</span>
                    <span class="s1">else </span><span class="s2">{</span>
                        <span class="s2">match--</span><span class="s1">;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">return </span><span class="s2">node</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">[hydrate</span><span class="s1">, </span><span class="s2">hydrateNode]</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s1">const </span><span class="s2">queuePostRenderEffect = queueEffectWithSuspense</span>
    <span class="s1">;</span>
<span class="s3">/**</span>
 <span class="s3">* The createRenderer function accepts two generic arguments:</span>
 <span class="s3">* HostNode and HostElement, corresponding to Node and Element types in the</span>
 <span class="s3">* host environment. For example, for runtime-dom, HostNode would be the DOM</span>
 <span class="s3">* `Node` interface and HostElement would be the DOM `Element` interface.</span>
 <span class="s3">*</span>
 <span class="s3">* Custom renderers can pass in the platform specific types like this:</span>
 <span class="s3">*</span>
 <span class="s3">* ``` js</span>
 <span class="s3">* const { render, createApp } = createRenderer&lt;Node, Element&gt;({</span>
 <span class="s3">*   patchProp,</span>
 <span class="s3">*   ...nodeOps</span>
 <span class="s3">* })</span>
 <span class="s3">* ```</span>
 <span class="s3">*/</span>
<span class="s1">function </span><span class="s2">createRenderer(options) {</span>
    <span class="s1">return </span><span class="s2">baseCreateRenderer(options)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s6">// Separate API for creating hydration-enabled renderer.</span>
<span class="s6">// Hydration logic is only used when calling this function, making it</span>
<span class="s6">// tree-shakable.</span>
<span class="s1">function </span><span class="s2">createHydrationRenderer(options) {</span>
    <span class="s1">return </span><span class="s2">baseCreateRenderer(options</span><span class="s1">, </span><span class="s2">createHydrationFunctions)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s6">// implementation</span>
<span class="s1">function </span><span class="s2">baseCreateRenderer(options</span><span class="s1">, </span><span class="s2">createHydrationFns) {</span>
    <span class="s1">const </span><span class="s2">target = shared.getGlobalThis()</span><span class="s1">;</span>
    <span class="s2">target.__VUE__ = </span><span class="s1">true;</span>
    <span class="s1">const </span><span class="s2">{ insert: hostInsert</span><span class="s1">, </span><span class="s2">remove: hostRemove</span><span class="s1">, </span><span class="s2">patchProp: hostPatchProp</span><span class="s1">, </span><span class="s2">createElement: hostCreateElement</span><span class="s1">, </span><span class="s2">createText: hostCreateText</span><span class="s1">, </span><span class="s2">createComment: hostCreateComment</span><span class="s1">, </span><span class="s2">setText: hostSetText</span><span class="s1">, </span><span class="s2">setElementText: hostSetElementText</span><span class="s1">, </span><span class="s2">parentNode: hostParentNode</span><span class="s1">, </span><span class="s2">nextSibling: hostNextSibling</span><span class="s1">, </span><span class="s2">setScopeId: hostSetScopeId = shared.NOOP</span><span class="s1">, </span><span class="s2">insertStaticContent: hostInsertStaticContent } = options</span><span class="s1">;</span>
    <span class="s6">// Note: functions inside this closure should use `const xxx = () =&gt; {}`</span>
    <span class="s6">// style in order to prevent being inlined by minifiers.</span>
    <span class="s1">const </span><span class="s2">patch = (n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor = </span><span class="s1">null, </span><span class="s2">parentComponent = </span><span class="s1">null, </span><span class="s2">parentSuspense = </span><span class="s1">null, </span><span class="s2">isSVG = </span><span class="s1">false, </span><span class="s2">slotScopeIds = </span><span class="s1">null, </span><span class="s2">optimized = !!n2.dynamicChildren) =&gt; {</span>
        <span class="s1">if </span><span class="s2">(n1 === n2) {</span>
            <span class="s1">return;</span>
        <span class="s2">}</span>
        <span class="s6">// patching &amp; not same type, unmount old tree</span>
        <span class="s1">if </span><span class="s2">(n1 &amp;&amp; !isSameVNodeType(n1</span><span class="s1">, </span><span class="s2">n2)) {</span>
            <span class="s2">anchor = getNextHostNode(n1)</span><span class="s1">;</span>
            <span class="s2">unmount(n1</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, true</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">n1 = </span><span class="s1">null;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(n2.patchFlag === -</span><span class="s5">2 </span><span class="s6">/* PatchFlags.BAIL */</span><span class="s2">) {</span>
            <span class="s2">optimized = </span><span class="s1">false;</span>
            <span class="s2">n2.dynamicChildren = </span><span class="s1">null;</span>
        <span class="s2">}</span>
        <span class="s1">const </span><span class="s2">{ type</span><span class="s1">, </span><span class="s2">ref</span><span class="s1">, </span><span class="s2">shapeFlag } = n2</span><span class="s1">;</span>
        <span class="s1">switch </span><span class="s2">(type) {</span>
            <span class="s1">case </span><span class="s2">Text:</span>
                <span class="s2">processText(n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor)</span><span class="s1">;</span>
                <span class="s1">break;</span>
            <span class="s1">case </span><span class="s2">Comment:</span>
                <span class="s2">processCommentNode(n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor)</span><span class="s1">;</span>
                <span class="s1">break;</span>
            <span class="s1">case </span><span class="s2">Static:</span>
                <span class="s1">if </span><span class="s2">(n1 == </span><span class="s1">null</span><span class="s2">) {</span>
                    <span class="s2">mountStaticNode(n2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">isSVG)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">break;</span>
            <span class="s1">case </span><span class="s2">Fragment:</span>
                <span class="s2">processFragment(n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
                <span class="s1">break;</span>
            <span class="s1">default</span><span class="s2">:</span>
                <span class="s1">if </span><span class="s2">(shapeFlag &amp; </span><span class="s5">1 </span><span class="s6">/* ShapeFlags.ELEMENT */</span><span class="s2">) {</span>
                    <span class="s2">processElement(n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else if </span><span class="s2">(shapeFlag &amp; </span><span class="s5">6 </span><span class="s6">/* ShapeFlags.COMPONENT */</span><span class="s2">) {</span>
                    <span class="s2">processComponent(n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else if </span><span class="s2">(shapeFlag &amp; </span><span class="s5">64 </span><span class="s6">/* ShapeFlags.TELEPORT */</span><span class="s2">) {</span>
                    <span class="s2">type.process(n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized</span><span class="s1">, </span><span class="s2">internals)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else if </span><span class="s2">(shapeFlag &amp; </span><span class="s5">128 </span><span class="s6">/* ShapeFlags.SUSPENSE */</span><span class="s2">) {</span>
                    <span class="s2">type.process(n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized</span><span class="s1">, </span><span class="s2">internals)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else ;</span>
        <span class="s2">}</span>
        <span class="s6">// set ref</span>
        <span class="s1">if </span><span class="s2">(ref != </span><span class="s1">null </span><span class="s2">&amp;&amp; parentComponent) {</span>
            <span class="s2">setRef(ref</span><span class="s1">, </span><span class="s2">n1 &amp;&amp; n1.ref</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">n2 || n1</span><span class="s1">, </span><span class="s2">!n2)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">processText = (n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor) =&gt; {</span>
        <span class="s1">if </span><span class="s2">(n1 == </span><span class="s1">null</span><span class="s2">) {</span>
            <span class="s2">hostInsert((n2.el = hostCreateText(n2.children))</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s1">const </span><span class="s2">el = (n2.el = n1.el)</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(n2.children !== n1.children) {</span>
                <span class="s2">hostSetText(el</span><span class="s1">, </span><span class="s2">n2.children)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">processCommentNode = (n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor) =&gt; {</span>
        <span class="s1">if </span><span class="s2">(n1 == </span><span class="s1">null</span><span class="s2">) {</span>
            <span class="s2">hostInsert((n2.el = hostCreateComment(n2.children || </span><span class="s0">''</span><span class="s2">))</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s6">// there's no support for dynamic comments</span>
            <span class="s2">n2.el = n1.el</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">mountStaticNode = (n2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">isSVG) =&gt; {</span>
        <span class="s2">[n2.el</span><span class="s1">, </span><span class="s2">n2.anchor] = hostInsertStaticContent(n2.children</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">n2.el</span><span class="s1">, </span><span class="s2">n2.anchor)</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">moveStaticNode = ({ el</span><span class="s1">, </span><span class="s2">anchor }</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">nextSibling) =&gt; {</span>
        <span class="s1">let </span><span class="s2">next</span><span class="s1">;</span>
        <span class="s1">while </span><span class="s2">(el &amp;&amp; el !== anchor) {</span>
            <span class="s2">next = hostNextSibling(el)</span><span class="s1">;</span>
            <span class="s2">hostInsert(el</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">nextSibling)</span><span class="s1">;</span>
            <span class="s2">el = next</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s2">hostInsert(anchor</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">nextSibling)</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">removeStaticNode = ({ el</span><span class="s1">, </span><span class="s2">anchor }) =&gt; {</span>
        <span class="s1">let </span><span class="s2">next</span><span class="s1">;</span>
        <span class="s1">while </span><span class="s2">(el &amp;&amp; el !== anchor) {</span>
            <span class="s2">next = hostNextSibling(el)</span><span class="s1">;</span>
            <span class="s2">hostRemove(el)</span><span class="s1">;</span>
            <span class="s2">el = next</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s2">hostRemove(anchor)</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">processElement = (n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized) =&gt; {</span>
        <span class="s2">isSVG = isSVG || n2.type === </span><span class="s0">'svg'</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(n1 == </span><span class="s1">null</span><span class="s2">) {</span>
            <span class="s2">mountElement(n2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">patchElement(n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">mountElement = (vnode</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized) =&gt; {</span>
        <span class="s1">let </span><span class="s2">el</span><span class="s1">;</span>
        <span class="s1">let </span><span class="s2">vnodeHook</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">{ type</span><span class="s1">, </span><span class="s2">props</span><span class="s1">, </span><span class="s2">shapeFlag</span><span class="s1">, </span><span class="s2">transition</span><span class="s1">, </span><span class="s2">dirs } = vnode</span><span class="s1">;</span>
        <span class="s2">el = vnode.el = hostCreateElement(vnode.type</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">props &amp;&amp; props.is</span><span class="s1">, </span><span class="s2">props)</span><span class="s1">;</span>
        <span class="s6">// mount children first, since some props may rely on child content</span>
        <span class="s6">// being already rendered, e.g. `&lt;select value&gt;`</span>
        <span class="s1">if </span><span class="s2">(shapeFlag &amp; </span><span class="s5">8 </span><span class="s6">/* ShapeFlags.TEXT_CHILDREN */</span><span class="s2">) {</span>
            <span class="s2">hostSetElementText(el</span><span class="s1">, </span><span class="s2">vnode.children)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(shapeFlag &amp; </span><span class="s5">16 </span><span class="s6">/* ShapeFlags.ARRAY_CHILDREN */</span><span class="s2">) {</span>
            <span class="s2">mountChildren(vnode.children</span><span class="s1">, </span><span class="s2">el</span><span class="s1">, null, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG &amp;&amp; type !== </span><span class="s0">'foreignObject'</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(dirs) {</span>
            <span class="s2">invokeDirectiveHook(vnode</span><span class="s1">, null, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s0">'created'</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s6">// scopeId</span>
        <span class="s2">setScopeId(el</span><span class="s1">, </span><span class="s2">vnode</span><span class="s1">, </span><span class="s2">vnode.scopeId</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">parentComponent)</span><span class="s1">;</span>
        <span class="s6">// props</span>
        <span class="s1">if </span><span class="s2">(props) {</span>
            <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">key </span><span class="s1">in </span><span class="s2">props) {</span>
                <span class="s1">if </span><span class="s2">(key !== </span><span class="s0">'value' </span><span class="s2">&amp;&amp; !shared.isReservedProp(key)) {</span>
                    <span class="s2">hostPatchProp(el</span><span class="s1">, </span><span class="s2">key</span><span class="s1">, null, </span><span class="s2">props[key]</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">vnode.children</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">unmountChildren)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s3">/**</span>
             <span class="s3">* Special case for setting value on DOM elements:</span>
             <span class="s3">* - it can be order-sensitive (e.g. should be set *after* min/max, #2325, #4024)</span>
             <span class="s3">* - it needs to be forced (#1471)</span>
             <span class="s3">* #2353 proposes adding another renderer option to configure this, but</span>
             <span class="s3">* the properties affects are so finite it is worth special casing it</span>
             <span class="s3">* here to reduce the complexity. (Special casing it also should not</span>
             <span class="s3">* affect non-DOM renderers)</span>
             <span class="s3">*/</span>
            <span class="s1">if </span><span class="s2">(</span><span class="s0">'value' </span><span class="s1">in </span><span class="s2">props) {</span>
                <span class="s2">hostPatchProp(el</span><span class="s1">, </span><span class="s0">'value'</span><span class="s1">, null, </span><span class="s2">props.value)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">if </span><span class="s2">((vnodeHook = props.onVnodeBeforeMount)) {</span>
                <span class="s2">invokeVNodeHook(vnodeHook</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">vnode)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(dirs) {</span>
            <span class="s2">invokeDirectiveHook(vnode</span><span class="s1">, null, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s0">'beforeMount'</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s6">// #1583 For inside suspense + suspense not resolved case, enter hook should call when suspense resolved</span>
        <span class="s6">// #1689 For inside suspense + suspense resolved case, just call it</span>
        <span class="s1">const </span><span class="s2">needCallTransitionHooks = (!parentSuspense || (parentSuspense &amp;&amp; !parentSuspense.pendingBranch)) &amp;&amp;</span>
            <span class="s2">transition &amp;&amp;</span>
            <span class="s2">!transition.persisted</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(needCallTransitionHooks) {</span>
            <span class="s2">transition.beforeEnter(el)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s2">hostInsert(el</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">((vnodeHook = props &amp;&amp; props.onVnodeMounted) ||</span>
            <span class="s2">needCallTransitionHooks ||</span>
            <span class="s2">dirs) {</span>
            <span class="s2">queuePostRenderEffect(() =&gt; {</span>
                <span class="s2">vnodeHook &amp;&amp; invokeVNodeHook(vnodeHook</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">vnode)</span><span class="s1">;</span>
                <span class="s2">needCallTransitionHooks &amp;&amp; transition.enter(el)</span><span class="s1">;</span>
                <span class="s2">dirs &amp;&amp; invokeDirectiveHook(vnode</span><span class="s1">, null, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s0">'mounted'</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span><span class="s1">, </span><span class="s2">parentSuspense)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">setScopeId = (el</span><span class="s1">, </span><span class="s2">vnode</span><span class="s1">, </span><span class="s2">scopeId</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">parentComponent) =&gt; {</span>
        <span class="s1">if </span><span class="s2">(scopeId) {</span>
            <span class="s2">hostSetScopeId(el</span><span class="s1">, </span><span class="s2">scopeId)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(slotScopeIds) {</span>
            <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s5">0</span><span class="s1">; </span><span class="s2">i &lt; slotScopeIds.length</span><span class="s1">; </span><span class="s2">i++) {</span>
                <span class="s2">hostSetScopeId(el</span><span class="s1">, </span><span class="s2">slotScopeIds[i])</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(parentComponent) {</span>
            <span class="s1">let </span><span class="s2">subTree = parentComponent.subTree</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(vnode === subTree) {</span>
                <span class="s1">const </span><span class="s2">parentVNode = parentComponent.vnode</span><span class="s1">;</span>
                <span class="s2">setScopeId(el</span><span class="s1">, </span><span class="s2">parentVNode</span><span class="s1">, </span><span class="s2">parentVNode.scopeId</span><span class="s1">, </span><span class="s2">parentVNode.slotScopeIds</span><span class="s1">, </span><span class="s2">parentComponent.parent)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">mountChildren = (children</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized</span><span class="s1">, </span><span class="s2">start = </span><span class="s5">0</span><span class="s2">) =&gt; {</span>
        <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = start</span><span class="s1">; </span><span class="s2">i &lt; children.length</span><span class="s1">; </span><span class="s2">i++) {</span>
            <span class="s1">const </span><span class="s2">child = (children[i] = optimized</span>
                <span class="s2">? cloneIfMounted(children[i])</span>
                <span class="s2">: normalizeVNode(children[i]))</span><span class="s1">;</span>
            <span class="s2">patch(</span><span class="s1">null, </span><span class="s2">child</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">patchElement = (n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized) =&gt; {</span>
        <span class="s1">const </span><span class="s2">el = (n2.el = n1.el)</span><span class="s1">;</span>
        <span class="s1">let </span><span class="s2">{ patchFlag</span><span class="s1">, </span><span class="s2">dynamicChildren</span><span class="s1">, </span><span class="s2">dirs } = n2</span><span class="s1">;</span>
        <span class="s6">// #1426 take the old vnode's patch flag into account since user may clone a</span>
        <span class="s6">// compiler-generated vnode, which de-opts to FULL_PROPS</span>
        <span class="s2">patchFlag |= n1.patchFlag &amp; </span><span class="s5">16 </span><span class="s6">/* PatchFlags.FULL_PROPS */</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">oldProps = n1.props || shared.EMPTY_OBJ</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">newProps = n2.props || shared.EMPTY_OBJ</span><span class="s1">;</span>
        <span class="s1">let </span><span class="s2">vnodeHook</span><span class="s1">;</span>
        <span class="s6">// disable recurse in beforeUpdate hooks</span>
        <span class="s2">parentComponent &amp;&amp; toggleRecurse(parentComponent</span><span class="s1">, false</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">((vnodeHook = newProps.onVnodeBeforeUpdate)) {</span>
            <span class="s2">invokeVNodeHook(vnodeHook</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">n1)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(dirs) {</span>
            <span class="s2">invokeDirectiveHook(n2</span><span class="s1">, </span><span class="s2">n1</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s0">'beforeUpdate'</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s2">parentComponent &amp;&amp; toggleRecurse(parentComponent</span><span class="s1">, true</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">areChildrenSVG = isSVG &amp;&amp; n2.type !== </span><span class="s0">'foreignObject'</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(dynamicChildren) {</span>
            <span class="s2">patchBlockChildren(n1.dynamicChildren</span><span class="s1">, </span><span class="s2">dynamicChildren</span><span class="s1">, </span><span class="s2">el</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">areChildrenSVG</span><span class="s1">, </span><span class="s2">slotScopeIds)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(!optimized) {</span>
            <span class="s6">// full diff</span>
            <span class="s2">patchChildren(n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">el</span><span class="s1">, null, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">areChildrenSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, false</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(patchFlag &gt; </span><span class="s5">0</span><span class="s2">) {</span>
            <span class="s6">// the presence of a patchFlag means this element's render code was</span>
            <span class="s6">// generated by the compiler and can take the fast path.</span>
            <span class="s6">// in this path old node and new node are guaranteed to have the same shape</span>
            <span class="s6">// (i.e. at the exact same position in the source template)</span>
            <span class="s1">if </span><span class="s2">(patchFlag &amp; </span><span class="s5">16 </span><span class="s6">/* PatchFlags.FULL_PROPS */</span><span class="s2">) {</span>
                <span class="s6">// element props contain dynamic keys, full diff needed</span>
                <span class="s2">patchProps(el</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">oldProps</span><span class="s1">, </span><span class="s2">newProps</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s6">// class</span>
                <span class="s6">// this flag is matched when the element has dynamic class bindings.</span>
                <span class="s1">if </span><span class="s2">(patchFlag &amp; </span><span class="s5">2 </span><span class="s6">/* PatchFlags.CLASS */</span><span class="s2">) {</span>
                    <span class="s1">if </span><span class="s2">(oldProps.class !== newProps.class) {</span>
                        <span class="s2">hostPatchProp(el</span><span class="s1">, </span><span class="s0">'class'</span><span class="s1">, null, </span><span class="s2">newProps.class</span><span class="s1">, </span><span class="s2">isSVG)</span><span class="s1">;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
                <span class="s6">// style</span>
                <span class="s6">// this flag is matched when the element has dynamic style bindings</span>
                <span class="s1">if </span><span class="s2">(patchFlag &amp; </span><span class="s5">4 </span><span class="s6">/* PatchFlags.STYLE */</span><span class="s2">) {</span>
                    <span class="s2">hostPatchProp(el</span><span class="s1">, </span><span class="s0">'style'</span><span class="s1">, </span><span class="s2">oldProps.style</span><span class="s1">, </span><span class="s2">newProps.style</span><span class="s1">, </span><span class="s2">isSVG)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s6">// props</span>
                <span class="s6">// This flag is matched when the element has dynamic prop/attr bindings</span>
                <span class="s6">// other than class and style. The keys of dynamic prop/attrs are saved for</span>
                <span class="s6">// faster iteration.</span>
                <span class="s6">// Note dynamic keys like :[foo]=&quot;bar&quot; will cause this optimization to</span>
                <span class="s6">// bail out and go through a full diff because we need to unset the old key</span>
                <span class="s1">if </span><span class="s2">(patchFlag &amp; </span><span class="s5">8 </span><span class="s6">/* PatchFlags.PROPS */</span><span class="s2">) {</span>
                    <span class="s6">// if the flag is present then dynamicProps must be non-null</span>
                    <span class="s1">const </span><span class="s2">propsToUpdate = n2.dynamicProps</span><span class="s1">;</span>
                    <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s5">0</span><span class="s1">; </span><span class="s2">i &lt; propsToUpdate.length</span><span class="s1">; </span><span class="s2">i++) {</span>
                        <span class="s1">const </span><span class="s2">key = propsToUpdate[i]</span><span class="s1">;</span>
                        <span class="s1">const </span><span class="s2">prev = oldProps[key]</span><span class="s1">;</span>
                        <span class="s1">const </span><span class="s2">next = newProps[key]</span><span class="s1">;</span>
                        <span class="s6">// #1471 force patch value</span>
                        <span class="s1">if </span><span class="s2">(next !== prev || key === </span><span class="s0">'value'</span><span class="s2">) {</span>
                            <span class="s2">hostPatchProp(el</span><span class="s1">, </span><span class="s2">key</span><span class="s1">, </span><span class="s2">prev</span><span class="s1">, </span><span class="s2">next</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">n1.children</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">unmountChildren)</span><span class="s1">;</span>
                        <span class="s2">}</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s6">// text</span>
            <span class="s6">// This flag is matched when the element has only dynamic text children.</span>
            <span class="s1">if </span><span class="s2">(patchFlag &amp; </span><span class="s5">1 </span><span class="s6">/* PatchFlags.TEXT */</span><span class="s2">) {</span>
                <span class="s1">if </span><span class="s2">(n1.children !== n2.children) {</span>
                    <span class="s2">hostSetElementText(el</span><span class="s1">, </span><span class="s2">n2.children)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(!optimized &amp;&amp; dynamicChildren == </span><span class="s1">null</span><span class="s2">) {</span>
            <span class="s6">// unoptimized, full diff</span>
            <span class="s2">patchProps(el</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">oldProps</span><span class="s1">, </span><span class="s2">newProps</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">((vnodeHook = newProps.onVnodeUpdated) || dirs) {</span>
            <span class="s2">queuePostRenderEffect(() =&gt; {</span>
                <span class="s2">vnodeHook &amp;&amp; invokeVNodeHook(vnodeHook</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">n1)</span><span class="s1">;</span>
                <span class="s2">dirs &amp;&amp; invokeDirectiveHook(n2</span><span class="s1">, </span><span class="s2">n1</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s0">'updated'</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span><span class="s1">, </span><span class="s2">parentSuspense)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s6">// The fast path for blocks.</span>
    <span class="s1">const </span><span class="s2">patchBlockChildren = (oldChildren</span><span class="s1">, </span><span class="s2">newChildren</span><span class="s1">, </span><span class="s2">fallbackContainer</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds) =&gt; {</span>
        <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s5">0</span><span class="s1">; </span><span class="s2">i &lt; newChildren.length</span><span class="s1">; </span><span class="s2">i++) {</span>
            <span class="s1">const </span><span class="s2">oldVNode = oldChildren[i]</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">newVNode = newChildren[i]</span><span class="s1">;</span>
            <span class="s6">// Determine the container (parent element) for the patch.</span>
            <span class="s1">const </span><span class="s2">container = </span>
            <span class="s6">// oldVNode may be an errored async setup() component inside Suspense</span>
            <span class="s6">// which will not have a mounted element</span>
            <span class="s2">oldVNode.el &amp;&amp;</span>
                <span class="s6">// - In the case of a Fragment, we need to provide the actual parent</span>
                <span class="s6">// of the Fragment itself so it can move its children.</span>
                <span class="s2">(oldVNode.type === Fragment ||</span>
                    <span class="s6">// - In the case of different nodes, there is going to be a replacement</span>
                    <span class="s6">// which also requires the correct parent container</span>
                    <span class="s2">!isSameVNodeType(oldVNode</span><span class="s1">, </span><span class="s2">newVNode) ||</span>
                    <span class="s6">// - In the case of a component, it could contain anything.</span>
                    <span class="s2">oldVNode.shapeFlag &amp; (</span><span class="s5">6 </span><span class="s6">/* ShapeFlags.COMPONENT */ </span><span class="s2">| </span><span class="s5">64 </span><span class="s6">/* ShapeFlags.TELEPORT */</span><span class="s2">))</span>
                <span class="s2">? hostParentNode(oldVNode.el)</span>
                <span class="s2">: </span><span class="s6">// In other cases, the parent container is not actually used so we</span>
                    <span class="s6">// just pass the block element here to avoid a DOM parentNode call.</span>
                    <span class="s2">fallbackContainer</span><span class="s1">;</span>
            <span class="s2">patch(oldVNode</span><span class="s1">, </span><span class="s2">newVNode</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, null, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, true</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">patchProps = (el</span><span class="s1">, </span><span class="s2">vnode</span><span class="s1">, </span><span class="s2">oldProps</span><span class="s1">, </span><span class="s2">newProps</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG) =&gt; {</span>
        <span class="s1">if </span><span class="s2">(oldProps !== newProps) {</span>
            <span class="s1">if </span><span class="s2">(oldProps !== shared.EMPTY_OBJ) {</span>
                <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">key </span><span class="s1">in </span><span class="s2">oldProps) {</span>
                    <span class="s1">if </span><span class="s2">(!shared.isReservedProp(key) &amp;&amp; !(key </span><span class="s1">in </span><span class="s2">newProps)) {</span>
                        <span class="s2">hostPatchProp(el</span><span class="s1">, </span><span class="s2">key</span><span class="s1">, </span><span class="s2">oldProps[key]</span><span class="s1">, null, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">vnode.children</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">unmountChildren)</span><span class="s1">;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">key </span><span class="s1">in </span><span class="s2">newProps) {</span>
                <span class="s6">// empty string is not valid prop</span>
                <span class="s1">if </span><span class="s2">(shared.isReservedProp(key))</span>
                    <span class="s1">continue;</span>
                <span class="s1">const </span><span class="s2">next = newProps[key]</span><span class="s1">;</span>
                <span class="s1">const </span><span class="s2">prev = oldProps[key]</span><span class="s1">;</span>
                <span class="s6">// defer patching value</span>
                <span class="s1">if </span><span class="s2">(next !== prev &amp;&amp; key !== </span><span class="s0">'value'</span><span class="s2">) {</span>
                    <span class="s2">hostPatchProp(el</span><span class="s1">, </span><span class="s2">key</span><span class="s1">, </span><span class="s2">prev</span><span class="s1">, </span><span class="s2">next</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">vnode.children</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">unmountChildren)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s1">if </span><span class="s2">(</span><span class="s0">'value' </span><span class="s1">in </span><span class="s2">newProps) {</span>
                <span class="s2">hostPatchProp(el</span><span class="s1">, </span><span class="s0">'value'</span><span class="s1">, </span><span class="s2">oldProps.value</span><span class="s1">, </span><span class="s2">newProps.value)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">processFragment = (n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized) =&gt; {</span>
        <span class="s1">const </span><span class="s2">fragmentStartAnchor = (n2.el = n1 ? n1.el : hostCreateText(</span><span class="s0">''</span><span class="s2">))</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">fragmentEndAnchor = (n2.anchor = n1 ? n1.anchor : hostCreateText(</span><span class="s0">''</span><span class="s2">))</span><span class="s1">;</span>
        <span class="s1">let </span><span class="s2">{ patchFlag</span><span class="s1">, </span><span class="s2">dynamicChildren</span><span class="s1">, </span><span class="s2">slotScopeIds: fragmentSlotScopeIds } = n2</span><span class="s1">;</span>
        <span class="s6">// check if this is a slot fragment with :slotted scope ids</span>
        <span class="s1">if </span><span class="s2">(fragmentSlotScopeIds) {</span>
            <span class="s2">slotScopeIds = slotScopeIds</span>
                <span class="s2">? slotScopeIds.concat(fragmentSlotScopeIds)</span>
                <span class="s2">: fragmentSlotScopeIds</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(n1 == </span><span class="s1">null</span><span class="s2">) {</span>
            <span class="s2">hostInsert(fragmentStartAnchor</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor)</span><span class="s1">;</span>
            <span class="s2">hostInsert(fragmentEndAnchor</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor)</span><span class="s1">;</span>
            <span class="s6">// a fragment can only have array children</span>
            <span class="s6">// since they are either generated by the compiler, or implicitly created</span>
            <span class="s6">// from arrays.</span>
            <span class="s2">mountChildren(n2.children</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">fragmentEndAnchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s1">if </span><span class="s2">(patchFlag &gt; </span><span class="s5">0 </span><span class="s2">&amp;&amp;</span>
                <span class="s2">patchFlag &amp; </span><span class="s5">64 </span><span class="s6">/* PatchFlags.STABLE_FRAGMENT */ </span><span class="s2">&amp;&amp;</span>
                <span class="s2">dynamicChildren &amp;&amp;</span>
                <span class="s6">// #2715 the previous fragment could've been a BAILed one as a result</span>
                <span class="s6">// of renderSlot() with no valid children</span>
                <span class="s2">n1.dynamicChildren) {</span>
                <span class="s6">// a stable fragment (template root or &lt;template v-for&gt;) doesn't need to</span>
                <span class="s6">// patch children order, but it may contain dynamicChildren.</span>
                <span class="s2">patchBlockChildren(n1.dynamicChildren</span><span class="s1">, </span><span class="s2">dynamicChildren</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds)</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(</span>
                <span class="s6">// #2080 if the stable fragment has a key, it's a &lt;template v-for&gt; that may</span>
                <span class="s6">//  get moved around. Make sure all root level vnodes inherit el.</span>
                <span class="s6">// #2134 or if it's a component root, it may also get moved around</span>
                <span class="s6">// as the component is being moved.</span>
                <span class="s2">n2.key != </span><span class="s1">null </span><span class="s2">||</span>
                    <span class="s2">(parentComponent &amp;&amp; n2 === parentComponent.subTree)) {</span>
                    <span class="s2">traverseStaticChildren(n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, true </span><span class="s6">/* shallow */</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s6">// keyed / unkeyed, or manual fragments.</span>
                <span class="s6">// for keyed &amp; unkeyed, since they are compiler generated from v-for,</span>
                <span class="s6">// each child is guaranteed to be a block so the fragment will never</span>
                <span class="s6">// have dynamicChildren.</span>
                <span class="s2">patchChildren(n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">fragmentEndAnchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">processComponent = (n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized) =&gt; {</span>
        <span class="s2">n2.slotScopeIds = slotScopeIds</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(n1 == </span><span class="s1">null</span><span class="s2">) {</span>
            <span class="s1">if </span><span class="s2">(n2.shapeFlag &amp; </span><span class="s5">512 </span><span class="s6">/* ShapeFlags.COMPONENT_KEPT_ALIVE */</span><span class="s2">) {</span>
                <span class="s2">parentComponent.ctx.activate(n2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s2">mountComponent(n2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">updateComponent(n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">mountComponent = (initialVNode</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">optimized) =&gt; {</span>
        <span class="s1">const </span><span class="s2">instance = (initialVNode.component = createComponentInstance(initialVNode</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense))</span><span class="s1">;</span>
        <span class="s6">// inject renderer internals for keepAlive</span>
        <span class="s1">if </span><span class="s2">(isKeepAlive(initialVNode)) {</span>
            <span class="s2">instance.ctx.renderer = internals</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s6">// resolve props and slots for setup context</span>
        <span class="s2">{</span>
            <span class="s2">setupComponent(instance)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s6">// setup() is async. This component relies on async logic to be resolved</span>
        <span class="s6">// before proceeding</span>
        <span class="s1">if </span><span class="s2">(instance.asyncDep) {</span>
            <span class="s2">parentSuspense &amp;&amp; parentSuspense.registerDep(instance</span><span class="s1">, </span><span class="s2">setupRenderEffect)</span><span class="s1">;</span>
            <span class="s6">// Give it a placeholder if this is not hydration</span>
            <span class="s6">// TODO handle self-defined fallback</span>
            <span class="s1">if </span><span class="s2">(!initialVNode.el) {</span>
                <span class="s1">const </span><span class="s2">placeholder = (instance.subTree = createVNode(Comment))</span><span class="s1">;</span>
                <span class="s2">processCommentNode(</span><span class="s1">null, </span><span class="s2">placeholder</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">return;</span>
        <span class="s2">}</span>
        <span class="s2">setupRenderEffect(instance</span><span class="s1">, </span><span class="s2">initialVNode</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">updateComponent = (n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">optimized) =&gt; {</span>
        <span class="s1">const </span><span class="s2">instance = (n2.component = n1.component)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(shouldUpdateComponent(n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">optimized)) {</span>
            <span class="s1">if </span><span class="s2">(instance.asyncDep &amp;&amp;</span>
                <span class="s2">!instance.asyncResolved) {</span>
                <span class="s2">updateComponentPreRender(instance</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
                <span class="s1">return;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s6">// normal update</span>
                <span class="s2">instance.next = n2</span><span class="s1">;</span>
                <span class="s6">// in case the child component is also queued, remove it to avoid</span>
                <span class="s6">// double updating the same child component in the same flush.</span>
                <span class="s2">invalidateJob(instance.update)</span><span class="s1">;</span>
                <span class="s6">// instance.update is the reactive effect.</span>
                <span class="s2">instance.update()</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s6">// no update needed. just copy over properties</span>
            <span class="s2">n2.el = n1.el</span><span class="s1">;</span>
            <span class="s2">instance.vnode = n2</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">setupRenderEffect = (instance</span><span class="s1">, </span><span class="s2">initialVNode</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">optimized) =&gt; {</span>
        <span class="s1">const </span><span class="s2">componentUpdateFn = () =&gt; {</span>
            <span class="s1">if </span><span class="s2">(!instance.isMounted) {</span>
                <span class="s1">let </span><span class="s2">vnodeHook</span><span class="s1">;</span>
                <span class="s1">const </span><span class="s2">{ el</span><span class="s1">, </span><span class="s2">props } = initialVNode</span><span class="s1">;</span>
                <span class="s1">const </span><span class="s2">{ bm</span><span class="s1">, </span><span class="s2">m</span><span class="s1">, </span><span class="s2">parent } = instance</span><span class="s1">;</span>
                <span class="s1">const </span><span class="s2">isAsyncWrapperVNode = isAsyncWrapper(initialVNode)</span><span class="s1">;</span>
                <span class="s2">toggleRecurse(instance</span><span class="s1">, false</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s6">// beforeMount hook</span>
                <span class="s1">if </span><span class="s2">(bm) {</span>
                    <span class="s2">shared.invokeArrayFns(bm)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s6">// onVnodeBeforeMount</span>
                <span class="s1">if </span><span class="s2">(!isAsyncWrapperVNode &amp;&amp;</span>
                    <span class="s2">(vnodeHook = props &amp;&amp; props.onVnodeBeforeMount)) {</span>
                    <span class="s2">invokeVNodeHook(vnodeHook</span><span class="s1">, </span><span class="s2">parent</span><span class="s1">, </span><span class="s2">initialVNode)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s2">toggleRecurse(instance</span><span class="s1">, true</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(el &amp;&amp; hydrateNode) {</span>
                    <span class="s6">// vnode has adopted host node - perform hydration instead of mount.</span>
                    <span class="s1">const </span><span class="s2">hydrateSubTree = () =&gt; {</span>
                        <span class="s2">instance.subTree = renderComponentRoot(instance)</span><span class="s1">;</span>
                        <span class="s2">hydrateNode(el</span><span class="s1">, </span><span class="s2">instance.subTree</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, null</span><span class="s2">)</span><span class="s1">;</span>
                    <span class="s2">}</span><span class="s1">;</span>
                    <span class="s1">if </span><span class="s2">(isAsyncWrapperVNode) {</span>
                        <span class="s2">initialVNode.type.__asyncLoader().then(</span>
                        <span class="s6">// note: we are moving the render call into an async callback,</span>
                        <span class="s6">// which means it won't track dependencies - but it's ok because</span>
                        <span class="s6">// a server-rendered async wrapper is already in resolved state</span>
                        <span class="s6">// and it will never need to change.</span>
                        <span class="s2">() =&gt; !instance.isUnmounted &amp;&amp; hydrateSubTree())</span><span class="s1">;</span>
                    <span class="s2">}</span>
                    <span class="s1">else </span><span class="s2">{</span>
                        <span class="s2">hydrateSubTree()</span><span class="s1">;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s1">const </span><span class="s2">subTree = (instance.subTree = renderComponentRoot(instance))</span><span class="s1">;</span>
                    <span class="s2">patch(</span><span class="s1">null, </span><span class="s2">subTree</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG)</span><span class="s1">;</span>
                    <span class="s2">initialVNode.el = subTree.el</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s6">// mounted hook</span>
                <span class="s1">if </span><span class="s2">(m) {</span>
                    <span class="s2">queuePostRenderEffect(m</span><span class="s1">, </span><span class="s2">parentSuspense)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s6">// onVnodeMounted</span>
                <span class="s1">if </span><span class="s2">(!isAsyncWrapperVNode &amp;&amp;</span>
                    <span class="s2">(vnodeHook = props &amp;&amp; props.onVnodeMounted)) {</span>
                    <span class="s1">const </span><span class="s2">scopedInitialVNode = initialVNode</span><span class="s1">;</span>
                    <span class="s2">queuePostRenderEffect(() =&gt; invokeVNodeHook(vnodeHook</span><span class="s1">, </span><span class="s2">parent</span><span class="s1">, </span><span class="s2">scopedInitialVNode)</span><span class="s1">, </span><span class="s2">parentSuspense)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s6">// activated hook for keep-alive roots.</span>
                <span class="s6">// #1742 activated hook must be accessed after first render</span>
                <span class="s6">// since the hook may be injected by a child keep-alive</span>
                <span class="s1">if </span><span class="s2">(initialVNode.shapeFlag &amp; </span><span class="s5">256 </span><span class="s6">/* ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE */ </span><span class="s2">||</span>
                    <span class="s2">(parent &amp;&amp;</span>
                        <span class="s2">isAsyncWrapper(parent.vnode) &amp;&amp;</span>
                        <span class="s2">parent.vnode.shapeFlag &amp; </span><span class="s5">256 </span><span class="s6">/* ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE */</span><span class="s2">)) {</span>
                    <span class="s2">instance.a &amp;&amp; queuePostRenderEffect(instance.a</span><span class="s1">, </span><span class="s2">parentSuspense)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s2">instance.isMounted = </span><span class="s1">true;</span>
                <span class="s6">// #2458: deference mount-only object parameters to prevent memleaks</span>
                <span class="s2">initialVNode = container = anchor = </span><span class="s1">null;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s6">// updateComponent</span>
                <span class="s6">// This is triggered by mutation of component's own state (next: null)</span>
                <span class="s6">// OR parent calling processComponent (next: VNode)</span>
                <span class="s1">let </span><span class="s2">{ next</span><span class="s1">, </span><span class="s2">bu</span><span class="s1">, </span><span class="s2">u</span><span class="s1">, </span><span class="s2">parent</span><span class="s1">, </span><span class="s2">vnode } = instance</span><span class="s1">;</span>
                <span class="s1">let </span><span class="s2">originNext = next</span><span class="s1">;</span>
                <span class="s1">let </span><span class="s2">vnodeHook</span><span class="s1">;</span>
                <span class="s6">// Disallow component effect recursion during pre-lifecycle hooks.</span>
                <span class="s2">toggleRecurse(instance</span><span class="s1">, false</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(next) {</span>
                    <span class="s2">next.el = vnode.el</span><span class="s1">;</span>
                    <span class="s2">updateComponentPreRender(instance</span><span class="s1">, </span><span class="s2">next</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s2">next = vnode</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s6">// beforeUpdate hook</span>
                <span class="s1">if </span><span class="s2">(bu) {</span>
                    <span class="s2">shared.invokeArrayFns(bu)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s6">// onVnodeBeforeUpdate</span>
                <span class="s1">if </span><span class="s2">((vnodeHook = next.props &amp;&amp; next.props.onVnodeBeforeUpdate)) {</span>
                    <span class="s2">invokeVNodeHook(vnodeHook</span><span class="s1">, </span><span class="s2">parent</span><span class="s1">, </span><span class="s2">next</span><span class="s1">, </span><span class="s2">vnode)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s2">toggleRecurse(instance</span><span class="s1">, true</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s1">const </span><span class="s2">nextTree = renderComponentRoot(instance)</span><span class="s1">;</span>
                <span class="s1">const </span><span class="s2">prevTree = instance.subTree</span><span class="s1">;</span>
                <span class="s2">instance.subTree = nextTree</span><span class="s1">;</span>
                <span class="s2">patch(prevTree</span><span class="s1">, </span><span class="s2">nextTree</span><span class="s1">, </span>
                <span class="s6">// parent may have changed if it's in a teleport</span>
                <span class="s2">hostParentNode(prevTree.el)</span><span class="s1">, </span>
                <span class="s6">// anchor may have changed if it's in a fragment</span>
                <span class="s2">getNextHostNode(prevTree)</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG)</span><span class="s1">;</span>
                <span class="s2">next.el = nextTree.el</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(originNext === </span><span class="s1">null</span><span class="s2">) {</span>
                    <span class="s6">// self-triggered update. In case of HOC, update parent component</span>
                    <span class="s6">// vnode el. HOC is indicated by parent instance's subTree pointing</span>
                    <span class="s6">// to child component's vnode</span>
                    <span class="s2">updateHOCHostEl(instance</span><span class="s1">, </span><span class="s2">nextTree.el)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s6">// updated hook</span>
                <span class="s1">if </span><span class="s2">(u) {</span>
                    <span class="s2">queuePostRenderEffect(u</span><span class="s1">, </span><span class="s2">parentSuspense)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s6">// onVnodeUpdated</span>
                <span class="s1">if </span><span class="s2">((vnodeHook = next.props &amp;&amp; next.props.onVnodeUpdated)) {</span>
                    <span class="s2">queuePostRenderEffect(() =&gt; invokeVNodeHook(vnodeHook</span><span class="s1">, </span><span class="s2">parent</span><span class="s1">, </span><span class="s2">next</span><span class="s1">, </span><span class="s2">vnode)</span><span class="s1">, </span><span class="s2">parentSuspense)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span><span class="s1">;</span>
        <span class="s6">// create reactive effect for rendering</span>
        <span class="s1">const </span><span class="s2">effect = (instance.effect = </span><span class="s1">new </span><span class="s2">reactivity.ReactiveEffect(componentUpdateFn</span><span class="s1">, </span><span class="s2">() =&gt; queueJob(update)</span><span class="s1">, </span><span class="s2">instance.scope </span><span class="s6">// track it in component's effect scope</span>
        <span class="s2">))</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">update = (instance.update = () =&gt; effect.run())</span><span class="s1">;</span>
        <span class="s2">update.id = instance.uid</span><span class="s1">;</span>
        <span class="s6">// allowRecurse</span>
        <span class="s6">// #1801, #2043 component render effects should allow recursive updates</span>
        <span class="s2">toggleRecurse(instance</span><span class="s1">, true</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">update()</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">updateComponentPreRender = (instance</span><span class="s1">, </span><span class="s2">nextVNode</span><span class="s1">, </span><span class="s2">optimized) =&gt; {</span>
        <span class="s2">nextVNode.component = instance</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">prevProps = instance.vnode.props</span><span class="s1">;</span>
        <span class="s2">instance.vnode = nextVNode</span><span class="s1">;</span>
        <span class="s2">instance.next = </span><span class="s1">null;</span>
        <span class="s2">updateProps(instance</span><span class="s1">, </span><span class="s2">nextVNode.props</span><span class="s1">, </span><span class="s2">prevProps</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
        <span class="s2">updateSlots(instance</span><span class="s1">, </span><span class="s2">nextVNode.children</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
        <span class="s2">reactivity.pauseTracking()</span><span class="s1">;</span>
        <span class="s6">// props update may have triggered pre-flush watchers.</span>
        <span class="s6">// flush them before the render update.</span>
        <span class="s2">flushPreFlushCbs()</span><span class="s1">;</span>
        <span class="s2">reactivity.resetTracking()</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">patchChildren = (n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized = </span><span class="s1">false</span><span class="s2">) =&gt; {</span>
        <span class="s1">const </span><span class="s2">c1 = n1 &amp;&amp; n1.children</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">prevShapeFlag = n1 ? n1.shapeFlag : </span><span class="s5">0</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">c2 = n2.children</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">{ patchFlag</span><span class="s1">, </span><span class="s2">shapeFlag } = n2</span><span class="s1">;</span>
        <span class="s6">// fast path</span>
        <span class="s1">if </span><span class="s2">(patchFlag &gt; </span><span class="s5">0</span><span class="s2">) {</span>
            <span class="s1">if </span><span class="s2">(patchFlag &amp; </span><span class="s5">128 </span><span class="s6">/* PatchFlags.KEYED_FRAGMENT */</span><span class="s2">) {</span>
                <span class="s6">// this could be either fully-keyed or mixed (some keyed some not)</span>
                <span class="s6">// presence of patchFlag means children are guaranteed to be arrays</span>
                <span class="s2">patchKeyedChildren(c1</span><span class="s1">, </span><span class="s2">c2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
                <span class="s1">return;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(patchFlag &amp; </span><span class="s5">256 </span><span class="s6">/* PatchFlags.UNKEYED_FRAGMENT */</span><span class="s2">) {</span>
                <span class="s6">// unkeyed</span>
                <span class="s2">patchUnkeyedChildren(c1</span><span class="s1">, </span><span class="s2">c2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
                <span class="s1">return;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s6">// children has 3 possibilities: text, array or no children.</span>
        <span class="s1">if </span><span class="s2">(shapeFlag &amp; </span><span class="s5">8 </span><span class="s6">/* ShapeFlags.TEXT_CHILDREN */</span><span class="s2">) {</span>
            <span class="s6">// text children fast path</span>
            <span class="s1">if </span><span class="s2">(prevShapeFlag &amp; </span><span class="s5">16 </span><span class="s6">/* ShapeFlags.ARRAY_CHILDREN */</span><span class="s2">) {</span>
                <span class="s2">unmountChildren(c1</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">if </span><span class="s2">(c2 !== c1) {</span>
                <span class="s2">hostSetElementText(container</span><span class="s1">, </span><span class="s2">c2)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s1">if </span><span class="s2">(prevShapeFlag &amp; </span><span class="s5">16 </span><span class="s6">/* ShapeFlags.ARRAY_CHILDREN */</span><span class="s2">) {</span>
                <span class="s6">// prev children was array</span>
                <span class="s1">if </span><span class="s2">(shapeFlag &amp; </span><span class="s5">16 </span><span class="s6">/* ShapeFlags.ARRAY_CHILDREN */</span><span class="s2">) {</span>
                    <span class="s6">// two arrays, cannot assume anything, do full diff</span>
                    <span class="s2">patchKeyedChildren(c1</span><span class="s1">, </span><span class="s2">c2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s6">// no new children, just unmount old</span>
                    <span class="s2">unmountChildren(c1</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, true</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s6">// prev children was text OR null</span>
                <span class="s6">// new children is array OR null</span>
                <span class="s1">if </span><span class="s2">(prevShapeFlag &amp; </span><span class="s5">8 </span><span class="s6">/* ShapeFlags.TEXT_CHILDREN */</span><span class="s2">) {</span>
                    <span class="s2">hostSetElementText(container</span><span class="s1">, </span><span class="s0">''</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s6">// mount new if array</span>
                <span class="s1">if </span><span class="s2">(shapeFlag &amp; </span><span class="s5">16 </span><span class="s6">/* ShapeFlags.ARRAY_CHILDREN */</span><span class="s2">) {</span>
                    <span class="s2">mountChildren(c2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">patchUnkeyedChildren = (c1</span><span class="s1">, </span><span class="s2">c2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized) =&gt; {</span>
        <span class="s2">c1 = c1 || shared.EMPTY_ARR</span><span class="s1">;</span>
        <span class="s2">c2 = c2 || shared.EMPTY_ARR</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">oldLength = c1.length</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">newLength = c2.length</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">commonLength = Math.min(oldLength</span><span class="s1">, </span><span class="s2">newLength)</span><span class="s1">;</span>
        <span class="s1">let </span><span class="s2">i</span><span class="s1">;</span>
        <span class="s1">for </span><span class="s2">(i = </span><span class="s5">0</span><span class="s1">; </span><span class="s2">i &lt; commonLength</span><span class="s1">; </span><span class="s2">i++) {</span>
            <span class="s1">const </span><span class="s2">nextChild = (c2[i] = optimized</span>
                <span class="s2">? cloneIfMounted(c2[i])</span>
                <span class="s2">: normalizeVNode(c2[i]))</span><span class="s1">;</span>
            <span class="s2">patch(c1[i]</span><span class="s1">, </span><span class="s2">nextChild</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, null, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(oldLength &gt; newLength) {</span>
            <span class="s6">// remove old</span>
            <span class="s2">unmountChildren(c1</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, true, false, </span><span class="s2">commonLength)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s6">// mount new</span>
            <span class="s2">mountChildren(c2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized</span><span class="s1">, </span><span class="s2">commonLength)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s6">// can be all-keyed or mixed</span>
    <span class="s1">const </span><span class="s2">patchKeyedChildren = (c1</span><span class="s1">, </span><span class="s2">c2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">parentAnchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized) =&gt; {</span>
        <span class="s1">let </span><span class="s2">i = </span><span class="s5">0</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">l2 = c2.length</span><span class="s1">;</span>
        <span class="s1">let </span><span class="s2">e1 = c1.length - </span><span class="s5">1</span><span class="s1">; </span><span class="s6">// prev ending index</span>
        <span class="s1">let </span><span class="s2">e2 = l2 - </span><span class="s5">1</span><span class="s1">; </span><span class="s6">// next ending index</span>
        <span class="s6">// 1. sync from start</span>
        <span class="s6">// (a b) c</span>
        <span class="s6">// (a b) d e</span>
        <span class="s1">while </span><span class="s2">(i &lt;= e1 &amp;&amp; i &lt;= e2) {</span>
            <span class="s1">const </span><span class="s2">n1 = c1[i]</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">n2 = (c2[i] = optimized</span>
                <span class="s2">? cloneIfMounted(c2[i])</span>
                <span class="s2">: normalizeVNode(c2[i]))</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(isSameVNodeType(n1</span><span class="s1">, </span><span class="s2">n2)) {</span>
                <span class="s2">patch(n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, null, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s1">break;</span>
            <span class="s2">}</span>
            <span class="s2">i++</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s6">// 2. sync from end</span>
        <span class="s6">// a (b c)</span>
        <span class="s6">// d e (b c)</span>
        <span class="s1">while </span><span class="s2">(i &lt;= e1 &amp;&amp; i &lt;= e2) {</span>
            <span class="s1">const </span><span class="s2">n1 = c1[e1]</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">n2 = (c2[e2] = optimized</span>
                <span class="s2">? cloneIfMounted(c2[e2])</span>
                <span class="s2">: normalizeVNode(c2[e2]))</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(isSameVNodeType(n1</span><span class="s1">, </span><span class="s2">n2)) {</span>
                <span class="s2">patch(n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, null, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s1">break;</span>
            <span class="s2">}</span>
            <span class="s2">e1--</span><span class="s1">;</span>
            <span class="s2">e2--</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s6">// 3. common sequence + mount</span>
        <span class="s6">// (a b)</span>
        <span class="s6">// (a b) c</span>
        <span class="s6">// i = 2, e1 = 1, e2 = 2</span>
        <span class="s6">// (a b)</span>
        <span class="s6">// c (a b)</span>
        <span class="s6">// i = 0, e1 = -1, e2 = 0</span>
        <span class="s1">if </span><span class="s2">(i &gt; e1) {</span>
            <span class="s1">if </span><span class="s2">(i &lt;= e2) {</span>
                <span class="s1">const </span><span class="s2">nextPos = e2 + </span><span class="s5">1</span><span class="s1">;</span>
                <span class="s1">const </span><span class="s2">anchor = nextPos &lt; l2 ? c2[nextPos].el : parentAnchor</span><span class="s1">;</span>
                <span class="s1">while </span><span class="s2">(i &lt;= e2) {</span>
                    <span class="s2">patch(</span><span class="s1">null, </span><span class="s2">(c2[i] = optimized</span>
                        <span class="s2">? cloneIfMounted(c2[i])</span>
                        <span class="s2">: normalizeVNode(c2[i]))</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
                    <span class="s2">i++</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s6">// 4. common sequence + unmount</span>
        <span class="s6">// (a b) c</span>
        <span class="s6">// (a b)</span>
        <span class="s6">// i = 2, e1 = 2, e2 = 1</span>
        <span class="s6">// a (b c)</span>
        <span class="s6">// (b c)</span>
        <span class="s6">// i = 0, e1 = 0, e2 = -1</span>
        <span class="s1">else if </span><span class="s2">(i &gt; e2) {</span>
            <span class="s1">while </span><span class="s2">(i &lt;= e1) {</span>
                <span class="s2">unmount(c1[i]</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, true</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s2">i++</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s6">// 5. unknown sequence</span>
        <span class="s6">// [i ... e1 + 1]: a b [c d e] f g</span>
        <span class="s6">// [i ... e2 + 1]: a b [e d c h] f g</span>
        <span class="s6">// i = 2, e1 = 4, e2 = 5</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s1">const </span><span class="s2">s1 = i</span><span class="s1">; </span><span class="s6">// prev starting index</span>
            <span class="s1">const </span><span class="s2">s2 = i</span><span class="s1">; </span><span class="s6">// next starting index</span>
            <span class="s6">// 5.1 build key:index map for newChildren</span>
            <span class="s1">const </span><span class="s2">keyToNewIndexMap = </span><span class="s1">new </span><span class="s2">Map()</span><span class="s1">;</span>
            <span class="s1">for </span><span class="s2">(i = s2</span><span class="s1">; </span><span class="s2">i &lt;= e2</span><span class="s1">; </span><span class="s2">i++) {</span>
                <span class="s1">const </span><span class="s2">nextChild = (c2[i] = optimized</span>
                    <span class="s2">? cloneIfMounted(c2[i])</span>
                    <span class="s2">: normalizeVNode(c2[i]))</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(nextChild.key != </span><span class="s1">null</span><span class="s2">) {</span>
                    <span class="s2">keyToNewIndexMap.set(nextChild.key</span><span class="s1">, </span><span class="s2">i)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s6">// 5.2 loop through old children left to be patched and try to patch</span>
            <span class="s6">// matching nodes &amp; remove nodes that are no longer present</span>
            <span class="s1">let </span><span class="s2">j</span><span class="s1">;</span>
            <span class="s1">let </span><span class="s2">patched = </span><span class="s5">0</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">toBePatched = e2 - s2 + </span><span class="s5">1</span><span class="s1">;</span>
            <span class="s1">let </span><span class="s2">moved = </span><span class="s1">false;</span>
            <span class="s6">// used to track whether any node has moved</span>
            <span class="s1">let </span><span class="s2">maxNewIndexSoFar = </span><span class="s5">0</span><span class="s1">;</span>
            <span class="s6">// works as Map&lt;newIndex, oldIndex&gt;</span>
            <span class="s6">// Note that oldIndex is offset by +1</span>
            <span class="s6">// and oldIndex = 0 is a special value indicating the new node has</span>
            <span class="s6">// no corresponding old node.</span>
            <span class="s6">// used for determining longest stable subsequence</span>
            <span class="s1">const </span><span class="s2">newIndexToOldIndexMap = </span><span class="s1">new </span><span class="s2">Array(toBePatched)</span><span class="s1">;</span>
            <span class="s1">for </span><span class="s2">(i = </span><span class="s5">0</span><span class="s1">; </span><span class="s2">i &lt; toBePatched</span><span class="s1">; </span><span class="s2">i++)</span>
                <span class="s2">newIndexToOldIndexMap[i] = </span><span class="s5">0</span><span class="s1">;</span>
            <span class="s1">for </span><span class="s2">(i = s1</span><span class="s1">; </span><span class="s2">i &lt;= e1</span><span class="s1">; </span><span class="s2">i++) {</span>
                <span class="s1">const </span><span class="s2">prevChild = c1[i]</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(patched &gt;= toBePatched) {</span>
                    <span class="s6">// all new children have been patched so this can only be a removal</span>
                    <span class="s2">unmount(prevChild</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, true</span><span class="s2">)</span><span class="s1">;</span>
                    <span class="s1">continue;</span>
                <span class="s2">}</span>
                <span class="s1">let </span><span class="s2">newIndex</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(prevChild.key != </span><span class="s1">null</span><span class="s2">) {</span>
                    <span class="s2">newIndex = keyToNewIndexMap.get(prevChild.key)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s6">// key-less node, try to locate a key-less node of the same type</span>
                    <span class="s1">for </span><span class="s2">(j = s2</span><span class="s1">; </span><span class="s2">j &lt;= e2</span><span class="s1">; </span><span class="s2">j++) {</span>
                        <span class="s1">if </span><span class="s2">(newIndexToOldIndexMap[j - s2] === </span><span class="s5">0 </span><span class="s2">&amp;&amp;</span>
                            <span class="s2">isSameVNodeType(prevChild</span><span class="s1">, </span><span class="s2">c2[j])) {</span>
                            <span class="s2">newIndex = j</span><span class="s1">;</span>
                            <span class="s1">break;</span>
                        <span class="s2">}</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
                <span class="s1">if </span><span class="s2">(newIndex === undefined) {</span>
                    <span class="s2">unmount(prevChild</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, true</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s2">newIndexToOldIndexMap[newIndex - s2] = i + </span><span class="s5">1</span><span class="s1">;</span>
                    <span class="s1">if </span><span class="s2">(newIndex &gt;= maxNewIndexSoFar) {</span>
                        <span class="s2">maxNewIndexSoFar = newIndex</span><span class="s1">;</span>
                    <span class="s2">}</span>
                    <span class="s1">else </span><span class="s2">{</span>
                        <span class="s2">moved = </span><span class="s1">true;</span>
                    <span class="s2">}</span>
                    <span class="s2">patch(prevChild</span><span class="s1">, </span><span class="s2">c2[newIndex]</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, null, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
                    <span class="s2">patched++</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s6">// 5.3 move and mount</span>
            <span class="s6">// generate longest stable subsequence only when nodes have moved</span>
            <span class="s1">const </span><span class="s2">increasingNewIndexSequence = moved</span>
                <span class="s2">? getSequence(newIndexToOldIndexMap)</span>
                <span class="s2">: shared.EMPTY_ARR</span><span class="s1">;</span>
            <span class="s2">j = increasingNewIndexSequence.length - </span><span class="s5">1</span><span class="s1">;</span>
            <span class="s6">// looping backwards so that we can use last patched node as anchor</span>
            <span class="s1">for </span><span class="s2">(i = toBePatched - </span><span class="s5">1</span><span class="s1">; </span><span class="s2">i &gt;= </span><span class="s5">0</span><span class="s1">; </span><span class="s2">i--) {</span>
                <span class="s1">const </span><span class="s2">nextIndex = s2 + i</span><span class="s1">;</span>
                <span class="s1">const </span><span class="s2">nextChild = c2[nextIndex]</span><span class="s1">;</span>
                <span class="s1">const </span><span class="s2">anchor = nextIndex + </span><span class="s5">1 </span><span class="s2">&lt; l2 ? c2[nextIndex + </span><span class="s5">1</span><span class="s2">].el : parentAnchor</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(newIndexToOldIndexMap[i] === </span><span class="s5">0</span><span class="s2">) {</span>
                    <span class="s6">// mount new</span>
                    <span class="s2">patch(</span><span class="s1">null, </span><span class="s2">nextChild</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else if </span><span class="s2">(moved) {</span>
                    <span class="s6">// move if:</span>
                    <span class="s6">// There is no stable subsequence (e.g. a reverse)</span>
                    <span class="s6">// OR current node is not among the stable sequence</span>
                    <span class="s1">if </span><span class="s2">(j &lt; </span><span class="s5">0 </span><span class="s2">|| i !== increasingNewIndexSequence[j]) {</span>
                        <span class="s2">move(nextChild</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s5">2 </span><span class="s6">/* MoveType.REORDER */</span><span class="s2">)</span><span class="s1">;</span>
                    <span class="s2">}</span>
                    <span class="s1">else </span><span class="s2">{</span>
                        <span class="s2">j--</span><span class="s1">;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">move = (vnode</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">moveType</span><span class="s1">, </span><span class="s2">parentSuspense = </span><span class="s1">null</span><span class="s2">) =&gt; {</span>
        <span class="s1">const </span><span class="s2">{ el</span><span class="s1">, </span><span class="s2">type</span><span class="s1">, </span><span class="s2">transition</span><span class="s1">, </span><span class="s2">children</span><span class="s1">, </span><span class="s2">shapeFlag } = vnode</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(shapeFlag &amp; </span><span class="s5">6 </span><span class="s6">/* ShapeFlags.COMPONENT */</span><span class="s2">) {</span>
            <span class="s2">move(vnode.component.subTree</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">moveType)</span><span class="s1">;</span>
            <span class="s1">return;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(shapeFlag &amp; </span><span class="s5">128 </span><span class="s6">/* ShapeFlags.SUSPENSE */</span><span class="s2">) {</span>
            <span class="s2">vnode.suspense.move(container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">moveType)</span><span class="s1">;</span>
            <span class="s1">return;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(shapeFlag &amp; </span><span class="s5">64 </span><span class="s6">/* ShapeFlags.TELEPORT */</span><span class="s2">) {</span>
            <span class="s2">type.move(vnode</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">internals)</span><span class="s1">;</span>
            <span class="s1">return;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(type === Fragment) {</span>
            <span class="s2">hostInsert(el</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor)</span><span class="s1">;</span>
            <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s5">0</span><span class="s1">; </span><span class="s2">i &lt; children.length</span><span class="s1">; </span><span class="s2">i++) {</span>
                <span class="s2">move(children[i]</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">moveType)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s2">hostInsert(vnode.anchor</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor)</span><span class="s1">;</span>
            <span class="s1">return;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(type === Static) {</span>
            <span class="s2">moveStaticNode(vnode</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor)</span><span class="s1">;</span>
            <span class="s1">return;</span>
        <span class="s2">}</span>
        <span class="s6">// single nodes</span>
        <span class="s1">const </span><span class="s2">needTransition = moveType !== </span><span class="s5">2 </span><span class="s6">/* MoveType.REORDER */ </span><span class="s2">&amp;&amp;</span>
            <span class="s2">shapeFlag &amp; </span><span class="s5">1 </span><span class="s6">/* ShapeFlags.ELEMENT */ </span><span class="s2">&amp;&amp;</span>
            <span class="s2">transition</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(needTransition) {</span>
            <span class="s1">if </span><span class="s2">(moveType === </span><span class="s5">0 </span><span class="s6">/* MoveType.ENTER */</span><span class="s2">) {</span>
                <span class="s2">transition.beforeEnter(el)</span><span class="s1">;</span>
                <span class="s2">hostInsert(el</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor)</span><span class="s1">;</span>
                <span class="s2">queuePostRenderEffect(() =&gt; transition.enter(el)</span><span class="s1">, </span><span class="s2">parentSuspense)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s1">const </span><span class="s2">{ leave</span><span class="s1">, </span><span class="s2">delayLeave</span><span class="s1">, </span><span class="s2">afterLeave } = transition</span><span class="s1">;</span>
                <span class="s1">const </span><span class="s2">remove = () =&gt; hostInsert(el</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor)</span><span class="s1">;</span>
                <span class="s1">const </span><span class="s2">performLeave = () =&gt; {</span>
                    <span class="s2">leave(el</span><span class="s1">, </span><span class="s2">() =&gt; {</span>
                        <span class="s2">remove()</span><span class="s1">;</span>
                        <span class="s2">afterLeave &amp;&amp; afterLeave()</span><span class="s1">;</span>
                    <span class="s2">})</span><span class="s1">;</span>
                <span class="s2">}</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(delayLeave) {</span>
                    <span class="s2">delayLeave(el</span><span class="s1">, </span><span class="s2">remove</span><span class="s1">, </span><span class="s2">performLeave)</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s2">performLeave()</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">hostInsert(el</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">unmount = (vnode</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">doRemove = </span><span class="s1">false, </span><span class="s2">optimized = </span><span class="s1">false</span><span class="s2">) =&gt; {</span>
        <span class="s1">const </span><span class="s2">{ type</span><span class="s1">, </span><span class="s2">props</span><span class="s1">, </span><span class="s2">ref</span><span class="s1">, </span><span class="s2">children</span><span class="s1">, </span><span class="s2">dynamicChildren</span><span class="s1">, </span><span class="s2">shapeFlag</span><span class="s1">, </span><span class="s2">patchFlag</span><span class="s1">, </span><span class="s2">dirs } = vnode</span><span class="s1">;</span>
        <span class="s6">// unset ref</span>
        <span class="s1">if </span><span class="s2">(ref != </span><span class="s1">null</span><span class="s2">) {</span>
            <span class="s2">setRef(ref</span><span class="s1">, null, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">vnode</span><span class="s1">, true</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(shapeFlag &amp; </span><span class="s5">256 </span><span class="s6">/* ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE */</span><span class="s2">) {</span>
            <span class="s2">parentComponent.ctx.deactivate(vnode)</span><span class="s1">;</span>
            <span class="s1">return;</span>
        <span class="s2">}</span>
        <span class="s1">const </span><span class="s2">shouldInvokeDirs = shapeFlag &amp; </span><span class="s5">1 </span><span class="s6">/* ShapeFlags.ELEMENT */ </span><span class="s2">&amp;&amp; dirs</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">shouldInvokeVnodeHook = !isAsyncWrapper(vnode)</span><span class="s1">;</span>
        <span class="s1">let </span><span class="s2">vnodeHook</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(shouldInvokeVnodeHook &amp;&amp;</span>
            <span class="s2">(vnodeHook = props &amp;&amp; props.onVnodeBeforeUnmount)) {</span>
            <span class="s2">invokeVNodeHook(vnodeHook</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">vnode)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(shapeFlag &amp; </span><span class="s5">6 </span><span class="s6">/* ShapeFlags.COMPONENT */</span><span class="s2">) {</span>
            <span class="s2">unmountComponent(vnode.component</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">doRemove)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s1">if </span><span class="s2">(shapeFlag &amp; </span><span class="s5">128 </span><span class="s6">/* ShapeFlags.SUSPENSE */</span><span class="s2">) {</span>
                <span class="s2">vnode.suspense.unmount(parentSuspense</span><span class="s1">, </span><span class="s2">doRemove)</span><span class="s1">;</span>
                <span class="s1">return;</span>
            <span class="s2">}</span>
            <span class="s1">if </span><span class="s2">(shouldInvokeDirs) {</span>
                <span class="s2">invokeDirectiveHook(vnode</span><span class="s1">, null, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s0">'beforeUnmount'</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">if </span><span class="s2">(shapeFlag &amp; </span><span class="s5">64 </span><span class="s6">/* ShapeFlags.TELEPORT */</span><span class="s2">) {</span>
                <span class="s2">vnode.type.remove(vnode</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">optimized</span><span class="s1">, </span><span class="s2">internals</span><span class="s1">, </span><span class="s2">doRemove)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(dynamicChildren &amp;&amp;</span>
                <span class="s6">// #1153: fast path should not be taken for non-stable (v-for) fragments</span>
                <span class="s2">(type !== Fragment ||</span>
                    <span class="s2">(patchFlag &gt; </span><span class="s5">0 </span><span class="s2">&amp;&amp; patchFlag &amp; </span><span class="s5">64 </span><span class="s6">/* PatchFlags.STABLE_FRAGMENT */</span><span class="s2">))) {</span>
                <span class="s6">// fast path for block nodes: only need to unmount dynamic children.</span>
                <span class="s2">unmountChildren(dynamicChildren</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, false, true</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">((type === Fragment &amp;&amp;</span>
                <span class="s2">patchFlag &amp;</span>
                    <span class="s2">(</span><span class="s5">128 </span><span class="s6">/* PatchFlags.KEYED_FRAGMENT */ </span><span class="s2">| </span><span class="s5">256 </span><span class="s6">/* PatchFlags.UNKEYED_FRAGMENT */</span><span class="s2">)) ||</span>
                <span class="s2">(!optimized &amp;&amp; shapeFlag &amp; </span><span class="s5">16 </span><span class="s6">/* ShapeFlags.ARRAY_CHILDREN */</span><span class="s2">)) {</span>
                <span class="s2">unmountChildren(children</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">if </span><span class="s2">(doRemove) {</span>
                <span class="s2">remove(vnode)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">((shouldInvokeVnodeHook &amp;&amp;</span>
            <span class="s2">(vnodeHook = props &amp;&amp; props.onVnodeUnmounted)) ||</span>
            <span class="s2">shouldInvokeDirs) {</span>
            <span class="s2">queuePostRenderEffect(() =&gt; {</span>
                <span class="s2">vnodeHook &amp;&amp; invokeVNodeHook(vnodeHook</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">vnode)</span><span class="s1">;</span>
                <span class="s2">shouldInvokeDirs &amp;&amp;</span>
                    <span class="s2">invokeDirectiveHook(vnode</span><span class="s1">, null, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s0">'unmounted'</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span><span class="s1">, </span><span class="s2">parentSuspense)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">remove = vnode =&gt; {</span>
        <span class="s1">const </span><span class="s2">{ type</span><span class="s1">, </span><span class="s2">el</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">transition } = vnode</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(type === Fragment) {</span>
            <span class="s2">{</span>
                <span class="s2">removeFragment(el</span><span class="s1">, </span><span class="s2">anchor)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">return;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(type === Static) {</span>
            <span class="s2">removeStaticNode(vnode)</span><span class="s1">;</span>
            <span class="s1">return;</span>
        <span class="s2">}</span>
        <span class="s1">const </span><span class="s2">performRemove = () =&gt; {</span>
            <span class="s2">hostRemove(el)</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(transition &amp;&amp; !transition.persisted &amp;&amp; transition.afterLeave) {</span>
                <span class="s2">transition.afterLeave()</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(vnode.shapeFlag &amp; </span><span class="s5">1 </span><span class="s6">/* ShapeFlags.ELEMENT */ </span><span class="s2">&amp;&amp;</span>
            <span class="s2">transition &amp;&amp;</span>
            <span class="s2">!transition.persisted) {</span>
            <span class="s1">const </span><span class="s2">{ leave</span><span class="s1">, </span><span class="s2">delayLeave } = transition</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">performLeave = () =&gt; leave(el</span><span class="s1">, </span><span class="s2">performRemove)</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(delayLeave) {</span>
                <span class="s2">delayLeave(vnode.el</span><span class="s1">, </span><span class="s2">performRemove</span><span class="s1">, </span><span class="s2">performLeave)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s2">performLeave()</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">performRemove()</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">removeFragment = (cur</span><span class="s1">, </span><span class="s2">end) =&gt; {</span>
        <span class="s6">// For fragments, directly remove all contained DOM nodes.</span>
        <span class="s6">// (fragment child nodes cannot have transition)</span>
        <span class="s1">let </span><span class="s2">next</span><span class="s1">;</span>
        <span class="s1">while </span><span class="s2">(cur !== end) {</span>
            <span class="s2">next = hostNextSibling(cur)</span><span class="s1">;</span>
            <span class="s2">hostRemove(cur)</span><span class="s1">;</span>
            <span class="s2">cur = next</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s2">hostRemove(end)</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">unmountComponent = (instance</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">doRemove) =&gt; {</span>
        <span class="s1">const </span><span class="s2">{ bum</span><span class="s1">, </span><span class="s2">scope</span><span class="s1">, </span><span class="s2">update</span><span class="s1">, </span><span class="s2">subTree</span><span class="s1">, </span><span class="s2">um } = instance</span><span class="s1">;</span>
        <span class="s6">// beforeUnmount hook</span>
        <span class="s1">if </span><span class="s2">(bum) {</span>
            <span class="s2">shared.invokeArrayFns(bum)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s6">// stop effects in component scope</span>
        <span class="s2">scope.stop()</span><span class="s1">;</span>
        <span class="s6">// update may be null if a component is unmounted before its async</span>
        <span class="s6">// setup has resolved.</span>
        <span class="s1">if </span><span class="s2">(update) {</span>
            <span class="s6">// so that scheduler will no longer invoke it</span>
            <span class="s2">update.active = </span><span class="s1">false;</span>
            <span class="s2">unmount(subTree</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">doRemove)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s6">// unmounted hook</span>
        <span class="s1">if </span><span class="s2">(um) {</span>
            <span class="s2">queuePostRenderEffect(um</span><span class="s1">, </span><span class="s2">parentSuspense)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s2">queuePostRenderEffect(() =&gt; {</span>
            <span class="s2">instance.isUnmounted = </span><span class="s1">true;</span>
        <span class="s2">}</span><span class="s1">, </span><span class="s2">parentSuspense)</span><span class="s1">;</span>
        <span class="s6">// A component with async dep inside a pending suspense is unmounted before</span>
        <span class="s6">// its async dep resolves. This should remove the dep from the suspense, and</span>
        <span class="s6">// cause the suspense to resolve immediately if that was the last dep.</span>
        <span class="s1">if </span><span class="s2">(parentSuspense &amp;&amp;</span>
            <span class="s2">parentSuspense.pendingBranch &amp;&amp;</span>
            <span class="s2">!parentSuspense.isUnmounted &amp;&amp;</span>
            <span class="s2">instance.asyncDep &amp;&amp;</span>
            <span class="s2">!instance.asyncResolved &amp;&amp;</span>
            <span class="s2">instance.suspenseId === parentSuspense.pendingId) {</span>
            <span class="s2">parentSuspense.deps--</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(parentSuspense.deps === </span><span class="s5">0</span><span class="s2">) {</span>
                <span class="s2">parentSuspense.resolve()</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">unmountChildren = (children</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">doRemove = </span><span class="s1">false, </span><span class="s2">optimized = </span><span class="s1">false, </span><span class="s2">start = </span><span class="s5">0</span><span class="s2">) =&gt; {</span>
        <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = start</span><span class="s1">; </span><span class="s2">i &lt; children.length</span><span class="s1">; </span><span class="s2">i++) {</span>
            <span class="s2">unmount(children[i]</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">doRemove</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">getNextHostNode = vnode =&gt; {</span>
        <span class="s1">if </span><span class="s2">(vnode.shapeFlag &amp; </span><span class="s5">6 </span><span class="s6">/* ShapeFlags.COMPONENT */</span><span class="s2">) {</span>
            <span class="s1">return </span><span class="s2">getNextHostNode(vnode.component.subTree)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(vnode.shapeFlag &amp; </span><span class="s5">128 </span><span class="s6">/* ShapeFlags.SUSPENSE */</span><span class="s2">) {</span>
            <span class="s1">return </span><span class="s2">vnode.suspense.next()</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">return </span><span class="s2">hostNextSibling((vnode.anchor || vnode.el))</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">render = (vnode</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">isSVG) =&gt; {</span>
        <span class="s1">if </span><span class="s2">(vnode == </span><span class="s1">null</span><span class="s2">) {</span>
            <span class="s1">if </span><span class="s2">(container._vnode) {</span>
                <span class="s2">unmount(container._vnode</span><span class="s1">, null, null, true</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">patch(container._vnode || </span><span class="s1">null, </span><span class="s2">vnode</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, null, null, null, </span><span class="s2">isSVG)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s2">flushPreFlushCbs()</span><span class="s1">;</span>
        <span class="s2">flushPostFlushCbs()</span><span class="s1">;</span>
        <span class="s2">container._vnode = vnode</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">internals = {</span>
        <span class="s2">p: patch</span><span class="s1">,</span>
        <span class="s2">um: unmount</span><span class="s1">,</span>
        <span class="s2">m: move</span><span class="s1">,</span>
        <span class="s2">r: remove</span><span class="s1">,</span>
        <span class="s2">mt: mountComponent</span><span class="s1">,</span>
        <span class="s2">mc: mountChildren</span><span class="s1">,</span>
        <span class="s2">pc: patchChildren</span><span class="s1">,</span>
        <span class="s2">pbc: patchBlockChildren</span><span class="s1">,</span>
        <span class="s2">n: getNextHostNode</span><span class="s1">,</span>
        <span class="s2">o: options</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">hydrate</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">hydrateNode</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(createHydrationFns) {</span>
        <span class="s2">[hydrate</span><span class="s1">, </span><span class="s2">hydrateNode] = createHydrationFns(internals)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">{</span>
        <span class="s2">render</span><span class="s1">,</span>
        <span class="s2">hydrate</span><span class="s1">,</span>
        <span class="s2">createApp: createAppAPI(render</span><span class="s1">, </span><span class="s2">hydrate)</span>
    <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">toggleRecurse({ effect</span><span class="s1">, </span><span class="s2">update }</span><span class="s1">, </span><span class="s2">allowed) {</span>
    <span class="s2">effect.allowRecurse = update.allowRecurse = allowed</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s3">/**</span>
 <span class="s3">* #1156</span>
 <span class="s3">* When a component is HMR-enabled, we need to make sure that all static nodes</span>
 <span class="s3">* inside a block also inherit the DOM element from the previous tree so that</span>
 <span class="s3">* HMR updates (which are full updates) can retrieve the element for patching.</span>
 <span class="s3">*</span>
 <span class="s3">* #2080</span>
 <span class="s3">* Inside keyed `template` fragment static children, if a fragment is moved,</span>
 <span class="s3">* the children will always be moved. Therefore, in order to ensure correct move</span>
 <span class="s3">* position, el should be inherited from previous nodes.</span>
 <span class="s3">*/</span>
<span class="s1">function </span><span class="s2">traverseStaticChildren(n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">shallow = </span><span class="s1">false</span><span class="s2">) {</span>
    <span class="s1">const </span><span class="s2">ch1 = n1.children</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">ch2 = n2.children</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(shared.isArray(ch1) &amp;&amp; shared.isArray(ch2)) {</span>
        <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s5">0</span><span class="s1">; </span><span class="s2">i &lt; ch1.length</span><span class="s1">; </span><span class="s2">i++) {</span>
            <span class="s6">// this is only called in the optimized path so array children are</span>
            <span class="s6">// guaranteed to be vnodes</span>
            <span class="s1">const </span><span class="s2">c1 = ch1[i]</span><span class="s1">;</span>
            <span class="s1">let </span><span class="s2">c2 = ch2[i]</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(c2.shapeFlag &amp; </span><span class="s5">1 </span><span class="s6">/* ShapeFlags.ELEMENT */ </span><span class="s2">&amp;&amp; !c2.dynamicChildren) {</span>
                <span class="s1">if </span><span class="s2">(c2.patchFlag &lt;= </span><span class="s5">0 </span><span class="s2">|| c2.patchFlag === </span><span class="s5">32 </span><span class="s6">/* PatchFlags.HYDRATE_EVENTS */</span><span class="s2">) {</span>
                    <span class="s2">c2 = ch2[i] = cloneIfMounted(ch2[i])</span><span class="s1">;</span>
                    <span class="s2">c2.el = c1.el</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">if </span><span class="s2">(!shallow)</span>
                    <span class="s2">traverseStaticChildren(c1</span><span class="s1">, </span><span class="s2">c2)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s6">// #6852 also inherit for text nodes</span>
            <span class="s1">if </span><span class="s2">(c2.type === Text) {</span>
                <span class="s2">c2.el = c1.el</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s6">// https://en.wikipedia.org/wiki/Longest_increasing_subsequence</span>
<span class="s1">function </span><span class="s2">getSequence(arr) {</span>
    <span class="s1">const </span><span class="s2">p = arr.slice()</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">result = [</span><span class="s5">0</span><span class="s2">]</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">i</span><span class="s1">, </span><span class="s2">j</span><span class="s1">, </span><span class="s2">u</span><span class="s1">, </span><span class="s2">v</span><span class="s1">, </span><span class="s2">c</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">len = arr.length</span><span class="s1">;</span>
    <span class="s1">for </span><span class="s2">(i = </span><span class="s5">0</span><span class="s1">; </span><span class="s2">i &lt; len</span><span class="s1">; </span><span class="s2">i++) {</span>
        <span class="s1">const </span><span class="s2">arrI = arr[i]</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(arrI !== </span><span class="s5">0</span><span class="s2">) {</span>
            <span class="s2">j = result[result.length - </span><span class="s5">1</span><span class="s2">]</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(arr[j] &lt; arrI) {</span>
                <span class="s2">p[i] = j</span><span class="s1">;</span>
                <span class="s2">result.push(i)</span><span class="s1">;</span>
                <span class="s1">continue;</span>
            <span class="s2">}</span>
            <span class="s2">u = </span><span class="s5">0</span><span class="s1">;</span>
            <span class="s2">v = result.length - </span><span class="s5">1</span><span class="s1">;</span>
            <span class="s1">while </span><span class="s2">(u &lt; v) {</span>
                <span class="s2">c = (u + v) &gt;&gt; </span><span class="s5">1</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(arr[result[c]] &lt; arrI) {</span>
                    <span class="s2">u = c + </span><span class="s5">1</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s2">v = c</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s1">if </span><span class="s2">(arrI &lt; arr[result[u]]) {</span>
                <span class="s1">if </span><span class="s2">(u &gt; </span><span class="s5">0</span><span class="s2">) {</span>
                    <span class="s2">p[i] = result[u - </span><span class="s5">1</span><span class="s2">]</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s2">result[u] = i</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s2">u = result.length</span><span class="s1">;</span>
    <span class="s2">v = result[u - </span><span class="s5">1</span><span class="s2">]</span><span class="s1">;</span>
    <span class="s1">while </span><span class="s2">(u-- &gt; </span><span class="s5">0</span><span class="s2">) {</span>
        <span class="s2">result[u] = v</span><span class="s1">;</span>
        <span class="s2">v = p[v]</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">result</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s1">const </span><span class="s2">isTeleport = (type) =&gt; type.__isTeleport</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">isTeleportDisabled = (props) =&gt; props &amp;&amp; (props.disabled || props.disabled === </span><span class="s0">''</span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">isTargetSVG = (target) =&gt; </span><span class="s1">typeof </span><span class="s2">SVGElement !== </span><span class="s0">'undefined' </span><span class="s2">&amp;&amp; target </span><span class="s1">instanceof </span><span class="s2">SVGElement</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">resolveTarget = (props</span><span class="s1">, </span><span class="s2">select) =&gt; {</span>
    <span class="s1">const </span><span class="s2">targetSelector = props &amp;&amp; props.to</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(shared.isString(targetSelector)) {</span>
        <span class="s1">if </span><span class="s2">(!select) {</span>
            <span class="s1">return null;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s1">const </span><span class="s2">target = select(targetSelector)</span><span class="s1">;</span>
            <span class="s1">return </span><span class="s2">target</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s1">return </span><span class="s2">targetSelector</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">TeleportImpl = {</span>
    <span class="s2">__isTeleport: </span><span class="s1">true,</span>
    <span class="s2">process(n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized</span><span class="s1">, </span><span class="s2">internals) {</span>
        <span class="s1">const </span><span class="s2">{ mc: mountChildren</span><span class="s1">, </span><span class="s2">pc: patchChildren</span><span class="s1">, </span><span class="s2">pbc: patchBlockChildren</span><span class="s1">, </span><span class="s2">o: { insert</span><span class="s1">, </span><span class="s2">querySelector</span><span class="s1">, </span><span class="s2">createText</span><span class="s1">, </span><span class="s2">createComment } } = internals</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">disabled = isTeleportDisabled(n2.props)</span><span class="s1">;</span>
        <span class="s1">let </span><span class="s2">{ shapeFlag</span><span class="s1">, </span><span class="s2">children</span><span class="s1">, </span><span class="s2">dynamicChildren } = n2</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(n1 == </span><span class="s1">null</span><span class="s2">) {</span>
            <span class="s6">// insert anchors in the main view</span>
            <span class="s1">const </span><span class="s2">placeholder = (n2.el = createText(</span><span class="s0">''</span><span class="s2">))</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">mainAnchor = (n2.anchor = createText(</span><span class="s0">''</span><span class="s2">))</span><span class="s1">;</span>
            <span class="s2">insert(placeholder</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor)</span><span class="s1">;</span>
            <span class="s2">insert(mainAnchor</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor)</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">target = (n2.target = resolveTarget(n2.props</span><span class="s1">, </span><span class="s2">querySelector))</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">targetAnchor = (n2.targetAnchor = createText(</span><span class="s0">''</span><span class="s2">))</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(target) {</span>
                <span class="s2">insert(targetAnchor</span><span class="s1">, </span><span class="s2">target)</span><span class="s1">;</span>
                <span class="s6">// #2652 we could be teleporting from a non-SVG tree into an SVG tree</span>
                <span class="s2">isSVG = isSVG || isTargetSVG(target)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">const </span><span class="s2">mount = (container</span><span class="s1">, </span><span class="s2">anchor) =&gt; {</span>
                <span class="s6">// Teleport *always* has Array children. This is enforced in both the</span>
                <span class="s6">// compiler and vnode children normalization.</span>
                <span class="s1">if </span><span class="s2">(shapeFlag &amp; </span><span class="s5">16 </span><span class="s6">/* ShapeFlags.ARRAY_CHILDREN */</span><span class="s2">) {</span>
                    <span class="s2">mountChildren(children</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(disabled) {</span>
                <span class="s2">mount(container</span><span class="s1">, </span><span class="s2">mainAnchor)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(target) {</span>
                <span class="s2">mount(target</span><span class="s1">, </span><span class="s2">targetAnchor)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s6">// update content</span>
            <span class="s2">n2.el = n1.el</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">mainAnchor = (n2.anchor = n1.anchor)</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">target = (n2.target = n1.target)</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">targetAnchor = (n2.targetAnchor = n1.targetAnchor)</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">wasDisabled = isTeleportDisabled(n1.props)</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">currentContainer = wasDisabled ? container : target</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">currentAnchor = wasDisabled ? mainAnchor : targetAnchor</span><span class="s1">;</span>
            <span class="s2">isSVG = isSVG || isTargetSVG(target)</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(dynamicChildren) {</span>
                <span class="s6">// fast path when the teleport happens to be a block root</span>
                <span class="s2">patchBlockChildren(n1.dynamicChildren</span><span class="s1">, </span><span class="s2">dynamicChildren</span><span class="s1">, </span><span class="s2">currentContainer</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds)</span><span class="s1">;</span>
                <span class="s6">// even in block tree mode we need to make sure all root-level nodes</span>
                <span class="s6">// in the teleport inherit previous DOM references so that they can</span>
                <span class="s6">// be moved in future patches.</span>
                <span class="s2">traverseStaticChildren(n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, true</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(!optimized) {</span>
                <span class="s2">patchChildren(n1</span><span class="s1">, </span><span class="s2">n2</span><span class="s1">, </span><span class="s2">currentContainer</span><span class="s1">, </span><span class="s2">currentAnchor</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">isSVG</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, false</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">if </span><span class="s2">(disabled) {</span>
                <span class="s1">if </span><span class="s2">(!wasDisabled) {</span>
                    <span class="s6">// enabled -&gt; disabled</span>
                    <span class="s6">// move into main container</span>
                    <span class="s2">moveTeleport(n2</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">mainAnchor</span><span class="s1">, </span><span class="s2">internals</span><span class="s1">, </span><span class="s5">1 </span><span class="s6">/* TeleportMoveTypes.TOGGLE */</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s6">// target changed</span>
                <span class="s1">if </span><span class="s2">((n2.props &amp;&amp; n2.props.to) !== (n1.props &amp;&amp; n1.props.to)) {</span>
                    <span class="s1">const </span><span class="s2">nextTarget = (n2.target = resolveTarget(n2.props</span><span class="s1">, </span><span class="s2">querySelector))</span><span class="s1">;</span>
                    <span class="s1">if </span><span class="s2">(nextTarget) {</span>
                        <span class="s2">moveTeleport(n2</span><span class="s1">, </span><span class="s2">nextTarget</span><span class="s1">, null, </span><span class="s2">internals</span><span class="s1">, </span><span class="s5">0 </span><span class="s6">/* TeleportMoveTypes.TARGET_CHANGE */</span><span class="s2">)</span><span class="s1">;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
                <span class="s1">else if </span><span class="s2">(wasDisabled) {</span>
                    <span class="s6">// disabled -&gt; enabled</span>
                    <span class="s6">// move into teleport target</span>
                    <span class="s2">moveTeleport(n2</span><span class="s1">, </span><span class="s2">target</span><span class="s1">, </span><span class="s2">targetAnchor</span><span class="s1">, </span><span class="s2">internals</span><span class="s1">, </span><span class="s5">1 </span><span class="s6">/* TeleportMoveTypes.TOGGLE */</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s2">updateCssVars(n2)</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">,</span>
    <span class="s2">remove(vnode</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">optimized</span><span class="s1">, </span><span class="s2">{ um: unmount</span><span class="s1">, </span><span class="s2">o: { remove: hostRemove } }</span><span class="s1">, </span><span class="s2">doRemove) {</span>
        <span class="s1">const </span><span class="s2">{ shapeFlag</span><span class="s1">, </span><span class="s2">children</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">targetAnchor</span><span class="s1">, </span><span class="s2">target</span><span class="s1">, </span><span class="s2">props } = vnode</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(target) {</span>
            <span class="s2">hostRemove(targetAnchor)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s6">// an unmounted teleport should always remove its children if not disabled</span>
        <span class="s1">if </span><span class="s2">(doRemove || !isTeleportDisabled(props)) {</span>
            <span class="s2">hostRemove(anchor)</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(shapeFlag &amp; </span><span class="s5">16 </span><span class="s6">/* ShapeFlags.ARRAY_CHILDREN */</span><span class="s2">) {</span>
                <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s5">0</span><span class="s1">; </span><span class="s2">i &lt; children.length</span><span class="s1">; </span><span class="s2">i++) {</span>
                    <span class="s1">const </span><span class="s2">child = children[i]</span><span class="s1">;</span>
                    <span class="s2">unmount(child</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, true, </span><span class="s2">!!child.dynamicChildren)</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">,</span>
    <span class="s2">move: moveTeleport</span><span class="s1">,</span>
    <span class="s2">hydrate: hydrateTeleport</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">moveTeleport(vnode</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">parentAnchor</span><span class="s1">, </span><span class="s2">{ o: { insert }</span><span class="s1">, </span><span class="s2">m: move }</span><span class="s1">, </span><span class="s2">moveType = </span><span class="s5">2 </span><span class="s6">/* TeleportMoveTypes.REORDER */</span><span class="s2">) {</span>
    <span class="s6">// move target anchor if this is a target change.</span>
    <span class="s1">if </span><span class="s2">(moveType === </span><span class="s5">0 </span><span class="s6">/* TeleportMoveTypes.TARGET_CHANGE */</span><span class="s2">) {</span>
        <span class="s2">insert(vnode.targetAnchor</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">parentAnchor)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">{ el</span><span class="s1">, </span><span class="s2">anchor</span><span class="s1">, </span><span class="s2">shapeFlag</span><span class="s1">, </span><span class="s2">children</span><span class="s1">, </span><span class="s2">props } = vnode</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">isReorder = moveType === </span><span class="s5">2 </span><span class="s6">/* TeleportMoveTypes.REORDER */</span><span class="s1">;</span>
    <span class="s6">// move main view anchor if this is a re-order.</span>
    <span class="s1">if </span><span class="s2">(isReorder) {</span>
        <span class="s2">insert(el</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">parentAnchor)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s6">// if this is a re-order and teleport is enabled (content is in target)</span>
    <span class="s6">// do not move children. So the opposite is: only move children if this</span>
    <span class="s6">// is not a reorder, or the teleport is disabled</span>
    <span class="s1">if </span><span class="s2">(!isReorder || isTeleportDisabled(props)) {</span>
        <span class="s6">// Teleport has either Array children or no children.</span>
        <span class="s1">if </span><span class="s2">(shapeFlag &amp; </span><span class="s5">16 </span><span class="s6">/* ShapeFlags.ARRAY_CHILDREN */</span><span class="s2">) {</span>
            <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s5">0</span><span class="s1">; </span><span class="s2">i &lt; children.length</span><span class="s1">; </span><span class="s2">i++) {</span>
                <span class="s2">move(children[i]</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">parentAnchor</span><span class="s1">, </span><span class="s5">2 </span><span class="s6">/* MoveType.REORDER */</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s6">// move main view anchor if this is a re-order.</span>
    <span class="s1">if </span><span class="s2">(isReorder) {</span>
        <span class="s2">insert(anchor</span><span class="s1">, </span><span class="s2">container</span><span class="s1">, </span><span class="s2">parentAnchor)</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">hydrateTeleport(node</span><span class="s1">, </span><span class="s2">vnode</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized</span><span class="s1">, </span><span class="s2">{ o: { nextSibling</span><span class="s1">, </span><span class="s2">parentNode</span><span class="s1">, </span><span class="s2">querySelector } }</span><span class="s1">, </span><span class="s2">hydrateChildren) {</span>
    <span class="s1">const </span><span class="s2">target = (vnode.target = resolveTarget(vnode.props</span><span class="s1">, </span><span class="s2">querySelector))</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(target) {</span>
        <span class="s6">// if multiple teleports rendered to the same target element, we need to</span>
        <span class="s6">// pick up from where the last teleport finished instead of the first node</span>
        <span class="s1">const </span><span class="s2">targetNode = target._lpa || target.firstChild</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(vnode.shapeFlag &amp; </span><span class="s5">16 </span><span class="s6">/* ShapeFlags.ARRAY_CHILDREN */</span><span class="s2">) {</span>
            <span class="s1">if </span><span class="s2">(isTeleportDisabled(vnode.props)) {</span>
                <span class="s2">vnode.anchor = hydrateChildren(nextSibling(node)</span><span class="s1">, </span><span class="s2">vnode</span><span class="s1">, </span><span class="s2">parentNode(node)</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
                <span class="s2">vnode.targetAnchor = targetNode</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s2">vnode.anchor = nextSibling(node)</span><span class="s1">;</span>
                <span class="s6">// lookahead until we find the target anchor</span>
                <span class="s6">// we cannot rely on return value of hydrateChildren() because there</span>
                <span class="s6">// could be nested teleports</span>
                <span class="s1">let </span><span class="s2">targetAnchor = targetNode</span><span class="s1">;</span>
                <span class="s1">while </span><span class="s2">(targetAnchor) {</span>
                    <span class="s2">targetAnchor = nextSibling(targetAnchor)</span><span class="s1">;</span>
                    <span class="s1">if </span><span class="s2">(targetAnchor &amp;&amp;</span>
                        <span class="s2">targetAnchor.nodeType === </span><span class="s5">8 </span><span class="s2">&amp;&amp;</span>
                        <span class="s2">targetAnchor.data === </span><span class="s0">'teleport anchor'</span><span class="s2">) {</span>
                        <span class="s2">vnode.targetAnchor = targetAnchor</span><span class="s1">;</span>
                        <span class="s2">target._lpa =</span>
                            <span class="s2">vnode.targetAnchor &amp;&amp; nextSibling(vnode.targetAnchor)</span><span class="s1">;</span>
                        <span class="s1">break;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
                <span class="s2">hydrateChildren(targetNode</span><span class="s1">, </span><span class="s2">vnode</span><span class="s1">, </span><span class="s2">target</span><span class="s1">, </span><span class="s2">parentComponent</span><span class="s1">, </span><span class="s2">parentSuspense</span><span class="s1">, </span><span class="s2">slotScopeIds</span><span class="s1">, </span><span class="s2">optimized)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s2">updateCssVars(vnode)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">vnode.anchor &amp;&amp; nextSibling(vnode.anchor)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s6">// Force-casted public typing for h and TSX props inference</span>
<span class="s1">const </span><span class="s2">Teleport = TeleportImpl</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">updateCssVars(vnode) {</span>
    <span class="s6">// presence of .ut method indicates owner component uses css vars.</span>
    <span class="s6">// code path here can assume browser environment.</span>
    <span class="s1">const </span><span class="s2">ctx = vnode.ctx</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(ctx &amp;&amp; ctx.ut) {</span>
        <span class="s1">let </span><span class="s2">node = vnode.children[</span><span class="s5">0</span><span class="s2">].el</span><span class="s1">;</span>
        <span class="s1">while </span><span class="s2">(node !== vnode.targetAnchor) {</span>
            <span class="s1">if </span><span class="s2">(node.nodeType === </span><span class="s5">1</span><span class="s2">)</span>
                <span class="s2">node.setAttribute(</span><span class="s0">'data-v-owner'</span><span class="s1">, </span><span class="s2">ctx.uid)</span><span class="s1">;</span>
            <span class="s2">node = node.nextSibling</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s2">ctx.ut()</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>

<span class="s1">const </span><span class="s2">Fragment = Symbol(undefined)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">Text = Symbol(undefined)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">Comment = Symbol(undefined)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">Static = Symbol(undefined)</span><span class="s1">;</span>
<span class="s6">// Since v-if and v-for are the two possible ways node structure can dynamically</span>
<span class="s6">// change, once we consider v-if branches and each v-for fragment a block, we</span>
<span class="s6">// can divide a template into nested blocks, and within each block the node</span>
<span class="s6">// structure would be stable. This allows us to skip most children diffing</span>
<span class="s6">// and only worry about the dynamic nodes (indicated by patch flags).</span>
<span class="s1">const </span><span class="s2">blockStack = []</span><span class="s1">;</span>
<span class="s1">let </span><span class="s2">currentBlock = </span><span class="s1">null;</span>
<span class="s3">/**</span>
 <span class="s3">* Open a block.</span>
 <span class="s3">* This must be called before `createBlock`. It cannot be part of `createBlock`</span>
 <span class="s3">* because the children of the block are evaluated before `createBlock` itself</span>
 <span class="s3">* is called. The generated code typically looks like this:</span>
 <span class="s3">*</span>
 <span class="s3">* ```js</span>
 <span class="s3">* function render() {</span>
 <span class="s3">*   return (openBlock(),createBlock('div', null, [...]))</span>
 <span class="s3">* }</span>
 <span class="s3">* ```</span>
 <span class="s3">* disableTracking is true when creating a v-for fragment block, since a v-for</span>
 <span class="s3">* fragment always diffs its children.</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s4">@private</span>
 <span class="s3">*/</span>
<span class="s1">function </span><span class="s2">openBlock(disableTracking = </span><span class="s1">false</span><span class="s2">) {</span>
    <span class="s2">blockStack.push((currentBlock = disableTracking ? </span><span class="s1">null </span><span class="s2">: []))</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">closeBlock() {</span>
    <span class="s2">blockStack.pop()</span><span class="s1">;</span>
    <span class="s2">currentBlock = blockStack[blockStack.length - </span><span class="s5">1</span><span class="s2">] || </span><span class="s1">null;</span>
<span class="s2">}</span>
<span class="s6">// Whether we should be tracking dynamic child nodes inside a block.</span>
<span class="s6">// Only tracks when this value is &gt; 0</span>
<span class="s6">// We are not using a simple boolean because this value may need to be</span>
<span class="s6">// incremented/decremented by nested usage of v-once (see below)</span>
<span class="s1">let </span><span class="s2">isBlockTreeEnabled = </span><span class="s5">1</span><span class="s1">;</span>
<span class="s3">/**</span>
 <span class="s3">* Block tracking sometimes needs to be disabled, for example during the</span>
 <span class="s3">* creation of a tree that needs to be cached by v-once. The compiler generates</span>
 <span class="s3">* code like this:</span>
 <span class="s3">*</span>
 <span class="s3">* ``` js</span>
 <span class="s3">* _cache[1] || (</span>
 <span class="s3">*   setBlockTracking(-1),</span>
 <span class="s3">*   _cache[1] = createVNode(...),</span>
 <span class="s3">*   setBlockTracking(1),</span>
 <span class="s3">*   _cache[1]</span>
 <span class="s3">* )</span>
 <span class="s3">* ```</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s4">@private</span>
 <span class="s3">*/</span>
<span class="s1">function </span><span class="s2">setBlockTracking(value) {</span>
    <span class="s2">isBlockTreeEnabled += value</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">setupBlock(vnode) {</span>
    <span class="s6">// save current block children on the block vnode</span>
    <span class="s2">vnode.dynamicChildren =</span>
        <span class="s2">isBlockTreeEnabled &gt; </span><span class="s5">0 </span><span class="s2">? currentBlock || shared.EMPTY_ARR : </span><span class="s1">null;</span>
    <span class="s6">// close block</span>
    <span class="s2">closeBlock()</span><span class="s1">;</span>
    <span class="s6">// a block is always going to be patched, so track it as a child of its</span>
    <span class="s6">// parent block</span>
    <span class="s1">if </span><span class="s2">(isBlockTreeEnabled &gt; </span><span class="s5">0 </span><span class="s2">&amp;&amp; currentBlock) {</span>
        <span class="s2">currentBlock.push(vnode)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">vnode</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s3">/**</span>
 <span class="s3">* </span><span class="s4">@private</span>
 <span class="s3">*/</span>
<span class="s1">function </span><span class="s2">createElementBlock(type</span><span class="s1">, </span><span class="s2">props</span><span class="s1">, </span><span class="s2">children</span><span class="s1">, </span><span class="s2">patchFlag</span><span class="s1">, </span><span class="s2">dynamicProps</span><span class="s1">, </span><span class="s2">shapeFlag) {</span>
    <span class="s1">return </span><span class="s2">setupBlock(createBaseVNode(type</span><span class="s1">, </span><span class="s2">props</span><span class="s1">, </span><span class="s2">children</span><span class="s1">, </span><span class="s2">patchFlag</span><span class="s1">, </span><span class="s2">dynamicProps</span><span class="s1">, </span><span class="s2">shapeFlag</span><span class="s1">, true </span><span class="s6">/* isBlock */</span><span class="s2">))</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s3">/**</span>
 <span class="s3">* Create a block root vnode. Takes the same exact arguments as `createVNode`.</span>
 <span class="s3">* A block root keeps track of dynamic nodes within the block in the</span>
 <span class="s3">* `dynamicChildren` array.</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s4">@private</span>
 <span class="s3">*/</span>
<span class="s1">function </span><span class="s2">createBlock(type</span><span class="s1">, </span><span class="s2">props</span><span class="s1">, </span><span class="s2">children</span><span class="s1">, </span><span class="s2">patchFlag</span><span class="s1">, </span><span class="s2">dynamicProps) {</span>
    <span class="s1">return </span><span class="s2">setupBlock(createVNode(type</span><span class="s1">, </span><span class="s2">props</span><span class="s1">, </span><span class="s2">children</span><span class="s1">, </span><span class="s2">patchFlag</span><span class="s1">, </span><span class="s2">dynamicProps</span><span class="s1">, true </span><span class="s6">/* isBlock: prevent a block from tracking itself */</span><span class="s2">))</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">isVNode(value) {</span>
    <span class="s1">return </span><span class="s2">value ? value.__v_isVNode === </span><span class="s1">true </span><span class="s2">: </span><span class="s1">false;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">isSameVNodeType(n1</span><span class="s1">, </span><span class="s2">n2) {</span>
    <span class="s1">return </span><span class="s2">n1.type === n2.type &amp;&amp; n1.key === n2.key</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s3">/**</span>
 <span class="s3">* Internal API for registering an arguments transform for createVNode</span>
 <span class="s3">* used for creating stubs in the test-utils</span>
 <span class="s3">* It is *internal* but needs to be exposed for test-utils to pick up proper</span>
 <span class="s3">* typings</span>
 <span class="s3">*/</span>
<span class="s1">function </span><span class="s2">transformVNodeArgs(transformer) {</span>
<span class="s2">}</span>
<span class="s1">const </span><span class="s2">InternalObjectKey = </span><span class="s0">`__vInternal`</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">normalizeKey = ({ key }) =&gt; key != </span><span class="s1">null </span><span class="s2">? key : </span><span class="s1">null;</span>
<span class="s1">const </span><span class="s2">normalizeRef = ({ ref</span><span class="s1">, </span><span class="s2">ref_key</span><span class="s1">, </span><span class="s2">ref_for }) =&gt; {</span>
    <span class="s1">return </span><span class="s2">(ref != </span><span class="s1">null</span>
        <span class="s2">? shared.isString(ref) || reactivity.isRef(ref) || shared.isFunction(ref)</span>
            <span class="s2">? { i: currentRenderingInstance</span><span class="s1">, </span><span class="s2">r: ref</span><span class="s1">, </span><span class="s2">k: ref_key</span><span class="s1">, </span><span class="s2">f: !!ref_for }</span>
            <span class="s2">: ref</span>
        <span class="s2">: </span><span class="s1">null</span><span class="s2">)</span><span class="s1">;</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">createBaseVNode(type</span><span class="s1">, </span><span class="s2">props = </span><span class="s1">null, </span><span class="s2">children = </span><span class="s1">null, </span><span class="s2">patchFlag = </span><span class="s5">0</span><span class="s1">, </span><span class="s2">dynamicProps = </span><span class="s1">null, </span><span class="s2">shapeFlag = type === Fragment ? </span><span class="s5">0 </span><span class="s2">: </span><span class="s5">1 </span><span class="s6">/* ShapeFlags.ELEMENT */</span><span class="s1">, </span><span class="s2">isBlockNode = </span><span class="s1">false, </span><span class="s2">needFullChildrenNormalization = </span><span class="s1">false</span><span class="s2">) {</span>
    <span class="s1">const </span><span class="s2">vnode = {</span>
        <span class="s2">__v_isVNode: </span><span class="s1">true,</span>
        <span class="s2">__v_skip: </span><span class="s1">true,</span>
        <span class="s2">type</span><span class="s1">,</span>
        <span class="s2">props</span><span class="s1">,</span>
        <span class="s2">key: props &amp;&amp; normalizeKey(props)</span><span class="s1">,</span>
        <span class="s2">ref: props &amp;&amp; normalizeRef(props)</span><span class="s1">,</span>
        <span class="s2">scopeId: currentScopeId</span><span class="s1">,</span>
        <span class="s2">slotScopeIds: </span><span class="s1">null,</span>
        <span class="s2">children</span><span class="s1">,</span>
        <span class="s2">component: </span><span class="s1">null,</span>
        <span class="s2">suspense: </span><span class="s1">null,</span>
        <span class="s2">ssContent: </span><span class="s1">null,</span>
        <span class="s2">ssFallback: </span><span class="s1">null,</span>
        <span class="s2">dirs: </span><span class="s1">null,</span>
        <span class="s2">transition: </span><span class="s1">null,</span>
        <span class="s2">el: </span><span class="s1">null,</span>
        <span class="s2">anchor: </span><span class="s1">null,</span>
        <span class="s2">target: </span><span class="s1">null,</span>
        <span class="s2">targetAnchor: </span><span class="s1">null,</span>
        <span class="s2">staticCount: </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s2">shapeFlag</span><span class="s1">,</span>
        <span class="s2">patchFlag</span><span class="s1">,</span>
        <span class="s2">dynamicProps</span><span class="s1">,</span>
        <span class="s2">dynamicChildren: </span><span class="s1">null,</span>
        <span class="s2">appContext: </span><span class="s1">null,</span>
        <span class="s2">ctx: currentRenderingInstance</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(needFullChildrenNormalization) {</span>
        <span class="s2">normalizeChildren(vnode</span><span class="s1">, </span><span class="s2">children)</span><span class="s1">;</span>
        <span class="s6">// normalize suspense children</span>
        <span class="s1">if </span><span class="s2">(shapeFlag &amp; </span><span class="s5">128 </span><span class="s6">/* ShapeFlags.SUSPENSE */</span><span class="s2">) {</span>
            <span class="s2">type.normalize(vnode)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(children) {</span>
        <span class="s6">// compiled element vnode - if children is passed, only possible types are</span>
        <span class="s6">// string or Array.</span>
        <span class="s2">vnode.shapeFlag |= shared.isString(children)</span>
            <span class="s2">? </span><span class="s5">8 </span><span class="s6">/* ShapeFlags.TEXT_CHILDREN */</span>
            <span class="s2">: </span><span class="s5">16 </span><span class="s6">/* ShapeFlags.ARRAY_CHILDREN */</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s6">// track vnode for block tree</span>
    <span class="s1">if </span><span class="s2">(isBlockTreeEnabled &gt; </span><span class="s5">0 </span><span class="s2">&amp;&amp;</span>
        <span class="s6">// avoid a block node from tracking itself</span>
        <span class="s2">!isBlockNode &amp;&amp;</span>
        <span class="s6">// has current parent block</span>
        <span class="s2">currentBlock &amp;&amp;</span>
        <span class="s6">// presence of a patch flag indicates this node needs patching on updates.</span>
        <span class="s6">// component nodes also should always be patched, because even if the</span>
        <span class="s6">// component doesn't need to update, it needs to persist the instance on to</span>
        <span class="s6">// the next vnode so that it can be properly unmounted later.</span>
        <span class="s2">(vnode.patchFlag &gt; </span><span class="s5">0 </span><span class="s2">|| shapeFlag &amp; </span><span class="s5">6 </span><span class="s6">/* ShapeFlags.COMPONENT */</span><span class="s2">) &amp;&amp;</span>
        <span class="s6">// the EVENTS flag is only for hydration and if it is the only flag, the</span>
        <span class="s6">// vnode should not be considered dynamic due to handler caching.</span>
        <span class="s2">vnode.patchFlag !== </span><span class="s5">32 </span><span class="s6">/* PatchFlags.HYDRATE_EVENTS */</span><span class="s2">) {</span>
        <span class="s2">currentBlock.push(vnode)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">vnode</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">const </span><span class="s2">createVNode = (_createVNode)</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">_createVNode(type</span><span class="s1">, </span><span class="s2">props = </span><span class="s1">null, </span><span class="s2">children = </span><span class="s1">null, </span><span class="s2">patchFlag = </span><span class="s5">0</span><span class="s1">, </span><span class="s2">dynamicProps = </span><span class="s1">null, </span><span class="s2">isBlockNode = </span><span class="s1">false</span><span class="s2">) {</span>
    <span class="s1">if </span><span class="s2">(!type || type === NULL_DYNAMIC_COMPONENT) {</span>
        <span class="s2">type = Comment</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(isVNode(type)) {</span>
        <span class="s6">// createVNode receiving an existing vnode. This happens in cases like</span>
        <span class="s6">// &lt;component :is=&quot;vnode&quot;/&gt;</span>
        <span class="s6">// #2078 make sure to merge refs during the clone instead of overwriting it</span>
        <span class="s1">const </span><span class="s2">cloned = cloneVNode(type</span><span class="s1">, </span><span class="s2">props</span><span class="s1">, true </span><span class="s6">/* mergeRef: true */</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(children) {</span>
            <span class="s2">normalizeChildren(cloned</span><span class="s1">, </span><span class="s2">children)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(isBlockTreeEnabled &gt; </span><span class="s5">0 </span><span class="s2">&amp;&amp; !isBlockNode &amp;&amp; currentBlock) {</span>
            <span class="s1">if </span><span class="s2">(cloned.shapeFlag &amp; </span><span class="s5">6 </span><span class="s6">/* ShapeFlags.COMPONENT */</span><span class="s2">) {</span>
                <span class="s2">currentBlock[currentBlock.indexOf(type)] = cloned</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s2">currentBlock.push(cloned)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s2">cloned.patchFlag |= -</span><span class="s5">2 </span><span class="s6">/* PatchFlags.BAIL */</span><span class="s1">;</span>
        <span class="s1">return </span><span class="s2">cloned</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s6">// class component normalization.</span>
    <span class="s1">if </span><span class="s2">(isClassComponent(type)) {</span>
        <span class="s2">type = type.__vccOpts</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s6">// class &amp; style normalization.</span>
    <span class="s1">if </span><span class="s2">(props) {</span>
        <span class="s6">// for reactive or proxy objects, we need to clone it to enable mutation.</span>
        <span class="s2">props = guardReactiveProps(props)</span><span class="s1">;</span>
        <span class="s1">let </span><span class="s2">{ </span><span class="s1">class</span><span class="s2">: klass</span><span class="s1">, </span><span class="s2">style } = props</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(klass &amp;&amp; !shared.isString(klass)) {</span>
            <span class="s2">props.class = shared.normalizeClass(klass)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(shared.isObject(style)) {</span>
            <span class="s6">// reactive state objects need to be cloned since they are likely to be</span>
            <span class="s6">// mutated</span>
            <span class="s1">if </span><span class="s2">(reactivity.isProxy(style) &amp;&amp; !shared.isArray(style)) {</span>
                <span class="s2">style = shared.extend({}</span><span class="s1">, </span><span class="s2">style)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s2">props.style = shared.normalizeStyle(style)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s6">// encode the vnode type information into a bitmap</span>
    <span class="s1">const </span><span class="s2">shapeFlag = shared.isString(type)</span>
        <span class="s2">? </span><span class="s5">1 </span><span class="s6">/* ShapeFlags.ELEMENT */</span>
        <span class="s2">: isSuspense(type)</span>
            <span class="s2">? </span><span class="s5">128 </span><span class="s6">/* ShapeFlags.SUSPENSE */</span>
            <span class="s2">: isTeleport(type)</span>
                <span class="s2">? </span><span class="s5">64 </span><span class="s6">/* ShapeFlags.TELEPORT */</span>
                <span class="s2">: shared.isObject(type)</span>
                    <span class="s2">? </span><span class="s5">4 </span><span class="s6">/* ShapeFlags.STATEFUL_COMPONENT */</span>
                    <span class="s2">: shared.isFunction(type)</span>
                        <span class="s2">? </span><span class="s5">2 </span><span class="s6">/* ShapeFlags.FUNCTIONAL_COMPONENT */</span>
                        <span class="s2">: </span><span class="s5">0</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">createBaseVNode(type</span><span class="s1">, </span><span class="s2">props</span><span class="s1">, </span><span class="s2">children</span><span class="s1">, </span><span class="s2">patchFlag</span><span class="s1">, </span><span class="s2">dynamicProps</span><span class="s1">, </span><span class="s2">shapeFlag</span><span class="s1">, </span><span class="s2">isBlockNode</span><span class="s1">, true</span><span class="s2">)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">guardReactiveProps(props) {</span>
    <span class="s1">if </span><span class="s2">(!props)</span>
        <span class="s1">return null;</span>
    <span class="s1">return </span><span class="s2">reactivity.isProxy(props) || InternalObjectKey </span><span class="s1">in </span><span class="s2">props</span>
        <span class="s2">? shared.extend({}</span><span class="s1">, </span><span class="s2">props)</span>
        <span class="s2">: props</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">cloneVNode(vnode</span><span class="s1">, </span><span class="s2">extraProps</span><span class="s1">, </span><span class="s2">mergeRef = </span><span class="s1">false</span><span class="s2">) {</span>
    <span class="s6">// This is intentionally NOT using spread or extend to avoid the runtime</span>
    <span class="s6">// key enumeration cost.</span>
    <span class="s1">const </span><span class="s2">{ props</span><span class="s1">, </span><span class="s2">ref</span><span class="s1">, </span><span class="s2">patchFlag</span><span class="s1">, </span><span class="s2">children } = vnode</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">mergedProps = extraProps ? mergeProps(props || {}</span><span class="s1">, </span><span class="s2">extraProps) : props</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">cloned = {</span>
        <span class="s2">__v_isVNode: </span><span class="s1">true,</span>
        <span class="s2">__v_skip: </span><span class="s1">true,</span>
        <span class="s2">type: vnode.type</span><span class="s1">,</span>
        <span class="s2">props: mergedProps</span><span class="s1">,</span>
        <span class="s2">key: mergedProps &amp;&amp; normalizeKey(mergedProps)</span><span class="s1">,</span>
        <span class="s2">ref: extraProps &amp;&amp; extraProps.ref</span>
            <span class="s2">? </span><span class="s6">// #2078 in the case of &lt;component :is=&quot;vnode&quot; ref=&quot;extra&quot;/&gt;</span>
                <span class="s6">// if the vnode itself already has a ref, cloneVNode will need to merge</span>
                <span class="s6">// the refs so the single vnode can be set on multiple refs</span>
                <span class="s2">mergeRef &amp;&amp; ref</span>
                    <span class="s2">? shared.isArray(ref)</span>
                        <span class="s2">? ref.concat(normalizeRef(extraProps))</span>
                        <span class="s2">: [ref</span><span class="s1">, </span><span class="s2">normalizeRef(extraProps)]</span>
                    <span class="s2">: normalizeRef(extraProps)</span>
            <span class="s2">: ref</span><span class="s1">,</span>
        <span class="s2">scopeId: vnode.scopeId</span><span class="s1">,</span>
        <span class="s2">slotScopeIds: vnode.slotScopeIds</span><span class="s1">,</span>
        <span class="s2">children: children</span><span class="s1">,</span>
        <span class="s2">target: vnode.target</span><span class="s1">,</span>
        <span class="s2">targetAnchor: vnode.targetAnchor</span><span class="s1">,</span>
        <span class="s2">staticCount: vnode.staticCount</span><span class="s1">,</span>
        <span class="s2">shapeFlag: vnode.shapeFlag</span><span class="s1">,</span>
        <span class="s6">// if the vnode is cloned with extra props, we can no longer assume its</span>
        <span class="s6">// existing patch flag to be reliable and need to add the FULL_PROPS flag.</span>
        <span class="s6">// note: preserve flag for fragments since they use the flag for children</span>
        <span class="s6">// fast paths only.</span>
        <span class="s2">patchFlag: extraProps &amp;&amp; vnode.type !== Fragment</span>
            <span class="s2">? patchFlag === -</span><span class="s5">1 </span><span class="s6">// hoisted node</span>
                <span class="s2">? </span><span class="s5">16 </span><span class="s6">/* PatchFlags.FULL_PROPS */</span>
                <span class="s2">: patchFlag | </span><span class="s5">16 </span><span class="s6">/* PatchFlags.FULL_PROPS */</span>
            <span class="s2">: patchFlag</span><span class="s1">,</span>
        <span class="s2">dynamicProps: vnode.dynamicProps</span><span class="s1">,</span>
        <span class="s2">dynamicChildren: vnode.dynamicChildren</span><span class="s1">,</span>
        <span class="s2">appContext: vnode.appContext</span><span class="s1">,</span>
        <span class="s2">dirs: vnode.dirs</span><span class="s1">,</span>
        <span class="s2">transition: vnode.transition</span><span class="s1">,</span>
        <span class="s6">// These should technically only be non-null on mounted VNodes. However,</span>
        <span class="s6">// they *should* be copied for kept-alive vnodes. So we just always copy</span>
        <span class="s6">// them since them being non-null during a mount doesn't affect the logic as</span>
        <span class="s6">// they will simply be overwritten.</span>
        <span class="s2">component: vnode.component</span><span class="s1">,</span>
        <span class="s2">suspense: vnode.suspense</span><span class="s1">,</span>
        <span class="s2">ssContent: vnode.ssContent &amp;&amp; cloneVNode(vnode.ssContent)</span><span class="s1">,</span>
        <span class="s2">ssFallback: vnode.ssFallback &amp;&amp; cloneVNode(vnode.ssFallback)</span><span class="s1">,</span>
        <span class="s2">el: vnode.el</span><span class="s1">,</span>
        <span class="s2">anchor: vnode.anchor</span><span class="s1">,</span>
        <span class="s2">ctx: vnode.ctx</span><span class="s1">,</span>
        <span class="s2">ce: vnode.ce</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">cloned</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s3">/**</span>
 <span class="s3">* </span><span class="s4">@private</span>
 <span class="s3">*/</span>
<span class="s1">function </span><span class="s2">createTextVNode(text = </span><span class="s0">' '</span><span class="s1">, </span><span class="s2">flag = </span><span class="s5">0</span><span class="s2">) {</span>
    <span class="s1">return </span><span class="s2">createVNode(Text</span><span class="s1">, null, </span><span class="s2">text</span><span class="s1">, </span><span class="s2">flag)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s3">/**</span>
 <span class="s3">* </span><span class="s4">@private</span>
 <span class="s3">*/</span>
<span class="s1">function </span><span class="s2">createStaticVNode(content</span><span class="s1">, </span><span class="s2">numberOfNodes) {</span>
    <span class="s6">// A static vnode can contain multiple stringified elements, and the number</span>
    <span class="s6">// of elements is necessary for hydration.</span>
    <span class="s1">const </span><span class="s2">vnode = createVNode(Static</span><span class="s1">, null, </span><span class="s2">content)</span><span class="s1">;</span>
    <span class="s2">vnode.staticCount = numberOfNodes</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">vnode</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s3">/**</span>
 <span class="s3">* </span><span class="s4">@private</span>
 <span class="s3">*/</span>
<span class="s1">function </span><span class="s2">createCommentVNode(text = </span><span class="s0">''</span><span class="s1">, </span>
<span class="s6">// when used as the v-else branch, the comment node must be created as a</span>
<span class="s6">// block to ensure correct updates.</span>
<span class="s2">asBlock = </span><span class="s1">false</span><span class="s2">) {</span>
    <span class="s1">return </span><span class="s2">asBlock</span>
        <span class="s2">? (openBlock()</span><span class="s1">, </span><span class="s2">createBlock(Comment</span><span class="s1">, null, </span><span class="s2">text))</span>
        <span class="s2">: createVNode(Comment</span><span class="s1">, null, </span><span class="s2">text)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">normalizeVNode(child) {</span>
    <span class="s1">if </span><span class="s2">(child == </span><span class="s1">null </span><span class="s2">|| </span><span class="s1">typeof </span><span class="s2">child === </span><span class="s0">'boolean'</span><span class="s2">) {</span>
        <span class="s6">// empty placeholder</span>
        <span class="s1">return </span><span class="s2">createVNode(Comment)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(shared.isArray(child)) {</span>
        <span class="s6">// fragment</span>
        <span class="s1">return </span><span class="s2">createVNode(Fragment</span><span class="s1">, null, </span>
        <span class="s6">// #3666, avoid reference pollution when reusing vnode</span>
        <span class="s2">child.slice())</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(</span><span class="s1">typeof </span><span class="s2">child === </span><span class="s0">'object'</span><span class="s2">) {</span>
        <span class="s6">// already vnode, this should be the most common since compiled templates</span>
        <span class="s6">// always produce all-vnode children arrays</span>
        <span class="s1">return </span><span class="s2">cloneIfMounted(child)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s6">// strings and numbers</span>
        <span class="s1">return </span><span class="s2">createVNode(Text</span><span class="s1">, null, </span><span class="s2">String(child))</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s6">// optimized normalization for template-compiled render fns</span>
<span class="s1">function </span><span class="s2">cloneIfMounted(child) {</span>
    <span class="s1">return </span><span class="s2">(child.el === </span><span class="s1">null </span><span class="s2">&amp;&amp; child.patchFlag !== -</span><span class="s5">1 </span><span class="s6">/* PatchFlags.HOISTED */</span><span class="s2">) ||</span>
        <span class="s2">child.memo</span>
        <span class="s2">? child</span>
        <span class="s2">: cloneVNode(child)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">normalizeChildren(vnode</span><span class="s1">, </span><span class="s2">children) {</span>
    <span class="s1">let </span><span class="s2">type = </span><span class="s5">0</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">{ shapeFlag } = vnode</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(children == </span><span class="s1">null</span><span class="s2">) {</span>
        <span class="s2">children = </span><span class="s1">null;</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(shared.isArray(children)) {</span>
        <span class="s2">type = </span><span class="s5">16 </span><span class="s6">/* ShapeFlags.ARRAY_CHILDREN */</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(</span><span class="s1">typeof </span><span class="s2">children === </span><span class="s0">'object'</span><span class="s2">) {</span>
        <span class="s1">if </span><span class="s2">(shapeFlag &amp; (</span><span class="s5">1 </span><span class="s6">/* ShapeFlags.ELEMENT */ </span><span class="s2">| </span><span class="s5">64 </span><span class="s6">/* ShapeFlags.TELEPORT */</span><span class="s2">)) {</span>
            <span class="s6">// Normalize slot to plain children for plain element and Teleport</span>
            <span class="s1">const </span><span class="s2">slot = children.default</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(slot) {</span>
                <span class="s6">// _c marker is added by withCtx() indicating this is a compiled slot</span>
                <span class="s2">slot._c &amp;&amp; (slot._d = </span><span class="s1">false</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s2">normalizeChildren(vnode</span><span class="s1">, </span><span class="s2">slot())</span><span class="s1">;</span>
                <span class="s2">slot._c &amp;&amp; (slot._d = </span><span class="s1">true</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">return;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">type = </span><span class="s5">32 </span><span class="s6">/* ShapeFlags.SLOTS_CHILDREN */</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">slotFlag = children._</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(!slotFlag &amp;&amp; !(InternalObjectKey </span><span class="s1">in </span><span class="s2">children)) {</span>
                <span class="s2">children._ctx = currentRenderingInstance</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(slotFlag === </span><span class="s5">3 </span><span class="s6">/* SlotFlags.FORWARDED */ </span><span class="s2">&amp;&amp; currentRenderingInstance) {</span>
                <span class="s6">// a child component receives forwarded slots from the parent.</span>
                <span class="s6">// its slot type is determined by its parent's slot type.</span>
                <span class="s1">if </span><span class="s2">(currentRenderingInstance.slots._ === </span><span class="s5">1 </span><span class="s6">/* SlotFlags.STABLE */</span><span class="s2">) {</span>
                    <span class="s2">children._ = </span><span class="s5">1 </span><span class="s6">/* SlotFlags.STABLE */</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s2">children._ = </span><span class="s5">2 </span><span class="s6">/* SlotFlags.DYNAMIC */</span><span class="s1">;</span>
                    <span class="s2">vnode.patchFlag |= </span><span class="s5">1024 </span><span class="s6">/* PatchFlags.DYNAMIC_SLOTS */</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(shared.isFunction(children)) {</span>
        <span class="s2">children = { </span><span class="s1">default</span><span class="s2">: children</span><span class="s1">, </span><span class="s2">_ctx: currentRenderingInstance }</span><span class="s1">;</span>
        <span class="s2">type = </span><span class="s5">32 </span><span class="s6">/* ShapeFlags.SLOTS_CHILDREN */</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s2">children = String(children)</span><span class="s1">;</span>
        <span class="s6">// force teleport children to array so it can be moved around</span>
        <span class="s1">if </span><span class="s2">(shapeFlag &amp; </span><span class="s5">64 </span><span class="s6">/* ShapeFlags.TELEPORT */</span><span class="s2">) {</span>
            <span class="s2">type = </span><span class="s5">16 </span><span class="s6">/* ShapeFlags.ARRAY_CHILDREN */</span><span class="s1">;</span>
            <span class="s2">children = [createTextVNode(children)]</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">type = </span><span class="s5">8 </span><span class="s6">/* ShapeFlags.TEXT_CHILDREN */</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s2">vnode.children = children</span><span class="s1">;</span>
    <span class="s2">vnode.shapeFlag |= type</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">mergeProps(...args) {</span>
    <span class="s1">const </span><span class="s2">ret = {}</span><span class="s1">;</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s5">0</span><span class="s1">; </span><span class="s2">i &lt; args.length</span><span class="s1">; </span><span class="s2">i++) {</span>
        <span class="s1">const </span><span class="s2">toMerge = args[i]</span><span class="s1">;</span>
        <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">key </span><span class="s1">in </span><span class="s2">toMerge) {</span>
            <span class="s1">if </span><span class="s2">(key === </span><span class="s0">'class'</span><span class="s2">) {</span>
                <span class="s1">if </span><span class="s2">(ret.class !== toMerge.class) {</span>
                    <span class="s2">ret.class = shared.normalizeClass([ret.class</span><span class="s1">, </span><span class="s2">toMerge.class])</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(key === </span><span class="s0">'style'</span><span class="s2">) {</span>
                <span class="s2">ret.style = shared.normalizeStyle([ret.style</span><span class="s1">, </span><span class="s2">toMerge.style])</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(shared.isOn(key)) {</span>
                <span class="s1">const </span><span class="s2">existing = ret[key]</span><span class="s1">;</span>
                <span class="s1">const </span><span class="s2">incoming = toMerge[key]</span><span class="s1">;</span>
                <span class="s1">if </span><span class="s2">(incoming &amp;&amp;</span>
                    <span class="s2">existing !== incoming &amp;&amp;</span>
                    <span class="s2">!(shared.isArray(existing) &amp;&amp; existing.includes(incoming))) {</span>
                    <span class="s2">ret[key] = existing</span>
                        <span class="s2">? [].concat(existing</span><span class="s1">, </span><span class="s2">incoming)</span>
                        <span class="s2">: incoming</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s1">else if </span><span class="s2">(key !== </span><span class="s0">''</span><span class="s2">) {</span>
                <span class="s2">ret[key] = toMerge[key]</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">ret</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">invokeVNodeHook(hook</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s2">vnode</span><span class="s1">, </span><span class="s2">prevVNode = </span><span class="s1">null</span><span class="s2">) {</span>
    <span class="s2">callWithAsyncErrorHandling(hook</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s5">7 </span><span class="s6">/* ErrorCodes.VNODE_HOOK */</span><span class="s1">, </span><span class="s2">[</span>
        <span class="s2">vnode</span><span class="s1">,</span>
        <span class="s2">prevVNode</span>
    <span class="s2">])</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s1">const </span><span class="s2">emptyAppContext = createAppContext()</span><span class="s1">;</span>
<span class="s1">let </span><span class="s2">uid = </span><span class="s5">0</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">createComponentInstance(vnode</span><span class="s1">, </span><span class="s2">parent</span><span class="s1">, </span><span class="s2">suspense) {</span>
    <span class="s1">const </span><span class="s2">type = vnode.type</span><span class="s1">;</span>
    <span class="s6">// inherit parent app context - or - if root, adopt from root vnode</span>
    <span class="s1">const </span><span class="s2">appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">instance = {</span>
        <span class="s2">uid: uid++</span><span class="s1">,</span>
        <span class="s2">vnode</span><span class="s1">,</span>
        <span class="s2">type</span><span class="s1">,</span>
        <span class="s2">parent</span><span class="s1">,</span>
        <span class="s2">appContext</span><span class="s1">,</span>
        <span class="s2">root: </span><span class="s1">null,</span>
        <span class="s2">next: </span><span class="s1">null,</span>
        <span class="s2">subTree: </span><span class="s1">null,</span>
        <span class="s2">effect: </span><span class="s1">null,</span>
        <span class="s2">update: </span><span class="s1">null,</span>
        <span class="s2">scope: </span><span class="s1">new </span><span class="s2">reactivity.EffectScope(</span><span class="s1">true </span><span class="s6">/* detached */</span><span class="s2">)</span><span class="s1">,</span>
        <span class="s2">render: </span><span class="s1">null,</span>
        <span class="s2">proxy: </span><span class="s1">null,</span>
        <span class="s2">exposed: </span><span class="s1">null,</span>
        <span class="s2">exposeProxy: </span><span class="s1">null,</span>
        <span class="s2">withProxy: </span><span class="s1">null,</span>
        <span class="s2">provides: parent ? parent.provides : Object.create(appContext.provides)</span><span class="s1">,</span>
        <span class="s2">accessCache: </span><span class="s1">null,</span>
        <span class="s2">renderCache: []</span><span class="s1">,</span>
        <span class="s6">// local resolved assets</span>
        <span class="s2">components: </span><span class="s1">null,</span>
        <span class="s2">directives: </span><span class="s1">null,</span>
        <span class="s6">// resolved props and emits options</span>
        <span class="s2">propsOptions: normalizePropsOptions(type</span><span class="s1">, </span><span class="s2">appContext)</span><span class="s1">,</span>
        <span class="s2">emitsOptions: normalizeEmitsOptions(type</span><span class="s1">, </span><span class="s2">appContext)</span><span class="s1">,</span>
        <span class="s6">// emit</span>
        <span class="s2">emit: </span><span class="s1">null,</span>
        <span class="s2">emitted: </span><span class="s1">null,</span>
        <span class="s6">// props default value</span>
        <span class="s2">propsDefaults: shared.EMPTY_OBJ</span><span class="s1">,</span>
        <span class="s6">// inheritAttrs</span>
        <span class="s2">inheritAttrs: type.inheritAttrs</span><span class="s1">,</span>
        <span class="s6">// state</span>
        <span class="s2">ctx: shared.EMPTY_OBJ</span><span class="s1">,</span>
        <span class="s2">data: shared.EMPTY_OBJ</span><span class="s1">,</span>
        <span class="s2">props: shared.EMPTY_OBJ</span><span class="s1">,</span>
        <span class="s2">attrs: shared.EMPTY_OBJ</span><span class="s1">,</span>
        <span class="s2">slots: shared.EMPTY_OBJ</span><span class="s1">,</span>
        <span class="s2">refs: shared.EMPTY_OBJ</span><span class="s1">,</span>
        <span class="s2">setupState: shared.EMPTY_OBJ</span><span class="s1">,</span>
        <span class="s2">setupContext: </span><span class="s1">null,</span>
        <span class="s6">// suspense related</span>
        <span class="s2">suspense</span><span class="s1">,</span>
        <span class="s2">suspenseId: suspense ? suspense.pendingId : </span><span class="s5">0</span><span class="s1">,</span>
        <span class="s2">asyncDep: </span><span class="s1">null,</span>
        <span class="s2">asyncResolved: </span><span class="s1">false,</span>
        <span class="s6">// lifecycle hooks</span>
        <span class="s6">// not using enums here because it results in computed properties</span>
        <span class="s2">isMounted: </span><span class="s1">false,</span>
        <span class="s2">isUnmounted: </span><span class="s1">false,</span>
        <span class="s2">isDeactivated: </span><span class="s1">false,</span>
        <span class="s2">bc: </span><span class="s1">null,</span>
        <span class="s2">c: </span><span class="s1">null,</span>
        <span class="s2">bm: </span><span class="s1">null,</span>
        <span class="s2">m: </span><span class="s1">null,</span>
        <span class="s2">bu: </span><span class="s1">null,</span>
        <span class="s2">u: </span><span class="s1">null,</span>
        <span class="s2">um: </span><span class="s1">null,</span>
        <span class="s2">bum: </span><span class="s1">null,</span>
        <span class="s2">da: </span><span class="s1">null,</span>
        <span class="s2">a: </span><span class="s1">null,</span>
        <span class="s2">rtg: </span><span class="s1">null,</span>
        <span class="s2">rtc: </span><span class="s1">null,</span>
        <span class="s2">ec: </span><span class="s1">null,</span>
        <span class="s2">sp: </span><span class="s1">null</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s2">{</span>
        <span class="s2">instance.ctx = { _: instance }</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s2">instance.root = parent ? parent.root : instance</span><span class="s1">;</span>
    <span class="s2">instance.emit = emit.bind(</span><span class="s1">null, </span><span class="s2">instance)</span><span class="s1">;</span>
    <span class="s6">// apply custom element special handling</span>
    <span class="s1">if </span><span class="s2">(vnode.ce) {</span>
        <span class="s2">vnode.ce(instance)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">instance</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">let </span><span class="s2">currentInstance = </span><span class="s1">null;</span>
<span class="s1">const </span><span class="s2">getCurrentInstance = () =&gt; currentInstance || currentRenderingInstance</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">setCurrentInstance = (instance) =&gt; {</span>
    <span class="s2">currentInstance = instance</span><span class="s1">;</span>
    <span class="s2">instance.scope.on()</span><span class="s1">;</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">unsetCurrentInstance = () =&gt; {</span>
    <span class="s2">currentInstance &amp;&amp; currentInstance.scope.off()</span><span class="s1">;</span>
    <span class="s2">currentInstance = </span><span class="s1">null;</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">isStatefulComponent(instance) {</span>
    <span class="s1">return </span><span class="s2">instance.vnode.shapeFlag &amp; </span><span class="s5">4 </span><span class="s6">/* ShapeFlags.STATEFUL_COMPONENT */</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">let </span><span class="s2">isInSSRComponentSetup = </span><span class="s1">false;</span>
<span class="s1">function </span><span class="s2">setupComponent(instance</span><span class="s1">, </span><span class="s2">isSSR = </span><span class="s1">false</span><span class="s2">) {</span>
    <span class="s2">isInSSRComponentSetup = isSSR</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">{ props</span><span class="s1">, </span><span class="s2">children } = instance.vnode</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">isStateful = isStatefulComponent(instance)</span><span class="s1">;</span>
    <span class="s2">initProps(instance</span><span class="s1">, </span><span class="s2">props</span><span class="s1">, </span><span class="s2">isStateful</span><span class="s1">, </span><span class="s2">isSSR)</span><span class="s1">;</span>
    <span class="s2">initSlots(instance</span><span class="s1">, </span><span class="s2">children)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">setupResult = isStateful</span>
        <span class="s2">? setupStatefulComponent(instance</span><span class="s1">, </span><span class="s2">isSSR)</span>
        <span class="s2">: undefined</span><span class="s1">;</span>
    <span class="s2">isInSSRComponentSetup = </span><span class="s1">false;</span>
    <span class="s1">return </span><span class="s2">setupResult</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">setupStatefulComponent(instance</span><span class="s1">, </span><span class="s2">isSSR) {</span>
    <span class="s1">const </span><span class="s2">Component = instance.type</span><span class="s1">;</span>
    <span class="s6">// 0. create render proxy property access cache</span>
    <span class="s2">instance.accessCache = Object.create(</span><span class="s1">null</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s6">// 1. create public instance / render proxy</span>
    <span class="s6">// also mark it raw so it's never observed</span>
    <span class="s2">instance.proxy = reactivity.markRaw(</span><span class="s1">new </span><span class="s2">Proxy(instance.ctx</span><span class="s1">, </span><span class="s2">PublicInstanceProxyHandlers))</span><span class="s1">;</span>
    <span class="s6">// 2. call setup()</span>
    <span class="s1">const </span><span class="s2">{ setup } = Component</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(setup) {</span>
        <span class="s1">const </span><span class="s2">setupContext = (instance.setupContext =</span>
            <span class="s2">setup.length &gt; </span><span class="s5">1 </span><span class="s2">? createSetupContext(instance) : </span><span class="s1">null</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">setCurrentInstance(instance)</span><span class="s1">;</span>
        <span class="s2">reactivity.pauseTracking()</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">setupResult = callWithErrorHandling(setup</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s5">0 </span><span class="s6">/* ErrorCodes.SETUP_FUNCTION */</span><span class="s1">, </span><span class="s2">[instance.props</span><span class="s1">, </span><span class="s2">setupContext])</span><span class="s1">;</span>
        <span class="s2">reactivity.resetTracking()</span><span class="s1">;</span>
        <span class="s2">unsetCurrentInstance()</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(shared.isPromise(setupResult)) {</span>
            <span class="s2">setupResult.then(unsetCurrentInstance</span><span class="s1">, </span><span class="s2">unsetCurrentInstance)</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(isSSR) {</span>
                <span class="s6">// return the promise so server-renderer can wait on it</span>
                <span class="s1">return </span><span class="s2">setupResult</span>
                    <span class="s2">.then((resolvedResult) =&gt; {</span>
                    <span class="s2">handleSetupResult(instance</span><span class="s1">, </span><span class="s2">resolvedResult</span><span class="s1">, </span><span class="s2">isSSR)</span><span class="s1">;</span>
                <span class="s2">})</span>
                    <span class="s2">.catch(e =&gt; {</span>
                    <span class="s2">handleError(e</span><span class="s1">, </span><span class="s2">instance</span><span class="s1">, </span><span class="s5">0 </span><span class="s6">/* ErrorCodes.SETUP_FUNCTION */</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s2">})</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s6">// async setup returned Promise.</span>
                <span class="s6">// bail here and wait for re-entry.</span>
                <span class="s2">instance.asyncDep = setupResult</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">handleSetupResult(instance</span><span class="s1">, </span><span class="s2">setupResult</span><span class="s1">, </span><span class="s2">isSSR)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s2">finishComponentSetup(instance</span><span class="s1">, </span><span class="s2">isSSR)</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">handleSetupResult(instance</span><span class="s1">, </span><span class="s2">setupResult</span><span class="s1">, </span><span class="s2">isSSR) {</span>
    <span class="s1">if </span><span class="s2">(shared.isFunction(setupResult)) {</span>
        <span class="s6">// setup returned an inline render function</span>
        <span class="s1">if </span><span class="s2">(instance.type.__ssrInlineRender) {</span>
            <span class="s6">// when the function's name is `ssrRender` (compiled by SFC inline mode),</span>
            <span class="s6">// set it as ssrRender instead.</span>
            <span class="s2">instance.ssrRender = setupResult</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s2">instance.render = setupResult</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(shared.isObject(setupResult)) {</span>
        <span class="s2">instance.setupState = reactivity.proxyRefs(setupResult)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else ;</span>
    <span class="s2">finishComponentSetup(instance</span><span class="s1">, </span><span class="s2">isSSR)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">let </span><span class="s2">compile</span><span class="s1">;</span>
<span class="s1">let </span><span class="s2">installWithProxy</span><span class="s1">;</span>
<span class="s3">/**</span>
 <span class="s3">* For runtime-dom to register the compiler.</span>
 <span class="s3">* Note the exported method uses any to avoid d.ts relying on the compiler types.</span>
 <span class="s3">*/</span>
<span class="s1">function </span><span class="s2">registerRuntimeCompiler(_compile) {</span>
    <span class="s2">compile = _compile</span><span class="s1">;</span>
    <span class="s2">installWithProxy = i =&gt; {</span>
        <span class="s1">if </span><span class="s2">(i.render._rc) {</span>
            <span class="s2">i.withProxy = </span><span class="s1">new </span><span class="s2">Proxy(i.ctx</span><span class="s1">, </span><span class="s2">RuntimeCompiledPublicInstanceProxyHandlers)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s6">// dev only</span>
<span class="s1">const </span><span class="s2">isRuntimeOnly = () =&gt; !compile</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">finishComponentSetup(instance</span><span class="s1">, </span><span class="s2">isSSR</span><span class="s1">, </span><span class="s2">skipOptions) {</span>
    <span class="s1">const </span><span class="s2">Component = instance.type</span><span class="s1">;</span>
    <span class="s6">// template / render function normalization</span>
    <span class="s6">// could be already set when returned from setup()</span>
    <span class="s1">if </span><span class="s2">(!instance.render) {</span>
        <span class="s6">// only do on-the-fly compile if not in SSR - SSR on-the-fly compilation</span>
        <span class="s6">// is done by server-renderer</span>
        <span class="s1">if </span><span class="s2">(!isSSR &amp;&amp; compile &amp;&amp; !Component.render) {</span>
            <span class="s1">const </span><span class="s2">template = Component.template ||</span>
                <span class="s2">resolveMergedOptions(instance).template</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(template) {</span>
                <span class="s1">const </span><span class="s2">{ isCustomElement</span><span class="s1">, </span><span class="s2">compilerOptions } = instance.appContext.config</span><span class="s1">;</span>
                <span class="s1">const </span><span class="s2">{ delimiters</span><span class="s1">, </span><span class="s2">compilerOptions: componentCompilerOptions } = Component</span><span class="s1">;</span>
                <span class="s1">const </span><span class="s2">finalCompilerOptions = shared.extend(shared.extend({</span>
                    <span class="s2">isCustomElement</span><span class="s1">,</span>
                    <span class="s2">delimiters</span>
                <span class="s2">}</span><span class="s1">, </span><span class="s2">compilerOptions)</span><span class="s1">, </span><span class="s2">componentCompilerOptions)</span><span class="s1">;</span>
                <span class="s2">Component.render = compile(template</span><span class="s1">, </span><span class="s2">finalCompilerOptions)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s2">instance.render = (Component.render || shared.NOOP)</span><span class="s1">;</span>
        <span class="s6">// for runtime-compiled render functions using `with` blocks, the render</span>
        <span class="s6">// proxy used needs a different `has` handler which is more performant and</span>
        <span class="s6">// also only allows a whitelist of globals to fallthrough.</span>
        <span class="s1">if </span><span class="s2">(installWithProxy) {</span>
            <span class="s2">installWithProxy(instance)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s6">// support for 2.x options</span>
    <span class="s2">{</span>
        <span class="s2">setCurrentInstance(instance)</span><span class="s1">;</span>
        <span class="s2">reactivity.pauseTracking()</span><span class="s1">;</span>
        <span class="s2">applyOptions(instance)</span><span class="s1">;</span>
        <span class="s2">reactivity.resetTracking()</span><span class="s1">;</span>
        <span class="s2">unsetCurrentInstance()</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">createAttrsProxy(instance) {</span>
    <span class="s1">return new </span><span class="s2">Proxy(instance.attrs</span><span class="s1">, </span><span class="s2">{</span>
            <span class="s2">get(target</span><span class="s1">, </span><span class="s2">key) {</span>
                <span class="s2">reactivity.track(instance</span><span class="s1">, </span><span class="s0">&quot;get&quot; </span><span class="s6">/* TrackOpTypes.GET */</span><span class="s1">, </span><span class="s0">'$attrs'</span><span class="s2">)</span><span class="s1">;</span>
                <span class="s1">return </span><span class="s2">target[key]</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">})</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">createSetupContext(instance) {</span>
    <span class="s1">const </span><span class="s2">expose = exposed =&gt; {</span>
        <span class="s2">instance.exposed = exposed || {}</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">attrs</span><span class="s1">;</span>
    <span class="s2">{</span>
        <span class="s1">return </span><span class="s2">{</span>
            <span class="s2">get attrs() {</span>
                <span class="s1">return </span><span class="s2">attrs || (attrs = createAttrsProxy(instance))</span><span class="s1">;</span>
            <span class="s2">}</span><span class="s1">,</span>
            <span class="s2">slots: instance.slots</span><span class="s1">,</span>
            <span class="s2">emit: instance.emit</span><span class="s1">,</span>
            <span class="s2">expose</span>
        <span class="s2">}</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">getExposeProxy(instance) {</span>
    <span class="s1">if </span><span class="s2">(instance.exposed) {</span>
        <span class="s1">return </span><span class="s2">(instance.exposeProxy ||</span>
            <span class="s2">(instance.exposeProxy = </span><span class="s1">new </span><span class="s2">Proxy(reactivity.proxyRefs(reactivity.markRaw(instance.exposed))</span><span class="s1">, </span><span class="s2">{</span>
                <span class="s2">get(target</span><span class="s1">, </span><span class="s2">key) {</span>
                    <span class="s1">if </span><span class="s2">(key </span><span class="s1">in </span><span class="s2">target) {</span>
                        <span class="s1">return </span><span class="s2">target[key]</span><span class="s1">;</span>
                    <span class="s2">}</span>
                    <span class="s1">else if </span><span class="s2">(key </span><span class="s1">in </span><span class="s2">publicPropertiesMap) {</span>
                        <span class="s1">return </span><span class="s2">publicPropertiesMap[key](instance)</span><span class="s1">;</span>
                    <span class="s2">}</span>
                <span class="s2">}</span><span class="s1">,</span>
                <span class="s2">has(target</span><span class="s1">, </span><span class="s2">key) {</span>
                    <span class="s1">return </span><span class="s2">key </span><span class="s1">in </span><span class="s2">target || key </span><span class="s1">in </span><span class="s2">publicPropertiesMap</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">})))</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">getComponentName(Component</span><span class="s1">, </span><span class="s2">includeInferred = </span><span class="s1">true</span><span class="s2">) {</span>
    <span class="s1">return </span><span class="s2">shared.isFunction(Component)</span>
        <span class="s2">? Component.displayName || Component.name</span>
        <span class="s2">: Component.name || (includeInferred &amp;&amp; Component.__name)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">isClassComponent(value) {</span>
    <span class="s1">return </span><span class="s2">shared.isFunction(value) &amp;&amp; </span><span class="s0">'__vccOpts' </span><span class="s1">in </span><span class="s2">value</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s1">const </span><span class="s2">computed = ((getterOrOptions</span><span class="s1">, </span><span class="s2">debugOptions) =&gt; {</span>
    <span class="s6">// @ts-ignore</span>
    <span class="s1">return </span><span class="s2">reactivity.computed(getterOrOptions</span><span class="s1">, </span><span class="s2">debugOptions</span><span class="s1">, </span><span class="s2">isInSSRComponentSetup)</span><span class="s1">;</span>
<span class="s2">})</span><span class="s1">;</span>

<span class="s6">// implementation</span>
<span class="s1">function </span><span class="s2">defineProps() {</span>
    <span class="s1">return null;</span>
<span class="s2">}</span>
<span class="s6">// implementation</span>
<span class="s1">function </span><span class="s2">defineEmits() {</span>
    <span class="s1">return null;</span>
<span class="s2">}</span>
<span class="s3">/**</span>
 <span class="s3">* Vue `&lt;script setup&gt;` compiler macro for declaring a component's exposed</span>
 <span class="s3">* instance properties when it is accessed by a parent component via template</span>
 <span class="s3">* refs.</span>
 <span class="s3">*</span>
 <span class="s3">* `&lt;script setup&gt;` components are closed by default - i.e. variables inside</span>
 <span class="s3">* the `&lt;script setup&gt;` scope is not exposed to parent unless explicitly exposed</span>
 <span class="s3">* via `defineExpose`.</span>
 <span class="s3">*</span>
 <span class="s3">* This is only usable inside `&lt;script setup&gt;`, is compiled away in the</span>
 <span class="s3">* output and should **not** be actually called at runtime.</span>
 <span class="s3">*/</span>
<span class="s1">function </span><span class="s2">defineExpose(exposed) {</span>
<span class="s2">}</span>
<span class="s3">/**</span>
 <span class="s3">* Vue `&lt;script setup&gt;` compiler macro for providing props default values when</span>
 <span class="s3">* using type-based `defineProps` declaration.</span>
 <span class="s3">*</span>
 <span class="s3">* Example usage:</span>
 <span class="s3">* ```ts</span>
 <span class="s3">* withDefaults(defineProps&lt;{</span>
 <span class="s3">*   size?: number</span>
 <span class="s3">*   labels?: string[]</span>
 <span class="s3">* }&gt;(), {</span>
 <span class="s3">*   size: 3,</span>
 <span class="s3">*   labels: () =&gt; ['default label']</span>
 <span class="s3">* })</span>
 <span class="s3">* ```</span>
 <span class="s3">*</span>
 <span class="s3">* This is only usable inside `&lt;script setup&gt;`, is compiled away in the output</span>
 <span class="s3">* and should **not** be actually called at runtime.</span>
 <span class="s3">*/</span>
<span class="s1">function </span><span class="s2">withDefaults(props</span><span class="s1">, </span><span class="s2">defaults) {</span>
    <span class="s1">return null;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">useSlots() {</span>
    <span class="s1">return </span><span class="s2">getContext().slots</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">useAttrs() {</span>
    <span class="s1">return </span><span class="s2">getContext().attrs</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">getContext() {</span>
    <span class="s1">const </span><span class="s2">i = getCurrentInstance()</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">i.setupContext || (i.setupContext = createSetupContext(i))</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s3">/**</span>
 <span class="s3">* Runtime helper for merging default declarations. Imported by compiled code</span>
 <span class="s3">* only.</span>
 <span class="s3">* </span><span class="s4">@internal</span>
 <span class="s3">*/</span>
<span class="s1">function </span><span class="s2">mergeDefaults(raw</span><span class="s1">, </span><span class="s2">defaults) {</span>
    <span class="s1">const </span><span class="s2">props = shared.isArray(raw)</span>
        <span class="s2">? raw.reduce((normalized</span><span class="s1">, </span><span class="s2">p) =&gt; ((normalized[p] = {})</span><span class="s1">, </span><span class="s2">normalized)</span><span class="s1">, </span><span class="s2">{})</span>
        <span class="s2">: raw</span><span class="s1">;</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">key </span><span class="s1">in </span><span class="s2">defaults) {</span>
        <span class="s1">const </span><span class="s2">opt = props[key]</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(opt) {</span>
            <span class="s1">if </span><span class="s2">(shared.isArray(opt) || shared.isFunction(opt)) {</span>
                <span class="s2">props[key] = { type: opt</span><span class="s1">, default</span><span class="s2">: defaults[key] }</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s2">opt.default = defaults[key]</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(opt === </span><span class="s1">null</span><span class="s2">) {</span>
            <span class="s2">props[key] = { </span><span class="s1">default</span><span class="s2">: defaults[key] }</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else ;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">props</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s3">/**</span>
 <span class="s3">* Used to create a proxy for the rest element when destructuring props with</span>
 <span class="s3">* defineProps().</span>
 <span class="s3">* </span><span class="s4">@internal</span>
 <span class="s3">*/</span>
<span class="s1">function </span><span class="s2">createPropsRestProxy(props</span><span class="s1">, </span><span class="s2">excludedKeys) {</span>
    <span class="s1">const </span><span class="s2">ret = {}</span><span class="s1">;</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">key </span><span class="s1">in </span><span class="s2">props) {</span>
        <span class="s1">if </span><span class="s2">(!excludedKeys.includes(key)) {</span>
            <span class="s2">Object.defineProperty(ret</span><span class="s1">, </span><span class="s2">key</span><span class="s1">, </span><span class="s2">{</span>
                <span class="s2">enumerable: </span><span class="s1">true,</span>
                <span class="s2">get: () =&gt; props[key]</span>
            <span class="s2">})</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">ret</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s3">/**</span>
 <span class="s3">* `&lt;script setup&gt;` helper for persisting the current instance context over</span>
 <span class="s3">* async/await flows.</span>
 <span class="s3">*</span>
 <span class="s3">* `@vue/compiler-sfc` converts the following:</span>
 <span class="s3">*</span>
 <span class="s3">* ```ts</span>
 <span class="s3">* const x = await foo()</span>
 <span class="s3">* ```</span>
 <span class="s3">*</span>
 <span class="s3">* into:</span>
 <span class="s3">*</span>
 <span class="s3">* ```ts</span>
 <span class="s3">* let __temp, __restore</span>
 <span class="s3">* const x = (([__temp, __restore] = withAsyncContext(() =&gt; foo())),__temp=await __temp,__restore(),__temp)</span>
 <span class="s3">* ```</span>
 <span class="s3">* </span><span class="s4">@internal</span>
 <span class="s3">*/</span>
<span class="s1">function </span><span class="s2">withAsyncContext(getAwaitable) {</span>
    <span class="s1">const </span><span class="s2">ctx = getCurrentInstance()</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">awaitable = getAwaitable()</span><span class="s1">;</span>
    <span class="s2">unsetCurrentInstance()</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(shared.isPromise(awaitable)) {</span>
        <span class="s2">awaitable = awaitable.catch(e =&gt; {</span>
            <span class="s2">setCurrentInstance(ctx)</span><span class="s1">;</span>
            <span class="s1">throw </span><span class="s2">e</span><span class="s1">;</span>
        <span class="s2">})</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">[awaitable</span><span class="s1">, </span><span class="s2">() =&gt; setCurrentInstance(ctx)]</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s6">// Actual implementation</span>
<span class="s1">function </span><span class="s2">h(type</span><span class="s1">, </span><span class="s2">propsOrChildren</span><span class="s1">, </span><span class="s2">children) {</span>
    <span class="s1">const </span><span class="s2">l = arguments.length</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(l === </span><span class="s5">2</span><span class="s2">) {</span>
        <span class="s1">if </span><span class="s2">(shared.isObject(propsOrChildren) &amp;&amp; !shared.isArray(propsOrChildren)) {</span>
            <span class="s6">// single vnode without props</span>
            <span class="s1">if </span><span class="s2">(isVNode(propsOrChildren)) {</span>
                <span class="s1">return </span><span class="s2">createVNode(type</span><span class="s1">, null, </span><span class="s2">[propsOrChildren])</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s6">// props without children</span>
            <span class="s1">return </span><span class="s2">createVNode(type</span><span class="s1">, </span><span class="s2">propsOrChildren)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else </span><span class="s2">{</span>
            <span class="s6">// omit props</span>
            <span class="s1">return </span><span class="s2">createVNode(type</span><span class="s1">, null, </span><span class="s2">propsOrChildren)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">else </span><span class="s2">{</span>
        <span class="s1">if </span><span class="s2">(l &gt; </span><span class="s5">3</span><span class="s2">) {</span>
            <span class="s2">children = Array.prototype.slice.call(arguments</span><span class="s1">, </span><span class="s5">2</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(l === </span><span class="s5">3 </span><span class="s2">&amp;&amp; isVNode(children)) {</span>
            <span class="s2">children = [children]</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">return </span><span class="s2">createVNode(type</span><span class="s1">, </span><span class="s2">propsOrChildren</span><span class="s1">, </span><span class="s2">children)</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>

<span class="s1">const </span><span class="s2">ssrContextKey = Symbol(</span><span class="s0">``</span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">useSSRContext = () =&gt; {</span>
    <span class="s2">{</span>
        <span class="s1">const </span><span class="s2">ctx = inject(ssrContextKey)</span><span class="s1">;</span>
        <span class="s1">return </span><span class="s2">ctx</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span><span class="s1">;</span>

<span class="s1">function </span><span class="s2">initCustomFormatter() {</span>
    <span class="s6">/* eslint-disable no-restricted-globals */</span>
    <span class="s2">{</span>
        <span class="s1">return;</span>
    <span class="s2">}</span>
<span class="s2">}</span>

<span class="s1">function </span><span class="s2">withMemo(memo</span><span class="s1">, </span><span class="s2">render</span><span class="s1">, </span><span class="s2">cache</span><span class="s1">, </span><span class="s2">index) {</span>
    <span class="s1">const </span><span class="s2">cached = cache[index]</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(cached &amp;&amp; isMemoSame(cached</span><span class="s1">, </span><span class="s2">memo)) {</span>
        <span class="s1">return </span><span class="s2">cached</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">ret = render()</span><span class="s1">;</span>
    <span class="s6">// shallow clone</span>
    <span class="s2">ret.memo = memo.slice()</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">(cache[index] = ret)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">isMemoSame(cached</span><span class="s1">, </span><span class="s2">memo) {</span>
    <span class="s1">const </span><span class="s2">prev = cached.memo</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(prev.length != memo.length) {</span>
        <span class="s1">return false;</span>
    <span class="s2">}</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s5">0</span><span class="s1">; </span><span class="s2">i &lt; prev.length</span><span class="s1">; </span><span class="s2">i++) {</span>
        <span class="s1">if </span><span class="s2">(shared.hasChanged(prev[i]</span><span class="s1">, </span><span class="s2">memo[i])) {</span>
            <span class="s1">return false;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s6">// make sure to let parent block track it when returning cached</span>
    <span class="s1">if </span><span class="s2">(isBlockTreeEnabled &gt; </span><span class="s5">0 </span><span class="s2">&amp;&amp; currentBlock) {</span>
        <span class="s2">currentBlock.push(cached)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return true;</span>
<span class="s2">}</span>

<span class="s6">// Core API ------------------------------------------------------------------</span>
<span class="s1">const </span><span class="s2">version = </span><span class="s0">&quot;3.2.47&quot;</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">_ssrUtils = {</span>
    <span class="s2">createComponentInstance</span><span class="s1">,</span>
    <span class="s2">setupComponent</span><span class="s1">,</span>
    <span class="s2">renderComponentRoot</span><span class="s1">,</span>
    <span class="s2">setCurrentRenderingInstance</span><span class="s1">,</span>
    <span class="s2">isVNode</span><span class="s1">,</span>
    <span class="s2">normalizeVNode</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s3">/**</span>
 <span class="s3">* SSR utils for \@vue/server-renderer. Only exposed in ssr-possible builds.</span>
 <span class="s3">* </span><span class="s4">@internal</span>
 <span class="s3">*/</span>
<span class="s1">const </span><span class="s2">ssrUtils = (_ssrUtils )</span><span class="s1">;</span>
<span class="s3">/**</span>
 <span class="s3">* </span><span class="s4">@internal </span><span class="s3">only exposed in compat builds</span>
 <span class="s3">*/</span>
<span class="s1">const </span><span class="s2">resolveFilter = </span><span class="s1">null;</span>
<span class="s3">/**</span>
 <span class="s3">* </span><span class="s4">@internal </span><span class="s3">only exposed in compat builds.</span>
 <span class="s3">*/</span>
<span class="s1">const </span><span class="s2">compatUtils = (</span><span class="s1">null</span><span class="s2">)</span><span class="s1">;</span>

<span class="s2">exports.EffectScope = reactivity.EffectScope</span><span class="s1">;</span>
<span class="s2">exports.ReactiveEffect = reactivity.ReactiveEffect</span><span class="s1">;</span>
<span class="s2">exports.customRef = reactivity.customRef</span><span class="s1">;</span>
<span class="s2">exports.effect = reactivity.effect</span><span class="s1">;</span>
<span class="s2">exports.effectScope = reactivity.effectScope</span><span class="s1">;</span>
<span class="s2">exports.getCurrentScope = reactivity.getCurrentScope</span><span class="s1">;</span>
<span class="s2">exports.isProxy = reactivity.isProxy</span><span class="s1">;</span>
<span class="s2">exports.isReactive = reactivity.isReactive</span><span class="s1">;</span>
<span class="s2">exports.isReadonly = reactivity.isReadonly</span><span class="s1">;</span>
<span class="s2">exports.isRef = reactivity.isRef</span><span class="s1">;</span>
<span class="s2">exports.isShallow = reactivity.isShallow</span><span class="s1">;</span>
<span class="s2">exports.markRaw = reactivity.markRaw</span><span class="s1">;</span>
<span class="s2">exports.onScopeDispose = reactivity.onScopeDispose</span><span class="s1">;</span>
<span class="s2">exports.proxyRefs = reactivity.proxyRefs</span><span class="s1">;</span>
<span class="s2">exports.reactive = reactivity.reactive</span><span class="s1">;</span>
<span class="s2">exports.readonly = reactivity.readonly</span><span class="s1">;</span>
<span class="s2">exports.ref = reactivity.ref</span><span class="s1">;</span>
<span class="s2">exports.shallowReactive = reactivity.shallowReactive</span><span class="s1">;</span>
<span class="s2">exports.shallowReadonly = reactivity.shallowReadonly</span><span class="s1">;</span>
<span class="s2">exports.shallowRef = reactivity.shallowRef</span><span class="s1">;</span>
<span class="s2">exports.stop = reactivity.stop</span><span class="s1">;</span>
<span class="s2">exports.toRaw = reactivity.toRaw</span><span class="s1">;</span>
<span class="s2">exports.toRef = reactivity.toRef</span><span class="s1">;</span>
<span class="s2">exports.toRefs = reactivity.toRefs</span><span class="s1">;</span>
<span class="s2">exports.triggerRef = reactivity.triggerRef</span><span class="s1">;</span>
<span class="s2">exports.unref = reactivity.unref</span><span class="s1">;</span>
<span class="s2">exports.camelize = shared.camelize</span><span class="s1">;</span>
<span class="s2">exports.capitalize = shared.capitalize</span><span class="s1">;</span>
<span class="s2">exports.normalizeClass = shared.normalizeClass</span><span class="s1">;</span>
<span class="s2">exports.normalizeProps = shared.normalizeProps</span><span class="s1">;</span>
<span class="s2">exports.normalizeStyle = shared.normalizeStyle</span><span class="s1">;</span>
<span class="s2">exports.toDisplayString = shared.toDisplayString</span><span class="s1">;</span>
<span class="s2">exports.toHandlerKey = shared.toHandlerKey</span><span class="s1">;</span>
<span class="s2">exports.BaseTransition = BaseTransition</span><span class="s1">;</span>
<span class="s2">exports.Comment = Comment</span><span class="s1">;</span>
<span class="s2">exports.Fragment = Fragment</span><span class="s1">;</span>
<span class="s2">exports.KeepAlive = KeepAlive</span><span class="s1">;</span>
<span class="s2">exports.Static = Static</span><span class="s1">;</span>
<span class="s2">exports.Suspense = Suspense</span><span class="s1">;</span>
<span class="s2">exports.Teleport = Teleport</span><span class="s1">;</span>
<span class="s2">exports.Text = Text</span><span class="s1">;</span>
<span class="s2">exports.assertNumber = assertNumber</span><span class="s1">;</span>
<span class="s2">exports.callWithAsyncErrorHandling = callWithAsyncErrorHandling</span><span class="s1">;</span>
<span class="s2">exports.callWithErrorHandling = callWithErrorHandling</span><span class="s1">;</span>
<span class="s2">exports.cloneVNode = cloneVNode</span><span class="s1">;</span>
<span class="s2">exports.compatUtils = compatUtils</span><span class="s1">;</span>
<span class="s2">exports.computed = computed</span><span class="s1">;</span>
<span class="s2">exports.createBlock = createBlock</span><span class="s1">;</span>
<span class="s2">exports.createCommentVNode = createCommentVNode</span><span class="s1">;</span>
<span class="s2">exports.createElementBlock = createElementBlock</span><span class="s1">;</span>
<span class="s2">exports.createElementVNode = createBaseVNode</span><span class="s1">;</span>
<span class="s2">exports.createHydrationRenderer = createHydrationRenderer</span><span class="s1">;</span>
<span class="s2">exports.createPropsRestProxy = createPropsRestProxy</span><span class="s1">;</span>
<span class="s2">exports.createRenderer = createRenderer</span><span class="s1">;</span>
<span class="s2">exports.createSlots = createSlots</span><span class="s1">;</span>
<span class="s2">exports.createStaticVNode = createStaticVNode</span><span class="s1">;</span>
<span class="s2">exports.createTextVNode = createTextVNode</span><span class="s1">;</span>
<span class="s2">exports.createVNode = createVNode</span><span class="s1">;</span>
<span class="s2">exports.defineAsyncComponent = defineAsyncComponent</span><span class="s1">;</span>
<span class="s2">exports.defineComponent = defineComponent</span><span class="s1">;</span>
<span class="s2">exports.defineEmits = defineEmits</span><span class="s1">;</span>
<span class="s2">exports.defineExpose = defineExpose</span><span class="s1">;</span>
<span class="s2">exports.defineProps = defineProps</span><span class="s1">;</span>
<span class="s2">exports.getCurrentInstance = getCurrentInstance</span><span class="s1">;</span>
<span class="s2">exports.getTransitionRawChildren = getTransitionRawChildren</span><span class="s1">;</span>
<span class="s2">exports.guardReactiveProps = guardReactiveProps</span><span class="s1">;</span>
<span class="s2">exports.h = h</span><span class="s1">;</span>
<span class="s2">exports.handleError = handleError</span><span class="s1">;</span>
<span class="s2">exports.initCustomFormatter = initCustomFormatter</span><span class="s1">;</span>
<span class="s2">exports.inject = inject</span><span class="s1">;</span>
<span class="s2">exports.isMemoSame = isMemoSame</span><span class="s1">;</span>
<span class="s2">exports.isRuntimeOnly = isRuntimeOnly</span><span class="s1">;</span>
<span class="s2">exports.isVNode = isVNode</span><span class="s1">;</span>
<span class="s2">exports.mergeDefaults = mergeDefaults</span><span class="s1">;</span>
<span class="s2">exports.mergeProps = mergeProps</span><span class="s1">;</span>
<span class="s2">exports.nextTick = nextTick</span><span class="s1">;</span>
<span class="s2">exports.onActivated = onActivated</span><span class="s1">;</span>
<span class="s2">exports.onBeforeMount = onBeforeMount</span><span class="s1">;</span>
<span class="s2">exports.onBeforeUnmount = onBeforeUnmount</span><span class="s1">;</span>
<span class="s2">exports.onBeforeUpdate = onBeforeUpdate</span><span class="s1">;</span>
<span class="s2">exports.onDeactivated = onDeactivated</span><span class="s1">;</span>
<span class="s2">exports.onErrorCaptured = onErrorCaptured</span><span class="s1">;</span>
<span class="s2">exports.onMounted = onMounted</span><span class="s1">;</span>
<span class="s2">exports.onRenderTracked = onRenderTracked</span><span class="s1">;</span>
<span class="s2">exports.onRenderTriggered = onRenderTriggered</span><span class="s1">;</span>
<span class="s2">exports.onServerPrefetch = onServerPrefetch</span><span class="s1">;</span>
<span class="s2">exports.onUnmounted = onUnmounted</span><span class="s1">;</span>
<span class="s2">exports.onUpdated = onUpdated</span><span class="s1">;</span>
<span class="s2">exports.openBlock = openBlock</span><span class="s1">;</span>
<span class="s2">exports.popScopeId = popScopeId</span><span class="s1">;</span>
<span class="s2">exports.provide = provide</span><span class="s1">;</span>
<span class="s2">exports.pushScopeId = pushScopeId</span><span class="s1">;</span>
<span class="s2">exports.queuePostFlushCb = queuePostFlushCb</span><span class="s1">;</span>
<span class="s2">exports.registerRuntimeCompiler = registerRuntimeCompiler</span><span class="s1">;</span>
<span class="s2">exports.renderList = renderList</span><span class="s1">;</span>
<span class="s2">exports.renderSlot = renderSlot</span><span class="s1">;</span>
<span class="s2">exports.resolveComponent = resolveComponent</span><span class="s1">;</span>
<span class="s2">exports.resolveDirective = resolveDirective</span><span class="s1">;</span>
<span class="s2">exports.resolveDynamicComponent = resolveDynamicComponent</span><span class="s1">;</span>
<span class="s2">exports.resolveFilter = resolveFilter</span><span class="s1">;</span>
<span class="s2">exports.resolveTransitionHooks = resolveTransitionHooks</span><span class="s1">;</span>
<span class="s2">exports.setBlockTracking = setBlockTracking</span><span class="s1">;</span>
<span class="s2">exports.setDevtoolsHook = setDevtoolsHook</span><span class="s1">;</span>
<span class="s2">exports.setTransitionHooks = setTransitionHooks</span><span class="s1">;</span>
<span class="s2">exports.ssrContextKey = ssrContextKey</span><span class="s1">;</span>
<span class="s2">exports.ssrUtils = ssrUtils</span><span class="s1">;</span>
<span class="s2">exports.toHandlers = toHandlers</span><span class="s1">;</span>
<span class="s2">exports.transformVNodeArgs = transformVNodeArgs</span><span class="s1">;</span>
<span class="s2">exports.useAttrs = useAttrs</span><span class="s1">;</span>
<span class="s2">exports.useSSRContext = useSSRContext</span><span class="s1">;</span>
<span class="s2">exports.useSlots = useSlots</span><span class="s1">;</span>
<span class="s2">exports.useTransitionState = useTransitionState</span><span class="s1">;</span>
<span class="s2">exports.version = version</span><span class="s1">;</span>
<span class="s2">exports.warn = warn</span><span class="s1">;</span>
<span class="s2">exports.watch = watch</span><span class="s1">;</span>
<span class="s2">exports.watchEffect = watchEffect</span><span class="s1">;</span>
<span class="s2">exports.watchPostEffect = watchPostEffect</span><span class="s1">;</span>
<span class="s2">exports.watchSyncEffect = watchSyncEffect</span><span class="s1">;</span>
<span class="s2">exports.withAsyncContext = withAsyncContext</span><span class="s1">;</span>
<span class="s2">exports.withCtx = withCtx</span><span class="s1">;</span>
<span class="s2">exports.withDefaults = withDefaults</span><span class="s1">;</span>
<span class="s2">exports.withDirectives = withDirectives</span><span class="s1">;</span>
<span class="s2">exports.withMemo = withMemo</span><span class="s1">;</span>
<span class="s2">exports.withScopeId = withScopeId</span><span class="s1">;</span>
</pre>
</body>
</html>