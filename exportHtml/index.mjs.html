<html>
<head>
<title>index.mjs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
.s5 { color: #629755; font-style: italic;}
.s6 { color: #629755; font-weight: bold; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
index.mjs</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">fs from </span><span class="s2">'node:fs'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ isCSSRequest</span><span class="s0">, </span><span class="s1">normalizePath as normalizePath$1</span><span class="s0">, </span><span class="s1">transformWithEsbuild</span><span class="s0">, </span><span class="s1">formatPostcssSourceMap</span><span class="s0">, </span><span class="s1">createFilter } from </span><span class="s2">'vite'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ createRequire } from </span><span class="s2">'node:module'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">path from </span><span class="s2">'node:path'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ createHash } from </span><span class="s2">'node:crypto'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">require$$0 from </span><span class="s2">'tty'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">require$$1 from </span><span class="s2">'util'</span><span class="s0">;</span>

<span class="s0">function </span><span class="s1">resolveCompiler(root) {</span>
  <span class="s0">const </span><span class="s1">compiler = tryResolveCompiler(root) || tryResolveCompiler()</span><span class="s0">;</span>
  <span class="s0">if </span><span class="s1">(!compiler) {</span>
    <span class="s0">throw new </span><span class="s1">Error(</span>
      <span class="s2">`Failed to resolve vue/compiler-sfc. 
@vitejs/plugin-vue requires vue (&gt;=3.2.25) to be present in the dependency tree.`</span>
    <span class="s1">)</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">return </span><span class="s1">compiler</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">tryResolveCompiler(root) {</span>
  <span class="s0">const </span><span class="s1">vueMeta = tryRequire(</span><span class="s2">&quot;vue/package.json&quot;</span><span class="s0">, </span><span class="s1">root)</span><span class="s0">;</span>
  <span class="s0">if </span><span class="s1">(vueMeta &amp;&amp; vueMeta.version.split(</span><span class="s2">&quot;.&quot;</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">] &gt;= </span><span class="s3">3</span><span class="s1">) {</span>
    <span class="s0">return </span><span class="s1">tryRequire(</span><span class="s2">&quot;vue/compiler-sfc&quot;</span><span class="s0">, </span><span class="s1">root)</span><span class="s0">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">const </span><span class="s1">_require = createRequire(</span><span class="s0">import</span><span class="s1">.meta.url)</span><span class="s0">;</span>
<span class="s0">function </span><span class="s1">tryRequire(id</span><span class="s0">, </span><span class="s1">from) {</span>
  <span class="s0">try </span><span class="s1">{</span>
    <span class="s0">return </span><span class="s1">from ? _require(_require.resolve(id</span><span class="s0">, </span><span class="s1">{ paths: [from] })) : _require(id)</span><span class="s0">;</span>
  <span class="s1">} </span><span class="s0">catch </span><span class="s1">(e) {</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">parseVueRequest(id) {</span>
  <span class="s0">const </span><span class="s1">[filename</span><span class="s0">, </span><span class="s1">rawQuery] = id.split(</span><span class="s2">`?`</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">query = Object.fromEntries(</span><span class="s0">new </span><span class="s1">URLSearchParams(rawQuery))</span><span class="s0">;</span>
  <span class="s0">if </span><span class="s1">(query.vue != </span><span class="s0">null</span><span class="s1">) {</span>
    <span class="s1">query.vue = </span><span class="s0">true;</span>
  <span class="s1">}</span>
  <span class="s0">if </span><span class="s1">(query.index != </span><span class="s0">null</span><span class="s1">) {</span>
    <span class="s1">query.index = Number(query.index)</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">if </span><span class="s1">(query.raw != </span><span class="s0">null</span><span class="s1">) {</span>
    <span class="s1">query.raw = </span><span class="s0">true;</span>
  <span class="s1">}</span>
  <span class="s0">if </span><span class="s1">(query.url != </span><span class="s0">null</span><span class="s1">) {</span>
    <span class="s1">query.url = </span><span class="s0">true;</span>
  <span class="s1">}</span>
  <span class="s0">if </span><span class="s1">(query.scoped != </span><span class="s0">null</span><span class="s1">) {</span>
    <span class="s1">query.scoped = </span><span class="s0">true;</span>
  <span class="s1">}</span>
  <span class="s0">return </span><span class="s1">{</span>
    <span class="s1">filename</span><span class="s0">,</span>
    <span class="s1">query</span>
  <span class="s1">}</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">slash(path) {</span>
	<span class="s0">const </span><span class="s1">isExtendedLengthPath = </span><span class="s3">/^\\\\\?\\/</span><span class="s1">.test(path)</span><span class="s0">;</span>

	<span class="s0">if </span><span class="s1">(isExtendedLengthPath) {</span>
		<span class="s0">return </span><span class="s1">path</span><span class="s0">;</span>
	<span class="s1">}</span>

	<span class="s0">return </span><span class="s1">path.replace(</span><span class="s3">/\\/g</span><span class="s0">, </span><span class="s2">'/'</span><span class="s1">)</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">const </span><span class="s1">cache = </span><span class="s4">/* @__PURE__ */ </span><span class="s0">new </span><span class="s1">Map()</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">prevCache = </span><span class="s4">/* @__PURE__ */ </span><span class="s0">new </span><span class="s1">Map()</span><span class="s0">;</span>
<span class="s0">function </span><span class="s1">createDescriptor(filename</span><span class="s0">, </span><span class="s1">source</span><span class="s0">, </span><span class="s1">{ root</span><span class="s0">, </span><span class="s1">isProduction</span><span class="s0">, </span><span class="s1">sourceMap</span><span class="s0">, </span><span class="s1">compiler }) {</span>
  <span class="s0">const </span><span class="s1">{ descriptor</span><span class="s0">, </span><span class="s1">errors } = compiler.parse(source</span><span class="s0">, </span><span class="s1">{</span>
    <span class="s1">filename</span><span class="s0">,</span>
    <span class="s1">sourceMap</span>
  <span class="s1">})</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">normalizedPath = slash(path.normalize(path.relative(root</span><span class="s0">, </span><span class="s1">filename)))</span><span class="s0">;</span>
  <span class="s1">descriptor.id = getHash(normalizedPath + (isProduction ? source : </span><span class="s2">&quot;&quot;</span><span class="s1">))</span><span class="s0">;</span>
  <span class="s1">cache.set(filename</span><span class="s0">, </span><span class="s1">descriptor)</span><span class="s0">;</span>
  <span class="s0">return </span><span class="s1">{ descriptor</span><span class="s0">, </span><span class="s1">errors }</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">getPrevDescriptor(filename) {</span>
  <span class="s0">return </span><span class="s1">prevCache.get(filename)</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">setPrevDescriptor(filename</span><span class="s0">, </span><span class="s1">entry) {</span>
  <span class="s1">prevCache.set(filename</span><span class="s0">, </span><span class="s1">entry)</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">getDescriptor(filename</span><span class="s0">, </span><span class="s1">options</span><span class="s0">, </span><span class="s1">createIfNotFound = </span><span class="s0">true</span><span class="s1">) {</span>
  <span class="s0">if </span><span class="s1">(cache.has(filename)) {</span>
    <span class="s0">return </span><span class="s1">cache.get(filename)</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">if </span><span class="s1">(createIfNotFound) {</span>
    <span class="s0">const </span><span class="s1">{ descriptor</span><span class="s0">, </span><span class="s1">errors } = createDescriptor(</span>
      <span class="s1">filename</span><span class="s0">,</span>
      <span class="s1">fs.readFileSync(filename</span><span class="s0">, </span><span class="s2">&quot;utf-8&quot;</span><span class="s1">)</span><span class="s0">,</span>
      <span class="s1">options</span>
    <span class="s1">)</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(errors.length) {</span>
      <span class="s0">throw </span><span class="s1">errors[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">descriptor</span><span class="s0">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">getSrcDescriptor(filename</span><span class="s0">, </span><span class="s1">query) {</span>
  <span class="s0">if </span><span class="s1">(query.scoped) {</span>
    <span class="s0">return </span><span class="s1">cache.get(</span><span class="s2">`</span><span class="s1">${filename}</span><span class="s2">?src=</span><span class="s1">${query.src}</span><span class="s2">`</span><span class="s1">)</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">return </span><span class="s1">cache.get(filename)</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">setSrcDescriptor(filename</span><span class="s0">, </span><span class="s1">entry</span><span class="s0">, </span><span class="s1">scoped) {</span>
  <span class="s0">if </span><span class="s1">(scoped) {</span>
    <span class="s1">cache.set(</span><span class="s2">`</span><span class="s1">${filename}</span><span class="s2">?src=</span><span class="s1">${entry.id}</span><span class="s2">`</span><span class="s0">, </span><span class="s1">entry)</span><span class="s0">;</span>
    <span class="s0">return;</span>
  <span class="s1">}</span>
  <span class="s1">cache.set(filename</span><span class="s0">, </span><span class="s1">entry)</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">getHash(text) {</span>
  <span class="s0">return </span><span class="s1">createHash(</span><span class="s2">&quot;sha256&quot;</span><span class="s1">).update(text).digest(</span><span class="s2">&quot;hex&quot;</span><span class="s1">).substring(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">8</span><span class="s1">)</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">createRollupError(id</span><span class="s0">, </span><span class="s1">error) {</span>
  <span class="s0">const </span><span class="s1">{ message</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">stack } = error</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">rollupError = {</span>
    <span class="s1">id</span><span class="s0">,</span>
    <span class="s1">plugin: </span><span class="s2">&quot;vue&quot;</span><span class="s0">,</span>
    <span class="s1">message</span><span class="s0">,</span>
    <span class="s1">name</span><span class="s0">,</span>
    <span class="s1">stack</span>
  <span class="s1">}</span><span class="s0">;</span>
  <span class="s0">if </span><span class="s1">(</span><span class="s2">&quot;code&quot; </span><span class="s0">in </span><span class="s1">error &amp;&amp; error.loc) {</span>
    <span class="s1">rollupError.loc = {</span>
      <span class="s1">file: id</span><span class="s0">,</span>
      <span class="s1">line: error.loc.start.line</span><span class="s0">,</span>
      <span class="s1">column: error.loc.start.column</span>
    <span class="s1">}</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">return </span><span class="s1">rollupError</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s1">async </span><span class="s0">function </span><span class="s1">transformTemplateAsModule(code</span><span class="s0">, </span><span class="s1">descriptor</span><span class="s0">, </span><span class="s1">options</span><span class="s0">, </span><span class="s1">pluginContext</span><span class="s0">, </span><span class="s1">ssr) {</span>
  <span class="s0">const </span><span class="s1">result = compile(code</span><span class="s0">, </span><span class="s1">descriptor</span><span class="s0">, </span><span class="s1">options</span><span class="s0">, </span><span class="s1">pluginContext</span><span class="s0">, </span><span class="s1">ssr)</span><span class="s0">;</span>
  <span class="s0">let </span><span class="s1">returnCode = result.code</span><span class="s0">;</span>
  <span class="s0">if </span><span class="s1">(options.devServer &amp;&amp; options.devServer.config.server.hmr !== </span><span class="s0">false </span><span class="s1">&amp;&amp; !ssr &amp;&amp; !options.isProduction) {</span>
    <span class="s1">returnCode += </span><span class="s2">`</span>
<span class="s2">import.meta.hot.accept(({ render }) =&gt; { 
      __VUE_HMR_RUNTIME__.rerender(</span><span class="s1">${JSON.stringify(descriptor.id)}</span><span class="s2">, render) 
    })`</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">return </span><span class="s1">{</span>
    <span class="s1">code: returnCode</span><span class="s0">,</span>
    <span class="s1">map: result.map</span>
  <span class="s1">}</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">transformTemplateInMain(code</span><span class="s0">, </span><span class="s1">descriptor</span><span class="s0">, </span><span class="s1">options</span><span class="s0">, </span><span class="s1">pluginContext</span><span class="s0">, </span><span class="s1">ssr) {</span>
  <span class="s0">const </span><span class="s1">result = compile(code</span><span class="s0">, </span><span class="s1">descriptor</span><span class="s0">, </span><span class="s1">options</span><span class="s0">, </span><span class="s1">pluginContext</span><span class="s0">, </span><span class="s1">ssr)</span><span class="s0">;</span>
  <span class="s0">return </span><span class="s1">{</span>
    <span class="s1">...result</span><span class="s0">,</span>
    <span class="s1">code: result.code.replace(</span>
      <span class="s3">/\nexport (function|const) (render|ssrRender)/</span><span class="s0">,</span>
      <span class="s2">&quot;</span><span class="s0">\n</span><span class="s2">$1 _sfc_$2&quot;</span>
    <span class="s1">)</span>
  <span class="s1">}</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">compile(code</span><span class="s0">, </span><span class="s1">descriptor</span><span class="s0">, </span><span class="s1">options</span><span class="s0">, </span><span class="s1">pluginContext</span><span class="s0">, </span><span class="s1">ssr) {</span>
  <span class="s0">const </span><span class="s1">filename = descriptor.filename</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">result = options.compiler.compileTemplate({</span>
    <span class="s1">...resolveTemplateCompilerOptions(descriptor</span><span class="s0">, </span><span class="s1">options</span><span class="s0">, </span><span class="s1">ssr)</span><span class="s0">,</span>
    <span class="s1">source: code</span>
  <span class="s1">})</span><span class="s0">;</span>
  <span class="s0">if </span><span class="s1">(result.errors.length) {</span>
    <span class="s1">result.errors.forEach(</span>
      <span class="s1">(error) =&gt; pluginContext.error(</span>
        <span class="s0">typeof </span><span class="s1">error === </span><span class="s2">&quot;string&quot; </span><span class="s1">? { id: filename</span><span class="s0">, </span><span class="s1">message: error } : createRollupError(filename</span><span class="s0">, </span><span class="s1">error)</span>
      <span class="s1">)</span>
    <span class="s1">)</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">if </span><span class="s1">(result.tips.length) {</span>
    <span class="s1">result.tips.forEach(</span>
      <span class="s1">(tip) =&gt; pluginContext.warn({</span>
        <span class="s1">id: filename</span><span class="s0">,</span>
        <span class="s1">message: tip</span>
      <span class="s1">})</span>
    <span class="s1">)</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">return </span><span class="s1">result</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">resolveTemplateCompilerOptions(descriptor</span><span class="s0">, </span><span class="s1">options</span><span class="s0">, </span><span class="s1">ssr) {</span>
  <span class="s0">const </span><span class="s1">block = descriptor.template</span><span class="s0">;</span>
  <span class="s0">if </span><span class="s1">(!block) {</span>
    <span class="s0">return;</span>
  <span class="s1">}</span>
  <span class="s0">const </span><span class="s1">resolvedScript = getResolvedScript(descriptor</span><span class="s0">, </span><span class="s1">ssr)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">hasScoped = descriptor.styles.some((s) =&gt; s.scoped)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">{ id</span><span class="s0">, </span><span class="s1">filename</span><span class="s0">, </span><span class="s1">cssVars } = descriptor</span><span class="s0">;</span>
  <span class="s0">let </span><span class="s1">transformAssetUrls = options.template?.transformAssetUrls</span><span class="s0">;</span>
  <span class="s0">let </span><span class="s1">assetUrlOptions</span><span class="s0">;</span>
  <span class="s0">if </span><span class="s1">(options.devServer) {</span>
    <span class="s0">if </span><span class="s1">(filename.startsWith(options.root)) {</span>
      <span class="s0">const </span><span class="s1">devBase = options.devServer.config.base</span><span class="s0">;</span>
      <span class="s1">assetUrlOptions = {</span>
        <span class="s1">base: (options.devServer.config.server?.origin ?? </span><span class="s2">&quot;&quot;</span><span class="s1">) + devBase + slash(path.relative(options.root</span><span class="s0">, </span><span class="s1">path.dirname(filename)))</span>
      <span class="s1">}</span><span class="s0">;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s0">else if </span><span class="s1">(transformAssetUrls !== </span><span class="s0">false</span><span class="s1">) {</span>
    <span class="s1">assetUrlOptions = {</span>
      <span class="s1">includeAbsolute: </span><span class="s0">true</span>
    <span class="s1">}</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">if </span><span class="s1">(transformAssetUrls &amp;&amp; </span><span class="s0">typeof </span><span class="s1">transformAssetUrls === </span><span class="s2">&quot;object&quot;</span><span class="s1">) {</span>
    <span class="s0">if </span><span class="s1">(Object.values(transformAssetUrls).some((val) =&gt; Array.isArray(val))) {</span>
      <span class="s1">transformAssetUrls = {</span>
        <span class="s1">...assetUrlOptions</span><span class="s0">,</span>
        <span class="s1">tags: transformAssetUrls</span>
      <span class="s1">}</span><span class="s0">;</span>
    <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
      <span class="s1">transformAssetUrls = { ...assetUrlOptions</span><span class="s0">, </span><span class="s1">...transformAssetUrls }</span><span class="s0">;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
    <span class="s1">transformAssetUrls = assetUrlOptions</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">let </span><span class="s1">preprocessOptions = block.lang &amp;&amp; options.template?.preprocessOptions</span><span class="s0">;</span>
  <span class="s0">if </span><span class="s1">(block.lang === </span><span class="s2">&quot;pug&quot;</span><span class="s1">) {</span>
    <span class="s1">preprocessOptions = {</span>
      <span class="s1">doctype: </span><span class="s2">&quot;html&quot;</span><span class="s0">,</span>
      <span class="s1">...preprocessOptions</span>
    <span class="s1">}</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">const </span><span class="s1">expressionPlugins = options.template?.compilerOptions?.expressionPlugins || []</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">lang = descriptor.scriptSetup?.lang || descriptor.script?.lang</span><span class="s0">;</span>
  <span class="s0">if </span><span class="s1">(lang &amp;&amp; </span><span class="s3">/tsx?$/</span><span class="s1">.test(lang) &amp;&amp; !expressionPlugins.includes(</span><span class="s2">&quot;typescript&quot;</span><span class="s1">)) {</span>
    <span class="s1">expressionPlugins.push(</span><span class="s2">&quot;typescript&quot;</span><span class="s1">)</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">return </span><span class="s1">{</span>
    <span class="s1">...options.template</span><span class="s0">,</span>
    <span class="s1">id</span><span class="s0">,</span>
    <span class="s1">filename</span><span class="s0">,</span>
    <span class="s1">scoped: hasScoped</span><span class="s0">,</span>
    <span class="s1">slotted: descriptor.slotted</span><span class="s0">,</span>
    <span class="s1">isProd: options.isProduction</span><span class="s0">,</span>
    <span class="s1">inMap: block.src ? </span><span class="s0">void </span><span class="s3">0 </span><span class="s1">: block.map</span><span class="s0">,</span>
    <span class="s1">ssr</span><span class="s0">,</span>
    <span class="s1">ssrCssVars: cssVars</span><span class="s0">,</span>
    <span class="s1">transformAssetUrls</span><span class="s0">,</span>
    <span class="s1">preprocessLang: block.lang</span><span class="s0">,</span>
    <span class="s1">preprocessOptions</span><span class="s0">,</span>
    <span class="s1">compilerOptions: {</span>
      <span class="s1">...options.template?.compilerOptions</span><span class="s0">,</span>
      <span class="s1">scopeId: hasScoped ? </span><span class="s2">`data-v-</span><span class="s1">${id}</span><span class="s2">` </span><span class="s1">: </span><span class="s0">void </span><span class="s3">0</span><span class="s0">,</span>
      <span class="s1">bindingMetadata: resolvedScript ? resolvedScript.bindings : </span><span class="s0">void </span><span class="s3">0</span><span class="s0">,</span>
      <span class="s1">expressionPlugins</span><span class="s0">,</span>
      <span class="s1">sourceMap: options.sourceMap</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">const </span><span class="s1">clientCache = </span><span class="s4">/* @__PURE__ */ </span><span class="s0">new </span><span class="s1">WeakMap()</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">ssrCache = </span><span class="s4">/* @__PURE__ */ </span><span class="s0">new </span><span class="s1">WeakMap()</span><span class="s0">;</span>
<span class="s0">function </span><span class="s1">getResolvedScript(descriptor</span><span class="s0">, </span><span class="s1">ssr) {</span>
  <span class="s0">return </span><span class="s1">(ssr ? ssrCache : clientCache).get(descriptor)</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">setResolvedScript(descriptor</span><span class="s0">, </span><span class="s1">script</span><span class="s0">, </span><span class="s1">ssr) {</span>
  <span class="s1">(ssr ? ssrCache : clientCache).set(descriptor</span><span class="s0">, </span><span class="s1">script)</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">isUseInlineTemplate(descriptor</span><span class="s0">, </span><span class="s1">isProd) {</span>
  <span class="s0">return </span><span class="s1">isProd &amp;&amp; !!descriptor.scriptSetup &amp;&amp; !descriptor.template?.src</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">resolveScript(descriptor</span><span class="s0">, </span><span class="s1">options</span><span class="s0">, </span><span class="s1">ssr) {</span>
  <span class="s0">if </span><span class="s1">(!descriptor.script &amp;&amp; !descriptor.scriptSetup) {</span>
    <span class="s0">return null;</span>
  <span class="s1">}</span>
  <span class="s0">const </span><span class="s1">cacheToUse = ssr ? ssrCache : clientCache</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">cached = cacheToUse.get(descriptor)</span><span class="s0">;</span>
  <span class="s0">if </span><span class="s1">(cached) {</span>
    <span class="s0">return </span><span class="s1">cached</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">let </span><span class="s1">resolved = </span><span class="s0">null;</span>
  <span class="s1">resolved = options.compiler.compileScript(descriptor</span><span class="s0">, </span><span class="s1">{</span>
    <span class="s1">...options.script</span><span class="s0">,</span>
    <span class="s1">id: descriptor.id</span><span class="s0">,</span>
    <span class="s1">isProd: options.isProduction</span><span class="s0">,</span>
    <span class="s1">inlineTemplate: isUseInlineTemplate(descriptor</span><span class="s0">, </span><span class="s1">!options.devServer)</span><span class="s0">,</span>
    <span class="s1">reactivityTransform: options.reactivityTransform !== </span><span class="s0">false,</span>
    <span class="s1">templateOptions: resolveTemplateCompilerOptions(descriptor</span><span class="s0">, </span><span class="s1">options</span><span class="s0">, </span><span class="s1">ssr)</span><span class="s0">,</span>
    <span class="s1">sourceMap: options.sourceMap</span>
  <span class="s1">})</span><span class="s0">;</span>
  <span class="s1">cacheToUse.set(descriptor</span><span class="s0">, </span><span class="s1">resolved)</span><span class="s0">;</span>
  <span class="s0">return </span><span class="s1">resolved</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">const </span><span class="s1">comma = </span><span class="s2">','</span><span class="s1">.charCodeAt(</span><span class="s3">0</span><span class="s1">)</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">semicolon = </span><span class="s2">';'</span><span class="s1">.charCodeAt(</span><span class="s3">0</span><span class="s1">)</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">chars = </span><span class="s2">'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">intToChar = </span><span class="s0">new </span><span class="s1">Uint8Array(</span><span class="s3">64</span><span class="s1">)</span><span class="s0">; </span><span class="s4">// 64 possible chars.</span>
<span class="s0">const </span><span class="s1">charToInt = </span><span class="s0">new </span><span class="s1">Uint8Array(</span><span class="s3">128</span><span class="s1">)</span><span class="s0">; </span><span class="s4">// z is 122 in ASCII</span>
<span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s3">0</span><span class="s0">; </span><span class="s1">i &lt; chars.length</span><span class="s0">; </span><span class="s1">i++) {</span>
    <span class="s0">const </span><span class="s1">c = chars.charCodeAt(i)</span><span class="s0">;</span>
    <span class="s1">intToChar[i] = c</span><span class="s0">;</span>
    <span class="s1">charToInt[c] = i</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s4">// Provide a fallback for older environments.</span>
<span class="s0">const </span><span class="s1">td = </span><span class="s0">typeof </span><span class="s1">TextDecoder !== </span><span class="s2">'undefined'</span>
    <span class="s1">? </span><span class="s4">/* #__PURE__ */ </span><span class="s0">new </span><span class="s1">TextDecoder()</span>
    <span class="s1">: </span><span class="s0">typeof </span><span class="s1">Buffer !== </span><span class="s2">'undefined'</span>
        <span class="s1">? {</span>
            <span class="s1">decode(buf) {</span>
                <span class="s0">const </span><span class="s1">out = Buffer.from(buf.buffer</span><span class="s0">, </span><span class="s1">buf.byteOffset</span><span class="s0">, </span><span class="s1">buf.byteLength)</span><span class="s0">;</span>
                <span class="s0">return </span><span class="s1">out.toString()</span><span class="s0">;</span>
            <span class="s1">}</span><span class="s0">,</span>
        <span class="s1">}</span>
        <span class="s1">: {</span>
            <span class="s1">decode(buf) {</span>
                <span class="s0">let </span><span class="s1">out = </span><span class="s2">''</span><span class="s0">;</span>
                <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s3">0</span><span class="s0">; </span><span class="s1">i &lt; buf.length</span><span class="s0">; </span><span class="s1">i++) {</span>
                    <span class="s1">out += String.fromCharCode(buf[i])</span><span class="s0">;</span>
                <span class="s1">}</span>
                <span class="s0">return </span><span class="s1">out</span><span class="s0">;</span>
            <span class="s1">}</span><span class="s0">,</span>
        <span class="s1">}</span><span class="s0">;</span>
<span class="s0">function </span><span class="s1">decode(mappings) {</span>
    <span class="s0">const </span><span class="s1">state = </span><span class="s0">new </span><span class="s1">Int32Array(</span><span class="s3">5</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">decoded = []</span><span class="s0">;</span>
    <span class="s0">let </span><span class="s1">index = </span><span class="s3">0</span><span class="s0">;</span>
    <span class="s0">do </span><span class="s1">{</span>
        <span class="s0">const </span><span class="s1">semi = indexOf(mappings</span><span class="s0">, </span><span class="s1">index)</span><span class="s0">;</span>
        <span class="s0">const </span><span class="s1">line = []</span><span class="s0">;</span>
        <span class="s0">let </span><span class="s1">sorted = </span><span class="s0">true;</span>
        <span class="s0">let </span><span class="s1">lastCol = </span><span class="s3">0</span><span class="s0">;</span>
        <span class="s1">state[</span><span class="s3">0</span><span class="s1">] = </span><span class="s3">0</span><span class="s0">;</span>
        <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = index</span><span class="s0">; </span><span class="s1">i &lt; semi</span><span class="s0">; </span><span class="s1">i++) {</span>
            <span class="s0">let </span><span class="s1">seg</span><span class="s0">;</span>
            <span class="s1">i = decodeInteger(mappings</span><span class="s0">, </span><span class="s1">i</span><span class="s0">, </span><span class="s1">state</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">; </span><span class="s4">// genColumn</span>
            <span class="s0">const </span><span class="s1">col = state[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">;</span>
            <span class="s0">if </span><span class="s1">(col &lt; lastCol)</span>
                <span class="s1">sorted = </span><span class="s0">false;</span>
            <span class="s1">lastCol = col</span><span class="s0">;</span>
            <span class="s0">if </span><span class="s1">(hasMoreVlq(mappings</span><span class="s0">, </span><span class="s1">i</span><span class="s0">, </span><span class="s1">semi)) {</span>
                <span class="s1">i = decodeInteger(mappings</span><span class="s0">, </span><span class="s1">i</span><span class="s0">, </span><span class="s1">state</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">; </span><span class="s4">// sourcesIndex</span>
                <span class="s1">i = decodeInteger(mappings</span><span class="s0">, </span><span class="s1">i</span><span class="s0">, </span><span class="s1">state</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">; </span><span class="s4">// sourceLine</span>
                <span class="s1">i = decodeInteger(mappings</span><span class="s0">, </span><span class="s1">i</span><span class="s0">, </span><span class="s1">state</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span><span class="s0">; </span><span class="s4">// sourceColumn</span>
                <span class="s0">if </span><span class="s1">(hasMoreVlq(mappings</span><span class="s0">, </span><span class="s1">i</span><span class="s0">, </span><span class="s1">semi)) {</span>
                    <span class="s1">i = decodeInteger(mappings</span><span class="s0">, </span><span class="s1">i</span><span class="s0">, </span><span class="s1">state</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)</span><span class="s0">; </span><span class="s4">// namesIndex</span>
                    <span class="s1">seg = [col</span><span class="s0">, </span><span class="s1">state[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">state[</span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">state[</span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">state[</span><span class="s3">4</span><span class="s1">]]</span><span class="s0">;</span>
                <span class="s1">}</span>
                <span class="s0">else </span><span class="s1">{</span>
                    <span class="s1">seg = [col</span><span class="s0">, </span><span class="s1">state[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">state[</span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">state[</span><span class="s3">3</span><span class="s1">]]</span><span class="s0">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s0">else </span><span class="s1">{</span>
                <span class="s1">seg = [col]</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s1">line.push(seg)</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(!sorted)</span>
            <span class="s1">sort(line)</span><span class="s0">;</span>
        <span class="s1">decoded.push(line)</span><span class="s0">;</span>
        <span class="s1">index = semi + </span><span class="s3">1</span><span class="s0">;</span>
    <span class="s1">} </span><span class="s0">while </span><span class="s1">(index &lt;= mappings.length)</span><span class="s0">;</span>
    <span class="s0">return </span><span class="s1">decoded</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">indexOf(mappings</span><span class="s0">, </span><span class="s1">index) {</span>
    <span class="s0">const </span><span class="s1">idx = mappings.indexOf(</span><span class="s2">';'</span><span class="s0">, </span><span class="s1">index)</span><span class="s0">;</span>
    <span class="s0">return </span><span class="s1">idx === -</span><span class="s3">1 </span><span class="s1">? mappings.length : idx</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">decodeInteger(mappings</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">state</span><span class="s0">, </span><span class="s1">j) {</span>
    <span class="s0">let </span><span class="s1">value = </span><span class="s3">0</span><span class="s0">;</span>
    <span class="s0">let </span><span class="s1">shift = </span><span class="s3">0</span><span class="s0">;</span>
    <span class="s0">let </span><span class="s1">integer = </span><span class="s3">0</span><span class="s0">;</span>
    <span class="s0">do </span><span class="s1">{</span>
        <span class="s0">const </span><span class="s1">c = mappings.charCodeAt(pos++)</span><span class="s0">;</span>
        <span class="s1">integer = charToInt[c]</span><span class="s0">;</span>
        <span class="s1">value |= (integer &amp; </span><span class="s3">31</span><span class="s1">) &lt;&lt; shift</span><span class="s0">;</span>
        <span class="s1">shift += </span><span class="s3">5</span><span class="s0">;</span>
    <span class="s1">} </span><span class="s0">while </span><span class="s1">(integer &amp; </span><span class="s3">32</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">shouldNegate = value &amp; </span><span class="s3">1</span><span class="s0">;</span>
    <span class="s1">value &gt;&gt;&gt;= </span><span class="s3">1</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(shouldNegate) {</span>
        <span class="s1">value = -</span><span class="s3">0x80000000 </span><span class="s1">| -value</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s1">state[j] += value</span><span class="s0">;</span>
    <span class="s0">return </span><span class="s1">pos</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">hasMoreVlq(mappings</span><span class="s0">, </span><span class="s1">i</span><span class="s0">, </span><span class="s1">length) {</span>
    <span class="s0">if </span><span class="s1">(i &gt;= length)</span>
        <span class="s0">return false;</span>
    <span class="s0">return </span><span class="s1">mappings.charCodeAt(i) !== comma</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">sort(line) {</span>
    <span class="s1">line.sort(sortComparator$1)</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">sortComparator$1(a</span><span class="s0">, </span><span class="s1">b) {</span>
    <span class="s0">return </span><span class="s1">a[</span><span class="s3">0</span><span class="s1">] - b[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">encode(decoded) {</span>
    <span class="s0">const </span><span class="s1">state = </span><span class="s0">new </span><span class="s1">Int32Array(</span><span class="s3">5</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">bufLength = </span><span class="s3">1024 </span><span class="s1">* </span><span class="s3">16</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">subLength = bufLength - </span><span class="s3">36</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">buf = </span><span class="s0">new </span><span class="s1">Uint8Array(bufLength)</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">sub = buf.subarray(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">subLength)</span><span class="s0">;</span>
    <span class="s0">let </span><span class="s1">pos = </span><span class="s3">0</span><span class="s0">;</span>
    <span class="s0">let </span><span class="s1">out = </span><span class="s2">''</span><span class="s0">;</span>
    <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s3">0</span><span class="s0">; </span><span class="s1">i &lt; decoded.length</span><span class="s0">; </span><span class="s1">i++) {</span>
        <span class="s0">const </span><span class="s1">line = decoded[i]</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(i &gt; </span><span class="s3">0</span><span class="s1">) {</span>
            <span class="s0">if </span><span class="s1">(pos === bufLength) {</span>
                <span class="s1">out += td.decode(buf)</span><span class="s0">;</span>
                <span class="s1">pos = </span><span class="s3">0</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s1">buf[pos++] = semicolon</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(line.length === </span><span class="s3">0</span><span class="s1">)</span>
            <span class="s0">continue;</span>
        <span class="s1">state[</span><span class="s3">0</span><span class="s1">] = </span><span class="s3">0</span><span class="s0">;</span>
        <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">j = </span><span class="s3">0</span><span class="s0">; </span><span class="s1">j &lt; line.length</span><span class="s0">; </span><span class="s1">j++) {</span>
            <span class="s0">const </span><span class="s1">segment = line[j]</span><span class="s0">;</span>
            <span class="s4">// We can push up to 5 ints, each int can take at most 7 chars, and we</span>
            <span class="s4">// may push a comma.</span>
            <span class="s0">if </span><span class="s1">(pos &gt; subLength) {</span>
                <span class="s1">out += td.decode(sub)</span><span class="s0">;</span>
                <span class="s1">buf.copyWithin(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">subLength</span><span class="s0">, </span><span class="s1">pos)</span><span class="s0">;</span>
                <span class="s1">pos -= subLength</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">(j &gt; </span><span class="s3">0</span><span class="s1">)</span>
                <span class="s1">buf[pos++] = comma</span><span class="s0">;</span>
            <span class="s1">pos = encodeInteger(buf</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">state</span><span class="s0">, </span><span class="s1">segment</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">; </span><span class="s4">// genColumn</span>
            <span class="s0">if </span><span class="s1">(segment.length === </span><span class="s3">1</span><span class="s1">)</span>
                <span class="s0">continue;</span>
            <span class="s1">pos = encodeInteger(buf</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">state</span><span class="s0">, </span><span class="s1">segment</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">; </span><span class="s4">// sourcesIndex</span>
            <span class="s1">pos = encodeInteger(buf</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">state</span><span class="s0">, </span><span class="s1">segment</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">; </span><span class="s4">// sourceLine</span>
            <span class="s1">pos = encodeInteger(buf</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">state</span><span class="s0">, </span><span class="s1">segment</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span><span class="s0">; </span><span class="s4">// sourceColumn</span>
            <span class="s0">if </span><span class="s1">(segment.length === </span><span class="s3">4</span><span class="s1">)</span>
                <span class="s0">continue;</span>
            <span class="s1">pos = encodeInteger(buf</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">state</span><span class="s0">, </span><span class="s1">segment</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)</span><span class="s0">; </span><span class="s4">// namesIndex</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">out + td.decode(buf.subarray(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">pos))</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">encodeInteger(buf</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">state</span><span class="s0">, </span><span class="s1">segment</span><span class="s0">, </span><span class="s1">j) {</span>
    <span class="s0">const </span><span class="s1">next = segment[j]</span><span class="s0">;</span>
    <span class="s0">let </span><span class="s1">num = next - state[j]</span><span class="s0">;</span>
    <span class="s1">state[j] = next</span><span class="s0">;</span>
    <span class="s1">num = num &lt; </span><span class="s3">0 </span><span class="s1">? (-num &lt;&lt; </span><span class="s3">1</span><span class="s1">) | </span><span class="s3">1 </span><span class="s1">: num &lt;&lt; </span><span class="s3">1</span><span class="s0">;</span>
    <span class="s0">do </span><span class="s1">{</span>
        <span class="s0">let </span><span class="s1">clamped = num &amp; </span><span class="s3">0b011111</span><span class="s0">;</span>
        <span class="s1">num &gt;&gt;&gt;= </span><span class="s3">5</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(num &gt; </span><span class="s3">0</span><span class="s1">)</span>
            <span class="s1">clamped |= </span><span class="s3">0b100000</span><span class="s0">;</span>
        <span class="s1">buf[pos++] = intToChar[clamped]</span><span class="s0">;</span>
    <span class="s1">} </span><span class="s0">while </span><span class="s1">(num &gt; </span><span class="s3">0</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s0">return </span><span class="s1">pos</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s4">// Matches the scheme of a URL, eg &quot;http://&quot;</span>
<span class="s0">const </span><span class="s1">schemeRegex = </span><span class="s3">/^[\w+.-]+:\/\//</span><span class="s0">;</span>
<span class="s5">/**</span>
 <span class="s5">* Matches the parts of a URL:</span>
 <span class="s5">* 1. Scheme, including &quot;:&quot;, guaranteed.</span>
 <span class="s5">* 2. User/password, including &quot;@&quot;, optional.</span>
 <span class="s5">* 3. Host, guaranteed.</span>
 <span class="s5">* 4. Port, including &quot;:&quot;, optional.</span>
 <span class="s5">* 5. Path, including &quot;/&quot;, optional.</span>
 <span class="s5">* 6. Query, including &quot;?&quot;, optional.</span>
 <span class="s5">* 7. Hash, including &quot;#&quot;, optional.</span>
 <span class="s5">*/</span>
<span class="s0">const </span><span class="s1">urlRegex = </span><span class="s3">/^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/</span><span class="s0">;</span>
<span class="s5">/**</span>
 <span class="s5">* File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start</span>
 <span class="s5">* with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).</span>
 <span class="s5">*</span>
 <span class="s5">* 1. Host, optional.</span>
 <span class="s5">* 2. Path, which may include &quot;/&quot;, guaranteed.</span>
 <span class="s5">* 3. Query, including &quot;?&quot;, optional.</span>
 <span class="s5">* 4. Hash, including &quot;#&quot;, optional.</span>
 <span class="s5">*/</span>
<span class="s0">const </span><span class="s1">fileRegex = </span><span class="s3">/^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">UrlType</span><span class="s0">;</span>
<span class="s1">(</span><span class="s0">function </span><span class="s1">(UrlType) {</span>
    <span class="s1">UrlType[UrlType[</span><span class="s2">&quot;Empty&quot;</span><span class="s1">] = </span><span class="s3">1</span><span class="s1">] = </span><span class="s2">&quot;Empty&quot;</span><span class="s0">;</span>
    <span class="s1">UrlType[UrlType[</span><span class="s2">&quot;Hash&quot;</span><span class="s1">] = </span><span class="s3">2</span><span class="s1">] = </span><span class="s2">&quot;Hash&quot;</span><span class="s0">;</span>
    <span class="s1">UrlType[UrlType[</span><span class="s2">&quot;Query&quot;</span><span class="s1">] = </span><span class="s3">3</span><span class="s1">] = </span><span class="s2">&quot;Query&quot;</span><span class="s0">;</span>
    <span class="s1">UrlType[UrlType[</span><span class="s2">&quot;RelativePath&quot;</span><span class="s1">] = </span><span class="s3">4</span><span class="s1">] = </span><span class="s2">&quot;RelativePath&quot;</span><span class="s0">;</span>
    <span class="s1">UrlType[UrlType[</span><span class="s2">&quot;AbsolutePath&quot;</span><span class="s1">] = </span><span class="s3">5</span><span class="s1">] = </span><span class="s2">&quot;AbsolutePath&quot;</span><span class="s0">;</span>
    <span class="s1">UrlType[UrlType[</span><span class="s2">&quot;SchemeRelative&quot;</span><span class="s1">] = </span><span class="s3">6</span><span class="s1">] = </span><span class="s2">&quot;SchemeRelative&quot;</span><span class="s0">;</span>
    <span class="s1">UrlType[UrlType[</span><span class="s2">&quot;Absolute&quot;</span><span class="s1">] = </span><span class="s3">7</span><span class="s1">] = </span><span class="s2">&quot;Absolute&quot;</span><span class="s0">;</span>
<span class="s1">})(UrlType || (UrlType = {}))</span><span class="s0">;</span>
<span class="s0">function </span><span class="s1">isAbsoluteUrl(input) {</span>
    <span class="s0">return </span><span class="s1">schemeRegex.test(input)</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">isSchemeRelativeUrl(input) {</span>
    <span class="s0">return </span><span class="s1">input.startsWith(</span><span class="s2">'//'</span><span class="s1">)</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">isAbsolutePath(input) {</span>
    <span class="s0">return </span><span class="s1">input.startsWith(</span><span class="s2">'/'</span><span class="s1">)</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">isFileUrl(input) {</span>
    <span class="s0">return </span><span class="s1">input.startsWith(</span><span class="s2">'file:'</span><span class="s1">)</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">isRelative(input) {</span>
    <span class="s0">return </span><span class="s3">/^[.?#]/</span><span class="s1">.test(input)</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">parseAbsoluteUrl(input) {</span>
    <span class="s0">const </span><span class="s1">match = urlRegex.exec(input)</span><span class="s0">;</span>
    <span class="s0">return </span><span class="s1">makeUrl(match[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">match[</span><span class="s3">2</span><span class="s1">] || </span><span class="s2">''</span><span class="s0">, </span><span class="s1">match[</span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">match[</span><span class="s3">4</span><span class="s1">] || </span><span class="s2">''</span><span class="s0">, </span><span class="s1">match[</span><span class="s3">5</span><span class="s1">] || </span><span class="s2">'/'</span><span class="s0">, </span><span class="s1">match[</span><span class="s3">6</span><span class="s1">] || </span><span class="s2">''</span><span class="s0">, </span><span class="s1">match[</span><span class="s3">7</span><span class="s1">] || </span><span class="s2">''</span><span class="s1">)</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">parseFileUrl(input) {</span>
    <span class="s0">const </span><span class="s1">match = fileRegex.exec(input)</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">path = match[</span><span class="s3">2</span><span class="s1">]</span><span class="s0">;</span>
    <span class="s0">return </span><span class="s1">makeUrl(</span><span class="s2">'file:'</span><span class="s0">, </span><span class="s2">''</span><span class="s0">, </span><span class="s1">match[</span><span class="s3">1</span><span class="s1">] || </span><span class="s2">''</span><span class="s0">, </span><span class="s2">''</span><span class="s0">, </span><span class="s1">isAbsolutePath(path) ? path : </span><span class="s2">'/' </span><span class="s1">+ path</span><span class="s0">, </span><span class="s1">match[</span><span class="s3">3</span><span class="s1">] || </span><span class="s2">''</span><span class="s0">, </span><span class="s1">match[</span><span class="s3">4</span><span class="s1">] || </span><span class="s2">''</span><span class="s1">)</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">makeUrl(scheme</span><span class="s0">, </span><span class="s1">user</span><span class="s0">, </span><span class="s1">host</span><span class="s0">, </span><span class="s1">port</span><span class="s0">, </span><span class="s1">path</span><span class="s0">, </span><span class="s1">query</span><span class="s0">, </span><span class="s1">hash) {</span>
    <span class="s0">return </span><span class="s1">{</span>
        <span class="s1">scheme</span><span class="s0">,</span>
        <span class="s1">user</span><span class="s0">,</span>
        <span class="s1">host</span><span class="s0">,</span>
        <span class="s1">port</span><span class="s0">,</span>
        <span class="s1">path</span><span class="s0">,</span>
        <span class="s1">query</span><span class="s0">,</span>
        <span class="s1">hash</span><span class="s0">,</span>
        <span class="s1">type: UrlType.Absolute</span><span class="s0">,</span>
    <span class="s1">}</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">parseUrl(input) {</span>
    <span class="s0">if </span><span class="s1">(isSchemeRelativeUrl(input)) {</span>
        <span class="s0">const </span><span class="s1">url = parseAbsoluteUrl(</span><span class="s2">'http:' </span><span class="s1">+ input)</span><span class="s0">;</span>
        <span class="s1">url.scheme = </span><span class="s2">''</span><span class="s0">;</span>
        <span class="s1">url.type = UrlType.SchemeRelative</span><span class="s0">;</span>
        <span class="s0">return </span><span class="s1">url</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">if </span><span class="s1">(isAbsolutePath(input)) {</span>
        <span class="s0">const </span><span class="s1">url = parseAbsoluteUrl(</span><span class="s2">'http://foo.com' </span><span class="s1">+ input)</span><span class="s0">;</span>
        <span class="s1">url.scheme = </span><span class="s2">''</span><span class="s0">;</span>
        <span class="s1">url.host = </span><span class="s2">''</span><span class="s0">;</span>
        <span class="s1">url.type = UrlType.AbsolutePath</span><span class="s0">;</span>
        <span class="s0">return </span><span class="s1">url</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">if </span><span class="s1">(isFileUrl(input))</span>
        <span class="s0">return </span><span class="s1">parseFileUrl(input)</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(isAbsoluteUrl(input))</span>
        <span class="s0">return </span><span class="s1">parseAbsoluteUrl(input)</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">url = parseAbsoluteUrl(</span><span class="s2">'http://foo.com/' </span><span class="s1">+ input)</span><span class="s0">;</span>
    <span class="s1">url.scheme = </span><span class="s2">''</span><span class="s0">;</span>
    <span class="s1">url.host = </span><span class="s2">''</span><span class="s0">;</span>
    <span class="s1">url.type = input</span>
        <span class="s1">? input.startsWith(</span><span class="s2">'?'</span><span class="s1">)</span>
            <span class="s1">? UrlType.Query</span>
            <span class="s1">: input.startsWith(</span><span class="s2">'#'</span><span class="s1">)</span>
                <span class="s1">? UrlType.Hash</span>
                <span class="s1">: UrlType.RelativePath</span>
        <span class="s1">: UrlType.Empty</span><span class="s0">;</span>
    <span class="s0">return </span><span class="s1">url</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">stripPathFilename(path) {</span>
    <span class="s4">// If a path ends with a parent directory &quot;..&quot;, then it's a relative path with excess parent</span>
    <span class="s4">// paths. It's not a file, so we can't strip it.</span>
    <span class="s0">if </span><span class="s1">(path.endsWith(</span><span class="s2">'/..'</span><span class="s1">))</span>
        <span class="s0">return </span><span class="s1">path</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">index = path.lastIndexOf(</span><span class="s2">'/'</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s0">return </span><span class="s1">path.slice(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">index + </span><span class="s3">1</span><span class="s1">)</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">mergePaths(url</span><span class="s0">, </span><span class="s1">base) {</span>
    <span class="s1">normalizePath(base</span><span class="s0">, </span><span class="s1">base.type)</span><span class="s0">;</span>
    <span class="s4">// If the path is just a &quot;/&quot;, then it was an empty path to begin with (remember, we're a relative</span>
    <span class="s4">// path).</span>
    <span class="s0">if </span><span class="s1">(url.path === </span><span class="s2">'/'</span><span class="s1">) {</span>
        <span class="s1">url.path = base.path</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">else </span><span class="s1">{</span>
        <span class="s4">// Resolution happens relative to the base path's directory, not the file.</span>
        <span class="s1">url.path = stripPathFilename(base.path) + url.path</span><span class="s0">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s5">/**</span>
 <span class="s5">* The path can have empty directories &quot;//&quot;, unneeded parents &quot;foo/..&quot;, or current directory</span>
 <span class="s5">* &quot;foo/.&quot;. We need to normalize to a standard representation.</span>
 <span class="s5">*/</span>
<span class="s0">function </span><span class="s1">normalizePath(url</span><span class="s0">, </span><span class="s1">type) {</span>
    <span class="s0">const </span><span class="s1">rel = type &lt;= UrlType.RelativePath</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">pieces = url.path.split(</span><span class="s2">'/'</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s4">// We need to preserve the first piece always, so that we output a leading slash. The item at</span>
    <span class="s4">// pieces[0] is an empty string.</span>
    <span class="s0">let </span><span class="s1">pointer = </span><span class="s3">1</span><span class="s0">;</span>
    <span class="s4">// Positive is the number of real directories we've output, used for popping a parent directory.</span>
    <span class="s4">// Eg, &quot;foo/bar/..&quot; will have a positive 2, and we can decrement to be left with just &quot;foo&quot;.</span>
    <span class="s0">let </span><span class="s1">positive = </span><span class="s3">0</span><span class="s0">;</span>
    <span class="s4">// We need to keep a trailing slash if we encounter an empty directory (eg, splitting &quot;foo/&quot; will</span>
    <span class="s4">// generate `[&quot;foo&quot;, &quot;&quot;]` pieces). And, if we pop a parent directory. But once we encounter a</span>
    <span class="s4">// real directory, we won't need to append, unless the other conditions happen again.</span>
    <span class="s0">let </span><span class="s1">addTrailingSlash = </span><span class="s0">false;</span>
    <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s3">1</span><span class="s0">; </span><span class="s1">i &lt; pieces.length</span><span class="s0">; </span><span class="s1">i++) {</span>
        <span class="s0">const </span><span class="s1">piece = pieces[i]</span><span class="s0">;</span>
        <span class="s4">// An empty directory, could be a trailing slash, or just a double &quot;//&quot; in the path.</span>
        <span class="s0">if </span><span class="s1">(!piece) {</span>
            <span class="s1">addTrailingSlash = </span><span class="s0">true;</span>
            <span class="s0">continue;</span>
        <span class="s1">}</span>
        <span class="s4">// If we encounter a real directory, then we don't need to append anymore.</span>
        <span class="s1">addTrailingSlash = </span><span class="s0">false;</span>
        <span class="s4">// A current directory, which we can always drop.</span>
        <span class="s0">if </span><span class="s1">(piece === </span><span class="s2">'.'</span><span class="s1">)</span>
            <span class="s0">continue;</span>
        <span class="s4">// A parent directory, we need to see if there are any real directories we can pop. Else, we</span>
        <span class="s4">// have an excess of parents, and we'll need to keep the &quot;..&quot;.</span>
        <span class="s0">if </span><span class="s1">(piece === </span><span class="s2">'..'</span><span class="s1">) {</span>
            <span class="s0">if </span><span class="s1">(positive) {</span>
                <span class="s1">addTrailingSlash = </span><span class="s0">true;</span>
                <span class="s1">positive--</span><span class="s0">;</span>
                <span class="s1">pointer--</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s0">else if </span><span class="s1">(rel) {</span>
                <span class="s4">// If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute</span>
                <span class="s4">// URL, protocol relative URL, or an absolute path, we don't need to keep excess.</span>
                <span class="s1">pieces[pointer++] = piece</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s0">continue;</span>
        <span class="s1">}</span>
        <span class="s4">// We've encountered a real directory. Move it to the next insertion pointer, which accounts for</span>
        <span class="s4">// any popped or dropped directories.</span>
        <span class="s1">pieces[pointer++] = piece</span><span class="s0">;</span>
        <span class="s1">positive++</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">let </span><span class="s1">path = </span><span class="s2">''</span><span class="s0">;</span>
    <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s3">1</span><span class="s0">; </span><span class="s1">i &lt; pointer</span><span class="s0">; </span><span class="s1">i++) {</span>
        <span class="s1">path += </span><span class="s2">'/' </span><span class="s1">+ pieces[i]</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">if </span><span class="s1">(!path || (addTrailingSlash &amp;&amp; !path.endsWith(</span><span class="s2">'/..'</span><span class="s1">))) {</span>
        <span class="s1">path += </span><span class="s2">'/'</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s1">url.path = path</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s5">/**</span>
 <span class="s5">* Attempts to resolve `input` URL/path relative to `base`.</span>
 <span class="s5">*/</span>
<span class="s0">function </span><span class="s1">resolve$1(input</span><span class="s0">, </span><span class="s1">base) {</span>
    <span class="s0">if </span><span class="s1">(!input &amp;&amp; !base)</span>
        <span class="s0">return </span><span class="s2">''</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">url = parseUrl(input)</span><span class="s0">;</span>
    <span class="s0">let </span><span class="s1">inputType = url.type</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(base &amp;&amp; inputType !== UrlType.Absolute) {</span>
        <span class="s0">const </span><span class="s1">baseUrl = parseUrl(base)</span><span class="s0">;</span>
        <span class="s0">const </span><span class="s1">baseType = baseUrl.type</span><span class="s0">;</span>
        <span class="s0">switch </span><span class="s1">(inputType) {</span>
            <span class="s0">case </span><span class="s1">UrlType.Empty:</span>
                <span class="s1">url.hash = baseUrl.hash</span><span class="s0">;</span>
            <span class="s4">// fall through</span>
            <span class="s0">case </span><span class="s1">UrlType.Hash:</span>
                <span class="s1">url.query = baseUrl.query</span><span class="s0">;</span>
            <span class="s4">// fall through</span>
            <span class="s0">case </span><span class="s1">UrlType.Query:</span>
            <span class="s0">case </span><span class="s1">UrlType.RelativePath:</span>
                <span class="s1">mergePaths(url</span><span class="s0">, </span><span class="s1">baseUrl)</span><span class="s0">;</span>
            <span class="s4">// fall through</span>
            <span class="s0">case </span><span class="s1">UrlType.AbsolutePath:</span>
                <span class="s4">// The host, user, and port are joined, you can't copy one without the others.</span>
                <span class="s1">url.user = baseUrl.user</span><span class="s0">;</span>
                <span class="s1">url.host = baseUrl.host</span><span class="s0">;</span>
                <span class="s1">url.port = baseUrl.port</span><span class="s0">;</span>
            <span class="s4">// fall through</span>
            <span class="s0">case </span><span class="s1">UrlType.SchemeRelative:</span>
                <span class="s4">// The input doesn't have a schema at least, so we need to copy at least that over.</span>
                <span class="s1">url.scheme = baseUrl.scheme</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(baseType &gt; inputType)</span>
            <span class="s1">inputType = baseType</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s1">normalizePath(url</span><span class="s0">, </span><span class="s1">inputType)</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">queryHash = url.query + url.hash</span><span class="s0">;</span>
    <span class="s0">switch </span><span class="s1">(inputType) {</span>
        <span class="s4">// This is impossible, because of the empty checks at the start of the function.</span>
        <span class="s4">// case UrlType.Empty:</span>
        <span class="s0">case </span><span class="s1">UrlType.Hash:</span>
        <span class="s0">case </span><span class="s1">UrlType.Query:</span>
            <span class="s0">return </span><span class="s1">queryHash</span><span class="s0">;</span>
        <span class="s0">case </span><span class="s1">UrlType.RelativePath: {</span>
            <span class="s4">// The first char is always a &quot;/&quot;, and we need it to be relative.</span>
            <span class="s0">const </span><span class="s1">path = url.path.slice(</span><span class="s3">1</span><span class="s1">)</span><span class="s0">;</span>
            <span class="s0">if </span><span class="s1">(!path)</span>
                <span class="s0">return </span><span class="s1">queryHash || </span><span class="s2">'.'</span><span class="s0">;</span>
            <span class="s0">if </span><span class="s1">(isRelative(base || input) &amp;&amp; !isRelative(path)) {</span>
                <span class="s4">// If base started with a leading &quot;.&quot;, or there is no base and input started with a &quot;.&quot;,</span>
                <span class="s4">// then we need to ensure that the relative path starts with a &quot;.&quot;. We don't know if</span>
                <span class="s4">// relative starts with a &quot;..&quot;, though, so check before prepending.</span>
                <span class="s0">return </span><span class="s2">'./' </span><span class="s1">+ path + queryHash</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s0">return </span><span class="s1">path + queryHash</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">case </span><span class="s1">UrlType.AbsolutePath:</span>
            <span class="s0">return </span><span class="s1">url.path + queryHash</span><span class="s0">;</span>
        <span class="s0">default</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">url.scheme + </span><span class="s2">'//' </span><span class="s1">+ url.user + url.host + url.port + url.path + queryHash</span><span class="s0">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">resolve(input</span><span class="s0">, </span><span class="s1">base) {</span>
    <span class="s4">// The base is always treated as a directory, if it's not empty.</span>
    <span class="s4">// https://github.com/mozilla/source-map/blob/8cb3ee57/lib/util.js#L327</span>
    <span class="s4">// https://github.com/chromium/chromium/blob/da4adbb3/third_party/blink/renderer/devtools/front_end/sdk/SourceMap.js#L400-L401</span>
    <span class="s0">if </span><span class="s1">(base &amp;&amp; !base.endsWith(</span><span class="s2">'/'</span><span class="s1">))</span>
        <span class="s1">base += </span><span class="s2">'/'</span><span class="s0">;</span>
    <span class="s0">return </span><span class="s1">resolve$1(input</span><span class="s0">, </span><span class="s1">base)</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s5">/**</span>
 <span class="s5">* Removes everything after the last &quot;/&quot;, but leaves the slash.</span>
 <span class="s5">*/</span>
<span class="s0">function </span><span class="s1">stripFilename(path) {</span>
    <span class="s0">if </span><span class="s1">(!path)</span>
        <span class="s0">return </span><span class="s2">''</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">index = path.lastIndexOf(</span><span class="s2">'/'</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s0">return </span><span class="s1">path.slice(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">index + </span><span class="s3">1</span><span class="s1">)</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">const </span><span class="s1">COLUMN$1 = </span><span class="s3">0</span><span class="s0">;</span>

<span class="s0">function </span><span class="s1">maybeSort(mappings</span><span class="s0">, </span><span class="s1">owned) {</span>
    <span class="s0">const </span><span class="s1">unsortedIndex = nextUnsortedSegmentLine(mappings</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(unsortedIndex === mappings.length)</span>
        <span class="s0">return </span><span class="s1">mappings</span><span class="s0">;</span>
    <span class="s4">// If we own the array (meaning we parsed it from JSON), then we're free to directly mutate it. If</span>
    <span class="s4">// not, we do not want to modify the consumer's input array.</span>
    <span class="s0">if </span><span class="s1">(!owned)</span>
        <span class="s1">mappings = mappings.slice()</span><span class="s0">;</span>
    <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = unsortedIndex</span><span class="s0">; </span><span class="s1">i &lt; mappings.length</span><span class="s0">; </span><span class="s1">i = nextUnsortedSegmentLine(mappings</span><span class="s0">, </span><span class="s1">i + </span><span class="s3">1</span><span class="s1">)) {</span>
        <span class="s1">mappings[i] = sortSegments(mappings[i]</span><span class="s0">, </span><span class="s1">owned)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">mappings</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">nextUnsortedSegmentLine(mappings</span><span class="s0">, </span><span class="s1">start) {</span>
    <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = start</span><span class="s0">; </span><span class="s1">i &lt; mappings.length</span><span class="s0">; </span><span class="s1">i++) {</span>
        <span class="s0">if </span><span class="s1">(!isSorted(mappings[i]))</span>
            <span class="s0">return </span><span class="s1">i</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">mappings.length</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">isSorted(line) {</span>
    <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">j = </span><span class="s3">1</span><span class="s0">; </span><span class="s1">j &lt; line.length</span><span class="s0">; </span><span class="s1">j++) {</span>
        <span class="s0">if </span><span class="s1">(line[j][COLUMN$1] &lt; line[j - </span><span class="s3">1</span><span class="s1">][COLUMN$1]) {</span>
            <span class="s0">return false;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">return true;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">sortSegments(line</span><span class="s0">, </span><span class="s1">owned) {</span>
    <span class="s0">if </span><span class="s1">(!owned)</span>
        <span class="s1">line = line.slice()</span><span class="s0">;</span>
    <span class="s0">return </span><span class="s1">line.sort(sortComparator)</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">sortComparator(a</span><span class="s0">, </span><span class="s1">b) {</span>
    <span class="s0">return </span><span class="s1">a[COLUMN$1] - b[COLUMN$1]</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">memoizedState() {</span>
    <span class="s0">return </span><span class="s1">{</span>
        <span class="s1">lastKey: -</span><span class="s3">1</span><span class="s0">,</span>
        <span class="s1">lastNeedle: -</span><span class="s3">1</span><span class="s0">,</span>
        <span class="s1">lastIndex: -</span><span class="s3">1</span><span class="s0">,</span>
    <span class="s1">}</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s5">/**</span>
 <span class="s5">* Returns the decoded (array of lines of segments) form of the SourceMap's mappings field.</span>
 <span class="s5">*/</span>
<span class="s0">let </span><span class="s1">decodedMappings</span><span class="s0">;</span>
<span class="s5">/**</span>
 <span class="s5">* Iterates each mapping in generated position order.</span>
 <span class="s5">*/</span>
<span class="s0">let </span><span class="s1">eachMapping</span><span class="s0">;</span>
<span class="s0">class </span><span class="s1">TraceMap {</span>
    <span class="s1">constructor(map</span><span class="s0">, </span><span class="s1">mapUrl) {</span>
        <span class="s0">const </span><span class="s1">isString = </span><span class="s0">typeof </span><span class="s1">map === </span><span class="s2">'string'</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(!isString &amp;&amp; map._decodedMemo)</span>
            <span class="s0">return </span><span class="s1">map</span><span class="s0">;</span>
        <span class="s0">const </span><span class="s1">parsed = (isString ? JSON.parse(map) : map)</span><span class="s0">;</span>
        <span class="s0">const </span><span class="s1">{ version</span><span class="s0">, </span><span class="s1">file</span><span class="s0">, </span><span class="s1">names</span><span class="s0">, </span><span class="s1">sourceRoot</span><span class="s0">, </span><span class="s1">sources</span><span class="s0">, </span><span class="s1">sourcesContent } = parsed</span><span class="s0">;</span>
        <span class="s0">this</span><span class="s1">.version = version</span><span class="s0">;</span>
        <span class="s0">this</span><span class="s1">.file = file</span><span class="s0">;</span>
        <span class="s0">this</span><span class="s1">.names = names</span><span class="s0">;</span>
        <span class="s0">this</span><span class="s1">.sourceRoot = sourceRoot</span><span class="s0">;</span>
        <span class="s0">this</span><span class="s1">.sources = sources</span><span class="s0">;</span>
        <span class="s0">this</span><span class="s1">.sourcesContent = sourcesContent</span><span class="s0">;</span>
        <span class="s0">const </span><span class="s1">from = resolve(sourceRoot || </span><span class="s2">''</span><span class="s0">, </span><span class="s1">stripFilename(mapUrl))</span><span class="s0">;</span>
        <span class="s0">this</span><span class="s1">.resolvedSources = sources.map((s) =&gt; resolve(s || </span><span class="s2">''</span><span class="s0">, </span><span class="s1">from))</span><span class="s0">;</span>
        <span class="s0">const </span><span class="s1">{ mappings } = parsed</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">mappings === </span><span class="s2">'string'</span><span class="s1">) {</span>
            <span class="s0">this</span><span class="s1">._encoded = mappings</span><span class="s0">;</span>
            <span class="s0">this</span><span class="s1">._decoded = undefined</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">else </span><span class="s1">{</span>
            <span class="s0">this</span><span class="s1">._encoded = undefined</span><span class="s0">;</span>
            <span class="s0">this</span><span class="s1">._decoded = maybeSort(mappings</span><span class="s0">, </span><span class="s1">isString)</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">this</span><span class="s1">._decodedMemo = memoizedState()</span><span class="s0">;</span>
        <span class="s0">this</span><span class="s1">._bySources = undefined</span><span class="s0">;</span>
        <span class="s0">this</span><span class="s1">._bySourceMemos = undefined</span><span class="s0">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">(() =&gt; {</span>
    <span class="s1">decodedMappings = (map) =&gt; {</span>
        <span class="s0">return </span><span class="s1">(map._decoded || (map._decoded = decode(map._encoded)))</span><span class="s0">;</span>
    <span class="s1">}</span><span class="s0">;</span>
    <span class="s1">eachMapping = (map</span><span class="s0">, </span><span class="s1">cb) =&gt; {</span>
        <span class="s0">const </span><span class="s1">decoded = decodedMappings(map)</span><span class="s0">;</span>
        <span class="s0">const </span><span class="s1">{ names</span><span class="s0">, </span><span class="s1">resolvedSources } = map</span><span class="s0">;</span>
        <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s3">0</span><span class="s0">; </span><span class="s1">i &lt; decoded.length</span><span class="s0">; </span><span class="s1">i++) {</span>
            <span class="s0">const </span><span class="s1">line = decoded[i]</span><span class="s0">;</span>
            <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">j = </span><span class="s3">0</span><span class="s0">; </span><span class="s1">j &lt; line.length</span><span class="s0">; </span><span class="s1">j++) {</span>
                <span class="s0">const </span><span class="s1">seg = line[j]</span><span class="s0">;</span>
                <span class="s0">const </span><span class="s1">generatedLine = i + </span><span class="s3">1</span><span class="s0">;</span>
                <span class="s0">const </span><span class="s1">generatedColumn = seg[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">;</span>
                <span class="s0">let </span><span class="s1">source = </span><span class="s0">null;</span>
                <span class="s0">let </span><span class="s1">originalLine = </span><span class="s0">null;</span>
                <span class="s0">let </span><span class="s1">originalColumn = </span><span class="s0">null;</span>
                <span class="s0">let </span><span class="s1">name = </span><span class="s0">null;</span>
                <span class="s0">if </span><span class="s1">(seg.length !== </span><span class="s3">1</span><span class="s1">) {</span>
                    <span class="s1">source = resolvedSources[seg[</span><span class="s3">1</span><span class="s1">]]</span><span class="s0">;</span>
                    <span class="s1">originalLine = seg[</span><span class="s3">2</span><span class="s1">] + </span><span class="s3">1</span><span class="s0">;</span>
                    <span class="s1">originalColumn = seg[</span><span class="s3">3</span><span class="s1">]</span><span class="s0">;</span>
                <span class="s1">}</span>
                <span class="s0">if </span><span class="s1">(seg.length === </span><span class="s3">5</span><span class="s1">)</span>
                    <span class="s1">name = names[seg[</span><span class="s3">4</span><span class="s1">]]</span><span class="s0">;</span>
                <span class="s1">cb({</span>
                    <span class="s1">generatedLine</span><span class="s0">,</span>
                    <span class="s1">generatedColumn</span><span class="s0">,</span>
                    <span class="s1">source</span><span class="s0">,</span>
                    <span class="s1">originalLine</span><span class="s0">,</span>
                    <span class="s1">originalColumn</span><span class="s0">,</span>
                    <span class="s1">name</span><span class="s0">,</span>
                <span class="s1">})</span><span class="s0">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span><span class="s0">;</span>
<span class="s1">})()</span><span class="s0">;</span>

<span class="s5">/**</span>
 <span class="s5">* Gets the index associated with `key` in the backing array, if it is already present.</span>
 <span class="s5">*/</span>
<span class="s0">let </span><span class="s1">get</span><span class="s0">;</span>
<span class="s5">/**</span>
 <span class="s5">* Puts `key` into the backing array, if it is not already present. Returns</span>
 <span class="s5">* the index of the `key` in the backing array.</span>
 <span class="s5">*/</span>
<span class="s0">let </span><span class="s1">put</span><span class="s0">;</span>
<span class="s5">/**</span>
 <span class="s5">* SetArray acts like a `Set` (allowing only one occurrence of a string `key`), but provides the</span>
 <span class="s5">* index of the `key` in the backing array.</span>
 <span class="s5">*</span>
 <span class="s5">* This is designed to allow synchronizing a second array with the contents of the backing array,</span>
 <span class="s5">* like how in a sourcemap `sourcesContent[i]` is the source content associated with `source[i]`,</span>
 <span class="s5">* and there are never duplicates.</span>
 <span class="s5">*/</span>
<span class="s0">class </span><span class="s1">SetArray {</span>
    <span class="s1">constructor() {</span>
        <span class="s0">this</span><span class="s1">._indexes = { __proto__: </span><span class="s0">null </span><span class="s1">}</span><span class="s0">;</span>
        <span class="s0">this</span><span class="s1">.array = []</span><span class="s0">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">(() =&gt; {</span>
    <span class="s1">get = (strarr</span><span class="s0">, </span><span class="s1">key) =&gt; strarr._indexes[key]</span><span class="s0">;</span>
    <span class="s1">put = (strarr</span><span class="s0">, </span><span class="s1">key) =&gt; {</span>
        <span class="s4">// The key may or may not be present. If it is present, it's a number.</span>
        <span class="s0">const </span><span class="s1">index = get(strarr</span><span class="s0">, </span><span class="s1">key)</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(index !== undefined)</span>
            <span class="s0">return </span><span class="s1">index</span><span class="s0">;</span>
        <span class="s0">const </span><span class="s1">{ array</span><span class="s0">, </span><span class="s1">_indexes: indexes } = strarr</span><span class="s0">;</span>
        <span class="s0">return </span><span class="s1">(indexes[key] = array.push(key) - </span><span class="s3">1</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s1">}</span><span class="s0">;</span>
<span class="s1">})()</span><span class="s0">;</span>

<span class="s0">const </span><span class="s1">COLUMN = </span><span class="s3">0</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">SOURCES_INDEX = </span><span class="s3">1</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">SOURCE_LINE = </span><span class="s3">2</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">SOURCE_COLUMN = </span><span class="s3">3</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">NAMES_INDEX = </span><span class="s3">4</span><span class="s0">;</span>

<span class="s0">const </span><span class="s1">NO_NAME = -</span><span class="s3">1</span><span class="s0">;</span>
<span class="s5">/**</span>
 <span class="s5">* A high-level API to associate a generated position with an original source position. Line is</span>
 <span class="s5">* 1-based, but column is 0-based, due to legacy behavior in `source-map` library.</span>
 <span class="s5">*/</span>
<span class="s0">let </span><span class="s1">addMapping</span><span class="s0">;</span>
<span class="s5">/**</span>
 <span class="s5">* Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects</span>
 <span class="s5">* a sourcemap, or to JSON.stringify.</span>
 <span class="s5">*/</span>
<span class="s0">let </span><span class="s1">toDecodedMap</span><span class="s0">;</span>
<span class="s5">/**</span>
 <span class="s5">* Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects</span>
 <span class="s5">* a sourcemap, or to JSON.stringify.</span>
 <span class="s5">*/</span>
<span class="s0">let </span><span class="s1">toEncodedMap</span><span class="s0">;</span>
<span class="s5">/**</span>
 <span class="s5">* Constructs a new GenMapping, using the already present mappings of the input.</span>
 <span class="s5">*/</span>
<span class="s0">let </span><span class="s1">fromMap</span><span class="s0">;</span>
<span class="s4">// This split declaration is only so that terser can elminiate the static initialization block.</span>
<span class="s0">let </span><span class="s1">addSegmentInternal</span><span class="s0">;</span>
<span class="s5">/**</span>
 <span class="s5">* Provides the state to generate a sourcemap.</span>
 <span class="s5">*/</span>
<span class="s0">class </span><span class="s1">GenMapping {</span>
    <span class="s1">constructor({ file</span><span class="s0">, </span><span class="s1">sourceRoot } = {}) {</span>
        <span class="s0">this</span><span class="s1">._names = </span><span class="s0">new </span><span class="s1">SetArray()</span><span class="s0">;</span>
        <span class="s0">this</span><span class="s1">._sources = </span><span class="s0">new </span><span class="s1">SetArray()</span><span class="s0">;</span>
        <span class="s0">this</span><span class="s1">._sourcesContent = []</span><span class="s0">;</span>
        <span class="s0">this</span><span class="s1">._mappings = []</span><span class="s0">;</span>
        <span class="s0">this</span><span class="s1">.file = file</span><span class="s0">;</span>
        <span class="s0">this</span><span class="s1">.sourceRoot = sourceRoot</span><span class="s0">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">(() =&gt; {</span>
    <span class="s1">addMapping = (map</span><span class="s0">, </span><span class="s1">mapping) =&gt; {</span>
        <span class="s0">return </span><span class="s1">addMappingInternal(</span><span class="s0">false, </span><span class="s1">map</span><span class="s0">, </span><span class="s1">mapping)</span><span class="s0">;</span>
    <span class="s1">}</span><span class="s0">;</span>
    <span class="s1">toDecodedMap = (map) =&gt; {</span>
        <span class="s0">const </span><span class="s1">{ file</span><span class="s0">, </span><span class="s1">sourceRoot</span><span class="s0">, </span><span class="s1">_mappings: mappings</span><span class="s0">, </span><span class="s1">_sources: sources</span><span class="s0">, </span><span class="s1">_sourcesContent: sourcesContent</span><span class="s0">, </span><span class="s1">_names: names</span><span class="s0">, </span><span class="s1">} = map</span><span class="s0">;</span>
        <span class="s1">removeEmptyFinalLines(mappings)</span><span class="s0">;</span>
        <span class="s0">return </span><span class="s1">{</span>
            <span class="s1">version: </span><span class="s3">3</span><span class="s0">,</span>
            <span class="s1">file: file || undefined</span><span class="s0">,</span>
            <span class="s1">names: names.array</span><span class="s0">,</span>
            <span class="s1">sourceRoot: sourceRoot || undefined</span><span class="s0">,</span>
            <span class="s1">sources: sources.array</span><span class="s0">,</span>
            <span class="s1">sourcesContent</span><span class="s0">,</span>
            <span class="s1">mappings</span><span class="s0">,</span>
        <span class="s1">}</span><span class="s0">;</span>
    <span class="s1">}</span><span class="s0">;</span>
    <span class="s1">toEncodedMap = (map) =&gt; {</span>
        <span class="s0">const </span><span class="s1">decoded = toDecodedMap(map)</span><span class="s0">;</span>
        <span class="s0">return </span><span class="s1">Object.assign(Object.assign({}</span><span class="s0">, </span><span class="s1">decoded)</span><span class="s0">, </span><span class="s1">{ mappings: encode(decoded.mappings) })</span><span class="s0">;</span>
    <span class="s1">}</span><span class="s0">;</span>
    <span class="s1">fromMap = (input) =&gt; {</span>
        <span class="s0">const </span><span class="s1">map = </span><span class="s0">new </span><span class="s1">TraceMap(input)</span><span class="s0">;</span>
        <span class="s0">const </span><span class="s1">gen = </span><span class="s0">new </span><span class="s1">GenMapping({ file: map.file</span><span class="s0">, </span><span class="s1">sourceRoot: map.sourceRoot })</span><span class="s0">;</span>
        <span class="s1">putAll(gen._names</span><span class="s0">, </span><span class="s1">map.names)</span><span class="s0">;</span>
        <span class="s1">putAll(gen._sources</span><span class="s0">, </span><span class="s1">map.sources)</span><span class="s0">;</span>
        <span class="s1">gen._sourcesContent = map.sourcesContent || map.sources.map(() =&gt; </span><span class="s0">null</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s1">gen._mappings = decodedMappings(map)</span><span class="s0">;</span>
        <span class="s0">return </span><span class="s1">gen</span><span class="s0">;</span>
    <span class="s1">}</span><span class="s0">;</span>
    <span class="s4">// Internal helpers</span>
    <span class="s1">addSegmentInternal = (skipable</span><span class="s0">, </span><span class="s1">map</span><span class="s0">, </span><span class="s1">genLine</span><span class="s0">, </span><span class="s1">genColumn</span><span class="s0">, </span><span class="s1">source</span><span class="s0">, </span><span class="s1">sourceLine</span><span class="s0">, </span><span class="s1">sourceColumn</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">content) =&gt; {</span>
        <span class="s0">const </span><span class="s1">{ _mappings: mappings</span><span class="s0">, </span><span class="s1">_sources: sources</span><span class="s0">, </span><span class="s1">_sourcesContent: sourcesContent</span><span class="s0">, </span><span class="s1">_names: names</span><span class="s0">, </span><span class="s1">} = map</span><span class="s0">;</span>
        <span class="s0">const </span><span class="s1">line = getLine(mappings</span><span class="s0">, </span><span class="s1">genLine)</span><span class="s0">;</span>
        <span class="s0">const </span><span class="s1">index = getColumnIndex(line</span><span class="s0">, </span><span class="s1">genColumn)</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(!source) {</span>
            <span class="s0">if </span><span class="s1">(skipable &amp;&amp; skipSourceless(line</span><span class="s0">, </span><span class="s1">index))</span>
                <span class="s0">return;</span>
            <span class="s0">return </span><span class="s1">insert(line</span><span class="s0">, </span><span class="s1">index</span><span class="s0">, </span><span class="s1">[genColumn])</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">const </span><span class="s1">sourcesIndex = put(sources</span><span class="s0">, </span><span class="s1">source)</span><span class="s0">;</span>
        <span class="s0">const </span><span class="s1">namesIndex = name ? put(names</span><span class="s0">, </span><span class="s1">name) : NO_NAME</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(sourcesIndex === sourcesContent.length)</span>
            <span class="s1">sourcesContent[sourcesIndex] = content !== </span><span class="s0">null </span><span class="s1">&amp;&amp; content !== </span><span class="s0">void </span><span class="s3">0 </span><span class="s1">? content : </span><span class="s0">null;</span>
        <span class="s0">if </span><span class="s1">(skipable &amp;&amp; skipSource(line</span><span class="s0">, </span><span class="s1">index</span><span class="s0">, </span><span class="s1">sourcesIndex</span><span class="s0">, </span><span class="s1">sourceLine</span><span class="s0">, </span><span class="s1">sourceColumn</span><span class="s0">, </span><span class="s1">namesIndex)) {</span>
            <span class="s0">return;</span>
        <span class="s1">}</span>
        <span class="s0">return </span><span class="s1">insert(line</span><span class="s0">, </span><span class="s1">index</span><span class="s0">, </span><span class="s1">name</span>
            <span class="s1">? [genColumn</span><span class="s0">, </span><span class="s1">sourcesIndex</span><span class="s0">, </span><span class="s1">sourceLine</span><span class="s0">, </span><span class="s1">sourceColumn</span><span class="s0">, </span><span class="s1">namesIndex]</span>
            <span class="s1">: [genColumn</span><span class="s0">, </span><span class="s1">sourcesIndex</span><span class="s0">, </span><span class="s1">sourceLine</span><span class="s0">, </span><span class="s1">sourceColumn])</span><span class="s0">;</span>
    <span class="s1">}</span><span class="s0">;</span>
<span class="s1">})()</span><span class="s0">;</span>
<span class="s0">function </span><span class="s1">getLine(mappings</span><span class="s0">, </span><span class="s1">index) {</span>
    <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = mappings.length</span><span class="s0">; </span><span class="s1">i &lt;= index</span><span class="s0">; </span><span class="s1">i++) {</span>
        <span class="s1">mappings[i] = []</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">mappings[index]</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">getColumnIndex(line</span><span class="s0">, </span><span class="s1">genColumn) {</span>
    <span class="s0">let </span><span class="s1">index = line.length</span><span class="s0">;</span>
    <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = index - </span><span class="s3">1</span><span class="s0">; </span><span class="s1">i &gt;= </span><span class="s3">0</span><span class="s0">; </span><span class="s1">index = i--) {</span>
        <span class="s0">const </span><span class="s1">current = line[i]</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(genColumn &gt;= current[COLUMN])</span>
            <span class="s0">break;</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">index</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">insert(array</span><span class="s0">, </span><span class="s1">index</span><span class="s0">, </span><span class="s1">value) {</span>
    <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = array.length</span><span class="s0">; </span><span class="s1">i &gt; index</span><span class="s0">; </span><span class="s1">i--) {</span>
        <span class="s1">array[i] = array[i - </span><span class="s3">1</span><span class="s1">]</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s1">array[index] = value</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">removeEmptyFinalLines(mappings) {</span>
    <span class="s0">const </span><span class="s1">{ length } = mappings</span><span class="s0">;</span>
    <span class="s0">let </span><span class="s1">len = length</span><span class="s0">;</span>
    <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = len - </span><span class="s3">1</span><span class="s0">; </span><span class="s1">i &gt;= </span><span class="s3">0</span><span class="s0">; </span><span class="s1">len = i</span><span class="s0">, </span><span class="s1">i--) {</span>
        <span class="s0">if </span><span class="s1">(mappings[i].length &gt; </span><span class="s3">0</span><span class="s1">)</span>
            <span class="s0">break;</span>
    <span class="s1">}</span>
    <span class="s0">if </span><span class="s1">(len &lt; length)</span>
        <span class="s1">mappings.length = len</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">putAll(strarr</span><span class="s0">, </span><span class="s1">array) {</span>
    <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s3">0</span><span class="s0">; </span><span class="s1">i &lt; array.length</span><span class="s0">; </span><span class="s1">i++)</span>
        <span class="s1">put(strarr</span><span class="s0">, </span><span class="s1">array[i])</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">skipSourceless(line</span><span class="s0">, </span><span class="s1">index) {</span>
    <span class="s4">// The start of a line is already sourceless, so adding a sourceless segment to the beginning</span>
    <span class="s4">// doesn't generate any useful information.</span>
    <span class="s0">if </span><span class="s1">(index === </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s0">return true;</span>
    <span class="s0">const </span><span class="s1">prev = line[index - </span><span class="s3">1</span><span class="s1">]</span><span class="s0">;</span>
    <span class="s4">// If the previous segment is also sourceless, then adding another sourceless segment doesn't</span>
    <span class="s4">// genrate any new information. Else, this segment will end the source/named segment and point to</span>
    <span class="s4">// a sourceless position, which is useful.</span>
    <span class="s0">return </span><span class="s1">prev.length === </span><span class="s3">1</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">skipSource(line</span><span class="s0">, </span><span class="s1">index</span><span class="s0">, </span><span class="s1">sourcesIndex</span><span class="s0">, </span><span class="s1">sourceLine</span><span class="s0">, </span><span class="s1">sourceColumn</span><span class="s0">, </span><span class="s1">namesIndex) {</span>
    <span class="s4">// A source/named segment at the start of a line gives position at that genColumn</span>
    <span class="s0">if </span><span class="s1">(index === </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s0">return false;</span>
    <span class="s0">const </span><span class="s1">prev = line[index - </span><span class="s3">1</span><span class="s1">]</span><span class="s0">;</span>
    <span class="s4">// If the previous segment is sourceless, then we're transitioning to a source.</span>
    <span class="s0">if </span><span class="s1">(prev.length === </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s0">return false;</span>
    <span class="s4">// If the previous segment maps to the exact same source position, then this segment doesn't</span>
    <span class="s4">// provide any new position information.</span>
    <span class="s0">return </span><span class="s1">(sourcesIndex === prev[SOURCES_INDEX] &amp;&amp;</span>
        <span class="s1">sourceLine === prev[SOURCE_LINE] &amp;&amp;</span>
        <span class="s1">sourceColumn === prev[SOURCE_COLUMN] &amp;&amp;</span>
        <span class="s1">namesIndex === (prev.length === </span><span class="s3">5 </span><span class="s1">? prev[NAMES_INDEX] : NO_NAME))</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">addMappingInternal(skipable</span><span class="s0">, </span><span class="s1">map</span><span class="s0">, </span><span class="s1">mapping) {</span>
    <span class="s0">const </span><span class="s1">{ generated</span><span class="s0">, </span><span class="s1">source</span><span class="s0">, </span><span class="s1">original</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">content } = mapping</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(!source) {</span>
        <span class="s0">return </span><span class="s1">addSegmentInternal(skipable</span><span class="s0">, </span><span class="s1">map</span><span class="s0">, </span><span class="s1">generated.line - </span><span class="s3">1</span><span class="s0">, </span><span class="s1">generated.column</span><span class="s0">, null, null, null, null, null</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">const </span><span class="s1">s = source</span><span class="s0">;</span>
    <span class="s0">return </span><span class="s1">addSegmentInternal(skipable</span><span class="s0">, </span><span class="s1">map</span><span class="s0">, </span><span class="s1">generated.line - </span><span class="s3">1</span><span class="s0">, </span><span class="s1">generated.column</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">original.line - </span><span class="s3">1</span><span class="s0">, </span><span class="s1">original.column</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">content)</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">getDefaultExportFromCjs (x) {</span>
	<span class="s0">return </span><span class="s1">x &amp;&amp; x.__esModule &amp;&amp; Object.prototype.hasOwnProperty.call(x</span><span class="s0">, </span><span class="s2">'default'</span><span class="s1">) ? x[</span><span class="s2">'default'</span><span class="s1">] : x</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">var </span><span class="s1">srcExports = {}</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">src = {</span>
  <span class="s1">get exports(){ </span><span class="s0">return </span><span class="s1">srcExports</span><span class="s0">; </span><span class="s1">}</span><span class="s0">,</span>
  <span class="s1">set exports(v){ srcExports = v</span><span class="s0">; </span><span class="s1">}</span><span class="s0">,</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">browserExports = {}</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">browser = {</span>
  <span class="s1">get exports(){ </span><span class="s0">return </span><span class="s1">browserExports</span><span class="s0">; </span><span class="s1">}</span><span class="s0">,</span>
  <span class="s1">set exports(v){ browserExports = v</span><span class="s0">; </span><span class="s1">}</span><span class="s0">,</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s5">/**</span>
 <span class="s5">* Helpers.</span>
 <span class="s5">*/</span>

<span class="s0">var </span><span class="s1">ms</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">hasRequiredMs</span><span class="s0">;</span>

<span class="s0">function </span><span class="s1">requireMs () {</span>
	<span class="s0">if </span><span class="s1">(hasRequiredMs) </span><span class="s0">return </span><span class="s1">ms</span><span class="s0">;</span>
	<span class="s1">hasRequiredMs = </span><span class="s3">1</span><span class="s0">;</span>
	<span class="s0">var </span><span class="s1">s = </span><span class="s3">1000</span><span class="s0">;</span>
	<span class="s0">var </span><span class="s1">m = s * </span><span class="s3">60</span><span class="s0">;</span>
	<span class="s0">var </span><span class="s1">h = m * </span><span class="s3">60</span><span class="s0">;</span>
	<span class="s0">var </span><span class="s1">d = h * </span><span class="s3">24</span><span class="s0">;</span>
	<span class="s0">var </span><span class="s1">w = d * </span><span class="s3">7</span><span class="s0">;</span>
	<span class="s0">var </span><span class="s1">y = d * </span><span class="s3">365.25</span><span class="s0">;</span>

	<span class="s5">/**</span>
	 <span class="s5">* Parse or format the given `val`.</span>
	 <span class="s5">*</span>
	 <span class="s5">* Options:</span>
	 <span class="s5">*</span>
	 <span class="s5">*  - `long` verbose formatting [false]</span>
	 <span class="s5">*</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{String|Number} val</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Object} [options]</span>
	 <span class="s5">* </span><span class="s6">@throws </span><span class="s5">{Error} throw an error if val is not a non-empty string or a number</span>
	 <span class="s5">* </span><span class="s6">@return </span><span class="s5">{String|Number}</span>
	 <span class="s5">* </span><span class="s6">@api </span><span class="s5">public</span>
	 <span class="s5">*/</span>

	<span class="s1">ms = </span><span class="s0">function</span><span class="s1">(val</span><span class="s0">, </span><span class="s1">options) {</span>
	  <span class="s1">options = options || {}</span><span class="s0">;</span>
	  <span class="s0">var </span><span class="s1">type = </span><span class="s0">typeof </span><span class="s1">val</span><span class="s0">;</span>
	  <span class="s0">if </span><span class="s1">(type === </span><span class="s2">'string' </span><span class="s1">&amp;&amp; val.length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
	    <span class="s0">return </span><span class="s1">parse(val)</span><span class="s0">;</span>
	  <span class="s1">} </span><span class="s0">else if </span><span class="s1">(type === </span><span class="s2">'number' </span><span class="s1">&amp;&amp; isFinite(val)) {</span>
	    <span class="s0">return </span><span class="s1">options.long ? fmtLong(val) : fmtShort(val)</span><span class="s0">;</span>
	  <span class="s1">}</span>
	  <span class="s0">throw new </span><span class="s1">Error(</span>
	    <span class="s2">'val is not a non-empty string or a valid number. val=' </span><span class="s1">+</span>
	      <span class="s1">JSON.stringify(val)</span>
	  <span class="s1">)</span><span class="s0">;</span>
	<span class="s1">}</span><span class="s0">;</span>

	<span class="s5">/**</span>
	 <span class="s5">* Parse the given `str` and return milliseconds.</span>
	 <span class="s5">*</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{String} str</span>
	 <span class="s5">* </span><span class="s6">@return </span><span class="s5">{Number}</span>
	 <span class="s5">* </span><span class="s6">@api </span><span class="s5">private</span>
	 <span class="s5">*/</span>

	<span class="s0">function </span><span class="s1">parse(str) {</span>
	  <span class="s1">str = String(str)</span><span class="s0">;</span>
	  <span class="s0">if </span><span class="s1">(str.length &gt; </span><span class="s3">100</span><span class="s1">) {</span>
	    <span class="s0">return;</span>
	  <span class="s1">}</span>
	  <span class="s0">var </span><span class="s1">match = </span><span class="s3">/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i</span><span class="s1">.exec(</span>
	    <span class="s1">str</span>
	  <span class="s1">)</span><span class="s0">;</span>
	  <span class="s0">if </span><span class="s1">(!match) {</span>
	    <span class="s0">return;</span>
	  <span class="s1">}</span>
	  <span class="s0">var </span><span class="s1">n = parseFloat(match[</span><span class="s3">1</span><span class="s1">])</span><span class="s0">;</span>
	  <span class="s0">var </span><span class="s1">type = (match[</span><span class="s3">2</span><span class="s1">] || </span><span class="s2">'ms'</span><span class="s1">).toLowerCase()</span><span class="s0">;</span>
	  <span class="s0">switch </span><span class="s1">(type) {</span>
	    <span class="s0">case </span><span class="s2">'years'</span><span class="s1">:</span>
	    <span class="s0">case </span><span class="s2">'year'</span><span class="s1">:</span>
	    <span class="s0">case </span><span class="s2">'yrs'</span><span class="s1">:</span>
	    <span class="s0">case </span><span class="s2">'yr'</span><span class="s1">:</span>
	    <span class="s0">case </span><span class="s2">'y'</span><span class="s1">:</span>
	      <span class="s0">return </span><span class="s1">n * y</span><span class="s0">;</span>
	    <span class="s0">case </span><span class="s2">'weeks'</span><span class="s1">:</span>
	    <span class="s0">case </span><span class="s2">'week'</span><span class="s1">:</span>
	    <span class="s0">case </span><span class="s2">'w'</span><span class="s1">:</span>
	      <span class="s0">return </span><span class="s1">n * w</span><span class="s0">;</span>
	    <span class="s0">case </span><span class="s2">'days'</span><span class="s1">:</span>
	    <span class="s0">case </span><span class="s2">'day'</span><span class="s1">:</span>
	    <span class="s0">case </span><span class="s2">'d'</span><span class="s1">:</span>
	      <span class="s0">return </span><span class="s1">n * d</span><span class="s0">;</span>
	    <span class="s0">case </span><span class="s2">'hours'</span><span class="s1">:</span>
	    <span class="s0">case </span><span class="s2">'hour'</span><span class="s1">:</span>
	    <span class="s0">case </span><span class="s2">'hrs'</span><span class="s1">:</span>
	    <span class="s0">case </span><span class="s2">'hr'</span><span class="s1">:</span>
	    <span class="s0">case </span><span class="s2">'h'</span><span class="s1">:</span>
	      <span class="s0">return </span><span class="s1">n * h</span><span class="s0">;</span>
	    <span class="s0">case </span><span class="s2">'minutes'</span><span class="s1">:</span>
	    <span class="s0">case </span><span class="s2">'minute'</span><span class="s1">:</span>
	    <span class="s0">case </span><span class="s2">'mins'</span><span class="s1">:</span>
	    <span class="s0">case </span><span class="s2">'min'</span><span class="s1">:</span>
	    <span class="s0">case </span><span class="s2">'m'</span><span class="s1">:</span>
	      <span class="s0">return </span><span class="s1">n * m</span><span class="s0">;</span>
	    <span class="s0">case </span><span class="s2">'seconds'</span><span class="s1">:</span>
	    <span class="s0">case </span><span class="s2">'second'</span><span class="s1">:</span>
	    <span class="s0">case </span><span class="s2">'secs'</span><span class="s1">:</span>
	    <span class="s0">case </span><span class="s2">'sec'</span><span class="s1">:</span>
	    <span class="s0">case </span><span class="s2">'s'</span><span class="s1">:</span>
	      <span class="s0">return </span><span class="s1">n * s</span><span class="s0">;</span>
	    <span class="s0">case </span><span class="s2">'milliseconds'</span><span class="s1">:</span>
	    <span class="s0">case </span><span class="s2">'millisecond'</span><span class="s1">:</span>
	    <span class="s0">case </span><span class="s2">'msecs'</span><span class="s1">:</span>
	    <span class="s0">case </span><span class="s2">'msec'</span><span class="s1">:</span>
	    <span class="s0">case </span><span class="s2">'ms'</span><span class="s1">:</span>
	      <span class="s0">return </span><span class="s1">n</span><span class="s0">;</span>
	    <span class="s0">default</span><span class="s1">:</span>
	      <span class="s0">return </span><span class="s1">undefined</span><span class="s0">;</span>
	  <span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* Short format for `ms`.</span>
	 <span class="s5">*</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Number} ms</span>
	 <span class="s5">* </span><span class="s6">@return </span><span class="s5">{String}</span>
	 <span class="s5">* </span><span class="s6">@api </span><span class="s5">private</span>
	 <span class="s5">*/</span>

	<span class="s0">function </span><span class="s1">fmtShort(ms) {</span>
	  <span class="s0">var </span><span class="s1">msAbs = Math.abs(ms)</span><span class="s0">;</span>
	  <span class="s0">if </span><span class="s1">(msAbs &gt;= d) {</span>
	    <span class="s0">return </span><span class="s1">Math.round(ms / d) + </span><span class="s2">'d'</span><span class="s0">;</span>
	  <span class="s1">}</span>
	  <span class="s0">if </span><span class="s1">(msAbs &gt;= h) {</span>
	    <span class="s0">return </span><span class="s1">Math.round(ms / h) + </span><span class="s2">'h'</span><span class="s0">;</span>
	  <span class="s1">}</span>
	  <span class="s0">if </span><span class="s1">(msAbs &gt;= m) {</span>
	    <span class="s0">return </span><span class="s1">Math.round(ms / m) + </span><span class="s2">'m'</span><span class="s0">;</span>
	  <span class="s1">}</span>
	  <span class="s0">if </span><span class="s1">(msAbs &gt;= s) {</span>
	    <span class="s0">return </span><span class="s1">Math.round(ms / s) + </span><span class="s2">'s'</span><span class="s0">;</span>
	  <span class="s1">}</span>
	  <span class="s0">return </span><span class="s1">ms + </span><span class="s2">'ms'</span><span class="s0">;</span>
	<span class="s1">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* Long format for `ms`.</span>
	 <span class="s5">*</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Number} ms</span>
	 <span class="s5">* </span><span class="s6">@return </span><span class="s5">{String}</span>
	 <span class="s5">* </span><span class="s6">@api </span><span class="s5">private</span>
	 <span class="s5">*/</span>

	<span class="s0">function </span><span class="s1">fmtLong(ms) {</span>
	  <span class="s0">var </span><span class="s1">msAbs = Math.abs(ms)</span><span class="s0">;</span>
	  <span class="s0">if </span><span class="s1">(msAbs &gt;= d) {</span>
	    <span class="s0">return </span><span class="s1">plural(ms</span><span class="s0">, </span><span class="s1">msAbs</span><span class="s0">, </span><span class="s1">d</span><span class="s0">, </span><span class="s2">'day'</span><span class="s1">)</span><span class="s0">;</span>
	  <span class="s1">}</span>
	  <span class="s0">if </span><span class="s1">(msAbs &gt;= h) {</span>
	    <span class="s0">return </span><span class="s1">plural(ms</span><span class="s0">, </span><span class="s1">msAbs</span><span class="s0">, </span><span class="s1">h</span><span class="s0">, </span><span class="s2">'hour'</span><span class="s1">)</span><span class="s0">;</span>
	  <span class="s1">}</span>
	  <span class="s0">if </span><span class="s1">(msAbs &gt;= m) {</span>
	    <span class="s0">return </span><span class="s1">plural(ms</span><span class="s0">, </span><span class="s1">msAbs</span><span class="s0">, </span><span class="s1">m</span><span class="s0">, </span><span class="s2">'minute'</span><span class="s1">)</span><span class="s0">;</span>
	  <span class="s1">}</span>
	  <span class="s0">if </span><span class="s1">(msAbs &gt;= s) {</span>
	    <span class="s0">return </span><span class="s1">plural(ms</span><span class="s0">, </span><span class="s1">msAbs</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s2">'second'</span><span class="s1">)</span><span class="s0">;</span>
	  <span class="s1">}</span>
	  <span class="s0">return </span><span class="s1">ms + </span><span class="s2">' ms'</span><span class="s0">;</span>
	<span class="s1">}</span>

	<span class="s5">/**</span>
	 <span class="s5">* Pluralization helper.</span>
	 <span class="s5">*/</span>

	<span class="s0">function </span><span class="s1">plural(ms</span><span class="s0">, </span><span class="s1">msAbs</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">name) {</span>
	  <span class="s0">var </span><span class="s1">isPlural = msAbs &gt;= n * </span><span class="s3">1.5</span><span class="s0">;</span>
	  <span class="s0">return </span><span class="s1">Math.round(ms / n) + </span><span class="s2">' ' </span><span class="s1">+ name + (isPlural ? </span><span class="s2">'s' </span><span class="s1">: </span><span class="s2">''</span><span class="s1">)</span><span class="s0">;</span>
	<span class="s1">}</span>
	<span class="s0">return </span><span class="s1">ms</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">var </span><span class="s1">common</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">hasRequiredCommon</span><span class="s0">;</span>

<span class="s0">function </span><span class="s1">requireCommon () {</span>
	<span class="s0">if </span><span class="s1">(hasRequiredCommon) </span><span class="s0">return </span><span class="s1">common</span><span class="s0">;</span>
	<span class="s1">hasRequiredCommon = </span><span class="s3">1</span><span class="s0">;</span>
	<span class="s5">/**</span>
	 <span class="s5">* This is the common logic for both the Node.js and web browser</span>
	 <span class="s5">* implementations of `debug()`.</span>
	 <span class="s5">*/</span>

	<span class="s0">function </span><span class="s1">setup(env) {</span>
		<span class="s1">createDebug.debug = createDebug</span><span class="s0">;</span>
		<span class="s1">createDebug.default = createDebug</span><span class="s0">;</span>
		<span class="s1">createDebug.coerce = coerce</span><span class="s0">;</span>
		<span class="s1">createDebug.disable = disable</span><span class="s0">;</span>
		<span class="s1">createDebug.enable = enable</span><span class="s0">;</span>
		<span class="s1">createDebug.enabled = enabled</span><span class="s0">;</span>
		<span class="s1">createDebug.humanize = requireMs()</span><span class="s0">;</span>
		<span class="s1">createDebug.destroy = destroy</span><span class="s0">;</span>

		<span class="s1">Object.keys(env).forEach(key =&gt; {</span>
			<span class="s1">createDebug[key] = env[key]</span><span class="s0">;</span>
		<span class="s1">})</span><span class="s0">;</span>

		<span class="s5">/**</span>
		<span class="s5">* The currently active debug mode names, and names to skip.</span>
		<span class="s5">*/</span>

		<span class="s1">createDebug.names = []</span><span class="s0">;</span>
		<span class="s1">createDebug.skips = []</span><span class="s0">;</span>

		<span class="s5">/**</span>
		<span class="s5">* Map of special &quot;%n&quot; handling functions, for the debug &quot;format&quot; argument.</span>
		<span class="s5">*</span>
		<span class="s5">* Valid key names are a single, lower or upper-case letter, i.e. &quot;n&quot; and &quot;N&quot;.</span>
		<span class="s5">*/</span>
		<span class="s1">createDebug.formatters = {}</span><span class="s0">;</span>

		<span class="s5">/**</span>
		<span class="s5">* Selects a color for a debug namespace</span>
		<span class="s5">* </span><span class="s6">@param </span><span class="s5">{String} namespace The namespace string for the debug instance to be colored</span>
		<span class="s5">* </span><span class="s6">@return </span><span class="s5">{Number|String} An ANSI color code for the given namespace</span>
		<span class="s5">* </span><span class="s6">@api </span><span class="s5">private</span>
		<span class="s5">*/</span>
		<span class="s0">function </span><span class="s1">selectColor(namespace) {</span>
			<span class="s0">let </span><span class="s1">hash = </span><span class="s3">0</span><span class="s0">;</span>

			<span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s3">0</span><span class="s0">; </span><span class="s1">i &lt; namespace.length</span><span class="s0">; </span><span class="s1">i++) {</span>
				<span class="s1">hash = ((hash &lt;&lt; </span><span class="s3">5</span><span class="s1">) - hash) + namespace.charCodeAt(i)</span><span class="s0">;</span>
				<span class="s1">hash |= </span><span class="s3">0</span><span class="s0">; </span><span class="s4">// Convert to 32bit integer</span>
			<span class="s1">}</span>

			<span class="s0">return </span><span class="s1">createDebug.colors[Math.abs(hash) % createDebug.colors.length]</span><span class="s0">;</span>
		<span class="s1">}</span>
		<span class="s1">createDebug.selectColor = selectColor</span><span class="s0">;</span>

		<span class="s5">/**</span>
		<span class="s5">* Create a debugger with the given `namespace`.</span>
		<span class="s5">*</span>
		<span class="s5">* </span><span class="s6">@param </span><span class="s5">{String} namespace</span>
		<span class="s5">* </span><span class="s6">@return </span><span class="s5">{Function}</span>
		<span class="s5">* </span><span class="s6">@api </span><span class="s5">public</span>
		<span class="s5">*/</span>
		<span class="s0">function </span><span class="s1">createDebug(namespace) {</span>
			<span class="s0">let </span><span class="s1">prevTime</span><span class="s0">;</span>
			<span class="s0">let </span><span class="s1">enableOverride = </span><span class="s0">null;</span>
			<span class="s0">let </span><span class="s1">namespacesCache</span><span class="s0">;</span>
			<span class="s0">let </span><span class="s1">enabledCache</span><span class="s0">;</span>

			<span class="s0">function </span><span class="s1">debug(...args) {</span>
				<span class="s4">// Disabled?</span>
				<span class="s0">if </span><span class="s1">(!debug.enabled) {</span>
					<span class="s0">return;</span>
				<span class="s1">}</span>

				<span class="s0">const </span><span class="s1">self = debug</span><span class="s0">;</span>

				<span class="s4">// Set `diff` timestamp</span>
				<span class="s0">const </span><span class="s1">curr = Number(</span><span class="s0">new </span><span class="s1">Date())</span><span class="s0">;</span>
				<span class="s0">const </span><span class="s1">ms = curr - (prevTime || curr)</span><span class="s0">;</span>
				<span class="s1">self.diff = ms</span><span class="s0">;</span>
				<span class="s1">self.prev = prevTime</span><span class="s0">;</span>
				<span class="s1">self.curr = curr</span><span class="s0">;</span>
				<span class="s1">prevTime = curr</span><span class="s0">;</span>

				<span class="s1">args[</span><span class="s3">0</span><span class="s1">] = createDebug.coerce(args[</span><span class="s3">0</span><span class="s1">])</span><span class="s0">;</span>

				<span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">args[</span><span class="s3">0</span><span class="s1">] !== </span><span class="s2">'string'</span><span class="s1">) {</span>
					<span class="s4">// Anything else let's inspect with %O</span>
					<span class="s1">args.unshift(</span><span class="s2">'%O'</span><span class="s1">)</span><span class="s0">;</span>
				<span class="s1">}</span>

				<span class="s4">// Apply any `formatters` transformations</span>
				<span class="s0">let </span><span class="s1">index = </span><span class="s3">0</span><span class="s0">;</span>
				<span class="s1">args[</span><span class="s3">0</span><span class="s1">] = args[</span><span class="s3">0</span><span class="s1">].replace(</span><span class="s3">/%([a-zA-Z%])/g</span><span class="s0">, </span><span class="s1">(match</span><span class="s0">, </span><span class="s1">format) =&gt; {</span>
					<span class="s4">// If we encounter an escaped % then don't increase the array index</span>
					<span class="s0">if </span><span class="s1">(match === </span><span class="s2">'%%'</span><span class="s1">) {</span>
						<span class="s0">return </span><span class="s2">'%'</span><span class="s0">;</span>
					<span class="s1">}</span>
					<span class="s1">index++</span><span class="s0">;</span>
					<span class="s0">const </span><span class="s1">formatter = createDebug.formatters[format]</span><span class="s0">;</span>
					<span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">formatter === </span><span class="s2">'function'</span><span class="s1">) {</span>
						<span class="s0">const </span><span class="s1">val = args[index]</span><span class="s0">;</span>
						<span class="s1">match = formatter.call(self</span><span class="s0">, </span><span class="s1">val)</span><span class="s0">;</span>

						<span class="s4">// Now we need to remove `args[index]` since it's inlined in the `format`</span>
						<span class="s1">args.splice(index</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">;</span>
						<span class="s1">index--</span><span class="s0">;</span>
					<span class="s1">}</span>
					<span class="s0">return </span><span class="s1">match</span><span class="s0">;</span>
				<span class="s1">})</span><span class="s0">;</span>

				<span class="s4">// Apply env-specific formatting (colors, etc.)</span>
				<span class="s1">createDebug.formatArgs.call(self</span><span class="s0">, </span><span class="s1">args)</span><span class="s0">;</span>

				<span class="s0">const </span><span class="s1">logFn = self.log || createDebug.log</span><span class="s0">;</span>
				<span class="s1">logFn.apply(self</span><span class="s0">, </span><span class="s1">args)</span><span class="s0">;</span>
			<span class="s1">}</span>

			<span class="s1">debug.namespace = namespace</span><span class="s0">;</span>
			<span class="s1">debug.useColors = createDebug.useColors()</span><span class="s0">;</span>
			<span class="s1">debug.color = createDebug.selectColor(namespace)</span><span class="s0">;</span>
			<span class="s1">debug.extend = extend</span><span class="s0">;</span>
			<span class="s1">debug.destroy = createDebug.destroy</span><span class="s0">; </span><span class="s4">// XXX Temporary. Will be removed in the next major release.</span>

			<span class="s1">Object.defineProperty(debug</span><span class="s0">, </span><span class="s2">'enabled'</span><span class="s0">, </span><span class="s1">{</span>
				<span class="s1">enumerable: </span><span class="s0">true,</span>
				<span class="s1">configurable: </span><span class="s0">false,</span>
				<span class="s1">get: () =&gt; {</span>
					<span class="s0">if </span><span class="s1">(enableOverride !== </span><span class="s0">null</span><span class="s1">) {</span>
						<span class="s0">return </span><span class="s1">enableOverride</span><span class="s0">;</span>
					<span class="s1">}</span>
					<span class="s0">if </span><span class="s1">(namespacesCache !== createDebug.namespaces) {</span>
						<span class="s1">namespacesCache = createDebug.namespaces</span><span class="s0">;</span>
						<span class="s1">enabledCache = createDebug.enabled(namespace)</span><span class="s0">;</span>
					<span class="s1">}</span>

					<span class="s0">return </span><span class="s1">enabledCache</span><span class="s0">;</span>
				<span class="s1">}</span><span class="s0">,</span>
				<span class="s1">set: v =&gt; {</span>
					<span class="s1">enableOverride = v</span><span class="s0">;</span>
				<span class="s1">}</span>
			<span class="s1">})</span><span class="s0">;</span>

			<span class="s4">// Env-specific initialization logic for debug instances</span>
			<span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">createDebug.init === </span><span class="s2">'function'</span><span class="s1">) {</span>
				<span class="s1">createDebug.init(debug)</span><span class="s0">;</span>
			<span class="s1">}</span>

			<span class="s0">return </span><span class="s1">debug</span><span class="s0">;</span>
		<span class="s1">}</span>

		<span class="s0">function </span><span class="s1">extend(namespace</span><span class="s0">, </span><span class="s1">delimiter) {</span>
			<span class="s0">const </span><span class="s1">newDebug = createDebug(</span><span class="s0">this</span><span class="s1">.namespace + (</span><span class="s0">typeof </span><span class="s1">delimiter === </span><span class="s2">'undefined' </span><span class="s1">? </span><span class="s2">':' </span><span class="s1">: delimiter) + namespace)</span><span class="s0">;</span>
			<span class="s1">newDebug.log = </span><span class="s0">this</span><span class="s1">.log</span><span class="s0">;</span>
			<span class="s0">return </span><span class="s1">newDebug</span><span class="s0">;</span>
		<span class="s1">}</span>

		<span class="s5">/**</span>
		<span class="s5">* Enables a debug mode by namespaces. This can include modes</span>
		<span class="s5">* separated by a colon and wildcards.</span>
		<span class="s5">*</span>
		<span class="s5">* </span><span class="s6">@param </span><span class="s5">{String} namespaces</span>
		<span class="s5">* </span><span class="s6">@api </span><span class="s5">public</span>
		<span class="s5">*/</span>
		<span class="s0">function </span><span class="s1">enable(namespaces) {</span>
			<span class="s1">createDebug.save(namespaces)</span><span class="s0">;</span>
			<span class="s1">createDebug.namespaces = namespaces</span><span class="s0">;</span>

			<span class="s1">createDebug.names = []</span><span class="s0">;</span>
			<span class="s1">createDebug.skips = []</span><span class="s0">;</span>

			<span class="s0">let </span><span class="s1">i</span><span class="s0">;</span>
			<span class="s0">const </span><span class="s1">split = (</span><span class="s0">typeof </span><span class="s1">namespaces === </span><span class="s2">'string' </span><span class="s1">? namespaces : </span><span class="s2">''</span><span class="s1">).split(</span><span class="s3">/[\s,]+/</span><span class="s1">)</span><span class="s0">;</span>
			<span class="s0">const </span><span class="s1">len = split.length</span><span class="s0">;</span>

			<span class="s0">for </span><span class="s1">(i = </span><span class="s3">0</span><span class="s0">; </span><span class="s1">i &lt; len</span><span class="s0">; </span><span class="s1">i++) {</span>
				<span class="s0">if </span><span class="s1">(!split[i]) {</span>
					<span class="s4">// ignore empty strings</span>
					<span class="s0">continue;</span>
				<span class="s1">}</span>

				<span class="s1">namespaces = split[i].replace(</span><span class="s3">/\*/g</span><span class="s0">, </span><span class="s2">'.*?'</span><span class="s1">)</span><span class="s0">;</span>

				<span class="s0">if </span><span class="s1">(namespaces[</span><span class="s3">0</span><span class="s1">] === </span><span class="s2">'-'</span><span class="s1">) {</span>
					<span class="s1">createDebug.skips.push(</span><span class="s0">new </span><span class="s1">RegExp(</span><span class="s2">'^' </span><span class="s1">+ namespaces.slice(</span><span class="s3">1</span><span class="s1">) + </span><span class="s2">'$'</span><span class="s1">))</span><span class="s0">;</span>
				<span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
					<span class="s1">createDebug.names.push(</span><span class="s0">new </span><span class="s1">RegExp(</span><span class="s2">'^' </span><span class="s1">+ namespaces + </span><span class="s2">'$'</span><span class="s1">))</span><span class="s0">;</span>
				<span class="s1">}</span>
			<span class="s1">}</span>
		<span class="s1">}</span>

		<span class="s5">/**</span>
		<span class="s5">* Disable debug output.</span>
		<span class="s5">*</span>
		<span class="s5">* </span><span class="s6">@return </span><span class="s5">{String} namespaces</span>
		<span class="s5">* </span><span class="s6">@api </span><span class="s5">public</span>
		<span class="s5">*/</span>
		<span class="s0">function </span><span class="s1">disable() {</span>
			<span class="s0">const </span><span class="s1">namespaces = [</span>
				<span class="s1">...createDebug.names.map(toNamespace)</span><span class="s0">,</span>
				<span class="s1">...createDebug.skips.map(toNamespace).map(namespace =&gt; </span><span class="s2">'-' </span><span class="s1">+ namespace)</span>
			<span class="s1">].join(</span><span class="s2">','</span><span class="s1">)</span><span class="s0">;</span>
			<span class="s1">createDebug.enable(</span><span class="s2">''</span><span class="s1">)</span><span class="s0">;</span>
			<span class="s0">return </span><span class="s1">namespaces</span><span class="s0">;</span>
		<span class="s1">}</span>

		<span class="s5">/**</span>
		<span class="s5">* Returns true if the given mode name is enabled, false otherwise.</span>
		<span class="s5">*</span>
		<span class="s5">* </span><span class="s6">@param </span><span class="s5">{String} name</span>
		<span class="s5">* </span><span class="s6">@return </span><span class="s5">{Boolean}</span>
		<span class="s5">* </span><span class="s6">@api </span><span class="s5">public</span>
		<span class="s5">*/</span>
		<span class="s0">function </span><span class="s1">enabled(name) {</span>
			<span class="s0">if </span><span class="s1">(name[name.length - </span><span class="s3">1</span><span class="s1">] === </span><span class="s2">'*'</span><span class="s1">) {</span>
				<span class="s0">return true;</span>
			<span class="s1">}</span>

			<span class="s0">let </span><span class="s1">i</span><span class="s0">;</span>
			<span class="s0">let </span><span class="s1">len</span><span class="s0">;</span>

			<span class="s0">for </span><span class="s1">(i = </span><span class="s3">0</span><span class="s0">, </span><span class="s1">len = createDebug.skips.length</span><span class="s0">; </span><span class="s1">i &lt; len</span><span class="s0">; </span><span class="s1">i++) {</span>
				<span class="s0">if </span><span class="s1">(createDebug.skips[i].test(name)) {</span>
					<span class="s0">return false;</span>
				<span class="s1">}</span>
			<span class="s1">}</span>

			<span class="s0">for </span><span class="s1">(i = </span><span class="s3">0</span><span class="s0">, </span><span class="s1">len = createDebug.names.length</span><span class="s0">; </span><span class="s1">i &lt; len</span><span class="s0">; </span><span class="s1">i++) {</span>
				<span class="s0">if </span><span class="s1">(createDebug.names[i].test(name)) {</span>
					<span class="s0">return true;</span>
				<span class="s1">}</span>
			<span class="s1">}</span>

			<span class="s0">return false;</span>
		<span class="s1">}</span>

		<span class="s5">/**</span>
		<span class="s5">* Convert regexp to namespace</span>
		<span class="s5">*</span>
		<span class="s5">* </span><span class="s6">@param </span><span class="s5">{RegExp} regxep</span>
		<span class="s5">* </span><span class="s6">@return </span><span class="s5">{String} namespace</span>
		<span class="s5">* </span><span class="s6">@api </span><span class="s5">private</span>
		<span class="s5">*/</span>
		<span class="s0">function </span><span class="s1">toNamespace(regexp) {</span>
			<span class="s0">return </span><span class="s1">regexp.toString()</span>
				<span class="s1">.substring(</span><span class="s3">2</span><span class="s0">, </span><span class="s1">regexp.toString().length - </span><span class="s3">2</span><span class="s1">)</span>
				<span class="s1">.replace(</span><span class="s3">/\.\*\?$/</span><span class="s0">, </span><span class="s2">'*'</span><span class="s1">)</span><span class="s0">;</span>
		<span class="s1">}</span>

		<span class="s5">/**</span>
		<span class="s5">* Coerce `val`.</span>
		<span class="s5">*</span>
		<span class="s5">* </span><span class="s6">@param </span><span class="s5">{Mixed} val</span>
		<span class="s5">* </span><span class="s6">@return </span><span class="s5">{Mixed}</span>
		<span class="s5">* </span><span class="s6">@api </span><span class="s5">private</span>
		<span class="s5">*/</span>
		<span class="s0">function </span><span class="s1">coerce(val) {</span>
			<span class="s0">if </span><span class="s1">(val </span><span class="s0">instanceof </span><span class="s1">Error) {</span>
				<span class="s0">return </span><span class="s1">val.stack || val.message</span><span class="s0">;</span>
			<span class="s1">}</span>
			<span class="s0">return </span><span class="s1">val</span><span class="s0">;</span>
		<span class="s1">}</span>

		<span class="s5">/**</span>
		<span class="s5">* XXX DO NOT USE. This is a temporary stub function.</span>
		<span class="s5">* XXX It WILL be removed in the next major release.</span>
		<span class="s5">*/</span>
		<span class="s0">function </span><span class="s1">destroy() {</span>
			<span class="s1">console.warn(</span><span class="s2">'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'</span><span class="s1">)</span><span class="s0">;</span>
		<span class="s1">}</span>

		<span class="s1">createDebug.enable(createDebug.load())</span><span class="s0">;</span>

		<span class="s0">return </span><span class="s1">createDebug</span><span class="s0">;</span>
	<span class="s1">}</span>

	<span class="s1">common = setup</span><span class="s0">;</span>
	<span class="s0">return </span><span class="s1">common</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s4">/* eslint-env browser */</span>

<span class="s0">var </span><span class="s1">hasRequiredBrowser</span><span class="s0">;</span>

<span class="s0">function </span><span class="s1">requireBrowser () {</span>
	<span class="s0">if </span><span class="s1">(hasRequiredBrowser) </span><span class="s0">return </span><span class="s1">browserExports</span><span class="s0">;</span>
	<span class="s1">hasRequiredBrowser = </span><span class="s3">1</span><span class="s0">;</span>
	<span class="s1">(</span><span class="s0">function </span><span class="s1">(module</span><span class="s0">, </span><span class="s1">exports) {</span>
		<span class="s5">/**</span>
		 <span class="s5">* This is the web browser implementation of `debug()`.</span>
		 <span class="s5">*/</span>

		<span class="s1">exports.formatArgs = formatArgs</span><span class="s0">;</span>
		<span class="s1">exports.save = save</span><span class="s0">;</span>
		<span class="s1">exports.load = load</span><span class="s0">;</span>
		<span class="s1">exports.useColors = useColors</span><span class="s0">;</span>
		<span class="s1">exports.storage = localstorage()</span><span class="s0">;</span>
		<span class="s1">exports.destroy = (() =&gt; {</span>
			<span class="s0">let </span><span class="s1">warned = </span><span class="s0">false;</span>

			<span class="s0">return </span><span class="s1">() =&gt; {</span>
				<span class="s0">if </span><span class="s1">(!warned) {</span>
					<span class="s1">warned = </span><span class="s0">true;</span>
					<span class="s1">console.warn(</span><span class="s2">'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'</span><span class="s1">)</span><span class="s0">;</span>
				<span class="s1">}</span>
			<span class="s1">}</span><span class="s0">;</span>
		<span class="s1">})()</span><span class="s0">;</span>

		<span class="s5">/**</span>
		 <span class="s5">* Colors.</span>
		 <span class="s5">*/</span>

		<span class="s1">exports.colors = [</span>
			<span class="s2">'#0000CC'</span><span class="s0">,</span>
			<span class="s2">'#0000FF'</span><span class="s0">,</span>
			<span class="s2">'#0033CC'</span><span class="s0">,</span>
			<span class="s2">'#0033FF'</span><span class="s0">,</span>
			<span class="s2">'#0066CC'</span><span class="s0">,</span>
			<span class="s2">'#0066FF'</span><span class="s0">,</span>
			<span class="s2">'#0099CC'</span><span class="s0">,</span>
			<span class="s2">'#0099FF'</span><span class="s0">,</span>
			<span class="s2">'#00CC00'</span><span class="s0">,</span>
			<span class="s2">'#00CC33'</span><span class="s0">,</span>
			<span class="s2">'#00CC66'</span><span class="s0">,</span>
			<span class="s2">'#00CC99'</span><span class="s0">,</span>
			<span class="s2">'#00CCCC'</span><span class="s0">,</span>
			<span class="s2">'#00CCFF'</span><span class="s0">,</span>
			<span class="s2">'#3300CC'</span><span class="s0">,</span>
			<span class="s2">'#3300FF'</span><span class="s0">,</span>
			<span class="s2">'#3333CC'</span><span class="s0">,</span>
			<span class="s2">'#3333FF'</span><span class="s0">,</span>
			<span class="s2">'#3366CC'</span><span class="s0">,</span>
			<span class="s2">'#3366FF'</span><span class="s0">,</span>
			<span class="s2">'#3399CC'</span><span class="s0">,</span>
			<span class="s2">'#3399FF'</span><span class="s0">,</span>
			<span class="s2">'#33CC00'</span><span class="s0">,</span>
			<span class="s2">'#33CC33'</span><span class="s0">,</span>
			<span class="s2">'#33CC66'</span><span class="s0">,</span>
			<span class="s2">'#33CC99'</span><span class="s0">,</span>
			<span class="s2">'#33CCCC'</span><span class="s0">,</span>
			<span class="s2">'#33CCFF'</span><span class="s0">,</span>
			<span class="s2">'#6600CC'</span><span class="s0">,</span>
			<span class="s2">'#6600FF'</span><span class="s0">,</span>
			<span class="s2">'#6633CC'</span><span class="s0">,</span>
			<span class="s2">'#6633FF'</span><span class="s0">,</span>
			<span class="s2">'#66CC00'</span><span class="s0">,</span>
			<span class="s2">'#66CC33'</span><span class="s0">,</span>
			<span class="s2">'#9900CC'</span><span class="s0">,</span>
			<span class="s2">'#9900FF'</span><span class="s0">,</span>
			<span class="s2">'#9933CC'</span><span class="s0">,</span>
			<span class="s2">'#9933FF'</span><span class="s0">,</span>
			<span class="s2">'#99CC00'</span><span class="s0">,</span>
			<span class="s2">'#99CC33'</span><span class="s0">,</span>
			<span class="s2">'#CC0000'</span><span class="s0">,</span>
			<span class="s2">'#CC0033'</span><span class="s0">,</span>
			<span class="s2">'#CC0066'</span><span class="s0">,</span>
			<span class="s2">'#CC0099'</span><span class="s0">,</span>
			<span class="s2">'#CC00CC'</span><span class="s0">,</span>
			<span class="s2">'#CC00FF'</span><span class="s0">,</span>
			<span class="s2">'#CC3300'</span><span class="s0">,</span>
			<span class="s2">'#CC3333'</span><span class="s0">,</span>
			<span class="s2">'#CC3366'</span><span class="s0">,</span>
			<span class="s2">'#CC3399'</span><span class="s0">,</span>
			<span class="s2">'#CC33CC'</span><span class="s0">,</span>
			<span class="s2">'#CC33FF'</span><span class="s0">,</span>
			<span class="s2">'#CC6600'</span><span class="s0">,</span>
			<span class="s2">'#CC6633'</span><span class="s0">,</span>
			<span class="s2">'#CC9900'</span><span class="s0">,</span>
			<span class="s2">'#CC9933'</span><span class="s0">,</span>
			<span class="s2">'#CCCC00'</span><span class="s0">,</span>
			<span class="s2">'#CCCC33'</span><span class="s0">,</span>
			<span class="s2">'#FF0000'</span><span class="s0">,</span>
			<span class="s2">'#FF0033'</span><span class="s0">,</span>
			<span class="s2">'#FF0066'</span><span class="s0">,</span>
			<span class="s2">'#FF0099'</span><span class="s0">,</span>
			<span class="s2">'#FF00CC'</span><span class="s0">,</span>
			<span class="s2">'#FF00FF'</span><span class="s0">,</span>
			<span class="s2">'#FF3300'</span><span class="s0">,</span>
			<span class="s2">'#FF3333'</span><span class="s0">,</span>
			<span class="s2">'#FF3366'</span><span class="s0">,</span>
			<span class="s2">'#FF3399'</span><span class="s0">,</span>
			<span class="s2">'#FF33CC'</span><span class="s0">,</span>
			<span class="s2">'#FF33FF'</span><span class="s0">,</span>
			<span class="s2">'#FF6600'</span><span class="s0">,</span>
			<span class="s2">'#FF6633'</span><span class="s0">,</span>
			<span class="s2">'#FF9900'</span><span class="s0">,</span>
			<span class="s2">'#FF9933'</span><span class="s0">,</span>
			<span class="s2">'#FFCC00'</span><span class="s0">,</span>
			<span class="s2">'#FFCC33'</span>
		<span class="s1">]</span><span class="s0">;</span>

		<span class="s5">/**</span>
		 <span class="s5">* Currently only WebKit-based Web Inspectors, Firefox &gt;= v31,</span>
		 <span class="s5">* and the Firebug extension (any Firefox version) are known</span>
		 <span class="s5">* to support &quot;%c&quot; CSS customizations.</span>
		 <span class="s5">*</span>
		 <span class="s5">* TODO: add a `localStorage` variable to explicitly enable/disable colors</span>
		 <span class="s5">*/</span>

		<span class="s4">// eslint-disable-next-line complexity</span>
		<span class="s0">function </span><span class="s1">useColors() {</span>
			<span class="s4">// NB: In an Electron preload script, document will be defined but not fully</span>
			<span class="s4">// initialized. Since we know we're in Chrome, we'll just detect this case</span>
			<span class="s4">// explicitly</span>
			<span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">window !== </span><span class="s2">'undefined' </span><span class="s1">&amp;&amp; window.process &amp;&amp; (window.process.type === </span><span class="s2">'renderer' </span><span class="s1">|| window.process.__nwjs)) {</span>
				<span class="s0">return true;</span>
			<span class="s1">}</span>

			<span class="s4">// Internet Explorer and Edge do not support colors.</span>
			<span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">navigator !== </span><span class="s2">'undefined' </span><span class="s1">&amp;&amp; navigator.userAgent &amp;&amp; navigator.userAgent.toLowerCase().match(</span><span class="s3">/(edge|trident)\/(\d+)/</span><span class="s1">)) {</span>
				<span class="s0">return false;</span>
			<span class="s1">}</span>

			<span class="s4">// Is webkit? http://stackoverflow.com/a/16459606/376773</span>
			<span class="s4">// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632</span>
			<span class="s0">return </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">document !== </span><span class="s2">'undefined' </span><span class="s1">&amp;&amp; document.documentElement &amp;&amp; document.documentElement.style &amp;&amp; document.documentElement.style.WebkitAppearance) ||</span>
				<span class="s4">// Is firebug? http://stackoverflow.com/a/398120/376773</span>
				<span class="s1">(</span><span class="s0">typeof </span><span class="s1">window !== </span><span class="s2">'undefined' </span><span class="s1">&amp;&amp; window.console &amp;&amp; (window.console.firebug || (window.console.exception &amp;&amp; window.console.table))) ||</span>
				<span class="s4">// Is firefox &gt;= v31?</span>
				<span class="s4">// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages</span>
				<span class="s1">(</span><span class="s0">typeof </span><span class="s1">navigator !== </span><span class="s2">'undefined' </span><span class="s1">&amp;&amp; navigator.userAgent &amp;&amp; navigator.userAgent.toLowerCase().match(</span><span class="s3">/firefox\/(\d+)/</span><span class="s1">) &amp;&amp; parseInt(RegExp.$1</span><span class="s0">, </span><span class="s3">10</span><span class="s1">) &gt;= </span><span class="s3">31</span><span class="s1">) ||</span>
				<span class="s4">// Double check webkit in userAgent just in case we are in a worker</span>
				<span class="s1">(</span><span class="s0">typeof </span><span class="s1">navigator !== </span><span class="s2">'undefined' </span><span class="s1">&amp;&amp; navigator.userAgent &amp;&amp; navigator.userAgent.toLowerCase().match(</span><span class="s3">/applewebkit\/(\d+)/</span><span class="s1">))</span><span class="s0">;</span>
		<span class="s1">}</span>

		<span class="s5">/**</span>
		 <span class="s5">* Colorize log arguments if enabled.</span>
		 <span class="s5">*</span>
		 <span class="s5">* </span><span class="s6">@api </span><span class="s5">public</span>
		 <span class="s5">*/</span>

		<span class="s0">function </span><span class="s1">formatArgs(args) {</span>
			<span class="s1">args[</span><span class="s3">0</span><span class="s1">] = (</span><span class="s0">this</span><span class="s1">.useColors ? </span><span class="s2">'%c' </span><span class="s1">: </span><span class="s2">''</span><span class="s1">) +</span>
				<span class="s0">this</span><span class="s1">.namespace +</span>
				<span class="s1">(</span><span class="s0">this</span><span class="s1">.useColors ? </span><span class="s2">' %c' </span><span class="s1">: </span><span class="s2">' '</span><span class="s1">) +</span>
				<span class="s1">args[</span><span class="s3">0</span><span class="s1">] +</span>
				<span class="s1">(</span><span class="s0">this</span><span class="s1">.useColors ? </span><span class="s2">'%c ' </span><span class="s1">: </span><span class="s2">' '</span><span class="s1">) +</span>
				<span class="s2">'+' </span><span class="s1">+ module.exports.humanize(</span><span class="s0">this</span><span class="s1">.diff)</span><span class="s0">;</span>

			<span class="s0">if </span><span class="s1">(!</span><span class="s0">this</span><span class="s1">.useColors) {</span>
				<span class="s0">return;</span>
			<span class="s1">}</span>

			<span class="s0">const </span><span class="s1">c = </span><span class="s2">'color: ' </span><span class="s1">+ </span><span class="s0">this</span><span class="s1">.color</span><span class="s0">;</span>
			<span class="s1">args.splice(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s2">'color: inherit'</span><span class="s1">)</span><span class="s0">;</span>

			<span class="s4">// The final &quot;%c&quot; is somewhat tricky, because there could be other</span>
			<span class="s4">// arguments passed either before or after the %c, so we need to</span>
			<span class="s4">// figure out the correct index to insert the CSS into</span>
			<span class="s0">let </span><span class="s1">index = </span><span class="s3">0</span><span class="s0">;</span>
			<span class="s0">let </span><span class="s1">lastC = </span><span class="s3">0</span><span class="s0">;</span>
			<span class="s1">args[</span><span class="s3">0</span><span class="s1">].replace(</span><span class="s3">/%[a-zA-Z%]/g</span><span class="s0">, </span><span class="s1">match =&gt; {</span>
				<span class="s0">if </span><span class="s1">(match === </span><span class="s2">'%%'</span><span class="s1">) {</span>
					<span class="s0">return;</span>
				<span class="s1">}</span>
				<span class="s1">index++</span><span class="s0">;</span>
				<span class="s0">if </span><span class="s1">(match === </span><span class="s2">'%c'</span><span class="s1">) {</span>
					<span class="s4">// We only are interested in the *last* %c</span>
					<span class="s4">// (the user may have provided their own)</span>
					<span class="s1">lastC = index</span><span class="s0">;</span>
				<span class="s1">}</span>
			<span class="s1">})</span><span class="s0">;</span>

			<span class="s1">args.splice(lastC</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">c)</span><span class="s0">;</span>
		<span class="s1">}</span>

		<span class="s5">/**</span>
		 <span class="s5">* Invokes `console.debug()` when available.</span>
		 <span class="s5">* No-op when `console.debug` is not a &quot;function&quot;.</span>
		 <span class="s5">* If `console.debug` is not available, falls back</span>
		 <span class="s5">* to `console.log`.</span>
		 <span class="s5">*</span>
		 <span class="s5">* </span><span class="s6">@api </span><span class="s5">public</span>
		 <span class="s5">*/</span>
		<span class="s1">exports.log = console.debug || console.log || (() =&gt; {})</span><span class="s0">;</span>

		<span class="s5">/**</span>
		 <span class="s5">* Save `namespaces`.</span>
		 <span class="s5">*</span>
		 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{String} namespaces</span>
		 <span class="s5">* </span><span class="s6">@api </span><span class="s5">private</span>
		 <span class="s5">*/</span>
		<span class="s0">function </span><span class="s1">save(namespaces) {</span>
			<span class="s0">try </span><span class="s1">{</span>
				<span class="s0">if </span><span class="s1">(namespaces) {</span>
					<span class="s1">exports.storage.setItem(</span><span class="s2">'debug'</span><span class="s0">, </span><span class="s1">namespaces)</span><span class="s0">;</span>
				<span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
					<span class="s1">exports.storage.removeItem(</span><span class="s2">'debug'</span><span class="s1">)</span><span class="s0">;</span>
				<span class="s1">}</span>
			<span class="s1">} </span><span class="s0">catch </span><span class="s1">(error) {</span>
				<span class="s4">// Swallow</span>
				<span class="s4">// XXX (@Qix-) should we be logging these?</span>
			<span class="s1">}</span>
		<span class="s1">}</span>

		<span class="s5">/**</span>
		 <span class="s5">* Load `namespaces`.</span>
		 <span class="s5">*</span>
		 <span class="s5">* </span><span class="s6">@return </span><span class="s5">{String} returns the previously persisted debug modes</span>
		 <span class="s5">* </span><span class="s6">@api </span><span class="s5">private</span>
		 <span class="s5">*/</span>
		<span class="s0">function </span><span class="s1">load() {</span>
			<span class="s0">let </span><span class="s1">r</span><span class="s0">;</span>
			<span class="s0">try </span><span class="s1">{</span>
				<span class="s1">r = exports.storage.getItem(</span><span class="s2">'debug'</span><span class="s1">)</span><span class="s0">;</span>
			<span class="s1">} </span><span class="s0">catch </span><span class="s1">(error) {</span>
				<span class="s4">// Swallow</span>
				<span class="s4">// XXX (@Qix-) should we be logging these?</span>
			<span class="s1">}</span>

			<span class="s4">// If debug isn't set in LS, and we're in Electron, try to load $DEBUG</span>
			<span class="s0">if </span><span class="s1">(!r &amp;&amp; </span><span class="s0">typeof </span><span class="s1">process !== </span><span class="s2">'undefined' </span><span class="s1">&amp;&amp; </span><span class="s2">'env' </span><span class="s0">in </span><span class="s1">process) {</span>
				<span class="s1">r = process.env.DEBUG</span><span class="s0">;</span>
			<span class="s1">}</span>

			<span class="s0">return </span><span class="s1">r</span><span class="s0">;</span>
		<span class="s1">}</span>

		<span class="s5">/**</span>
		 <span class="s5">* Localstorage attempts to return the localstorage.</span>
		 <span class="s5">*</span>
		 <span class="s5">* This is necessary because safari throws</span>
		 <span class="s5">* when a user disables cookies/localstorage</span>
		 <span class="s5">* and you attempt to access it.</span>
		 <span class="s5">*</span>
		 <span class="s5">* </span><span class="s6">@return </span><span class="s5">{LocalStorage}</span>
		 <span class="s5">* </span><span class="s6">@api </span><span class="s5">private</span>
		 <span class="s5">*/</span>

		<span class="s0">function </span><span class="s1">localstorage() {</span>
			<span class="s0">try </span><span class="s1">{</span>
				<span class="s4">// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context</span>
				<span class="s4">// The Browser also has localStorage in the global context.</span>
				<span class="s0">return </span><span class="s1">localStorage</span><span class="s0">;</span>
			<span class="s1">} </span><span class="s0">catch </span><span class="s1">(error) {</span>
				<span class="s4">// Swallow</span>
				<span class="s4">// XXX (@Qix-) should we be logging these?</span>
			<span class="s1">}</span>
		<span class="s1">}</span>

		<span class="s1">module.exports = requireCommon()(exports)</span><span class="s0">;</span>

		<span class="s0">const </span><span class="s1">{formatters} = module.exports</span><span class="s0">;</span>

		<span class="s5">/**</span>
		 <span class="s5">* Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.</span>
		 <span class="s5">*/</span>

		<span class="s1">formatters.j = </span><span class="s0">function </span><span class="s1">(v) {</span>
			<span class="s0">try </span><span class="s1">{</span>
				<span class="s0">return </span><span class="s1">JSON.stringify(v)</span><span class="s0">;</span>
			<span class="s1">} </span><span class="s0">catch </span><span class="s1">(error) {</span>
				<span class="s0">return </span><span class="s2">'[UnexpectedJSONParseError]: ' </span><span class="s1">+ error.message</span><span class="s0">;</span>
			<span class="s1">}</span>
		<span class="s1">}</span><span class="s0">;</span>
<span class="s1">} (browser</span><span class="s0">, </span><span class="s1">browserExports))</span><span class="s0">;</span>
	<span class="s0">return </span><span class="s1">browserExports</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">var </span><span class="s1">nodeExports = {}</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">node = {</span>
  <span class="s1">get exports(){ </span><span class="s0">return </span><span class="s1">nodeExports</span><span class="s0">; </span><span class="s1">}</span><span class="s0">,</span>
  <span class="s1">set exports(v){ nodeExports = v</span><span class="s0">; </span><span class="s1">}</span><span class="s0">,</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s5">/**</span>
 <span class="s5">* Module dependencies.</span>
 <span class="s5">*/</span>

<span class="s0">var </span><span class="s1">hasRequiredNode</span><span class="s0">;</span>

<span class="s0">function </span><span class="s1">requireNode () {</span>
	<span class="s0">if </span><span class="s1">(hasRequiredNode) </span><span class="s0">return </span><span class="s1">nodeExports</span><span class="s0">;</span>
	<span class="s1">hasRequiredNode = </span><span class="s3">1</span><span class="s0">;</span>
	<span class="s1">(</span><span class="s0">function </span><span class="s1">(module</span><span class="s0">, </span><span class="s1">exports) {</span>
		<span class="s0">const </span><span class="s1">tty = require$$0</span><span class="s0">;</span>
		<span class="s0">const </span><span class="s1">util = require$$1</span><span class="s0">;</span>

		<span class="s5">/**</span>
		 <span class="s5">* This is the Node.js implementation of `debug()`.</span>
		 <span class="s5">*/</span>

		<span class="s1">exports.init = init</span><span class="s0">;</span>
		<span class="s1">exports.log = log</span><span class="s0">;</span>
		<span class="s1">exports.formatArgs = formatArgs</span><span class="s0">;</span>
		<span class="s1">exports.save = save</span><span class="s0">;</span>
		<span class="s1">exports.load = load</span><span class="s0">;</span>
		<span class="s1">exports.useColors = useColors</span><span class="s0">;</span>
		<span class="s1">exports.destroy = util.deprecate(</span>
			<span class="s1">() =&gt; {}</span><span class="s0">,</span>
			<span class="s2">'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'</span>
		<span class="s1">)</span><span class="s0">;</span>

		<span class="s5">/**</span>
		 <span class="s5">* Colors.</span>
		 <span class="s5">*/</span>

		<span class="s1">exports.colors = [</span><span class="s3">6</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">;</span>

		<span class="s0">try </span><span class="s1">{</span>
			<span class="s4">// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)</span>
			<span class="s4">// eslint-disable-next-line import/no-extraneous-dependencies</span>
			<span class="s0">const </span><span class="s1">supportsColor = require(</span><span class="s2">'supports-color'</span><span class="s1">)</span><span class="s0">;</span>

			<span class="s0">if </span><span class="s1">(supportsColor &amp;&amp; (supportsColor.stderr || supportsColor).level &gt;= </span><span class="s3">2</span><span class="s1">) {</span>
				<span class="s1">exports.colors = [</span>
					<span class="s3">20</span><span class="s0">,</span>
					<span class="s3">21</span><span class="s0">,</span>
					<span class="s3">26</span><span class="s0">,</span>
					<span class="s3">27</span><span class="s0">,</span>
					<span class="s3">32</span><span class="s0">,</span>
					<span class="s3">33</span><span class="s0">,</span>
					<span class="s3">38</span><span class="s0">,</span>
					<span class="s3">39</span><span class="s0">,</span>
					<span class="s3">40</span><span class="s0">,</span>
					<span class="s3">41</span><span class="s0">,</span>
					<span class="s3">42</span><span class="s0">,</span>
					<span class="s3">43</span><span class="s0">,</span>
					<span class="s3">44</span><span class="s0">,</span>
					<span class="s3">45</span><span class="s0">,</span>
					<span class="s3">56</span><span class="s0">,</span>
					<span class="s3">57</span><span class="s0">,</span>
					<span class="s3">62</span><span class="s0">,</span>
					<span class="s3">63</span><span class="s0">,</span>
					<span class="s3">68</span><span class="s0">,</span>
					<span class="s3">69</span><span class="s0">,</span>
					<span class="s3">74</span><span class="s0">,</span>
					<span class="s3">75</span><span class="s0">,</span>
					<span class="s3">76</span><span class="s0">,</span>
					<span class="s3">77</span><span class="s0">,</span>
					<span class="s3">78</span><span class="s0">,</span>
					<span class="s3">79</span><span class="s0">,</span>
					<span class="s3">80</span><span class="s0">,</span>
					<span class="s3">81</span><span class="s0">,</span>
					<span class="s3">92</span><span class="s0">,</span>
					<span class="s3">93</span><span class="s0">,</span>
					<span class="s3">98</span><span class="s0">,</span>
					<span class="s3">99</span><span class="s0">,</span>
					<span class="s3">112</span><span class="s0">,</span>
					<span class="s3">113</span><span class="s0">,</span>
					<span class="s3">128</span><span class="s0">,</span>
					<span class="s3">129</span><span class="s0">,</span>
					<span class="s3">134</span><span class="s0">,</span>
					<span class="s3">135</span><span class="s0">,</span>
					<span class="s3">148</span><span class="s0">,</span>
					<span class="s3">149</span><span class="s0">,</span>
					<span class="s3">160</span><span class="s0">,</span>
					<span class="s3">161</span><span class="s0">,</span>
					<span class="s3">162</span><span class="s0">,</span>
					<span class="s3">163</span><span class="s0">,</span>
					<span class="s3">164</span><span class="s0">,</span>
					<span class="s3">165</span><span class="s0">,</span>
					<span class="s3">166</span><span class="s0">,</span>
					<span class="s3">167</span><span class="s0">,</span>
					<span class="s3">168</span><span class="s0">,</span>
					<span class="s3">169</span><span class="s0">,</span>
					<span class="s3">170</span><span class="s0">,</span>
					<span class="s3">171</span><span class="s0">,</span>
					<span class="s3">172</span><span class="s0">,</span>
					<span class="s3">173</span><span class="s0">,</span>
					<span class="s3">178</span><span class="s0">,</span>
					<span class="s3">179</span><span class="s0">,</span>
					<span class="s3">184</span><span class="s0">,</span>
					<span class="s3">185</span><span class="s0">,</span>
					<span class="s3">196</span><span class="s0">,</span>
					<span class="s3">197</span><span class="s0">,</span>
					<span class="s3">198</span><span class="s0">,</span>
					<span class="s3">199</span><span class="s0">,</span>
					<span class="s3">200</span><span class="s0">,</span>
					<span class="s3">201</span><span class="s0">,</span>
					<span class="s3">202</span><span class="s0">,</span>
					<span class="s3">203</span><span class="s0">,</span>
					<span class="s3">204</span><span class="s0">,</span>
					<span class="s3">205</span><span class="s0">,</span>
					<span class="s3">206</span><span class="s0">,</span>
					<span class="s3">207</span><span class="s0">,</span>
					<span class="s3">208</span><span class="s0">,</span>
					<span class="s3">209</span><span class="s0">,</span>
					<span class="s3">214</span><span class="s0">,</span>
					<span class="s3">215</span><span class="s0">,</span>
					<span class="s3">220</span><span class="s0">,</span>
					<span class="s3">221</span>
				<span class="s1">]</span><span class="s0">;</span>
			<span class="s1">}</span>
		<span class="s1">} </span><span class="s0">catch </span><span class="s1">(error) {</span>
			<span class="s4">// Swallow - we only care if `supports-color` is available; it doesn't have to be.</span>
		<span class="s1">}</span>

		<span class="s5">/**</span>
		 <span class="s5">* Build up the default `inspectOpts` object from the environment variables.</span>
		 <span class="s5">*</span>
		 <span class="s5">*   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js</span>
		 <span class="s5">*/</span>

		<span class="s1">exports.inspectOpts = Object.keys(process.env).filter(key =&gt; {</span>
			<span class="s0">return </span><span class="s3">/^debug_/i</span><span class="s1">.test(key)</span><span class="s0">;</span>
		<span class="s1">}).reduce((obj</span><span class="s0">, </span><span class="s1">key) =&gt; {</span>
			<span class="s4">// Camel-case</span>
			<span class="s0">const </span><span class="s1">prop = key</span>
				<span class="s1">.substring(</span><span class="s3">6</span><span class="s1">)</span>
				<span class="s1">.toLowerCase()</span>
				<span class="s1">.replace(</span><span class="s3">/_([a-z])/g</span><span class="s0">, </span><span class="s1">(_</span><span class="s0">, </span><span class="s1">k) =&gt; {</span>
					<span class="s0">return </span><span class="s1">k.toUpperCase()</span><span class="s0">;</span>
				<span class="s1">})</span><span class="s0">;</span>

			<span class="s4">// Coerce string value into JS value</span>
			<span class="s0">let </span><span class="s1">val = process.env[key]</span><span class="s0">;</span>
			<span class="s0">if </span><span class="s1">(</span><span class="s3">/^(yes|on|true|enabled)$/i</span><span class="s1">.test(val)) {</span>
				<span class="s1">val = </span><span class="s0">true;</span>
			<span class="s1">} </span><span class="s0">else if </span><span class="s1">(</span><span class="s3">/^(no|off|false|disabled)$/i</span><span class="s1">.test(val)) {</span>
				<span class="s1">val = </span><span class="s0">false;</span>
			<span class="s1">} </span><span class="s0">else if </span><span class="s1">(val === </span><span class="s2">'null'</span><span class="s1">) {</span>
				<span class="s1">val = </span><span class="s0">null;</span>
			<span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
				<span class="s1">val = Number(val)</span><span class="s0">;</span>
			<span class="s1">}</span>

			<span class="s1">obj[prop] = val</span><span class="s0">;</span>
			<span class="s0">return </span><span class="s1">obj</span><span class="s0">;</span>
		<span class="s1">}</span><span class="s0">, </span><span class="s1">{})</span><span class="s0">;</span>

		<span class="s5">/**</span>
		 <span class="s5">* Is stdout a TTY? Colored output is enabled when `true`.</span>
		 <span class="s5">*/</span>

		<span class="s0">function </span><span class="s1">useColors() {</span>
			<span class="s0">return </span><span class="s2">'colors' </span><span class="s0">in </span><span class="s1">exports.inspectOpts ?</span>
				<span class="s1">Boolean(exports.inspectOpts.colors) :</span>
				<span class="s1">tty.isatty(process.stderr.fd)</span><span class="s0">;</span>
		<span class="s1">}</span>

		<span class="s5">/**</span>
		 <span class="s5">* Adds ANSI color escape codes if enabled.</span>
		 <span class="s5">*</span>
		 <span class="s5">* </span><span class="s6">@api </span><span class="s5">public</span>
		 <span class="s5">*/</span>

		<span class="s0">function </span><span class="s1">formatArgs(args) {</span>
			<span class="s0">const </span><span class="s1">{namespace: name</span><span class="s0">, </span><span class="s1">useColors} = </span><span class="s0">this;</span>

			<span class="s0">if </span><span class="s1">(useColors) {</span>
				<span class="s0">const </span><span class="s1">c = </span><span class="s0">this</span><span class="s1">.color</span><span class="s0">;</span>
				<span class="s0">const </span><span class="s1">colorCode = </span><span class="s2">'</span><span class="s0">\u001B</span><span class="s2">[3' </span><span class="s1">+ (c &lt; </span><span class="s3">8 </span><span class="s1">? c : </span><span class="s2">'8;5;' </span><span class="s1">+ c)</span><span class="s0">;</span>
				<span class="s0">const </span><span class="s1">prefix = </span><span class="s2">`  </span><span class="s1">${colorCode}</span><span class="s2">;1m</span><span class="s1">${name} </span><span class="s0">\u001B</span><span class="s2">[0m`</span><span class="s0">;</span>

				<span class="s1">args[</span><span class="s3">0</span><span class="s1">] = prefix + args[</span><span class="s3">0</span><span class="s1">].split(</span><span class="s2">'</span><span class="s0">\n</span><span class="s2">'</span><span class="s1">).join(</span><span class="s2">'</span><span class="s0">\n</span><span class="s2">' </span><span class="s1">+ prefix)</span><span class="s0">;</span>
				<span class="s1">args.push(colorCode + </span><span class="s2">'m+' </span><span class="s1">+ module.exports.humanize(</span><span class="s0">this</span><span class="s1">.diff) + </span><span class="s2">'</span><span class="s0">\u001B</span><span class="s2">[0m'</span><span class="s1">)</span><span class="s0">;</span>
			<span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
				<span class="s1">args[</span><span class="s3">0</span><span class="s1">] = getDate() + name + </span><span class="s2">' ' </span><span class="s1">+ args[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">;</span>
			<span class="s1">}</span>
		<span class="s1">}</span>

		<span class="s0">function </span><span class="s1">getDate() {</span>
			<span class="s0">if </span><span class="s1">(exports.inspectOpts.hideDate) {</span>
				<span class="s0">return </span><span class="s2">''</span><span class="s0">;</span>
			<span class="s1">}</span>
			<span class="s0">return new </span><span class="s1">Date().toISOString() + </span><span class="s2">' '</span><span class="s0">;</span>
		<span class="s1">}</span>

		<span class="s5">/**</span>
		 <span class="s5">* Invokes `util.format()` with the specified arguments and writes to stderr.</span>
		 <span class="s5">*/</span>

		<span class="s0">function </span><span class="s1">log(...args) {</span>
			<span class="s0">return </span><span class="s1">process.stderr.write(util.format(...args) + </span><span class="s2">'</span><span class="s0">\n</span><span class="s2">'</span><span class="s1">)</span><span class="s0">;</span>
		<span class="s1">}</span>

		<span class="s5">/**</span>
		 <span class="s5">* Save `namespaces`.</span>
		 <span class="s5">*</span>
		 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{String} namespaces</span>
		 <span class="s5">* </span><span class="s6">@api </span><span class="s5">private</span>
		 <span class="s5">*/</span>
		<span class="s0">function </span><span class="s1">save(namespaces) {</span>
			<span class="s0">if </span><span class="s1">(namespaces) {</span>
				<span class="s1">process.env.DEBUG = namespaces</span><span class="s0">;</span>
			<span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
				<span class="s4">// If you set a process.env field to null or undefined, it gets cast to the</span>
				<span class="s4">// string 'null' or 'undefined'. Just delete instead.</span>
				<span class="s0">delete </span><span class="s1">process.env.DEBUG</span><span class="s0">;</span>
			<span class="s1">}</span>
		<span class="s1">}</span>

		<span class="s5">/**</span>
		 <span class="s5">* Load `namespaces`.</span>
		 <span class="s5">*</span>
		 <span class="s5">* </span><span class="s6">@return </span><span class="s5">{String} returns the previously persisted debug modes</span>
		 <span class="s5">* </span><span class="s6">@api </span><span class="s5">private</span>
		 <span class="s5">*/</span>

		<span class="s0">function </span><span class="s1">load() {</span>
			<span class="s0">return </span><span class="s1">process.env.DEBUG</span><span class="s0">;</span>
		<span class="s1">}</span>

		<span class="s5">/**</span>
		 <span class="s5">* Init logic for `debug` instances.</span>
		 <span class="s5">*</span>
		 <span class="s5">* Create a new `inspectOpts` object in case `useColors` is set</span>
		 <span class="s5">* differently for a particular `debug` instance.</span>
		 <span class="s5">*/</span>

		<span class="s0">function </span><span class="s1">init(debug) {</span>
			<span class="s1">debug.inspectOpts = {}</span><span class="s0">;</span>

			<span class="s0">const </span><span class="s1">keys = Object.keys(exports.inspectOpts)</span><span class="s0">;</span>
			<span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s3">0</span><span class="s0">; </span><span class="s1">i &lt; keys.length</span><span class="s0">; </span><span class="s1">i++) {</span>
				<span class="s1">debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]]</span><span class="s0">;</span>
			<span class="s1">}</span>
		<span class="s1">}</span>

		<span class="s1">module.exports = requireCommon()(exports)</span><span class="s0">;</span>

		<span class="s0">const </span><span class="s1">{formatters} = module.exports</span><span class="s0">;</span>

		<span class="s5">/**</span>
		 <span class="s5">* Map %o to `util.inspect()`, all on a single line.</span>
		 <span class="s5">*/</span>

		<span class="s1">formatters.o = </span><span class="s0">function </span><span class="s1">(v) {</span>
			<span class="s0">this</span><span class="s1">.inspectOpts.colors = </span><span class="s0">this</span><span class="s1">.useColors</span><span class="s0">;</span>
			<span class="s0">return </span><span class="s1">util.inspect(v</span><span class="s0">, this</span><span class="s1">.inspectOpts)</span>
				<span class="s1">.split(</span><span class="s2">'</span><span class="s0">\n</span><span class="s2">'</span><span class="s1">)</span>
				<span class="s1">.map(str =&gt; str.trim())</span>
				<span class="s1">.join(</span><span class="s2">' '</span><span class="s1">)</span><span class="s0">;</span>
		<span class="s1">}</span><span class="s0">;</span>

		<span class="s5">/**</span>
		 <span class="s5">* Map %O to `util.inspect()`, allowing multiple lines if needed.</span>
		 <span class="s5">*/</span>

		<span class="s1">formatters.O = </span><span class="s0">function </span><span class="s1">(v) {</span>
			<span class="s0">this</span><span class="s1">.inspectOpts.colors = </span><span class="s0">this</span><span class="s1">.useColors</span><span class="s0">;</span>
			<span class="s0">return </span><span class="s1">util.inspect(v</span><span class="s0">, this</span><span class="s1">.inspectOpts)</span><span class="s0">;</span>
		<span class="s1">}</span><span class="s0">;</span>
<span class="s1">} (node</span><span class="s0">, </span><span class="s1">nodeExports))</span><span class="s0">;</span>
	<span class="s0">return </span><span class="s1">nodeExports</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s5">/**</span>
 <span class="s5">* Detect Electron renderer / nwjs process, which is node, but we should</span>
 <span class="s5">* treat as a browser.</span>
 <span class="s5">*/</span>

<span class="s1">(</span><span class="s0">function </span><span class="s1">(module) {</span>
	<span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">process === </span><span class="s2">'undefined' </span><span class="s1">|| process.type === </span><span class="s2">'renderer' </span><span class="s1">|| process.browser === </span><span class="s0">true </span><span class="s1">|| process.__nwjs) {</span>
		<span class="s1">module.exports = requireBrowser()</span><span class="s0">;</span>
	<span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
		<span class="s1">module.exports = requireNode()</span><span class="s0">;</span>
	<span class="s1">}</span>
<span class="s1">} (src))</span><span class="s0">;</span>

<span class="s0">const </span><span class="s1">_debug = </span><span class="s4">/*@__PURE__*/</span><span class="s1">getDefaultExportFromCjs(srcExports)</span><span class="s0">;</span>

<span class="s0">const </span><span class="s1">debug = _debug(</span><span class="s2">&quot;vite:hmr&quot;</span><span class="s1">)</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">directRequestRE = </span><span class="s3">/(?:\?|&amp;)direct\b/</span><span class="s0">;</span>
<span class="s1">async </span><span class="s0">function </span><span class="s1">handleHotUpdate({ file</span><span class="s0">, </span><span class="s1">modules</span><span class="s0">, </span><span class="s1">read</span><span class="s0">, </span><span class="s1">server }</span><span class="s0">, </span><span class="s1">options) {</span>
  <span class="s0">const </span><span class="s1">prevDescriptor = getDescriptor(file</span><span class="s0">, </span><span class="s1">options</span><span class="s0">, false</span><span class="s1">)</span><span class="s0">;</span>
  <span class="s0">if </span><span class="s1">(!prevDescriptor) {</span>
    <span class="s0">return;</span>
  <span class="s1">}</span>
  <span class="s1">setPrevDescriptor(file</span><span class="s0">, </span><span class="s1">prevDescriptor)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">content = </span><span class="s0">await </span><span class="s1">read()</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">{ descriptor } = createDescriptor(file</span><span class="s0">, </span><span class="s1">content</span><span class="s0">, </span><span class="s1">options)</span><span class="s0">;</span>
  <span class="s0">let </span><span class="s1">needRerender = </span><span class="s0">false;</span>
  <span class="s0">const </span><span class="s1">affectedModules = </span><span class="s4">/* @__PURE__ */ </span><span class="s0">new </span><span class="s1">Set()</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">mainModule = modules.filter((m) =&gt; !</span><span class="s3">/type=/</span><span class="s1">.test(m.url) || </span><span class="s3">/type=script/</span><span class="s1">.test(m.url)).sort((m1</span><span class="s0">, </span><span class="s1">m2) =&gt; {</span>
    <span class="s0">return </span><span class="s1">m1.url.length - m2.url.length</span><span class="s0">;</span>
  <span class="s1">})[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">templateModule = modules.find((m) =&gt; </span><span class="s3">/type=template/</span><span class="s1">.test(m.url))</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">scriptChanged = hasScriptChanged(prevDescriptor</span><span class="s0">, </span><span class="s1">descriptor)</span><span class="s0">;</span>
  <span class="s0">if </span><span class="s1">(scriptChanged) {</span>
    <span class="s0">let </span><span class="s1">scriptModule</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(descriptor.scriptSetup?.lang &amp;&amp; !descriptor.scriptSetup.src || descriptor.script?.lang &amp;&amp; !descriptor.script.src) {</span>
      <span class="s0">const </span><span class="s1">scriptModuleRE = </span><span class="s0">new </span><span class="s1">RegExp(</span>
        <span class="s2">`type=script.*&amp;lang.</span><span class="s1">${descriptor.scriptSetup?.lang || descriptor.script?.lang}</span><span class="s2">$`</span>
      <span class="s1">)</span><span class="s0">;</span>
      <span class="s1">scriptModule = modules.find((m) =&gt; scriptModuleRE.test(m.url))</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s1">affectedModules.add(scriptModule || mainModule)</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">if </span><span class="s1">(!isEqualBlock(descriptor.template</span><span class="s0">, </span><span class="s1">prevDescriptor.template)) {</span>
    <span class="s0">if </span><span class="s1">(!scriptChanged) {</span>
      <span class="s1">setResolvedScript(</span>
        <span class="s1">descriptor</span><span class="s0">,</span>
        <span class="s1">getResolvedScript(prevDescriptor</span><span class="s0">, false</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s0">false</span>
      <span class="s1">)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s1">affectedModules.add(templateModule)</span><span class="s0">;</span>
    <span class="s1">needRerender = </span><span class="s0">true;</span>
  <span class="s1">}</span>
  <span class="s0">let </span><span class="s1">didUpdateStyle = </span><span class="s0">false;</span>
  <span class="s0">const </span><span class="s1">prevStyles = prevDescriptor.styles || []</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">nextStyles = descriptor.styles || []</span><span class="s0">;</span>
  <span class="s0">if </span><span class="s1">(prevDescriptor.cssVars.join(</span><span class="s2">&quot;&quot;</span><span class="s1">) !== descriptor.cssVars.join(</span><span class="s2">&quot;&quot;</span><span class="s1">)) {</span>
    <span class="s1">affectedModules.add(mainModule)</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">if </span><span class="s1">(prevStyles.some((s) =&gt; s.scoped) !== nextStyles.some((s) =&gt; s.scoped)) {</span>
    <span class="s1">affectedModules.add(templateModule)</span><span class="s0">;</span>
    <span class="s1">affectedModules.add(mainModule)</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s3">0</span><span class="s0">; </span><span class="s1">i &lt; nextStyles.length</span><span class="s0">; </span><span class="s1">i++) {</span>
    <span class="s0">const </span><span class="s1">prev = prevStyles[i]</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">next = nextStyles[i]</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(!prev || !isEqualBlock(prev</span><span class="s0">, </span><span class="s1">next)) {</span>
      <span class="s1">didUpdateStyle = </span><span class="s0">true;</span>
      <span class="s0">const </span><span class="s1">mod = modules.find(</span>
        <span class="s1">(m) =&gt; m.url.includes(</span><span class="s2">`type=style&amp;index=</span><span class="s1">${i}</span><span class="s2">`</span><span class="s1">) &amp;&amp; m.url.endsWith(</span><span class="s2">`.</span><span class="s1">${next.lang || </span><span class="s2">&quot;css&quot;</span><span class="s1">}</span><span class="s2">`</span><span class="s1">) &amp;&amp; !directRequestRE.test(m.url)</span>
      <span class="s1">)</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(mod) {</span>
        <span class="s1">affectedModules.add(mod)</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(mod.url.includes(</span><span class="s2">&quot;&amp;inline&quot;</span><span class="s1">)) {</span>
          <span class="s1">affectedModules.add(mainModule)</span><span class="s0">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
        <span class="s1">affectedModules.add(mainModule)</span><span class="s0">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">if </span><span class="s1">(prevStyles.length &gt; nextStyles.length) {</span>
    <span class="s1">affectedModules.add(mainModule)</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">const </span><span class="s1">prevCustoms = prevDescriptor.customBlocks || []</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">nextCustoms = descriptor.customBlocks || []</span><span class="s0">;</span>
  <span class="s0">if </span><span class="s1">(prevCustoms.length !== nextCustoms.length) {</span>
    <span class="s1">affectedModules.add(mainModule)</span><span class="s0">;</span>
  <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
    <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s3">0</span><span class="s0">; </span><span class="s1">i &lt; nextCustoms.length</span><span class="s0">; </span><span class="s1">i++) {</span>
      <span class="s0">const </span><span class="s1">prev = prevCustoms[i]</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">next = nextCustoms[i]</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(!prev || !isEqualBlock(prev</span><span class="s0">, </span><span class="s1">next)) {</span>
        <span class="s0">const </span><span class="s1">mod = modules.find(</span>
          <span class="s1">(m) =&gt; m.url.includes(</span><span class="s2">`type=</span><span class="s1">${prev.type}</span><span class="s2">&amp;index=</span><span class="s1">${i}</span><span class="s2">`</span><span class="s1">)</span>
        <span class="s1">)</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(mod) {</span>
          <span class="s1">affectedModules.add(mod)</span><span class="s0">;</span>
        <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
          <span class="s1">affectedModules.add(mainModule)</span><span class="s0">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">const </span><span class="s1">updateType = []</span><span class="s0">;</span>
  <span class="s0">if </span><span class="s1">(needRerender) {</span>
    <span class="s1">updateType.push(</span><span class="s2">`template`</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(!templateModule) {</span>
      <span class="s1">affectedModules.add(mainModule)</span><span class="s0">;</span>
    <span class="s1">} </span><span class="s0">else if </span><span class="s1">(mainModule &amp;&amp; !affectedModules.has(mainModule)) {</span>
      <span class="s0">const </span><span class="s1">styleImporters = [...mainModule.importers].filter(</span>
        <span class="s1">(m) =&gt; isCSSRequest(m.url)</span>
      <span class="s1">)</span><span class="s0">;</span>
      <span class="s1">styleImporters.forEach((m) =&gt; affectedModules.add(m))</span><span class="s0">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">if </span><span class="s1">(didUpdateStyle) {</span>
    <span class="s1">updateType.push(</span><span class="s2">`style`</span><span class="s1">)</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">if </span><span class="s1">(updateType.length) {</span>
    <span class="s1">debug(</span><span class="s2">`[vue:update(</span><span class="s1">${updateType.join(</span><span class="s2">&quot;&amp;&quot;</span><span class="s1">)}</span><span class="s2">)] </span><span class="s1">${file}</span><span class="s2">`</span><span class="s1">)</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">return </span><span class="s1">[...affectedModules].filter(Boolean)</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">isEqualBlock(a</span><span class="s0">, </span><span class="s1">b) {</span>
  <span class="s0">if </span><span class="s1">(!a &amp;&amp; !b)</span>
    <span class="s0">return true;</span>
  <span class="s0">if </span><span class="s1">(!a || !b)</span>
    <span class="s0">return false;</span>
  <span class="s0">if </span><span class="s1">(a.src &amp;&amp; b.src &amp;&amp; a.src === b.src)</span>
    <span class="s0">return true;</span>
  <span class="s0">if </span><span class="s1">(a.content !== b.content)</span>
    <span class="s0">return false;</span>
  <span class="s0">const </span><span class="s1">keysA = Object.keys(a.attrs)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">keysB = Object.keys(b.attrs)</span><span class="s0">;</span>
  <span class="s0">if </span><span class="s1">(keysA.length !== keysB.length) {</span>
    <span class="s0">return false;</span>
  <span class="s1">}</span>
  <span class="s0">return </span><span class="s1">keysA.every((key) =&gt; a.attrs[key] === b.attrs[key])</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">isOnlyTemplateChanged(prev</span><span class="s0">, </span><span class="s1">next) {</span>
  <span class="s0">return </span><span class="s1">!hasScriptChanged(prev</span><span class="s0">, </span><span class="s1">next) &amp;&amp; prev.styles.length === next.styles.length &amp;&amp; prev.styles.every((s</span><span class="s0">, </span><span class="s1">i) =&gt; isEqualBlock(s</span><span class="s0">, </span><span class="s1">next.styles[i])) &amp;&amp; prev.customBlocks.length === next.customBlocks.length &amp;&amp; prev.customBlocks.every((s</span><span class="s0">, </span><span class="s1">i) =&gt; isEqualBlock(s</span><span class="s0">, </span><span class="s1">next.customBlocks[i]))</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">hasScriptChanged(prev</span><span class="s0">, </span><span class="s1">next) {</span>
  <span class="s0">if </span><span class="s1">(!isEqualBlock(prev.script</span><span class="s0">, </span><span class="s1">next.script)) {</span>
    <span class="s0">return true;</span>
  <span class="s1">}</span>
  <span class="s0">if </span><span class="s1">(!isEqualBlock(prev.scriptSetup</span><span class="s0">, </span><span class="s1">next.scriptSetup)) {</span>
    <span class="s0">return true;</span>
  <span class="s1">}</span>
  <span class="s0">const </span><span class="s1">prevResolvedScript = getResolvedScript(prev</span><span class="s0">, false</span><span class="s1">)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">prevImports = prevResolvedScript?.imports</span><span class="s0">;</span>
  <span class="s0">if </span><span class="s1">(prevImports) {</span>
    <span class="s0">return </span><span class="s1">!next.template || next.shouldForceReload(prevImports)</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">return false;</span>
<span class="s1">}</span>

<span class="s0">const </span><span class="s1">EXPORT_HELPER_ID = </span><span class="s2">&quot;</span><span class="s0">\0</span><span class="s2">plugin-vue:export-helper&quot;</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">helperCode = </span><span class="s2">`</span>
<span class="s2">export default (sfc, props) =&gt; { 
  const target = sfc.__vccOpts || sfc; 
  for (const [key, val] of props) { 
    target[key] = val; 
  } 
  return target; 
} 
`</span><span class="s0">;</span>

<span class="s1">async </span><span class="s0">function </span><span class="s1">transformMain(code</span><span class="s0">, </span><span class="s1">filename</span><span class="s0">, </span><span class="s1">options</span><span class="s0">, </span><span class="s1">pluginContext</span><span class="s0">, </span><span class="s1">ssr</span><span class="s0">, </span><span class="s1">asCustomElement) {</span>
  <span class="s0">const </span><span class="s1">{ devServer</span><span class="s0">, </span><span class="s1">isProduction</span><span class="s0">, </span><span class="s1">devToolsEnabled } = options</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">prevDescriptor = getPrevDescriptor(filename)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">{ descriptor</span><span class="s0">, </span><span class="s1">errors } = createDescriptor(filename</span><span class="s0">, </span><span class="s1">code</span><span class="s0">, </span><span class="s1">options)</span><span class="s0">;</span>
  <span class="s0">if </span><span class="s1">(errors.length) {</span>
    <span class="s1">errors.forEach(</span>
      <span class="s1">(error) =&gt; pluginContext.error(createRollupError(filename</span><span class="s0">, </span><span class="s1">error))</span>
    <span class="s1">)</span><span class="s0">;</span>
    <span class="s0">return null;</span>
  <span class="s1">}</span>
  <span class="s0">const </span><span class="s1">attachedProps = []</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">hasScoped = descriptor.styles.some((s) =&gt; s.scoped)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">{ code: scriptCode</span><span class="s0">, </span><span class="s1">map: scriptMap } = </span><span class="s0">await </span><span class="s1">genScriptCode(</span>
    <span class="s1">descriptor</span><span class="s0">,</span>
    <span class="s1">options</span><span class="s0">,</span>
    <span class="s1">pluginContext</span><span class="s0">,</span>
    <span class="s1">ssr</span>
  <span class="s1">)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">hasTemplateImport = descriptor.template &amp;&amp; !isUseInlineTemplate(descriptor</span><span class="s0">, </span><span class="s1">!devServer)</span><span class="s0">;</span>
  <span class="s0">let </span><span class="s1">templateCode = </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
  <span class="s0">let </span><span class="s1">templateMap = </span><span class="s0">void </span><span class="s3">0</span><span class="s0">;</span>
  <span class="s0">if </span><span class="s1">(hasTemplateImport) {</span>
    <span class="s1">({ code: templateCode</span><span class="s0">, </span><span class="s1">map: templateMap } = </span><span class="s0">await </span><span class="s1">genTemplateCode(</span>
      <span class="s1">descriptor</span><span class="s0">,</span>
      <span class="s1">options</span><span class="s0">,</span>
      <span class="s1">pluginContext</span><span class="s0">,</span>
      <span class="s1">ssr</span>
    <span class="s1">))</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">if </span><span class="s1">(hasTemplateImport) {</span>
    <span class="s1">attachedProps.push(</span>
      <span class="s1">ssr ? [</span><span class="s2">&quot;ssrRender&quot;</span><span class="s0">, </span><span class="s2">&quot;_sfc_ssrRender&quot;</span><span class="s1">] : [</span><span class="s2">&quot;render&quot;</span><span class="s0">, </span><span class="s2">&quot;_sfc_render&quot;</span><span class="s1">]</span>
    <span class="s1">)</span><span class="s0">;</span>
  <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
    <span class="s0">if </span><span class="s1">(prevDescriptor &amp;&amp; !isEqualBlock(descriptor.template</span><span class="s0">, </span><span class="s1">prevDescriptor.template)) {</span>
      <span class="s1">attachedProps.push([ssr ? </span><span class="s2">&quot;ssrRender&quot; </span><span class="s1">: </span><span class="s2">&quot;render&quot;</span><span class="s0">, </span><span class="s2">&quot;() =&gt; {}&quot;</span><span class="s1">])</span><span class="s0">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">const </span><span class="s1">stylesCode = </span><span class="s0">await </span><span class="s1">genStyleCode(</span>
    <span class="s1">descriptor</span><span class="s0">,</span>
    <span class="s1">pluginContext</span><span class="s0">,</span>
    <span class="s1">asCustomElement</span><span class="s0">,</span>
    <span class="s1">attachedProps</span>
  <span class="s1">)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">customBlocksCode = </span><span class="s0">await </span><span class="s1">genCustomBlockCode(descriptor</span><span class="s0">, </span><span class="s1">pluginContext)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">output = [</span>
    <span class="s1">scriptCode</span><span class="s0">,</span>
    <span class="s1">templateCode</span><span class="s0">,</span>
    <span class="s1">stylesCode</span><span class="s0">,</span>
    <span class="s1">customBlocksCode</span>
  <span class="s1">]</span><span class="s0">;</span>
  <span class="s0">if </span><span class="s1">(hasScoped) {</span>
    <span class="s1">attachedProps.push([</span><span class="s2">`__scopeId`</span><span class="s0">, </span><span class="s1">JSON.stringify(</span><span class="s2">`data-v-</span><span class="s1">${descriptor.id}</span><span class="s2">`</span><span class="s1">)])</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">if </span><span class="s1">(devToolsEnabled || devServer &amp;&amp; !isProduction) {</span>
    <span class="s1">attachedProps.push([</span>
      <span class="s2">`__file`</span><span class="s0">,</span>
      <span class="s1">JSON.stringify(isProduction ? path.basename(filename) : filename)</span>
    <span class="s1">])</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">if </span><span class="s1">(devServer &amp;&amp; devServer.config.server.hmr !== </span><span class="s0">false </span><span class="s1">&amp;&amp; !ssr &amp;&amp; !isProduction) {</span>
    <span class="s1">output.push(</span><span class="s2">`_sfc_main.__hmrId = </span><span class="s1">${JSON.stringify(descriptor.id)}</span><span class="s2">`</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s1">output.push(</span>
      <span class="s2">`typeof __VUE_HMR_RUNTIME__ !== 'undefined' &amp;&amp; __VUE_HMR_RUNTIME__.createRecord(_sfc_main.__hmrId, _sfc_main)`</span>
    <span class="s1">)</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(prevDescriptor &amp;&amp; isOnlyTemplateChanged(prevDescriptor</span><span class="s0">, </span><span class="s1">descriptor)) {</span>
      <span class="s1">output.push(</span><span class="s2">`export const _rerender_only = true`</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s1">output.push(</span>
      <span class="s2">`import.meta.hot.accept(mod =&gt; {`</span><span class="s0">,</span>
      <span class="s2">`  if (!mod) return`</span><span class="s0">,</span>
      <span class="s2">`  const { default: updated, _rerender_only } = mod`</span><span class="s0">,</span>
      <span class="s2">`  if (_rerender_only) {`</span><span class="s0">,</span>
      <span class="s2">`    __VUE_HMR_RUNTIME__.rerender(updated.__hmrId, updated.render)`</span><span class="s0">,</span>
      <span class="s2">`  } else {`</span><span class="s0">,</span>
      <span class="s2">`    __VUE_HMR_RUNTIME__.reload(updated.__hmrId, updated)`</span><span class="s0">,</span>
      <span class="s2">`  }`</span><span class="s0">,</span>
      <span class="s2">`})`</span>
    <span class="s1">)</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">if </span><span class="s1">(ssr) {</span>
    <span class="s0">const </span><span class="s1">normalizedFilename = normalizePath$1(</span>
      <span class="s1">path.relative(options.root</span><span class="s0">, </span><span class="s1">filename)</span>
    <span class="s1">)</span><span class="s0">;</span>
    <span class="s1">output.push(</span>
      <span class="s2">`import { useSSRContext as __vite_useSSRContext } from 'vue'`</span><span class="s0">,</span>
      <span class="s2">`const _sfc_setup = _sfc_main.setup`</span><span class="s0">,</span>
      <span class="s2">`_sfc_main.setup = (props, ctx) =&gt; {`</span><span class="s0">,</span>
      <span class="s2">`  const ssrContext = __vite_useSSRContext()`</span><span class="s0">,</span>
      <span class="s2">`  ;(ssrContext.modules || (ssrContext.modules = new Set())).add(</span><span class="s1">${JSON.stringify(</span>
        <span class="s1">normalizedFilename</span>
      <span class="s1">)}</span><span class="s2">)`</span><span class="s0">,</span>
      <span class="s2">`  return _sfc_setup ? _sfc_setup(props, ctx) : undefined`</span><span class="s0">,</span>
      <span class="s2">`}`</span>
    <span class="s1">)</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">let </span><span class="s1">resolvedMap = </span><span class="s0">void </span><span class="s3">0</span><span class="s0">;</span>
  <span class="s0">if </span><span class="s1">(options.sourceMap) {</span>
    <span class="s0">if </span><span class="s1">(scriptMap &amp;&amp; templateMap) {</span>
      <span class="s0">const </span><span class="s1">gen = fromMap(</span>
        <span class="s4">// version property of result.map is declared as string</span>
        <span class="s4">// but actually it is `3`</span>
        <span class="s1">scriptMap</span>
      <span class="s1">)</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">tracer = </span><span class="s0">new </span><span class="s1">TraceMap(</span>
        <span class="s4">// same above</span>
        <span class="s1">templateMap</span>
      <span class="s1">)</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">offset = (scriptCode.match(</span><span class="s3">/\r?\n/g</span><span class="s1">)?.length ?? </span><span class="s3">0</span><span class="s1">) + </span><span class="s3">1</span><span class="s0">;</span>
      <span class="s1">eachMapping(tracer</span><span class="s0">, </span><span class="s1">(m) =&gt; {</span>
        <span class="s0">if </span><span class="s1">(m.source == </span><span class="s0">null</span><span class="s1">)</span>
          <span class="s0">return;</span>
        <span class="s1">addMapping(gen</span><span class="s0">, </span><span class="s1">{</span>
          <span class="s1">source: m.source</span><span class="s0">,</span>
          <span class="s1">original: { line: m.originalLine</span><span class="s0">, </span><span class="s1">column: m.originalColumn }</span><span class="s0">,</span>
          <span class="s1">generated: {</span>
            <span class="s1">line: m.generatedLine + offset</span><span class="s0">,</span>
            <span class="s1">column: m.generatedColumn</span>
          <span class="s1">}</span>
        <span class="s1">})</span><span class="s0">;</span>
      <span class="s1">})</span><span class="s0">;</span>
      <span class="s1">resolvedMap = toEncodedMap(gen)</span><span class="s0">;</span>
      <span class="s1">resolvedMap.sourcesContent = templateMap.sourcesContent</span><span class="s0">;</span>
    <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
      <span class="s1">resolvedMap = scriptMap ?? templateMap</span><span class="s0">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">if </span><span class="s1">(!attachedProps.length) {</span>
    <span class="s1">output.push(</span><span class="s2">`export default _sfc_main`</span><span class="s1">)</span><span class="s0">;</span>
  <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
    <span class="s1">output.push(</span>
      <span class="s2">`import _export_sfc from '</span><span class="s1">${EXPORT_HELPER_ID}</span><span class="s2">'`</span><span class="s0">,</span>
      <span class="s2">`export default /*#__PURE__*/_export_sfc(_sfc_main, [</span><span class="s1">${attachedProps.map(([key</span><span class="s0">, </span><span class="s1">val]) =&gt; </span><span class="s2">`['</span><span class="s1">${key}</span><span class="s2">',</span><span class="s1">${val}</span><span class="s2">]`</span><span class="s1">).join(</span><span class="s2">&quot;,&quot;</span><span class="s1">)}</span><span class="s2">])`</span>
    <span class="s1">)</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">let </span><span class="s1">resolvedCode = output.join(</span><span class="s2">&quot;</span><span class="s0">\n</span><span class="s2">&quot;</span><span class="s1">)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">lang = descriptor.scriptSetup?.lang || descriptor.script?.lang</span><span class="s0">;</span>
  <span class="s0">if </span><span class="s1">(lang &amp;&amp; </span><span class="s3">/tsx?$/</span><span class="s1">.test(lang) &amp;&amp; !descriptor.script?.src) {</span>
    <span class="s0">const </span><span class="s1">{ code: code2</span><span class="s0">, </span><span class="s1">map } = </span><span class="s0">await </span><span class="s1">transformWithEsbuild(</span>
      <span class="s1">resolvedCode</span><span class="s0">,</span>
      <span class="s1">filename</span><span class="s0">,</span>
      <span class="s1">{</span>
        <span class="s1">loader: </span><span class="s2">&quot;ts&quot;</span><span class="s0">,</span>
        <span class="s1">target: </span><span class="s2">&quot;esnext&quot;</span><span class="s0">,</span>
        <span class="s1">sourcemap: options.sourceMap</span>
      <span class="s1">}</span><span class="s0">,</span>
      <span class="s1">resolvedMap</span>
    <span class="s1">)</span><span class="s0">;</span>
    <span class="s1">resolvedCode = code2</span><span class="s0">;</span>
    <span class="s1">resolvedMap = resolvedMap ? map : resolvedMap</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">return </span><span class="s1">{</span>
    <span class="s1">code: resolvedCode</span><span class="s0">,</span>
    <span class="s1">map: resolvedMap || {</span>
      <span class="s1">mappings: </span><span class="s2">&quot;&quot;</span>
    <span class="s1">}</span><span class="s0">,</span>
    <span class="s1">meta: {</span>
      <span class="s1">vite: {</span>
        <span class="s1">lang: descriptor.script?.lang || descriptor.scriptSetup?.lang || </span><span class="s2">&quot;js&quot;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s0">function </span><span class="s1">genTemplateCode(descriptor</span><span class="s0">, </span><span class="s1">options</span><span class="s0">, </span><span class="s1">pluginContext</span><span class="s0">, </span><span class="s1">ssr) {</span>
  <span class="s0">const </span><span class="s1">template = descriptor.template</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">hasScoped = descriptor.styles.some((style) =&gt; style.scoped)</span><span class="s0">;</span>
  <span class="s0">if </span><span class="s1">(!template.lang &amp;&amp; !template.src) {</span>
    <span class="s0">return </span><span class="s1">transformTemplateInMain(</span>
      <span class="s1">template.content</span><span class="s0">,</span>
      <span class="s1">descriptor</span><span class="s0">,</span>
      <span class="s1">options</span><span class="s0">,</span>
      <span class="s1">pluginContext</span><span class="s0">,</span>
      <span class="s1">ssr</span>
    <span class="s1">)</span><span class="s0">;</span>
  <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
    <span class="s0">if </span><span class="s1">(template.src) {</span>
      <span class="s0">await </span><span class="s1">linkSrcToDescriptor(</span>
        <span class="s1">template.src</span><span class="s0">,</span>
        <span class="s1">descriptor</span><span class="s0">,</span>
        <span class="s1">pluginContext</span><span class="s0">,</span>
        <span class="s1">hasScoped</span>
      <span class="s1">)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">const </span><span class="s1">src = template.src || descriptor.filename</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">srcQuery = template.src ? hasScoped ? </span><span class="s2">`&amp;src=</span><span class="s1">${descriptor.id}</span><span class="s2">` </span><span class="s1">: </span><span class="s2">&quot;&amp;src=true&quot; </span><span class="s1">: </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">scopedQuery = hasScoped ? </span><span class="s2">`&amp;scoped=</span><span class="s1">${descriptor.id}</span><span class="s2">` </span><span class="s1">: </span><span class="s2">``</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">attrsQuery = attrsToQuery(template.attrs</span><span class="s0">, </span><span class="s2">&quot;js&quot;</span><span class="s0">, true</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">query = </span><span class="s2">`?vue&amp;type=template</span><span class="s1">${srcQuery}${scopedQuery}${attrsQuery}</span><span class="s2">`</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">request = JSON.stringify(src + query)</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">renderFnName = ssr ? </span><span class="s2">&quot;ssrRender&quot; </span><span class="s1">: </span><span class="s2">&quot;render&quot;</span><span class="s0">;</span>
    <span class="s0">return </span><span class="s1">{</span>
      <span class="s1">code: </span><span class="s2">`import { </span><span class="s1">${renderFnName} </span><span class="s2">as _sfc_</span><span class="s1">${renderFnName} </span><span class="s2">} from </span><span class="s1">${request}</span><span class="s2">`</span><span class="s0">,</span>
      <span class="s1">map: </span><span class="s0">void </span><span class="s3">0</span>
    <span class="s1">}</span><span class="s0">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s0">function </span><span class="s1">genScriptCode(descriptor</span><span class="s0">, </span><span class="s1">options</span><span class="s0">, </span><span class="s1">pluginContext</span><span class="s0">, </span><span class="s1">ssr) {</span>
  <span class="s0">let </span><span class="s1">scriptCode = </span><span class="s2">`const _sfc_main = {}`</span><span class="s0">;</span>
  <span class="s0">let </span><span class="s1">map</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">script = resolveScript(descriptor</span><span class="s0">, </span><span class="s1">options</span><span class="s0">, </span><span class="s1">ssr)</span><span class="s0">;</span>
  <span class="s0">if </span><span class="s1">(script) {</span>
    <span class="s0">if </span><span class="s1">((!script.lang || script.lang === </span><span class="s2">&quot;ts&quot; </span><span class="s1">&amp;&amp; options.devServer) &amp;&amp; !script.src) {</span>
      <span class="s0">const </span><span class="s1">userPlugins = options.script?.babelParserPlugins || []</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">defaultPlugins = script.lang === </span><span class="s2">&quot;ts&quot; </span><span class="s1">? userPlugins.includes(</span><span class="s2">&quot;decorators&quot;</span><span class="s1">) ? [</span><span class="s2">&quot;typescript&quot;</span><span class="s1">] : [</span><span class="s2">&quot;typescript&quot;</span><span class="s0">, </span><span class="s2">&quot;decorators-legacy&quot;</span><span class="s1">] : []</span><span class="s0">;</span>
      <span class="s1">scriptCode = options.compiler.rewriteDefault(</span>
        <span class="s1">script.content</span><span class="s0">,</span>
        <span class="s2">&quot;_sfc_main&quot;</span><span class="s0">,</span>
        <span class="s1">[...defaultPlugins</span><span class="s0">, </span><span class="s1">...userPlugins]</span>
      <span class="s1">)</span><span class="s0">;</span>
      <span class="s1">map = script.map</span><span class="s0">;</span>
    <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
      <span class="s0">if </span><span class="s1">(script.src) {</span>
        <span class="s0">await </span><span class="s1">linkSrcToDescriptor(script.src</span><span class="s0">, </span><span class="s1">descriptor</span><span class="s0">, </span><span class="s1">pluginContext</span><span class="s0">, false</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">const </span><span class="s1">src = script.src || descriptor.filename</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">langFallback = script.src &amp;&amp; path.extname(src).slice(</span><span class="s3">1</span><span class="s1">) || </span><span class="s2">&quot;js&quot;</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">attrsQuery = attrsToQuery(script.attrs</span><span class="s0">, </span><span class="s1">langFallback)</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">srcQuery = script.src ? </span><span class="s2">`&amp;src=true` </span><span class="s1">: </span><span class="s2">``</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">query = </span><span class="s2">`?vue&amp;type=script</span><span class="s1">${srcQuery}${attrsQuery}</span><span class="s2">`</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">request = JSON.stringify(src + query)</span><span class="s0">;</span>
      <span class="s1">scriptCode = </span><span class="s2">`import _sfc_main from </span><span class="s1">${request}</span>
<span class="s2">export * from </span><span class="s1">${request}</span><span class="s2">`</span><span class="s0">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">return </span><span class="s1">{</span>
    <span class="s1">code: scriptCode</span><span class="s0">,</span>
    <span class="s1">map</span>
  <span class="s1">}</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s0">function </span><span class="s1">genStyleCode(descriptor</span><span class="s0">, </span><span class="s1">pluginContext</span><span class="s0">, </span><span class="s1">asCustomElement</span><span class="s0">, </span><span class="s1">attachedProps) {</span>
  <span class="s0">let </span><span class="s1">stylesCode = </span><span class="s2">``</span><span class="s0">;</span>
  <span class="s0">let </span><span class="s1">cssModulesMap</span><span class="s0">;</span>
  <span class="s0">if </span><span class="s1">(descriptor.styles.length) {</span>
    <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s3">0</span><span class="s0">; </span><span class="s1">i &lt; descriptor.styles.length</span><span class="s0">; </span><span class="s1">i++) {</span>
      <span class="s0">const </span><span class="s1">style = descriptor.styles[i]</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(style.src) {</span>
        <span class="s0">await </span><span class="s1">linkSrcToDescriptor(</span>
          <span class="s1">style.src</span><span class="s0">,</span>
          <span class="s1">descriptor</span><span class="s0">,</span>
          <span class="s1">pluginContext</span><span class="s0">,</span>
          <span class="s1">style.scoped</span>
        <span class="s1">)</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">const </span><span class="s1">src = style.src || descriptor.filename</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">attrsQuery = attrsToQuery(style.attrs</span><span class="s0">, </span><span class="s2">&quot;css&quot;</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">srcQuery = style.src ? style.scoped ? </span><span class="s2">`&amp;src=</span><span class="s1">${descriptor.id}</span><span class="s2">` </span><span class="s1">: </span><span class="s2">&quot;&amp;src=true&quot; </span><span class="s1">: </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">directQuery = asCustomElement ? </span><span class="s2">`&amp;inline` </span><span class="s1">: </span><span class="s2">``</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">scopedQuery = style.scoped ? </span><span class="s2">`&amp;scoped=</span><span class="s1">${descriptor.id}</span><span class="s2">` </span><span class="s1">: </span><span class="s2">``</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">query = </span><span class="s2">`?vue&amp;type=style&amp;index=</span><span class="s1">${i}${srcQuery}${directQuery}${scopedQuery}</span><span class="s2">`</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">styleRequest = src + query + attrsQuery</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(style.module) {</span>
        <span class="s0">if </span><span class="s1">(asCustomElement) {</span>
          <span class="s0">throw new </span><span class="s1">Error(</span>
            <span class="s2">`&lt;style module&gt; is not supported in custom elements mode.`</span>
          <span class="s1">)</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">const </span><span class="s1">[importCode</span><span class="s0">, </span><span class="s1">nameMap] = genCSSModulesCode(</span>
          <span class="s1">i</span><span class="s0">,</span>
          <span class="s1">styleRequest</span><span class="s0">,</span>
          <span class="s1">style.module</span>
        <span class="s1">)</span><span class="s0">;</span>
        <span class="s1">stylesCode += importCode</span><span class="s0">;</span>
        <span class="s1">Object.assign(cssModulesMap || (cssModulesMap = {})</span><span class="s0">, </span><span class="s1">nameMap)</span><span class="s0">;</span>
      <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
        <span class="s0">if </span><span class="s1">(asCustomElement) {</span>
          <span class="s1">stylesCode += </span><span class="s2">`</span>
<span class="s2">import _style_</span><span class="s1">${i} </span><span class="s2">from </span><span class="s1">${JSON.stringify(</span>
            <span class="s1">styleRequest</span>
          <span class="s1">)}</span><span class="s2">`</span><span class="s0">;</span>
        <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
          <span class="s1">stylesCode += </span><span class="s2">`</span>
<span class="s2">import </span><span class="s1">${JSON.stringify(styleRequest)}</span><span class="s2">`</span><span class="s0">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">if </span><span class="s1">(asCustomElement) {</span>
      <span class="s1">attachedProps.push([</span>
        <span class="s2">`styles`</span><span class="s0">,</span>
        <span class="s2">`[</span><span class="s1">${descriptor.styles.map((_</span><span class="s0">, </span><span class="s1">i) =&gt; </span><span class="s2">`_style_</span><span class="s1">${i}</span><span class="s2">`</span><span class="s1">).join(</span><span class="s2">&quot;,&quot;</span><span class="s1">)}</span><span class="s2">]`</span>
      <span class="s1">])</span><span class="s0">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">if </span><span class="s1">(cssModulesMap) {</span>
    <span class="s0">const </span><span class="s1">mappingCode = Object.entries(cssModulesMap).reduce(</span>
      <span class="s1">(code</span><span class="s0">, </span><span class="s1">[key</span><span class="s0">, </span><span class="s1">value]) =&gt; code + </span><span class="s2">`&quot;</span><span class="s1">${key}</span><span class="s2">&quot;:</span><span class="s1">${value}</span><span class="s2">, 
`</span><span class="s0">,</span>
      <span class="s2">&quot;{</span><span class="s0">\n</span><span class="s2">&quot;</span>
    <span class="s1">) + </span><span class="s2">&quot;}&quot;</span><span class="s0">;</span>
    <span class="s1">stylesCode += </span><span class="s2">`</span>
<span class="s2">const cssModules = </span><span class="s1">${mappingCode}</span><span class="s2">`</span><span class="s0">;</span>
    <span class="s1">attachedProps.push([</span><span class="s2">`__cssModules`</span><span class="s0">, </span><span class="s2">`cssModules`</span><span class="s1">])</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">return </span><span class="s1">stylesCode</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">genCSSModulesCode(index</span><span class="s0">, </span><span class="s1">request</span><span class="s0">, </span><span class="s1">moduleName) {</span>
  <span class="s0">const </span><span class="s1">styleVar = </span><span class="s2">`style</span><span class="s1">${index}</span><span class="s2">`</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">exposedName = </span><span class="s0">typeof </span><span class="s1">moduleName === </span><span class="s2">&quot;string&quot; </span><span class="s1">? moduleName : </span><span class="s2">&quot;$style&quot;</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">moduleRequest = request.replace(</span><span class="s3">/\.(\w+)$/</span><span class="s0">, </span><span class="s2">&quot;.module.$1&quot;</span><span class="s1">)</span><span class="s0">;</span>
  <span class="s0">return </span><span class="s1">[</span>
    <span class="s2">`</span>
<span class="s2">import </span><span class="s1">${styleVar} </span><span class="s2">from </span><span class="s1">${JSON.stringify(moduleRequest)}</span><span class="s2">`</span><span class="s0">,</span>
    <span class="s1">{ [exposedName]: styleVar }</span>
  <span class="s1">]</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s0">function </span><span class="s1">genCustomBlockCode(descriptor</span><span class="s0">, </span><span class="s1">pluginContext) {</span>
  <span class="s0">let </span><span class="s1">code = </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
  <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">index = </span><span class="s3">0</span><span class="s0">; </span><span class="s1">index &lt; descriptor.customBlocks.length</span><span class="s0">; </span><span class="s1">index++) {</span>
    <span class="s0">const </span><span class="s1">block = descriptor.customBlocks[index]</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(block.src) {</span>
      <span class="s0">await </span><span class="s1">linkSrcToDescriptor(block.src</span><span class="s0">, </span><span class="s1">descriptor</span><span class="s0">, </span><span class="s1">pluginContext</span><span class="s0">, false</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s1">}</span>
    <span class="s0">const </span><span class="s1">src = block.src || descriptor.filename</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">attrsQuery = attrsToQuery(block.attrs</span><span class="s0">, </span><span class="s1">block.type)</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">srcQuery = block.src ? </span><span class="s2">`&amp;src=true` </span><span class="s1">: </span><span class="s2">``</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">query = </span><span class="s2">`?vue&amp;type=</span><span class="s1">${block.type}</span><span class="s2">&amp;index=</span><span class="s1">${index}${srcQuery}${attrsQuery}</span><span class="s2">`</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">request = JSON.stringify(src + query)</span><span class="s0">;</span>
    <span class="s1">code += </span><span class="s2">`import block</span><span class="s1">${index} </span><span class="s2">from </span><span class="s1">${request}</span>
<span class="s2">`</span><span class="s0">;</span>
    <span class="s1">code += </span><span class="s2">`if (typeof block</span><span class="s1">${index} </span><span class="s2">=== 'function') block</span><span class="s1">${index}</span><span class="s2">(_sfc_main) 
`</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">return </span><span class="s1">code</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s0">function </span><span class="s1">linkSrcToDescriptor(src</span><span class="s0">, </span><span class="s1">descriptor</span><span class="s0">, </span><span class="s1">pluginContext</span><span class="s0">, </span><span class="s1">scoped) {</span>
  <span class="s0">const </span><span class="s1">srcFile = (</span><span class="s0">await </span><span class="s1">pluginContext.resolve(src</span><span class="s0">, </span><span class="s1">descriptor.filename))?.id || src</span><span class="s0">;</span>
  <span class="s1">setSrcDescriptor(srcFile.replace(</span><span class="s3">/\?.*$/</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">descriptor</span><span class="s0">, </span><span class="s1">scoped)</span><span class="s0">;</span>
<span class="s1">}</span>
<span class="s0">const </span><span class="s1">ignoreList = [</span><span class="s2">&quot;id&quot;</span><span class="s0">, </span><span class="s2">&quot;index&quot;</span><span class="s0">, </span><span class="s2">&quot;src&quot;</span><span class="s0">, </span><span class="s2">&quot;type&quot;</span><span class="s0">, </span><span class="s2">&quot;lang&quot;</span><span class="s0">, </span><span class="s2">&quot;module&quot;</span><span class="s0">, </span><span class="s2">&quot;scoped&quot;</span><span class="s1">]</span><span class="s0">;</span>
<span class="s0">function </span><span class="s1">attrsToQuery(attrs</span><span class="s0">, </span><span class="s1">langFallback</span><span class="s0">, </span><span class="s1">forceLangFallback = </span><span class="s0">false</span><span class="s1">) {</span>
  <span class="s0">let </span><span class="s1">query = </span><span class="s2">``</span><span class="s0">;</span>
  <span class="s0">for </span><span class="s1">(</span><span class="s0">const </span><span class="s1">name </span><span class="s0">in </span><span class="s1">attrs) {</span>
    <span class="s0">const </span><span class="s1">value = attrs[name]</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(!ignoreList.includes(name)) {</span>
      <span class="s1">query += </span><span class="s2">`&amp;</span><span class="s1">${encodeURIComponent(name)}${value ? </span><span class="s2">`=</span><span class="s1">${encodeURIComponent(value)}</span><span class="s2">` </span><span class="s1">: </span><span class="s2">``</span><span class="s1">}</span><span class="s2">`</span><span class="s0">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">if </span><span class="s1">(langFallback || attrs.lang) {</span>
    <span class="s1">query += </span><span class="s2">`lang` </span><span class="s0">in </span><span class="s1">attrs ? forceLangFallback ? </span><span class="s2">`&amp;lang.</span><span class="s1">${langFallback}</span><span class="s2">` </span><span class="s1">: </span><span class="s2">`&amp;lang.</span><span class="s1">${attrs.lang}</span><span class="s2">` </span><span class="s1">: </span><span class="s2">`&amp;lang.</span><span class="s1">${langFallback}</span><span class="s2">`</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">return </span><span class="s1">query</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s1">async </span><span class="s0">function </span><span class="s1">transformStyle(code</span><span class="s0">, </span><span class="s1">descriptor</span><span class="s0">, </span><span class="s1">index</span><span class="s0">, </span><span class="s1">options</span><span class="s0">, </span><span class="s1">pluginContext</span><span class="s0">, </span><span class="s1">filename) {</span>
  <span class="s0">const </span><span class="s1">block = descriptor.styles[index]</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">result = </span><span class="s0">await </span><span class="s1">options.compiler.compileStyleAsync({</span>
    <span class="s1">...options.style</span><span class="s0">,</span>
    <span class="s1">filename: descriptor.filename</span><span class="s0">,</span>
    <span class="s1">id: </span><span class="s2">`data-v-</span><span class="s1">${descriptor.id}</span><span class="s2">`</span><span class="s0">,</span>
    <span class="s1">isProd: options.isProduction</span><span class="s0">,</span>
    <span class="s1">source: code</span><span class="s0">,</span>
    <span class="s1">scoped: block.scoped</span><span class="s0">,</span>
    <span class="s1">...options.cssDevSourcemap ? {</span>
      <span class="s1">postcssOptions: {</span>
        <span class="s1">map: {</span>
          <span class="s1">from: filename</span><span class="s0">,</span>
          <span class="s1">inline: </span><span class="s0">false,</span>
          <span class="s1">annotation: </span><span class="s0">false</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} : {}</span>
  <span class="s1">})</span><span class="s0">;</span>
  <span class="s0">if </span><span class="s1">(result.errors.length) {</span>
    <span class="s1">result.errors.forEach((error) =&gt; {</span>
      <span class="s0">if </span><span class="s1">(error.line &amp;&amp; error.column) {</span>
        <span class="s1">error.loc = {</span>
          <span class="s1">file: descriptor.filename</span><span class="s0">,</span>
          <span class="s1">line: error.line + block.loc.start.line</span><span class="s0">,</span>
          <span class="s1">column: error.column</span>
        <span class="s1">}</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s1">pluginContext.error(error)</span><span class="s0">;</span>
    <span class="s1">})</span><span class="s0">;</span>
    <span class="s0">return null;</span>
  <span class="s1">}</span>
  <span class="s0">const </span><span class="s1">map = result.map ? </span><span class="s0">await </span><span class="s1">formatPostcssSourceMap(</span>
    <span class="s4">// version property of result.map is declared as string</span>
    <span class="s4">// but actually it is a number</span>
    <span class="s1">result.map</span><span class="s0">,</span>
    <span class="s1">filename</span>
  <span class="s1">) : { mappings: </span><span class="s2">&quot;&quot; </span><span class="s1">}</span><span class="s0">;</span>
  <span class="s0">return </span><span class="s1">{</span>
    <span class="s1">code: result.code</span><span class="s0">,</span>
    <span class="s1">map</span>
  <span class="s1">}</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">vuePlugin(rawOptions = {}) {</span>
  <span class="s0">const </span><span class="s1">{</span>
    <span class="s1">include = </span><span class="s3">/\.vue$/</span><span class="s0">,</span>
    <span class="s1">exclude</span><span class="s0">,</span>
    <span class="s1">customElement = </span><span class="s3">/\.ce\.vue$/</span><span class="s0">,</span>
    <span class="s1">reactivityTransform = </span><span class="s0">false</span>
  <span class="s1">} = rawOptions</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">filter = createFilter(include</span><span class="s0">, </span><span class="s1">exclude)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">customElementFilter = </span><span class="s0">typeof </span><span class="s1">customElement === </span><span class="s2">&quot;boolean&quot; </span><span class="s1">? () =&gt; customElement : createFilter(customElement)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">refTransformFilter = reactivityTransform === </span><span class="s0">false </span><span class="s1">? () =&gt; </span><span class="s0">false </span><span class="s1">: reactivityTransform === </span><span class="s0">true </span><span class="s1">? createFilter(</span><span class="s3">/\.(j|t)sx?$/</span><span class="s0">, </span><span class="s3">/node_modules/</span><span class="s1">) : createFilter(reactivityTransform)</span><span class="s0">;</span>
  <span class="s0">let </span><span class="s1">options = {</span>
    <span class="s1">isProduction: process.env.NODE_ENV === </span><span class="s2">&quot;production&quot;</span><span class="s0">,</span>
    <span class="s1">compiler: </span><span class="s0">null,</span>
    <span class="s4">// to be set in buildStart</span>
    <span class="s1">...rawOptions</span><span class="s0">,</span>
    <span class="s1">include</span><span class="s0">,</span>
    <span class="s1">exclude</span><span class="s0">,</span>
    <span class="s1">customElement</span><span class="s0">,</span>
    <span class="s1">reactivityTransform</span><span class="s0">,</span>
    <span class="s1">root: process.cwd()</span><span class="s0">,</span>
    <span class="s1">sourceMap: </span><span class="s0">true,</span>
    <span class="s1">cssDevSourcemap: </span><span class="s0">false,</span>
    <span class="s1">devToolsEnabled: process.env.NODE_ENV !== </span><span class="s2">&quot;production&quot;</span>
  <span class="s1">}</span><span class="s0">;</span>
  <span class="s0">return </span><span class="s1">{</span>
    <span class="s1">name: </span><span class="s2">&quot;vite:vue&quot;</span><span class="s0">,</span>
    <span class="s1">handleHotUpdate(ctx) {</span>
      <span class="s0">if </span><span class="s1">(!filter(ctx.file)) {</span>
        <span class="s0">return;</span>
      <span class="s1">}</span>
      <span class="s0">return </span><span class="s1">handleHotUpdate(ctx</span><span class="s0">, </span><span class="s1">options)</span><span class="s0">;</span>
    <span class="s1">}</span><span class="s0">,</span>
    <span class="s1">config(config) {</span>
      <span class="s0">return </span><span class="s1">{</span>
        <span class="s1">resolve: {</span>
          <span class="s1">dedupe: config.build?.ssr ? [] : [</span><span class="s2">&quot;vue&quot;</span><span class="s1">]</span>
        <span class="s1">}</span><span class="s0">,</span>
        <span class="s1">define: {</span>
          <span class="s1">__VUE_OPTIONS_API__: config.define?.__VUE_OPTIONS_API__ ?? </span><span class="s0">true,</span>
          <span class="s1">__VUE_PROD_DEVTOOLS__: config.define?.__VUE_PROD_DEVTOOLS__ ?? </span><span class="s0">false</span>
        <span class="s1">}</span><span class="s0">,</span>
        <span class="s1">ssr: {</span>
          <span class="s1">external: config.legacy?.buildSsrCjsExternalHeuristics ? [</span><span class="s2">&quot;vue&quot;</span><span class="s0">, </span><span class="s2">&quot;@vue/server-renderer&quot;</span><span class="s1">] : []</span>
        <span class="s1">}</span>
      <span class="s1">}</span><span class="s0">;</span>
    <span class="s1">}</span><span class="s0">,</span>
    <span class="s1">configResolved(config) {</span>
      <span class="s1">options = {</span>
        <span class="s1">...options</span><span class="s0">,</span>
        <span class="s1">root: config.root</span><span class="s0">,</span>
        <span class="s1">sourceMap: config.command === </span><span class="s2">&quot;build&quot; </span><span class="s1">? !!config.build.sourcemap : </span><span class="s0">true,</span>
        <span class="s1">cssDevSourcemap: config.css?.devSourcemap ?? </span><span class="s0">false,</span>
        <span class="s1">isProduction: config.isProduction</span><span class="s0">,</span>
        <span class="s1">devToolsEnabled: !!config.define.__VUE_PROD_DEVTOOLS__ || !config.isProduction</span>
      <span class="s1">}</span><span class="s0">;</span>
    <span class="s1">}</span><span class="s0">,</span>
    <span class="s1">configureServer(server) {</span>
      <span class="s1">options.devServer = server</span><span class="s0">;</span>
    <span class="s1">}</span><span class="s0">,</span>
    <span class="s1">buildStart() {</span>
      <span class="s1">options.compiler = options.compiler || resolveCompiler(options.root)</span><span class="s0">;</span>
    <span class="s1">}</span><span class="s0">,</span>
    <span class="s1">async resolveId(id) {</span>
      <span class="s0">if </span><span class="s1">(id === EXPORT_HELPER_ID) {</span>
        <span class="s0">return </span><span class="s1">id</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(parseVueRequest(id).query.vue) {</span>
        <span class="s0">return </span><span class="s1">id</span><span class="s0">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span><span class="s0">,</span>
    <span class="s1">load(id</span><span class="s0">, </span><span class="s1">opt) {</span>
      <span class="s0">const </span><span class="s1">ssr = opt?.ssr === </span><span class="s0">true;</span>
      <span class="s0">if </span><span class="s1">(id === EXPORT_HELPER_ID) {</span>
        <span class="s0">return </span><span class="s1">helperCode</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">const </span><span class="s1">{ filename</span><span class="s0">, </span><span class="s1">query } = parseVueRequest(id)</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(query.vue) {</span>
        <span class="s0">if </span><span class="s1">(query.src) {</span>
          <span class="s0">return </span><span class="s1">fs.readFileSync(filename</span><span class="s0">, </span><span class="s2">&quot;utf-8&quot;</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">const </span><span class="s1">descriptor = getDescriptor(filename</span><span class="s0">, </span><span class="s1">options)</span><span class="s0">;</span>
        <span class="s0">let </span><span class="s1">block</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(query.type === </span><span class="s2">&quot;script&quot;</span><span class="s1">) {</span>
          <span class="s1">block = getResolvedScript(descriptor</span><span class="s0">, </span><span class="s1">ssr)</span><span class="s0">;</span>
        <span class="s1">} </span><span class="s0">else if </span><span class="s1">(query.type === </span><span class="s2">&quot;template&quot;</span><span class="s1">) {</span>
          <span class="s1">block = descriptor.template</span><span class="s0">;</span>
        <span class="s1">} </span><span class="s0">else if </span><span class="s1">(query.type === </span><span class="s2">&quot;style&quot;</span><span class="s1">) {</span>
          <span class="s1">block = descriptor.styles[query.index]</span><span class="s0">;</span>
        <span class="s1">} </span><span class="s0">else if </span><span class="s1">(query.index != </span><span class="s0">null</span><span class="s1">) {</span>
          <span class="s1">block = descriptor.customBlocks[query.index]</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(block) {</span>
          <span class="s0">return </span><span class="s1">{</span>
            <span class="s1">code: block.content</span><span class="s0">,</span>
            <span class="s1">map: block.map</span>
          <span class="s1">}</span><span class="s0">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span><span class="s0">,</span>
    <span class="s1">transform(code</span><span class="s0">, </span><span class="s1">id</span><span class="s0">, </span><span class="s1">opt) {</span>
      <span class="s0">const </span><span class="s1">ssr = opt?.ssr === </span><span class="s0">true;</span>
      <span class="s0">const </span><span class="s1">{ filename</span><span class="s0">, </span><span class="s1">query } = parseVueRequest(id)</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(query.raw || query.url) {</span>
        <span class="s0">return;</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(!filter(filename) &amp;&amp; !query.vue) {</span>
        <span class="s0">if </span><span class="s1">(!query.vue &amp;&amp; refTransformFilter(filename) &amp;&amp; options.compiler.shouldTransformRef(code)) {</span>
          <span class="s0">return </span><span class="s1">options.compiler.transformRef(code</span><span class="s0">, </span><span class="s1">{</span>
            <span class="s1">filename</span><span class="s0">,</span>
            <span class="s1">sourceMap: </span><span class="s0">true</span>
          <span class="s1">})</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">return;</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(!query.vue) {</span>
        <span class="s0">return </span><span class="s1">transformMain(</span>
          <span class="s1">code</span><span class="s0">,</span>
          <span class="s1">filename</span><span class="s0">,</span>
          <span class="s1">options</span><span class="s0">,</span>
          <span class="s0">this,</span>
          <span class="s1">ssr</span><span class="s0">,</span>
          <span class="s1">customElementFilter(filename)</span>
        <span class="s1">)</span><span class="s0">;</span>
      <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
        <span class="s0">const </span><span class="s1">descriptor = query.src ? getSrcDescriptor(filename</span><span class="s0">, </span><span class="s1">query) : getDescriptor(filename</span><span class="s0">, </span><span class="s1">options)</span><span class="s0">;</span>
        <span class="s0">if </span><span class="s1">(query.type === </span><span class="s2">&quot;template&quot;</span><span class="s1">) {</span>
          <span class="s0">return </span><span class="s1">transformTemplateAsModule(code</span><span class="s0">, </span><span class="s1">descriptor</span><span class="s0">, </span><span class="s1">options</span><span class="s0">, this, </span><span class="s1">ssr)</span><span class="s0">;</span>
        <span class="s1">} </span><span class="s0">else if </span><span class="s1">(query.type === </span><span class="s2">&quot;style&quot;</span><span class="s1">) {</span>
          <span class="s0">return </span><span class="s1">transformStyle(</span>
            <span class="s1">code</span><span class="s0">,</span>
            <span class="s1">descriptor</span><span class="s0">,</span>
            <span class="s1">Number(query.index)</span><span class="s0">,</span>
            <span class="s1">options</span><span class="s0">,</span>
            <span class="s0">this,</span>
            <span class="s1">filename</span>
          <span class="s1">)</span><span class="s0">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">{ vuePlugin as </span><span class="s0">default, </span><span class="s1">parseVueRequest }</span><span class="s0">;</span>
</pre>
</body>
</html>