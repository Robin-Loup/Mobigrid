<html>
<head>
<title>vue.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
.s1 { color: #6a8759;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
vue.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span>
  <span class="s1">&quot;version&quot;</span><span class="s2">: </span><span class="s3">3</span><span class="s2">,</span>
  <span class="s1">&quot;sources&quot;</span><span class="s2">: </span><span class="s0">[</span><span class="s1">&quot;../../@vue/shared/dist/shared.esm-bundler.js&quot;</span><span class="s2">, </span><span class="s1">&quot;../../@vue/reactivity/dist/reactivity.esm-bundler.js&quot;</span><span class="s2">, </span><span class="s1">&quot;../../@vue/runtime-core/dist/runtime-core.esm-bundler.js&quot;</span><span class="s2">, </span><span class="s1">&quot;../../@vue/runtime-dom/dist/runtime-dom.esm-bundler.js&quot;</span><span class="s2">, </span><span class="s1">&quot;../../vue/dist/vue.runtime.esm-bundler.js&quot;</span><span class="s0">]</span><span class="s2">,</span>
  <span class="s1">&quot;sourcesContent&quot;</span><span class="s2">: </span><span class="s0">[</span><span class="s1">&quot;/**</span><span class="s2">\n </span><span class="s1">* Make a map and return a function for checking if a key</span><span class="s2">\n </span><span class="s1">* is in that map.</span><span class="s2">\n </span><span class="s1">* IMPORTANT: all calls of this function must be prefixed with</span><span class="s2">\n </span><span class="s1">* </span><span class="s2">\\</span><span class="s1">/</span><span class="s2">\\</span><span class="s1">*#</span><span class="s2">\\</span><span class="s1">_</span><span class="s2">\\</span><span class="s1">_PURE</span><span class="s2">\\</span><span class="s1">_</span><span class="s2">\\</span><span class="s1">_</span><span class="s2">\\</span><span class="s1">*</span><span class="s2">\\</span><span class="s1">/</span><span class="s2">\n </span><span class="s1">* So that rollup can tree-shake them if necessary.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function makeMap(str, expectsLowerCase) {</span><span class="s2">\n    </span><span class="s1">const map = Object.create(null);</span><span class="s2">\n    </span><span class="s1">const list = str.split(',');</span><span class="s2">\n    </span><span class="s1">for (let i = 0; i &lt; list.length; i++) {</span><span class="s2">\n        </span><span class="s1">map[list[i]] = true;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return expectsLowerCase ? val =&gt; !!map[val.toLowerCase()] : val =&gt; !!map[val];</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* dev only flag -&gt; name mapping</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const PatchFlagNames = {</span><span class="s2">\n    </span><span class="s1">[1 /* PatchFlags.TEXT */]: `TEXT`,</span><span class="s2">\n    </span><span class="s1">[2 /* PatchFlags.CLASS */]: `CLASS`,</span><span class="s2">\n    </span><span class="s1">[4 /* PatchFlags.STYLE */]: `STYLE`,</span><span class="s2">\n    </span><span class="s1">[8 /* PatchFlags.PROPS */]: `PROPS`,</span><span class="s2">\n    </span><span class="s1">[16 /* PatchFlags.FULL_PROPS */]: `FULL_PROPS`,</span><span class="s2">\n    </span><span class="s1">[32 /* PatchFlags.HYDRATE_EVENTS */]: `HYDRATE_EVENTS`,</span><span class="s2">\n    </span><span class="s1">[64 /* PatchFlags.STABLE_FRAGMENT */]: `STABLE_FRAGMENT`,</span><span class="s2">\n    </span><span class="s1">[128 /* PatchFlags.KEYED_FRAGMENT */]: `KEYED_FRAGMENT`,</span><span class="s2">\n    </span><span class="s1">[256 /* PatchFlags.UNKEYED_FRAGMENT */]: `UNKEYED_FRAGMENT`,</span><span class="s2">\n    </span><span class="s1">[512 /* PatchFlags.NEED_PATCH */]: `NEED_PATCH`,</span><span class="s2">\n    </span><span class="s1">[1024 /* PatchFlags.DYNAMIC_SLOTS */]: `DYNAMIC_SLOTS`,</span><span class="s2">\n    </span><span class="s1">[2048 /* PatchFlags.DEV_ROOT_FRAGMENT */]: `DEV_ROOT_FRAGMENT`,</span><span class="s2">\n    </span><span class="s1">[-1 /* PatchFlags.HOISTED */]: `HOISTED`,</span><span class="s2">\n    </span><span class="s1">[-2 /* PatchFlags.BAIL */]: `BAIL`</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Dev only</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const slotFlagsText = {</span><span class="s2">\n    </span><span class="s1">[1 /* SlotFlags.STABLE */]: 'STABLE',</span><span class="s2">\n    </span><span class="s1">[2 /* SlotFlags.DYNAMIC */]: 'DYNAMIC',</span><span class="s2">\n    </span><span class="s1">[3 /* SlotFlags.FORWARDED */]: 'FORWARDED'</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">const GLOBALS_WHITE_LISTED = 'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +</span><span class="s2">\n    </span><span class="s1">'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +</span><span class="s2">\n    </span><span class="s1">'Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt';</span><span class="s2">\n</span><span class="s1">const isGloballyWhitelisted = /*#__PURE__*/ makeMap(GLOBALS_WHITE_LISTED);</span><span class="s2">\n\n</span><span class="s1">const range = 2;</span><span class="s2">\n</span><span class="s1">function generateCodeFrame(source, start = 0, end = source.length) {</span><span class="s2">\n    </span><span class="s1">// Split the content into individual lines but capture the newline sequence</span><span class="s2">\n    </span><span class="s1">// that separated each line. This is important because the actual sequence is</span><span class="s2">\n    </span><span class="s1">// needed to properly take into account the full line length for offset</span><span class="s2">\n    </span><span class="s1">// comparison</span><span class="s2">\n    </span><span class="s1">let lines = source.split(/(</span><span class="s2">\\</span><span class="s1">r?</span><span class="s2">\\</span><span class="s1">n)/);</span><span class="s2">\n    </span><span class="s1">// Separate the lines and newline sequences into separate arrays for easier referencing</span><span class="s2">\n    </span><span class="s1">const newlineSequences = lines.filter((_, idx) =&gt; idx % 2 === 1);</span><span class="s2">\n    </span><span class="s1">lines = lines.filter((_, idx) =&gt; idx % 2 === 0);</span><span class="s2">\n    </span><span class="s1">let count = 0;</span><span class="s2">\n    </span><span class="s1">const res = [];</span><span class="s2">\n    </span><span class="s1">for (let i = 0; i &lt; lines.length; i++) {</span><span class="s2">\n        </span><span class="s1">count +=</span><span class="s2">\n            </span><span class="s1">lines[i].length +</span><span class="s2">\n                </span><span class="s1">((newlineSequences[i] &amp;&amp; newlineSequences[i].length) || 0);</span><span class="s2">\n        </span><span class="s1">if (count &gt;= start) {</span><span class="s2">\n            </span><span class="s1">for (let j = i - range; j &lt;= i + range || end &gt; count; j++) {</span><span class="s2">\n                </span><span class="s1">if (j &lt; 0 || j &gt;= lines.length)</span><span class="s2">\n                    </span><span class="s1">continue;</span><span class="s2">\n                </span><span class="s1">const line = j + 1;</span><span class="s2">\n                </span><span class="s1">res.push(`${line}${' '.repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);</span><span class="s2">\n                </span><span class="s1">const lineLength = lines[j].length;</span><span class="s2">\n                </span><span class="s1">const newLineSeqLength = (newlineSequences[j] &amp;&amp; newlineSequences[j].length) || 0;</span><span class="s2">\n                </span><span class="s1">if (j === i) {</span><span class="s2">\n                    </span><span class="s1">// push underline</span><span class="s2">\n                    </span><span class="s1">const pad = start - (count - (lineLength + newLineSeqLength));</span><span class="s2">\n                    </span><span class="s1">const length = Math.max(1, end &gt; count ? lineLength - pad : end - start);</span><span class="s2">\n                    </span><span class="s1">res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length));</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else if (j &gt; i) {</span><span class="s2">\n                    </span><span class="s1">if (end &gt; count) {</span><span class="s2">\n                        </span><span class="s1">const length = Math.max(Math.min(end - count, lineLength), 1);</span><span class="s2">\n                        </span><span class="s1">res.push(`   |  ` + '^'.repeat(length));</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">count += lineLength + newLineSeqLength;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">break;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return res.join('</span><span class="s2">\\</span><span class="s1">n');</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function normalizeStyle(value) {</span><span class="s2">\n    </span><span class="s1">if (isArray(value)) {</span><span class="s2">\n        </span><span class="s1">const res = {};</span><span class="s2">\n        </span><span class="s1">for (let i = 0; i &lt; value.length; i++) {</span><span class="s2">\n            </span><span class="s1">const item = value[i];</span><span class="s2">\n            </span><span class="s1">const normalized = isString(item)</span><span class="s2">\n                </span><span class="s1">? parseStringStyle(item)</span><span class="s2">\n                </span><span class="s1">: normalizeStyle(item);</span><span class="s2">\n            </span><span class="s1">if (normalized) {</span><span class="s2">\n                </span><span class="s1">for (const key in normalized) {</span><span class="s2">\n                    </span><span class="s1">res[key] = normalized[key];</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return res;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (isString(value)) {</span><span class="s2">\n        </span><span class="s1">return value;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (isObject(value)) {</span><span class="s2">\n        </span><span class="s1">return value;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">const listDelimiterRE = /;(?![^(]*</span><span class="s2">\\</span><span class="s1">))/g;</span><span class="s2">\n</span><span class="s1">const propertyDelimiterRE = /:([^]+)/;</span><span class="s2">\n</span><span class="s1">const styleCommentRE = /</span><span class="s2">\\</span><span class="s1">/</span><span class="s2">\\</span><span class="s1">*.*?</span><span class="s2">\\</span><span class="s1">*</span><span class="s2">\\</span><span class="s1">//gs;</span><span class="s2">\n</span><span class="s1">function parseStringStyle(cssText) {</span><span class="s2">\n    </span><span class="s1">const ret = {};</span><span class="s2">\n    </span><span class="s1">cssText</span><span class="s2">\n        </span><span class="s1">.replace(styleCommentRE, '')</span><span class="s2">\n        </span><span class="s1">.split(listDelimiterRE)</span><span class="s2">\n        </span><span class="s1">.forEach(item =&gt; {</span><span class="s2">\n        </span><span class="s1">if (item) {</span><span class="s2">\n            </span><span class="s1">const tmp = item.split(propertyDelimiterRE);</span><span class="s2">\n            </span><span class="s1">tmp.length &gt; 1 &amp;&amp; (ret[tmp[0].trim()] = tmp[1].trim());</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">return ret;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function stringifyStyle(styles) {</span><span class="s2">\n    </span><span class="s1">let ret = '';</span><span class="s2">\n    </span><span class="s1">if (!styles || isString(styles)) {</span><span class="s2">\n        </span><span class="s1">return ret;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">for (const key in styles) {</span><span class="s2">\n        </span><span class="s1">const value = styles[key];</span><span class="s2">\n        </span><span class="s1">const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);</span><span class="s2">\n        </span><span class="s1">if (isString(value) || typeof value === 'number') {</span><span class="s2">\n            </span><span class="s1">// only render valid values</span><span class="s2">\n            </span><span class="s1">ret += `${normalizedKey}:${value};`;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return ret;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function normalizeClass(value) {</span><span class="s2">\n    </span><span class="s1">let res = '';</span><span class="s2">\n    </span><span class="s1">if (isString(value)) {</span><span class="s2">\n        </span><span class="s1">res = value;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (isArray(value)) {</span><span class="s2">\n        </span><span class="s1">for (let i = 0; i &lt; value.length; i++) {</span><span class="s2">\n            </span><span class="s1">const normalized = normalizeClass(value[i]);</span><span class="s2">\n            </span><span class="s1">if (normalized) {</span><span class="s2">\n                </span><span class="s1">res += normalized + ' ';</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (isObject(value)) {</span><span class="s2">\n        </span><span class="s1">for (const name in value) {</span><span class="s2">\n            </span><span class="s1">if (value[name]) {</span><span class="s2">\n                </span><span class="s1">res += name + ' ';</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return res.trim();</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function normalizeProps(props) {</span><span class="s2">\n    </span><span class="s1">if (!props)</span><span class="s2">\n        </span><span class="s1">return null;</span><span class="s2">\n    </span><span class="s1">let { class: klass, style } = props;</span><span class="s2">\n    </span><span class="s1">if (klass &amp;&amp; !isString(klass)) {</span><span class="s2">\n        </span><span class="s1">props.class = normalizeClass(klass);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (style) {</span><span class="s2">\n        </span><span class="s1">props.style = normalizeStyle(style);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return props;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// These tag configs are shared between compiler-dom and runtime-dom, so they</span><span class="s2">\n</span><span class="s1">// https://developer.mozilla.org/en-US/docs/Web/HTML/Element</span><span class="s2">\n</span><span class="s1">const HTML_TAGS = 'html,body,base,head,link,meta,style,title,address,article,aside,footer,' +</span><span class="s2">\n    </span><span class="s1">'header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,' +</span><span class="s2">\n    </span><span class="s1">'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +</span><span class="s2">\n    </span><span class="s1">'data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,' +</span><span class="s2">\n    </span><span class="s1">'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +</span><span class="s2">\n    </span><span class="s1">'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +</span><span class="s2">\n    </span><span class="s1">'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +</span><span class="s2">\n    </span><span class="s1">'option,output,progress,select,textarea,details,dialog,menu,' +</span><span class="s2">\n    </span><span class="s1">'summary,template,blockquote,iframe,tfoot';</span><span class="s2">\n</span><span class="s1">// https://developer.mozilla.org/en-US/docs/Web/SVG/Element</span><span class="s2">\n</span><span class="s1">const SVG_TAGS = 'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +</span><span class="s2">\n    </span><span class="s1">'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +</span><span class="s2">\n    </span><span class="s1">'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +</span><span class="s2">\n    </span><span class="s1">'feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +</span><span class="s2">\n    </span><span class="s1">'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +</span><span class="s2">\n    </span><span class="s1">'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +</span><span class="s2">\n    </span><span class="s1">'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' +</span><span class="s2">\n    </span><span class="s1">'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +</span><span class="s2">\n    </span><span class="s1">'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +</span><span class="s2">\n    </span><span class="s1">'text,textPath,title,tspan,unknown,use,view';</span><span class="s2">\n</span><span class="s1">const VOID_TAGS = 'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr';</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Compiler only.</span><span class="s2">\n </span><span class="s1">* Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const isHTMLTag = /*#__PURE__*/ makeMap(HTML_TAGS);</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Compiler only.</span><span class="s2">\n </span><span class="s1">* Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const isSVGTag = /*#__PURE__*/ makeMap(SVG_TAGS);</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Compiler only.</span><span class="s2">\n </span><span class="s1">* Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const isVoidTag = /*#__PURE__*/ makeMap(VOID_TAGS);</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* On the client we only need to offer special cases for boolean attributes that</span><span class="s2">\n </span><span class="s1">* have different names from their corresponding dom properties:</span><span class="s2">\n </span><span class="s1">* - itemscope -&gt; N/A</span><span class="s2">\n </span><span class="s1">* - allowfullscreen -&gt; allowFullscreen</span><span class="s2">\n </span><span class="s1">* - formnovalidate -&gt; formNoValidate</span><span class="s2">\n </span><span class="s1">* - ismap -&gt; isMap</span><span class="s2">\n </span><span class="s1">* - nomodule -&gt; noModule</span><span class="s2">\n </span><span class="s1">* - novalidate -&gt; noValidate</span><span class="s2">\n </span><span class="s1">* - readonly -&gt; readOnly</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;</span><span class="s2">\n</span><span class="s1">const isSpecialBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs);</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* The full list is needed during SSR to produce the correct initial markup.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const isBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs +</span><span class="s2">\n    </span><span class="s1">`,async,autofocus,autoplay,controls,default,defer,disabled,hidden,` +</span><span class="s2">\n    </span><span class="s1">`loop,open,required,reversed,scoped,seamless,` +</span><span class="s2">\n    </span><span class="s1">`checked,muted,multiple,selected`);</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Boolean attributes should be included if the value is truthy or ''.</span><span class="s2">\n </span><span class="s1">* e.g. `&lt;select multiple&gt;` compiles to `{ multiple: '' }`</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function includeBooleanAttr(value) {</span><span class="s2">\n    </span><span class="s1">return !!value || value === '';</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">const unsafeAttrCharRE = /[&gt;/=</span><span class="s2">\&quot;</span><span class="s1">'</span><span class="s2">\\</span><span class="s1">u0009</span><span class="s2">\\</span><span class="s1">u000a</span><span class="s2">\\</span><span class="s1">u000c</span><span class="s2">\\</span><span class="s1">u0020]/;</span><span class="s2">\n</span><span class="s1">const attrValidationCache = {};</span><span class="s2">\n</span><span class="s1">function isSSRSafeAttrName(name) {</span><span class="s2">\n    </span><span class="s1">if (attrValidationCache.hasOwnProperty(name)) {</span><span class="s2">\n        </span><span class="s1">return attrValidationCache[name];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">const isUnsafe = unsafeAttrCharRE.test(name);</span><span class="s2">\n    </span><span class="s1">if (isUnsafe) {</span><span class="s2">\n        </span><span class="s1">console.error(`unsafe attribute name: ${name}`);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return (attrValidationCache[name] = !isUnsafe);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">const propsToAttrMap = {</span><span class="s2">\n    </span><span class="s1">acceptCharset: 'accept-charset',</span><span class="s2">\n    </span><span class="s1">className: 'class',</span><span class="s2">\n    </span><span class="s1">htmlFor: 'for',</span><span class="s2">\n    </span><span class="s1">httpEquiv: 'http-equiv'</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Known attributes, this is used for stringification of runtime static nodes</span><span class="s2">\n </span><span class="s1">* so that we don't stringify bindings that cannot be set from HTML.</span><span class="s2">\n </span><span class="s1">* Don't also forget to allow `data-*` and `aria-*`!</span><span class="s2">\n </span><span class="s1">* Generated from https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const isKnownHtmlAttr = /*#__PURE__*/ makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,` +</span><span class="s2">\n    </span><span class="s1">`autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,` +</span><span class="s2">\n    </span><span class="s1">`border,buffered,capture,challenge,charset,checked,cite,class,code,` +</span><span class="s2">\n    </span><span class="s1">`codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,` +</span><span class="s2">\n    </span><span class="s1">`coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,` +</span><span class="s2">\n    </span><span class="s1">`disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,` +</span><span class="s2">\n    </span><span class="s1">`formaction,formenctype,formmethod,formnovalidate,formtarget,headers,` +</span><span class="s2">\n    </span><span class="s1">`height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,` +</span><span class="s2">\n    </span><span class="s1">`ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,` +</span><span class="s2">\n    </span><span class="s1">`manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,` +</span><span class="s2">\n    </span><span class="s1">`open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,` +</span><span class="s2">\n    </span><span class="s1">`referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,` +</span><span class="s2">\n    </span><span class="s1">`selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,` +</span><span class="s2">\n    </span><span class="s1">`start,step,style,summary,tabindex,target,title,translate,type,usemap,` +</span><span class="s2">\n    </span><span class="s1">`value,width,wrap`);</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Generated from https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const isKnownSvgAttr = /*#__PURE__*/ makeMap(`xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,` +</span><span class="s2">\n    </span><span class="s1">`arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,` +</span><span class="s2">\n    </span><span class="s1">`baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,` +</span><span class="s2">\n    </span><span class="s1">`clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,` +</span><span class="s2">\n    </span><span class="s1">`color-interpolation-filters,color-profile,color-rendering,` +</span><span class="s2">\n    </span><span class="s1">`contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,` +</span><span class="s2">\n    </span><span class="s1">`descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,` +</span><span class="s2">\n    </span><span class="s1">`dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,` +</span><span class="s2">\n    </span><span class="s1">`fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,` +</span><span class="s2">\n    </span><span class="s1">`font-family,font-size,font-size-adjust,font-stretch,font-style,` +</span><span class="s2">\n    </span><span class="s1">`font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,` +</span><span class="s2">\n    </span><span class="s1">`glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,` +</span><span class="s2">\n    </span><span class="s1">`gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,` +</span><span class="s2">\n    </span><span class="s1">`horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,` +</span><span class="s2">\n    </span><span class="s1">`k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,` +</span><span class="s2">\n    </span><span class="s1">`lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,` +</span><span class="s2">\n    </span><span class="s1">`marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,` +</span><span class="s2">\n    </span><span class="s1">`mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,` +</span><span class="s2">\n    </span><span class="s1">`name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,` +</span><span class="s2">\n    </span><span class="s1">`overflow,overline-position,overline-thickness,panose-1,paint-order,path,` +</span><span class="s2">\n    </span><span class="s1">`pathLength,patternContentUnits,patternTransform,patternUnits,ping,` +</span><span class="s2">\n    </span><span class="s1">`pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,` +</span><span class="s2">\n    </span><span class="s1">`preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,` +</span><span class="s2">\n    </span><span class="s1">`rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,` +</span><span class="s2">\n    </span><span class="s1">`restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,` +</span><span class="s2">\n    </span><span class="s1">`specularConstant,specularExponent,speed,spreadMethod,startOffset,` +</span><span class="s2">\n    </span><span class="s1">`stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,` +</span><span class="s2">\n    </span><span class="s1">`strikethrough-position,strikethrough-thickness,string,stroke,` +</span><span class="s2">\n    </span><span class="s1">`stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,` +</span><span class="s2">\n    </span><span class="s1">`stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,` +</span><span class="s2">\n    </span><span class="s1">`systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,` +</span><span class="s2">\n    </span><span class="s1">`text-decoration,text-rendering,textLength,to,transform,transform-origin,` +</span><span class="s2">\n    </span><span class="s1">`type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,` +</span><span class="s2">\n    </span><span class="s1">`unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,` +</span><span class="s2">\n    </span><span class="s1">`v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,` +</span><span class="s2">\n    </span><span class="s1">`vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,` +</span><span class="s2">\n    </span><span class="s1">`writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,` +</span><span class="s2">\n    </span><span class="s1">`xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,` +</span><span class="s2">\n    </span><span class="s1">`xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`);</span><span class="s2">\n\n</span><span class="s1">const escapeRE = /[</span><span class="s2">\&quot;</span><span class="s1">'&amp;&lt;&gt;]/;</span><span class="s2">\n</span><span class="s1">function escapeHtml(string) {</span><span class="s2">\n    </span><span class="s1">const str = '' + string;</span><span class="s2">\n    </span><span class="s1">const match = escapeRE.exec(str);</span><span class="s2">\n    </span><span class="s1">if (!match) {</span><span class="s2">\n        </span><span class="s1">return str;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let html = '';</span><span class="s2">\n    </span><span class="s1">let escaped;</span><span class="s2">\n    </span><span class="s1">let index;</span><span class="s2">\n    </span><span class="s1">let lastIndex = 0;</span><span class="s2">\n    </span><span class="s1">for (index = match.index; index &lt; str.length; index++) {</span><span class="s2">\n        </span><span class="s1">switch (str.charCodeAt(index)) {</span><span class="s2">\n            </span><span class="s1">case 34: // </span><span class="s2">\&quot;\n                </span><span class="s1">escaped = '&amp;quot;';</span><span class="s2">\n                </span><span class="s1">break;</span><span class="s2">\n            </span><span class="s1">case 38: // &amp;</span><span class="s2">\n                </span><span class="s1">escaped = '&amp;amp;';</span><span class="s2">\n                </span><span class="s1">break;</span><span class="s2">\n            </span><span class="s1">case 39: // '</span><span class="s2">\n                </span><span class="s1">escaped = '&amp;#39;';</span><span class="s2">\n                </span><span class="s1">break;</span><span class="s2">\n            </span><span class="s1">case 60: // &lt;</span><span class="s2">\n                </span><span class="s1">escaped = '&amp;lt;';</span><span class="s2">\n                </span><span class="s1">break;</span><span class="s2">\n            </span><span class="s1">case 62: // &gt;</span><span class="s2">\n                </span><span class="s1">escaped = '&amp;gt;';</span><span class="s2">\n                </span><span class="s1">break;</span><span class="s2">\n            </span><span class="s1">default:</span><span class="s2">\n                </span><span class="s1">continue;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (lastIndex !== index) {</span><span class="s2">\n            </span><span class="s1">html += str.slice(lastIndex, index);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">lastIndex = index + 1;</span><span class="s2">\n        </span><span class="s1">html += escaped;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return lastIndex !== index ? html + str.slice(lastIndex, index) : html;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// https://www.w3.org/TR/html52/syntax.html#comments</span><span class="s2">\n</span><span class="s1">const commentStripRE = /^-?&gt;|&lt;!--|--&gt;|--!&gt;|&lt;!-$/g;</span><span class="s2">\n</span><span class="s1">function escapeHtmlComment(src) {</span><span class="s2">\n    </span><span class="s1">return src.replace(commentStripRE, '');</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function looseCompareArrays(a, b) {</span><span class="s2">\n    </span><span class="s1">if (a.length !== b.length)</span><span class="s2">\n        </span><span class="s1">return false;</span><span class="s2">\n    </span><span class="s1">let equal = true;</span><span class="s2">\n    </span><span class="s1">for (let i = 0; equal &amp;&amp; i &lt; a.length; i++) {</span><span class="s2">\n        </span><span class="s1">equal = looseEqual(a[i], b[i]);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return equal;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function looseEqual(a, b) {</span><span class="s2">\n    </span><span class="s1">if (a === b)</span><span class="s2">\n        </span><span class="s1">return true;</span><span class="s2">\n    </span><span class="s1">let aValidType = isDate(a);</span><span class="s2">\n    </span><span class="s1">let bValidType = isDate(b);</span><span class="s2">\n    </span><span class="s1">if (aValidType || bValidType) {</span><span class="s2">\n        </span><span class="s1">return aValidType &amp;&amp; bValidType ? a.getTime() === b.getTime() : false;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">aValidType = isSymbol(a);</span><span class="s2">\n    </span><span class="s1">bValidType = isSymbol(b);</span><span class="s2">\n    </span><span class="s1">if (aValidType || bValidType) {</span><span class="s2">\n        </span><span class="s1">return a === b;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">aValidType = isArray(a);</span><span class="s2">\n    </span><span class="s1">bValidType = isArray(b);</span><span class="s2">\n    </span><span class="s1">if (aValidType || bValidType) {</span><span class="s2">\n        </span><span class="s1">return aValidType &amp;&amp; bValidType ? looseCompareArrays(a, b) : false;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">aValidType = isObject(a);</span><span class="s2">\n    </span><span class="s1">bValidType = isObject(b);</span><span class="s2">\n    </span><span class="s1">if (aValidType || bValidType) {</span><span class="s2">\n        </span><span class="s1">/* istanbul ignore if: this if will probably never be called */</span><span class="s2">\n        </span><span class="s1">if (!aValidType || !bValidType) {</span><span class="s2">\n            </span><span class="s1">return false;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">const aKeysCount = Object.keys(a).length;</span><span class="s2">\n        </span><span class="s1">const bKeysCount = Object.keys(b).length;</span><span class="s2">\n        </span><span class="s1">if (aKeysCount !== bKeysCount) {</span><span class="s2">\n            </span><span class="s1">return false;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">for (const key in a) {</span><span class="s2">\n            </span><span class="s1">const aHasKey = a.hasOwnProperty(key);</span><span class="s2">\n            </span><span class="s1">const bHasKey = b.hasOwnProperty(key);</span><span class="s2">\n            </span><span class="s1">if ((aHasKey &amp;&amp; !bHasKey) ||</span><span class="s2">\n                </span><span class="s1">(!aHasKey &amp;&amp; bHasKey) ||</span><span class="s2">\n                </span><span class="s1">!looseEqual(a[key], b[key])) {</span><span class="s2">\n                </span><span class="s1">return false;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return String(a) === String(b);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function looseIndexOf(arr, val) {</span><span class="s2">\n    </span><span class="s1">return arr.findIndex(item =&gt; looseEqual(item, val));</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* For converting {{ interpolation }} values to displayed strings.</span><span class="s2">\n </span><span class="s1">* @private</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const toDisplayString = (val) =&gt; {</span><span class="s2">\n    </span><span class="s1">return isString(val)</span><span class="s2">\n        </span><span class="s1">? val</span><span class="s2">\n        </span><span class="s1">: val == null</span><span class="s2">\n            </span><span class="s1">? ''</span><span class="s2">\n            </span><span class="s1">: isArray(val) ||</span><span class="s2">\n                </span><span class="s1">(isObject(val) &amp;&amp;</span><span class="s2">\n                    </span><span class="s1">(val.toString === objectToString || !isFunction(val.toString)))</span><span class="s2">\n                </span><span class="s1">? JSON.stringify(val, replacer, 2)</span><span class="s2">\n                </span><span class="s1">: String(val);</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">const replacer = (_key, val) =&gt; {</span><span class="s2">\n    </span><span class="s1">// can't use isRef here since @vue/shared has no deps</span><span class="s2">\n    </span><span class="s1">if (val &amp;&amp; val.__v_isRef) {</span><span class="s2">\n        </span><span class="s1">return replacer(_key, val.value);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (isMap(val)) {</span><span class="s2">\n        </span><span class="s1">return {</span><span class="s2">\n            </span><span class="s1">[`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val]) =&gt; {</span><span class="s2">\n                </span><span class="s1">entries[`${key} =&gt;`] = val;</span><span class="s2">\n                </span><span class="s1">return entries;</span><span class="s2">\n            </span><span class="s1">}, {})</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (isSet(val)) {</span><span class="s2">\n        </span><span class="s1">return {</span><span class="s2">\n            </span><span class="s1">[`Set(${val.size})`]: [...val.values()]</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (isObject(val) &amp;&amp; !isArray(val) &amp;&amp; !isPlainObject(val)) {</span><span class="s2">\n        </span><span class="s1">return String(val);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return val;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">const EMPTY_OBJ = (process.env.NODE_ENV !== 'production')</span><span class="s2">\n    </span><span class="s1">? Object.freeze({})</span><span class="s2">\n    </span><span class="s1">: {};</span><span class="s2">\n</span><span class="s1">const EMPTY_ARR = (process.env.NODE_ENV !== 'production') ? Object.freeze([]) : [];</span><span class="s2">\n</span><span class="s1">const NOOP = () =&gt; { };</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Always return false.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const NO = () =&gt; false;</span><span class="s2">\n</span><span class="s1">const onRE = /^on[^a-z]/;</span><span class="s2">\n</span><span class="s1">const isOn = (key) =&gt; onRE.test(key);</span><span class="s2">\n</span><span class="s1">const isModelListener = (key) =&gt; key.startsWith('onUpdate:');</span><span class="s2">\n</span><span class="s1">const extend = Object.assign;</span><span class="s2">\n</span><span class="s1">const remove = (arr, el) =&gt; {</span><span class="s2">\n    </span><span class="s1">const i = arr.indexOf(el);</span><span class="s2">\n    </span><span class="s1">if (i &gt; -1) {</span><span class="s2">\n        </span><span class="s1">arr.splice(i, 1);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">const hasOwnProperty = Object.prototype.hasOwnProperty;</span><span class="s2">\n</span><span class="s1">const hasOwn = (val, key) =&gt; hasOwnProperty.call(val, key);</span><span class="s2">\n</span><span class="s1">const isArray = Array.isArray;</span><span class="s2">\n</span><span class="s1">const isMap = (val) =&gt; toTypeString(val) === '[object Map]';</span><span class="s2">\n</span><span class="s1">const isSet = (val) =&gt; toTypeString(val) === '[object Set]';</span><span class="s2">\n</span><span class="s1">const isDate = (val) =&gt; toTypeString(val) === '[object Date]';</span><span class="s2">\n</span><span class="s1">const isRegExp = (val) =&gt; toTypeString(val) === '[object RegExp]';</span><span class="s2">\n</span><span class="s1">const isFunction = (val) =&gt; typeof val === 'function';</span><span class="s2">\n</span><span class="s1">const isString = (val) =&gt; typeof val === 'string';</span><span class="s2">\n</span><span class="s1">const isSymbol = (val) =&gt; typeof val === 'symbol';</span><span class="s2">\n</span><span class="s1">const isObject = (val) =&gt; val !== null &amp;&amp; typeof val === 'object';</span><span class="s2">\n</span><span class="s1">const isPromise = (val) =&gt; {</span><span class="s2">\n    </span><span class="s1">return isObject(val) &amp;&amp; isFunction(val.then) &amp;&amp; isFunction(val.catch);</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">const objectToString = Object.prototype.toString;</span><span class="s2">\n</span><span class="s1">const toTypeString = (value) =&gt; objectToString.call(value);</span><span class="s2">\n</span><span class="s1">const toRawType = (value) =&gt; {</span><span class="s2">\n    </span><span class="s1">// extract </span><span class="s2">\&quot;</span><span class="s1">RawType</span><span class="s2">\&quot; </span><span class="s1">from strings like </span><span class="s2">\&quot;</span><span class="s1">[object RawType]</span><span class="s2">\&quot;\n    </span><span class="s1">return toTypeString(value).slice(8, -1);</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">const isPlainObject = (val) =&gt; toTypeString(val) === '[object Object]';</span><span class="s2">\n</span><span class="s1">const isIntegerKey = (key) =&gt; isString(key) &amp;&amp;</span><span class="s2">\n    </span><span class="s1">key !== 'NaN' &amp;&amp;</span><span class="s2">\n    </span><span class="s1">key[0] !== '-' &amp;&amp;</span><span class="s2">\n    </span><span class="s1">'' + parseInt(key, 10) === key;</span><span class="s2">\n</span><span class="s1">const isReservedProp = /*#__PURE__*/ makeMap(</span><span class="s2">\n</span><span class="s1">// the leading comma is intentional so empty string </span><span class="s2">\&quot;\&quot; </span><span class="s1">is also included</span><span class="s2">\n</span><span class="s1">',key,ref,ref_for,ref_key,' +</span><span class="s2">\n    </span><span class="s1">'onVnodeBeforeMount,onVnodeMounted,' +</span><span class="s2">\n    </span><span class="s1">'onVnodeBeforeUpdate,onVnodeUpdated,' +</span><span class="s2">\n    </span><span class="s1">'onVnodeBeforeUnmount,onVnodeUnmounted');</span><span class="s2">\n</span><span class="s1">const isBuiltInDirective = /*#__PURE__*/ makeMap('bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo');</span><span class="s2">\n</span><span class="s1">const cacheStringFunction = (fn) =&gt; {</span><span class="s2">\n    </span><span class="s1">const cache = Object.create(null);</span><span class="s2">\n    </span><span class="s1">return ((str) =&gt; {</span><span class="s2">\n        </span><span class="s1">const hit = cache[str];</span><span class="s2">\n        </span><span class="s1">return hit || (cache[str] = fn(str));</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">const camelizeRE = /-(</span><span class="s2">\\</span><span class="s1">w)/g;</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* @private</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const camelize = cacheStringFunction((str) =&gt; {</span><span class="s2">\n    </span><span class="s1">return str.replace(camelizeRE, (_, c) =&gt; (c ? c.toUpperCase() : ''));</span><span class="s2">\n</span><span class="s1">});</span><span class="s2">\n</span><span class="s1">const hyphenateRE = /</span><span class="s2">\\</span><span class="s1">B([A-Z])/g;</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* @private</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const hyphenate = cacheStringFunction((str) =&gt; str.replace(hyphenateRE, '-$1').toLowerCase());</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* @private</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const capitalize = cacheStringFunction((str) =&gt; str.charAt(0).toUpperCase() + str.slice(1));</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* @private</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const toHandlerKey = cacheStringFunction((str) =&gt; str ? `on${capitalize(str)}` : ``);</span><span class="s2">\n</span><span class="s1">// compare whether a value has changed, accounting for NaN.</span><span class="s2">\n</span><span class="s1">const hasChanged = (value, oldValue) =&gt; !Object.is(value, oldValue);</span><span class="s2">\n</span><span class="s1">const invokeArrayFns = (fns, arg) =&gt; {</span><span class="s2">\n    </span><span class="s1">for (let i = 0; i &lt; fns.length; i++) {</span><span class="s2">\n        </span><span class="s1">fns[i](arg);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">const def = (obj, key, value) =&gt; {</span><span class="s2">\n    </span><span class="s1">Object.defineProperty(obj, key, {</span><span class="s2">\n        </span><span class="s1">configurable: true,</span><span class="s2">\n        </span><span class="s1">enumerable: false,</span><span class="s2">\n        </span><span class="s1">value</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* </span><span class="s2">\&quot;</span><span class="s1">123-foo</span><span class="s2">\&quot; </span><span class="s1">will be parsed to 123</span><span class="s2">\n </span><span class="s1">* This is used for the .number modifier in v-model</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const looseToNumber = (val) =&gt; {</span><span class="s2">\n    </span><span class="s1">const n = parseFloat(val);</span><span class="s2">\n    </span><span class="s1">return isNaN(n) ? val : n;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Only conerces number-like strings</span><span class="s2">\n </span><span class="s1">* </span><span class="s2">\&quot;</span><span class="s1">123-foo</span><span class="s2">\&quot; </span><span class="s1">will be returned as-is</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const toNumber = (val) =&gt; {</span><span class="s2">\n    </span><span class="s1">const n = isString(val) ? Number(val) : NaN;</span><span class="s2">\n    </span><span class="s1">return isNaN(n) ? val : n;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">let _globalThis;</span><span class="s2">\n</span><span class="s1">const getGlobalThis = () =&gt; {</span><span class="s2">\n    </span><span class="s1">return (_globalThis ||</span><span class="s2">\n        </span><span class="s1">(_globalThis =</span><span class="s2">\n            </span><span class="s1">typeof globalThis !== 'undefined'</span><span class="s2">\n                </span><span class="s1">? globalThis</span><span class="s2">\n                </span><span class="s1">: typeof self !== 'undefined'</span><span class="s2">\n                    </span><span class="s1">? self</span><span class="s2">\n                    </span><span class="s1">: typeof window !== 'undefined'</span><span class="s2">\n                        </span><span class="s1">? window</span><span class="s2">\n                        </span><span class="s1">: typeof global !== 'undefined'</span><span class="s2">\n                            </span><span class="s1">? global</span><span class="s2">\n                            </span><span class="s1">: {}));</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">const identRE = /^[_$a-zA-Z</span><span class="s2">\\</span><span class="s1">xA0-</span><span class="s2">\\</span><span class="s1">uFFFF][_$a-zA-Z0-9</span><span class="s2">\\</span><span class="s1">xA0-</span><span class="s2">\\</span><span class="s1">uFFFF]*$/;</span><span class="s2">\n</span><span class="s1">function genPropsAccessExp(name) {</span><span class="s2">\n    </span><span class="s1">return identRE.test(name)</span><span class="s2">\n        </span><span class="s1">? `__props.${name}`</span><span class="s2">\n        </span><span class="s1">: `__props[${JSON.stringify(name)}]`;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">export { EMPTY_ARR, EMPTY_OBJ, NO, NOOP, PatchFlagNames, camelize, capitalize, def, escapeHtml, escapeHtmlComment, extend, genPropsAccessExp, generateCodeFrame, getGlobalThis, hasChanged, hasOwn, hyphenate, includeBooleanAttr, invokeArrayFns, isArray, isBooleanAttr, isBuiltInDirective, isDate, isFunction, isGloballyWhitelisted, isHTMLTag, isIntegerKey, isKnownHtmlAttr, isKnownSvgAttr, isMap, isModelListener, isObject, isOn, isPlainObject, isPromise, isRegExp, isReservedProp, isSSRSafeAttrName, isSVGTag, isSet, isSpecialBooleanAttr, isString, isSymbol, isVoidTag, looseEqual, looseIndexOf, looseToNumber, makeMap, normalizeClass, normalizeProps, normalizeStyle, objectToString, parseStringStyle, propsToAttrMap, remove, slotFlagsText, stringifyStyle, toDisplayString, toHandlerKey, toNumber, toRawType, toTypeString };</span><span class="s2">\n</span><span class="s1">&quot;</span><span class="s2">, </span><span class="s1">&quot;import { extend, isArray, isMap, isIntegerKey, hasOwn, isSymbol, isObject, hasChanged, makeMap, capitalize, toRawType, def, isFunction, NOOP } from '@vue/shared';</span><span class="s2">\n\n</span><span class="s1">function warn(msg, ...args) {</span><span class="s2">\n    </span><span class="s1">console.warn(`[Vue warn] ${msg}`, ...args);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">let activeEffectScope;</span><span class="s2">\n</span><span class="s1">class EffectScope {</span><span class="s2">\n    </span><span class="s1">constructor(detached = false) {</span><span class="s2">\n        </span><span class="s1">this.detached = detached;</span><span class="s2">\n        </span><span class="s1">/**</span><span class="s2">\n         </span><span class="s1">* @internal</span><span class="s2">\n         </span><span class="s1">*/</span><span class="s2">\n        </span><span class="s1">this._active = true;</span><span class="s2">\n        </span><span class="s1">/**</span><span class="s2">\n         </span><span class="s1">* @internal</span><span class="s2">\n         </span><span class="s1">*/</span><span class="s2">\n        </span><span class="s1">this.effects = [];</span><span class="s2">\n        </span><span class="s1">/**</span><span class="s2">\n         </span><span class="s1">* @internal</span><span class="s2">\n         </span><span class="s1">*/</span><span class="s2">\n        </span><span class="s1">this.cleanups = [];</span><span class="s2">\n        </span><span class="s1">this.parent = activeEffectScope;</span><span class="s2">\n        </span><span class="s1">if (!detached &amp;&amp; activeEffectScope) {</span><span class="s2">\n            </span><span class="s1">this.index =</span><span class="s2">\n                </span><span class="s1">(activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">get active() {</span><span class="s2">\n        </span><span class="s1">return this._active;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">run(fn) {</span><span class="s2">\n        </span><span class="s1">if (this._active) {</span><span class="s2">\n            </span><span class="s1">const currentEffectScope = activeEffectScope;</span><span class="s2">\n            </span><span class="s1">try {</span><span class="s2">\n                </span><span class="s1">activeEffectScope = this;</span><span class="s2">\n                </span><span class="s1">return fn();</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">finally {</span><span class="s2">\n                </span><span class="s1">activeEffectScope = currentEffectScope;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n            </span><span class="s1">warn(`cannot run an inactive effect scope.`);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">/**</span><span class="s2">\n     </span><span class="s1">* This should only be called on non-detached scopes</span><span class="s2">\n     </span><span class="s1">* @internal</span><span class="s2">\n     </span><span class="s1">*/</span><span class="s2">\n    </span><span class="s1">on() {</span><span class="s2">\n        </span><span class="s1">activeEffectScope = this;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">/**</span><span class="s2">\n     </span><span class="s1">* This should only be called on non-detached scopes</span><span class="s2">\n     </span><span class="s1">* @internal</span><span class="s2">\n     </span><span class="s1">*/</span><span class="s2">\n    </span><span class="s1">off() {</span><span class="s2">\n        </span><span class="s1">activeEffectScope = this.parent;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">stop(fromParent) {</span><span class="s2">\n        </span><span class="s1">if (this._active) {</span><span class="s2">\n            </span><span class="s1">let i, l;</span><span class="s2">\n            </span><span class="s1">for (i = 0, l = this.effects.length; i &lt; l; i++) {</span><span class="s2">\n                </span><span class="s1">this.effects[i].stop();</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">for (i = 0, l = this.cleanups.length; i &lt; l; i++) {</span><span class="s2">\n                </span><span class="s1">this.cleanups[i]();</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">if (this.scopes) {</span><span class="s2">\n                </span><span class="s1">for (i = 0, l = this.scopes.length; i &lt; l; i++) {</span><span class="s2">\n                    </span><span class="s1">this.scopes[i].stop(true);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">// nested scope, dereference from parent to avoid memory leaks</span><span class="s2">\n            </span><span class="s1">if (!this.detached &amp;&amp; this.parent &amp;&amp; !fromParent) {</span><span class="s2">\n                </span><span class="s1">// optimized O(1) removal</span><span class="s2">\n                </span><span class="s1">const last = this.parent.scopes.pop();</span><span class="s2">\n                </span><span class="s1">if (last &amp;&amp; last !== this) {</span><span class="s2">\n                    </span><span class="s1">this.parent.scopes[this.index] = last;</span><span class="s2">\n                    </span><span class="s1">last.index = this.index;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">this.parent = undefined;</span><span class="s2">\n            </span><span class="s1">this._active = false;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function effectScope(detached) {</span><span class="s2">\n    </span><span class="s1">return new EffectScope(detached);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function recordEffectScope(effect, scope = activeEffectScope) {</span><span class="s2">\n    </span><span class="s1">if (scope &amp;&amp; scope.active) {</span><span class="s2">\n        </span><span class="s1">scope.effects.push(effect);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getCurrentScope() {</span><span class="s2">\n    </span><span class="s1">return activeEffectScope;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function onScopeDispose(fn) {</span><span class="s2">\n    </span><span class="s1">if (activeEffectScope) {</span><span class="s2">\n        </span><span class="s1">activeEffectScope.cleanups.push(fn);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n        </span><span class="s1">warn(`onScopeDispose() is called when there is no active effect scope` +</span><span class="s2">\n            </span><span class="s1">` to be associated with.`);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">const createDep = (effects) =&gt; {</span><span class="s2">\n    </span><span class="s1">const dep = new Set(effects);</span><span class="s2">\n    </span><span class="s1">dep.w = 0;</span><span class="s2">\n    </span><span class="s1">dep.n = 0;</span><span class="s2">\n    </span><span class="s1">return dep;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">const wasTracked = (dep) =&gt; (dep.w &amp; trackOpBit) &gt; 0;</span><span class="s2">\n</span><span class="s1">const newTracked = (dep) =&gt; (dep.n &amp; trackOpBit) &gt; 0;</span><span class="s2">\n</span><span class="s1">const initDepMarkers = ({ deps }) =&gt; {</span><span class="s2">\n    </span><span class="s1">if (deps.length) {</span><span class="s2">\n        </span><span class="s1">for (let i = 0; i &lt; deps.length; i++) {</span><span class="s2">\n            </span><span class="s1">deps[i].w |= trackOpBit; // set was tracked</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">const finalizeDepMarkers = (effect) =&gt; {</span><span class="s2">\n    </span><span class="s1">const { deps } = effect;</span><span class="s2">\n    </span><span class="s1">if (deps.length) {</span><span class="s2">\n        </span><span class="s1">let ptr = 0;</span><span class="s2">\n        </span><span class="s1">for (let i = 0; i &lt; deps.length; i++) {</span><span class="s2">\n            </span><span class="s1">const dep = deps[i];</span><span class="s2">\n            </span><span class="s1">if (wasTracked(dep) &amp;&amp; !newTracked(dep)) {</span><span class="s2">\n                </span><span class="s1">dep.delete(effect);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">deps[ptr++] = dep;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">// clear bits</span><span class="s2">\n            </span><span class="s1">dep.w &amp;= ~trackOpBit;</span><span class="s2">\n            </span><span class="s1">dep.n &amp;= ~trackOpBit;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">deps.length = ptr;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">const targetMap = new WeakMap();</span><span class="s2">\n</span><span class="s1">// The number of effects currently being tracked recursively.</span><span class="s2">\n</span><span class="s1">let effectTrackDepth = 0;</span><span class="s2">\n</span><span class="s1">let trackOpBit = 1;</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* The bitwise track markers support at most 30 levels of recursion.</span><span class="s2">\n </span><span class="s1">* This value is chosen to enable modern JS engines to use a SMI on all platforms.</span><span class="s2">\n </span><span class="s1">* When recursion depth is greater, fall back to using a full cleanup.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const maxMarkerBits = 30;</span><span class="s2">\n</span><span class="s1">let activeEffect;</span><span class="s2">\n</span><span class="s1">const ITERATE_KEY = Symbol((process.env.NODE_ENV !== 'production') ? 'iterate' : '');</span><span class="s2">\n</span><span class="s1">const MAP_KEY_ITERATE_KEY = Symbol((process.env.NODE_ENV !== 'production') ? 'Map key iterate' : '');</span><span class="s2">\n</span><span class="s1">class ReactiveEffect {</span><span class="s2">\n    </span><span class="s1">constructor(fn, scheduler = null, scope) {</span><span class="s2">\n        </span><span class="s1">this.fn = fn;</span><span class="s2">\n        </span><span class="s1">this.scheduler = scheduler;</span><span class="s2">\n        </span><span class="s1">this.active = true;</span><span class="s2">\n        </span><span class="s1">this.deps = [];</span><span class="s2">\n        </span><span class="s1">this.parent = undefined;</span><span class="s2">\n        </span><span class="s1">recordEffectScope(this, scope);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">run() {</span><span class="s2">\n        </span><span class="s1">if (!this.active) {</span><span class="s2">\n            </span><span class="s1">return this.fn();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">let parent = activeEffect;</span><span class="s2">\n        </span><span class="s1">let lastShouldTrack = shouldTrack;</span><span class="s2">\n        </span><span class="s1">while (parent) {</span><span class="s2">\n            </span><span class="s1">if (parent === this) {</span><span class="s2">\n                </span><span class="s1">return;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">parent = parent.parent;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">try {</span><span class="s2">\n            </span><span class="s1">this.parent = activeEffect;</span><span class="s2">\n            </span><span class="s1">activeEffect = this;</span><span class="s2">\n            </span><span class="s1">shouldTrack = true;</span><span class="s2">\n            </span><span class="s1">trackOpBit = 1 &lt;&lt; ++effectTrackDepth;</span><span class="s2">\n            </span><span class="s1">if (effectTrackDepth &lt;= maxMarkerBits) {</span><span class="s2">\n                </span><span class="s1">initDepMarkers(this);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">cleanupEffect(this);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">return this.fn();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">finally {</span><span class="s2">\n            </span><span class="s1">if (effectTrackDepth &lt;= maxMarkerBits) {</span><span class="s2">\n                </span><span class="s1">finalizeDepMarkers(this);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">trackOpBit = 1 &lt;&lt; --effectTrackDepth;</span><span class="s2">\n            </span><span class="s1">activeEffect = this.parent;</span><span class="s2">\n            </span><span class="s1">shouldTrack = lastShouldTrack;</span><span class="s2">\n            </span><span class="s1">this.parent = undefined;</span><span class="s2">\n            </span><span class="s1">if (this.deferStop) {</span><span class="s2">\n                </span><span class="s1">this.stop();</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">stop() {</span><span class="s2">\n        </span><span class="s1">// stopped while running itself - defer the cleanup</span><span class="s2">\n        </span><span class="s1">if (activeEffect === this) {</span><span class="s2">\n            </span><span class="s1">this.deferStop = true;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (this.active) {</span><span class="s2">\n            </span><span class="s1">cleanupEffect(this);</span><span class="s2">\n            </span><span class="s1">if (this.onStop) {</span><span class="s2">\n                </span><span class="s1">this.onStop();</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">this.active = false;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function cleanupEffect(effect) {</span><span class="s2">\n    </span><span class="s1">const { deps } = effect;</span><span class="s2">\n    </span><span class="s1">if (deps.length) {</span><span class="s2">\n        </span><span class="s1">for (let i = 0; i &lt; deps.length; i++) {</span><span class="s2">\n            </span><span class="s1">deps[i].delete(effect);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">deps.length = 0;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function effect(fn, options) {</span><span class="s2">\n    </span><span class="s1">if (fn.effect) {</span><span class="s2">\n        </span><span class="s1">fn = fn.effect.fn;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">const _effect = new ReactiveEffect(fn);</span><span class="s2">\n    </span><span class="s1">if (options) {</span><span class="s2">\n        </span><span class="s1">extend(_effect, options);</span><span class="s2">\n        </span><span class="s1">if (options.scope)</span><span class="s2">\n            </span><span class="s1">recordEffectScope(_effect, options.scope);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (!options || !options.lazy) {</span><span class="s2">\n        </span><span class="s1">_effect.run();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">const runner = _effect.run.bind(_effect);</span><span class="s2">\n    </span><span class="s1">runner.effect = _effect;</span><span class="s2">\n    </span><span class="s1">return runner;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function stop(runner) {</span><span class="s2">\n    </span><span class="s1">runner.effect.stop();</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">let shouldTrack = true;</span><span class="s2">\n</span><span class="s1">const trackStack = [];</span><span class="s2">\n</span><span class="s1">function pauseTracking() {</span><span class="s2">\n    </span><span class="s1">trackStack.push(shouldTrack);</span><span class="s2">\n    </span><span class="s1">shouldTrack = false;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function enableTracking() {</span><span class="s2">\n    </span><span class="s1">trackStack.push(shouldTrack);</span><span class="s2">\n    </span><span class="s1">shouldTrack = true;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function resetTracking() {</span><span class="s2">\n    </span><span class="s1">const last = trackStack.pop();</span><span class="s2">\n    </span><span class="s1">shouldTrack = last === undefined ? true : last;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function track(target, type, key) {</span><span class="s2">\n    </span><span class="s1">if (shouldTrack &amp;&amp; activeEffect) {</span><span class="s2">\n        </span><span class="s1">let depsMap = targetMap.get(target);</span><span class="s2">\n        </span><span class="s1">if (!depsMap) {</span><span class="s2">\n            </span><span class="s1">targetMap.set(target, (depsMap = new Map()));</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">let dep = depsMap.get(key);</span><span class="s2">\n        </span><span class="s1">if (!dep) {</span><span class="s2">\n            </span><span class="s1">depsMap.set(key, (dep = createDep()));</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">const eventInfo = (process.env.NODE_ENV !== 'production')</span><span class="s2">\n            </span><span class="s1">? { effect: activeEffect, target, type, key }</span><span class="s2">\n            </span><span class="s1">: undefined;</span><span class="s2">\n        </span><span class="s1">trackEffects(dep, eventInfo);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function trackEffects(dep, debuggerEventExtraInfo) {</span><span class="s2">\n    </span><span class="s1">let shouldTrack = false;</span><span class="s2">\n    </span><span class="s1">if (effectTrackDepth &lt;= maxMarkerBits) {</span><span class="s2">\n        </span><span class="s1">if (!newTracked(dep)) {</span><span class="s2">\n            </span><span class="s1">dep.n |= trackOpBit; // set newly tracked</span><span class="s2">\n            </span><span class="s1">shouldTrack = !wasTracked(dep);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">// Full cleanup mode.</span><span class="s2">\n        </span><span class="s1">shouldTrack = !dep.has(activeEffect);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (shouldTrack) {</span><span class="s2">\n        </span><span class="s1">dep.add(activeEffect);</span><span class="s2">\n        </span><span class="s1">activeEffect.deps.push(dep);</span><span class="s2">\n        </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp; activeEffect.onTrack) {</span><span class="s2">\n            </span><span class="s1">activeEffect.onTrack(Object.assign({ effect: activeEffect }, debuggerEventExtraInfo));</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function trigger(target, type, key, newValue, oldValue, oldTarget) {</span><span class="s2">\n    </span><span class="s1">const depsMap = targetMap.get(target);</span><span class="s2">\n    </span><span class="s1">if (!depsMap) {</span><span class="s2">\n        </span><span class="s1">// never been tracked</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let deps = [];</span><span class="s2">\n    </span><span class="s1">if (type === </span><span class="s2">\&quot;</span><span class="s1">clear</span><span class="s2">\&quot; </span><span class="s1">/* TriggerOpTypes.CLEAR */) {</span><span class="s2">\n        </span><span class="s1">// collection being cleared</span><span class="s2">\n        </span><span class="s1">// trigger all effects for target</span><span class="s2">\n        </span><span class="s1">deps = [...depsMap.values()];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (key === 'length' &amp;&amp; isArray(target)) {</span><span class="s2">\n        </span><span class="s1">const newLength = Number(newValue);</span><span class="s2">\n        </span><span class="s1">depsMap.forEach((dep, key) =&gt; {</span><span class="s2">\n            </span><span class="s1">if (key === 'length' || key &gt;= newLength) {</span><span class="s2">\n                </span><span class="s1">deps.push(dep);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">// schedule runs for SET | ADD | DELETE</span><span class="s2">\n        </span><span class="s1">if (key !== void 0) {</span><span class="s2">\n            </span><span class="s1">deps.push(depsMap.get(key));</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// also run for iteration key on ADD | DELETE | Map.SET</span><span class="s2">\n        </span><span class="s1">switch (type) {</span><span class="s2">\n            </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">add</span><span class="s2">\&quot; </span><span class="s1">/* TriggerOpTypes.ADD */:</span><span class="s2">\n                </span><span class="s1">if (!isArray(target)) {</span><span class="s2">\n                    </span><span class="s1">deps.push(depsMap.get(ITERATE_KEY));</span><span class="s2">\n                    </span><span class="s1">if (isMap(target)) {</span><span class="s2">\n                        </span><span class="s1">deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else if (isIntegerKey(key)) {</span><span class="s2">\n                    </span><span class="s1">// new index added to array -&gt; length changes</span><span class="s2">\n                    </span><span class="s1">deps.push(depsMap.get('length'));</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">break;</span><span class="s2">\n            </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">delete</span><span class="s2">\&quot; </span><span class="s1">/* TriggerOpTypes.DELETE */:</span><span class="s2">\n                </span><span class="s1">if (!isArray(target)) {</span><span class="s2">\n                    </span><span class="s1">deps.push(depsMap.get(ITERATE_KEY));</span><span class="s2">\n                    </span><span class="s1">if (isMap(target)) {</span><span class="s2">\n                        </span><span class="s1">deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">break;</span><span class="s2">\n            </span><span class="s1">case </span><span class="s2">\&quot;</span><span class="s1">set</span><span class="s2">\&quot; </span><span class="s1">/* TriggerOpTypes.SET */:</span><span class="s2">\n                </span><span class="s1">if (isMap(target)) {</span><span class="s2">\n                    </span><span class="s1">deps.push(depsMap.get(ITERATE_KEY));</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">break;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">const eventInfo = (process.env.NODE_ENV !== 'production')</span><span class="s2">\n        </span><span class="s1">? { target, type, key, newValue, oldValue, oldTarget }</span><span class="s2">\n        </span><span class="s1">: undefined;</span><span class="s2">\n    </span><span class="s1">if (deps.length === 1) {</span><span class="s2">\n        </span><span class="s1">if (deps[0]) {</span><span class="s2">\n            </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n                </span><span class="s1">triggerEffects(deps[0], eventInfo);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">triggerEffects(deps[0]);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">const effects = [];</span><span class="s2">\n        </span><span class="s1">for (const dep of deps) {</span><span class="s2">\n            </span><span class="s1">if (dep) {</span><span class="s2">\n                </span><span class="s1">effects.push(...dep);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n            </span><span class="s1">triggerEffects(createDep(effects), eventInfo);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">triggerEffects(createDep(effects));</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function triggerEffects(dep, debuggerEventExtraInfo) {</span><span class="s2">\n    </span><span class="s1">// spread into array for stabilization</span><span class="s2">\n    </span><span class="s1">const effects = isArray(dep) ? dep : [...dep];</span><span class="s2">\n    </span><span class="s1">for (const effect of effects) {</span><span class="s2">\n        </span><span class="s1">if (effect.computed) {</span><span class="s2">\n            </span><span class="s1">triggerEffect(effect, debuggerEventExtraInfo);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">for (const effect of effects) {</span><span class="s2">\n        </span><span class="s1">if (!effect.computed) {</span><span class="s2">\n            </span><span class="s1">triggerEffect(effect, debuggerEventExtraInfo);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function triggerEffect(effect, debuggerEventExtraInfo) {</span><span class="s2">\n    </span><span class="s1">if (effect !== activeEffect || effect.allowRecurse) {</span><span class="s2">\n        </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp; effect.onTrigger) {</span><span class="s2">\n            </span><span class="s1">effect.onTrigger(extend({ effect }, debuggerEventExtraInfo));</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (effect.scheduler) {</span><span class="s2">\n            </span><span class="s1">effect.scheduler();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">effect.run();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getDepFromReactive(object, key) {</span><span class="s2">\n    </span><span class="s1">var _a;</span><span class="s2">\n    </span><span class="s1">return (_a = targetMap.get(object)) === null || _a === void 0 ? void 0 : _a.get(key);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">const isNonTrackableKeys = /*#__PURE__*/ makeMap(`__proto__,__v_isRef,__isVue`);</span><span class="s2">\n</span><span class="s1">const builtInSymbols = new Set(</span><span class="s2">\n</span><span class="s1">/*#__PURE__*/</span><span class="s2">\n</span><span class="s1">Object.getOwnPropertyNames(Symbol)</span><span class="s2">\n    </span><span class="s1">// ios10.x Object.getOwnPropertyNames(Symbol) can enumerate 'arguments' and 'caller'</span><span class="s2">\n    </span><span class="s1">// but accessing them on Symbol leads to TypeError because Symbol is a strict mode</span><span class="s2">\n    </span><span class="s1">// function</span><span class="s2">\n    </span><span class="s1">.filter(key =&gt; key !== 'arguments' &amp;&amp; key !== 'caller')</span><span class="s2">\n    </span><span class="s1">.map(key =&gt; Symbol[key])</span><span class="s2">\n    </span><span class="s1">.filter(isSymbol));</span><span class="s2">\n</span><span class="s1">const get$1 = /*#__PURE__*/ createGetter();</span><span class="s2">\n</span><span class="s1">const shallowGet = /*#__PURE__*/ createGetter(false, true);</span><span class="s2">\n</span><span class="s1">const readonlyGet = /*#__PURE__*/ createGetter(true);</span><span class="s2">\n</span><span class="s1">const shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true);</span><span class="s2">\n</span><span class="s1">const arrayInstrumentations = /*#__PURE__*/ createArrayInstrumentations();</span><span class="s2">\n</span><span class="s1">function createArrayInstrumentations() {</span><span class="s2">\n    </span><span class="s1">const instrumentations = {};</span><span class="s2">\n    </span><span class="s1">['includes', 'indexOf', 'lastIndexOf'].forEach(key =&gt; {</span><span class="s2">\n        </span><span class="s1">instrumentations[key] = function (...args) {</span><span class="s2">\n            </span><span class="s1">const arr = toRaw(this);</span><span class="s2">\n            </span><span class="s1">for (let i = 0, l = this.length; i &lt; l; i++) {</span><span class="s2">\n                </span><span class="s1">track(arr, </span><span class="s2">\&quot;</span><span class="s1">get</span><span class="s2">\&quot; </span><span class="s1">/* TrackOpTypes.GET */, i + '');</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">// we run the method using the original args first (which may be reactive)</span><span class="s2">\n            </span><span class="s1">const res = arr[key](...args);</span><span class="s2">\n            </span><span class="s1">if (res === -1 || res === false) {</span><span class="s2">\n                </span><span class="s1">// if that didn't work, run it again using raw values.</span><span class="s2">\n                </span><span class="s1">return arr[key](...args.map(toRaw));</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">return res;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">['push', 'pop', 'shift', 'unshift', 'splice'].forEach(key =&gt; {</span><span class="s2">\n        </span><span class="s1">instrumentations[key] = function (...args) {</span><span class="s2">\n            </span><span class="s1">pauseTracking();</span><span class="s2">\n            </span><span class="s1">const res = toRaw(this)[key].apply(this, args);</span><span class="s2">\n            </span><span class="s1">resetTracking();</span><span class="s2">\n            </span><span class="s1">return res;</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">return instrumentations;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function hasOwnProperty(key) {</span><span class="s2">\n    </span><span class="s1">const obj = toRaw(this);</span><span class="s2">\n    </span><span class="s1">track(obj, </span><span class="s2">\&quot;</span><span class="s1">has</span><span class="s2">\&quot; </span><span class="s1">/* TrackOpTypes.HAS */, key);</span><span class="s2">\n    </span><span class="s1">return obj.hasOwnProperty(key);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createGetter(isReadonly = false, shallow = false) {</span><span class="s2">\n    </span><span class="s1">return function get(target, key, receiver) {</span><span class="s2">\n        </span><span class="s1">if (key === </span><span class="s2">\&quot;</span><span class="s1">__v_isReactive</span><span class="s2">\&quot; </span><span class="s1">/* ReactiveFlags.IS_REACTIVE */) {</span><span class="s2">\n            </span><span class="s1">return !isReadonly;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (key === </span><span class="s2">\&quot;</span><span class="s1">__v_isReadonly</span><span class="s2">\&quot; </span><span class="s1">/* ReactiveFlags.IS_READONLY */) {</span><span class="s2">\n            </span><span class="s1">return isReadonly;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (key === </span><span class="s2">\&quot;</span><span class="s1">__v_isShallow</span><span class="s2">\&quot; </span><span class="s1">/* ReactiveFlags.IS_SHALLOW */) {</span><span class="s2">\n            </span><span class="s1">return shallow;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (key === </span><span class="s2">\&quot;</span><span class="s1">__v_raw</span><span class="s2">\&quot; </span><span class="s1">/* ReactiveFlags.RAW */ &amp;&amp;</span><span class="s2">\n            </span><span class="s1">receiver ===</span><span class="s2">\n                </span><span class="s1">(isReadonly</span><span class="s2">\n                    </span><span class="s1">? shallow</span><span class="s2">\n                        </span><span class="s1">? shallowReadonlyMap</span><span class="s2">\n                        </span><span class="s1">: readonlyMap</span><span class="s2">\n                    </span><span class="s1">: shallow</span><span class="s2">\n                        </span><span class="s1">? shallowReactiveMap</span><span class="s2">\n                        </span><span class="s1">: reactiveMap).get(target)) {</span><span class="s2">\n            </span><span class="s1">return target;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">const targetIsArray = isArray(target);</span><span class="s2">\n        </span><span class="s1">if (!isReadonly) {</span><span class="s2">\n            </span><span class="s1">if (targetIsArray &amp;&amp; hasOwn(arrayInstrumentations, key)) {</span><span class="s2">\n                </span><span class="s1">return Reflect.get(arrayInstrumentations, key, receiver);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">if (key === 'hasOwnProperty') {</span><span class="s2">\n                </span><span class="s1">return hasOwnProperty;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">const res = Reflect.get(target, key, receiver);</span><span class="s2">\n        </span><span class="s1">if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {</span><span class="s2">\n            </span><span class="s1">return res;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (!isReadonly) {</span><span class="s2">\n            </span><span class="s1">track(target, </span><span class="s2">\&quot;</span><span class="s1">get</span><span class="s2">\&quot; </span><span class="s1">/* TrackOpTypes.GET */, key);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (shallow) {</span><span class="s2">\n            </span><span class="s1">return res;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (isRef(res)) {</span><span class="s2">\n            </span><span class="s1">// ref unwrapping - skip unwrap for Array + integer key.</span><span class="s2">\n            </span><span class="s1">return targetIsArray &amp;&amp; isIntegerKey(key) ? res : res.value;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (isObject(res)) {</span><span class="s2">\n            </span><span class="s1">// Convert returned value into a proxy as well. we do the isObject check</span><span class="s2">\n            </span><span class="s1">// here to avoid invalid value warning. Also need to lazy access readonly</span><span class="s2">\n            </span><span class="s1">// and reactive here to avoid circular dependency.</span><span class="s2">\n            </span><span class="s1">return isReadonly ? readonly(res) : reactive(res);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return res;</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">const set$1 = /*#__PURE__*/ createSetter();</span><span class="s2">\n</span><span class="s1">const shallowSet = /*#__PURE__*/ createSetter(true);</span><span class="s2">\n</span><span class="s1">function createSetter(shallow = false) {</span><span class="s2">\n    </span><span class="s1">return function set(target, key, value, receiver) {</span><span class="s2">\n        </span><span class="s1">let oldValue = target[key];</span><span class="s2">\n        </span><span class="s1">if (isReadonly(oldValue) &amp;&amp; isRef(oldValue) &amp;&amp; !isRef(value)) {</span><span class="s2">\n            </span><span class="s1">return false;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (!shallow) {</span><span class="s2">\n            </span><span class="s1">if (!isShallow(value) &amp;&amp; !isReadonly(value)) {</span><span class="s2">\n                </span><span class="s1">oldValue = toRaw(oldValue);</span><span class="s2">\n                </span><span class="s1">value = toRaw(value);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">if (!isArray(target) &amp;&amp; isRef(oldValue) &amp;&amp; !isRef(value)) {</span><span class="s2">\n                </span><span class="s1">oldValue.value = value;</span><span class="s2">\n                </span><span class="s1">return true;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">const hadKey = isArray(target) &amp;&amp; isIntegerKey(key)</span><span class="s2">\n            </span><span class="s1">? Number(key) &lt; target.length</span><span class="s2">\n            </span><span class="s1">: hasOwn(target, key);</span><span class="s2">\n        </span><span class="s1">const result = Reflect.set(target, key, value, receiver);</span><span class="s2">\n        </span><span class="s1">// don't trigger if target is something up in the prototype chain of original</span><span class="s2">\n        </span><span class="s1">if (target === toRaw(receiver)) {</span><span class="s2">\n            </span><span class="s1">if (!hadKey) {</span><span class="s2">\n                </span><span class="s1">trigger(target, </span><span class="s2">\&quot;</span><span class="s1">add</span><span class="s2">\&quot; </span><span class="s1">/* TriggerOpTypes.ADD */, key, value);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else if (hasChanged(value, oldValue)) {</span><span class="s2">\n                </span><span class="s1">trigger(target, </span><span class="s2">\&quot;</span><span class="s1">set</span><span class="s2">\&quot; </span><span class="s1">/* TriggerOpTypes.SET */, key, value, oldValue);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return result;</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function deleteProperty(target, key) {</span><span class="s2">\n    </span><span class="s1">const hadKey = hasOwn(target, key);</span><span class="s2">\n    </span><span class="s1">const oldValue = target[key];</span><span class="s2">\n    </span><span class="s1">const result = Reflect.deleteProperty(target, key);</span><span class="s2">\n    </span><span class="s1">if (result &amp;&amp; hadKey) {</span><span class="s2">\n        </span><span class="s1">trigger(target, </span><span class="s2">\&quot;</span><span class="s1">delete</span><span class="s2">\&quot; </span><span class="s1">/* TriggerOpTypes.DELETE */, key, undefined, oldValue);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return result;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function has$1(target, key) {</span><span class="s2">\n    </span><span class="s1">const result = Reflect.has(target, key);</span><span class="s2">\n    </span><span class="s1">if (!isSymbol(key) || !builtInSymbols.has(key)) {</span><span class="s2">\n        </span><span class="s1">track(target, </span><span class="s2">\&quot;</span><span class="s1">has</span><span class="s2">\&quot; </span><span class="s1">/* TrackOpTypes.HAS */, key);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return result;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function ownKeys(target) {</span><span class="s2">\n    </span><span class="s1">track(target, </span><span class="s2">\&quot;</span><span class="s1">iterate</span><span class="s2">\&quot; </span><span class="s1">/* TrackOpTypes.ITERATE */, isArray(target) ? 'length' : ITERATE_KEY);</span><span class="s2">\n    </span><span class="s1">return Reflect.ownKeys(target);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">const mutableHandlers = {</span><span class="s2">\n    </span><span class="s1">get: get$1,</span><span class="s2">\n    </span><span class="s1">set: set$1,</span><span class="s2">\n    </span><span class="s1">deleteProperty,</span><span class="s2">\n    </span><span class="s1">has: has$1,</span><span class="s2">\n    </span><span class="s1">ownKeys</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">const readonlyHandlers = {</span><span class="s2">\n    </span><span class="s1">get: readonlyGet,</span><span class="s2">\n    </span><span class="s1">set(target, key) {</span><span class="s2">\n        </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n            </span><span class="s1">warn(`Set operation on key </span><span class="s2">\&quot;</span><span class="s1">${String(key)}</span><span class="s2">\&quot; </span><span class="s1">failed: target is readonly.`, target);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return true;</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">deleteProperty(target, key) {</span><span class="s2">\n        </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n            </span><span class="s1">warn(`Delete operation on key </span><span class="s2">\&quot;</span><span class="s1">${String(key)}</span><span class="s2">\&quot; </span><span class="s1">failed: target is readonly.`, target);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return true;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">const shallowReactiveHandlers = /*#__PURE__*/ extend({}, mutableHandlers, {</span><span class="s2">\n    </span><span class="s1">get: shallowGet,</span><span class="s2">\n    </span><span class="s1">set: shallowSet</span><span class="s2">\n</span><span class="s1">});</span><span class="s2">\n</span><span class="s1">// Props handlers are special in the sense that it should not unwrap top-level</span><span class="s2">\n</span><span class="s1">// refs (in order to allow refs to be explicitly passed down), but should</span><span class="s2">\n</span><span class="s1">// retain the reactivity of the normal readonly object.</span><span class="s2">\n</span><span class="s1">const shallowReadonlyHandlers = /*#__PURE__*/ extend({}, readonlyHandlers, {</span><span class="s2">\n    </span><span class="s1">get: shallowReadonlyGet</span><span class="s2">\n</span><span class="s1">});</span><span class="s2">\n\n</span><span class="s1">const toShallow = (value) =&gt; value;</span><span class="s2">\n</span><span class="s1">const getProto = (v) =&gt; Reflect.getPrototypeOf(v);</span><span class="s2">\n</span><span class="s1">function get(target, key, isReadonly = false, isShallow = false) {</span><span class="s2">\n    </span><span class="s1">// #1772: readonly(reactive(Map)) should return readonly + reactive version</span><span class="s2">\n    </span><span class="s1">// of the value</span><span class="s2">\n    </span><span class="s1">target = target[</span><span class="s2">\&quot;</span><span class="s1">__v_raw</span><span class="s2">\&quot; </span><span class="s1">/* ReactiveFlags.RAW */];</span><span class="s2">\n    </span><span class="s1">const rawTarget = toRaw(target);</span><span class="s2">\n    </span><span class="s1">const rawKey = toRaw(key);</span><span class="s2">\n    </span><span class="s1">if (!isReadonly) {</span><span class="s2">\n        </span><span class="s1">if (key !== rawKey) {</span><span class="s2">\n            </span><span class="s1">track(rawTarget, </span><span class="s2">\&quot;</span><span class="s1">get</span><span class="s2">\&quot; </span><span class="s1">/* TrackOpTypes.GET */, key);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">track(rawTarget, </span><span class="s2">\&quot;</span><span class="s1">get</span><span class="s2">\&quot; </span><span class="s1">/* TrackOpTypes.GET */, rawKey);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">const { has } = getProto(rawTarget);</span><span class="s2">\n    </span><span class="s1">const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;</span><span class="s2">\n    </span><span class="s1">if (has.call(rawTarget, key)) {</span><span class="s2">\n        </span><span class="s1">return wrap(target.get(key));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (has.call(rawTarget, rawKey)) {</span><span class="s2">\n        </span><span class="s1">return wrap(target.get(rawKey));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (target !== rawTarget) {</span><span class="s2">\n        </span><span class="s1">// #3602 readonly(reactive(Map))</span><span class="s2">\n        </span><span class="s1">// ensure that the nested reactive `Map` can do tracking for itself</span><span class="s2">\n        </span><span class="s1">target.get(key);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function has(key, isReadonly = false) {</span><span class="s2">\n    </span><span class="s1">const target = this[</span><span class="s2">\&quot;</span><span class="s1">__v_raw</span><span class="s2">\&quot; </span><span class="s1">/* ReactiveFlags.RAW */];</span><span class="s2">\n    </span><span class="s1">const rawTarget = toRaw(target);</span><span class="s2">\n    </span><span class="s1">const rawKey = toRaw(key);</span><span class="s2">\n    </span><span class="s1">if (!isReadonly) {</span><span class="s2">\n        </span><span class="s1">if (key !== rawKey) {</span><span class="s2">\n            </span><span class="s1">track(rawTarget, </span><span class="s2">\&quot;</span><span class="s1">has</span><span class="s2">\&quot; </span><span class="s1">/* TrackOpTypes.HAS */, key);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">track(rawTarget, </span><span class="s2">\&quot;</span><span class="s1">has</span><span class="s2">\&quot; </span><span class="s1">/* TrackOpTypes.HAS */, rawKey);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return key === rawKey</span><span class="s2">\n        </span><span class="s1">? target.has(key)</span><span class="s2">\n        </span><span class="s1">: target.has(key) || target.has(rawKey);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function size(target, isReadonly = false) {</span><span class="s2">\n    </span><span class="s1">target = target[</span><span class="s2">\&quot;</span><span class="s1">__v_raw</span><span class="s2">\&quot; </span><span class="s1">/* ReactiveFlags.RAW */];</span><span class="s2">\n    </span><span class="s1">!isReadonly &amp;&amp; track(toRaw(target), </span><span class="s2">\&quot;</span><span class="s1">iterate</span><span class="s2">\&quot; </span><span class="s1">/* TrackOpTypes.ITERATE */, ITERATE_KEY);</span><span class="s2">\n    </span><span class="s1">return Reflect.get(target, 'size', target);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function add(value) {</span><span class="s2">\n    </span><span class="s1">value = toRaw(value);</span><span class="s2">\n    </span><span class="s1">const target = toRaw(this);</span><span class="s2">\n    </span><span class="s1">const proto = getProto(target);</span><span class="s2">\n    </span><span class="s1">const hadKey = proto.has.call(target, value);</span><span class="s2">\n    </span><span class="s1">if (!hadKey) {</span><span class="s2">\n        </span><span class="s1">target.add(value);</span><span class="s2">\n        </span><span class="s1">trigger(target, </span><span class="s2">\&quot;</span><span class="s1">add</span><span class="s2">\&quot; </span><span class="s1">/* TriggerOpTypes.ADD */, value, value);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return this;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function set(key, value) {</span><span class="s2">\n    </span><span class="s1">value = toRaw(value);</span><span class="s2">\n    </span><span class="s1">const target = toRaw(this);</span><span class="s2">\n    </span><span class="s1">const { has, get } = getProto(target);</span><span class="s2">\n    </span><span class="s1">let hadKey = has.call(target, key);</span><span class="s2">\n    </span><span class="s1">if (!hadKey) {</span><span class="s2">\n        </span><span class="s1">key = toRaw(key);</span><span class="s2">\n        </span><span class="s1">hadKey = has.call(target, key);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n        </span><span class="s1">checkIdentityKeys(target, has, key);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">const oldValue = get.call(target, key);</span><span class="s2">\n    </span><span class="s1">target.set(key, value);</span><span class="s2">\n    </span><span class="s1">if (!hadKey) {</span><span class="s2">\n        </span><span class="s1">trigger(target, </span><span class="s2">\&quot;</span><span class="s1">add</span><span class="s2">\&quot; </span><span class="s1">/* TriggerOpTypes.ADD */, key, value);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (hasChanged(value, oldValue)) {</span><span class="s2">\n        </span><span class="s1">trigger(target, </span><span class="s2">\&quot;</span><span class="s1">set</span><span class="s2">\&quot; </span><span class="s1">/* TriggerOpTypes.SET */, key, value, oldValue);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return this;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function deleteEntry(key) {</span><span class="s2">\n    </span><span class="s1">const target = toRaw(this);</span><span class="s2">\n    </span><span class="s1">const { has, get } = getProto(target);</span><span class="s2">\n    </span><span class="s1">let hadKey = has.call(target, key);</span><span class="s2">\n    </span><span class="s1">if (!hadKey) {</span><span class="s2">\n        </span><span class="s1">key = toRaw(key);</span><span class="s2">\n        </span><span class="s1">hadKey = has.call(target, key);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n        </span><span class="s1">checkIdentityKeys(target, has, key);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">const oldValue = get ? get.call(target, key) : undefined;</span><span class="s2">\n    </span><span class="s1">// forward the operation before queueing reactions</span><span class="s2">\n    </span><span class="s1">const result = target.delete(key);</span><span class="s2">\n    </span><span class="s1">if (hadKey) {</span><span class="s2">\n        </span><span class="s1">trigger(target, </span><span class="s2">\&quot;</span><span class="s1">delete</span><span class="s2">\&quot; </span><span class="s1">/* TriggerOpTypes.DELETE */, key, undefined, oldValue);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return result;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function clear() {</span><span class="s2">\n    </span><span class="s1">const target = toRaw(this);</span><span class="s2">\n    </span><span class="s1">const hadItems = target.size !== 0;</span><span class="s2">\n    </span><span class="s1">const oldTarget = (process.env.NODE_ENV !== 'production')</span><span class="s2">\n        </span><span class="s1">? isMap(target)</span><span class="s2">\n            </span><span class="s1">? new Map(target)</span><span class="s2">\n            </span><span class="s1">: new Set(target)</span><span class="s2">\n        </span><span class="s1">: undefined;</span><span class="s2">\n    </span><span class="s1">// forward the operation before queueing reactions</span><span class="s2">\n    </span><span class="s1">const result = target.clear();</span><span class="s2">\n    </span><span class="s1">if (hadItems) {</span><span class="s2">\n        </span><span class="s1">trigger(target, </span><span class="s2">\&quot;</span><span class="s1">clear</span><span class="s2">\&quot; </span><span class="s1">/* TriggerOpTypes.CLEAR */, undefined, undefined, oldTarget);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return result;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createForEach(isReadonly, isShallow) {</span><span class="s2">\n    </span><span class="s1">return function forEach(callback, thisArg) {</span><span class="s2">\n        </span><span class="s1">const observed = this;</span><span class="s2">\n        </span><span class="s1">const target = observed[</span><span class="s2">\&quot;</span><span class="s1">__v_raw</span><span class="s2">\&quot; </span><span class="s1">/* ReactiveFlags.RAW */];</span><span class="s2">\n        </span><span class="s1">const rawTarget = toRaw(target);</span><span class="s2">\n        </span><span class="s1">const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;</span><span class="s2">\n        </span><span class="s1">!isReadonly &amp;&amp; track(rawTarget, </span><span class="s2">\&quot;</span><span class="s1">iterate</span><span class="s2">\&quot; </span><span class="s1">/* TrackOpTypes.ITERATE */, ITERATE_KEY);</span><span class="s2">\n        </span><span class="s1">return target.forEach((value, key) =&gt; {</span><span class="s2">\n            </span><span class="s1">// important: make sure the callback is</span><span class="s2">\n            </span><span class="s1">// 1. invoked with the reactive map as `this` and 3rd arg</span><span class="s2">\n            </span><span class="s1">// 2. the value received should be a corresponding reactive/readonly.</span><span class="s2">\n            </span><span class="s1">return callback.call(thisArg, wrap(value), wrap(key), observed);</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createIterableMethod(method, isReadonly, isShallow) {</span><span class="s2">\n    </span><span class="s1">return function (...args) {</span><span class="s2">\n        </span><span class="s1">const target = this[</span><span class="s2">\&quot;</span><span class="s1">__v_raw</span><span class="s2">\&quot; </span><span class="s1">/* ReactiveFlags.RAW */];</span><span class="s2">\n        </span><span class="s1">const rawTarget = toRaw(target);</span><span class="s2">\n        </span><span class="s1">const targetIsMap = isMap(rawTarget);</span><span class="s2">\n        </span><span class="s1">const isPair = method === 'entries' || (method === Symbol.iterator &amp;&amp; targetIsMap);</span><span class="s2">\n        </span><span class="s1">const isKeyOnly = method === 'keys' &amp;&amp; targetIsMap;</span><span class="s2">\n        </span><span class="s1">const innerIterator = target[method](...args);</span><span class="s2">\n        </span><span class="s1">const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;</span><span class="s2">\n        </span><span class="s1">!isReadonly &amp;&amp;</span><span class="s2">\n            </span><span class="s1">track(rawTarget, </span><span class="s2">\&quot;</span><span class="s1">iterate</span><span class="s2">\&quot; </span><span class="s1">/* TrackOpTypes.ITERATE */, isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);</span><span class="s2">\n        </span><span class="s1">// return a wrapped iterator which returns observed versions of the</span><span class="s2">\n        </span><span class="s1">// values emitted from the real iterator</span><span class="s2">\n        </span><span class="s1">return {</span><span class="s2">\n            </span><span class="s1">// iterator protocol</span><span class="s2">\n            </span><span class="s1">next() {</span><span class="s2">\n                </span><span class="s1">const { value, done } = innerIterator.next();</span><span class="s2">\n                </span><span class="s1">return done</span><span class="s2">\n                    </span><span class="s1">? { value, done }</span><span class="s2">\n                    </span><span class="s1">: {</span><span class="s2">\n                        </span><span class="s1">value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),</span><span class="s2">\n                        </span><span class="s1">done</span><span class="s2">\n                    </span><span class="s1">};</span><span class="s2">\n            </span><span class="s1">},</span><span class="s2">\n            </span><span class="s1">// iterable protocol</span><span class="s2">\n            </span><span class="s1">[Symbol.iterator]() {</span><span class="s2">\n                </span><span class="s1">return this;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createReadonlyMethod(type) {</span><span class="s2">\n    </span><span class="s1">return function (...args) {</span><span class="s2">\n        </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n            </span><span class="s1">const key = args[0] ? `on key </span><span class="s2">\&quot;</span><span class="s1">${args[0]}</span><span class="s2">\&quot; </span><span class="s1">` : ``;</span><span class="s2">\n            </span><span class="s1">console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return type === </span><span class="s2">\&quot;</span><span class="s1">delete</span><span class="s2">\&quot; </span><span class="s1">/* TriggerOpTypes.DELETE */ ? false : this;</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createInstrumentations() {</span><span class="s2">\n    </span><span class="s1">const mutableInstrumentations = {</span><span class="s2">\n        </span><span class="s1">get(key) {</span><span class="s2">\n            </span><span class="s1">return get(this, key);</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">get size() {</span><span class="s2">\n            </span><span class="s1">return size(this);</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">has,</span><span class="s2">\n        </span><span class="s1">add,</span><span class="s2">\n        </span><span class="s1">set,</span><span class="s2">\n        </span><span class="s1">delete: deleteEntry,</span><span class="s2">\n        </span><span class="s1">clear,</span><span class="s2">\n        </span><span class="s1">forEach: createForEach(false, false)</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">const shallowInstrumentations = {</span><span class="s2">\n        </span><span class="s1">get(key) {</span><span class="s2">\n            </span><span class="s1">return get(this, key, false, true);</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">get size() {</span><span class="s2">\n            </span><span class="s1">return size(this);</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">has,</span><span class="s2">\n        </span><span class="s1">add,</span><span class="s2">\n        </span><span class="s1">set,</span><span class="s2">\n        </span><span class="s1">delete: deleteEntry,</span><span class="s2">\n        </span><span class="s1">clear,</span><span class="s2">\n        </span><span class="s1">forEach: createForEach(false, true)</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">const readonlyInstrumentations = {</span><span class="s2">\n        </span><span class="s1">get(key) {</span><span class="s2">\n            </span><span class="s1">return get(this, key, true);</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">get size() {</span><span class="s2">\n            </span><span class="s1">return size(this, true);</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">has(key) {</span><span class="s2">\n            </span><span class="s1">return has.call(this, key, true);</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">add: createReadonlyMethod(</span><span class="s2">\&quot;</span><span class="s1">add</span><span class="s2">\&quot; </span><span class="s1">/* TriggerOpTypes.ADD */),</span><span class="s2">\n        </span><span class="s1">set: createReadonlyMethod(</span><span class="s2">\&quot;</span><span class="s1">set</span><span class="s2">\&quot; </span><span class="s1">/* TriggerOpTypes.SET */),</span><span class="s2">\n        </span><span class="s1">delete: createReadonlyMethod(</span><span class="s2">\&quot;</span><span class="s1">delete</span><span class="s2">\&quot; </span><span class="s1">/* TriggerOpTypes.DELETE */),</span><span class="s2">\n        </span><span class="s1">clear: createReadonlyMethod(</span><span class="s2">\&quot;</span><span class="s1">clear</span><span class="s2">\&quot; </span><span class="s1">/* TriggerOpTypes.CLEAR */),</span><span class="s2">\n        </span><span class="s1">forEach: createForEach(true, false)</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">const shallowReadonlyInstrumentations = {</span><span class="s2">\n        </span><span class="s1">get(key) {</span><span class="s2">\n            </span><span class="s1">return get(this, key, true, true);</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">get size() {</span><span class="s2">\n            </span><span class="s1">return size(this, true);</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">has(key) {</span><span class="s2">\n            </span><span class="s1">return has.call(this, key, true);</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">add: createReadonlyMethod(</span><span class="s2">\&quot;</span><span class="s1">add</span><span class="s2">\&quot; </span><span class="s1">/* TriggerOpTypes.ADD */),</span><span class="s2">\n        </span><span class="s1">set: createReadonlyMethod(</span><span class="s2">\&quot;</span><span class="s1">set</span><span class="s2">\&quot; </span><span class="s1">/* TriggerOpTypes.SET */),</span><span class="s2">\n        </span><span class="s1">delete: createReadonlyMethod(</span><span class="s2">\&quot;</span><span class="s1">delete</span><span class="s2">\&quot; </span><span class="s1">/* TriggerOpTypes.DELETE */),</span><span class="s2">\n        </span><span class="s1">clear: createReadonlyMethod(</span><span class="s2">\&quot;</span><span class="s1">clear</span><span class="s2">\&quot; </span><span class="s1">/* TriggerOpTypes.CLEAR */),</span><span class="s2">\n        </span><span class="s1">forEach: createForEach(true, true)</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">const iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator];</span><span class="s2">\n    </span><span class="s1">iteratorMethods.forEach(method =&gt; {</span><span class="s2">\n        </span><span class="s1">mutableInstrumentations[method] = createIterableMethod(method, false, false);</span><span class="s2">\n        </span><span class="s1">readonlyInstrumentations[method] = createIterableMethod(method, true, false);</span><span class="s2">\n        </span><span class="s1">shallowInstrumentations[method] = createIterableMethod(method, false, true);</span><span class="s2">\n        </span><span class="s1">shallowReadonlyInstrumentations[method] = createIterableMethod(method, true, true);</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">return [</span><span class="s2">\n        </span><span class="s1">mutableInstrumentations,</span><span class="s2">\n        </span><span class="s1">readonlyInstrumentations,</span><span class="s2">\n        </span><span class="s1">shallowInstrumentations,</span><span class="s2">\n        </span><span class="s1">shallowReadonlyInstrumentations</span><span class="s2">\n    </span><span class="s1">];</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">const [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* #__PURE__*/ createInstrumentations();</span><span class="s2">\n</span><span class="s1">function createInstrumentationGetter(isReadonly, shallow) {</span><span class="s2">\n    </span><span class="s1">const instrumentations = shallow</span><span class="s2">\n        </span><span class="s1">? isReadonly</span><span class="s2">\n            </span><span class="s1">? shallowReadonlyInstrumentations</span><span class="s2">\n            </span><span class="s1">: shallowInstrumentations</span><span class="s2">\n        </span><span class="s1">: isReadonly</span><span class="s2">\n            </span><span class="s1">? readonlyInstrumentations</span><span class="s2">\n            </span><span class="s1">: mutableInstrumentations;</span><span class="s2">\n    </span><span class="s1">return (target, key, receiver) =&gt; {</span><span class="s2">\n        </span><span class="s1">if (key === </span><span class="s2">\&quot;</span><span class="s1">__v_isReactive</span><span class="s2">\&quot; </span><span class="s1">/* ReactiveFlags.IS_REACTIVE */) {</span><span class="s2">\n            </span><span class="s1">return !isReadonly;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (key === </span><span class="s2">\&quot;</span><span class="s1">__v_isReadonly</span><span class="s2">\&quot; </span><span class="s1">/* ReactiveFlags.IS_READONLY */) {</span><span class="s2">\n            </span><span class="s1">return isReadonly;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (key === </span><span class="s2">\&quot;</span><span class="s1">__v_raw</span><span class="s2">\&quot; </span><span class="s1">/* ReactiveFlags.RAW */) {</span><span class="s2">\n            </span><span class="s1">return target;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return Reflect.get(hasOwn(instrumentations, key) &amp;&amp; key in target</span><span class="s2">\n            </span><span class="s1">? instrumentations</span><span class="s2">\n            </span><span class="s1">: target, key, receiver);</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">const mutableCollectionHandlers = {</span><span class="s2">\n    </span><span class="s1">get: /*#__PURE__*/ createInstrumentationGetter(false, false)</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">const shallowCollectionHandlers = {</span><span class="s2">\n    </span><span class="s1">get: /*#__PURE__*/ createInstrumentationGetter(false, true)</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">const readonlyCollectionHandlers = {</span><span class="s2">\n    </span><span class="s1">get: /*#__PURE__*/ createInstrumentationGetter(true, false)</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">const shallowReadonlyCollectionHandlers = {</span><span class="s2">\n    </span><span class="s1">get: /*#__PURE__*/ createInstrumentationGetter(true, true)</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">function checkIdentityKeys(target, has, key) {</span><span class="s2">\n    </span><span class="s1">const rawKey = toRaw(key);</span><span class="s2">\n    </span><span class="s1">if (rawKey !== key &amp;&amp; has.call(target, rawKey)) {</span><span class="s2">\n        </span><span class="s1">const type = toRawType(target);</span><span class="s2">\n        </span><span class="s1">console.warn(`Reactive ${type} contains both the raw and reactive ` +</span><span class="s2">\n            </span><span class="s1">`versions of the same object${type === `Map` ? ` as keys` : ``}, ` +</span><span class="s2">\n            </span><span class="s1">`which can lead to inconsistencies. ` +</span><span class="s2">\n            </span><span class="s1">`Avoid differentiating between the raw and reactive versions ` +</span><span class="s2">\n            </span><span class="s1">`of an object and only use the reactive version if possible.`);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">const reactiveMap = new WeakMap();</span><span class="s2">\n</span><span class="s1">const shallowReactiveMap = new WeakMap();</span><span class="s2">\n</span><span class="s1">const readonlyMap = new WeakMap();</span><span class="s2">\n</span><span class="s1">const shallowReadonlyMap = new WeakMap();</span><span class="s2">\n</span><span class="s1">function targetTypeMap(rawType) {</span><span class="s2">\n    </span><span class="s1">switch (rawType) {</span><span class="s2">\n        </span><span class="s1">case 'Object':</span><span class="s2">\n        </span><span class="s1">case 'Array':</span><span class="s2">\n            </span><span class="s1">return 1 /* TargetType.COMMON */;</span><span class="s2">\n        </span><span class="s1">case 'Map':</span><span class="s2">\n        </span><span class="s1">case 'Set':</span><span class="s2">\n        </span><span class="s1">case 'WeakMap':</span><span class="s2">\n        </span><span class="s1">case 'WeakSet':</span><span class="s2">\n            </span><span class="s1">return 2 /* TargetType.COLLECTION */;</span><span class="s2">\n        </span><span class="s1">default:</span><span class="s2">\n            </span><span class="s1">return 0 /* TargetType.INVALID */;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getTargetType(value) {</span><span class="s2">\n    </span><span class="s1">return value[</span><span class="s2">\&quot;</span><span class="s1">__v_skip</span><span class="s2">\&quot; </span><span class="s1">/* ReactiveFlags.SKIP */] || !Object.isExtensible(value)</span><span class="s2">\n        </span><span class="s1">? 0 /* TargetType.INVALID */</span><span class="s2">\n        </span><span class="s1">: targetTypeMap(toRawType(value));</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function reactive(target) {</span><span class="s2">\n    </span><span class="s1">// if trying to observe a readonly proxy, return the readonly version.</span><span class="s2">\n    </span><span class="s1">if (isReadonly(target)) {</span><span class="s2">\n        </span><span class="s1">return target;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Return a shallowly-reactive copy of the original object, where only the root</span><span class="s2">\n </span><span class="s1">* level properties are reactive. It also does not auto-unwrap refs (even at the</span><span class="s2">\n </span><span class="s1">* root level).</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function shallowReactive(target) {</span><span class="s2">\n    </span><span class="s1">return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Creates a readonly copy of the original object. Note the returned copy is not</span><span class="s2">\n </span><span class="s1">* made reactive, but `readonly` can be called on an already reactive object.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function readonly(target) {</span><span class="s2">\n    </span><span class="s1">return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Returns a reactive-copy of the original object, where only the root level</span><span class="s2">\n </span><span class="s1">* properties are readonly, and does NOT unwrap refs nor recursively convert</span><span class="s2">\n </span><span class="s1">* returned properties.</span><span class="s2">\n </span><span class="s1">* This is used for creating the props proxy object for stateful components.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function shallowReadonly(target) {</span><span class="s2">\n    </span><span class="s1">return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {</span><span class="s2">\n    </span><span class="s1">if (!isObject(target)) {</span><span class="s2">\n        </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n            </span><span class="s1">console.warn(`value cannot be made reactive: ${String(target)}`);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return target;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// target is already a Proxy, return it.</span><span class="s2">\n    </span><span class="s1">// exception: calling readonly() on a reactive object</span><span class="s2">\n    </span><span class="s1">if (target[</span><span class="s2">\&quot;</span><span class="s1">__v_raw</span><span class="s2">\&quot; </span><span class="s1">/* ReactiveFlags.RAW */] &amp;&amp;</span><span class="s2">\n        </span><span class="s1">!(isReadonly &amp;&amp; target[</span><span class="s2">\&quot;</span><span class="s1">__v_isReactive</span><span class="s2">\&quot; </span><span class="s1">/* ReactiveFlags.IS_REACTIVE */])) {</span><span class="s2">\n        </span><span class="s1">return target;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// target already has corresponding Proxy</span><span class="s2">\n    </span><span class="s1">const existingProxy = proxyMap.get(target);</span><span class="s2">\n    </span><span class="s1">if (existingProxy) {</span><span class="s2">\n        </span><span class="s1">return existingProxy;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// only specific value types can be observed.</span><span class="s2">\n    </span><span class="s1">const targetType = getTargetType(target);</span><span class="s2">\n    </span><span class="s1">if (targetType === 0 /* TargetType.INVALID */) {</span><span class="s2">\n        </span><span class="s1">return target;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">const proxy = new Proxy(target, targetType === 2 /* TargetType.COLLECTION */ ? collectionHandlers : baseHandlers);</span><span class="s2">\n    </span><span class="s1">proxyMap.set(target, proxy);</span><span class="s2">\n    </span><span class="s1">return proxy;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isReactive(value) {</span><span class="s2">\n    </span><span class="s1">if (isReadonly(value)) {</span><span class="s2">\n        </span><span class="s1">return isReactive(value[</span><span class="s2">\&quot;</span><span class="s1">__v_raw</span><span class="s2">\&quot; </span><span class="s1">/* ReactiveFlags.RAW */]);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return !!(value &amp;&amp; value[</span><span class="s2">\&quot;</span><span class="s1">__v_isReactive</span><span class="s2">\&quot; </span><span class="s1">/* ReactiveFlags.IS_REACTIVE */]);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isReadonly(value) {</span><span class="s2">\n    </span><span class="s1">return !!(value &amp;&amp; value[</span><span class="s2">\&quot;</span><span class="s1">__v_isReadonly</span><span class="s2">\&quot; </span><span class="s1">/* ReactiveFlags.IS_READONLY */]);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isShallow(value) {</span><span class="s2">\n    </span><span class="s1">return !!(value &amp;&amp; value[</span><span class="s2">\&quot;</span><span class="s1">__v_isShallow</span><span class="s2">\&quot; </span><span class="s1">/* ReactiveFlags.IS_SHALLOW */]);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isProxy(value) {</span><span class="s2">\n    </span><span class="s1">return isReactive(value) || isReadonly(value);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function toRaw(observed) {</span><span class="s2">\n    </span><span class="s1">const raw = observed &amp;&amp; observed[</span><span class="s2">\&quot;</span><span class="s1">__v_raw</span><span class="s2">\&quot; </span><span class="s1">/* ReactiveFlags.RAW */];</span><span class="s2">\n    </span><span class="s1">return raw ? toRaw(raw) : observed;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function markRaw(value) {</span><span class="s2">\n    </span><span class="s1">def(value, </span><span class="s2">\&quot;</span><span class="s1">__v_skip</span><span class="s2">\&quot; </span><span class="s1">/* ReactiveFlags.SKIP */, true);</span><span class="s2">\n    </span><span class="s1">return value;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">const toReactive = (value) =&gt; isObject(value) ? reactive(value) : value;</span><span class="s2">\n</span><span class="s1">const toReadonly = (value) =&gt; isObject(value) ? readonly(value) : value;</span><span class="s2">\n\n</span><span class="s1">function trackRefValue(ref) {</span><span class="s2">\n    </span><span class="s1">if (shouldTrack &amp;&amp; activeEffect) {</span><span class="s2">\n        </span><span class="s1">ref = toRaw(ref);</span><span class="s2">\n        </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n            </span><span class="s1">trackEffects(ref.dep || (ref.dep = createDep()), {</span><span class="s2">\n                </span><span class="s1">target: ref,</span><span class="s2">\n                </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">get</span><span class="s2">\&quot; </span><span class="s1">/* TrackOpTypes.GET */,</span><span class="s2">\n                </span><span class="s1">key: 'value'</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">trackEffects(ref.dep || (ref.dep = createDep()));</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function triggerRefValue(ref, newVal) {</span><span class="s2">\n    </span><span class="s1">ref = toRaw(ref);</span><span class="s2">\n    </span><span class="s1">const dep = ref.dep;</span><span class="s2">\n    </span><span class="s1">if (dep) {</span><span class="s2">\n        </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n            </span><span class="s1">triggerEffects(dep, {</span><span class="s2">\n                </span><span class="s1">target: ref,</span><span class="s2">\n                </span><span class="s1">type: </span><span class="s2">\&quot;</span><span class="s1">set</span><span class="s2">\&quot; </span><span class="s1">/* TriggerOpTypes.SET */,</span><span class="s2">\n                </span><span class="s1">key: 'value',</span><span class="s2">\n                </span><span class="s1">newValue: newVal</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">triggerEffects(dep);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isRef(r) {</span><span class="s2">\n    </span><span class="s1">return !!(r &amp;&amp; r.__v_isRef === true);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function ref(value) {</span><span class="s2">\n    </span><span class="s1">return createRef(value, false);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function shallowRef(value) {</span><span class="s2">\n    </span><span class="s1">return createRef(value, true);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createRef(rawValue, shallow) {</span><span class="s2">\n    </span><span class="s1">if (isRef(rawValue)) {</span><span class="s2">\n        </span><span class="s1">return rawValue;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return new RefImpl(rawValue, shallow);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">class RefImpl {</span><span class="s2">\n    </span><span class="s1">constructor(value, __v_isShallow) {</span><span class="s2">\n        </span><span class="s1">this.__v_isShallow = __v_isShallow;</span><span class="s2">\n        </span><span class="s1">this.dep = undefined;</span><span class="s2">\n        </span><span class="s1">this.__v_isRef = true;</span><span class="s2">\n        </span><span class="s1">this._rawValue = __v_isShallow ? value : toRaw(value);</span><span class="s2">\n        </span><span class="s1">this._value = __v_isShallow ? value : toReactive(value);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">get value() {</span><span class="s2">\n        </span><span class="s1">trackRefValue(this);</span><span class="s2">\n        </span><span class="s1">return this._value;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">set value(newVal) {</span><span class="s2">\n        </span><span class="s1">const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);</span><span class="s2">\n        </span><span class="s1">newVal = useDirectValue ? newVal : toRaw(newVal);</span><span class="s2">\n        </span><span class="s1">if (hasChanged(newVal, this._rawValue)) {</span><span class="s2">\n            </span><span class="s1">this._rawValue = newVal;</span><span class="s2">\n            </span><span class="s1">this._value = useDirectValue ? newVal : toReactive(newVal);</span><span class="s2">\n            </span><span class="s1">triggerRefValue(this, newVal);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function triggerRef(ref) {</span><span class="s2">\n    </span><span class="s1">triggerRefValue(ref, (process.env.NODE_ENV !== 'production') ? ref.value : void 0);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function unref(ref) {</span><span class="s2">\n    </span><span class="s1">return isRef(ref) ? ref.value : ref;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">const shallowUnwrapHandlers = {</span><span class="s2">\n    </span><span class="s1">get: (target, key, receiver) =&gt; unref(Reflect.get(target, key, receiver)),</span><span class="s2">\n    </span><span class="s1">set: (target, key, value, receiver) =&gt; {</span><span class="s2">\n        </span><span class="s1">const oldValue = target[key];</span><span class="s2">\n        </span><span class="s1">if (isRef(oldValue) &amp;&amp; !isRef(value)) {</span><span class="s2">\n            </span><span class="s1">oldValue.value = value;</span><span class="s2">\n            </span><span class="s1">return true;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">return Reflect.set(target, key, value, receiver);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">function proxyRefs(objectWithRefs) {</span><span class="s2">\n    </span><span class="s1">return isReactive(objectWithRefs)</span><span class="s2">\n        </span><span class="s1">? objectWithRefs</span><span class="s2">\n        </span><span class="s1">: new Proxy(objectWithRefs, shallowUnwrapHandlers);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">class CustomRefImpl {</span><span class="s2">\n    </span><span class="s1">constructor(factory) {</span><span class="s2">\n        </span><span class="s1">this.dep = undefined;</span><span class="s2">\n        </span><span class="s1">this.__v_isRef = true;</span><span class="s2">\n        </span><span class="s1">const { get, set } = factory(() =&gt; trackRefValue(this), () =&gt; triggerRefValue(this));</span><span class="s2">\n        </span><span class="s1">this._get = get;</span><span class="s2">\n        </span><span class="s1">this._set = set;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">get value() {</span><span class="s2">\n        </span><span class="s1">return this._get();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">set value(newVal) {</span><span class="s2">\n        </span><span class="s1">this._set(newVal);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function customRef(factory) {</span><span class="s2">\n    </span><span class="s1">return new CustomRefImpl(factory);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function toRefs(object) {</span><span class="s2">\n    </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp; !isProxy(object)) {</span><span class="s2">\n        </span><span class="s1">console.warn(`toRefs() expects a reactive object but received a plain one.`);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">const ret = isArray(object) ? new Array(object.length) : {};</span><span class="s2">\n    </span><span class="s1">for (const key in object) {</span><span class="s2">\n        </span><span class="s1">ret[key] = toRef(object, key);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return ret;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">class ObjectRefImpl {</span><span class="s2">\n    </span><span class="s1">constructor(_object, _key, _defaultValue) {</span><span class="s2">\n        </span><span class="s1">this._object = _object;</span><span class="s2">\n        </span><span class="s1">this._key = _key;</span><span class="s2">\n        </span><span class="s1">this._defaultValue = _defaultValue;</span><span class="s2">\n        </span><span class="s1">this.__v_isRef = true;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">get value() {</span><span class="s2">\n        </span><span class="s1">const val = this._object[this._key];</span><span class="s2">\n        </span><span class="s1">return val === undefined ? this._defaultValue : val;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">set value(newVal) {</span><span class="s2">\n        </span><span class="s1">this._object[this._key] = newVal;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">get dep() {</span><span class="s2">\n        </span><span class="s1">return getDepFromReactive(toRaw(this._object), this._key);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function toRef(object, key, defaultValue) {</span><span class="s2">\n    </span><span class="s1">const val = object[key];</span><span class="s2">\n    </span><span class="s1">return isRef(val)</span><span class="s2">\n        </span><span class="s1">? val</span><span class="s2">\n        </span><span class="s1">: new ObjectRefImpl(object, key, defaultValue);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">var _a$1;</span><span class="s2">\n</span><span class="s1">class ComputedRefImpl {</span><span class="s2">\n    </span><span class="s1">constructor(getter, _setter, isReadonly, isSSR) {</span><span class="s2">\n        </span><span class="s1">this._setter = _setter;</span><span class="s2">\n        </span><span class="s1">this.dep = undefined;</span><span class="s2">\n        </span><span class="s1">this.__v_isRef = true;</span><span class="s2">\n        </span><span class="s1">this[_a$1] = false;</span><span class="s2">\n        </span><span class="s1">this._dirty = true;</span><span class="s2">\n        </span><span class="s1">this.effect = new ReactiveEffect(getter, () =&gt; {</span><span class="s2">\n            </span><span class="s1">if (!this._dirty) {</span><span class="s2">\n                </span><span class="s1">this._dirty = true;</span><span class="s2">\n                </span><span class="s1">triggerRefValue(this);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">this.effect.computed = this;</span><span class="s2">\n        </span><span class="s1">this.effect.active = this._cacheable = !isSSR;</span><span class="s2">\n        </span><span class="s1">this[</span><span class="s2">\&quot;</span><span class="s1">__v_isReadonly</span><span class="s2">\&quot; </span><span class="s1">/* ReactiveFlags.IS_READONLY */] = isReadonly;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">get value() {</span><span class="s2">\n        </span><span class="s1">// the computed ref may get wrapped by other proxies e.g. readonly() #3376</span><span class="s2">\n        </span><span class="s1">const self = toRaw(this);</span><span class="s2">\n        </span><span class="s1">trackRefValue(self);</span><span class="s2">\n        </span><span class="s1">if (self._dirty || !self._cacheable) {</span><span class="s2">\n            </span><span class="s1">self._dirty = false;</span><span class="s2">\n            </span><span class="s1">self._value = self.effect.run();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return self._value;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">set value(newValue) {</span><span class="s2">\n        </span><span class="s1">this._setter(newValue);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">_a$1 = </span><span class="s2">\&quot;</span><span class="s1">__v_isReadonly</span><span class="s2">\&quot; </span><span class="s1">/* ReactiveFlags.IS_READONLY */;</span><span class="s2">\n</span><span class="s1">function computed(getterOrOptions, debugOptions, isSSR = false) {</span><span class="s2">\n    </span><span class="s1">let getter;</span><span class="s2">\n    </span><span class="s1">let setter;</span><span class="s2">\n    </span><span class="s1">const onlyGetter = isFunction(getterOrOptions);</span><span class="s2">\n    </span><span class="s1">if (onlyGetter) {</span><span class="s2">\n        </span><span class="s1">getter = getterOrOptions;</span><span class="s2">\n        </span><span class="s1">setter = (process.env.NODE_ENV !== 'production')</span><span class="s2">\n            </span><span class="s1">? () =&gt; {</span><span class="s2">\n                </span><span class="s1">console.warn('Write operation failed: computed value is readonly');</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">: NOOP;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">getter = getterOrOptions.get;</span><span class="s2">\n        </span><span class="s1">setter = getterOrOptions.set;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);</span><span class="s2">\n    </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp; debugOptions &amp;&amp; !isSSR) {</span><span class="s2">\n        </span><span class="s1">cRef.effect.onTrack = debugOptions.onTrack;</span><span class="s2">\n        </span><span class="s1">cRef.effect.onTrigger = debugOptions.onTrigger;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return cRef;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">var _a;</span><span class="s2">\n</span><span class="s1">const tick = /*#__PURE__*/ Promise.resolve();</span><span class="s2">\n</span><span class="s1">const queue = [];</span><span class="s2">\n</span><span class="s1">let queued = false;</span><span class="s2">\n</span><span class="s1">const scheduler = (fn) =&gt; {</span><span class="s2">\n    </span><span class="s1">queue.push(fn);</span><span class="s2">\n    </span><span class="s1">if (!queued) {</span><span class="s2">\n        </span><span class="s1">queued = true;</span><span class="s2">\n        </span><span class="s1">tick.then(flush);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">const flush = () =&gt; {</span><span class="s2">\n    </span><span class="s1">for (let i = 0; i &lt; queue.length; i++) {</span><span class="s2">\n        </span><span class="s1">queue[i]();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">queue.length = 0;</span><span class="s2">\n    </span><span class="s1">queued = false;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">class DeferredComputedRefImpl {</span><span class="s2">\n    </span><span class="s1">constructor(getter) {</span><span class="s2">\n        </span><span class="s1">this.dep = undefined;</span><span class="s2">\n        </span><span class="s1">this._dirty = true;</span><span class="s2">\n        </span><span class="s1">this.__v_isRef = true;</span><span class="s2">\n        </span><span class="s1">this[_a] = true;</span><span class="s2">\n        </span><span class="s1">let compareTarget;</span><span class="s2">\n        </span><span class="s1">let hasCompareTarget = false;</span><span class="s2">\n        </span><span class="s1">let scheduled = false;</span><span class="s2">\n        </span><span class="s1">this.effect = new ReactiveEffect(getter, (computedTrigger) =&gt; {</span><span class="s2">\n            </span><span class="s1">if (this.dep) {</span><span class="s2">\n                </span><span class="s1">if (computedTrigger) {</span><span class="s2">\n                    </span><span class="s1">compareTarget = this._value;</span><span class="s2">\n                    </span><span class="s1">hasCompareTarget = true;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else if (!scheduled) {</span><span class="s2">\n                    </span><span class="s1">const valueToCompare = hasCompareTarget ? compareTarget : this._value;</span><span class="s2">\n                    </span><span class="s1">scheduled = true;</span><span class="s2">\n                    </span><span class="s1">hasCompareTarget = false;</span><span class="s2">\n                    </span><span class="s1">scheduler(() =&gt; {</span><span class="s2">\n                        </span><span class="s1">if (this.effect.active &amp;&amp; this._get() !== valueToCompare) {</span><span class="s2">\n                            </span><span class="s1">triggerRefValue(this);</span><span class="s2">\n                        </span><span class="s1">}</span><span class="s2">\n                        </span><span class="s1">scheduled = false;</span><span class="s2">\n                    </span><span class="s1">});</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">// chained upstream computeds are notified synchronously to ensure</span><span class="s2">\n                </span><span class="s1">// value invalidation in case of sync access; normal effects are</span><span class="s2">\n                </span><span class="s1">// deferred to be triggered in scheduler.</span><span class="s2">\n                </span><span class="s1">for (const e of this.dep) {</span><span class="s2">\n                    </span><span class="s1">if (e.computed instanceof DeferredComputedRefImpl) {</span><span class="s2">\n                        </span><span class="s1">e.scheduler(true /* computedTrigger */);</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">this._dirty = true;</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">this.effect.computed = this;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">_get() {</span><span class="s2">\n        </span><span class="s1">if (this._dirty) {</span><span class="s2">\n            </span><span class="s1">this._dirty = false;</span><span class="s2">\n            </span><span class="s1">return (this._value = this.effect.run());</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return this._value;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">get value() {</span><span class="s2">\n        </span><span class="s1">trackRefValue(this);</span><span class="s2">\n        </span><span class="s1">// the computed ref may get wrapped by other proxies e.g. readonly() #3376</span><span class="s2">\n        </span><span class="s1">return toRaw(this)._get();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">_a = </span><span class="s2">\&quot;</span><span class="s1">__v_isReadonly</span><span class="s2">\&quot; </span><span class="s1">/* ReactiveFlags.IS_READONLY */;</span><span class="s2">\n</span><span class="s1">function deferredComputed(getter) {</span><span class="s2">\n    </span><span class="s1">return new DeferredComputedRefImpl(getter);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">export { EffectScope, ITERATE_KEY, ReactiveEffect, computed, customRef, deferredComputed, effect, effectScope, enableTracking, getCurrentScope, isProxy, isReactive, isReadonly, isRef, isShallow, markRaw, onScopeDispose, pauseTracking, proxyRefs, reactive, readonly, ref, resetTracking, shallowReactive, shallowReadonly, shallowRef, stop, toRaw, toRef, toRefs, track, trigger, triggerRef, unref };</span><span class="s2">\n</span><span class="s1">&quot;</span><span class="s2">, </span><span class="s1">&quot;import { pauseTracking, resetTracking, isRef, toRaw, getCurrentScope, isShallow as isShallow$1, isReactive, ReactiveEffect, ref, shallowReadonly, track, reactive, shallowReactive, trigger, isProxy, proxyRefs, markRaw, EffectScope, computed as computed$1, isReadonly } from '@vue/reactivity';</span><span class="s2">\n</span><span class="s1">export { EffectScope, ReactiveEffect, customRef, effect, effectScope, getCurrentScope, isProxy, isReactive, isReadonly, isRef, isShallow, markRaw, onScopeDispose, proxyRefs, reactive, readonly, ref, shallowReactive, shallowReadonly, shallowRef, stop, toRaw, toRef, toRefs, triggerRef, unref } from '@vue/reactivity';</span><span class="s2">\n</span><span class="s1">import { isString, isFunction, isPromise, isArray, NOOP, getGlobalThis, extend, EMPTY_OBJ, toHandlerKey, looseToNumber, hyphenate, camelize, isObject, isOn, hasOwn, isModelListener, toNumber, hasChanged, remove, isSet, isMap, isPlainObject, invokeArrayFns, isRegExp, isBuiltInDirective, capitalize, isGloballyWhitelisted, def, isReservedProp, EMPTY_ARR, toRawType, makeMap, NO, normalizeClass, normalizeStyle } from '@vue/shared';</span><span class="s2">\n</span><span class="s1">export { camelize, capitalize, normalizeClass, normalizeProps, normalizeStyle, toDisplayString, toHandlerKey } from '@vue/shared';</span><span class="s2">\n\n</span><span class="s1">const stack = [];</span><span class="s2">\n</span><span class="s1">function pushWarningContext(vnode) {</span><span class="s2">\n    </span><span class="s1">stack.push(vnode);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function popWarningContext() {</span><span class="s2">\n    </span><span class="s1">stack.pop();</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function warn(msg, ...args) {</span><span class="s2">\n    </span><span class="s1">if (!(process.env.NODE_ENV !== 'production'))</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">// avoid props formatting or warn handler tracking deps that might be mutated</span><span class="s2">\n    </span><span class="s1">// during patch, leading to infinite recursion.</span><span class="s2">\n    </span><span class="s1">pauseTracking();</span><span class="s2">\n    </span><span class="s1">const instance = stack.length ? stack[stack.length - 1].component : null;</span><span class="s2">\n    </span><span class="s1">const appWarnHandler = instance &amp;&amp; instance.appContext.config.warnHandler;</span><span class="s2">\n    </span><span class="s1">const trace = getComponentTrace();</span><span class="s2">\n    </span><span class="s1">if (appWarnHandler) {</span><span class="s2">\n        </span><span class="s1">callWithErrorHandling(appWarnHandler, instance, 11 /* ErrorCodes.APP_WARN_HANDLER */, [</span><span class="s2">\n            </span><span class="s1">msg + args.join(''),</span><span class="s2">\n            </span><span class="s1">instance &amp;&amp; instance.proxy,</span><span class="s2">\n            </span><span class="s1">trace</span><span class="s2">\n                </span><span class="s1">.map(({ vnode }) =&gt; `at &lt;${formatComponentName(instance, vnode.type)}&gt;`)</span><span class="s2">\n                </span><span class="s1">.join('</span><span class="s2">\\</span><span class="s1">n'),</span><span class="s2">\n            </span><span class="s1">trace</span><span class="s2">\n        </span><span class="s1">]);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">const warnArgs = [`[Vue warn]: ${msg}`, ...args];</span><span class="s2">\n        </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n        </span><span class="s1">if (trace.length &amp;&amp;</span><span class="s2">\n            </span><span class="s1">// avoid spamming console during tests</span><span class="s2">\n            </span><span class="s1">!false) {</span><span class="s2">\n            </span><span class="s1">warnArgs.push(`</span><span class="s2">\\</span><span class="s1">n`, ...formatTrace(trace));</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">console.warn(...warnArgs);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">resetTracking();</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getComponentTrace() {</span><span class="s2">\n    </span><span class="s1">let currentVNode = stack[stack.length - 1];</span><span class="s2">\n    </span><span class="s1">if (!currentVNode) {</span><span class="s2">\n        </span><span class="s1">return [];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// we can't just use the stack because it will be incomplete during updates</span><span class="s2">\n    </span><span class="s1">// that did not start from the root. Re-construct the parent chain using</span><span class="s2">\n    </span><span class="s1">// instance parent pointers.</span><span class="s2">\n    </span><span class="s1">const normalizedStack = [];</span><span class="s2">\n    </span><span class="s1">while (currentVNode) {</span><span class="s2">\n        </span><span class="s1">const last = normalizedStack[0];</span><span class="s2">\n        </span><span class="s1">if (last &amp;&amp; last.vnode === currentVNode) {</span><span class="s2">\n            </span><span class="s1">last.recurseCount++;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">normalizedStack.push({</span><span class="s2">\n                </span><span class="s1">vnode: currentVNode,</span><span class="s2">\n                </span><span class="s1">recurseCount: 0</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">const parentInstance = currentVNode.component &amp;&amp; currentVNode.component.parent;</span><span class="s2">\n        </span><span class="s1">currentVNode = parentInstance &amp;&amp; parentInstance.vnode;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return normalizedStack;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/* istanbul ignore next */</span><span class="s2">\n</span><span class="s1">function formatTrace(trace) {</span><span class="s2">\n    </span><span class="s1">const logs = [];</span><span class="s2">\n    </span><span class="s1">trace.forEach((entry, i) =&gt; {</span><span class="s2">\n        </span><span class="s1">logs.push(...(i === 0 ? [] : [`</span><span class="s2">\\</span><span class="s1">n`]), ...formatTraceEntry(entry));</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">return logs;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function formatTraceEntry({ vnode, recurseCount }) {</span><span class="s2">\n    </span><span class="s1">const postfix = recurseCount &gt; 0 ? `... (${recurseCount} recursive calls)` : ``;</span><span class="s2">\n    </span><span class="s1">const isRoot = vnode.component ? vnode.component.parent == null : false;</span><span class="s2">\n    </span><span class="s1">const open = ` at &lt;${formatComponentName(vnode.component, vnode.type, isRoot)}`;</span><span class="s2">\n    </span><span class="s1">const close = `&gt;` + postfix;</span><span class="s2">\n    </span><span class="s1">return vnode.props</span><span class="s2">\n        </span><span class="s1">? [open, ...formatProps(vnode.props), close]</span><span class="s2">\n        </span><span class="s1">: [open + close];</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/* istanbul ignore next */</span><span class="s2">\n</span><span class="s1">function formatProps(props) {</span><span class="s2">\n    </span><span class="s1">const res = [];</span><span class="s2">\n    </span><span class="s1">const keys = Object.keys(props);</span><span class="s2">\n    </span><span class="s1">keys.slice(0, 3).forEach(key =&gt; {</span><span class="s2">\n        </span><span class="s1">res.push(...formatProp(key, props[key]));</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">if (keys.length &gt; 3) {</span><span class="s2">\n        </span><span class="s1">res.push(` ...`);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return res;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/* istanbul ignore next */</span><span class="s2">\n</span><span class="s1">function formatProp(key, value, raw) {</span><span class="s2">\n    </span><span class="s1">if (isString(value)) {</span><span class="s2">\n        </span><span class="s1">value = JSON.stringify(value);</span><span class="s2">\n        </span><span class="s1">return raw ? value : [`${key}=${value}`];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (typeof value === 'number' ||</span><span class="s2">\n        </span><span class="s1">typeof value === 'boolean' ||</span><span class="s2">\n        </span><span class="s1">value == null) {</span><span class="s2">\n        </span><span class="s1">return raw ? value : [`${key}=${value}`];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (isRef(value)) {</span><span class="s2">\n        </span><span class="s1">value = formatProp(key, toRaw(value.value), true);</span><span class="s2">\n        </span><span class="s1">return raw ? value : [`${key}=Ref&lt;`, value, `&gt;`];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (isFunction(value)) {</span><span class="s2">\n        </span><span class="s1">return [`${key}=fn${value.name ? `&lt;${value.name}&gt;` : ``}`];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">value = toRaw(value);</span><span class="s2">\n        </span><span class="s1">return raw ? value : [`${key}=`, value];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* @internal</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function assertNumber(val, type) {</span><span class="s2">\n    </span><span class="s1">if (!(process.env.NODE_ENV !== 'production'))</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">if (val === undefined) {</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (typeof val !== 'number') {</span><span class="s2">\n        </span><span class="s1">warn(`${type} is not a valid number - ` + `got ${JSON.stringify(val)}.`);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (isNaN(val)) {</span><span class="s2">\n        </span><span class="s1">warn(`${type} is NaN - ` + 'the duration expression might be incorrect.');</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">const ErrorTypeStrings = {</span><span class="s2">\n    </span><span class="s1">[</span><span class="s2">\&quot;</span><span class="s1">sp</span><span class="s2">\&quot; </span><span class="s1">/* LifecycleHooks.SERVER_PREFETCH */]: 'serverPrefetch hook',</span><span class="s2">\n    </span><span class="s1">[</span><span class="s2">\&quot;</span><span class="s1">bc</span><span class="s2">\&quot; </span><span class="s1">/* LifecycleHooks.BEFORE_CREATE */]: 'beforeCreate hook',</span><span class="s2">\n    </span><span class="s1">[</span><span class="s2">\&quot;</span><span class="s1">c</span><span class="s2">\&quot; </span><span class="s1">/* LifecycleHooks.CREATED */]: 'created hook',</span><span class="s2">\n    </span><span class="s1">[</span><span class="s2">\&quot;</span><span class="s1">bm</span><span class="s2">\&quot; </span><span class="s1">/* LifecycleHooks.BEFORE_MOUNT */]: 'beforeMount hook',</span><span class="s2">\n    </span><span class="s1">[</span><span class="s2">\&quot;</span><span class="s1">m</span><span class="s2">\&quot; </span><span class="s1">/* LifecycleHooks.MOUNTED */]: 'mounted hook',</span><span class="s2">\n    </span><span class="s1">[</span><span class="s2">\&quot;</span><span class="s1">bu</span><span class="s2">\&quot; </span><span class="s1">/* LifecycleHooks.BEFORE_UPDATE */]: 'beforeUpdate hook',</span><span class="s2">\n    </span><span class="s1">[</span><span class="s2">\&quot;</span><span class="s1">u</span><span class="s2">\&quot; </span><span class="s1">/* LifecycleHooks.UPDATED */]: 'updated',</span><span class="s2">\n    </span><span class="s1">[</span><span class="s2">\&quot;</span><span class="s1">bum</span><span class="s2">\&quot; </span><span class="s1">/* LifecycleHooks.BEFORE_UNMOUNT */]: 'beforeUnmount hook',</span><span class="s2">\n    </span><span class="s1">[</span><span class="s2">\&quot;</span><span class="s1">um</span><span class="s2">\&quot; </span><span class="s1">/* LifecycleHooks.UNMOUNTED */]: 'unmounted hook',</span><span class="s2">\n    </span><span class="s1">[</span><span class="s2">\&quot;</span><span class="s1">a</span><span class="s2">\&quot; </span><span class="s1">/* LifecycleHooks.ACTIVATED */]: 'activated hook',</span><span class="s2">\n    </span><span class="s1">[</span><span class="s2">\&quot;</span><span class="s1">da</span><span class="s2">\&quot; </span><span class="s1">/* LifecycleHooks.DEACTIVATED */]: 'deactivated hook',</span><span class="s2">\n    </span><span class="s1">[</span><span class="s2">\&quot;</span><span class="s1">ec</span><span class="s2">\&quot; </span><span class="s1">/* LifecycleHooks.ERROR_CAPTURED */]: 'errorCaptured hook',</span><span class="s2">\n    </span><span class="s1">[</span><span class="s2">\&quot;</span><span class="s1">rtc</span><span class="s2">\&quot; </span><span class="s1">/* LifecycleHooks.RENDER_TRACKED */]: 'renderTracked hook',</span><span class="s2">\n    </span><span class="s1">[</span><span class="s2">\&quot;</span><span class="s1">rtg</span><span class="s2">\&quot; </span><span class="s1">/* LifecycleHooks.RENDER_TRIGGERED */]: 'renderTriggered hook',</span><span class="s2">\n    </span><span class="s1">[0 /* ErrorCodes.SETUP_FUNCTION */]: 'setup function',</span><span class="s2">\n    </span><span class="s1">[1 /* ErrorCodes.RENDER_FUNCTION */]: 'render function',</span><span class="s2">\n    </span><span class="s1">[2 /* ErrorCodes.WATCH_GETTER */]: 'watcher getter',</span><span class="s2">\n    </span><span class="s1">[3 /* ErrorCodes.WATCH_CALLBACK */]: 'watcher callback',</span><span class="s2">\n    </span><span class="s1">[4 /* ErrorCodes.WATCH_CLEANUP */]: 'watcher cleanup function',</span><span class="s2">\n    </span><span class="s1">[5 /* ErrorCodes.NATIVE_EVENT_HANDLER */]: 'native event handler',</span><span class="s2">\n    </span><span class="s1">[6 /* ErrorCodes.COMPONENT_EVENT_HANDLER */]: 'component event handler',</span><span class="s2">\n    </span><span class="s1">[7 /* ErrorCodes.VNODE_HOOK */]: 'vnode hook',</span><span class="s2">\n    </span><span class="s1">[8 /* ErrorCodes.DIRECTIVE_HOOK */]: 'directive hook',</span><span class="s2">\n    </span><span class="s1">[9 /* ErrorCodes.TRANSITION_HOOK */]: 'transition hook',</span><span class="s2">\n    </span><span class="s1">[10 /* ErrorCodes.APP_ERROR_HANDLER */]: 'app errorHandler',</span><span class="s2">\n    </span><span class="s1">[11 /* ErrorCodes.APP_WARN_HANDLER */]: 'app warnHandler',</span><span class="s2">\n    </span><span class="s1">[12 /* ErrorCodes.FUNCTION_REF */]: 'ref function',</span><span class="s2">\n    </span><span class="s1">[13 /* ErrorCodes.ASYNC_COMPONENT_LOADER */]: 'async component loader',</span><span class="s2">\n    </span><span class="s1">[14 /* ErrorCodes.SCHEDULER */]: 'scheduler flush. This is likely a Vue internals bug. ' +</span><span class="s2">\n        </span><span class="s1">'Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core'</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">function callWithErrorHandling(fn, instance, type, args) {</span><span class="s2">\n    </span><span class="s1">let res;</span><span class="s2">\n    </span><span class="s1">try {</span><span class="s2">\n        </span><span class="s1">res = args ? fn(...args) : fn();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">catch (err) {</span><span class="s2">\n        </span><span class="s1">handleError(err, instance, type);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return res;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function callWithAsyncErrorHandling(fn, instance, type, args) {</span><span class="s2">\n    </span><span class="s1">if (isFunction(fn)) {</span><span class="s2">\n        </span><span class="s1">const res = callWithErrorHandling(fn, instance, type, args);</span><span class="s2">\n        </span><span class="s1">if (res &amp;&amp; isPromise(res)) {</span><span class="s2">\n            </span><span class="s1">res.catch(err =&gt; {</span><span class="s2">\n                </span><span class="s1">handleError(err, instance, type);</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return res;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">const values = [];</span><span class="s2">\n    </span><span class="s1">for (let i = 0; i &lt; fn.length; i++) {</span><span class="s2">\n        </span><span class="s1">values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return values;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function handleError(err, instance, type, throwInDev = true) {</span><span class="s2">\n    </span><span class="s1">const contextVNode = instance ? instance.vnode : null;</span><span class="s2">\n    </span><span class="s1">if (instance) {</span><span class="s2">\n        </span><span class="s1">let cur = instance.parent;</span><span class="s2">\n        </span><span class="s1">// the exposed instance is the render proxy to keep it consistent with 2.x</span><span class="s2">\n        </span><span class="s1">const exposedInstance = instance.proxy;</span><span class="s2">\n        </span><span class="s1">// in production the hook receives only the error code</span><span class="s2">\n        </span><span class="s1">const errorInfo = (process.env.NODE_ENV !== 'production') ? ErrorTypeStrings[type] : type;</span><span class="s2">\n        </span><span class="s1">while (cur) {</span><span class="s2">\n            </span><span class="s1">const errorCapturedHooks = cur.ec;</span><span class="s2">\n            </span><span class="s1">if (errorCapturedHooks) {</span><span class="s2">\n                </span><span class="s1">for (let i = 0; i &lt; errorCapturedHooks.length; i++) {</span><span class="s2">\n                    </span><span class="s1">if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {</span><span class="s2">\n                        </span><span class="s1">return;</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">cur = cur.parent;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// app-level handling</span><span class="s2">\n        </span><span class="s1">const appErrorHandler = instance.appContext.config.errorHandler;</span><span class="s2">\n        </span><span class="s1">if (appErrorHandler) {</span><span class="s2">\n            </span><span class="s1">callWithErrorHandling(appErrorHandler, null, 10 /* ErrorCodes.APP_ERROR_HANDLER */, [err, exposedInstance, errorInfo]);</span><span class="s2">\n            </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">logError(err, type, contextVNode, throwInDev);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function logError(err, type, contextVNode, throwInDev = true) {</span><span class="s2">\n    </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n        </span><span class="s1">const info = ErrorTypeStrings[type];</span><span class="s2">\n        </span><span class="s1">if (contextVNode) {</span><span class="s2">\n            </span><span class="s1">pushWarningContext(contextVNode);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">warn(`Unhandled error${info ? ` during execution of ${info}` : ``}`);</span><span class="s2">\n        </span><span class="s1">if (contextVNode) {</span><span class="s2">\n            </span><span class="s1">popWarningContext();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// crash in dev by default so it's more noticeable</span><span class="s2">\n        </span><span class="s1">if (throwInDev) {</span><span class="s2">\n            </span><span class="s1">throw err;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">console.error(err);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">// recover in prod to reduce the impact on end-user</span><span class="s2">\n        </span><span class="s1">console.error(err);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">let isFlushing = false;</span><span class="s2">\n</span><span class="s1">let isFlushPending = false;</span><span class="s2">\n</span><span class="s1">const queue = [];</span><span class="s2">\n</span><span class="s1">let flushIndex = 0;</span><span class="s2">\n</span><span class="s1">const pendingPostFlushCbs = [];</span><span class="s2">\n</span><span class="s1">let activePostFlushCbs = null;</span><span class="s2">\n</span><span class="s1">let postFlushIndex = 0;</span><span class="s2">\n</span><span class="s1">const resolvedPromise = /*#__PURE__*/ Promise.resolve();</span><span class="s2">\n</span><span class="s1">let currentFlushPromise = null;</span><span class="s2">\n</span><span class="s1">const RECURSION_LIMIT = 100;</span><span class="s2">\n</span><span class="s1">function nextTick(fn) {</span><span class="s2">\n    </span><span class="s1">const p = currentFlushPromise || resolvedPromise;</span><span class="s2">\n    </span><span class="s1">return fn ? p.then(this ? fn.bind(this) : fn) : p;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// #2768</span><span class="s2">\n</span><span class="s1">// Use binary-search to find a suitable position in the queue,</span><span class="s2">\n</span><span class="s1">// so that the queue maintains the increasing order of job's id,</span><span class="s2">\n</span><span class="s1">// which can prevent the job from being skipped and also can avoid repeated patching.</span><span class="s2">\n</span><span class="s1">function findInsertionIndex(id) {</span><span class="s2">\n    </span><span class="s1">// the start index should be `flushIndex + 1`</span><span class="s2">\n    </span><span class="s1">let start = flushIndex + 1;</span><span class="s2">\n    </span><span class="s1">let end = queue.length;</span><span class="s2">\n    </span><span class="s1">while (start &lt; end) {</span><span class="s2">\n        </span><span class="s1">const middle = (start + end) &gt;&gt;&gt; 1;</span><span class="s2">\n        </span><span class="s1">const middleJobId = getId(queue[middle]);</span><span class="s2">\n        </span><span class="s1">middleJobId &lt; id ? (start = middle + 1) : (end = middle);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return start;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function queueJob(job) {</span><span class="s2">\n    </span><span class="s1">// the dedupe search uses the startIndex argument of Array.includes()</span><span class="s2">\n    </span><span class="s1">// by default the search index includes the current job that is being run</span><span class="s2">\n    </span><span class="s1">// so it cannot recursively trigger itself again.</span><span class="s2">\n    </span><span class="s1">// if the job is a watch() callback, the search will start with a +1 index to</span><span class="s2">\n    </span><span class="s1">// allow it recursively trigger itself - it is the user's responsibility to</span><span class="s2">\n    </span><span class="s1">// ensure it doesn't end up in an infinite loop.</span><span class="s2">\n    </span><span class="s1">if (!queue.length ||</span><span class="s2">\n        </span><span class="s1">!queue.includes(job, isFlushing &amp;&amp; job.allowRecurse ? flushIndex + 1 : flushIndex)) {</span><span class="s2">\n        </span><span class="s1">if (job.id == null) {</span><span class="s2">\n            </span><span class="s1">queue.push(job);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">queue.splice(findInsertionIndex(job.id), 0, job);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">queueFlush();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function queueFlush() {</span><span class="s2">\n    </span><span class="s1">if (!isFlushing &amp;&amp; !isFlushPending) {</span><span class="s2">\n        </span><span class="s1">isFlushPending = true;</span><span class="s2">\n        </span><span class="s1">currentFlushPromise = resolvedPromise.then(flushJobs);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function invalidateJob(job) {</span><span class="s2">\n    </span><span class="s1">const i = queue.indexOf(job);</span><span class="s2">\n    </span><span class="s1">if (i &gt; flushIndex) {</span><span class="s2">\n        </span><span class="s1">queue.splice(i, 1);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function queuePostFlushCb(cb) {</span><span class="s2">\n    </span><span class="s1">if (!isArray(cb)) {</span><span class="s2">\n        </span><span class="s1">if (!activePostFlushCbs ||</span><span class="s2">\n            </span><span class="s1">!activePostFlushCbs.includes(cb, cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex)) {</span><span class="s2">\n            </span><span class="s1">pendingPostFlushCbs.push(cb);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">// if cb is an array, it is a component lifecycle hook which can only be</span><span class="s2">\n        </span><span class="s1">// triggered by a job, which is already deduped in the main queue, so</span><span class="s2">\n        </span><span class="s1">// we can skip duplicate check here to improve perf</span><span class="s2">\n        </span><span class="s1">pendingPostFlushCbs.push(...cb);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">queueFlush();</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function flushPreFlushCbs(seen, </span><span class="s2">\n</span><span class="s1">// if currently flushing, skip the current job itself</span><span class="s2">\n</span><span class="s1">i = isFlushing ? flushIndex + 1 : 0) {</span><span class="s2">\n    </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n        </span><span class="s1">seen = seen || new Map();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">for (; i &lt; queue.length; i++) {</span><span class="s2">\n        </span><span class="s1">const cb = queue[i];</span><span class="s2">\n        </span><span class="s1">if (cb &amp;&amp; cb.pre) {</span><span class="s2">\n            </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp; checkRecursiveUpdates(seen, cb)) {</span><span class="s2">\n                </span><span class="s1">continue;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">queue.splice(i, 1);</span><span class="s2">\n            </span><span class="s1">i--;</span><span class="s2">\n            </span><span class="s1">cb();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function flushPostFlushCbs(seen) {</span><span class="s2">\n    </span><span class="s1">if (pendingPostFlushCbs.length) {</span><span class="s2">\n        </span><span class="s1">const deduped = [...new Set(pendingPostFlushCbs)];</span><span class="s2">\n        </span><span class="s1">pendingPostFlushCbs.length = 0;</span><span class="s2">\n        </span><span class="s1">// #1947 already has active queue, nested flushPostFlushCbs call</span><span class="s2">\n        </span><span class="s1">if (activePostFlushCbs) {</span><span class="s2">\n            </span><span class="s1">activePostFlushCbs.push(...deduped);</span><span class="s2">\n            </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">activePostFlushCbs = deduped;</span><span class="s2">\n        </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n            </span><span class="s1">seen = seen || new Map();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">activePostFlushCbs.sort((a, b) =&gt; getId(a) - getId(b));</span><span class="s2">\n        </span><span class="s1">for (postFlushIndex = 0; postFlushIndex &lt; activePostFlushCbs.length; postFlushIndex++) {</span><span class="s2">\n            </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp;</span><span class="s2">\n                </span><span class="s1">checkRecursiveUpdates(seen, activePostFlushCbs[postFlushIndex])) {</span><span class="s2">\n                </span><span class="s1">continue;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">activePostFlushCbs[postFlushIndex]();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">activePostFlushCbs = null;</span><span class="s2">\n        </span><span class="s1">postFlushIndex = 0;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">const getId = (job) =&gt; job.id == null ? Infinity : job.id;</span><span class="s2">\n</span><span class="s1">const comparator = (a, b) =&gt; {</span><span class="s2">\n    </span><span class="s1">const diff = getId(a) - getId(b);</span><span class="s2">\n    </span><span class="s1">if (diff === 0) {</span><span class="s2">\n        </span><span class="s1">if (a.pre &amp;&amp; !b.pre)</span><span class="s2">\n            </span><span class="s1">return -1;</span><span class="s2">\n        </span><span class="s1">if (b.pre &amp;&amp; !a.pre)</span><span class="s2">\n            </span><span class="s1">return 1;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return diff;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">function flushJobs(seen) {</span><span class="s2">\n    </span><span class="s1">isFlushPending = false;</span><span class="s2">\n    </span><span class="s1">isFlushing = true;</span><span class="s2">\n    </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n        </span><span class="s1">seen = seen || new Map();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// Sort queue before flush.</span><span class="s2">\n    </span><span class="s1">// This ensures that:</span><span class="s2">\n    </span><span class="s1">// 1. Components are updated from parent to child. (because parent is always</span><span class="s2">\n    </span><span class="s1">//    created before the child so its render effect will have smaller</span><span class="s2">\n    </span><span class="s1">//    priority number)</span><span class="s2">\n    </span><span class="s1">// 2. If a component is unmounted during a parent component's update,</span><span class="s2">\n    </span><span class="s1">//    its update can be skipped.</span><span class="s2">\n    </span><span class="s1">queue.sort(comparator);</span><span class="s2">\n    </span><span class="s1">// conditional usage of checkRecursiveUpdate must be determined out of</span><span class="s2">\n    </span><span class="s1">// try ... catch block since Rollup by default de-optimizes treeshaking</span><span class="s2">\n    </span><span class="s1">// inside try-catch. This can leave all warning code unshaked. Although</span><span class="s2">\n    </span><span class="s1">// they would get eventually shaken by a minifier like terser, some minifiers</span><span class="s2">\n    </span><span class="s1">// would fail to do that (e.g. https://github.com/evanw/esbuild/issues/1610)</span><span class="s2">\n    </span><span class="s1">const check = (process.env.NODE_ENV !== 'production')</span><span class="s2">\n        </span><span class="s1">? (job) =&gt; checkRecursiveUpdates(seen, job)</span><span class="s2">\n        </span><span class="s1">: NOOP;</span><span class="s2">\n    </span><span class="s1">try {</span><span class="s2">\n        </span><span class="s1">for (flushIndex = 0; flushIndex &lt; queue.length; flushIndex++) {</span><span class="s2">\n            </span><span class="s1">const job = queue[flushIndex];</span><span class="s2">\n            </span><span class="s1">if (job &amp;&amp; job.active !== false) {</span><span class="s2">\n                </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp; check(job)) {</span><span class="s2">\n                    </span><span class="s1">continue;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">// console.log(`running:`, job.id)</span><span class="s2">\n                </span><span class="s1">callWithErrorHandling(job, null, 14 /* ErrorCodes.SCHEDULER */);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">finally {</span><span class="s2">\n        </span><span class="s1">flushIndex = 0;</span><span class="s2">\n        </span><span class="s1">queue.length = 0;</span><span class="s2">\n        </span><span class="s1">flushPostFlushCbs(seen);</span><span class="s2">\n        </span><span class="s1">isFlushing = false;</span><span class="s2">\n        </span><span class="s1">currentFlushPromise = null;</span><span class="s2">\n        </span><span class="s1">// some postFlushCb queued jobs!</span><span class="s2">\n        </span><span class="s1">// keep flushing until it drains.</span><span class="s2">\n        </span><span class="s1">if (queue.length || pendingPostFlushCbs.length) {</span><span class="s2">\n            </span><span class="s1">flushJobs(seen);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function checkRecursiveUpdates(seen, fn) {</span><span class="s2">\n    </span><span class="s1">if (!seen.has(fn)) {</span><span class="s2">\n        </span><span class="s1">seen.set(fn, 1);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">const count = seen.get(fn);</span><span class="s2">\n        </span><span class="s1">if (count &gt; RECURSION_LIMIT) {</span><span class="s2">\n            </span><span class="s1">const instance = fn.ownerInstance;</span><span class="s2">\n            </span><span class="s1">const componentName = instance &amp;&amp; getComponentName(instance.type);</span><span class="s2">\n            </span><span class="s1">warn(`Maximum recursive updates exceeded${componentName ? ` in component &lt;${componentName}&gt;` : ``}. ` +</span><span class="s2">\n                </span><span class="s1">`This means you have a reactive effect that is mutating its own ` +</span><span class="s2">\n                </span><span class="s1">`dependencies and thus recursively triggering itself. Possible sources ` +</span><span class="s2">\n                </span><span class="s1">`include component template, render function, updated hook or ` +</span><span class="s2">\n                </span><span class="s1">`watcher source function.`);</span><span class="s2">\n            </span><span class="s1">return true;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">seen.set(fn, count + 1);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/* eslint-disable no-restricted-globals */</span><span class="s2">\n</span><span class="s1">let isHmrUpdating = false;</span><span class="s2">\n</span><span class="s1">const hmrDirtyComponents = new Set();</span><span class="s2">\n</span><span class="s1">// Expose the HMR runtime on the global object</span><span class="s2">\n</span><span class="s1">// This makes it entirely tree-shakable without polluting the exports and makes</span><span class="s2">\n</span><span class="s1">// it easier to be used in toolings like vue-loader</span><span class="s2">\n</span><span class="s1">// Note: for a component to be eligible for HMR it also needs the __hmrId option</span><span class="s2">\n</span><span class="s1">// to be set so that its instances can be registered / removed.</span><span class="s2">\n</span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n    </span><span class="s1">getGlobalThis().__VUE_HMR_RUNTIME__ = {</span><span class="s2">\n        </span><span class="s1">createRecord: tryWrap(createRecord),</span><span class="s2">\n        </span><span class="s1">rerender: tryWrap(rerender),</span><span class="s2">\n        </span><span class="s1">reload: tryWrap(reload)</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">const map = new Map();</span><span class="s2">\n</span><span class="s1">function registerHMR(instance) {</span><span class="s2">\n    </span><span class="s1">const id = instance.type.__hmrId;</span><span class="s2">\n    </span><span class="s1">let record = map.get(id);</span><span class="s2">\n    </span><span class="s1">if (!record) {</span><span class="s2">\n        </span><span class="s1">createRecord(id, instance.type);</span><span class="s2">\n        </span><span class="s1">record = map.get(id);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">record.instances.add(instance);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function unregisterHMR(instance) {</span><span class="s2">\n    </span><span class="s1">map.get(instance.type.__hmrId).instances.delete(instance);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createRecord(id, initialDef) {</span><span class="s2">\n    </span><span class="s1">if (map.has(id)) {</span><span class="s2">\n        </span><span class="s1">return false;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">map.set(id, {</span><span class="s2">\n        </span><span class="s1">initialDef: normalizeClassComponent(initialDef),</span><span class="s2">\n        </span><span class="s1">instances: new Set()</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">return true;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function normalizeClassComponent(component) {</span><span class="s2">\n    </span><span class="s1">return isClassComponent(component) ? component.__vccOpts : component;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function rerender(id, newRender) {</span><span class="s2">\n    </span><span class="s1">const record = map.get(id);</span><span class="s2">\n    </span><span class="s1">if (!record) {</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// update initial record (for not-yet-rendered component)</span><span class="s2">\n    </span><span class="s1">record.initialDef.render = newRender;</span><span class="s2">\n    </span><span class="s1">[...record.instances].forEach(instance =&gt; {</span><span class="s2">\n        </span><span class="s1">if (newRender) {</span><span class="s2">\n            </span><span class="s1">instance.render = newRender;</span><span class="s2">\n            </span><span class="s1">normalizeClassComponent(instance.type).render = newRender;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">instance.renderCache = [];</span><span class="s2">\n        </span><span class="s1">// this flag forces child components with slot content to update</span><span class="s2">\n        </span><span class="s1">isHmrUpdating = true;</span><span class="s2">\n        </span><span class="s1">instance.update();</span><span class="s2">\n        </span><span class="s1">isHmrUpdating = false;</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function reload(id, newComp) {</span><span class="s2">\n    </span><span class="s1">const record = map.get(id);</span><span class="s2">\n    </span><span class="s1">if (!record)</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">newComp = normalizeClassComponent(newComp);</span><span class="s2">\n    </span><span class="s1">// update initial def (for not-yet-rendered components)</span><span class="s2">\n    </span><span class="s1">updateComponentDef(record.initialDef, newComp);</span><span class="s2">\n    </span><span class="s1">// create a snapshot which avoids the set being mutated during updates</span><span class="s2">\n    </span><span class="s1">const instances = [...record.instances];</span><span class="s2">\n    </span><span class="s1">for (const instance of instances) {</span><span class="s2">\n        </span><span class="s1">const oldComp = normalizeClassComponent(instance.type);</span><span class="s2">\n        </span><span class="s1">if (!hmrDirtyComponents.has(oldComp)) {</span><span class="s2">\n            </span><span class="s1">// 1. Update existing comp definition to match new one</span><span class="s2">\n            </span><span class="s1">if (oldComp !== record.initialDef) {</span><span class="s2">\n                </span><span class="s1">updateComponentDef(oldComp, newComp);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">// 2. mark definition dirty. This forces the renderer to replace the</span><span class="s2">\n            </span><span class="s1">// component on patch.</span><span class="s2">\n            </span><span class="s1">hmrDirtyComponents.add(oldComp);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// 3. invalidate options resolution cache</span><span class="s2">\n        </span><span class="s1">instance.appContext.optionsCache.delete(instance.type);</span><span class="s2">\n        </span><span class="s1">// 4. actually update</span><span class="s2">\n        </span><span class="s1">if (instance.ceReload) {</span><span class="s2">\n            </span><span class="s1">// custom element</span><span class="s2">\n            </span><span class="s1">hmrDirtyComponents.add(oldComp);</span><span class="s2">\n            </span><span class="s1">instance.ceReload(newComp.styles);</span><span class="s2">\n            </span><span class="s1">hmrDirtyComponents.delete(oldComp);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (instance.parent) {</span><span class="s2">\n            </span><span class="s1">// 4. Force the parent instance to re-render. This will cause all updated</span><span class="s2">\n            </span><span class="s1">// components to be unmounted and re-mounted. Queue the update so that we</span><span class="s2">\n            </span><span class="s1">// don't end up forcing the same parent to re-render multiple times.</span><span class="s2">\n            </span><span class="s1">queueJob(instance.parent.update);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (instance.appContext.reload) {</span><span class="s2">\n            </span><span class="s1">// root instance mounted via createApp() has a reload method</span><span class="s2">\n            </span><span class="s1">instance.appContext.reload();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (typeof window !== 'undefined') {</span><span class="s2">\n            </span><span class="s1">// root instance inside tree created via raw render(). Force reload.</span><span class="s2">\n            </span><span class="s1">window.location.reload();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">console.warn('[HMR] Root or manually mounted instance modified. Full reload required.');</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// 5. make sure to cleanup dirty hmr components after update</span><span class="s2">\n    </span><span class="s1">queuePostFlushCb(() =&gt; {</span><span class="s2">\n        </span><span class="s1">for (const instance of instances) {</span><span class="s2">\n            </span><span class="s1">hmrDirtyComponents.delete(normalizeClassComponent(instance.type));</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function updateComponentDef(oldComp, newComp) {</span><span class="s2">\n    </span><span class="s1">extend(oldComp, newComp);</span><span class="s2">\n    </span><span class="s1">for (const key in oldComp) {</span><span class="s2">\n        </span><span class="s1">if (key !== '__file' &amp;&amp; !(key in newComp)) {</span><span class="s2">\n            </span><span class="s1">delete oldComp[key];</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function tryWrap(fn) {</span><span class="s2">\n    </span><span class="s1">return (id, arg) =&gt; {</span><span class="s2">\n        </span><span class="s1">try {</span><span class="s2">\n            </span><span class="s1">return fn(id, arg);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">catch (e) {</span><span class="s2">\n            </span><span class="s1">console.error(e);</span><span class="s2">\n            </span><span class="s1">console.warn(`[HMR] Something went wrong during Vue component hot-reload. ` +</span><span class="s2">\n                </span><span class="s1">`Full reload required.`);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">let devtools;</span><span class="s2">\n</span><span class="s1">let buffer = [];</span><span class="s2">\n</span><span class="s1">let devtoolsNotInstalled = false;</span><span class="s2">\n</span><span class="s1">function emit$1(event, ...args) {</span><span class="s2">\n    </span><span class="s1">if (devtools) {</span><span class="s2">\n        </span><span class="s1">devtools.emit(event, ...args);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (!devtoolsNotInstalled) {</span><span class="s2">\n        </span><span class="s1">buffer.push({ event, args });</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function setDevtoolsHook(hook, target) {</span><span class="s2">\n    </span><span class="s1">var _a, _b;</span><span class="s2">\n    </span><span class="s1">devtools = hook;</span><span class="s2">\n    </span><span class="s1">if (devtools) {</span><span class="s2">\n        </span><span class="s1">devtools.enabled = true;</span><span class="s2">\n        </span><span class="s1">buffer.forEach(({ event, args }) =&gt; devtools.emit(event, ...args));</span><span class="s2">\n        </span><span class="s1">buffer = [];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (</span><span class="s2">\n    </span><span class="s1">// handle late devtools injection - only do this if we are in an actual</span><span class="s2">\n    </span><span class="s1">// browser environment to avoid the timer handle stalling test runner exit</span><span class="s2">\n    </span><span class="s1">// (#4815)</span><span class="s2">\n    </span><span class="s1">typeof window !== 'undefined' &amp;&amp;</span><span class="s2">\n        </span><span class="s1">// some envs mock window but not fully</span><span class="s2">\n        </span><span class="s1">window.HTMLElement &amp;&amp;</span><span class="s2">\n        </span><span class="s1">// also exclude jsdom</span><span class="s2">\n        </span><span class="s1">!((_b = (_a = window.navigator) === null || _a === void 0 ? void 0 : _a.userAgent) === null || _b === void 0 ? void 0 : _b.includes('jsdom'))) {</span><span class="s2">\n        </span><span class="s1">const replay = (target.__VUE_DEVTOOLS_HOOK_REPLAY__ =</span><span class="s2">\n            </span><span class="s1">target.__VUE_DEVTOOLS_HOOK_REPLAY__ || []);</span><span class="s2">\n        </span><span class="s1">replay.push((newHook) =&gt; {</span><span class="s2">\n            </span><span class="s1">setDevtoolsHook(newHook, target);</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">// clear buffer after 3s - the user probably doesn't have devtools installed</span><span class="s2">\n        </span><span class="s1">// at all, and keeping the buffer will cause memory leaks (#4738)</span><span class="s2">\n        </span><span class="s1">setTimeout(() =&gt; {</span><span class="s2">\n            </span><span class="s1">if (!devtools) {</span><span class="s2">\n                </span><span class="s1">target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;</span><span class="s2">\n                </span><span class="s1">devtoolsNotInstalled = true;</span><span class="s2">\n                </span><span class="s1">buffer = [];</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}, 3000);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">// non-browser env, assume not installed</span><span class="s2">\n        </span><span class="s1">devtoolsNotInstalled = true;</span><span class="s2">\n        </span><span class="s1">buffer = [];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function devtoolsInitApp(app, version) {</span><span class="s2">\n    </span><span class="s1">emit$1(</span><span class="s2">\&quot;</span><span class="s1">app:init</span><span class="s2">\&quot; </span><span class="s1">/* DevtoolsHooks.APP_INIT */, app, version, {</span><span class="s2">\n        </span><span class="s1">Fragment,</span><span class="s2">\n        </span><span class="s1">Text,</span><span class="s2">\n        </span><span class="s1">Comment,</span><span class="s2">\n        </span><span class="s1">Static</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function devtoolsUnmountApp(app) {</span><span class="s2">\n    </span><span class="s1">emit$1(</span><span class="s2">\&quot;</span><span class="s1">app:unmount</span><span class="s2">\&quot; </span><span class="s1">/* DevtoolsHooks.APP_UNMOUNT */, app);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">const devtoolsComponentAdded = /*#__PURE__*/ createDevtoolsComponentHook(</span><span class="s2">\&quot;</span><span class="s1">component:added</span><span class="s2">\&quot; </span><span class="s1">/* DevtoolsHooks.COMPONENT_ADDED */);</span><span class="s2">\n</span><span class="s1">const devtoolsComponentUpdated = </span><span class="s2">\n</span><span class="s1">/*#__PURE__*/ createDevtoolsComponentHook(</span><span class="s2">\&quot;</span><span class="s1">component:updated</span><span class="s2">\&quot; </span><span class="s1">/* DevtoolsHooks.COMPONENT_UPDATED */);</span><span class="s2">\n</span><span class="s1">const _devtoolsComponentRemoved = /*#__PURE__*/ createDevtoolsComponentHook(</span><span class="s2">\&quot;</span><span class="s1">component:removed</span><span class="s2">\&quot; </span><span class="s1">/* DevtoolsHooks.COMPONENT_REMOVED */);</span><span class="s2">\n</span><span class="s1">const devtoolsComponentRemoved = (component) =&gt; {</span><span class="s2">\n    </span><span class="s1">if (devtools &amp;&amp;</span><span class="s2">\n        </span><span class="s1">typeof devtools.cleanupBuffer === 'function' &amp;&amp;</span><span class="s2">\n        </span><span class="s1">// remove the component if it wasn't buffered</span><span class="s2">\n        </span><span class="s1">!devtools.cleanupBuffer(component)) {</span><span class="s2">\n        </span><span class="s1">_devtoolsComponentRemoved(component);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">function createDevtoolsComponentHook(hook) {</span><span class="s2">\n    </span><span class="s1">return (component) =&gt; {</span><span class="s2">\n        </span><span class="s1">emit$1(hook, component.appContext.app, component.uid, component.parent ? component.parent.uid : undefined, component);</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">const devtoolsPerfStart = /*#__PURE__*/ createDevtoolsPerformanceHook(</span><span class="s2">\&quot;</span><span class="s1">perf:start</span><span class="s2">\&quot; </span><span class="s1">/* DevtoolsHooks.PERFORMANCE_START */);</span><span class="s2">\n</span><span class="s1">const devtoolsPerfEnd = /*#__PURE__*/ createDevtoolsPerformanceHook(</span><span class="s2">\&quot;</span><span class="s1">perf:end</span><span class="s2">\&quot; </span><span class="s1">/* DevtoolsHooks.PERFORMANCE_END */);</span><span class="s2">\n</span><span class="s1">function createDevtoolsPerformanceHook(hook) {</span><span class="s2">\n    </span><span class="s1">return (component, type, time) =&gt; {</span><span class="s2">\n        </span><span class="s1">emit$1(hook, component.appContext.app, component.uid, component, type, time);</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function devtoolsComponentEmit(component, event, params) {</span><span class="s2">\n    </span><span class="s1">emit$1(</span><span class="s2">\&quot;</span><span class="s1">component:emit</span><span class="s2">\&quot; </span><span class="s1">/* DevtoolsHooks.COMPONENT_EMIT */, component.appContext.app, component, event, params);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function emit(instance, event, ...rawArgs) {</span><span class="s2">\n    </span><span class="s1">if (instance.isUnmounted)</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">const props = instance.vnode.props || EMPTY_OBJ;</span><span class="s2">\n    </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n        </span><span class="s1">const { emitsOptions, propsOptions: [propsOptions] } = instance;</span><span class="s2">\n        </span><span class="s1">if (emitsOptions) {</span><span class="s2">\n            </span><span class="s1">if (!(event in emitsOptions) &amp;&amp;</span><span class="s2">\n                </span><span class="s1">!(false )) {</span><span class="s2">\n                </span><span class="s1">if (!propsOptions || !(toHandlerKey(event) in propsOptions)) {</span><span class="s2">\n                    </span><span class="s1">warn(`Component emitted event </span><span class="s2">\&quot;</span><span class="s1">${event}</span><span class="s2">\&quot; </span><span class="s1">but it is neither declared in ` +</span><span class="s2">\n                        </span><span class="s1">`the emits option nor as an </span><span class="s2">\&quot;</span><span class="s1">${toHandlerKey(event)}</span><span class="s2">\&quot; </span><span class="s1">prop.`);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">const validator = emitsOptions[event];</span><span class="s2">\n                </span><span class="s1">if (isFunction(validator)) {</span><span class="s2">\n                    </span><span class="s1">const isValid = validator(...rawArgs);</span><span class="s2">\n                    </span><span class="s1">if (!isValid) {</span><span class="s2">\n                        </span><span class="s1">warn(`Invalid event arguments: event validation failed for event </span><span class="s2">\&quot;</span><span class="s1">${event}</span><span class="s2">\&quot;</span><span class="s1">.`);</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let args = rawArgs;</span><span class="s2">\n    </span><span class="s1">const isModelListener = event.startsWith('update:');</span><span class="s2">\n    </span><span class="s1">// for v-model update:xxx events, apply modifiers on args</span><span class="s2">\n    </span><span class="s1">const modelArg = isModelListener &amp;&amp; event.slice(7);</span><span class="s2">\n    </span><span class="s1">if (modelArg &amp;&amp; modelArg in props) {</span><span class="s2">\n        </span><span class="s1">const modifiersKey = `${modelArg === 'modelValue' ? 'model' : modelArg}Modifiers`;</span><span class="s2">\n        </span><span class="s1">const { number, trim } = props[modifiersKey] || EMPTY_OBJ;</span><span class="s2">\n        </span><span class="s1">if (trim) {</span><span class="s2">\n            </span><span class="s1">args = rawArgs.map(a =&gt; (isString(a) ? a.trim() : a));</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (number) {</span><span class="s2">\n            </span><span class="s1">args = rawArgs.map(looseToNumber);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if ((process.env.NODE_ENV !== 'production') || __VUE_PROD_DEVTOOLS__) {</span><span class="s2">\n        </span><span class="s1">devtoolsComponentEmit(instance, event, args);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n        </span><span class="s1">const lowerCaseEvent = event.toLowerCase();</span><span class="s2">\n        </span><span class="s1">if (lowerCaseEvent !== event &amp;&amp; props[toHandlerKey(lowerCaseEvent)]) {</span><span class="s2">\n            </span><span class="s1">warn(`Event </span><span class="s2">\&quot;</span><span class="s1">${lowerCaseEvent}</span><span class="s2">\&quot; </span><span class="s1">is emitted in component ` +</span><span class="s2">\n                </span><span class="s1">`${formatComponentName(instance, instance.type)} but the handler is registered for </span><span class="s2">\&quot;</span><span class="s1">${event}</span><span class="s2">\&quot;</span><span class="s1">. ` +</span><span class="s2">\n                </span><span class="s1">`Note that HTML attributes are case-insensitive and you cannot use ` +</span><span class="s2">\n                </span><span class="s1">`v-on to listen to camelCase events when using in-DOM templates. ` +</span><span class="s2">\n                </span><span class="s1">`You should probably use </span><span class="s2">\&quot;</span><span class="s1">${hyphenate(event)}</span><span class="s2">\&quot; </span><span class="s1">instead of </span><span class="s2">\&quot;</span><span class="s1">${event}</span><span class="s2">\&quot;</span><span class="s1">.`);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let handlerName;</span><span class="s2">\n    </span><span class="s1">let handler = props[(handlerName = toHandlerKey(event))] ||</span><span class="s2">\n        </span><span class="s1">// also try camelCase event handler (#2249)</span><span class="s2">\n        </span><span class="s1">props[(handlerName = toHandlerKey(camelize(event)))];</span><span class="s2">\n    </span><span class="s1">// for v-model update:xxx events, also trigger kebab-case equivalent</span><span class="s2">\n    </span><span class="s1">// for props passed via kebab-case</span><span class="s2">\n    </span><span class="s1">if (!handler &amp;&amp; isModelListener) {</span><span class="s2">\n        </span><span class="s1">handler = props[(handlerName = toHandlerKey(hyphenate(event)))];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (handler) {</span><span class="s2">\n        </span><span class="s1">callWithAsyncErrorHandling(handler, instance, 6 /* ErrorCodes.COMPONENT_EVENT_HANDLER */, args);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">const onceHandler = props[handlerName + `Once`];</span><span class="s2">\n    </span><span class="s1">if (onceHandler) {</span><span class="s2">\n        </span><span class="s1">if (!instance.emitted) {</span><span class="s2">\n            </span><span class="s1">instance.emitted = {};</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (instance.emitted[handlerName]) {</span><span class="s2">\n            </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">instance.emitted[handlerName] = true;</span><span class="s2">\n        </span><span class="s1">callWithAsyncErrorHandling(onceHandler, instance, 6 /* ErrorCodes.COMPONENT_EVENT_HANDLER */, args);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function normalizeEmitsOptions(comp, appContext, asMixin = false) {</span><span class="s2">\n    </span><span class="s1">const cache = appContext.emitsCache;</span><span class="s2">\n    </span><span class="s1">const cached = cache.get(comp);</span><span class="s2">\n    </span><span class="s1">if (cached !== undefined) {</span><span class="s2">\n        </span><span class="s1">return cached;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">const raw = comp.emits;</span><span class="s2">\n    </span><span class="s1">let normalized = {};</span><span class="s2">\n    </span><span class="s1">// apply mixin/extends props</span><span class="s2">\n    </span><span class="s1">let hasExtends = false;</span><span class="s2">\n    </span><span class="s1">if (__VUE_OPTIONS_API__ &amp;&amp; !isFunction(comp)) {</span><span class="s2">\n        </span><span class="s1">const extendEmits = (raw) =&gt; {</span><span class="s2">\n            </span><span class="s1">const normalizedFromExtend = normalizeEmitsOptions(raw, appContext, true);</span><span class="s2">\n            </span><span class="s1">if (normalizedFromExtend) {</span><span class="s2">\n                </span><span class="s1">hasExtends = true;</span><span class="s2">\n                </span><span class="s1">extend(normalized, normalizedFromExtend);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n        </span><span class="s1">if (!asMixin &amp;&amp; appContext.mixins.length) {</span><span class="s2">\n            </span><span class="s1">appContext.mixins.forEach(extendEmits);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (comp.extends) {</span><span class="s2">\n            </span><span class="s1">extendEmits(comp.extends);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (comp.mixins) {</span><span class="s2">\n            </span><span class="s1">comp.mixins.forEach(extendEmits);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (!raw &amp;&amp; !hasExtends) {</span><span class="s2">\n        </span><span class="s1">if (isObject(comp)) {</span><span class="s2">\n            </span><span class="s1">cache.set(comp, null);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return null;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (isArray(raw)) {</span><span class="s2">\n        </span><span class="s1">raw.forEach(key =&gt; (normalized[key] = null));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">extend(normalized, raw);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (isObject(comp)) {</span><span class="s2">\n        </span><span class="s1">cache.set(comp, normalized);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return normalized;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// Check if an incoming prop key is a declared emit event listener.</span><span class="s2">\n</span><span class="s1">// e.g. With `emits: { click: null }`, props named `onClick` and `onclick` are</span><span class="s2">\n</span><span class="s1">// both considered matched listeners.</span><span class="s2">\n</span><span class="s1">function isEmitListener(options, key) {</span><span class="s2">\n    </span><span class="s1">if (!options || !isOn(key)) {</span><span class="s2">\n        </span><span class="s1">return false;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">key = key.slice(2).replace(/Once$/, '');</span><span class="s2">\n    </span><span class="s1">return (hasOwn(options, key[0].toLowerCase() + key.slice(1)) ||</span><span class="s2">\n        </span><span class="s1">hasOwn(options, hyphenate(key)) ||</span><span class="s2">\n        </span><span class="s1">hasOwn(options, key));</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* mark the current rendering instance for asset resolution (e.g.</span><span class="s2">\n </span><span class="s1">* resolveComponent, resolveDirective) during render</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">let currentRenderingInstance = null;</span><span class="s2">\n</span><span class="s1">let currentScopeId = null;</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Note: rendering calls maybe nested. The function returns the parent rendering</span><span class="s2">\n </span><span class="s1">* instance if present, which should be restored after the render is done:</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* ```js</span><span class="s2">\n </span><span class="s1">* const prev = setCurrentRenderingInstance(i)</span><span class="s2">\n </span><span class="s1">* // ...render</span><span class="s2">\n </span><span class="s1">* setCurrentRenderingInstance(prev)</span><span class="s2">\n </span><span class="s1">* ```</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function setCurrentRenderingInstance(instance) {</span><span class="s2">\n    </span><span class="s1">const prev = currentRenderingInstance;</span><span class="s2">\n    </span><span class="s1">currentRenderingInstance = instance;</span><span class="s2">\n    </span><span class="s1">currentScopeId = (instance &amp;&amp; instance.type.__scopeId) || null;</span><span class="s2">\n    </span><span class="s1">return prev;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Set scope id when creating hoisted vnodes.</span><span class="s2">\n </span><span class="s1">* @private compiler helper</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function pushScopeId(id) {</span><span class="s2">\n    </span><span class="s1">currentScopeId = id;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Technically we no longer need this after 3.0.8 but we need to keep the same</span><span class="s2">\n </span><span class="s1">* API for backwards compat w/ code generated by compilers.</span><span class="s2">\n </span><span class="s1">* @private</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function popScopeId() {</span><span class="s2">\n    </span><span class="s1">currentScopeId = null;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Only for backwards compat</span><span class="s2">\n </span><span class="s1">* @private</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const withScopeId = (_id) =&gt; withCtx;</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Wrap a slot function to memoize current rendering instance</span><span class="s2">\n </span><span class="s1">* @private compiler helper</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot // false only</span><span class="s2">\n</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">if (!ctx)</span><span class="s2">\n        </span><span class="s1">return fn;</span><span class="s2">\n    </span><span class="s1">// already normalized</span><span class="s2">\n    </span><span class="s1">if (fn._n) {</span><span class="s2">\n        </span><span class="s1">return fn;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">const renderFnWithContext = (...args) =&gt; {</span><span class="s2">\n        </span><span class="s1">// If a user calls a compiled slot inside a template expression (#1745), it</span><span class="s2">\n        </span><span class="s1">// can mess up block tracking, so by default we disable block tracking and</span><span class="s2">\n        </span><span class="s1">// force bail out when invoking a compiled slot (indicated by the ._d flag).</span><span class="s2">\n        </span><span class="s1">// This isn't necessary if rendering a compiled `&lt;slot&gt;`, so we flip the</span><span class="s2">\n        </span><span class="s1">// ._d flag off when invoking the wrapped fn inside `renderSlot`.</span><span class="s2">\n        </span><span class="s1">if (renderFnWithContext._d) {</span><span class="s2">\n            </span><span class="s1">setBlockTracking(-1);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">const prevInstance = setCurrentRenderingInstance(ctx);</span><span class="s2">\n        </span><span class="s1">let res;</span><span class="s2">\n        </span><span class="s1">try {</span><span class="s2">\n            </span><span class="s1">res = fn(...args);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">finally {</span><span class="s2">\n            </span><span class="s1">setCurrentRenderingInstance(prevInstance);</span><span class="s2">\n            </span><span class="s1">if (renderFnWithContext._d) {</span><span class="s2">\n                </span><span class="s1">setBlockTracking(1);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if ((process.env.NODE_ENV !== 'production') || __VUE_PROD_DEVTOOLS__) {</span><span class="s2">\n            </span><span class="s1">devtoolsComponentUpdated(ctx);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return res;</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">// mark normalized to avoid duplicated wrapping</span><span class="s2">\n    </span><span class="s1">renderFnWithContext._n = true;</span><span class="s2">\n    </span><span class="s1">// mark this as compiled by default</span><span class="s2">\n    </span><span class="s1">// this is used in vnode.ts -&gt; normalizeChildren() to set the slot</span><span class="s2">\n    </span><span class="s1">// rendering flag.</span><span class="s2">\n    </span><span class="s1">renderFnWithContext._c = true;</span><span class="s2">\n    </span><span class="s1">// disable block tracking by default</span><span class="s2">\n    </span><span class="s1">renderFnWithContext._d = true;</span><span class="s2">\n    </span><span class="s1">return renderFnWithContext;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* dev only flag to track whether $attrs was used during render.</span><span class="s2">\n </span><span class="s1">* If $attrs was used during render then the warning for failed attrs</span><span class="s2">\n </span><span class="s1">* fallthrough can be suppressed.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">let accessedAttrs = false;</span><span class="s2">\n</span><span class="s1">function markAttrsAccessed() {</span><span class="s2">\n    </span><span class="s1">accessedAttrs = true;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function renderComponentRoot(instance) {</span><span class="s2">\n    </span><span class="s1">const { type: Component, vnode, proxy, withProxy, props, propsOptions: [propsOptions], slots, attrs, emit, render, renderCache, data, setupState, ctx, inheritAttrs } = instance;</span><span class="s2">\n    </span><span class="s1">let result;</span><span class="s2">\n    </span><span class="s1">let fallthroughAttrs;</span><span class="s2">\n    </span><span class="s1">const prev = setCurrentRenderingInstance(instance);</span><span class="s2">\n    </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n        </span><span class="s1">accessedAttrs = false;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">try {</span><span class="s2">\n        </span><span class="s1">if (vnode.shapeFlag &amp; 4 /* ShapeFlags.STATEFUL_COMPONENT */) {</span><span class="s2">\n            </span><span class="s1">// withProxy is a proxy with a different `has` trap only for</span><span class="s2">\n            </span><span class="s1">// runtime-compiled render functions using `with` block.</span><span class="s2">\n            </span><span class="s1">const proxyToUse = withProxy || proxy;</span><span class="s2">\n            </span><span class="s1">result = normalizeVNode(render.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx));</span><span class="s2">\n            </span><span class="s1">fallthroughAttrs = attrs;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">// functional</span><span class="s2">\n            </span><span class="s1">const render = Component;</span><span class="s2">\n            </span><span class="s1">// in dev, mark attrs accessed if optional props (attrs === props)</span><span class="s2">\n            </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp; attrs === props) {</span><span class="s2">\n                </span><span class="s1">markAttrsAccessed();</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">result = normalizeVNode(render.length &gt; 1</span><span class="s2">\n                </span><span class="s1">? render(props, (process.env.NODE_ENV !== 'production')</span><span class="s2">\n                    </span><span class="s1">? {</span><span class="s2">\n                        </span><span class="s1">get attrs() {</span><span class="s2">\n                            </span><span class="s1">markAttrsAccessed();</span><span class="s2">\n                            </span><span class="s1">return attrs;</span><span class="s2">\n                        </span><span class="s1">},</span><span class="s2">\n                        </span><span class="s1">slots,</span><span class="s2">\n                        </span><span class="s1">emit</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">: { attrs, slots, emit })</span><span class="s2">\n                </span><span class="s1">: render(props, null /* we know it doesn't need it */));</span><span class="s2">\n            </span><span class="s1">fallthroughAttrs = Component.props</span><span class="s2">\n                </span><span class="s1">? attrs</span><span class="s2">\n                </span><span class="s1">: getFunctionalFallthrough(attrs);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">catch (err) {</span><span class="s2">\n        </span><span class="s1">blockStack.length = 0;</span><span class="s2">\n        </span><span class="s1">handleError(err, instance, 1 /* ErrorCodes.RENDER_FUNCTION */);</span><span class="s2">\n        </span><span class="s1">result = createVNode(Comment);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// attr merging</span><span class="s2">\n    </span><span class="s1">// in dev mode, comments are preserved, and it's possible for a template</span><span class="s2">\n    </span><span class="s1">// to have comments along side the root element which makes it a fragment</span><span class="s2">\n    </span><span class="s1">let root = result;</span><span class="s2">\n    </span><span class="s1">let setRoot = undefined;</span><span class="s2">\n    </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp;</span><span class="s2">\n        </span><span class="s1">result.patchFlag &gt; 0 &amp;&amp;</span><span class="s2">\n        </span><span class="s1">result.patchFlag &amp; 2048 /* PatchFlags.DEV_ROOT_FRAGMENT */) {</span><span class="s2">\n        </span><span class="s1">[root, setRoot] = getChildRoot(result);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (fallthroughAttrs &amp;&amp; inheritAttrs !== false) {</span><span class="s2">\n        </span><span class="s1">const keys = Object.keys(fallthroughAttrs);</span><span class="s2">\n        </span><span class="s1">const { shapeFlag } = root;</span><span class="s2">\n        </span><span class="s1">if (keys.length) {</span><span class="s2">\n            </span><span class="s1">if (shapeFlag &amp; (1 /* ShapeFlags.ELEMENT */ | 6 /* ShapeFlags.COMPONENT */)) {</span><span class="s2">\n                </span><span class="s1">if (propsOptions &amp;&amp; keys.some(isModelListener)) {</span><span class="s2">\n                    </span><span class="s1">// If a v-model listener (onUpdate:xxx) has a corresponding declared</span><span class="s2">\n                    </span><span class="s1">// prop, it indicates this component expects to handle v-model and</span><span class="s2">\n                    </span><span class="s1">// it should not fallthrough.</span><span class="s2">\n                    </span><span class="s1">// related: #1543, #1643, #1989</span><span class="s2">\n                    </span><span class="s1">fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">root = cloneVNode(root, fallthroughAttrs);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else if ((process.env.NODE_ENV !== 'production') &amp;&amp; !accessedAttrs &amp;&amp; root.type !== Comment) {</span><span class="s2">\n                </span><span class="s1">const allAttrs = Object.keys(attrs);</span><span class="s2">\n                </span><span class="s1">const eventAttrs = [];</span><span class="s2">\n                </span><span class="s1">const extraAttrs = [];</span><span class="s2">\n                </span><span class="s1">for (let i = 0, l = allAttrs.length; i &lt; l; i++) {</span><span class="s2">\n                    </span><span class="s1">const key = allAttrs[i];</span><span class="s2">\n                    </span><span class="s1">if (isOn(key)) {</span><span class="s2">\n                        </span><span class="s1">// ignore v-model handlers when they fail to fallthrough</span><span class="s2">\n                        </span><span class="s1">if (!isModelListener(key)) {</span><span class="s2">\n                            </span><span class="s1">// remove `on`, lowercase first letter to reflect event casing</span><span class="s2">\n                            </span><span class="s1">// accurately</span><span class="s2">\n                            </span><span class="s1">eventAttrs.push(key[2].toLowerCase() + key.slice(3));</span><span class="s2">\n                        </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">else {</span><span class="s2">\n                        </span><span class="s1">extraAttrs.push(key);</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">if (extraAttrs.length) {</span><span class="s2">\n                    </span><span class="s1">warn(`Extraneous non-props attributes (` +</span><span class="s2">\n                        </span><span class="s1">`${extraAttrs.join(', ')}) ` +</span><span class="s2">\n                        </span><span class="s1">`were passed to component but could not be automatically inherited ` +</span><span class="s2">\n                        </span><span class="s1">`because component renders fragment or text root nodes.`);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">if (eventAttrs.length) {</span><span class="s2">\n                    </span><span class="s1">warn(`Extraneous non-emits event listeners (` +</span><span class="s2">\n                        </span><span class="s1">`${eventAttrs.join(', ')}) ` +</span><span class="s2">\n                        </span><span class="s1">`were passed to component but could not be automatically inherited ` +</span><span class="s2">\n                        </span><span class="s1">`because component renders fragment or text root nodes. ` +</span><span class="s2">\n                        </span><span class="s1">`If the listener is intended to be a component custom event listener only, ` +</span><span class="s2">\n                        </span><span class="s1">`declare it using the </span><span class="s2">\&quot;</span><span class="s1">emits</span><span class="s2">\&quot; </span><span class="s1">option.`);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// inherit directives</span><span class="s2">\n    </span><span class="s1">if (vnode.dirs) {</span><span class="s2">\n        </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp; !isElementRoot(root)) {</span><span class="s2">\n            </span><span class="s1">warn(`Runtime directive used on component with non-element root node. ` +</span><span class="s2">\n                </span><span class="s1">`The directives will not function as intended.`);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// clone before mutating since the root may be a hoisted vnode</span><span class="s2">\n        </span><span class="s1">root = cloneVNode(root);</span><span class="s2">\n        </span><span class="s1">root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// inherit transition data</span><span class="s2">\n    </span><span class="s1">if (vnode.transition) {</span><span class="s2">\n        </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp; !isElementRoot(root)) {</span><span class="s2">\n            </span><span class="s1">warn(`Component inside &lt;Transition&gt; renders non-element root node ` +</span><span class="s2">\n                </span><span class="s1">`that cannot be animated.`);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">root.transition = vnode.transition;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp; setRoot) {</span><span class="s2">\n        </span><span class="s1">setRoot(root);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">result = root;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">setCurrentRenderingInstance(prev);</span><span class="s2">\n    </span><span class="s1">return result;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* dev only</span><span class="s2">\n </span><span class="s1">* In dev mode, template root level comments are rendered, which turns the</span><span class="s2">\n </span><span class="s1">* template into a fragment root, but we need to locate the single element</span><span class="s2">\n </span><span class="s1">* root for attrs and scope id processing.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const getChildRoot = (vnode) =&gt; {</span><span class="s2">\n    </span><span class="s1">const rawChildren = vnode.children;</span><span class="s2">\n    </span><span class="s1">const dynamicChildren = vnode.dynamicChildren;</span><span class="s2">\n    </span><span class="s1">const childRoot = filterSingleRoot(rawChildren);</span><span class="s2">\n    </span><span class="s1">if (!childRoot) {</span><span class="s2">\n        </span><span class="s1">return [vnode, undefined];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">const index = rawChildren.indexOf(childRoot);</span><span class="s2">\n    </span><span class="s1">const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;</span><span class="s2">\n    </span><span class="s1">const setRoot = (updatedRoot) =&gt; {</span><span class="s2">\n        </span><span class="s1">rawChildren[index] = updatedRoot;</span><span class="s2">\n        </span><span class="s1">if (dynamicChildren) {</span><span class="s2">\n            </span><span class="s1">if (dynamicIndex &gt; -1) {</span><span class="s2">\n                </span><span class="s1">dynamicChildren[dynamicIndex] = updatedRoot;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else if (updatedRoot.patchFlag &gt; 0) {</span><span class="s2">\n                </span><span class="s1">vnode.dynamicChildren = [...dynamicChildren, updatedRoot];</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">return [normalizeVNode(childRoot), setRoot];</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">function filterSingleRoot(children) {</span><span class="s2">\n    </span><span class="s1">let singleRoot;</span><span class="s2">\n    </span><span class="s1">for (let i = 0; i &lt; children.length; i++) {</span><span class="s2">\n        </span><span class="s1">const child = children[i];</span><span class="s2">\n        </span><span class="s1">if (isVNode(child)) {</span><span class="s2">\n            </span><span class="s1">// ignore user comment</span><span class="s2">\n            </span><span class="s1">if (child.type !== Comment || child.children === 'v-if') {</span><span class="s2">\n                </span><span class="s1">if (singleRoot) {</span><span class="s2">\n                    </span><span class="s1">// has more than 1 non-comment child, return now</span><span class="s2">\n                    </span><span class="s1">return;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else {</span><span class="s2">\n                    </span><span class="s1">singleRoot = child;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return singleRoot;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">const getFunctionalFallthrough = (attrs) =&gt; {</span><span class="s2">\n    </span><span class="s1">let res;</span><span class="s2">\n    </span><span class="s1">for (const key in attrs) {</span><span class="s2">\n        </span><span class="s1">if (key === 'class' || key === 'style' || isOn(key)) {</span><span class="s2">\n            </span><span class="s1">(res || (res = {}))[key] = attrs[key];</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return res;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">const filterModelListeners = (attrs, props) =&gt; {</span><span class="s2">\n    </span><span class="s1">const res = {};</span><span class="s2">\n    </span><span class="s1">for (const key in attrs) {</span><span class="s2">\n        </span><span class="s1">if (!isModelListener(key) || !(key.slice(9) in props)) {</span><span class="s2">\n            </span><span class="s1">res[key] = attrs[key];</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return res;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">const isElementRoot = (vnode) =&gt; {</span><span class="s2">\n    </span><span class="s1">return (vnode.shapeFlag &amp; (6 /* ShapeFlags.COMPONENT */ | 1 /* ShapeFlags.ELEMENT */) ||</span><span class="s2">\n        </span><span class="s1">vnode.type === Comment // potential v-if branch switch</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">function shouldUpdateComponent(prevVNode, nextVNode, optimized) {</span><span class="s2">\n    </span><span class="s1">const { props: prevProps, children: prevChildren, component } = prevVNode;</span><span class="s2">\n    </span><span class="s1">const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;</span><span class="s2">\n    </span><span class="s1">const emits = component.emitsOptions;</span><span class="s2">\n    </span><span class="s1">// Parent component's render function was hot-updated. Since this may have</span><span class="s2">\n    </span><span class="s1">// caused the child component's slots content to have changed, we need to</span><span class="s2">\n    </span><span class="s1">// force the child to update as well.</span><span class="s2">\n    </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp; (prevChildren || nextChildren) &amp;&amp; isHmrUpdating) {</span><span class="s2">\n        </span><span class="s1">return true;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// force child update for runtime directive or transition on component vnode.</span><span class="s2">\n    </span><span class="s1">if (nextVNode.dirs || nextVNode.transition) {</span><span class="s2">\n        </span><span class="s1">return true;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (optimized &amp;&amp; patchFlag &gt;= 0) {</span><span class="s2">\n        </span><span class="s1">if (patchFlag &amp; 1024 /* PatchFlags.DYNAMIC_SLOTS */) {</span><span class="s2">\n            </span><span class="s1">// slot content that references values that might have changed,</span><span class="s2">\n            </span><span class="s1">// e.g. in a v-for</span><span class="s2">\n            </span><span class="s1">return true;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (patchFlag &amp; 16 /* PatchFlags.FULL_PROPS */) {</span><span class="s2">\n            </span><span class="s1">if (!prevProps) {</span><span class="s2">\n                </span><span class="s1">return !!nextProps;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">// presence of this flag indicates props are always non-null</span><span class="s2">\n            </span><span class="s1">return hasPropsChanged(prevProps, nextProps, emits);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (patchFlag &amp; 8 /* PatchFlags.PROPS */) {</span><span class="s2">\n            </span><span class="s1">const dynamicProps = nextVNode.dynamicProps;</span><span class="s2">\n            </span><span class="s1">for (let i = 0; i &lt; dynamicProps.length; i++) {</span><span class="s2">\n                </span><span class="s1">const key = dynamicProps[i];</span><span class="s2">\n                </span><span class="s1">if (nextProps[key] !== prevProps[key] &amp;&amp;</span><span class="s2">\n                    </span><span class="s1">!isEmitListener(emits, key)) {</span><span class="s2">\n                    </span><span class="s1">return true;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">// this path is only taken by manually written render functions</span><span class="s2">\n        </span><span class="s1">// so presence of any children leads to a forced update</span><span class="s2">\n        </span><span class="s1">if (prevChildren || nextChildren) {</span><span class="s2">\n            </span><span class="s1">if (!nextChildren || !nextChildren.$stable) {</span><span class="s2">\n                </span><span class="s1">return true;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (prevProps === nextProps) {</span><span class="s2">\n            </span><span class="s1">return false;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (!prevProps) {</span><span class="s2">\n            </span><span class="s1">return !!nextProps;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (!nextProps) {</span><span class="s2">\n            </span><span class="s1">return true;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return hasPropsChanged(prevProps, nextProps, emits);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return false;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function hasPropsChanged(prevProps, nextProps, emitsOptions) {</span><span class="s2">\n    </span><span class="s1">const nextKeys = Object.keys(nextProps);</span><span class="s2">\n    </span><span class="s1">if (nextKeys.length !== Object.keys(prevProps).length) {</span><span class="s2">\n        </span><span class="s1">return true;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">for (let i = 0; i &lt; nextKeys.length; i++) {</span><span class="s2">\n        </span><span class="s1">const key = nextKeys[i];</span><span class="s2">\n        </span><span class="s1">if (nextProps[key] !== prevProps[key] &amp;&amp;</span><span class="s2">\n            </span><span class="s1">!isEmitListener(emitsOptions, key)) {</span><span class="s2">\n            </span><span class="s1">return true;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return false;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function updateHOCHostEl({ vnode, parent }, el // HostNode</span><span class="s2">\n</span><span class="s1">) {</span><span class="s2">\n    </span><span class="s1">while (parent &amp;&amp; parent.subTree === vnode) {</span><span class="s2">\n        </span><span class="s1">(vnode = parent.vnode).el = el;</span><span class="s2">\n        </span><span class="s1">parent = parent.parent;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">const isSuspense = (type) =&gt; type.__isSuspense;</span><span class="s2">\n</span><span class="s1">// Suspense exposes a component-like API, and is treated like a component</span><span class="s2">\n</span><span class="s1">// in the compiler, but internally it's a special built-in type that hooks</span><span class="s2">\n</span><span class="s1">// directly into the renderer.</span><span class="s2">\n</span><span class="s1">const SuspenseImpl = {</span><span class="s2">\n    </span><span class="s1">name: 'Suspense',</span><span class="s2">\n    </span><span class="s1">// In order to make Suspense tree-shakable, we need to avoid importing it</span><span class="s2">\n    </span><span class="s1">// directly in the renderer. The renderer checks for the __isSuspense flag</span><span class="s2">\n    </span><span class="s1">// on a vnode's type and calls the `process` method, passing in renderer</span><span class="s2">\n    </span><span class="s1">// internals.</span><span class="s2">\n    </span><span class="s1">__isSuspense: true,</span><span class="s2">\n    </span><span class="s1">process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, </span><span class="s2">\n    </span><span class="s1">// platform-specific impl passed from renderer</span><span class="s2">\n    </span><span class="s1">rendererInternals) {</span><span class="s2">\n        </span><span class="s1">if (n1 == null) {</span><span class="s2">\n            </span><span class="s1">mountSuspense(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, rendererInternals);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">hydrate: hydrateSuspense,</span><span class="s2">\n    </span><span class="s1">create: createSuspenseBoundary,</span><span class="s2">\n    </span><span class="s1">normalize: normalizeSuspenseChildren</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">// Force-casted public typing for h and TSX props inference</span><span class="s2">\n</span><span class="s1">const Suspense = (SuspenseImpl</span><span class="s2">\n    </span><span class="s1">);</span><span class="s2">\n</span><span class="s1">function triggerEvent(vnode, name) {</span><span class="s2">\n    </span><span class="s1">const eventListener = vnode.props &amp;&amp; vnode.props[name];</span><span class="s2">\n    </span><span class="s1">if (isFunction(eventListener)) {</span><span class="s2">\n        </span><span class="s1">eventListener();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {</span><span class="s2">\n    </span><span class="s1">const { p: patch, o: { createElement } } = rendererInternals;</span><span class="s2">\n    </span><span class="s1">const hiddenContainer = createElement('div');</span><span class="s2">\n    </span><span class="s1">const suspense = (vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals));</span><span class="s2">\n    </span><span class="s1">// start mounting the content subtree in an off-dom container</span><span class="s2">\n    </span><span class="s1">patch(null, (suspense.pendingBranch = vnode.ssContent), hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds);</span><span class="s2">\n    </span><span class="s1">// now check if we have encountered any async deps</span><span class="s2">\n    </span><span class="s1">if (suspense.deps &gt; 0) {</span><span class="s2">\n        </span><span class="s1">// has async</span><span class="s2">\n        </span><span class="s1">// invoke @fallback event</span><span class="s2">\n        </span><span class="s1">triggerEvent(vnode, 'onPending');</span><span class="s2">\n        </span><span class="s1">triggerEvent(vnode, 'onFallback');</span><span class="s2">\n        </span><span class="s1">// mount the fallback tree</span><span class="s2">\n        </span><span class="s1">patch(null, vnode.ssFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context</span><span class="s2">\n        </span><span class="s1">isSVG, slotScopeIds);</span><span class="s2">\n        </span><span class="s1">setActiveBranch(suspense, vnode.ssFallback);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">// Suspense has no async deps. Just resolve.</span><span class="s2">\n        </span><span class="s1">suspense.resolve();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, { p: patch, um: unmount, o: { createElement } }) {</span><span class="s2">\n    </span><span class="s1">const suspense = (n2.suspense = n1.suspense);</span><span class="s2">\n    </span><span class="s1">suspense.vnode = n2;</span><span class="s2">\n    </span><span class="s1">n2.el = n1.el;</span><span class="s2">\n    </span><span class="s1">const newBranch = n2.ssContent;</span><span class="s2">\n    </span><span class="s1">const newFallback = n2.ssFallback;</span><span class="s2">\n    </span><span class="s1">const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;</span><span class="s2">\n    </span><span class="s1">if (pendingBranch) {</span><span class="s2">\n        </span><span class="s1">suspense.pendingBranch = newBranch;</span><span class="s2">\n        </span><span class="s1">if (isSameVNodeType(newBranch, pendingBranch)) {</span><span class="s2">\n            </span><span class="s1">// same root type but content may have changed.</span><span class="s2">\n            </span><span class="s1">patch(pendingBranch, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);</span><span class="s2">\n            </span><span class="s1">if (suspense.deps &lt;= 0) {</span><span class="s2">\n                </span><span class="s1">suspense.resolve();</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else if (isInFallback) {</span><span class="s2">\n                </span><span class="s1">patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context</span><span class="s2">\n                </span><span class="s1">isSVG, slotScopeIds, optimized);</span><span class="s2">\n                </span><span class="s1">setActiveBranch(suspense, newFallback);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">// toggled before pending tree is resolved</span><span class="s2">\n            </span><span class="s1">suspense.pendingId++;</span><span class="s2">\n            </span><span class="s1">if (isHydrating) {</span><span class="s2">\n                </span><span class="s1">// if toggled before hydration is finished, the current DOM tree is</span><span class="s2">\n                </span><span class="s1">// no longer valid. set it as the active branch so it will be unmounted</span><span class="s2">\n                </span><span class="s1">// when resolved</span><span class="s2">\n                </span><span class="s1">suspense.isHydrating = false;</span><span class="s2">\n                </span><span class="s1">suspense.activeBranch = pendingBranch;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">unmount(pendingBranch, parentComponent, suspense);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">// increment pending ID. this is used to invalidate async callbacks</span><span class="s2">\n            </span><span class="s1">// reset suspense state</span><span class="s2">\n            </span><span class="s1">suspense.deps = 0;</span><span class="s2">\n            </span><span class="s1">// discard effects from pending branch</span><span class="s2">\n            </span><span class="s1">suspense.effects.length = 0;</span><span class="s2">\n            </span><span class="s1">// discard previous container</span><span class="s2">\n            </span><span class="s1">suspense.hiddenContainer = createElement('div');</span><span class="s2">\n            </span><span class="s1">if (isInFallback) {</span><span class="s2">\n                </span><span class="s1">// already in fallback state</span><span class="s2">\n                </span><span class="s1">patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);</span><span class="s2">\n                </span><span class="s1">if (suspense.deps &lt;= 0) {</span><span class="s2">\n                    </span><span class="s1">suspense.resolve();</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else {</span><span class="s2">\n                    </span><span class="s1">patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context</span><span class="s2">\n                    </span><span class="s1">isSVG, slotScopeIds, optimized);</span><span class="s2">\n                    </span><span class="s1">setActiveBranch(suspense, newFallback);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else if (activeBranch &amp;&amp; isSameVNodeType(newBranch, activeBranch)) {</span><span class="s2">\n                </span><span class="s1">// toggled </span><span class="s2">\&quot;</span><span class="s1">back</span><span class="s2">\&quot; </span><span class="s1">to current active branch</span><span class="s2">\n                </span><span class="s1">patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);</span><span class="s2">\n                </span><span class="s1">// force resolve</span><span class="s2">\n                </span><span class="s1">suspense.resolve(true);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">// switched to a 3rd branch</span><span class="s2">\n                </span><span class="s1">patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);</span><span class="s2">\n                </span><span class="s1">if (suspense.deps &lt;= 0) {</span><span class="s2">\n                    </span><span class="s1">suspense.resolve();</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">if (activeBranch &amp;&amp; isSameVNodeType(newBranch, activeBranch)) {</span><span class="s2">\n            </span><span class="s1">// root did not change, just normal patch</span><span class="s2">\n            </span><span class="s1">patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);</span><span class="s2">\n            </span><span class="s1">setActiveBranch(suspense, newBranch);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">// root node toggled</span><span class="s2">\n            </span><span class="s1">// invoke @pending event</span><span class="s2">\n            </span><span class="s1">triggerEvent(n2, 'onPending');</span><span class="s2">\n            </span><span class="s1">// mount pending branch in off-dom container</span><span class="s2">\n            </span><span class="s1">suspense.pendingBranch = newBranch;</span><span class="s2">\n            </span><span class="s1">suspense.pendingId++;</span><span class="s2">\n            </span><span class="s1">patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);</span><span class="s2">\n            </span><span class="s1">if (suspense.deps &lt;= 0) {</span><span class="s2">\n                </span><span class="s1">// incoming branch has no async deps, resolve now.</span><span class="s2">\n                </span><span class="s1">suspense.resolve();</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">const { timeout, pendingId } = suspense;</span><span class="s2">\n                </span><span class="s1">if (timeout &gt; 0) {</span><span class="s2">\n                    </span><span class="s1">setTimeout(() =&gt; {</span><span class="s2">\n                        </span><span class="s1">if (suspense.pendingId === pendingId) {</span><span class="s2">\n                            </span><span class="s1">suspense.fallback(newFallback);</span><span class="s2">\n                        </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">}, timeout);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else if (timeout === 0) {</span><span class="s2">\n                    </span><span class="s1">suspense.fallback(newFallback);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">let hasWarned = false;</span><span class="s2">\n</span><span class="s1">function createSuspenseBoundary(vnode, parent, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals, isHydrating = false) {</span><span class="s2">\n    </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n    </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp; !false &amp;&amp; !hasWarned) {</span><span class="s2">\n        </span><span class="s1">hasWarned = true;</span><span class="s2">\n        </span><span class="s1">// @ts-ignore `console.info` cannot be null error</span><span class="s2">\n        </span><span class="s1">console[console.info ? 'info' : 'log'](`&lt;Suspense&gt; is an experimental feature and its API will likely change.`);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">const { p: patch, m: move, um: unmount, n: next, o: { parentNode, remove } } = rendererInternals;</span><span class="s2">\n    </span><span class="s1">const timeout = vnode.props ? toNumber(vnode.props.timeout) : undefined;</span><span class="s2">\n    </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n        </span><span class="s1">assertNumber(timeout, `Suspense timeout`);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">const suspense = {</span><span class="s2">\n        </span><span class="s1">vnode,</span><span class="s2">\n        </span><span class="s1">parent,</span><span class="s2">\n        </span><span class="s1">parentComponent,</span><span class="s2">\n        </span><span class="s1">isSVG,</span><span class="s2">\n        </span><span class="s1">container,</span><span class="s2">\n        </span><span class="s1">hiddenContainer,</span><span class="s2">\n        </span><span class="s1">anchor,</span><span class="s2">\n        </span><span class="s1">deps: 0,</span><span class="s2">\n        </span><span class="s1">pendingId: 0,</span><span class="s2">\n        </span><span class="s1">timeout: typeof timeout === 'number' ? timeout : -1,</span><span class="s2">\n        </span><span class="s1">activeBranch: null,</span><span class="s2">\n        </span><span class="s1">pendingBranch: null,</span><span class="s2">\n        </span><span class="s1">isInFallback: true,</span><span class="s2">\n        </span><span class="s1">isHydrating,</span><span class="s2">\n        </span><span class="s1">isUnmounted: false,</span><span class="s2">\n        </span><span class="s1">effects: [],</span><span class="s2">\n        </span><span class="s1">resolve(resume = false) {</span><span class="s2">\n            </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n                </span><span class="s1">if (!resume &amp;&amp; !suspense.pendingBranch) {</span><span class="s2">\n                    </span><span class="s1">throw new Error(`suspense.resolve() is called without a pending branch.`);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">if (suspense.isUnmounted) {</span><span class="s2">\n                    </span><span class="s1">throw new Error(`suspense.resolve() is called on an already unmounted suspense boundary.`);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">const { vnode, activeBranch, pendingBranch, pendingId, effects, parentComponent, container } = suspense;</span><span class="s2">\n            </span><span class="s1">if (suspense.isHydrating) {</span><span class="s2">\n                </span><span class="s1">suspense.isHydrating = false;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else if (!resume) {</span><span class="s2">\n                </span><span class="s1">const delayEnter = activeBranch &amp;&amp;</span><span class="s2">\n                    </span><span class="s1">pendingBranch.transition &amp;&amp;</span><span class="s2">\n                    </span><span class="s1">pendingBranch.transition.mode === 'out-in';</span><span class="s2">\n                </span><span class="s1">if (delayEnter) {</span><span class="s2">\n                    </span><span class="s1">activeBranch.transition.afterLeave = () =&gt; {</span><span class="s2">\n                        </span><span class="s1">if (pendingId === suspense.pendingId) {</span><span class="s2">\n                            </span><span class="s1">move(pendingBranch, container, anchor, 0 /* MoveType.ENTER */);</span><span class="s2">\n                        </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">};</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">// this is initial anchor on mount</span><span class="s2">\n                </span><span class="s1">let { anchor } = suspense;</span><span class="s2">\n                </span><span class="s1">// unmount current active tree</span><span class="s2">\n                </span><span class="s1">if (activeBranch) {</span><span class="s2">\n                    </span><span class="s1">// if the fallback tree was mounted, it may have been moved</span><span class="s2">\n                    </span><span class="s1">// as part of a parent suspense. get the latest anchor for insertion</span><span class="s2">\n                    </span><span class="s1">anchor = next(activeBranch);</span><span class="s2">\n                    </span><span class="s1">unmount(activeBranch, parentComponent, suspense, true);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">if (!delayEnter) {</span><span class="s2">\n                    </span><span class="s1">// move content from off-dom container to actual container</span><span class="s2">\n                    </span><span class="s1">move(pendingBranch, container, anchor, 0 /* MoveType.ENTER */);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">setActiveBranch(suspense, pendingBranch);</span><span class="s2">\n            </span><span class="s1">suspense.pendingBranch = null;</span><span class="s2">\n            </span><span class="s1">suspense.isInFallback = false;</span><span class="s2">\n            </span><span class="s1">// flush buffered effects</span><span class="s2">\n            </span><span class="s1">// check if there is a pending parent suspense</span><span class="s2">\n            </span><span class="s1">let parent = suspense.parent;</span><span class="s2">\n            </span><span class="s1">let hasUnresolvedAncestor = false;</span><span class="s2">\n            </span><span class="s1">while (parent) {</span><span class="s2">\n                </span><span class="s1">if (parent.pendingBranch) {</span><span class="s2">\n                    </span><span class="s1">// found a pending parent suspense, merge buffered post jobs</span><span class="s2">\n                    </span><span class="s1">// into that parent</span><span class="s2">\n                    </span><span class="s1">parent.effects.push(...effects);</span><span class="s2">\n                    </span><span class="s1">hasUnresolvedAncestor = true;</span><span class="s2">\n                    </span><span class="s1">break;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">parent = parent.parent;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">// no pending parent suspense, flush all jobs</span><span class="s2">\n            </span><span class="s1">if (!hasUnresolvedAncestor) {</span><span class="s2">\n                </span><span class="s1">queuePostFlushCb(effects);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">suspense.effects = [];</span><span class="s2">\n            </span><span class="s1">// invoke @resolve event</span><span class="s2">\n            </span><span class="s1">triggerEvent(vnode, 'onResolve');</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">fallback(fallbackVNode) {</span><span class="s2">\n            </span><span class="s1">if (!suspense.pendingBranch) {</span><span class="s2">\n                </span><span class="s1">return;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">const { vnode, activeBranch, parentComponent, container, isSVG } = suspense;</span><span class="s2">\n            </span><span class="s1">// invoke @fallback event</span><span class="s2">\n            </span><span class="s1">triggerEvent(vnode, 'onFallback');</span><span class="s2">\n            </span><span class="s1">const anchor = next(activeBranch);</span><span class="s2">\n            </span><span class="s1">const mountFallback = () =&gt; {</span><span class="s2">\n                </span><span class="s1">if (!suspense.isInFallback) {</span><span class="s2">\n                    </span><span class="s1">return;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">// mount the fallback tree</span><span class="s2">\n                </span><span class="s1">patch(null, fallbackVNode, container, anchor, parentComponent, null, // fallback tree will not have suspense context</span><span class="s2">\n                </span><span class="s1">isSVG, slotScopeIds, optimized);</span><span class="s2">\n                </span><span class="s1">setActiveBranch(suspense, fallbackVNode);</span><span class="s2">\n            </span><span class="s1">};</span><span class="s2">\n            </span><span class="s1">const delayEnter = fallbackVNode.transition &amp;&amp; fallbackVNode.transition.mode === 'out-in';</span><span class="s2">\n            </span><span class="s1">if (delayEnter) {</span><span class="s2">\n                </span><span class="s1">activeBranch.transition.afterLeave = mountFallback;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">suspense.isInFallback = true;</span><span class="s2">\n            </span><span class="s1">// unmount current active branch</span><span class="s2">\n            </span><span class="s1">unmount(activeBranch, parentComponent, null, // no suspense so unmount hooks fire now</span><span class="s2">\n            </span><span class="s1">true // shouldRemove</span><span class="s2">\n            </span><span class="s1">);</span><span class="s2">\n            </span><span class="s1">if (!delayEnter) {</span><span class="s2">\n                </span><span class="s1">mountFallback();</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">move(container, anchor, type) {</span><span class="s2">\n            </span><span class="s1">suspense.activeBranch &amp;&amp;</span><span class="s2">\n                </span><span class="s1">move(suspense.activeBranch, container, anchor, type);</span><span class="s2">\n            </span><span class="s1">suspense.container = container;</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">next() {</span><span class="s2">\n            </span><span class="s1">return suspense.activeBranch &amp;&amp; next(suspense.activeBranch);</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">registerDep(instance, setupRenderEffect) {</span><span class="s2">\n            </span><span class="s1">const isInPendingSuspense = !!suspense.pendingBranch;</span><span class="s2">\n            </span><span class="s1">if (isInPendingSuspense) {</span><span class="s2">\n                </span><span class="s1">suspense.deps++;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">const hydratedEl = instance.vnode.el;</span><span class="s2">\n            </span><span class="s1">instance</span><span class="s2">\n                </span><span class="s1">.asyncDep.catch(err =&gt; {</span><span class="s2">\n                </span><span class="s1">handleError(err, instance, 0 /* ErrorCodes.SETUP_FUNCTION */);</span><span class="s2">\n            </span><span class="s1">})</span><span class="s2">\n                </span><span class="s1">.then(asyncSetupResult =&gt; {</span><span class="s2">\n                </span><span class="s1">// retry when the setup() promise resolves.</span><span class="s2">\n                </span><span class="s1">// component may have been unmounted before resolve.</span><span class="s2">\n                </span><span class="s1">if (instance.isUnmounted ||</span><span class="s2">\n                    </span><span class="s1">suspense.isUnmounted ||</span><span class="s2">\n                    </span><span class="s1">suspense.pendingId !== instance.suspenseId) {</span><span class="s2">\n                    </span><span class="s1">return;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">// retry from this component</span><span class="s2">\n                </span><span class="s1">instance.asyncResolved = true;</span><span class="s2">\n                </span><span class="s1">const { vnode } = instance;</span><span class="s2">\n                </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n                    </span><span class="s1">pushWarningContext(vnode);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">handleSetupResult(instance, asyncSetupResult, false);</span><span class="s2">\n                </span><span class="s1">if (hydratedEl) {</span><span class="s2">\n                    </span><span class="s1">// vnode may have been replaced if an update happened before the</span><span class="s2">\n                    </span><span class="s1">// async dep is resolved.</span><span class="s2">\n                    </span><span class="s1">vnode.el = hydratedEl;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">const placeholder = !hydratedEl &amp;&amp; instance.subTree.el;</span><span class="s2">\n                </span><span class="s1">setupRenderEffect(instance, vnode, </span><span class="s2">\n                </span><span class="s1">// component may have been moved before resolve.</span><span class="s2">\n                </span><span class="s1">// if this is not a hydration, instance.subTree will be the comment</span><span class="s2">\n                </span><span class="s1">// placeholder.</span><span class="s2">\n                </span><span class="s1">parentNode(hydratedEl || instance.subTree.el), </span><span class="s2">\n                </span><span class="s1">// anchor will not be used if this is hydration, so only need to</span><span class="s2">\n                </span><span class="s1">// consider the comment placeholder case.</span><span class="s2">\n                </span><span class="s1">hydratedEl ? null : next(instance.subTree), suspense, isSVG, optimized);</span><span class="s2">\n                </span><span class="s1">if (placeholder) {</span><span class="s2">\n                    </span><span class="s1">remove(placeholder);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">updateHOCHostEl(instance, vnode.el);</span><span class="s2">\n                </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n                    </span><span class="s1">popWarningContext();</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">// only decrease deps count if suspense is not already resolved</span><span class="s2">\n                </span><span class="s1">if (isInPendingSuspense &amp;&amp; --suspense.deps === 0) {</span><span class="s2">\n                    </span><span class="s1">suspense.resolve();</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">unmount(parentSuspense, doRemove) {</span><span class="s2">\n            </span><span class="s1">suspense.isUnmounted = true;</span><span class="s2">\n            </span><span class="s1">if (suspense.activeBranch) {</span><span class="s2">\n                </span><span class="s1">unmount(suspense.activeBranch, parentComponent, parentSuspense, doRemove);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">if (suspense.pendingBranch) {</span><span class="s2">\n                </span><span class="s1">unmount(suspense.pendingBranch, parentComponent, parentSuspense, doRemove);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">return suspense;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function hydrateSuspense(node, vnode, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals, hydrateNode) {</span><span class="s2">\n    </span><span class="s1">/* eslint-disable no-restricted-globals */</span><span class="s2">\n    </span><span class="s1">const suspense = (vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, node.parentNode, document.createElement('div'), null, isSVG, slotScopeIds, optimized, rendererInternals, true /* hydrating */));</span><span class="s2">\n    </span><span class="s1">// there are two possible scenarios for server-rendered suspense:</span><span class="s2">\n    </span><span class="s1">// - success: ssr content should be fully resolved</span><span class="s2">\n    </span><span class="s1">// - failure: ssr content should be the fallback branch.</span><span class="s2">\n    </span><span class="s1">// however, on the client we don't really know if it has failed or not</span><span class="s2">\n    </span><span class="s1">// attempt to hydrate the DOM assuming it has succeeded, but we still</span><span class="s2">\n    </span><span class="s1">// need to construct a suspense boundary first</span><span class="s2">\n    </span><span class="s1">const result = hydrateNode(node, (suspense.pendingBranch = vnode.ssContent), parentComponent, suspense, slotScopeIds, optimized);</span><span class="s2">\n    </span><span class="s1">if (suspense.deps === 0) {</span><span class="s2">\n        </span><span class="s1">suspense.resolve();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return result;</span><span class="s2">\n    </span><span class="s1">/* eslint-enable no-restricted-globals */</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function normalizeSuspenseChildren(vnode) {</span><span class="s2">\n    </span><span class="s1">const { shapeFlag, children } = vnode;</span><span class="s2">\n    </span><span class="s1">const isSlotChildren = shapeFlag &amp; 32 /* ShapeFlags.SLOTS_CHILDREN */;</span><span class="s2">\n    </span><span class="s1">vnode.ssContent = normalizeSuspenseSlot(isSlotChildren ? children.default : children);</span><span class="s2">\n    </span><span class="s1">vnode.ssFallback = isSlotChildren</span><span class="s2">\n        </span><span class="s1">? normalizeSuspenseSlot(children.fallback)</span><span class="s2">\n        </span><span class="s1">: createVNode(Comment);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function normalizeSuspenseSlot(s) {</span><span class="s2">\n    </span><span class="s1">let block;</span><span class="s2">\n    </span><span class="s1">if (isFunction(s)) {</span><span class="s2">\n        </span><span class="s1">const trackBlock = isBlockTreeEnabled &amp;&amp; s._c;</span><span class="s2">\n        </span><span class="s1">if (trackBlock) {</span><span class="s2">\n            </span><span class="s1">// disableTracking: false</span><span class="s2">\n            </span><span class="s1">// allow block tracking for compiled slots</span><span class="s2">\n            </span><span class="s1">// (see ./componentRenderContext.ts)</span><span class="s2">\n            </span><span class="s1">s._d = false;</span><span class="s2">\n            </span><span class="s1">openBlock();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">s = s();</span><span class="s2">\n        </span><span class="s1">if (trackBlock) {</span><span class="s2">\n            </span><span class="s1">s._d = true;</span><span class="s2">\n            </span><span class="s1">block = currentBlock;</span><span class="s2">\n            </span><span class="s1">closeBlock();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (isArray(s)) {</span><span class="s2">\n        </span><span class="s1">const singleChild = filterSingleRoot(s);</span><span class="s2">\n        </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp; !singleChild) {</span><span class="s2">\n            </span><span class="s1">warn(`&lt;Suspense&gt; slots expect a single root node.`);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">s = singleChild;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">s = normalizeVNode(s);</span><span class="s2">\n    </span><span class="s1">if (block &amp;&amp; !s.dynamicChildren) {</span><span class="s2">\n        </span><span class="s1">s.dynamicChildren = block.filter(c =&gt; c !== s);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return s;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function queueEffectWithSuspense(fn, suspense) {</span><span class="s2">\n    </span><span class="s1">if (suspense &amp;&amp; suspense.pendingBranch) {</span><span class="s2">\n        </span><span class="s1">if (isArray(fn)) {</span><span class="s2">\n            </span><span class="s1">suspense.effects.push(...fn);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">suspense.effects.push(fn);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">queuePostFlushCb(fn);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function setActiveBranch(suspense, branch) {</span><span class="s2">\n    </span><span class="s1">suspense.activeBranch = branch;</span><span class="s2">\n    </span><span class="s1">const { vnode, parentComponent } = suspense;</span><span class="s2">\n    </span><span class="s1">const el = (vnode.el = branch.el);</span><span class="s2">\n    </span><span class="s1">// in case suspense is the root node of a component,</span><span class="s2">\n    </span><span class="s1">// recursively update the HOC el</span><span class="s2">\n    </span><span class="s1">if (parentComponent &amp;&amp; parentComponent.subTree === vnode) {</span><span class="s2">\n        </span><span class="s1">parentComponent.vnode.el = el;</span><span class="s2">\n        </span><span class="s1">updateHOCHostEl(parentComponent, el);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function provide(key, value) {</span><span class="s2">\n    </span><span class="s1">if (!currentInstance) {</span><span class="s2">\n        </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n            </span><span class="s1">warn(`provide() can only be used inside setup().`);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">let provides = currentInstance.provides;</span><span class="s2">\n        </span><span class="s1">// by default an instance inherits its parent's provides object</span><span class="s2">\n        </span><span class="s1">// but when it needs to provide values of its own, it creates its</span><span class="s2">\n        </span><span class="s1">// own provides object using parent provides object as prototype.</span><span class="s2">\n        </span><span class="s1">// this way in `inject` we can simply look up injections from direct</span><span class="s2">\n        </span><span class="s1">// parent and let the prototype chain do the work.</span><span class="s2">\n        </span><span class="s1">const parentProvides = currentInstance.parent &amp;&amp; currentInstance.parent.provides;</span><span class="s2">\n        </span><span class="s1">if (parentProvides === provides) {</span><span class="s2">\n            </span><span class="s1">provides = currentInstance.provides = Object.create(parentProvides);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// TS doesn't allow symbol as index type</span><span class="s2">\n        </span><span class="s1">provides[key] = value;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function inject(key, defaultValue, treatDefaultAsFactory = false) {</span><span class="s2">\n    </span><span class="s1">// fallback to `currentRenderingInstance` so that this can be called in</span><span class="s2">\n    </span><span class="s1">// a functional component</span><span class="s2">\n    </span><span class="s1">const instance = currentInstance || currentRenderingInstance;</span><span class="s2">\n    </span><span class="s1">if (instance) {</span><span class="s2">\n        </span><span class="s1">// #2400</span><span class="s2">\n        </span><span class="s1">// to support `app.use` plugins,</span><span class="s2">\n        </span><span class="s1">// fallback to appContext's `provides` if the instance is at root</span><span class="s2">\n        </span><span class="s1">const provides = instance.parent == null</span><span class="s2">\n            </span><span class="s1">? instance.vnode.appContext &amp;&amp; instance.vnode.appContext.provides</span><span class="s2">\n            </span><span class="s1">: instance.parent.provides;</span><span class="s2">\n        </span><span class="s1">if (provides &amp;&amp; key in provides) {</span><span class="s2">\n            </span><span class="s1">// TS doesn't allow symbol as index type</span><span class="s2">\n            </span><span class="s1">return provides[key];</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (arguments.length &gt; 1) {</span><span class="s2">\n            </span><span class="s1">return treatDefaultAsFactory &amp;&amp; isFunction(defaultValue)</span><span class="s2">\n                </span><span class="s1">? defaultValue.call(instance.proxy)</span><span class="s2">\n                </span><span class="s1">: defaultValue;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n            </span><span class="s1">warn(`injection </span><span class="s2">\&quot;</span><span class="s1">${String(key)}</span><span class="s2">\&quot; </span><span class="s1">not found.`);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n        </span><span class="s1">warn(`inject() can only be used inside setup() or functional components.`);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// Simple effect.</span><span class="s2">\n</span><span class="s1">function watchEffect(effect, options) {</span><span class="s2">\n    </span><span class="s1">return doWatch(effect, null, options);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function watchPostEffect(effect, options) {</span><span class="s2">\n    </span><span class="s1">return doWatch(effect, null, (process.env.NODE_ENV !== 'production') ? Object.assign(Object.assign({}, options), { flush: 'post' }) : { flush: 'post' });</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function watchSyncEffect(effect, options) {</span><span class="s2">\n    </span><span class="s1">return doWatch(effect, null, (process.env.NODE_ENV !== 'production') ? Object.assign(Object.assign({}, options), { flush: 'sync' }) : { flush: 'sync' });</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// initial value for watchers to trigger on undefined initial values</span><span class="s2">\n</span><span class="s1">const INITIAL_WATCHER_VALUE = {};</span><span class="s2">\n</span><span class="s1">// implementation</span><span class="s2">\n</span><span class="s1">function watch(source, cb, options) {</span><span class="s2">\n    </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp; !isFunction(cb)) {</span><span class="s2">\n        </span><span class="s1">warn(`</span><span class="s2">\\</span><span class="s1">`watch(fn, options?)</span><span class="s2">\\</span><span class="s1">` signature has been moved to a separate API. ` +</span><span class="s2">\n            </span><span class="s1">`Use </span><span class="s2">\\</span><span class="s1">`watchEffect(fn, options?)</span><span class="s2">\\</span><span class="s1">` instead. </span><span class="s2">\\</span><span class="s1">`watch</span><span class="s2">\\</span><span class="s1">` now only ` +</span><span class="s2">\n            </span><span class="s1">`supports </span><span class="s2">\\</span><span class="s1">`watch(source, cb, options?) signature.`);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return doWatch(source, cb, options);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {</span><span class="s2">\n    </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp; !cb) {</span><span class="s2">\n        </span><span class="s1">if (immediate !== undefined) {</span><span class="s2">\n            </span><span class="s1">warn(`watch() </span><span class="s2">\&quot;</span><span class="s1">immediate</span><span class="s2">\&quot; </span><span class="s1">option is only respected when using the ` +</span><span class="s2">\n                </span><span class="s1">`watch(source, callback, options?) signature.`);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (deep !== undefined) {</span><span class="s2">\n            </span><span class="s1">warn(`watch() </span><span class="s2">\&quot;</span><span class="s1">deep</span><span class="s2">\&quot; </span><span class="s1">option is only respected when using the ` +</span><span class="s2">\n                </span><span class="s1">`watch(source, callback, options?) signature.`);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">const warnInvalidSource = (s) =&gt; {</span><span class="s2">\n        </span><span class="s1">warn(`Invalid watch source: `, s, `A watch source can only be a getter/effect function, a ref, ` +</span><span class="s2">\n            </span><span class="s1">`a reactive object, or an array of these types.`);</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">const instance = getCurrentScope() === (currentInstance === null || currentInstance === void 0 ? void 0 : currentInstance.scope) ? currentInstance : null;</span><span class="s2">\n    </span><span class="s1">// const instance = currentInstance</span><span class="s2">\n    </span><span class="s1">let getter;</span><span class="s2">\n    </span><span class="s1">let forceTrigger = false;</span><span class="s2">\n    </span><span class="s1">let isMultiSource = false;</span><span class="s2">\n    </span><span class="s1">if (isRef(source)) {</span><span class="s2">\n        </span><span class="s1">getter = () =&gt; source.value;</span><span class="s2">\n        </span><span class="s1">forceTrigger = isShallow$1(source);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (isReactive(source)) {</span><span class="s2">\n        </span><span class="s1">getter = () =&gt; source;</span><span class="s2">\n        </span><span class="s1">deep = true;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (isArray(source)) {</span><span class="s2">\n        </span><span class="s1">isMultiSource = true;</span><span class="s2">\n        </span><span class="s1">forceTrigger = source.some(s =&gt; isReactive(s) || isShallow$1(s));</span><span class="s2">\n        </span><span class="s1">getter = () =&gt; source.map(s =&gt; {</span><span class="s2">\n            </span><span class="s1">if (isRef(s)) {</span><span class="s2">\n                </span><span class="s1">return s.value;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else if (isReactive(s)) {</span><span class="s2">\n                </span><span class="s1">return traverse(s);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else if (isFunction(s)) {</span><span class="s2">\n                </span><span class="s1">return callWithErrorHandling(s, instance, 2 /* ErrorCodes.WATCH_GETTER */);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">(process.env.NODE_ENV !== 'production') &amp;&amp; warnInvalidSource(s);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (isFunction(source)) {</span><span class="s2">\n        </span><span class="s1">if (cb) {</span><span class="s2">\n            </span><span class="s1">// getter with cb</span><span class="s2">\n            </span><span class="s1">getter = () =&gt; callWithErrorHandling(source, instance, 2 /* ErrorCodes.WATCH_GETTER */);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">// no cb -&gt; simple effect</span><span class="s2">\n            </span><span class="s1">getter = () =&gt; {</span><span class="s2">\n                </span><span class="s1">if (instance &amp;&amp; instance.isUnmounted) {</span><span class="s2">\n                    </span><span class="s1">return;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">if (cleanup) {</span><span class="s2">\n                    </span><span class="s1">cleanup();</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">return callWithAsyncErrorHandling(source, instance, 3 /* ErrorCodes.WATCH_CALLBACK */, [onCleanup]);</span><span class="s2">\n            </span><span class="s1">};</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">getter = NOOP;</span><span class="s2">\n        </span><span class="s1">(process.env.NODE_ENV !== 'production') &amp;&amp; warnInvalidSource(source);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (cb &amp;&amp; deep) {</span><span class="s2">\n        </span><span class="s1">const baseGetter = getter;</span><span class="s2">\n        </span><span class="s1">getter = () =&gt; traverse(baseGetter());</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let cleanup;</span><span class="s2">\n    </span><span class="s1">let onCleanup = (fn) =&gt; {</span><span class="s2">\n        </span><span class="s1">cleanup = effect.onStop = () =&gt; {</span><span class="s2">\n            </span><span class="s1">callWithErrorHandling(fn, instance, 4 /* ErrorCodes.WATCH_CLEANUP */);</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">// in SSR there is no need to setup an actual effect, and it should be noop</span><span class="s2">\n    </span><span class="s1">// unless it's eager or sync flush</span><span class="s2">\n    </span><span class="s1">let ssrCleanup;</span><span class="s2">\n    </span><span class="s1">if (isInSSRComponentSetup) {</span><span class="s2">\n        </span><span class="s1">// we will also not call the invalidate callback (+ runner is not set up)</span><span class="s2">\n        </span><span class="s1">onCleanup = NOOP;</span><span class="s2">\n        </span><span class="s1">if (!cb) {</span><span class="s2">\n            </span><span class="s1">getter();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (immediate) {</span><span class="s2">\n            </span><span class="s1">callWithAsyncErrorHandling(cb, instance, 3 /* ErrorCodes.WATCH_CALLBACK */, [</span><span class="s2">\n                </span><span class="s1">getter(),</span><span class="s2">\n                </span><span class="s1">isMultiSource ? [] : undefined,</span><span class="s2">\n                </span><span class="s1">onCleanup</span><span class="s2">\n            </span><span class="s1">]);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (flush === 'sync') {</span><span class="s2">\n            </span><span class="s1">const ctx = useSSRContext();</span><span class="s2">\n            </span><span class="s1">ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">return NOOP;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let oldValue = isMultiSource</span><span class="s2">\n        </span><span class="s1">? new Array(source.length).fill(INITIAL_WATCHER_VALUE)</span><span class="s2">\n        </span><span class="s1">: INITIAL_WATCHER_VALUE;</span><span class="s2">\n    </span><span class="s1">const job = () =&gt; {</span><span class="s2">\n        </span><span class="s1">if (!effect.active) {</span><span class="s2">\n            </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (cb) {</span><span class="s2">\n            </span><span class="s1">// watch(source, cb)</span><span class="s2">\n            </span><span class="s1">const newValue = effect.run();</span><span class="s2">\n            </span><span class="s1">if (deep ||</span><span class="s2">\n                </span><span class="s1">forceTrigger ||</span><span class="s2">\n                </span><span class="s1">(isMultiSource</span><span class="s2">\n                    </span><span class="s1">? newValue.some((v, i) =&gt; hasChanged(v, oldValue[i]))</span><span class="s2">\n                    </span><span class="s1">: hasChanged(newValue, oldValue)) ||</span><span class="s2">\n                </span><span class="s1">(false  )) {</span><span class="s2">\n                </span><span class="s1">// cleanup before running cb again</span><span class="s2">\n                </span><span class="s1">if (cleanup) {</span><span class="s2">\n                    </span><span class="s1">cleanup();</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">callWithAsyncErrorHandling(cb, instance, 3 /* ErrorCodes.WATCH_CALLBACK */, [</span><span class="s2">\n                    </span><span class="s1">newValue,</span><span class="s2">\n                    </span><span class="s1">// pass undefined as the old value when it's changed for the first time</span><span class="s2">\n                    </span><span class="s1">oldValue === INITIAL_WATCHER_VALUE</span><span class="s2">\n                        </span><span class="s1">? undefined</span><span class="s2">\n                        </span><span class="s1">: isMultiSource &amp;&amp; oldValue[0] === INITIAL_WATCHER_VALUE</span><span class="s2">\n                            </span><span class="s1">? []</span><span class="s2">\n                            </span><span class="s1">: oldValue,</span><span class="s2">\n                    </span><span class="s1">onCleanup</span><span class="s2">\n                </span><span class="s1">]);</span><span class="s2">\n                </span><span class="s1">oldValue = newValue;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">// watchEffect</span><span class="s2">\n            </span><span class="s1">effect.run();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">// important: mark the job as a watcher callback so that scheduler knows</span><span class="s2">\n    </span><span class="s1">// it is allowed to self-trigger (#1727)</span><span class="s2">\n    </span><span class="s1">job.allowRecurse = !!cb;</span><span class="s2">\n    </span><span class="s1">let scheduler;</span><span class="s2">\n    </span><span class="s1">if (flush === 'sync') {</span><span class="s2">\n        </span><span class="s1">scheduler = job; // the scheduler function gets called directly</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (flush === 'post') {</span><span class="s2">\n        </span><span class="s1">scheduler = () =&gt; queuePostRenderEffect(job, instance &amp;&amp; instance.suspense);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">// default: 'pre'</span><span class="s2">\n        </span><span class="s1">job.pre = true;</span><span class="s2">\n        </span><span class="s1">if (instance)</span><span class="s2">\n            </span><span class="s1">job.id = instance.uid;</span><span class="s2">\n        </span><span class="s1">scheduler = () =&gt; queueJob(job);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">const effect = new ReactiveEffect(getter, scheduler);</span><span class="s2">\n    </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n        </span><span class="s1">effect.onTrack = onTrack;</span><span class="s2">\n        </span><span class="s1">effect.onTrigger = onTrigger;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// initial run</span><span class="s2">\n    </span><span class="s1">if (cb) {</span><span class="s2">\n        </span><span class="s1">if (immediate) {</span><span class="s2">\n            </span><span class="s1">job();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">oldValue = effect.run();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (flush === 'post') {</span><span class="s2">\n        </span><span class="s1">queuePostRenderEffect(effect.run.bind(effect), instance &amp;&amp; instance.suspense);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">effect.run();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">const unwatch = () =&gt; {</span><span class="s2">\n        </span><span class="s1">effect.stop();</span><span class="s2">\n        </span><span class="s1">if (instance &amp;&amp; instance.scope) {</span><span class="s2">\n            </span><span class="s1">remove(instance.scope.effects, effect);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">if (ssrCleanup)</span><span class="s2">\n        </span><span class="s1">ssrCleanup.push(unwatch);</span><span class="s2">\n    </span><span class="s1">return unwatch;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// this.$watch</span><span class="s2">\n</span><span class="s1">function instanceWatch(source, value, options) {</span><span class="s2">\n    </span><span class="s1">const publicThis = this.proxy;</span><span class="s2">\n    </span><span class="s1">const getter = isString(source)</span><span class="s2">\n        </span><span class="s1">? source.includes('.')</span><span class="s2">\n            </span><span class="s1">? createPathGetter(publicThis, source)</span><span class="s2">\n            </span><span class="s1">: () =&gt; publicThis[source]</span><span class="s2">\n        </span><span class="s1">: source.bind(publicThis, publicThis);</span><span class="s2">\n    </span><span class="s1">let cb;</span><span class="s2">\n    </span><span class="s1">if (isFunction(value)) {</span><span class="s2">\n        </span><span class="s1">cb = value;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">cb = value.handler;</span><span class="s2">\n        </span><span class="s1">options = value;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">const cur = currentInstance;</span><span class="s2">\n    </span><span class="s1">setCurrentInstance(this);</span><span class="s2">\n    </span><span class="s1">const res = doWatch(getter, cb.bind(publicThis), options);</span><span class="s2">\n    </span><span class="s1">if (cur) {</span><span class="s2">\n        </span><span class="s1">setCurrentInstance(cur);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">unsetCurrentInstance();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return res;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createPathGetter(ctx, path) {</span><span class="s2">\n    </span><span class="s1">const segments = path.split('.');</span><span class="s2">\n    </span><span class="s1">return () =&gt; {</span><span class="s2">\n        </span><span class="s1">let cur = ctx;</span><span class="s2">\n        </span><span class="s1">for (let i = 0; i &lt; segments.length &amp;&amp; cur; i++) {</span><span class="s2">\n            </span><span class="s1">cur = cur[segments[i]];</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return cur;</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function traverse(value, seen) {</span><span class="s2">\n    </span><span class="s1">if (!isObject(value) || value[</span><span class="s2">\&quot;</span><span class="s1">__v_skip</span><span class="s2">\&quot; </span><span class="s1">/* ReactiveFlags.SKIP */]) {</span><span class="s2">\n        </span><span class="s1">return value;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">seen = seen || new Set();</span><span class="s2">\n    </span><span class="s1">if (seen.has(value)) {</span><span class="s2">\n        </span><span class="s1">return value;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">seen.add(value);</span><span class="s2">\n    </span><span class="s1">if (isRef(value)) {</span><span class="s2">\n        </span><span class="s1">traverse(value.value, seen);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (isArray(value)) {</span><span class="s2">\n        </span><span class="s1">for (let i = 0; i &lt; value.length; i++) {</span><span class="s2">\n            </span><span class="s1">traverse(value[i], seen);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (isSet(value) || isMap(value)) {</span><span class="s2">\n        </span><span class="s1">value.forEach((v) =&gt; {</span><span class="s2">\n            </span><span class="s1">traverse(v, seen);</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (isPlainObject(value)) {</span><span class="s2">\n        </span><span class="s1">for (const key in value) {</span><span class="s2">\n            </span><span class="s1">traverse(value[key], seen);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return value;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function useTransitionState() {</span><span class="s2">\n    </span><span class="s1">const state = {</span><span class="s2">\n        </span><span class="s1">isMounted: false,</span><span class="s2">\n        </span><span class="s1">isLeaving: false,</span><span class="s2">\n        </span><span class="s1">isUnmounting: false,</span><span class="s2">\n        </span><span class="s1">leavingVNodes: new Map()</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">onMounted(() =&gt; {</span><span class="s2">\n        </span><span class="s1">state.isMounted = true;</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">onBeforeUnmount(() =&gt; {</span><span class="s2">\n        </span><span class="s1">state.isUnmounting = true;</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">return state;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">const TransitionHookValidator = [Function, Array];</span><span class="s2">\n</span><span class="s1">const BaseTransitionImpl = {</span><span class="s2">\n    </span><span class="s1">name: `BaseTransition`,</span><span class="s2">\n    </span><span class="s1">props: {</span><span class="s2">\n        </span><span class="s1">mode: String,</span><span class="s2">\n        </span><span class="s1">appear: Boolean,</span><span class="s2">\n        </span><span class="s1">persisted: Boolean,</span><span class="s2">\n        </span><span class="s1">// enter</span><span class="s2">\n        </span><span class="s1">onBeforeEnter: TransitionHookValidator,</span><span class="s2">\n        </span><span class="s1">onEnter: TransitionHookValidator,</span><span class="s2">\n        </span><span class="s1">onAfterEnter: TransitionHookValidator,</span><span class="s2">\n        </span><span class="s1">onEnterCancelled: TransitionHookValidator,</span><span class="s2">\n        </span><span class="s1">// leave</span><span class="s2">\n        </span><span class="s1">onBeforeLeave: TransitionHookValidator,</span><span class="s2">\n        </span><span class="s1">onLeave: TransitionHookValidator,</span><span class="s2">\n        </span><span class="s1">onAfterLeave: TransitionHookValidator,</span><span class="s2">\n        </span><span class="s1">onLeaveCancelled: TransitionHookValidator,</span><span class="s2">\n        </span><span class="s1">// appear</span><span class="s2">\n        </span><span class="s1">onBeforeAppear: TransitionHookValidator,</span><span class="s2">\n        </span><span class="s1">onAppear: TransitionHookValidator,</span><span class="s2">\n        </span><span class="s1">onAfterAppear: TransitionHookValidator,</span><span class="s2">\n        </span><span class="s1">onAppearCancelled: TransitionHookValidator</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">setup(props, { slots }) {</span><span class="s2">\n        </span><span class="s1">const instance = getCurrentInstance();</span><span class="s2">\n        </span><span class="s1">const state = useTransitionState();</span><span class="s2">\n        </span><span class="s1">let prevTransitionKey;</span><span class="s2">\n        </span><span class="s1">return () =&gt; {</span><span class="s2">\n            </span><span class="s1">const children = slots.default &amp;&amp; getTransitionRawChildren(slots.default(), true);</span><span class="s2">\n            </span><span class="s1">if (!children || !children.length) {</span><span class="s2">\n                </span><span class="s1">return;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">let child = children[0];</span><span class="s2">\n            </span><span class="s1">if (children.length &gt; 1) {</span><span class="s2">\n                </span><span class="s1">let hasFound = false;</span><span class="s2">\n                </span><span class="s1">// locate first non-comment child</span><span class="s2">\n                </span><span class="s1">for (const c of children) {</span><span class="s2">\n                    </span><span class="s1">if (c.type !== Comment) {</span><span class="s2">\n                        </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp; hasFound) {</span><span class="s2">\n                            </span><span class="s1">// warn more than one non-comment child</span><span class="s2">\n                            </span><span class="s1">warn('&lt;transition&gt; can only be used on a single element or component. ' +</span><span class="s2">\n                                </span><span class="s1">'Use &lt;transition-group&gt; for lists.');</span><span class="s2">\n                            </span><span class="s1">break;</span><span class="s2">\n                        </span><span class="s1">}</span><span class="s2">\n                        </span><span class="s1">child = c;</span><span class="s2">\n                        </span><span class="s1">hasFound = true;</span><span class="s2">\n                        </span><span class="s1">if (!(process.env.NODE_ENV !== 'production'))</span><span class="s2">\n                            </span><span class="s1">break;</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">// there's no need to track reactivity for these props so use the raw</span><span class="s2">\n            </span><span class="s1">// props for a bit better perf</span><span class="s2">\n            </span><span class="s1">const rawProps = toRaw(props);</span><span class="s2">\n            </span><span class="s1">const { mode } = rawProps;</span><span class="s2">\n            </span><span class="s1">// check mode</span><span class="s2">\n            </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp;</span><span class="s2">\n                </span><span class="s1">mode &amp;&amp;</span><span class="s2">\n                </span><span class="s1">mode !== 'in-out' &amp;&amp;</span><span class="s2">\n                </span><span class="s1">mode !== 'out-in' &amp;&amp;</span><span class="s2">\n                </span><span class="s1">mode !== 'default') {</span><span class="s2">\n                </span><span class="s1">warn(`invalid &lt;transition&gt; mode: ${mode}`);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">if (state.isLeaving) {</span><span class="s2">\n                </span><span class="s1">return emptyPlaceholder(child);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">// in the case of &lt;transition&gt;&lt;keep-alive/&gt;&lt;/transition&gt;, we need to</span><span class="s2">\n            </span><span class="s1">// compare the type of the kept-alive children.</span><span class="s2">\n            </span><span class="s1">const innerChild = getKeepAliveChild(child);</span><span class="s2">\n            </span><span class="s1">if (!innerChild) {</span><span class="s2">\n                </span><span class="s1">return emptyPlaceholder(child);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">const enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance);</span><span class="s2">\n            </span><span class="s1">setTransitionHooks(innerChild, enterHooks);</span><span class="s2">\n            </span><span class="s1">const oldChild = instance.subTree;</span><span class="s2">\n            </span><span class="s1">const oldInnerChild = oldChild &amp;&amp; getKeepAliveChild(oldChild);</span><span class="s2">\n            </span><span class="s1">let transitionKeyChanged = false;</span><span class="s2">\n            </span><span class="s1">const { getTransitionKey } = innerChild.type;</span><span class="s2">\n            </span><span class="s1">if (getTransitionKey) {</span><span class="s2">\n                </span><span class="s1">const key = getTransitionKey();</span><span class="s2">\n                </span><span class="s1">if (prevTransitionKey === undefined) {</span><span class="s2">\n                    </span><span class="s1">prevTransitionKey = key;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else if (key !== prevTransitionKey) {</span><span class="s2">\n                    </span><span class="s1">prevTransitionKey = key;</span><span class="s2">\n                    </span><span class="s1">transitionKeyChanged = true;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">// handle mode</span><span class="s2">\n            </span><span class="s1">if (oldInnerChild &amp;&amp;</span><span class="s2">\n                </span><span class="s1">oldInnerChild.type !== Comment &amp;&amp;</span><span class="s2">\n                </span><span class="s1">(!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {</span><span class="s2">\n                </span><span class="s1">const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance);</span><span class="s2">\n                </span><span class="s1">// update old tree's hooks in case of dynamic transition</span><span class="s2">\n                </span><span class="s1">setTransitionHooks(oldInnerChild, leavingHooks);</span><span class="s2">\n                </span><span class="s1">// switching between different views</span><span class="s2">\n                </span><span class="s1">if (mode === 'out-in') {</span><span class="s2">\n                    </span><span class="s1">state.isLeaving = true;</span><span class="s2">\n                    </span><span class="s1">// return placeholder node and queue update when leave finishes</span><span class="s2">\n                    </span><span class="s1">leavingHooks.afterLeave = () =&gt; {</span><span class="s2">\n                        </span><span class="s1">state.isLeaving = false;</span><span class="s2">\n                        </span><span class="s1">// #6835</span><span class="s2">\n                        </span><span class="s1">// it also needs to be updated when active is undefined</span><span class="s2">\n                        </span><span class="s1">if (instance.update.active !== false) {</span><span class="s2">\n                            </span><span class="s1">instance.update();</span><span class="s2">\n                        </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">};</span><span class="s2">\n                    </span><span class="s1">return emptyPlaceholder(child);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else if (mode === 'in-out' &amp;&amp; innerChild.type !== Comment) {</span><span class="s2">\n                    </span><span class="s1">leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) =&gt; {</span><span class="s2">\n                        </span><span class="s1">const leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);</span><span class="s2">\n                        </span><span class="s1">leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;</span><span class="s2">\n                        </span><span class="s1">// early removal callback</span><span class="s2">\n                        </span><span class="s1">el._leaveCb = () =&gt; {</span><span class="s2">\n                            </span><span class="s1">earlyRemove();</span><span class="s2">\n                            </span><span class="s1">el._leaveCb = undefined;</span><span class="s2">\n                            </span><span class="s1">delete enterHooks.delayedLeave;</span><span class="s2">\n                        </span><span class="s1">};</span><span class="s2">\n                        </span><span class="s1">enterHooks.delayedLeave = delayedLeave;</span><span class="s2">\n                    </span><span class="s1">};</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">return child;</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">// export the public type for h/tsx inference</span><span class="s2">\n</span><span class="s1">// also to avoid inline import() in generated d.ts files</span><span class="s2">\n</span><span class="s1">const BaseTransition = BaseTransitionImpl;</span><span class="s2">\n</span><span class="s1">function getLeavingNodesForType(state, vnode) {</span><span class="s2">\n    </span><span class="s1">const { leavingVNodes } = state;</span><span class="s2">\n    </span><span class="s1">let leavingVNodesCache = leavingVNodes.get(vnode.type);</span><span class="s2">\n    </span><span class="s1">if (!leavingVNodesCache) {</span><span class="s2">\n        </span><span class="s1">leavingVNodesCache = Object.create(null);</span><span class="s2">\n        </span><span class="s1">leavingVNodes.set(vnode.type, leavingVNodesCache);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return leavingVNodesCache;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// The transition hooks are attached to the vnode as vnode.transition</span><span class="s2">\n</span><span class="s1">// and will be called at appropriate timing in the renderer.</span><span class="s2">\n</span><span class="s1">function resolveTransitionHooks(vnode, props, state, instance) {</span><span class="s2">\n    </span><span class="s1">const { appear, mode, persisted = false, onBeforeEnter, onEnter, onAfterEnter, onEnterCancelled, onBeforeLeave, onLeave, onAfterLeave, onLeaveCancelled, onBeforeAppear, onAppear, onAfterAppear, onAppearCancelled } = props;</span><span class="s2">\n    </span><span class="s1">const key = String(vnode.key);</span><span class="s2">\n    </span><span class="s1">const leavingVNodesCache = getLeavingNodesForType(state, vnode);</span><span class="s2">\n    </span><span class="s1">const callHook = (hook, args) =&gt; {</span><span class="s2">\n        </span><span class="s1">hook &amp;&amp;</span><span class="s2">\n            </span><span class="s1">callWithAsyncErrorHandling(hook, instance, 9 /* ErrorCodes.TRANSITION_HOOK */, args);</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">const callAsyncHook = (hook, args) =&gt; {</span><span class="s2">\n        </span><span class="s1">const done = args[1];</span><span class="s2">\n        </span><span class="s1">callHook(hook, args);</span><span class="s2">\n        </span><span class="s1">if (isArray(hook)) {</span><span class="s2">\n            </span><span class="s1">if (hook.every(hook =&gt; hook.length &lt;= 1))</span><span class="s2">\n                </span><span class="s1">done();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (hook.length &lt;= 1) {</span><span class="s2">\n            </span><span class="s1">done();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">const hooks = {</span><span class="s2">\n        </span><span class="s1">mode,</span><span class="s2">\n        </span><span class="s1">persisted,</span><span class="s2">\n        </span><span class="s1">beforeEnter(el) {</span><span class="s2">\n            </span><span class="s1">let hook = onBeforeEnter;</span><span class="s2">\n            </span><span class="s1">if (!state.isMounted) {</span><span class="s2">\n                </span><span class="s1">if (appear) {</span><span class="s2">\n                    </span><span class="s1">hook = onBeforeAppear || onBeforeEnter;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else {</span><span class="s2">\n                    </span><span class="s1">return;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">// for same element (v-show)</span><span class="s2">\n            </span><span class="s1">if (el._leaveCb) {</span><span class="s2">\n                </span><span class="s1">el._leaveCb(true /* cancelled */);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">// for toggled element with same key (v-if)</span><span class="s2">\n            </span><span class="s1">const leavingVNode = leavingVNodesCache[key];</span><span class="s2">\n            </span><span class="s1">if (leavingVNode &amp;&amp;</span><span class="s2">\n                </span><span class="s1">isSameVNodeType(vnode, leavingVNode) &amp;&amp;</span><span class="s2">\n                </span><span class="s1">leavingVNode.el._leaveCb) {</span><span class="s2">\n                </span><span class="s1">// force early removal (not cancelled)</span><span class="s2">\n                </span><span class="s1">leavingVNode.el._leaveCb();</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">callHook(hook, [el]);</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">enter(el) {</span><span class="s2">\n            </span><span class="s1">let hook = onEnter;</span><span class="s2">\n            </span><span class="s1">let afterHook = onAfterEnter;</span><span class="s2">\n            </span><span class="s1">let cancelHook = onEnterCancelled;</span><span class="s2">\n            </span><span class="s1">if (!state.isMounted) {</span><span class="s2">\n                </span><span class="s1">if (appear) {</span><span class="s2">\n                    </span><span class="s1">hook = onAppear || onEnter;</span><span class="s2">\n                    </span><span class="s1">afterHook = onAfterAppear || onAfterEnter;</span><span class="s2">\n                    </span><span class="s1">cancelHook = onAppearCancelled || onEnterCancelled;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else {</span><span class="s2">\n                    </span><span class="s1">return;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">let called = false;</span><span class="s2">\n            </span><span class="s1">const done = (el._enterCb = (cancelled) =&gt; {</span><span class="s2">\n                </span><span class="s1">if (called)</span><span class="s2">\n                    </span><span class="s1">return;</span><span class="s2">\n                </span><span class="s1">called = true;</span><span class="s2">\n                </span><span class="s1">if (cancelled) {</span><span class="s2">\n                    </span><span class="s1">callHook(cancelHook, [el]);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else {</span><span class="s2">\n                    </span><span class="s1">callHook(afterHook, [el]);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">if (hooks.delayedLeave) {</span><span class="s2">\n                    </span><span class="s1">hooks.delayedLeave();</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">el._enterCb = undefined;</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n            </span><span class="s1">if (hook) {</span><span class="s2">\n                </span><span class="s1">callAsyncHook(hook, [el, done]);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">done();</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">leave(el, remove) {</span><span class="s2">\n            </span><span class="s1">const key = String(vnode.key);</span><span class="s2">\n            </span><span class="s1">if (el._enterCb) {</span><span class="s2">\n                </span><span class="s1">el._enterCb(true /* cancelled */);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">if (state.isUnmounting) {</span><span class="s2">\n                </span><span class="s1">return remove();</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">callHook(onBeforeLeave, [el]);</span><span class="s2">\n            </span><span class="s1">let called = false;</span><span class="s2">\n            </span><span class="s1">const done = (el._leaveCb = (cancelled) =&gt; {</span><span class="s2">\n                </span><span class="s1">if (called)</span><span class="s2">\n                    </span><span class="s1">return;</span><span class="s2">\n                </span><span class="s1">called = true;</span><span class="s2">\n                </span><span class="s1">remove();</span><span class="s2">\n                </span><span class="s1">if (cancelled) {</span><span class="s2">\n                    </span><span class="s1">callHook(onLeaveCancelled, [el]);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else {</span><span class="s2">\n                    </span><span class="s1">callHook(onAfterLeave, [el]);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">el._leaveCb = undefined;</span><span class="s2">\n                </span><span class="s1">if (leavingVNodesCache[key] === vnode) {</span><span class="s2">\n                    </span><span class="s1">delete leavingVNodesCache[key];</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n            </span><span class="s1">leavingVNodesCache[key] = vnode;</span><span class="s2">\n            </span><span class="s1">if (onLeave) {</span><span class="s2">\n                </span><span class="s1">callAsyncHook(onLeave, [el, done]);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">done();</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">clone(vnode) {</span><span class="s2">\n            </span><span class="s1">return resolveTransitionHooks(vnode, props, state, instance);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">return hooks;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// the placeholder really only handles one special case: KeepAlive</span><span class="s2">\n</span><span class="s1">// in the case of a KeepAlive in a leave phase we need to return a KeepAlive</span><span class="s2">\n</span><span class="s1">// placeholder with empty content to avoid the KeepAlive instance from being</span><span class="s2">\n</span><span class="s1">// unmounted.</span><span class="s2">\n</span><span class="s1">function emptyPlaceholder(vnode) {</span><span class="s2">\n    </span><span class="s1">if (isKeepAlive(vnode)) {</span><span class="s2">\n        </span><span class="s1">vnode = cloneVNode(vnode);</span><span class="s2">\n        </span><span class="s1">vnode.children = null;</span><span class="s2">\n        </span><span class="s1">return vnode;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getKeepAliveChild(vnode) {</span><span class="s2">\n    </span><span class="s1">return isKeepAlive(vnode)</span><span class="s2">\n        </span><span class="s1">? vnode.children</span><span class="s2">\n            </span><span class="s1">? vnode.children[0]</span><span class="s2">\n            </span><span class="s1">: undefined</span><span class="s2">\n        </span><span class="s1">: vnode;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function setTransitionHooks(vnode, hooks) {</span><span class="s2">\n    </span><span class="s1">if (vnode.shapeFlag &amp; 6 /* ShapeFlags.COMPONENT */ &amp;&amp; vnode.component) {</span><span class="s2">\n        </span><span class="s1">setTransitionHooks(vnode.component.subTree, hooks);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (vnode.shapeFlag &amp; 128 /* ShapeFlags.SUSPENSE */) {</span><span class="s2">\n        </span><span class="s1">vnode.ssContent.transition = hooks.clone(vnode.ssContent);</span><span class="s2">\n        </span><span class="s1">vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">vnode.transition = hooks;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getTransitionRawChildren(children, keepComment = false, parentKey) {</span><span class="s2">\n    </span><span class="s1">let ret = [];</span><span class="s2">\n    </span><span class="s1">let keyedFragmentCount = 0;</span><span class="s2">\n    </span><span class="s1">for (let i = 0; i &lt; children.length; i++) {</span><span class="s2">\n        </span><span class="s1">let child = children[i];</span><span class="s2">\n        </span><span class="s1">// #5360 inherit parent key in case of &lt;template v-for&gt;</span><span class="s2">\n        </span><span class="s1">const key = parentKey == null</span><span class="s2">\n            </span><span class="s1">? child.key</span><span class="s2">\n            </span><span class="s1">: String(parentKey) + String(child.key != null ? child.key : i);</span><span class="s2">\n        </span><span class="s1">// handle fragment children case, e.g. v-for</span><span class="s2">\n        </span><span class="s1">if (child.type === Fragment) {</span><span class="s2">\n            </span><span class="s1">if (child.patchFlag &amp; 128 /* PatchFlags.KEYED_FRAGMENT */)</span><span class="s2">\n                </span><span class="s1">keyedFragmentCount++;</span><span class="s2">\n            </span><span class="s1">ret = ret.concat(getTransitionRawChildren(child.children, keepComment, key));</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// comment placeholders should be skipped, e.g. v-if</span><span class="s2">\n        </span><span class="s1">else if (keepComment || child.type !== Comment) {</span><span class="s2">\n            </span><span class="s1">ret.push(key != null ? cloneVNode(child, { key }) : child);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// #1126 if a transition children list contains multiple sub fragments, these</span><span class="s2">\n    </span><span class="s1">// fragments will be merged into a flat children array. Since each v-for</span><span class="s2">\n    </span><span class="s1">// fragment may contain different static bindings inside, we need to de-op</span><span class="s2">\n    </span><span class="s1">// these children to force full diffs to ensure correct behavior.</span><span class="s2">\n    </span><span class="s1">if (keyedFragmentCount &gt; 1) {</span><span class="s2">\n        </span><span class="s1">for (let i = 0; i &lt; ret.length; i++) {</span><span class="s2">\n            </span><span class="s1">ret[i].patchFlag = -2 /* PatchFlags.BAIL */;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return ret;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// implementation, close to no-op</span><span class="s2">\n</span><span class="s1">function defineComponent(options) {</span><span class="s2">\n    </span><span class="s1">return isFunction(options) ? { setup: options, name: options.name } : options;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">const isAsyncWrapper = (i) =&gt; !!i.type.__asyncLoader;</span><span class="s2">\n</span><span class="s1">function defineAsyncComponent(source) {</span><span class="s2">\n    </span><span class="s1">if (isFunction(source)) {</span><span class="s2">\n        </span><span class="s1">source = { loader: source };</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">const { loader, loadingComponent, errorComponent, delay = 200, timeout, // undefined = never times out</span><span class="s2">\n    </span><span class="s1">suspensible = true, onError: userOnError } = source;</span><span class="s2">\n    </span><span class="s1">let pendingRequest = null;</span><span class="s2">\n    </span><span class="s1">let resolvedComp;</span><span class="s2">\n    </span><span class="s1">let retries = 0;</span><span class="s2">\n    </span><span class="s1">const retry = () =&gt; {</span><span class="s2">\n        </span><span class="s1">retries++;</span><span class="s2">\n        </span><span class="s1">pendingRequest = null;</span><span class="s2">\n        </span><span class="s1">return load();</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">const load = () =&gt; {</span><span class="s2">\n        </span><span class="s1">let thisRequest;</span><span class="s2">\n        </span><span class="s1">return (pendingRequest ||</span><span class="s2">\n            </span><span class="s1">(thisRequest = pendingRequest =</span><span class="s2">\n                </span><span class="s1">loader()</span><span class="s2">\n                    </span><span class="s1">.catch(err =&gt; {</span><span class="s2">\n                    </span><span class="s1">err = err instanceof Error ? err : new Error(String(err));</span><span class="s2">\n                    </span><span class="s1">if (userOnError) {</span><span class="s2">\n                        </span><span class="s1">return new Promise((resolve, reject) =&gt; {</span><span class="s2">\n                            </span><span class="s1">const userRetry = () =&gt; resolve(retry());</span><span class="s2">\n                            </span><span class="s1">const userFail = () =&gt; reject(err);</span><span class="s2">\n                            </span><span class="s1">userOnError(err, userRetry, userFail, retries + 1);</span><span class="s2">\n                        </span><span class="s1">});</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">else {</span><span class="s2">\n                        </span><span class="s1">throw err;</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">})</span><span class="s2">\n                    </span><span class="s1">.then((comp) =&gt; {</span><span class="s2">\n                    </span><span class="s1">if (thisRequest !== pendingRequest &amp;&amp; pendingRequest) {</span><span class="s2">\n                        </span><span class="s1">return pendingRequest;</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp; !comp) {</span><span class="s2">\n                        </span><span class="s1">warn(`Async component loader resolved to undefined. ` +</span><span class="s2">\n                            </span><span class="s1">`If you are using retry(), make sure to return its return value.`);</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">// interop module default</span><span class="s2">\n                    </span><span class="s1">if (comp &amp;&amp;</span><span class="s2">\n                        </span><span class="s1">(comp.__esModule || comp[Symbol.toStringTag] === 'Module')) {</span><span class="s2">\n                        </span><span class="s1">comp = comp.default;</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp; comp &amp;&amp; !isObject(comp) &amp;&amp; !isFunction(comp)) {</span><span class="s2">\n                        </span><span class="s1">throw new Error(`Invalid async component load result: ${comp}`);</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">resolvedComp = comp;</span><span class="s2">\n                    </span><span class="s1">return comp;</span><span class="s2">\n                </span><span class="s1">})));</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">return defineComponent({</span><span class="s2">\n        </span><span class="s1">name: 'AsyncComponentWrapper',</span><span class="s2">\n        </span><span class="s1">__asyncLoader: load,</span><span class="s2">\n        </span><span class="s1">get __asyncResolved() {</span><span class="s2">\n            </span><span class="s1">return resolvedComp;</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">setup() {</span><span class="s2">\n            </span><span class="s1">const instance = currentInstance;</span><span class="s2">\n            </span><span class="s1">// already resolved</span><span class="s2">\n            </span><span class="s1">if (resolvedComp) {</span><span class="s2">\n                </span><span class="s1">return () =&gt; createInnerComp(resolvedComp, instance);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">const onError = (err) =&gt; {</span><span class="s2">\n                </span><span class="s1">pendingRequest = null;</span><span class="s2">\n                </span><span class="s1">handleError(err, instance, 13 /* ErrorCodes.ASYNC_COMPONENT_LOADER */, !errorComponent /* do not throw in dev if user provided error component */);</span><span class="s2">\n            </span><span class="s1">};</span><span class="s2">\n            </span><span class="s1">// suspense-controlled or SSR.</span><span class="s2">\n            </span><span class="s1">if ((suspensible &amp;&amp; instance.suspense) ||</span><span class="s2">\n                </span><span class="s1">(isInSSRComponentSetup)) {</span><span class="s2">\n                </span><span class="s1">return load()</span><span class="s2">\n                    </span><span class="s1">.then(comp =&gt; {</span><span class="s2">\n                    </span><span class="s1">return () =&gt; createInnerComp(comp, instance);</span><span class="s2">\n                </span><span class="s1">})</span><span class="s2">\n                    </span><span class="s1">.catch(err =&gt; {</span><span class="s2">\n                    </span><span class="s1">onError(err);</span><span class="s2">\n                    </span><span class="s1">return () =&gt; errorComponent</span><span class="s2">\n                        </span><span class="s1">? createVNode(errorComponent, {</span><span class="s2">\n                            </span><span class="s1">error: err</span><span class="s2">\n                        </span><span class="s1">})</span><span class="s2">\n                        </span><span class="s1">: null;</span><span class="s2">\n                </span><span class="s1">});</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">const loaded = ref(false);</span><span class="s2">\n            </span><span class="s1">const error = ref();</span><span class="s2">\n            </span><span class="s1">const delayed = ref(!!delay);</span><span class="s2">\n            </span><span class="s1">if (delay) {</span><span class="s2">\n                </span><span class="s1">setTimeout(() =&gt; {</span><span class="s2">\n                    </span><span class="s1">delayed.value = false;</span><span class="s2">\n                </span><span class="s1">}, delay);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">if (timeout != null) {</span><span class="s2">\n                </span><span class="s1">setTimeout(() =&gt; {</span><span class="s2">\n                    </span><span class="s1">if (!loaded.value &amp;&amp; !error.value) {</span><span class="s2">\n                        </span><span class="s1">const err = new Error(`Async component timed out after ${timeout}ms.`);</span><span class="s2">\n                        </span><span class="s1">onError(err);</span><span class="s2">\n                        </span><span class="s1">error.value = err;</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">}, timeout);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">load()</span><span class="s2">\n                </span><span class="s1">.then(() =&gt; {</span><span class="s2">\n                </span><span class="s1">loaded.value = true;</span><span class="s2">\n                </span><span class="s1">if (instance.parent &amp;&amp; isKeepAlive(instance.parent.vnode)) {</span><span class="s2">\n                    </span><span class="s1">// parent is keep-alive, force update so the loaded component's</span><span class="s2">\n                    </span><span class="s1">// name is taken into account</span><span class="s2">\n                    </span><span class="s1">queueJob(instance.parent.update);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">})</span><span class="s2">\n                </span><span class="s1">.catch(err =&gt; {</span><span class="s2">\n                </span><span class="s1">onError(err);</span><span class="s2">\n                </span><span class="s1">error.value = err;</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n            </span><span class="s1">return () =&gt; {</span><span class="s2">\n                </span><span class="s1">if (loaded.value &amp;&amp; resolvedComp) {</span><span class="s2">\n                    </span><span class="s1">return createInnerComp(resolvedComp, instance);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else if (error.value &amp;&amp; errorComponent) {</span><span class="s2">\n                    </span><span class="s1">return createVNode(errorComponent, {</span><span class="s2">\n                        </span><span class="s1">error: error.value</span><span class="s2">\n                    </span><span class="s1">});</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else if (loadingComponent &amp;&amp; !delayed.value) {</span><span class="s2">\n                    </span><span class="s1">return createVNode(loadingComponent);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">};</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createInnerComp(comp, parent) {</span><span class="s2">\n    </span><span class="s1">const { ref, props, children, ce } = parent.vnode;</span><span class="s2">\n    </span><span class="s1">const vnode = createVNode(comp, props, children);</span><span class="s2">\n    </span><span class="s1">// ensure inner component inherits the async wrapper's ref owner</span><span class="s2">\n    </span><span class="s1">vnode.ref = ref;</span><span class="s2">\n    </span><span class="s1">// pass the custom element callback on to the inner comp</span><span class="s2">\n    </span><span class="s1">// and remove it from the async wrapper</span><span class="s2">\n    </span><span class="s1">vnode.ce = ce;</span><span class="s2">\n    </span><span class="s1">delete parent.vnode.ce;</span><span class="s2">\n    </span><span class="s1">return vnode;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">const isKeepAlive = (vnode) =&gt; vnode.type.__isKeepAlive;</span><span class="s2">\n</span><span class="s1">const KeepAliveImpl = {</span><span class="s2">\n    </span><span class="s1">name: `KeepAlive`,</span><span class="s2">\n    </span><span class="s1">// Marker for special handling inside the renderer. We are not using a ===</span><span class="s2">\n    </span><span class="s1">// check directly on KeepAlive in the renderer, because importing it directly</span><span class="s2">\n    </span><span class="s1">// would prevent it from being tree-shaken.</span><span class="s2">\n    </span><span class="s1">__isKeepAlive: true,</span><span class="s2">\n    </span><span class="s1">props: {</span><span class="s2">\n        </span><span class="s1">include: [String, RegExp, Array],</span><span class="s2">\n        </span><span class="s1">exclude: [String, RegExp, Array],</span><span class="s2">\n        </span><span class="s1">max: [String, Number]</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">setup(props, { slots }) {</span><span class="s2">\n        </span><span class="s1">const instance = getCurrentInstance();</span><span class="s2">\n        </span><span class="s1">// KeepAlive communicates with the instantiated renderer via the</span><span class="s2">\n        </span><span class="s1">// ctx where the renderer passes in its internals,</span><span class="s2">\n        </span><span class="s1">// and the KeepAlive instance exposes activate/deactivate implementations.</span><span class="s2">\n        </span><span class="s1">// The whole point of this is to avoid importing KeepAlive directly in the</span><span class="s2">\n        </span><span class="s1">// renderer to facilitate tree-shaking.</span><span class="s2">\n        </span><span class="s1">const sharedContext = instance.ctx;</span><span class="s2">\n        </span><span class="s1">// if the internal renderer is not registered, it indicates that this is server-side rendering,</span><span class="s2">\n        </span><span class="s1">// for KeepAlive, we just need to render its children</span><span class="s2">\n        </span><span class="s1">if (!sharedContext.renderer) {</span><span class="s2">\n            </span><span class="s1">return () =&gt; {</span><span class="s2">\n                </span><span class="s1">const children = slots.default &amp;&amp; slots.default();</span><span class="s2">\n                </span><span class="s1">return children &amp;&amp; children.length === 1 ? children[0] : children;</span><span class="s2">\n            </span><span class="s1">};</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">const cache = new Map();</span><span class="s2">\n        </span><span class="s1">const keys = new Set();</span><span class="s2">\n        </span><span class="s1">let current = null;</span><span class="s2">\n        </span><span class="s1">if ((process.env.NODE_ENV !== 'production') || __VUE_PROD_DEVTOOLS__) {</span><span class="s2">\n            </span><span class="s1">instance.__v_cache = cache;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">const parentSuspense = instance.suspense;</span><span class="s2">\n        </span><span class="s1">const { renderer: { p: patch, m: move, um: _unmount, o: { createElement } } } = sharedContext;</span><span class="s2">\n        </span><span class="s1">const storageContainer = createElement('div');</span><span class="s2">\n        </span><span class="s1">sharedContext.activate = (vnode, container, anchor, isSVG, optimized) =&gt; {</span><span class="s2">\n            </span><span class="s1">const instance = vnode.component;</span><span class="s2">\n            </span><span class="s1">move(vnode, container, anchor, 0 /* MoveType.ENTER */, parentSuspense);</span><span class="s2">\n            </span><span class="s1">// in case props have changed</span><span class="s2">\n            </span><span class="s1">patch(instance.vnode, vnode, container, anchor, instance, parentSuspense, isSVG, vnode.slotScopeIds, optimized);</span><span class="s2">\n            </span><span class="s1">queuePostRenderEffect(() =&gt; {</span><span class="s2">\n                </span><span class="s1">instance.isDeactivated = false;</span><span class="s2">\n                </span><span class="s1">if (instance.a) {</span><span class="s2">\n                    </span><span class="s1">invokeArrayFns(instance.a);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">const vnodeHook = vnode.props &amp;&amp; vnode.props.onVnodeMounted;</span><span class="s2">\n                </span><span class="s1">if (vnodeHook) {</span><span class="s2">\n                    </span><span class="s1">invokeVNodeHook(vnodeHook, instance.parent, vnode);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}, parentSuspense);</span><span class="s2">\n            </span><span class="s1">if ((process.env.NODE_ENV !== 'production') || __VUE_PROD_DEVTOOLS__) {</span><span class="s2">\n                </span><span class="s1">// Update components tree</span><span class="s2">\n                </span><span class="s1">devtoolsComponentAdded(instance);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n        </span><span class="s1">sharedContext.deactivate = (vnode) =&gt; {</span><span class="s2">\n            </span><span class="s1">const instance = vnode.component;</span><span class="s2">\n            </span><span class="s1">move(vnode, storageContainer, null, 1 /* MoveType.LEAVE */, parentSuspense);</span><span class="s2">\n            </span><span class="s1">queuePostRenderEffect(() =&gt; {</span><span class="s2">\n                </span><span class="s1">if (instance.da) {</span><span class="s2">\n                    </span><span class="s1">invokeArrayFns(instance.da);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">const vnodeHook = vnode.props &amp;&amp; vnode.props.onVnodeUnmounted;</span><span class="s2">\n                </span><span class="s1">if (vnodeHook) {</span><span class="s2">\n                    </span><span class="s1">invokeVNodeHook(vnodeHook, instance.parent, vnode);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">instance.isDeactivated = true;</span><span class="s2">\n            </span><span class="s1">}, parentSuspense);</span><span class="s2">\n            </span><span class="s1">if ((process.env.NODE_ENV !== 'production') || __VUE_PROD_DEVTOOLS__) {</span><span class="s2">\n                </span><span class="s1">// Update components tree</span><span class="s2">\n                </span><span class="s1">devtoolsComponentAdded(instance);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n        </span><span class="s1">function unmount(vnode) {</span><span class="s2">\n            </span><span class="s1">// reset the shapeFlag so it can be properly unmounted</span><span class="s2">\n            </span><span class="s1">resetShapeFlag(vnode);</span><span class="s2">\n            </span><span class="s1">_unmount(vnode, instance, parentSuspense, true);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">function pruneCache(filter) {</span><span class="s2">\n            </span><span class="s1">cache.forEach((vnode, key) =&gt; {</span><span class="s2">\n                </span><span class="s1">const name = getComponentName(vnode.type);</span><span class="s2">\n                </span><span class="s1">if (name &amp;&amp; (!filter || !filter(name))) {</span><span class="s2">\n                    </span><span class="s1">pruneCacheEntry(key);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">function pruneCacheEntry(key) {</span><span class="s2">\n            </span><span class="s1">const cached = cache.get(key);</span><span class="s2">\n            </span><span class="s1">if (!current || !isSameVNodeType(cached, current)) {</span><span class="s2">\n                </span><span class="s1">unmount(cached);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else if (current) {</span><span class="s2">\n                </span><span class="s1">// current active instance should no longer be kept-alive.</span><span class="s2">\n                </span><span class="s1">// we can't unmount it now but it might be later, so reset its flag now.</span><span class="s2">\n                </span><span class="s1">resetShapeFlag(current);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">cache.delete(key);</span><span class="s2">\n            </span><span class="s1">keys.delete(key);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// prune cache on include/exclude prop change</span><span class="s2">\n        </span><span class="s1">watch(() =&gt; [props.include, props.exclude], ([include, exclude]) =&gt; {</span><span class="s2">\n            </span><span class="s1">include &amp;&amp; pruneCache(name =&gt; matches(include, name));</span><span class="s2">\n            </span><span class="s1">exclude &amp;&amp; pruneCache(name =&gt; !matches(exclude, name));</span><span class="s2">\n        </span><span class="s1">}, </span><span class="s2">\n        </span><span class="s1">// prune post-render after `current` has been updated</span><span class="s2">\n        </span><span class="s1">{ flush: 'post', deep: true });</span><span class="s2">\n        </span><span class="s1">// cache sub tree after render</span><span class="s2">\n        </span><span class="s1">let pendingCacheKey = null;</span><span class="s2">\n        </span><span class="s1">const cacheSubtree = () =&gt; {</span><span class="s2">\n            </span><span class="s1">// fix #1621, the pendingCacheKey could be 0</span><span class="s2">\n            </span><span class="s1">if (pendingCacheKey != null) {</span><span class="s2">\n                </span><span class="s1">cache.set(pendingCacheKey, getInnerChild(instance.subTree));</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n        </span><span class="s1">onMounted(cacheSubtree);</span><span class="s2">\n        </span><span class="s1">onUpdated(cacheSubtree);</span><span class="s2">\n        </span><span class="s1">onBeforeUnmount(() =&gt; {</span><span class="s2">\n            </span><span class="s1">cache.forEach(cached =&gt; {</span><span class="s2">\n                </span><span class="s1">const { subTree, suspense } = instance;</span><span class="s2">\n                </span><span class="s1">const vnode = getInnerChild(subTree);</span><span class="s2">\n                </span><span class="s1">if (cached.type === vnode.type &amp;&amp; cached.key === vnode.key) {</span><span class="s2">\n                    </span><span class="s1">// current instance will be unmounted as part of keep-alive's unmount</span><span class="s2">\n                    </span><span class="s1">resetShapeFlag(vnode);</span><span class="s2">\n                    </span><span class="s1">// but invoke its deactivated hook here</span><span class="s2">\n                    </span><span class="s1">const da = vnode.component.da;</span><span class="s2">\n                    </span><span class="s1">da &amp;&amp; queuePostRenderEffect(da, suspense);</span><span class="s2">\n                    </span><span class="s1">return;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">unmount(cached);</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">return () =&gt; {</span><span class="s2">\n            </span><span class="s1">pendingCacheKey = null;</span><span class="s2">\n            </span><span class="s1">if (!slots.default) {</span><span class="s2">\n                </span><span class="s1">return null;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">const children = slots.default();</span><span class="s2">\n            </span><span class="s1">const rawVNode = children[0];</span><span class="s2">\n            </span><span class="s1">if (children.length &gt; 1) {</span><span class="s2">\n                </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n                    </span><span class="s1">warn(`KeepAlive should contain exactly one component child.`);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">current = null;</span><span class="s2">\n                </span><span class="s1">return children;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else if (!isVNode(rawVNode) ||</span><span class="s2">\n                </span><span class="s1">(!(rawVNode.shapeFlag &amp; 4 /* ShapeFlags.STATEFUL_COMPONENT */) &amp;&amp;</span><span class="s2">\n                    </span><span class="s1">!(rawVNode.shapeFlag &amp; 128 /* ShapeFlags.SUSPENSE */))) {</span><span class="s2">\n                </span><span class="s1">current = null;</span><span class="s2">\n                </span><span class="s1">return rawVNode;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">let vnode = getInnerChild(rawVNode);</span><span class="s2">\n            </span><span class="s1">const comp = vnode.type;</span><span class="s2">\n            </span><span class="s1">// for async components, name check should be based in its loaded</span><span class="s2">\n            </span><span class="s1">// inner component if available</span><span class="s2">\n            </span><span class="s1">const name = getComponentName(isAsyncWrapper(vnode)</span><span class="s2">\n                </span><span class="s1">? vnode.type.__asyncResolved || {}</span><span class="s2">\n                </span><span class="s1">: comp);</span><span class="s2">\n            </span><span class="s1">const { include, exclude, max } = props;</span><span class="s2">\n            </span><span class="s1">if ((include &amp;&amp; (!name || !matches(include, name))) ||</span><span class="s2">\n                </span><span class="s1">(exclude &amp;&amp; name &amp;&amp; matches(exclude, name))) {</span><span class="s2">\n                </span><span class="s1">current = vnode;</span><span class="s2">\n                </span><span class="s1">return rawVNode;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">const key = vnode.key == null ? comp : vnode.key;</span><span class="s2">\n            </span><span class="s1">const cachedVNode = cache.get(key);</span><span class="s2">\n            </span><span class="s1">// clone vnode if it's reused because we are going to mutate it</span><span class="s2">\n            </span><span class="s1">if (vnode.el) {</span><span class="s2">\n                </span><span class="s1">vnode = cloneVNode(vnode);</span><span class="s2">\n                </span><span class="s1">if (rawVNode.shapeFlag &amp; 128 /* ShapeFlags.SUSPENSE */) {</span><span class="s2">\n                    </span><span class="s1">rawVNode.ssContent = vnode;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">// #1513 it's possible for the returned vnode to be cloned due to attr</span><span class="s2">\n            </span><span class="s1">// fallthrough or scopeId, so the vnode here may not be the final vnode</span><span class="s2">\n            </span><span class="s1">// that is mounted. Instead of caching it directly, we store the pending</span><span class="s2">\n            </span><span class="s1">// key and cache `instance.subTree` (the normalized vnode) in</span><span class="s2">\n            </span><span class="s1">// beforeMount/beforeUpdate hooks.</span><span class="s2">\n            </span><span class="s1">pendingCacheKey = key;</span><span class="s2">\n            </span><span class="s1">if (cachedVNode) {</span><span class="s2">\n                </span><span class="s1">// copy over mounted state</span><span class="s2">\n                </span><span class="s1">vnode.el = cachedVNode.el;</span><span class="s2">\n                </span><span class="s1">vnode.component = cachedVNode.component;</span><span class="s2">\n                </span><span class="s1">if (vnode.transition) {</span><span class="s2">\n                    </span><span class="s1">// recursively update transition hooks on subTree</span><span class="s2">\n                    </span><span class="s1">setTransitionHooks(vnode, vnode.transition);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">// avoid vnode being mounted as fresh</span><span class="s2">\n                </span><span class="s1">vnode.shapeFlag |= 512 /* ShapeFlags.COMPONENT_KEPT_ALIVE */;</span><span class="s2">\n                </span><span class="s1">// make this key the freshest</span><span class="s2">\n                </span><span class="s1">keys.delete(key);</span><span class="s2">\n                </span><span class="s1">keys.add(key);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">keys.add(key);</span><span class="s2">\n                </span><span class="s1">// prune oldest entry</span><span class="s2">\n                </span><span class="s1">if (max &amp;&amp; keys.size &gt; parseInt(max, 10)) {</span><span class="s2">\n                    </span><span class="s1">pruneCacheEntry(keys.values().next().value);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">// avoid vnode being unmounted</span><span class="s2">\n            </span><span class="s1">vnode.shapeFlag |= 256 /* ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE */;</span><span class="s2">\n            </span><span class="s1">current = vnode;</span><span class="s2">\n            </span><span class="s1">return isSuspense(rawVNode.type) ? rawVNode : vnode;</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">// export the public type for h/tsx inference</span><span class="s2">\n</span><span class="s1">// also to avoid inline import() in generated d.ts files</span><span class="s2">\n</span><span class="s1">const KeepAlive = KeepAliveImpl;</span><span class="s2">\n</span><span class="s1">function matches(pattern, name) {</span><span class="s2">\n    </span><span class="s1">if (isArray(pattern)) {</span><span class="s2">\n        </span><span class="s1">return pattern.some((p) =&gt; matches(p, name));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (isString(pattern)) {</span><span class="s2">\n        </span><span class="s1">return pattern.split(',').includes(name);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (isRegExp(pattern)) {</span><span class="s2">\n        </span><span class="s1">return pattern.test(name);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">/* istanbul ignore next */</span><span class="s2">\n    </span><span class="s1">return false;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function onActivated(hook, target) {</span><span class="s2">\n    </span><span class="s1">registerKeepAliveHook(hook, </span><span class="s2">\&quot;</span><span class="s1">a</span><span class="s2">\&quot; </span><span class="s1">/* LifecycleHooks.ACTIVATED */, target);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function onDeactivated(hook, target) {</span><span class="s2">\n    </span><span class="s1">registerKeepAliveHook(hook, </span><span class="s2">\&quot;</span><span class="s1">da</span><span class="s2">\&quot; </span><span class="s1">/* LifecycleHooks.DEACTIVATED */, target);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function registerKeepAliveHook(hook, type, target = currentInstance) {</span><span class="s2">\n    </span><span class="s1">// cache the deactivate branch check wrapper for injected hooks so the same</span><span class="s2">\n    </span><span class="s1">// hook can be properly deduped by the scheduler. </span><span class="s2">\&quot;</span><span class="s1">__wdc</span><span class="s2">\&quot; </span><span class="s1">stands for </span><span class="s2">\&quot;</span><span class="s1">with</span><span class="s2">\n    </span><span class="s1">// deactivation check</span><span class="s2">\&quot;</span><span class="s1">.</span><span class="s2">\n    </span><span class="s1">const wrappedHook = hook.__wdc ||</span><span class="s2">\n        </span><span class="s1">(hook.__wdc = () =&gt; {</span><span class="s2">\n            </span><span class="s1">// only fire the hook if the target instance is NOT in a deactivated branch.</span><span class="s2">\n            </span><span class="s1">let current = target;</span><span class="s2">\n            </span><span class="s1">while (current) {</span><span class="s2">\n                </span><span class="s1">if (current.isDeactivated) {</span><span class="s2">\n                    </span><span class="s1">return;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">current = current.parent;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">return hook();</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">injectHook(type, wrappedHook, target);</span><span class="s2">\n    </span><span class="s1">// In addition to registering it on the target instance, we walk up the parent</span><span class="s2">\n    </span><span class="s1">// chain and register it on all ancestor instances that are keep-alive roots.</span><span class="s2">\n    </span><span class="s1">// This avoids the need to walk the entire component tree when invoking these</span><span class="s2">\n    </span><span class="s1">// hooks, and more importantly, avoids the need to track child components in</span><span class="s2">\n    </span><span class="s1">// arrays.</span><span class="s2">\n    </span><span class="s1">if (target) {</span><span class="s2">\n        </span><span class="s1">let current = target.parent;</span><span class="s2">\n        </span><span class="s1">while (current &amp;&amp; current.parent) {</span><span class="s2">\n            </span><span class="s1">if (isKeepAlive(current.parent.vnode)) {</span><span class="s2">\n                </span><span class="s1">injectToKeepAliveRoot(wrappedHook, type, target, current);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">current = current.parent;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {</span><span class="s2">\n    </span><span class="s1">// injectHook wraps the original for error handling, so make sure to remove</span><span class="s2">\n    </span><span class="s1">// the wrapped version.</span><span class="s2">\n    </span><span class="s1">const injected = injectHook(type, hook, keepAliveRoot, true /* prepend */);</span><span class="s2">\n    </span><span class="s1">onUnmounted(() =&gt; {</span><span class="s2">\n        </span><span class="s1">remove(keepAliveRoot[type], injected);</span><span class="s2">\n    </span><span class="s1">}, target);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function resetShapeFlag(vnode) {</span><span class="s2">\n    </span><span class="s1">// bitwise operations to remove keep alive flags</span><span class="s2">\n    </span><span class="s1">vnode.shapeFlag &amp;= ~256 /* ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE */;</span><span class="s2">\n    </span><span class="s1">vnode.shapeFlag &amp;= ~512 /* ShapeFlags.COMPONENT_KEPT_ALIVE */;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getInnerChild(vnode) {</span><span class="s2">\n    </span><span class="s1">return vnode.shapeFlag &amp; 128 /* ShapeFlags.SUSPENSE */ ? vnode.ssContent : vnode;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function injectHook(type, hook, target = currentInstance, prepend = false) {</span><span class="s2">\n    </span><span class="s1">if (target) {</span><span class="s2">\n        </span><span class="s1">const hooks = target[type] || (target[type] = []);</span><span class="s2">\n        </span><span class="s1">// cache the error handling wrapper for injected hooks so the same hook</span><span class="s2">\n        </span><span class="s1">// can be properly deduped by the scheduler. </span><span class="s2">\&quot;</span><span class="s1">__weh</span><span class="s2">\&quot; </span><span class="s1">stands for </span><span class="s2">\&quot;</span><span class="s1">with error</span><span class="s2">\n        </span><span class="s1">// handling</span><span class="s2">\&quot;</span><span class="s1">.</span><span class="s2">\n        </span><span class="s1">const wrappedHook = hook.__weh ||</span><span class="s2">\n            </span><span class="s1">(hook.__weh = (...args) =&gt; {</span><span class="s2">\n                </span><span class="s1">if (target.isUnmounted) {</span><span class="s2">\n                    </span><span class="s1">return;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">// disable tracking inside all lifecycle hooks</span><span class="s2">\n                </span><span class="s1">// since they can potentially be called inside effects.</span><span class="s2">\n                </span><span class="s1">pauseTracking();</span><span class="s2">\n                </span><span class="s1">// Set currentInstance during hook invocation.</span><span class="s2">\n                </span><span class="s1">// This assumes the hook does not synchronously trigger other hooks, which</span><span class="s2">\n                </span><span class="s1">// can only be false when the user does something really funky.</span><span class="s2">\n                </span><span class="s1">setCurrentInstance(target);</span><span class="s2">\n                </span><span class="s1">const res = callWithAsyncErrorHandling(hook, target, type, args);</span><span class="s2">\n                </span><span class="s1">unsetCurrentInstance();</span><span class="s2">\n                </span><span class="s1">resetTracking();</span><span class="s2">\n                </span><span class="s1">return res;</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">if (prepend) {</span><span class="s2">\n            </span><span class="s1">hooks.unshift(wrappedHook);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">hooks.push(wrappedHook);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return wrappedHook;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n        </span><span class="s1">const apiName = toHandlerKey(ErrorTypeStrings[type].replace(/ hook$/, ''));</span><span class="s2">\n        </span><span class="s1">warn(`${apiName} is called when there is no active component instance to be ` +</span><span class="s2">\n            </span><span class="s1">`associated with. ` +</span><span class="s2">\n            </span><span class="s1">`Lifecycle injection APIs can only be used during execution of setup().` +</span><span class="s2">\n            </span><span class="s1">(` If you are using async setup(), make sure to register lifecycle ` +</span><span class="s2">\n                    </span><span class="s1">`hooks before the first await statement.`</span><span class="s2">\n                </span><span class="s1">));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">const createHook = (lifecycle) =&gt; (hook, target = currentInstance) =&gt; </span><span class="s2">\n</span><span class="s1">// post-create lifecycle registrations are noops during SSR (except for serverPrefetch)</span><span class="s2">\n</span><span class="s1">(!isInSSRComponentSetup || lifecycle === </span><span class="s2">\&quot;</span><span class="s1">sp</span><span class="s2">\&quot; </span><span class="s1">/* LifecycleHooks.SERVER_PREFETCH */) &amp;&amp;</span><span class="s2">\n    </span><span class="s1">injectHook(lifecycle, (...args) =&gt; hook(...args), target);</span><span class="s2">\n</span><span class="s1">const onBeforeMount = createHook(</span><span class="s2">\&quot;</span><span class="s1">bm</span><span class="s2">\&quot; </span><span class="s1">/* LifecycleHooks.BEFORE_MOUNT */);</span><span class="s2">\n</span><span class="s1">const onMounted = createHook(</span><span class="s2">\&quot;</span><span class="s1">m</span><span class="s2">\&quot; </span><span class="s1">/* LifecycleHooks.MOUNTED */);</span><span class="s2">\n</span><span class="s1">const onBeforeUpdate = createHook(</span><span class="s2">\&quot;</span><span class="s1">bu</span><span class="s2">\&quot; </span><span class="s1">/* LifecycleHooks.BEFORE_UPDATE */);</span><span class="s2">\n</span><span class="s1">const onUpdated = createHook(</span><span class="s2">\&quot;</span><span class="s1">u</span><span class="s2">\&quot; </span><span class="s1">/* LifecycleHooks.UPDATED */);</span><span class="s2">\n</span><span class="s1">const onBeforeUnmount = createHook(</span><span class="s2">\&quot;</span><span class="s1">bum</span><span class="s2">\&quot; </span><span class="s1">/* LifecycleHooks.BEFORE_UNMOUNT */);</span><span class="s2">\n</span><span class="s1">const onUnmounted = createHook(</span><span class="s2">\&quot;</span><span class="s1">um</span><span class="s2">\&quot; </span><span class="s1">/* LifecycleHooks.UNMOUNTED */);</span><span class="s2">\n</span><span class="s1">const onServerPrefetch = createHook(</span><span class="s2">\&quot;</span><span class="s1">sp</span><span class="s2">\&quot; </span><span class="s1">/* LifecycleHooks.SERVER_PREFETCH */);</span><span class="s2">\n</span><span class="s1">const onRenderTriggered = createHook(</span><span class="s2">\&quot;</span><span class="s1">rtg</span><span class="s2">\&quot; </span><span class="s1">/* LifecycleHooks.RENDER_TRIGGERED */);</span><span class="s2">\n</span><span class="s1">const onRenderTracked = createHook(</span><span class="s2">\&quot;</span><span class="s1">rtc</span><span class="s2">\&quot; </span><span class="s1">/* LifecycleHooks.RENDER_TRACKED */);</span><span class="s2">\n</span><span class="s1">function onErrorCaptured(hook, target = currentInstance) {</span><span class="s2">\n    </span><span class="s1">injectHook(</span><span class="s2">\&quot;</span><span class="s1">ec</span><span class="s2">\&quot; </span><span class="s1">/* LifecycleHooks.ERROR_CAPTURED */, hook, target);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n</span><span class="s1">Runtime helper for applying directives to a vnode. Example usage:</span><span class="s2">\n\n</span><span class="s1">const comp = resolveComponent('comp')</span><span class="s2">\n</span><span class="s1">const foo = resolveDirective('foo')</span><span class="s2">\n</span><span class="s1">const bar = resolveDirective('bar')</span><span class="s2">\n\n</span><span class="s1">return withDirectives(h(comp), [</span><span class="s2">\n  </span><span class="s1">[foo, this.x],</span><span class="s2">\n  </span><span class="s1">[bar, this.y]</span><span class="s2">\n</span><span class="s1">])</span><span class="s2">\n</span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function validateDirectiveName(name) {</span><span class="s2">\n    </span><span class="s1">if (isBuiltInDirective(name)) {</span><span class="s2">\n        </span><span class="s1">warn('Do not use built-in directive ids as custom directive id: ' + name);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Adds directives to a VNode.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function withDirectives(vnode, directives) {</span><span class="s2">\n    </span><span class="s1">const internalInstance = currentRenderingInstance;</span><span class="s2">\n    </span><span class="s1">if (internalInstance === null) {</span><span class="s2">\n        </span><span class="s1">(process.env.NODE_ENV !== 'production') &amp;&amp; warn(`withDirectives can only be used inside render functions.`);</span><span class="s2">\n        </span><span class="s1">return vnode;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">const instance = getExposeProxy(internalInstance) ||</span><span class="s2">\n        </span><span class="s1">internalInstance.proxy;</span><span class="s2">\n    </span><span class="s1">const bindings = vnode.dirs || (vnode.dirs = []);</span><span class="s2">\n    </span><span class="s1">for (let i = 0; i &lt; directives.length; i++) {</span><span class="s2">\n        </span><span class="s1">let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];</span><span class="s2">\n        </span><span class="s1">if (dir) {</span><span class="s2">\n            </span><span class="s1">if (isFunction(dir)) {</span><span class="s2">\n                </span><span class="s1">dir = {</span><span class="s2">\n                    </span><span class="s1">mounted: dir,</span><span class="s2">\n                    </span><span class="s1">updated: dir</span><span class="s2">\n                </span><span class="s1">};</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">if (dir.deep) {</span><span class="s2">\n                </span><span class="s1">traverse(value);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">bindings.push({</span><span class="s2">\n                </span><span class="s1">dir,</span><span class="s2">\n                </span><span class="s1">instance,</span><span class="s2">\n                </span><span class="s1">value,</span><span class="s2">\n                </span><span class="s1">oldValue: void 0,</span><span class="s2">\n                </span><span class="s1">arg,</span><span class="s2">\n                </span><span class="s1">modifiers</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return vnode;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function invokeDirectiveHook(vnode, prevVNode, instance, name) {</span><span class="s2">\n    </span><span class="s1">const bindings = vnode.dirs;</span><span class="s2">\n    </span><span class="s1">const oldBindings = prevVNode &amp;&amp; prevVNode.dirs;</span><span class="s2">\n    </span><span class="s1">for (let i = 0; i &lt; bindings.length; i++) {</span><span class="s2">\n        </span><span class="s1">const binding = bindings[i];</span><span class="s2">\n        </span><span class="s1">if (oldBindings) {</span><span class="s2">\n            </span><span class="s1">binding.oldValue = oldBindings[i].value;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">let hook = binding.dir[name];</span><span class="s2">\n        </span><span class="s1">if (hook) {</span><span class="s2">\n            </span><span class="s1">// disable tracking inside all lifecycle hooks</span><span class="s2">\n            </span><span class="s1">// since they can potentially be called inside effects.</span><span class="s2">\n            </span><span class="s1">pauseTracking();</span><span class="s2">\n            </span><span class="s1">callWithAsyncErrorHandling(hook, instance, 8 /* ErrorCodes.DIRECTIVE_HOOK */, [</span><span class="s2">\n                </span><span class="s1">vnode.el,</span><span class="s2">\n                </span><span class="s1">binding,</span><span class="s2">\n                </span><span class="s1">vnode,</span><span class="s2">\n                </span><span class="s1">prevVNode</span><span class="s2">\n            </span><span class="s1">]);</span><span class="s2">\n            </span><span class="s1">resetTracking();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">const COMPONENTS = 'components';</span><span class="s2">\n</span><span class="s1">const DIRECTIVES = 'directives';</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* @private</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function resolveComponent(name, maybeSelfReference) {</span><span class="s2">\n    </span><span class="s1">return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">const NULL_DYNAMIC_COMPONENT = Symbol();</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* @private</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function resolveDynamicComponent(component) {</span><span class="s2">\n    </span><span class="s1">if (isString(component)) {</span><span class="s2">\n        </span><span class="s1">return resolveAsset(COMPONENTS, component, false) || component;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">// invalid types will fallthrough to createVNode and raise warning</span><span class="s2">\n        </span><span class="s1">return (component || NULL_DYNAMIC_COMPONENT);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* @private</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function resolveDirective(name) {</span><span class="s2">\n    </span><span class="s1">return resolveAsset(DIRECTIVES, name);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// implementation</span><span class="s2">\n</span><span class="s1">function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {</span><span class="s2">\n    </span><span class="s1">const instance = currentRenderingInstance || currentInstance;</span><span class="s2">\n    </span><span class="s1">if (instance) {</span><span class="s2">\n        </span><span class="s1">const Component = instance.type;</span><span class="s2">\n        </span><span class="s1">// explicit self name has highest priority</span><span class="s2">\n        </span><span class="s1">if (type === COMPONENTS) {</span><span class="s2">\n            </span><span class="s1">const selfName = getComponentName(Component, false /* do not include inferred name to avoid breaking existing code */);</span><span class="s2">\n            </span><span class="s1">if (selfName &amp;&amp;</span><span class="s2">\n                </span><span class="s1">(selfName === name ||</span><span class="s2">\n                    </span><span class="s1">selfName === camelize(name) ||</span><span class="s2">\n                    </span><span class="s1">selfName === capitalize(camelize(name)))) {</span><span class="s2">\n                </span><span class="s1">return Component;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">const res = </span><span class="s2">\n        </span><span class="s1">// local registration</span><span class="s2">\n        </span><span class="s1">// check instance[type] first which is resolved for options API</span><span class="s2">\n        </span><span class="s1">resolve(instance[type] || Component[type], name) ||</span><span class="s2">\n            </span><span class="s1">// global registration</span><span class="s2">\n            </span><span class="s1">resolve(instance.appContext[type], name);</span><span class="s2">\n        </span><span class="s1">if (!res &amp;&amp; maybeSelfReference) {</span><span class="s2">\n            </span><span class="s1">// fallback to implicit self-reference</span><span class="s2">\n            </span><span class="s1">return Component;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp; warnMissing &amp;&amp; !res) {</span><span class="s2">\n            </span><span class="s1">const extra = type === COMPONENTS</span><span class="s2">\n                </span><span class="s1">? `</span><span class="s2">\\</span><span class="s1">nIf this is a native custom element, make sure to exclude it from ` +</span><span class="s2">\n                    </span><span class="s1">`component resolution via compilerOptions.isCustomElement.`</span><span class="s2">\n                </span><span class="s1">: ``;</span><span class="s2">\n            </span><span class="s1">warn(`Failed to resolve ${type.slice(0, -1)}: ${name}${extra}`);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return res;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n        </span><span class="s1">warn(`resolve${capitalize(type.slice(0, -1))} ` +</span><span class="s2">\n            </span><span class="s1">`can only be used in render() or setup().`);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function resolve(registry, name) {</span><span class="s2">\n    </span><span class="s1">return (registry &amp;&amp;</span><span class="s2">\n        </span><span class="s1">(registry[name] ||</span><span class="s2">\n            </span><span class="s1">registry[camelize(name)] ||</span><span class="s2">\n            </span><span class="s1">registry[capitalize(camelize(name))]));</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Actual implementation</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function renderList(source, renderItem, cache, index) {</span><span class="s2">\n    </span><span class="s1">let ret;</span><span class="s2">\n    </span><span class="s1">const cached = (cache &amp;&amp; cache[index]);</span><span class="s2">\n    </span><span class="s1">if (isArray(source) || isString(source)) {</span><span class="s2">\n        </span><span class="s1">ret = new Array(source.length);</span><span class="s2">\n        </span><span class="s1">for (let i = 0, l = source.length; i &lt; l; i++) {</span><span class="s2">\n            </span><span class="s1">ret[i] = renderItem(source[i], i, undefined, cached &amp;&amp; cached[i]);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (typeof source === 'number') {</span><span class="s2">\n        </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp; !Number.isInteger(source)) {</span><span class="s2">\n            </span><span class="s1">warn(`The v-for range expect an integer value but got ${source}.`);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">ret = new Array(source);</span><span class="s2">\n        </span><span class="s1">for (let i = 0; i &lt; source; i++) {</span><span class="s2">\n            </span><span class="s1">ret[i] = renderItem(i + 1, i, undefined, cached &amp;&amp; cached[i]);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (isObject(source)) {</span><span class="s2">\n        </span><span class="s1">if (source[Symbol.iterator]) {</span><span class="s2">\n            </span><span class="s1">ret = Array.from(source, (item, i) =&gt; renderItem(item, i, undefined, cached &amp;&amp; cached[i]));</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">const keys = Object.keys(source);</span><span class="s2">\n            </span><span class="s1">ret = new Array(keys.length);</span><span class="s2">\n            </span><span class="s1">for (let i = 0, l = keys.length; i &lt; l; i++) {</span><span class="s2">\n                </span><span class="s1">const key = keys[i];</span><span class="s2">\n                </span><span class="s1">ret[i] = renderItem(source[key], key, i, cached &amp;&amp; cached[i]);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">ret = [];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (cache) {</span><span class="s2">\n        </span><span class="s1">cache[index] = ret;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return ret;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Compiler runtime helper for creating dynamic slots object</span><span class="s2">\n </span><span class="s1">* @private</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function createSlots(slots, dynamicSlots) {</span><span class="s2">\n    </span><span class="s1">for (let i = 0; i &lt; dynamicSlots.length; i++) {</span><span class="s2">\n        </span><span class="s1">const slot = dynamicSlots[i];</span><span class="s2">\n        </span><span class="s1">// array of dynamic slot generated by &lt;template v-for=</span><span class="s2">\&quot;</span><span class="s1">...</span><span class="s2">\&quot; </span><span class="s1">#[...]&gt;</span><span class="s2">\n        </span><span class="s1">if (isArray(slot)) {</span><span class="s2">\n            </span><span class="s1">for (let j = 0; j &lt; slot.length; j++) {</span><span class="s2">\n                </span><span class="s1">slots[slot[j].name] = slot[j].fn;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (slot) {</span><span class="s2">\n            </span><span class="s1">// conditional single slot generated by &lt;template v-if=</span><span class="s2">\&quot;</span><span class="s1">...</span><span class="s2">\&quot; </span><span class="s1">#foo&gt;</span><span class="s2">\n            </span><span class="s1">slots[slot.name] = slot.key</span><span class="s2">\n                </span><span class="s1">? (...args) =&gt; {</span><span class="s2">\n                    </span><span class="s1">const res = slot.fn(...args);</span><span class="s2">\n                    </span><span class="s1">// attach branch key so each conditional branch is considered a</span><span class="s2">\n                    </span><span class="s1">// different fragment</span><span class="s2">\n                    </span><span class="s1">if (res)</span><span class="s2">\n                        </span><span class="s1">res.key = slot.key;</span><span class="s2">\n                    </span><span class="s1">return res;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">: slot.fn;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return slots;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Compiler runtime helper for rendering `&lt;slot/&gt;`</span><span class="s2">\n </span><span class="s1">* @private</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function renderSlot(slots, name, props = {}, </span><span class="s2">\n</span><span class="s1">// this is not a user-facing function, so the fallback is always generated by</span><span class="s2">\n</span><span class="s1">// the compiler and guaranteed to be a function returning an array</span><span class="s2">\n</span><span class="s1">fallback, noSlotted) {</span><span class="s2">\n    </span><span class="s1">if (currentRenderingInstance.isCE ||</span><span class="s2">\n        </span><span class="s1">(currentRenderingInstance.parent &amp;&amp;</span><span class="s2">\n            </span><span class="s1">isAsyncWrapper(currentRenderingInstance.parent) &amp;&amp;</span><span class="s2">\n            </span><span class="s1">currentRenderingInstance.parent.isCE)) {</span><span class="s2">\n        </span><span class="s1">if (name !== 'default')</span><span class="s2">\n            </span><span class="s1">props.name = name;</span><span class="s2">\n        </span><span class="s1">return createVNode('slot', props, fallback &amp;&amp; fallback());</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let slot = slots[name];</span><span class="s2">\n    </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp; slot &amp;&amp; slot.length &gt; 1) {</span><span class="s2">\n        </span><span class="s1">warn(`SSR-optimized slot function detected in a non-SSR-optimized render ` +</span><span class="s2">\n            </span><span class="s1">`function. You need to mark this component with $dynamic-slots in the ` +</span><span class="s2">\n            </span><span class="s1">`parent template.`);</span><span class="s2">\n        </span><span class="s1">slot = () =&gt; [];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// a compiled slot disables block tracking by default to avoid manual</span><span class="s2">\n    </span><span class="s1">// invocation interfering with template-based block tracking, but in</span><span class="s2">\n    </span><span class="s1">// `renderSlot` we can be sure that it's template-based so we can force</span><span class="s2">\n    </span><span class="s1">// enable it.</span><span class="s2">\n    </span><span class="s1">if (slot &amp;&amp; slot._c) {</span><span class="s2">\n        </span><span class="s1">slot._d = false;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">openBlock();</span><span class="s2">\n    </span><span class="s1">const validSlotContent = slot &amp;&amp; ensureValidVNode(slot(props));</span><span class="s2">\n    </span><span class="s1">const rendered = createBlock(Fragment, {</span><span class="s2">\n        </span><span class="s1">key: props.key ||</span><span class="s2">\n            </span><span class="s1">// slot content array of a dynamic conditional slot may have a branch</span><span class="s2">\n            </span><span class="s1">// key attached in the `createSlots` helper, respect that</span><span class="s2">\n            </span><span class="s1">(validSlotContent &amp;&amp; validSlotContent.key) ||</span><span class="s2">\n            </span><span class="s1">`_${name}`</span><span class="s2">\n    </span><span class="s1">}, validSlotContent || (fallback ? fallback() : []), validSlotContent &amp;&amp; slots._ === 1 /* SlotFlags.STABLE */</span><span class="s2">\n        </span><span class="s1">? 64 /* PatchFlags.STABLE_FRAGMENT */</span><span class="s2">\n        </span><span class="s1">: -2 /* PatchFlags.BAIL */);</span><span class="s2">\n    </span><span class="s1">if (!noSlotted &amp;&amp; rendered.scopeId) {</span><span class="s2">\n        </span><span class="s1">rendered.slotScopeIds = [rendered.scopeId + '-s'];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (slot &amp;&amp; slot._c) {</span><span class="s2">\n        </span><span class="s1">slot._d = true;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return rendered;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function ensureValidVNode(vnodes) {</span><span class="s2">\n    </span><span class="s1">return vnodes.some(child =&gt; {</span><span class="s2">\n        </span><span class="s1">if (!isVNode(child))</span><span class="s2">\n            </span><span class="s1">return true;</span><span class="s2">\n        </span><span class="s1">if (child.type === Comment)</span><span class="s2">\n            </span><span class="s1">return false;</span><span class="s2">\n        </span><span class="s1">if (child.type === Fragment &amp;&amp;</span><span class="s2">\n            </span><span class="s1">!ensureValidVNode(child.children))</span><span class="s2">\n            </span><span class="s1">return false;</span><span class="s2">\n        </span><span class="s1">return true;</span><span class="s2">\n    </span><span class="s1">})</span><span class="s2">\n        </span><span class="s1">? vnodes</span><span class="s2">\n        </span><span class="s1">: null;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* For prefixing keys in v-on=</span><span class="s2">\&quot;</span><span class="s1">obj</span><span class="s2">\&quot; </span><span class="s1">with </span><span class="s2">\&quot;</span><span class="s1">on</span><span class="s2">\&quot;\n </span><span class="s1">* @private</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function toHandlers(obj, preserveCaseIfNecessary) {</span><span class="s2">\n    </span><span class="s1">const ret = {};</span><span class="s2">\n    </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp; !isObject(obj)) {</span><span class="s2">\n        </span><span class="s1">warn(`v-on with no argument expects an object value.`);</span><span class="s2">\n        </span><span class="s1">return ret;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">for (const key in obj) {</span><span class="s2">\n        </span><span class="s1">ret[preserveCaseIfNecessary &amp;&amp; /[A-Z]/.test(key)</span><span class="s2">\n            </span><span class="s1">? `on:${key}`</span><span class="s2">\n            </span><span class="s1">: toHandlerKey(key)] = obj[key];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return ret;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* #2437 In Vue 3, functional components do not have a public instance proxy but</span><span class="s2">\n </span><span class="s1">* they exist in the internal parent chain. For code that relies on traversing</span><span class="s2">\n </span><span class="s1">* public $parent chains, skip functional ones and go to the parent instead.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const getPublicInstance = (i) =&gt; {</span><span class="s2">\n    </span><span class="s1">if (!i)</span><span class="s2">\n        </span><span class="s1">return null;</span><span class="s2">\n    </span><span class="s1">if (isStatefulComponent(i))</span><span class="s2">\n        </span><span class="s1">return getExposeProxy(i) || i.proxy;</span><span class="s2">\n    </span><span class="s1">return getPublicInstance(i.parent);</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">const publicPropertiesMap = </span><span class="s2">\n</span><span class="s1">// Move PURE marker to new line to workaround compiler discarding it</span><span class="s2">\n</span><span class="s1">// due to type annotation</span><span class="s2">\n</span><span class="s1">/*#__PURE__*/ extend(Object.create(null), {</span><span class="s2">\n    </span><span class="s1">$: i =&gt; i,</span><span class="s2">\n    </span><span class="s1">$el: i =&gt; i.vnode.el,</span><span class="s2">\n    </span><span class="s1">$data: i =&gt; i.data,</span><span class="s2">\n    </span><span class="s1">$props: i =&gt; ((process.env.NODE_ENV !== 'production') ? shallowReadonly(i.props) : i.props),</span><span class="s2">\n    </span><span class="s1">$attrs: i =&gt; ((process.env.NODE_ENV !== 'production') ? shallowReadonly(i.attrs) : i.attrs),</span><span class="s2">\n    </span><span class="s1">$slots: i =&gt; ((process.env.NODE_ENV !== 'production') ? shallowReadonly(i.slots) : i.slots),</span><span class="s2">\n    </span><span class="s1">$refs: i =&gt; ((process.env.NODE_ENV !== 'production') ? shallowReadonly(i.refs) : i.refs),</span><span class="s2">\n    </span><span class="s1">$parent: i =&gt; getPublicInstance(i.parent),</span><span class="s2">\n    </span><span class="s1">$root: i =&gt; getPublicInstance(i.root),</span><span class="s2">\n    </span><span class="s1">$emit: i =&gt; i.emit,</span><span class="s2">\n    </span><span class="s1">$options: i =&gt; (__VUE_OPTIONS_API__ ? resolveMergedOptions(i) : i.type),</span><span class="s2">\n    </span><span class="s1">$forceUpdate: i =&gt; i.f || (i.f = () =&gt; queueJob(i.update)),</span><span class="s2">\n    </span><span class="s1">$nextTick: i =&gt; i.n || (i.n = nextTick.bind(i.proxy)),</span><span class="s2">\n    </span><span class="s1">$watch: i =&gt; (__VUE_OPTIONS_API__ ? instanceWatch.bind(i) : NOOP)</span><span class="s2">\n</span><span class="s1">});</span><span class="s2">\n</span><span class="s1">const isReservedPrefix = (key) =&gt; key === '_' || key === '$';</span><span class="s2">\n</span><span class="s1">const hasSetupBinding = (state, key) =&gt; state !== EMPTY_OBJ &amp;&amp; !state.__isScriptSetup &amp;&amp; hasOwn(state, key);</span><span class="s2">\n</span><span class="s1">const PublicInstanceProxyHandlers = {</span><span class="s2">\n    </span><span class="s1">get({ _: instance }, key) {</span><span class="s2">\n        </span><span class="s1">const { ctx, setupState, data, props, accessCache, type, appContext } = instance;</span><span class="s2">\n        </span><span class="s1">// for internal formatters to know that this is a Vue instance</span><span class="s2">\n        </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp; key === '__isVue') {</span><span class="s2">\n            </span><span class="s1">return true;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// data / props / ctx</span><span class="s2">\n        </span><span class="s1">// This getter gets called for every property access on the render context</span><span class="s2">\n        </span><span class="s1">// during render and is a major hotspot. The most expensive part of this</span><span class="s2">\n        </span><span class="s1">// is the multiple hasOwn() calls. It's much faster to do a simple property</span><span class="s2">\n        </span><span class="s1">// access on a plain object, so we use an accessCache object (with null</span><span class="s2">\n        </span><span class="s1">// prototype) to memoize what access type a key corresponds to.</span><span class="s2">\n        </span><span class="s1">let normalizedProps;</span><span class="s2">\n        </span><span class="s1">if (key[0] !== '$') {</span><span class="s2">\n            </span><span class="s1">const n = accessCache[key];</span><span class="s2">\n            </span><span class="s1">if (n !== undefined) {</span><span class="s2">\n                </span><span class="s1">switch (n) {</span><span class="s2">\n                    </span><span class="s1">case 1 /* AccessTypes.SETUP */:</span><span class="s2">\n                        </span><span class="s1">return setupState[key];</span><span class="s2">\n                    </span><span class="s1">case 2 /* AccessTypes.DATA */:</span><span class="s2">\n                        </span><span class="s1">return data[key];</span><span class="s2">\n                    </span><span class="s1">case 4 /* AccessTypes.CONTEXT */:</span><span class="s2">\n                        </span><span class="s1">return ctx[key];</span><span class="s2">\n                    </span><span class="s1">case 3 /* AccessTypes.PROPS */:</span><span class="s2">\n                        </span><span class="s1">return props[key];</span><span class="s2">\n                    </span><span class="s1">// default: just fallthrough</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else if (hasSetupBinding(setupState, key)) {</span><span class="s2">\n                </span><span class="s1">accessCache[key] = 1 /* AccessTypes.SETUP */;</span><span class="s2">\n                </span><span class="s1">return setupState[key];</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else if (data !== EMPTY_OBJ &amp;&amp; hasOwn(data, key)) {</span><span class="s2">\n                </span><span class="s1">accessCache[key] = 2 /* AccessTypes.DATA */;</span><span class="s2">\n                </span><span class="s1">return data[key];</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else if (</span><span class="s2">\n            </span><span class="s1">// only cache other properties when instance has declared (thus stable)</span><span class="s2">\n            </span><span class="s1">// props</span><span class="s2">\n            </span><span class="s1">(normalizedProps = instance.propsOptions[0]) &amp;&amp;</span><span class="s2">\n                </span><span class="s1">hasOwn(normalizedProps, key)) {</span><span class="s2">\n                </span><span class="s1">accessCache[key] = 3 /* AccessTypes.PROPS */;</span><span class="s2">\n                </span><span class="s1">return props[key];</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else if (ctx !== EMPTY_OBJ &amp;&amp; hasOwn(ctx, key)) {</span><span class="s2">\n                </span><span class="s1">accessCache[key] = 4 /* AccessTypes.CONTEXT */;</span><span class="s2">\n                </span><span class="s1">return ctx[key];</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else if (!__VUE_OPTIONS_API__ || shouldCacheAccess) {</span><span class="s2">\n                </span><span class="s1">accessCache[key] = 0 /* AccessTypes.OTHER */;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">const publicGetter = publicPropertiesMap[key];</span><span class="s2">\n        </span><span class="s1">let cssModule, globalProperties;</span><span class="s2">\n        </span><span class="s1">// public $xxx properties</span><span class="s2">\n        </span><span class="s1">if (publicGetter) {</span><span class="s2">\n            </span><span class="s1">if (key === '$attrs') {</span><span class="s2">\n                </span><span class="s1">track(instance, </span><span class="s2">\&quot;</span><span class="s1">get</span><span class="s2">\&quot; </span><span class="s1">/* TrackOpTypes.GET */, key);</span><span class="s2">\n                </span><span class="s1">(process.env.NODE_ENV !== 'production') &amp;&amp; markAttrsAccessed();</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">return publicGetter(instance);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (</span><span class="s2">\n        </span><span class="s1">// css module (injected by vue-loader)</span><span class="s2">\n        </span><span class="s1">(cssModule = type.__cssModules) &amp;&amp;</span><span class="s2">\n            </span><span class="s1">(cssModule = cssModule[key])) {</span><span class="s2">\n            </span><span class="s1">return cssModule;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (ctx !== EMPTY_OBJ &amp;&amp; hasOwn(ctx, key)) {</span><span class="s2">\n            </span><span class="s1">// user may set custom properties to `this` that start with `$`</span><span class="s2">\n            </span><span class="s1">accessCache[key] = 4 /* AccessTypes.CONTEXT */;</span><span class="s2">\n            </span><span class="s1">return ctx[key];</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (</span><span class="s2">\n        </span><span class="s1">// global properties</span><span class="s2">\n        </span><span class="s1">((globalProperties = appContext.config.globalProperties),</span><span class="s2">\n            </span><span class="s1">hasOwn(globalProperties, key))) {</span><span class="s2">\n            </span><span class="s1">{</span><span class="s2">\n                </span><span class="s1">return globalProperties[key];</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if ((process.env.NODE_ENV !== 'production') &amp;&amp;</span><span class="s2">\n            </span><span class="s1">currentRenderingInstance &amp;&amp;</span><span class="s2">\n            </span><span class="s1">(!isString(key) ||</span><span class="s2">\n                </span><span class="s1">// #1091 avoid internal isRef/isVNode checks on component instance leading</span><span class="s2">\n                </span><span class="s1">// to infinite warning loop</span><span class="s2">\n                </span><span class="s1">key.indexOf('__v') !== 0)) {</span><span class="s2">\n            </span><span class="s1">if (data !== EMPTY_OBJ &amp;&amp; isReservedPrefix(key[0]) &amp;&amp; hasOwn(data, key)) {</span><span class="s2">\n                </span><span class="s1">warn(`Property ${JSON.stringify(key)} must be accessed via $data because it starts with a reserved ` +</span><span class="s2">\n                    </span><span class="s1">`character (</span><span class="s2">\&quot;</span><span class="s1">$</span><span class="s2">\&quot; </span><span class="s1">or </span><span class="s2">\&quot;</span><span class="s1">_</span><span class="s2">\&quot;</span><span class="s1">) and is not proxied on the render context.`);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else if (instance === currentRenderingInstance) {</span><span class="s2">\n                </span><span class="s1">warn(`Property ${JSON.stringify(key)} was accessed during render ` +</span><span class="s2">\n                    </span><span class="s1">`but is not defined on instance.`);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">set({ _: instance }, key, value) {</span><span class="s2">\n        </span><span class="s1">const { data, setupState, ctx } = instance;</span><span class="s2">\n        </span><span class="s1">if (hasSetupBinding(setupState, key)) {</span><span class="s2">\n            </span><span class="s1">setupState[key] = value;</span><span class="s2">\n            </span><span class="s1">return true;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if ((process.env.NODE_ENV !== 'production') &amp;&amp;</span><span class="s2">\n            </span><span class="s1">setupState.__isScriptSetup &amp;&amp;</span><span class="s2">\n            </span><span class="s1">hasOwn(setupState, key)) {</span><span class="s2">\n            </span><span class="s1">warn(`Cannot mutate &lt;script setup&gt; binding </span><span class="s2">\&quot;</span><span class="s1">${key}</span><span class="s2">\&quot; </span><span class="s1">from Options API.`);</span><span class="s2">\n            </span><span class="s1">return false;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (data !== EMPTY_OBJ &amp;&amp; hasOwn(data, key)) {</span><span class="s2">\n            </span><span class="s1">data[key] = value;</span><span class="s2">\n            </span><span class="s1">return true;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (hasOwn(instance.props, key)) {</span><span class="s2">\n            </span><span class="s1">(process.env.NODE_ENV !== 'production') &amp;&amp; warn(`Attempting to mutate prop </span><span class="s2">\&quot;</span><span class="s1">${key}</span><span class="s2">\&quot;</span><span class="s1">. Props are readonly.`);</span><span class="s2">\n            </span><span class="s1">return false;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (key[0] === '$' &amp;&amp; key.slice(1) in instance) {</span><span class="s2">\n            </span><span class="s1">(process.env.NODE_ENV !== 'production') &amp;&amp;</span><span class="s2">\n                </span><span class="s1">warn(`Attempting to mutate public property </span><span class="s2">\&quot;</span><span class="s1">${key}</span><span class="s2">\&quot;</span><span class="s1">. ` +</span><span class="s2">\n                    </span><span class="s1">`Properties starting with $ are reserved and readonly.`);</span><span class="s2">\n            </span><span class="s1">return false;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp; key in instance.appContext.config.globalProperties) {</span><span class="s2">\n                </span><span class="s1">Object.defineProperty(ctx, key, {</span><span class="s2">\n                    </span><span class="s1">enumerable: true,</span><span class="s2">\n                    </span><span class="s1">configurable: true,</span><span class="s2">\n                    </span><span class="s1">value</span><span class="s2">\n                </span><span class="s1">});</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">ctx[key] = value;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return true;</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">has({ _: { data, setupState, accessCache, ctx, appContext, propsOptions } }, key) {</span><span class="s2">\n        </span><span class="s1">let normalizedProps;</span><span class="s2">\n        </span><span class="s1">return (!!accessCache[key] ||</span><span class="s2">\n            </span><span class="s1">(data !== EMPTY_OBJ &amp;&amp; hasOwn(data, key)) ||</span><span class="s2">\n            </span><span class="s1">hasSetupBinding(setupState, key) ||</span><span class="s2">\n            </span><span class="s1">((normalizedProps = propsOptions[0]) &amp;&amp; hasOwn(normalizedProps, key)) ||</span><span class="s2">\n            </span><span class="s1">hasOwn(ctx, key) ||</span><span class="s2">\n            </span><span class="s1">hasOwn(publicPropertiesMap, key) ||</span><span class="s2">\n            </span><span class="s1">hasOwn(appContext.config.globalProperties, key));</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">defineProperty(target, key, descriptor) {</span><span class="s2">\n        </span><span class="s1">if (descriptor.get != null) {</span><span class="s2">\n            </span><span class="s1">// invalidate key cache of a getter based property #5417</span><span class="s2">\n            </span><span class="s1">target._.accessCache[key] = 0;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (hasOwn(descriptor, 'value')) {</span><span class="s2">\n            </span><span class="s1">this.set(target, key, descriptor.value, null);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return Reflect.defineProperty(target, key, descriptor);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp; !false) {</span><span class="s2">\n    </span><span class="s1">PublicInstanceProxyHandlers.ownKeys = (target) =&gt; {</span><span class="s2">\n        </span><span class="s1">warn(`Avoid app logic that relies on enumerating keys on a component instance. ` +</span><span class="s2">\n            </span><span class="s1">`The keys will be empty in production mode to avoid performance overhead.`);</span><span class="s2">\n        </span><span class="s1">return Reflect.ownKeys(target);</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">const RuntimeCompiledPublicInstanceProxyHandlers = /*#__PURE__*/ extend({}, PublicInstanceProxyHandlers, {</span><span class="s2">\n    </span><span class="s1">get(target, key) {</span><span class="s2">\n        </span><span class="s1">// fast path for unscopables when using `with` block</span><span class="s2">\n        </span><span class="s1">if (key === Symbol.unscopables) {</span><span class="s2">\n            </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return PublicInstanceProxyHandlers.get(target, key, target);</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">has(_, key) {</span><span class="s2">\n        </span><span class="s1">const has = key[0] !== '_' &amp;&amp; !isGloballyWhitelisted(key);</span><span class="s2">\n        </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp; !has &amp;&amp; PublicInstanceProxyHandlers.has(_, key)) {</span><span class="s2">\n            </span><span class="s1">warn(`Property ${JSON.stringify(key)} should not start with _ which is a reserved prefix for Vue internals.`);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return has;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">});</span><span class="s2">\n</span><span class="s1">// dev only</span><span class="s2">\n</span><span class="s1">// In dev mode, the proxy target exposes the same properties as seen on `this`</span><span class="s2">\n</span><span class="s1">// for easier console inspection. In prod mode it will be an empty object so</span><span class="s2">\n</span><span class="s1">// these properties definitions can be skipped.</span><span class="s2">\n</span><span class="s1">function createDevRenderContext(instance) {</span><span class="s2">\n    </span><span class="s1">const target = {};</span><span class="s2">\n    </span><span class="s1">// expose internal instance for proxy handlers</span><span class="s2">\n    </span><span class="s1">Object.defineProperty(target, `_`, {</span><span class="s2">\n        </span><span class="s1">configurable: true,</span><span class="s2">\n        </span><span class="s1">enumerable: false,</span><span class="s2">\n        </span><span class="s1">get: () =&gt; instance</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">// expose public properties</span><span class="s2">\n    </span><span class="s1">Object.keys(publicPropertiesMap).forEach(key =&gt; {</span><span class="s2">\n        </span><span class="s1">Object.defineProperty(target, key, {</span><span class="s2">\n            </span><span class="s1">configurable: true,</span><span class="s2">\n            </span><span class="s1">enumerable: false,</span><span class="s2">\n            </span><span class="s1">get: () =&gt; publicPropertiesMap[key](instance),</span><span class="s2">\n            </span><span class="s1">// intercepted by the proxy so no need for implementation,</span><span class="s2">\n            </span><span class="s1">// but needed to prevent set errors</span><span class="s2">\n            </span><span class="s1">set: NOOP</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">return target;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// dev only</span><span class="s2">\n</span><span class="s1">function exposePropsOnRenderContext(instance) {</span><span class="s2">\n    </span><span class="s1">const { ctx, propsOptions: [propsOptions] } = instance;</span><span class="s2">\n    </span><span class="s1">if (propsOptions) {</span><span class="s2">\n        </span><span class="s1">Object.keys(propsOptions).forEach(key =&gt; {</span><span class="s2">\n            </span><span class="s1">Object.defineProperty(ctx, key, {</span><span class="s2">\n                </span><span class="s1">enumerable: true,</span><span class="s2">\n                </span><span class="s1">configurable: true,</span><span class="s2">\n                </span><span class="s1">get: () =&gt; instance.props[key],</span><span class="s2">\n                </span><span class="s1">set: NOOP</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// dev only</span><span class="s2">\n</span><span class="s1">function exposeSetupStateOnRenderContext(instance) {</span><span class="s2">\n    </span><span class="s1">const { ctx, setupState } = instance;</span><span class="s2">\n    </span><span class="s1">Object.keys(toRaw(setupState)).forEach(key =&gt; {</span><span class="s2">\n        </span><span class="s1">if (!setupState.__isScriptSetup) {</span><span class="s2">\n            </span><span class="s1">if (isReservedPrefix(key[0])) {</span><span class="s2">\n                </span><span class="s1">warn(`setup() return property ${JSON.stringify(key)} should not start with </span><span class="s2">\&quot;</span><span class="s1">$</span><span class="s2">\&quot; </span><span class="s1">or </span><span class="s2">\&quot;</span><span class="s1">_</span><span class="s2">\&quot; </span><span class="s1">` +</span><span class="s2">\n                    </span><span class="s1">`which are reserved prefixes for Vue internals.`);</span><span class="s2">\n                </span><span class="s1">return;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">Object.defineProperty(ctx, key, {</span><span class="s2">\n                </span><span class="s1">enumerable: true,</span><span class="s2">\n                </span><span class="s1">configurable: true,</span><span class="s2">\n                </span><span class="s1">get: () =&gt; setupState[key],</span><span class="s2">\n                </span><span class="s1">set: NOOP</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function createDuplicateChecker() {</span><span class="s2">\n    </span><span class="s1">const cache = Object.create(null);</span><span class="s2">\n    </span><span class="s1">return (type, key) =&gt; {</span><span class="s2">\n        </span><span class="s1">if (cache[key]) {</span><span class="s2">\n            </span><span class="s1">warn(`${type} property </span><span class="s2">\&quot;</span><span class="s1">${key}</span><span class="s2">\&quot; </span><span class="s1">is already defined in ${cache[key]}.`);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">cache[key] = type;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">let shouldCacheAccess = true;</span><span class="s2">\n</span><span class="s1">function applyOptions(instance) {</span><span class="s2">\n    </span><span class="s1">const options = resolveMergedOptions(instance);</span><span class="s2">\n    </span><span class="s1">const publicThis = instance.proxy;</span><span class="s2">\n    </span><span class="s1">const ctx = instance.ctx;</span><span class="s2">\n    </span><span class="s1">// do not cache property access on public proxy during state initialization</span><span class="s2">\n    </span><span class="s1">shouldCacheAccess = false;</span><span class="s2">\n    </span><span class="s1">// call beforeCreate first before accessing other options since</span><span class="s2">\n    </span><span class="s1">// the hook may mutate resolved options (#2791)</span><span class="s2">\n    </span><span class="s1">if (options.beforeCreate) {</span><span class="s2">\n        </span><span class="s1">callHook(options.beforeCreate, instance, </span><span class="s2">\&quot;</span><span class="s1">bc</span><span class="s2">\&quot; </span><span class="s1">/* LifecycleHooks.BEFORE_CREATE */);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">const { </span><span class="s2">\n    </span><span class="s1">// state</span><span class="s2">\n    </span><span class="s1">data: dataOptions, computed: computedOptions, methods, watch: watchOptions, provide: provideOptions, inject: injectOptions, </span><span class="s2">\n    </span><span class="s1">// lifecycle</span><span class="s2">\n    </span><span class="s1">created, beforeMount, mounted, beforeUpdate, updated, activated, deactivated, beforeDestroy, beforeUnmount, destroyed, unmounted, render, renderTracked, renderTriggered, errorCaptured, serverPrefetch, </span><span class="s2">\n    </span><span class="s1">// public API</span><span class="s2">\n    </span><span class="s1">expose, inheritAttrs, </span><span class="s2">\n    </span><span class="s1">// assets</span><span class="s2">\n    </span><span class="s1">components, directives, filters } = options;</span><span class="s2">\n    </span><span class="s1">const checkDuplicateProperties = (process.env.NODE_ENV !== 'production') ? createDuplicateChecker() : null;</span><span class="s2">\n    </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n        </span><span class="s1">const [propsOptions] = instance.propsOptions;</span><span class="s2">\n        </span><span class="s1">if (propsOptions) {</span><span class="s2">\n            </span><span class="s1">for (const key in propsOptions) {</span><span class="s2">\n                </span><span class="s1">checkDuplicateProperties(</span><span class="s2">\&quot;</span><span class="s1">Props</span><span class="s2">\&quot; </span><span class="s1">/* OptionTypes.PROPS */, key);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// options initialization order (to be consistent with Vue 2):</span><span class="s2">\n    </span><span class="s1">// - props (already done outside of this function)</span><span class="s2">\n    </span><span class="s1">// - inject</span><span class="s2">\n    </span><span class="s1">// - methods</span><span class="s2">\n    </span><span class="s1">// - data (deferred since it relies on `this` access)</span><span class="s2">\n    </span><span class="s1">// - computed</span><span class="s2">\n    </span><span class="s1">// - watch (deferred since it relies on `this` access)</span><span class="s2">\n    </span><span class="s1">if (injectOptions) {</span><span class="s2">\n        </span><span class="s1">resolveInjections(injectOptions, ctx, checkDuplicateProperties, instance.appContext.config.unwrapInjectedRef);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (methods) {</span><span class="s2">\n        </span><span class="s1">for (const key in methods) {</span><span class="s2">\n            </span><span class="s1">const methodHandler = methods[key];</span><span class="s2">\n            </span><span class="s1">if (isFunction(methodHandler)) {</span><span class="s2">\n                </span><span class="s1">// In dev mode, we use the `createRenderContext` function to define</span><span class="s2">\n                </span><span class="s1">// methods to the proxy target, and those are read-only but</span><span class="s2">\n                </span><span class="s1">// reconfigurable, so it needs to be redefined here</span><span class="s2">\n                </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n                    </span><span class="s1">Object.defineProperty(ctx, key, {</span><span class="s2">\n                        </span><span class="s1">value: methodHandler.bind(publicThis),</span><span class="s2">\n                        </span><span class="s1">configurable: true,</span><span class="s2">\n                        </span><span class="s1">enumerable: true,</span><span class="s2">\n                        </span><span class="s1">writable: true</span><span class="s2">\n                    </span><span class="s1">});</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else {</span><span class="s2">\n                    </span><span class="s1">ctx[key] = methodHandler.bind(publicThis);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n                    </span><span class="s1">checkDuplicateProperties(</span><span class="s2">\&quot;</span><span class="s1">Methods</span><span class="s2">\&quot; </span><span class="s1">/* OptionTypes.METHODS */, key);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n                </span><span class="s1">warn(`Method </span><span class="s2">\&quot;</span><span class="s1">${key}</span><span class="s2">\&quot; </span><span class="s1">has type </span><span class="s2">\&quot;</span><span class="s1">${typeof methodHandler}</span><span class="s2">\&quot; </span><span class="s1">in the component definition. ` +</span><span class="s2">\n                    </span><span class="s1">`Did you reference the function correctly?`);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (dataOptions) {</span><span class="s2">\n        </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp; !isFunction(dataOptions)) {</span><span class="s2">\n            </span><span class="s1">warn(`The data option must be a function. ` +</span><span class="s2">\n                </span><span class="s1">`Plain object usage is no longer supported.`);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">const data = dataOptions.call(publicThis, publicThis);</span><span class="s2">\n        </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp; isPromise(data)) {</span><span class="s2">\n            </span><span class="s1">warn(`data() returned a Promise - note data() cannot be async; If you ` +</span><span class="s2">\n                </span><span class="s1">`intend to perform data fetching before component renders, use ` +</span><span class="s2">\n                </span><span class="s1">`async setup() + &lt;Suspense&gt;.`);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (!isObject(data)) {</span><span class="s2">\n            </span><span class="s1">(process.env.NODE_ENV !== 'production') &amp;&amp; warn(`data() should return an object.`);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">instance.data = reactive(data);</span><span class="s2">\n            </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n                </span><span class="s1">for (const key in data) {</span><span class="s2">\n                    </span><span class="s1">checkDuplicateProperties(</span><span class="s2">\&quot;</span><span class="s1">Data</span><span class="s2">\&quot; </span><span class="s1">/* OptionTypes.DATA */, key);</span><span class="s2">\n                    </span><span class="s1">// expose data on ctx during dev</span><span class="s2">\n                    </span><span class="s1">if (!isReservedPrefix(key[0])) {</span><span class="s2">\n                        </span><span class="s1">Object.defineProperty(ctx, key, {</span><span class="s2">\n                            </span><span class="s1">configurable: true,</span><span class="s2">\n                            </span><span class="s1">enumerable: true,</span><span class="s2">\n                            </span><span class="s1">get: () =&gt; data[key],</span><span class="s2">\n                            </span><span class="s1">set: NOOP</span><span class="s2">\n                        </span><span class="s1">});</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// state initialization complete at this point - start caching access</span><span class="s2">\n    </span><span class="s1">shouldCacheAccess = true;</span><span class="s2">\n    </span><span class="s1">if (computedOptions) {</span><span class="s2">\n        </span><span class="s1">for (const key in computedOptions) {</span><span class="s2">\n            </span><span class="s1">const opt = computedOptions[key];</span><span class="s2">\n            </span><span class="s1">const get = isFunction(opt)</span><span class="s2">\n                </span><span class="s1">? opt.bind(publicThis, publicThis)</span><span class="s2">\n                </span><span class="s1">: isFunction(opt.get)</span><span class="s2">\n                    </span><span class="s1">? opt.get.bind(publicThis, publicThis)</span><span class="s2">\n                    </span><span class="s1">: NOOP;</span><span class="s2">\n            </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp; get === NOOP) {</span><span class="s2">\n                </span><span class="s1">warn(`Computed property </span><span class="s2">\&quot;</span><span class="s1">${key}</span><span class="s2">\&quot; </span><span class="s1">has no getter.`);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">const set = !isFunction(opt) &amp;&amp; isFunction(opt.set)</span><span class="s2">\n                </span><span class="s1">? opt.set.bind(publicThis)</span><span class="s2">\n                </span><span class="s1">: (process.env.NODE_ENV !== 'production')</span><span class="s2">\n                    </span><span class="s1">? () =&gt; {</span><span class="s2">\n                        </span><span class="s1">warn(`Write operation failed: computed property </span><span class="s2">\&quot;</span><span class="s1">${key}</span><span class="s2">\&quot; </span><span class="s1">is readonly.`);</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">: NOOP;</span><span class="s2">\n            </span><span class="s1">const c = computed({</span><span class="s2">\n                </span><span class="s1">get,</span><span class="s2">\n                </span><span class="s1">set</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n            </span><span class="s1">Object.defineProperty(ctx, key, {</span><span class="s2">\n                </span><span class="s1">enumerable: true,</span><span class="s2">\n                </span><span class="s1">configurable: true,</span><span class="s2">\n                </span><span class="s1">get: () =&gt; c.value,</span><span class="s2">\n                </span><span class="s1">set: v =&gt; (c.value = v)</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n            </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n                </span><span class="s1">checkDuplicateProperties(</span><span class="s2">\&quot;</span><span class="s1">Computed</span><span class="s2">\&quot; </span><span class="s1">/* OptionTypes.COMPUTED */, key);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (watchOptions) {</span><span class="s2">\n        </span><span class="s1">for (const key in watchOptions) {</span><span class="s2">\n            </span><span class="s1">createWatcher(watchOptions[key], ctx, publicThis, key);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (provideOptions) {</span><span class="s2">\n        </span><span class="s1">const provides = isFunction(provideOptions)</span><span class="s2">\n            </span><span class="s1">? provideOptions.call(publicThis)</span><span class="s2">\n            </span><span class="s1">: provideOptions;</span><span class="s2">\n        </span><span class="s1">Reflect.ownKeys(provides).forEach(key =&gt; {</span><span class="s2">\n            </span><span class="s1">provide(key, provides[key]);</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (created) {</span><span class="s2">\n        </span><span class="s1">callHook(created, instance, </span><span class="s2">\&quot;</span><span class="s1">c</span><span class="s2">\&quot; </span><span class="s1">/* LifecycleHooks.CREATED */);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">function registerLifecycleHook(register, hook) {</span><span class="s2">\n        </span><span class="s1">if (isArray(hook)) {</span><span class="s2">\n            </span><span class="s1">hook.forEach(_hook =&gt; register(_hook.bind(publicThis)));</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (hook) {</span><span class="s2">\n            </span><span class="s1">register(hook.bind(publicThis));</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">registerLifecycleHook(onBeforeMount, beforeMount);</span><span class="s2">\n    </span><span class="s1">registerLifecycleHook(onMounted, mounted);</span><span class="s2">\n    </span><span class="s1">registerLifecycleHook(onBeforeUpdate, beforeUpdate);</span><span class="s2">\n    </span><span class="s1">registerLifecycleHook(onUpdated, updated);</span><span class="s2">\n    </span><span class="s1">registerLifecycleHook(onActivated, activated);</span><span class="s2">\n    </span><span class="s1">registerLifecycleHook(onDeactivated, deactivated);</span><span class="s2">\n    </span><span class="s1">registerLifecycleHook(onErrorCaptured, errorCaptured);</span><span class="s2">\n    </span><span class="s1">registerLifecycleHook(onRenderTracked, renderTracked);</span><span class="s2">\n    </span><span class="s1">registerLifecycleHook(onRenderTriggered, renderTriggered);</span><span class="s2">\n    </span><span class="s1">registerLifecycleHook(onBeforeUnmount, beforeUnmount);</span><span class="s2">\n    </span><span class="s1">registerLifecycleHook(onUnmounted, unmounted);</span><span class="s2">\n    </span><span class="s1">registerLifecycleHook(onServerPrefetch, serverPrefetch);</span><span class="s2">\n    </span><span class="s1">if (isArray(expose)) {</span><span class="s2">\n        </span><span class="s1">if (expose.length) {</span><span class="s2">\n            </span><span class="s1">const exposed = instance.exposed || (instance.exposed = {});</span><span class="s2">\n            </span><span class="s1">expose.forEach(key =&gt; {</span><span class="s2">\n                </span><span class="s1">Object.defineProperty(exposed, key, {</span><span class="s2">\n                    </span><span class="s1">get: () =&gt; publicThis[key],</span><span class="s2">\n                    </span><span class="s1">set: val =&gt; (publicThis[key] = val)</span><span class="s2">\n                </span><span class="s1">});</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (!instance.exposed) {</span><span class="s2">\n            </span><span class="s1">instance.exposed = {};</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// options that are handled when creating the instance but also need to be</span><span class="s2">\n    </span><span class="s1">// applied from mixins</span><span class="s2">\n    </span><span class="s1">if (render &amp;&amp; instance.render === NOOP) {</span><span class="s2">\n        </span><span class="s1">instance.render = render;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (inheritAttrs != null) {</span><span class="s2">\n        </span><span class="s1">instance.inheritAttrs = inheritAttrs;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// asset options.</span><span class="s2">\n    </span><span class="s1">if (components)</span><span class="s2">\n        </span><span class="s1">instance.components = components;</span><span class="s2">\n    </span><span class="s1">if (directives)</span><span class="s2">\n        </span><span class="s1">instance.directives = directives;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP, unwrapRef = false) {</span><span class="s2">\n    </span><span class="s1">if (isArray(injectOptions)) {</span><span class="s2">\n        </span><span class="s1">injectOptions = normalizeInject(injectOptions);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">for (const key in injectOptions) {</span><span class="s2">\n        </span><span class="s1">const opt = injectOptions[key];</span><span class="s2">\n        </span><span class="s1">let injected;</span><span class="s2">\n        </span><span class="s1">if (isObject(opt)) {</span><span class="s2">\n            </span><span class="s1">if ('default' in opt) {</span><span class="s2">\n                </span><span class="s1">injected = inject(opt.from || key, opt.default, true /* treat default function as factory */);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">injected = inject(opt.from || key);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">injected = inject(opt);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (isRef(injected)) {</span><span class="s2">\n            </span><span class="s1">// TODO remove the check in 3.3</span><span class="s2">\n            </span><span class="s1">if (unwrapRef) {</span><span class="s2">\n                </span><span class="s1">Object.defineProperty(ctx, key, {</span><span class="s2">\n                    </span><span class="s1">enumerable: true,</span><span class="s2">\n                    </span><span class="s1">configurable: true,</span><span class="s2">\n                    </span><span class="s1">get: () =&gt; injected.value,</span><span class="s2">\n                    </span><span class="s1">set: v =&gt; (injected.value = v)</span><span class="s2">\n                </span><span class="s1">});</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n                    </span><span class="s1">warn(`injected property </span><span class="s2">\&quot;</span><span class="s1">${key}</span><span class="s2">\&quot; </span><span class="s1">is a ref and will be auto-unwrapped ` +</span><span class="s2">\n                        </span><span class="s1">`and no longer needs </span><span class="s2">\\</span><span class="s1">`.value</span><span class="s2">\\</span><span class="s1">` in the next minor release. ` +</span><span class="s2">\n                        </span><span class="s1">`To opt-in to the new behavior now, ` +</span><span class="s2">\n                        </span><span class="s1">`set </span><span class="s2">\\</span><span class="s1">`app.config.unwrapInjectedRef = true</span><span class="s2">\\</span><span class="s1">` (this config is ` +</span><span class="s2">\n                        </span><span class="s1">`temporary and will not be needed in the future.)`);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">ctx[key] = injected;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">ctx[key] = injected;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n            </span><span class="s1">checkDuplicateProperties(</span><span class="s2">\&quot;</span><span class="s1">Inject</span><span class="s2">\&quot; </span><span class="s1">/* OptionTypes.INJECT */, key);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function callHook(hook, instance, type) {</span><span class="s2">\n    </span><span class="s1">callWithAsyncErrorHandling(isArray(hook)</span><span class="s2">\n        </span><span class="s1">? hook.map(h =&gt; h.bind(instance.proxy))</span><span class="s2">\n        </span><span class="s1">: hook.bind(instance.proxy), instance, type);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createWatcher(raw, ctx, publicThis, key) {</span><span class="s2">\n    </span><span class="s1">const getter = key.includes('.')</span><span class="s2">\n        </span><span class="s1">? createPathGetter(publicThis, key)</span><span class="s2">\n        </span><span class="s1">: () =&gt; publicThis[key];</span><span class="s2">\n    </span><span class="s1">if (isString(raw)) {</span><span class="s2">\n        </span><span class="s1">const handler = ctx[raw];</span><span class="s2">\n        </span><span class="s1">if (isFunction(handler)) {</span><span class="s2">\n            </span><span class="s1">watch(getter, handler);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n            </span><span class="s1">warn(`Invalid watch handler specified by key </span><span class="s2">\&quot;</span><span class="s1">${raw}</span><span class="s2">\&quot;</span><span class="s1">`, handler);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (isFunction(raw)) {</span><span class="s2">\n        </span><span class="s1">watch(getter, raw.bind(publicThis));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (isObject(raw)) {</span><span class="s2">\n        </span><span class="s1">if (isArray(raw)) {</span><span class="s2">\n            </span><span class="s1">raw.forEach(r =&gt; createWatcher(r, ctx, publicThis, key));</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">const handler = isFunction(raw.handler)</span><span class="s2">\n                </span><span class="s1">? raw.handler.bind(publicThis)</span><span class="s2">\n                </span><span class="s1">: ctx[raw.handler];</span><span class="s2">\n            </span><span class="s1">if (isFunction(handler)) {</span><span class="s2">\n                </span><span class="s1">watch(getter, handler, raw);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n                </span><span class="s1">warn(`Invalid watch handler specified by key </span><span class="s2">\&quot;</span><span class="s1">${raw.handler}</span><span class="s2">\&quot;</span><span class="s1">`, handler);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n        </span><span class="s1">warn(`Invalid watch option: </span><span class="s2">\&quot;</span><span class="s1">${key}</span><span class="s2">\&quot;</span><span class="s1">`, raw);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Resolve merged options and cache it on the component.</span><span class="s2">\n </span><span class="s1">* This is done only once per-component since the merging does not involve</span><span class="s2">\n </span><span class="s1">* instances.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function resolveMergedOptions(instance) {</span><span class="s2">\n    </span><span class="s1">const base = instance.type;</span><span class="s2">\n    </span><span class="s1">const { mixins, extends: extendsOptions } = base;</span><span class="s2">\n    </span><span class="s1">const { mixins: globalMixins, optionsCache: cache, config: { optionMergeStrategies } } = instance.appContext;</span><span class="s2">\n    </span><span class="s1">const cached = cache.get(base);</span><span class="s2">\n    </span><span class="s1">let resolved;</span><span class="s2">\n    </span><span class="s1">if (cached) {</span><span class="s2">\n        </span><span class="s1">resolved = cached;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (!globalMixins.length &amp;&amp; !mixins &amp;&amp; !extendsOptions) {</span><span class="s2">\n        </span><span class="s1">{</span><span class="s2">\n            </span><span class="s1">resolved = base;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">resolved = {};</span><span class="s2">\n        </span><span class="s1">if (globalMixins.length) {</span><span class="s2">\n            </span><span class="s1">globalMixins.forEach(m =&gt; mergeOptions(resolved, m, optionMergeStrategies, true));</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">mergeOptions(resolved, base, optionMergeStrategies);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (isObject(base)) {</span><span class="s2">\n        </span><span class="s1">cache.set(base, resolved);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return resolved;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function mergeOptions(to, from, strats, asMixin = false) {</span><span class="s2">\n    </span><span class="s1">const { mixins, extends: extendsOptions } = from;</span><span class="s2">\n    </span><span class="s1">if (extendsOptions) {</span><span class="s2">\n        </span><span class="s1">mergeOptions(to, extendsOptions, strats, true);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (mixins) {</span><span class="s2">\n        </span><span class="s1">mixins.forEach((m) =&gt; mergeOptions(to, m, strats, true));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">for (const key in from) {</span><span class="s2">\n        </span><span class="s1">if (asMixin &amp;&amp; key === 'expose') {</span><span class="s2">\n            </span><span class="s1">(process.env.NODE_ENV !== 'production') &amp;&amp;</span><span class="s2">\n                </span><span class="s1">warn(`</span><span class="s2">\&quot;</span><span class="s1">expose</span><span class="s2">\&quot; </span><span class="s1">option is ignored when declared in mixins or extends. ` +</span><span class="s2">\n                    </span><span class="s1">`It should only be declared in the base component itself.`);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">const strat = internalOptionMergeStrats[key] || (strats &amp;&amp; strats[key]);</span><span class="s2">\n            </span><span class="s1">to[key] = strat ? strat(to[key], from[key]) : from[key];</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return to;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">const internalOptionMergeStrats = {</span><span class="s2">\n    </span><span class="s1">data: mergeDataFn,</span><span class="s2">\n    </span><span class="s1">props: mergeObjectOptions,</span><span class="s2">\n    </span><span class="s1">emits: mergeObjectOptions,</span><span class="s2">\n    </span><span class="s1">// objects</span><span class="s2">\n    </span><span class="s1">methods: mergeObjectOptions,</span><span class="s2">\n    </span><span class="s1">computed: mergeObjectOptions,</span><span class="s2">\n    </span><span class="s1">// lifecycle</span><span class="s2">\n    </span><span class="s1">beforeCreate: mergeAsArray,</span><span class="s2">\n    </span><span class="s1">created: mergeAsArray,</span><span class="s2">\n    </span><span class="s1">beforeMount: mergeAsArray,</span><span class="s2">\n    </span><span class="s1">mounted: mergeAsArray,</span><span class="s2">\n    </span><span class="s1">beforeUpdate: mergeAsArray,</span><span class="s2">\n    </span><span class="s1">updated: mergeAsArray,</span><span class="s2">\n    </span><span class="s1">beforeDestroy: mergeAsArray,</span><span class="s2">\n    </span><span class="s1">beforeUnmount: mergeAsArray,</span><span class="s2">\n    </span><span class="s1">destroyed: mergeAsArray,</span><span class="s2">\n    </span><span class="s1">unmounted: mergeAsArray,</span><span class="s2">\n    </span><span class="s1">activated: mergeAsArray,</span><span class="s2">\n    </span><span class="s1">deactivated: mergeAsArray,</span><span class="s2">\n    </span><span class="s1">errorCaptured: mergeAsArray,</span><span class="s2">\n    </span><span class="s1">serverPrefetch: mergeAsArray,</span><span class="s2">\n    </span><span class="s1">// assets</span><span class="s2">\n    </span><span class="s1">components: mergeObjectOptions,</span><span class="s2">\n    </span><span class="s1">directives: mergeObjectOptions,</span><span class="s2">\n    </span><span class="s1">// watch</span><span class="s2">\n    </span><span class="s1">watch: mergeWatchOptions,</span><span class="s2">\n    </span><span class="s1">// provide / inject</span><span class="s2">\n    </span><span class="s1">provide: mergeDataFn,</span><span class="s2">\n    </span><span class="s1">inject: mergeInject</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">function mergeDataFn(to, from) {</span><span class="s2">\n    </span><span class="s1">if (!from) {</span><span class="s2">\n        </span><span class="s1">return to;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (!to) {</span><span class="s2">\n        </span><span class="s1">return from;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return function mergedDataFn() {</span><span class="s2">\n        </span><span class="s1">return (extend)(isFunction(to) ? to.call(this, this) : to, isFunction(from) ? from.call(this, this) : from);</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function mergeInject(to, from) {</span><span class="s2">\n    </span><span class="s1">return mergeObjectOptions(normalizeInject(to), normalizeInject(from));</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function normalizeInject(raw) {</span><span class="s2">\n    </span><span class="s1">if (isArray(raw)) {</span><span class="s2">\n        </span><span class="s1">const res = {};</span><span class="s2">\n        </span><span class="s1">for (let i = 0; i &lt; raw.length; i++) {</span><span class="s2">\n            </span><span class="s1">res[raw[i]] = raw[i];</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return res;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return raw;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function mergeAsArray(to, from) {</span><span class="s2">\n    </span><span class="s1">return to ? [...new Set([].concat(to, from))] : from;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function mergeObjectOptions(to, from) {</span><span class="s2">\n    </span><span class="s1">return to ? extend(extend(Object.create(null), to), from) : from;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function mergeWatchOptions(to, from) {</span><span class="s2">\n    </span><span class="s1">if (!to)</span><span class="s2">\n        </span><span class="s1">return from;</span><span class="s2">\n    </span><span class="s1">if (!from)</span><span class="s2">\n        </span><span class="s1">return to;</span><span class="s2">\n    </span><span class="s1">const merged = extend(Object.create(null), to);</span><span class="s2">\n    </span><span class="s1">for (const key in from) {</span><span class="s2">\n        </span><span class="s1">merged[key] = mergeAsArray(to[key], from[key]);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return merged;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function initProps(instance, rawProps, isStateful, // result of bitwise flag comparison</span><span class="s2">\n</span><span class="s1">isSSR = false) {</span><span class="s2">\n    </span><span class="s1">const props = {};</span><span class="s2">\n    </span><span class="s1">const attrs = {};</span><span class="s2">\n    </span><span class="s1">def(attrs, InternalObjectKey, 1);</span><span class="s2">\n    </span><span class="s1">instance.propsDefaults = Object.create(null);</span><span class="s2">\n    </span><span class="s1">setFullProps(instance, rawProps, props, attrs);</span><span class="s2">\n    </span><span class="s1">// ensure all declared prop keys are present</span><span class="s2">\n    </span><span class="s1">for (const key in instance.propsOptions[0]) {</span><span class="s2">\n        </span><span class="s1">if (!(key in props)) {</span><span class="s2">\n            </span><span class="s1">props[key] = undefined;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// validation</span><span class="s2">\n    </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n        </span><span class="s1">validateProps(rawProps || {}, props, instance);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (isStateful) {</span><span class="s2">\n        </span><span class="s1">// stateful</span><span class="s2">\n        </span><span class="s1">instance.props = isSSR ? props : shallowReactive(props);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">if (!instance.type.props) {</span><span class="s2">\n            </span><span class="s1">// functional w/ optional props, props === attrs</span><span class="s2">\n            </span><span class="s1">instance.props = attrs;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">// functional w/ declared props</span><span class="s2">\n            </span><span class="s1">instance.props = props;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">instance.attrs = attrs;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isInHmrContext(instance) {</span><span class="s2">\n    </span><span class="s1">while (instance) {</span><span class="s2">\n        </span><span class="s1">if (instance.type.__hmrId)</span><span class="s2">\n            </span><span class="s1">return true;</span><span class="s2">\n        </span><span class="s1">instance = instance.parent;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function updateProps(instance, rawProps, rawPrevProps, optimized) {</span><span class="s2">\n    </span><span class="s1">const { props, attrs, vnode: { patchFlag } } = instance;</span><span class="s2">\n    </span><span class="s1">const rawCurrentProps = toRaw(props);</span><span class="s2">\n    </span><span class="s1">const [options] = instance.propsOptions;</span><span class="s2">\n    </span><span class="s1">let hasAttrsChanged = false;</span><span class="s2">\n    </span><span class="s1">if (</span><span class="s2">\n    </span><span class="s1">// always force full diff in dev</span><span class="s2">\n    </span><span class="s1">// - #1942 if hmr is enabled with sfc component</span><span class="s2">\n    </span><span class="s1">// - vite#872 non-sfc component used by sfc component</span><span class="s2">\n    </span><span class="s1">!((process.env.NODE_ENV !== 'production') &amp;&amp; isInHmrContext(instance)) &amp;&amp;</span><span class="s2">\n        </span><span class="s1">(optimized || patchFlag &gt; 0) &amp;&amp;</span><span class="s2">\n        </span><span class="s1">!(patchFlag &amp; 16 /* PatchFlags.FULL_PROPS */)) {</span><span class="s2">\n        </span><span class="s1">if (patchFlag &amp; 8 /* PatchFlags.PROPS */) {</span><span class="s2">\n            </span><span class="s1">// Compiler-generated props &amp; no keys change, just set the updated</span><span class="s2">\n            </span><span class="s1">// the props.</span><span class="s2">\n            </span><span class="s1">const propsToUpdate = instance.vnode.dynamicProps;</span><span class="s2">\n            </span><span class="s1">for (let i = 0; i &lt; propsToUpdate.length; i++) {</span><span class="s2">\n                </span><span class="s1">let key = propsToUpdate[i];</span><span class="s2">\n                </span><span class="s1">// skip if the prop key is a declared emit event listener</span><span class="s2">\n                </span><span class="s1">if (isEmitListener(instance.emitsOptions, key)) {</span><span class="s2">\n                    </span><span class="s1">continue;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">// PROPS flag guarantees rawProps to be non-null</span><span class="s2">\n                </span><span class="s1">const value = rawProps[key];</span><span class="s2">\n                </span><span class="s1">if (options) {</span><span class="s2">\n                    </span><span class="s1">// attr / props separation was done on init and will be consistent</span><span class="s2">\n                    </span><span class="s1">// in this code path, so just check if attrs have it.</span><span class="s2">\n                    </span><span class="s1">if (hasOwn(attrs, key)) {</span><span class="s2">\n                        </span><span class="s1">if (value !== attrs[key]) {</span><span class="s2">\n                            </span><span class="s1">attrs[key] = value;</span><span class="s2">\n                            </span><span class="s1">hasAttrsChanged = true;</span><span class="s2">\n                        </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">else {</span><span class="s2">\n                        </span><span class="s1">const camelizedKey = camelize(key);</span><span class="s2">\n                        </span><span class="s1">props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value, instance, false /* isAbsent */);</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else {</span><span class="s2">\n                    </span><span class="s1">if (value !== attrs[key]) {</span><span class="s2">\n                        </span><span class="s1">attrs[key] = value;</span><span class="s2">\n                        </span><span class="s1">hasAttrsChanged = true;</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">// full props update.</span><span class="s2">\n        </span><span class="s1">if (setFullProps(instance, rawProps, props, attrs)) {</span><span class="s2">\n            </span><span class="s1">hasAttrsChanged = true;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// in case of dynamic props, check if we need to delete keys from</span><span class="s2">\n        </span><span class="s1">// the props object</span><span class="s2">\n        </span><span class="s1">let kebabKey;</span><span class="s2">\n        </span><span class="s1">for (const key in rawCurrentProps) {</span><span class="s2">\n            </span><span class="s1">if (!rawProps ||</span><span class="s2">\n                </span><span class="s1">// for camelCase</span><span class="s2">\n                </span><span class="s1">(!hasOwn(rawProps, key) &amp;&amp;</span><span class="s2">\n                    </span><span class="s1">// it's possible the original props was passed in as kebab-case</span><span class="s2">\n                    </span><span class="s1">// and converted to camelCase (#955)</span><span class="s2">\n                    </span><span class="s1">((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey)))) {</span><span class="s2">\n                </span><span class="s1">if (options) {</span><span class="s2">\n                    </span><span class="s1">if (rawPrevProps &amp;&amp;</span><span class="s2">\n                        </span><span class="s1">// for camelCase</span><span class="s2">\n                        </span><span class="s1">(rawPrevProps[key] !== undefined ||</span><span class="s2">\n                            </span><span class="s1">// for kebab-case</span><span class="s2">\n                            </span><span class="s1">rawPrevProps[kebabKey] !== undefined)) {</span><span class="s2">\n                        </span><span class="s1">props[key] = resolvePropValue(options, rawCurrentProps, key, undefined, instance, true /* isAbsent */);</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else {</span><span class="s2">\n                    </span><span class="s1">delete props[key];</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// in the case of functional component w/o props declaration, props and</span><span class="s2">\n        </span><span class="s1">// attrs point to the same object so it should already have been updated.</span><span class="s2">\n        </span><span class="s1">if (attrs !== rawCurrentProps) {</span><span class="s2">\n            </span><span class="s1">for (const key in attrs) {</span><span class="s2">\n                </span><span class="s1">if (!rawProps ||</span><span class="s2">\n                    </span><span class="s1">(!hasOwn(rawProps, key) &amp;&amp;</span><span class="s2">\n                        </span><span class="s1">(!false ))) {</span><span class="s2">\n                    </span><span class="s1">delete attrs[key];</span><span class="s2">\n                    </span><span class="s1">hasAttrsChanged = true;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// trigger updates for $attrs in case it's used in component slots</span><span class="s2">\n    </span><span class="s1">if (hasAttrsChanged) {</span><span class="s2">\n        </span><span class="s1">trigger(instance, </span><span class="s2">\&quot;</span><span class="s1">set</span><span class="s2">\&quot; </span><span class="s1">/* TriggerOpTypes.SET */, '$attrs');</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n        </span><span class="s1">validateProps(rawProps || {}, props, instance);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function setFullProps(instance, rawProps, props, attrs) {</span><span class="s2">\n    </span><span class="s1">const [options, needCastKeys] = instance.propsOptions;</span><span class="s2">\n    </span><span class="s1">let hasAttrsChanged = false;</span><span class="s2">\n    </span><span class="s1">let rawCastValues;</span><span class="s2">\n    </span><span class="s1">if (rawProps) {</span><span class="s2">\n        </span><span class="s1">for (let key in rawProps) {</span><span class="s2">\n            </span><span class="s1">// key, ref are reserved and never passed down</span><span class="s2">\n            </span><span class="s1">if (isReservedProp(key)) {</span><span class="s2">\n                </span><span class="s1">continue;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">const value = rawProps[key];</span><span class="s2">\n            </span><span class="s1">// prop option names are camelized during normalization, so to support</span><span class="s2">\n            </span><span class="s1">// kebab -&gt; camel conversion here we need to camelize the key.</span><span class="s2">\n            </span><span class="s1">let camelKey;</span><span class="s2">\n            </span><span class="s1">if (options &amp;&amp; hasOwn(options, (camelKey = camelize(key)))) {</span><span class="s2">\n                </span><span class="s1">if (!needCastKeys || !needCastKeys.includes(camelKey)) {</span><span class="s2">\n                    </span><span class="s1">props[camelKey] = value;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else {</span><span class="s2">\n                    </span><span class="s1">(rawCastValues || (rawCastValues = {}))[camelKey] = value;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else if (!isEmitListener(instance.emitsOptions, key)) {</span><span class="s2">\n                </span><span class="s1">if (!(key in attrs) || value !== attrs[key]) {</span><span class="s2">\n                    </span><span class="s1">attrs[key] = value;</span><span class="s2">\n                    </span><span class="s1">hasAttrsChanged = true;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (needCastKeys) {</span><span class="s2">\n        </span><span class="s1">const rawCurrentProps = toRaw(props);</span><span class="s2">\n        </span><span class="s1">const castValues = rawCastValues || EMPTY_OBJ;</span><span class="s2">\n        </span><span class="s1">for (let i = 0; i &lt; needCastKeys.length; i++) {</span><span class="s2">\n            </span><span class="s1">const key = needCastKeys[i];</span><span class="s2">\n            </span><span class="s1">props[key] = resolvePropValue(options, rawCurrentProps, key, castValues[key], instance, !hasOwn(castValues, key));</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return hasAttrsChanged;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function resolvePropValue(options, props, key, value, instance, isAbsent) {</span><span class="s2">\n    </span><span class="s1">const opt = options[key];</span><span class="s2">\n    </span><span class="s1">if (opt != null) {</span><span class="s2">\n        </span><span class="s1">const hasDefault = hasOwn(opt, 'default');</span><span class="s2">\n        </span><span class="s1">// default values</span><span class="s2">\n        </span><span class="s1">if (hasDefault &amp;&amp; value === undefined) {</span><span class="s2">\n            </span><span class="s1">const defaultValue = opt.default;</span><span class="s2">\n            </span><span class="s1">if (opt.type !== Function &amp;&amp; isFunction(defaultValue)) {</span><span class="s2">\n                </span><span class="s1">const { propsDefaults } = instance;</span><span class="s2">\n                </span><span class="s1">if (key in propsDefaults) {</span><span class="s2">\n                    </span><span class="s1">value = propsDefaults[key];</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else {</span><span class="s2">\n                    </span><span class="s1">setCurrentInstance(instance);</span><span class="s2">\n                    </span><span class="s1">value = propsDefaults[key] = defaultValue.call(null, props);</span><span class="s2">\n                    </span><span class="s1">unsetCurrentInstance();</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">value = defaultValue;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// boolean casting</span><span class="s2">\n        </span><span class="s1">if (opt[0 /* BooleanFlags.shouldCast */]) {</span><span class="s2">\n            </span><span class="s1">if (isAbsent &amp;&amp; !hasDefault) {</span><span class="s2">\n                </span><span class="s1">value = false;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else if (opt[1 /* BooleanFlags.shouldCastTrue */] &amp;&amp;</span><span class="s2">\n                </span><span class="s1">(value === '' || value === hyphenate(key))) {</span><span class="s2">\n                </span><span class="s1">value = true;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return value;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function normalizePropsOptions(comp, appContext, asMixin = false) {</span><span class="s2">\n    </span><span class="s1">const cache = appContext.propsCache;</span><span class="s2">\n    </span><span class="s1">const cached = cache.get(comp);</span><span class="s2">\n    </span><span class="s1">if (cached) {</span><span class="s2">\n        </span><span class="s1">return cached;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">const raw = comp.props;</span><span class="s2">\n    </span><span class="s1">const normalized = {};</span><span class="s2">\n    </span><span class="s1">const needCastKeys = [];</span><span class="s2">\n    </span><span class="s1">// apply mixin/extends props</span><span class="s2">\n    </span><span class="s1">let hasExtends = false;</span><span class="s2">\n    </span><span class="s1">if (__VUE_OPTIONS_API__ &amp;&amp; !isFunction(comp)) {</span><span class="s2">\n        </span><span class="s1">const extendProps = (raw) =&gt; {</span><span class="s2">\n            </span><span class="s1">hasExtends = true;</span><span class="s2">\n            </span><span class="s1">const [props, keys] = normalizePropsOptions(raw, appContext, true);</span><span class="s2">\n            </span><span class="s1">extend(normalized, props);</span><span class="s2">\n            </span><span class="s1">if (keys)</span><span class="s2">\n                </span><span class="s1">needCastKeys.push(...keys);</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n        </span><span class="s1">if (!asMixin &amp;&amp; appContext.mixins.length) {</span><span class="s2">\n            </span><span class="s1">appContext.mixins.forEach(extendProps);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (comp.extends) {</span><span class="s2">\n            </span><span class="s1">extendProps(comp.extends);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (comp.mixins) {</span><span class="s2">\n            </span><span class="s1">comp.mixins.forEach(extendProps);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (!raw &amp;&amp; !hasExtends) {</span><span class="s2">\n        </span><span class="s1">if (isObject(comp)) {</span><span class="s2">\n            </span><span class="s1">cache.set(comp, EMPTY_ARR);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return EMPTY_ARR;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (isArray(raw)) {</span><span class="s2">\n        </span><span class="s1">for (let i = 0; i &lt; raw.length; i++) {</span><span class="s2">\n            </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp; !isString(raw[i])) {</span><span class="s2">\n                </span><span class="s1">warn(`props must be strings when using array syntax.`, raw[i]);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">const normalizedKey = camelize(raw[i]);</span><span class="s2">\n            </span><span class="s1">if (validatePropName(normalizedKey)) {</span><span class="s2">\n                </span><span class="s1">normalized[normalizedKey] = EMPTY_OBJ;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (raw) {</span><span class="s2">\n        </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp; !isObject(raw)) {</span><span class="s2">\n            </span><span class="s1">warn(`invalid props options`, raw);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">for (const key in raw) {</span><span class="s2">\n            </span><span class="s1">const normalizedKey = camelize(key);</span><span class="s2">\n            </span><span class="s1">if (validatePropName(normalizedKey)) {</span><span class="s2">\n                </span><span class="s1">const opt = raw[key];</span><span class="s2">\n                </span><span class="s1">const prop = (normalized[normalizedKey] =</span><span class="s2">\n                    </span><span class="s1">isArray(opt) || isFunction(opt) ? { type: opt } : Object.assign({}, opt));</span><span class="s2">\n                </span><span class="s1">if (prop) {</span><span class="s2">\n                    </span><span class="s1">const booleanIndex = getTypeIndex(Boolean, prop.type);</span><span class="s2">\n                    </span><span class="s1">const stringIndex = getTypeIndex(String, prop.type);</span><span class="s2">\n                    </span><span class="s1">prop[0 /* BooleanFlags.shouldCast */] = booleanIndex &gt; -1;</span><span class="s2">\n                    </span><span class="s1">prop[1 /* BooleanFlags.shouldCastTrue */] =</span><span class="s2">\n                        </span><span class="s1">stringIndex &lt; 0 || booleanIndex &lt; stringIndex;</span><span class="s2">\n                    </span><span class="s1">// if the prop needs boolean casting or default value</span><span class="s2">\n                    </span><span class="s1">if (booleanIndex &gt; -1 || hasOwn(prop, 'default')) {</span><span class="s2">\n                        </span><span class="s1">needCastKeys.push(normalizedKey);</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">const res = [normalized, needCastKeys];</span><span class="s2">\n    </span><span class="s1">if (isObject(comp)) {</span><span class="s2">\n        </span><span class="s1">cache.set(comp, res);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return res;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function validatePropName(key) {</span><span class="s2">\n    </span><span class="s1">if (key[0] !== '$') {</span><span class="s2">\n        </span><span class="s1">return true;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n        </span><span class="s1">warn(`Invalid prop name: </span><span class="s2">\&quot;</span><span class="s1">${key}</span><span class="s2">\&quot; </span><span class="s1">is a reserved property.`);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return false;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// use function string name to check type constructors</span><span class="s2">\n</span><span class="s1">// so that it works across vms / iframes.</span><span class="s2">\n</span><span class="s1">function getType(ctor) {</span><span class="s2">\n    </span><span class="s1">const match = ctor &amp;&amp; ctor.toString().match(/^</span><span class="s2">\\</span><span class="s1">s*(function|class) (</span><span class="s2">\\</span><span class="s1">w+)/);</span><span class="s2">\n    </span><span class="s1">return match ? match[2] : ctor === null ? 'null' : '';</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isSameType(a, b) {</span><span class="s2">\n    </span><span class="s1">return getType(a) === getType(b);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getTypeIndex(type, expectedTypes) {</span><span class="s2">\n    </span><span class="s1">if (isArray(expectedTypes)) {</span><span class="s2">\n        </span><span class="s1">return expectedTypes.findIndex(t =&gt; isSameType(t, type));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (isFunction(expectedTypes)) {</span><span class="s2">\n        </span><span class="s1">return isSameType(expectedTypes, type) ? 0 : -1;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return -1;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* dev only</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function validateProps(rawProps, props, instance) {</span><span class="s2">\n    </span><span class="s1">const resolvedValues = toRaw(props);</span><span class="s2">\n    </span><span class="s1">const options = instance.propsOptions[0];</span><span class="s2">\n    </span><span class="s1">for (const key in options) {</span><span class="s2">\n        </span><span class="s1">let opt = options[key];</span><span class="s2">\n        </span><span class="s1">if (opt == null)</span><span class="s2">\n            </span><span class="s1">continue;</span><span class="s2">\n        </span><span class="s1">validateProp(key, resolvedValues[key], opt, !hasOwn(rawProps, key) &amp;&amp; !hasOwn(rawProps, hyphenate(key)));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* dev only</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function validateProp(name, value, prop, isAbsent) {</span><span class="s2">\n    </span><span class="s1">const { type, required, validator } = prop;</span><span class="s2">\n    </span><span class="s1">// required!</span><span class="s2">\n    </span><span class="s1">if (required &amp;&amp; isAbsent) {</span><span class="s2">\n        </span><span class="s1">warn('Missing required prop: </span><span class="s2">\&quot;</span><span class="s1">' + name + '</span><span class="s2">\&quot;</span><span class="s1">');</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// missing but optional</span><span class="s2">\n    </span><span class="s1">if (value == null &amp;&amp; !prop.required) {</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// type check</span><span class="s2">\n    </span><span class="s1">if (type != null &amp;&amp; type !== true) {</span><span class="s2">\n        </span><span class="s1">let isValid = false;</span><span class="s2">\n        </span><span class="s1">const types = isArray(type) ? type : [type];</span><span class="s2">\n        </span><span class="s1">const expectedTypes = [];</span><span class="s2">\n        </span><span class="s1">// value is valid as long as one of the specified types match</span><span class="s2">\n        </span><span class="s1">for (let i = 0; i &lt; types.length &amp;&amp; !isValid; i++) {</span><span class="s2">\n            </span><span class="s1">const { valid, expectedType } = assertType(value, types[i]);</span><span class="s2">\n            </span><span class="s1">expectedTypes.push(expectedType || '');</span><span class="s2">\n            </span><span class="s1">isValid = valid;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (!isValid) {</span><span class="s2">\n            </span><span class="s1">warn(getInvalidTypeMessage(name, value, expectedTypes));</span><span class="s2">\n            </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// custom validator</span><span class="s2">\n    </span><span class="s1">if (validator &amp;&amp; !validator(value)) {</span><span class="s2">\n        </span><span class="s1">warn('Invalid prop: custom validator check failed for prop </span><span class="s2">\&quot;</span><span class="s1">' + name + '</span><span class="s2">\&quot;</span><span class="s1">.');</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">const isSimpleType = /*#__PURE__*/ makeMap('String,Number,Boolean,Function,Symbol,BigInt');</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* dev only</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function assertType(value, type) {</span><span class="s2">\n    </span><span class="s1">let valid;</span><span class="s2">\n    </span><span class="s1">const expectedType = getType(type);</span><span class="s2">\n    </span><span class="s1">if (isSimpleType(expectedType)) {</span><span class="s2">\n        </span><span class="s1">const t = typeof value;</span><span class="s2">\n        </span><span class="s1">valid = t === expectedType.toLowerCase();</span><span class="s2">\n        </span><span class="s1">// for primitive wrapper objects</span><span class="s2">\n        </span><span class="s1">if (!valid &amp;&amp; t === 'object') {</span><span class="s2">\n            </span><span class="s1">valid = value instanceof type;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (expectedType === 'Object') {</span><span class="s2">\n        </span><span class="s1">valid = isObject(value);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (expectedType === 'Array') {</span><span class="s2">\n        </span><span class="s1">valid = isArray(value);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (expectedType === 'null') {</span><span class="s2">\n        </span><span class="s1">valid = value === null;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">valid = value instanceof type;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n        </span><span class="s1">valid,</span><span class="s2">\n        </span><span class="s1">expectedType</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* dev only</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function getInvalidTypeMessage(name, value, expectedTypes) {</span><span class="s2">\n    </span><span class="s1">let message = `Invalid prop: type check failed for prop </span><span class="s2">\&quot;</span><span class="s1">${name}</span><span class="s2">\&quot;</span><span class="s1">.` +</span><span class="s2">\n        </span><span class="s1">` Expected ${expectedTypes.map(capitalize).join(' | ')}`;</span><span class="s2">\n    </span><span class="s1">const expectedType = expectedTypes[0];</span><span class="s2">\n    </span><span class="s1">const receivedType = toRawType(value);</span><span class="s2">\n    </span><span class="s1">const expectedValue = styleValue(value, expectedType);</span><span class="s2">\n    </span><span class="s1">const receivedValue = styleValue(value, receivedType);</span><span class="s2">\n    </span><span class="s1">// check if we need to specify expected value</span><span class="s2">\n    </span><span class="s1">if (expectedTypes.length === 1 &amp;&amp;</span><span class="s2">\n        </span><span class="s1">isExplicable(expectedType) &amp;&amp;</span><span class="s2">\n        </span><span class="s1">!isBoolean(expectedType, receivedType)) {</span><span class="s2">\n        </span><span class="s1">message += ` with value ${expectedValue}`;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">message += `, got ${receivedType} `;</span><span class="s2">\n    </span><span class="s1">// check if we need to specify received value</span><span class="s2">\n    </span><span class="s1">if (isExplicable(receivedType)) {</span><span class="s2">\n        </span><span class="s1">message += `with value ${receivedValue}.`;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return message;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* dev only</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function styleValue(value, type) {</span><span class="s2">\n    </span><span class="s1">if (type === 'String') {</span><span class="s2">\n        </span><span class="s1">return `</span><span class="s2">\&quot;</span><span class="s1">${value}</span><span class="s2">\&quot;</span><span class="s1">`;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (type === 'Number') {</span><span class="s2">\n        </span><span class="s1">return `${Number(value)}`;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">return `${value}`;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* dev only</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function isExplicable(type) {</span><span class="s2">\n    </span><span class="s1">const explicitTypes = ['string', 'number', 'boolean'];</span><span class="s2">\n    </span><span class="s1">return explicitTypes.some(elem =&gt; type.toLowerCase() === elem);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* dev only</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function isBoolean(...args) {</span><span class="s2">\n    </span><span class="s1">return args.some(elem =&gt; elem.toLowerCase() === 'boolean');</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">const isInternalKey = (key) =&gt; key[0] === '_' || key === '$stable';</span><span class="s2">\n</span><span class="s1">const normalizeSlotValue = (value) =&gt; isArray(value)</span><span class="s2">\n    </span><span class="s1">? value.map(normalizeVNode)</span><span class="s2">\n    </span><span class="s1">: [normalizeVNode(value)];</span><span class="s2">\n</span><span class="s1">const normalizeSlot = (key, rawSlot, ctx) =&gt; {</span><span class="s2">\n    </span><span class="s1">if (rawSlot._n) {</span><span class="s2">\n        </span><span class="s1">// already normalized - #5353</span><span class="s2">\n        </span><span class="s1">return rawSlot;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">const normalized = withCtx((...args) =&gt; {</span><span class="s2">\n        </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp; currentInstance) {</span><span class="s2">\n            </span><span class="s1">warn(`Slot </span><span class="s2">\&quot;</span><span class="s1">${key}</span><span class="s2">\&quot; </span><span class="s1">invoked outside of the render function: ` +</span><span class="s2">\n                </span><span class="s1">`this will not track dependencies used in the slot. ` +</span><span class="s2">\n                </span><span class="s1">`Invoke the slot function inside the render function instead.`);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return normalizeSlotValue(rawSlot(...args));</span><span class="s2">\n    </span><span class="s1">}, ctx);</span><span class="s2">\n    </span><span class="s1">normalized._c = false;</span><span class="s2">\n    </span><span class="s1">return normalized;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">const normalizeObjectSlots = (rawSlots, slots, instance) =&gt; {</span><span class="s2">\n    </span><span class="s1">const ctx = rawSlots._ctx;</span><span class="s2">\n    </span><span class="s1">for (const key in rawSlots) {</span><span class="s2">\n        </span><span class="s1">if (isInternalKey(key))</span><span class="s2">\n            </span><span class="s1">continue;</span><span class="s2">\n        </span><span class="s1">const value = rawSlots[key];</span><span class="s2">\n        </span><span class="s1">if (isFunction(value)) {</span><span class="s2">\n            </span><span class="s1">slots[key] = normalizeSlot(key, value, ctx);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (value != null) {</span><span class="s2">\n            </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp;</span><span class="s2">\n                </span><span class="s1">!(false )) {</span><span class="s2">\n                </span><span class="s1">warn(`Non-function value encountered for slot </span><span class="s2">\&quot;</span><span class="s1">${key}</span><span class="s2">\&quot;</span><span class="s1">. ` +</span><span class="s2">\n                    </span><span class="s1">`Prefer function slots for better performance.`);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">const normalized = normalizeSlotValue(value);</span><span class="s2">\n            </span><span class="s1">slots[key] = () =&gt; normalized;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">const normalizeVNodeSlots = (instance, children) =&gt; {</span><span class="s2">\n    </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp;</span><span class="s2">\n        </span><span class="s1">!isKeepAlive(instance.vnode) &amp;&amp;</span><span class="s2">\n        </span><span class="s1">!(false )) {</span><span class="s2">\n        </span><span class="s1">warn(`Non-function value encountered for default slot. ` +</span><span class="s2">\n            </span><span class="s1">`Prefer function slots for better performance.`);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">const normalized = normalizeSlotValue(children);</span><span class="s2">\n    </span><span class="s1">instance.slots.default = () =&gt; normalized;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">const initSlots = (instance, children) =&gt; {</span><span class="s2">\n    </span><span class="s1">if (instance.vnode.shapeFlag &amp; 32 /* ShapeFlags.SLOTS_CHILDREN */) {</span><span class="s2">\n        </span><span class="s1">const type = children._;</span><span class="s2">\n        </span><span class="s1">if (type) {</span><span class="s2">\n            </span><span class="s1">// users can get the shallow readonly version of the slots object through `this.$slots`,</span><span class="s2">\n            </span><span class="s1">// we should avoid the proxy object polluting the slots of the internal instance</span><span class="s2">\n            </span><span class="s1">instance.slots = toRaw(children);</span><span class="s2">\n            </span><span class="s1">// make compiler marker non-enumerable</span><span class="s2">\n            </span><span class="s1">def(children, '_', type);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">normalizeObjectSlots(children, (instance.slots = {}));</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">instance.slots = {};</span><span class="s2">\n        </span><span class="s1">if (children) {</span><span class="s2">\n            </span><span class="s1">normalizeVNodeSlots(instance, children);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">def(instance.slots, InternalObjectKey, 1);</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">const updateSlots = (instance, children, optimized) =&gt; {</span><span class="s2">\n    </span><span class="s1">const { vnode, slots } = instance;</span><span class="s2">\n    </span><span class="s1">let needDeletionCheck = true;</span><span class="s2">\n    </span><span class="s1">let deletionComparisonTarget = EMPTY_OBJ;</span><span class="s2">\n    </span><span class="s1">if (vnode.shapeFlag &amp; 32 /* ShapeFlags.SLOTS_CHILDREN */) {</span><span class="s2">\n        </span><span class="s1">const type = children._;</span><span class="s2">\n        </span><span class="s1">if (type) {</span><span class="s2">\n            </span><span class="s1">// compiled slots.</span><span class="s2">\n            </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp; isHmrUpdating) {</span><span class="s2">\n                </span><span class="s1">// Parent was HMR updated so slot content may have changed.</span><span class="s2">\n                </span><span class="s1">// force update slots and mark instance for hmr as well</span><span class="s2">\n                </span><span class="s1">extend(slots, children);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else if (optimized &amp;&amp; type === 1 /* SlotFlags.STABLE */) {</span><span class="s2">\n                </span><span class="s1">// compiled AND stable.</span><span class="s2">\n                </span><span class="s1">// no need to update, and skip stale slots removal.</span><span class="s2">\n                </span><span class="s1">needDeletionCheck = false;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">// compiled but dynamic (v-if/v-for on slots) - update slots, but skip</span><span class="s2">\n                </span><span class="s1">// normalization.</span><span class="s2">\n                </span><span class="s1">extend(slots, children);</span><span class="s2">\n                </span><span class="s1">// #2893</span><span class="s2">\n                </span><span class="s1">// when rendering the optimized slots by manually written render function,</span><span class="s2">\n                </span><span class="s1">// we need to delete the `slots._` flag if necessary to make subsequent updates reliable,</span><span class="s2">\n                </span><span class="s1">// i.e. let the `renderSlot` create the bailed Fragment</span><span class="s2">\n                </span><span class="s1">if (!optimized &amp;&amp; type === 1 /* SlotFlags.STABLE */) {</span><span class="s2">\n                    </span><span class="s1">delete slots._;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">needDeletionCheck = !children.$stable;</span><span class="s2">\n            </span><span class="s1">normalizeObjectSlots(children, slots);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">deletionComparisonTarget = children;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (children) {</span><span class="s2">\n        </span><span class="s1">// non slot object children (direct value) passed to a component</span><span class="s2">\n        </span><span class="s1">normalizeVNodeSlots(instance, children);</span><span class="s2">\n        </span><span class="s1">deletionComparisonTarget = { default: 1 };</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// delete stale slots</span><span class="s2">\n    </span><span class="s1">if (needDeletionCheck) {</span><span class="s2">\n        </span><span class="s1">for (const key in slots) {</span><span class="s2">\n            </span><span class="s1">if (!isInternalKey(key) &amp;&amp; !(key in deletionComparisonTarget)) {</span><span class="s2">\n                </span><span class="s1">delete slots[key];</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">function createAppContext() {</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n        </span><span class="s1">app: null,</span><span class="s2">\n        </span><span class="s1">config: {</span><span class="s2">\n            </span><span class="s1">isNativeTag: NO,</span><span class="s2">\n            </span><span class="s1">performance: false,</span><span class="s2">\n            </span><span class="s1">globalProperties: {},</span><span class="s2">\n            </span><span class="s1">optionMergeStrategies: {},</span><span class="s2">\n            </span><span class="s1">errorHandler: undefined,</span><span class="s2">\n            </span><span class="s1">warnHandler: undefined,</span><span class="s2">\n            </span><span class="s1">compilerOptions: {}</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">mixins: [],</span><span class="s2">\n        </span><span class="s1">components: {},</span><span class="s2">\n        </span><span class="s1">directives: {},</span><span class="s2">\n        </span><span class="s1">provides: Object.create(null),</span><span class="s2">\n        </span><span class="s1">optionsCache: new WeakMap(),</span><span class="s2">\n        </span><span class="s1">propsCache: new WeakMap(),</span><span class="s2">\n        </span><span class="s1">emitsCache: new WeakMap()</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">let uid$1 = 0;</span><span class="s2">\n</span><span class="s1">function createAppAPI(render, hydrate) {</span><span class="s2">\n    </span><span class="s1">return function createApp(rootComponent, rootProps = null) {</span><span class="s2">\n        </span><span class="s1">if (!isFunction(rootComponent)) {</span><span class="s2">\n            </span><span class="s1">rootComponent = Object.assign({}, rootComponent);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (rootProps != null &amp;&amp; !isObject(rootProps)) {</span><span class="s2">\n            </span><span class="s1">(process.env.NODE_ENV !== 'production') &amp;&amp; warn(`root props passed to app.mount() must be an object.`);</span><span class="s2">\n            </span><span class="s1">rootProps = null;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">const context = createAppContext();</span><span class="s2">\n        </span><span class="s1">const installedPlugins = new Set();</span><span class="s2">\n        </span><span class="s1">let isMounted = false;</span><span class="s2">\n        </span><span class="s1">const app = (context.app = {</span><span class="s2">\n            </span><span class="s1">_uid: uid$1++,</span><span class="s2">\n            </span><span class="s1">_component: rootComponent,</span><span class="s2">\n            </span><span class="s1">_props: rootProps,</span><span class="s2">\n            </span><span class="s1">_container: null,</span><span class="s2">\n            </span><span class="s1">_context: context,</span><span class="s2">\n            </span><span class="s1">_instance: null,</span><span class="s2">\n            </span><span class="s1">version,</span><span class="s2">\n            </span><span class="s1">get config() {</span><span class="s2">\n                </span><span class="s1">return context.config;</span><span class="s2">\n            </span><span class="s1">},</span><span class="s2">\n            </span><span class="s1">set config(v) {</span><span class="s2">\n                </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n                    </span><span class="s1">warn(`app.config cannot be replaced. Modify individual options instead.`);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">},</span><span class="s2">\n            </span><span class="s1">use(plugin, ...options) {</span><span class="s2">\n                </span><span class="s1">if (installedPlugins.has(plugin)) {</span><span class="s2">\n                    </span><span class="s1">(process.env.NODE_ENV !== 'production') &amp;&amp; warn(`Plugin has already been applied to target app.`);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else if (plugin &amp;&amp; isFunction(plugin.install)) {</span><span class="s2">\n                    </span><span class="s1">installedPlugins.add(plugin);</span><span class="s2">\n                    </span><span class="s1">plugin.install(app, ...options);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else if (isFunction(plugin)) {</span><span class="s2">\n                    </span><span class="s1">installedPlugins.add(plugin);</span><span class="s2">\n                    </span><span class="s1">plugin(app, ...options);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n                    </span><span class="s1">warn(`A plugin must either be a function or an object with an </span><span class="s2">\&quot;</span><span class="s1">install</span><span class="s2">\&quot; </span><span class="s1">` +</span><span class="s2">\n                        </span><span class="s1">`function.`);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">return app;</span><span class="s2">\n            </span><span class="s1">},</span><span class="s2">\n            </span><span class="s1">mixin(mixin) {</span><span class="s2">\n                </span><span class="s1">if (__VUE_OPTIONS_API__) {</span><span class="s2">\n                    </span><span class="s1">if (!context.mixins.includes(mixin)) {</span><span class="s2">\n                        </span><span class="s1">context.mixins.push(mixin);</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">else if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n                        </span><span class="s1">warn('Mixin has already been applied to target app' +</span><span class="s2">\n                            </span><span class="s1">(mixin.name ? `: ${mixin.name}` : ''));</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n                    </span><span class="s1">warn('Mixins are only available in builds supporting Options API');</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">return app;</span><span class="s2">\n            </span><span class="s1">},</span><span class="s2">\n            </span><span class="s1">component(name, component) {</span><span class="s2">\n                </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n                    </span><span class="s1">validateComponentName(name, context.config);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">if (!component) {</span><span class="s2">\n                    </span><span class="s1">return context.components[name];</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp; context.components[name]) {</span><span class="s2">\n                    </span><span class="s1">warn(`Component </span><span class="s2">\&quot;</span><span class="s1">${name}</span><span class="s2">\&quot; </span><span class="s1">has already been registered in target app.`);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">context.components[name] = component;</span><span class="s2">\n                </span><span class="s1">return app;</span><span class="s2">\n            </span><span class="s1">},</span><span class="s2">\n            </span><span class="s1">directive(name, directive) {</span><span class="s2">\n                </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n                    </span><span class="s1">validateDirectiveName(name);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">if (!directive) {</span><span class="s2">\n                    </span><span class="s1">return context.directives[name];</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp; context.directives[name]) {</span><span class="s2">\n                    </span><span class="s1">warn(`Directive </span><span class="s2">\&quot;</span><span class="s1">${name}</span><span class="s2">\&quot; </span><span class="s1">has already been registered in target app.`);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">context.directives[name] = directive;</span><span class="s2">\n                </span><span class="s1">return app;</span><span class="s2">\n            </span><span class="s1">},</span><span class="s2">\n            </span><span class="s1">mount(rootContainer, isHydrate, isSVG) {</span><span class="s2">\n                </span><span class="s1">if (!isMounted) {</span><span class="s2">\n                    </span><span class="s1">// #5571</span><span class="s2">\n                    </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp; rootContainer.__vue_app__) {</span><span class="s2">\n                        </span><span class="s1">warn(`There is already an app instance mounted on the host container.</span><span class="s2">\\</span><span class="s1">n` +</span><span class="s2">\n                            </span><span class="s1">` If you want to mount another app on the same host container,` +</span><span class="s2">\n                            </span><span class="s1">` you need to unmount the previous app by calling </span><span class="s2">\\</span><span class="s1">`app.unmount()</span><span class="s2">\\</span><span class="s1">` first.`);</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">const vnode = createVNode(rootComponent, rootProps);</span><span class="s2">\n                    </span><span class="s1">// store app context on the root VNode.</span><span class="s2">\n                    </span><span class="s1">// this will be set on the root instance on initial mount.</span><span class="s2">\n                    </span><span class="s1">vnode.appContext = context;</span><span class="s2">\n                    </span><span class="s1">// HMR root reload</span><span class="s2">\n                    </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n                        </span><span class="s1">context.reload = () =&gt; {</span><span class="s2">\n                            </span><span class="s1">render(cloneVNode(vnode), rootContainer, isSVG);</span><span class="s2">\n                        </span><span class="s1">};</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">if (isHydrate &amp;&amp; hydrate) {</span><span class="s2">\n                        </span><span class="s1">hydrate(vnode, rootContainer);</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">else {</span><span class="s2">\n                        </span><span class="s1">render(vnode, rootContainer, isSVG);</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">isMounted = true;</span><span class="s2">\n                    </span><span class="s1">app._container = rootContainer;</span><span class="s2">\n                    </span><span class="s1">rootContainer.__vue_app__ = app;</span><span class="s2">\n                    </span><span class="s1">if ((process.env.NODE_ENV !== 'production') || __VUE_PROD_DEVTOOLS__) {</span><span class="s2">\n                        </span><span class="s1">app._instance = vnode.component;</span><span class="s2">\n                        </span><span class="s1">devtoolsInitApp(app, version);</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">return getExposeProxy(vnode.component) || vnode.component.proxy;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n                    </span><span class="s1">warn(`App has already been mounted.</span><span class="s2">\\</span><span class="s1">n` +</span><span class="s2">\n                        </span><span class="s1">`If you want to remount the same app, move your app creation logic ` +</span><span class="s2">\n                        </span><span class="s1">`into a factory function and create fresh app instances for each ` +</span><span class="s2">\n                        </span><span class="s1">`mount - e.g. </span><span class="s2">\\</span><span class="s1">`const createMyApp = () =&gt; createApp(App)</span><span class="s2">\\</span><span class="s1">``);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">},</span><span class="s2">\n            </span><span class="s1">unmount() {</span><span class="s2">\n                </span><span class="s1">if (isMounted) {</span><span class="s2">\n                    </span><span class="s1">render(null, app._container);</span><span class="s2">\n                    </span><span class="s1">if ((process.env.NODE_ENV !== 'production') || __VUE_PROD_DEVTOOLS__) {</span><span class="s2">\n                        </span><span class="s1">app._instance = null;</span><span class="s2">\n                        </span><span class="s1">devtoolsUnmountApp(app);</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">delete app._container.__vue_app__;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n                    </span><span class="s1">warn(`Cannot unmount an app that is not mounted.`);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">},</span><span class="s2">\n            </span><span class="s1">provide(key, value) {</span><span class="s2">\n                </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp; key in context.provides) {</span><span class="s2">\n                    </span><span class="s1">warn(`App already provides property with key </span><span class="s2">\&quot;</span><span class="s1">${String(key)}</span><span class="s2">\&quot;</span><span class="s1">. ` +</span><span class="s2">\n                        </span><span class="s1">`It will be overwritten with the new value.`);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">context.provides[key] = value;</span><span class="s2">\n                </span><span class="s1">return app;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">return app;</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Function for handling a template ref</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {</span><span class="s2">\n    </span><span class="s1">if (isArray(rawRef)) {</span><span class="s2">\n        </span><span class="s1">rawRef.forEach((r, i) =&gt; setRef(r, oldRawRef &amp;&amp; (isArray(oldRawRef) ? oldRawRef[i] : oldRawRef), parentSuspense, vnode, isUnmount));</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (isAsyncWrapper(vnode) &amp;&amp; !isUnmount) {</span><span class="s2">\n        </span><span class="s1">// when mounting async components, nothing needs to be done,</span><span class="s2">\n        </span><span class="s1">// because the template ref is forwarded to inner component</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">const refValue = vnode.shapeFlag &amp; 4 /* ShapeFlags.STATEFUL_COMPONENT */</span><span class="s2">\n        </span><span class="s1">? getExposeProxy(vnode.component) || vnode.component.proxy</span><span class="s2">\n        </span><span class="s1">: vnode.el;</span><span class="s2">\n    </span><span class="s1">const value = isUnmount ? null : refValue;</span><span class="s2">\n    </span><span class="s1">const { i: owner, r: ref } = rawRef;</span><span class="s2">\n    </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp; !owner) {</span><span class="s2">\n        </span><span class="s1">warn(`Missing ref owner context. ref cannot be used on hoisted vnodes. ` +</span><span class="s2">\n            </span><span class="s1">`A vnode with ref must be created inside the render function.`);</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">const oldRef = oldRawRef &amp;&amp; oldRawRef.r;</span><span class="s2">\n    </span><span class="s1">const refs = owner.refs === EMPTY_OBJ ? (owner.refs = {}) : owner.refs;</span><span class="s2">\n    </span><span class="s1">const setupState = owner.setupState;</span><span class="s2">\n    </span><span class="s1">// dynamic ref changed. unset old ref</span><span class="s2">\n    </span><span class="s1">if (oldRef != null &amp;&amp; oldRef !== ref) {</span><span class="s2">\n        </span><span class="s1">if (isString(oldRef)) {</span><span class="s2">\n            </span><span class="s1">refs[oldRef] = null;</span><span class="s2">\n            </span><span class="s1">if (hasOwn(setupState, oldRef)) {</span><span class="s2">\n                </span><span class="s1">setupState[oldRef] = null;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (isRef(oldRef)) {</span><span class="s2">\n            </span><span class="s1">oldRef.value = null;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (isFunction(ref)) {</span><span class="s2">\n        </span><span class="s1">callWithErrorHandling(ref, owner, 12 /* ErrorCodes.FUNCTION_REF */, [value, refs]);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">const _isString = isString(ref);</span><span class="s2">\n        </span><span class="s1">const _isRef = isRef(ref);</span><span class="s2">\n        </span><span class="s1">if (_isString || _isRef) {</span><span class="s2">\n            </span><span class="s1">const doSet = () =&gt; {</span><span class="s2">\n                </span><span class="s1">if (rawRef.f) {</span><span class="s2">\n                    </span><span class="s1">const existing = _isString</span><span class="s2">\n                        </span><span class="s1">? hasOwn(setupState, ref)</span><span class="s2">\n                            </span><span class="s1">? setupState[ref]</span><span class="s2">\n                            </span><span class="s1">: refs[ref]</span><span class="s2">\n                        </span><span class="s1">: ref.value;</span><span class="s2">\n                    </span><span class="s1">if (isUnmount) {</span><span class="s2">\n                        </span><span class="s1">isArray(existing) &amp;&amp; remove(existing, refValue);</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">else {</span><span class="s2">\n                        </span><span class="s1">if (!isArray(existing)) {</span><span class="s2">\n                            </span><span class="s1">if (_isString) {</span><span class="s2">\n                                </span><span class="s1">refs[ref] = [refValue];</span><span class="s2">\n                                </span><span class="s1">if (hasOwn(setupState, ref)) {</span><span class="s2">\n                                    </span><span class="s1">setupState[ref] = refs[ref];</span><span class="s2">\n                                </span><span class="s1">}</span><span class="s2">\n                            </span><span class="s1">}</span><span class="s2">\n                            </span><span class="s1">else {</span><span class="s2">\n                                </span><span class="s1">ref.value = [refValue];</span><span class="s2">\n                                </span><span class="s1">if (rawRef.k)</span><span class="s2">\n                                    </span><span class="s1">refs[rawRef.k] = ref.value;</span><span class="s2">\n                            </span><span class="s1">}</span><span class="s2">\n                        </span><span class="s1">}</span><span class="s2">\n                        </span><span class="s1">else if (!existing.includes(refValue)) {</span><span class="s2">\n                            </span><span class="s1">existing.push(refValue);</span><span class="s2">\n                        </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else if (_isString) {</span><span class="s2">\n                    </span><span class="s1">refs[ref] = value;</span><span class="s2">\n                    </span><span class="s1">if (hasOwn(setupState, ref)) {</span><span class="s2">\n                        </span><span class="s1">setupState[ref] = value;</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else if (_isRef) {</span><span class="s2">\n                    </span><span class="s1">ref.value = value;</span><span class="s2">\n                    </span><span class="s1">if (rawRef.k)</span><span class="s2">\n                        </span><span class="s1">refs[rawRef.k] = value;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n                    </span><span class="s1">warn('Invalid template ref type:', ref, `(${typeof ref})`);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">};</span><span class="s2">\n            </span><span class="s1">if (value) {</span><span class="s2">\n                </span><span class="s1">doSet.id = -1;</span><span class="s2">\n                </span><span class="s1">queuePostRenderEffect(doSet, parentSuspense);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">doSet();</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n            </span><span class="s1">warn('Invalid template ref type:', ref, `(${typeof ref})`);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">let hasMismatch = false;</span><span class="s2">\n</span><span class="s1">const isSVGContainer = (container) =&gt; /svg/.test(container.namespaceURI) &amp;&amp; container.tagName !== 'foreignObject';</span><span class="s2">\n</span><span class="s1">const isComment = (node) =&gt; node.nodeType === 8 /* DOMNodeTypes.COMMENT */;</span><span class="s2">\n</span><span class="s1">// Note: hydration is DOM-specific</span><span class="s2">\n</span><span class="s1">// But we have to place it in core due to tight coupling with core - splitting</span><span class="s2">\n</span><span class="s1">// it out creates a ton of unnecessary complexity.</span><span class="s2">\n</span><span class="s1">// Hydration also depends on some renderer internal logic which needs to be</span><span class="s2">\n</span><span class="s1">// passed in via arguments.</span><span class="s2">\n</span><span class="s1">function createHydrationFunctions(rendererInternals) {</span><span class="s2">\n    </span><span class="s1">const { mt: mountComponent, p: patch, o: { patchProp, createText, nextSibling, parentNode, remove, insert, createComment } } = rendererInternals;</span><span class="s2">\n    </span><span class="s1">const hydrate = (vnode, container) =&gt; {</span><span class="s2">\n        </span><span class="s1">if (!container.hasChildNodes()) {</span><span class="s2">\n            </span><span class="s1">(process.env.NODE_ENV !== 'production') &amp;&amp;</span><span class="s2">\n                </span><span class="s1">warn(`Attempting to hydrate existing markup but container is empty. ` +</span><span class="s2">\n                    </span><span class="s1">`Performing full mount instead.`);</span><span class="s2">\n            </span><span class="s1">patch(null, vnode, container);</span><span class="s2">\n            </span><span class="s1">flushPostFlushCbs();</span><span class="s2">\n            </span><span class="s1">container._vnode = vnode;</span><span class="s2">\n            </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">hasMismatch = false;</span><span class="s2">\n        </span><span class="s1">hydrateNode(container.firstChild, vnode, null, null, null);</span><span class="s2">\n        </span><span class="s1">flushPostFlushCbs();</span><span class="s2">\n        </span><span class="s1">container._vnode = vnode;</span><span class="s2">\n        </span><span class="s1">if (hasMismatch &amp;&amp; !false) {</span><span class="s2">\n            </span><span class="s1">// this error should show up in production</span><span class="s2">\n            </span><span class="s1">console.error(`Hydration completed but contains mismatches.`);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">const hydrateNode = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false) =&gt; {</span><span class="s2">\n        </span><span class="s1">const isFragmentStart = isComment(node) &amp;&amp; node.data === '[';</span><span class="s2">\n        </span><span class="s1">const onMismatch = () =&gt; handleMismatch(node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragmentStart);</span><span class="s2">\n        </span><span class="s1">const { type, ref, shapeFlag, patchFlag } = vnode;</span><span class="s2">\n        </span><span class="s1">let domType = node.nodeType;</span><span class="s2">\n        </span><span class="s1">vnode.el = node;</span><span class="s2">\n        </span><span class="s1">if (patchFlag === -2 /* PatchFlags.BAIL */) {</span><span class="s2">\n            </span><span class="s1">optimized = false;</span><span class="s2">\n            </span><span class="s1">vnode.dynamicChildren = null;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">let nextNode = null;</span><span class="s2">\n        </span><span class="s1">switch (type) {</span><span class="s2">\n            </span><span class="s1">case Text:</span><span class="s2">\n                </span><span class="s1">if (domType !== 3 /* DOMNodeTypes.TEXT */) {</span><span class="s2">\n                    </span><span class="s1">// #5728 empty text node inside a slot can cause hydration failure</span><span class="s2">\n                    </span><span class="s1">// because the server rendered HTML won't contain a text node</span><span class="s2">\n                    </span><span class="s1">if (vnode.children === '') {</span><span class="s2">\n                        </span><span class="s1">insert((vnode.el = createText('')), parentNode(node), node);</span><span class="s2">\n                        </span><span class="s1">nextNode = node;</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">else {</span><span class="s2">\n                        </span><span class="s1">nextNode = onMismatch();</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else {</span><span class="s2">\n                    </span><span class="s1">if (node.data !== vnode.children) {</span><span class="s2">\n                        </span><span class="s1">hasMismatch = true;</span><span class="s2">\n                        </span><span class="s1">(process.env.NODE_ENV !== 'production') &amp;&amp;</span><span class="s2">\n                            </span><span class="s1">warn(`Hydration text mismatch:` +</span><span class="s2">\n                                </span><span class="s1">`</span><span class="s2">\\</span><span class="s1">n- Client: ${JSON.stringify(node.data)}` +</span><span class="s2">\n                                </span><span class="s1">`</span><span class="s2">\\</span><span class="s1">n- Server: ${JSON.stringify(vnode.children)}`);</span><span class="s2">\n                        </span><span class="s1">node.data = vnode.children;</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">nextNode = nextSibling(node);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">break;</span><span class="s2">\n            </span><span class="s1">case Comment:</span><span class="s2">\n                </span><span class="s1">if (domType !== 8 /* DOMNodeTypes.COMMENT */ || isFragmentStart) {</span><span class="s2">\n                    </span><span class="s1">nextNode = onMismatch();</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else {</span><span class="s2">\n                    </span><span class="s1">nextNode = nextSibling(node);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">break;</span><span class="s2">\n            </span><span class="s1">case Static:</span><span class="s2">\n                </span><span class="s1">if (isFragmentStart) {</span><span class="s2">\n                    </span><span class="s1">// entire template is static but SSRed as a fragment</span><span class="s2">\n                    </span><span class="s1">node = nextSibling(node);</span><span class="s2">\n                    </span><span class="s1">domType = node.nodeType;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">if (domType === 1 /* DOMNodeTypes.ELEMENT */ || domType === 3 /* DOMNodeTypes.TEXT */) {</span><span class="s2">\n                    </span><span class="s1">// determine anchor, adopt content</span><span class="s2">\n                    </span><span class="s1">nextNode = node;</span><span class="s2">\n                    </span><span class="s1">// if the static vnode has its content stripped during build,</span><span class="s2">\n                    </span><span class="s1">// adopt it from the server-rendered HTML.</span><span class="s2">\n                    </span><span class="s1">const needToAdoptContent = !vnode.children.length;</span><span class="s2">\n                    </span><span class="s1">for (let i = 0; i &lt; vnode.staticCount; i++) {</span><span class="s2">\n                        </span><span class="s1">if (needToAdoptContent)</span><span class="s2">\n                            </span><span class="s1">vnode.children +=</span><span class="s2">\n                                </span><span class="s1">nextNode.nodeType === 1 /* DOMNodeTypes.ELEMENT */</span><span class="s2">\n                                    </span><span class="s1">? nextNode.outerHTML</span><span class="s2">\n                                    </span><span class="s1">: nextNode.data;</span><span class="s2">\n                        </span><span class="s1">if (i === vnode.staticCount - 1) {</span><span class="s2">\n                            </span><span class="s1">vnode.anchor = nextNode;</span><span class="s2">\n                        </span><span class="s1">}</span><span class="s2">\n                        </span><span class="s1">nextNode = nextSibling(nextNode);</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">return isFragmentStart ? nextSibling(nextNode) : nextNode;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else {</span><span class="s2">\n                    </span><span class="s1">onMismatch();</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">break;</span><span class="s2">\n            </span><span class="s1">case Fragment:</span><span class="s2">\n                </span><span class="s1">if (!isFragmentStart) {</span><span class="s2">\n                    </span><span class="s1">nextNode = onMismatch();</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else {</span><span class="s2">\n                    </span><span class="s1">nextNode = hydrateFragment(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">break;</span><span class="s2">\n            </span><span class="s1">default:</span><span class="s2">\n                </span><span class="s1">if (shapeFlag &amp; 1 /* ShapeFlags.ELEMENT */) {</span><span class="s2">\n                    </span><span class="s1">if (domType !== 1 /* DOMNodeTypes.ELEMENT */ ||</span><span class="s2">\n                        </span><span class="s1">vnode.type.toLowerCase() !==</span><span class="s2">\n                            </span><span class="s1">node.tagName.toLowerCase()) {</span><span class="s2">\n                        </span><span class="s1">nextNode = onMismatch();</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">else {</span><span class="s2">\n                        </span><span class="s1">nextNode = hydrateElement(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else if (shapeFlag &amp; 6 /* ShapeFlags.COMPONENT */) {</span><span class="s2">\n                    </span><span class="s1">// when setting up the render effect, if the initial vnode already</span><span class="s2">\n                    </span><span class="s1">// has .el set, the component will perform hydration instead of mount</span><span class="s2">\n                    </span><span class="s1">// on its sub-tree.</span><span class="s2">\n                    </span><span class="s1">vnode.slotScopeIds = slotScopeIds;</span><span class="s2">\n                    </span><span class="s1">const container = parentNode(node);</span><span class="s2">\n                    </span><span class="s1">mountComponent(vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), optimized);</span><span class="s2">\n                    </span><span class="s1">// component may be async, so in the case of fragments we cannot rely</span><span class="s2">\n                    </span><span class="s1">// on component's rendered output to determine the end of the fragment</span><span class="s2">\n                    </span><span class="s1">// instead, we do a lookahead to find the end anchor node.</span><span class="s2">\n                    </span><span class="s1">nextNode = isFragmentStart</span><span class="s2">\n                        </span><span class="s1">? locateClosingAsyncAnchor(node)</span><span class="s2">\n                        </span><span class="s1">: nextSibling(node);</span><span class="s2">\n                    </span><span class="s1">// #4293 teleport as component root</span><span class="s2">\n                    </span><span class="s1">if (nextNode &amp;&amp;</span><span class="s2">\n                        </span><span class="s1">isComment(nextNode) &amp;&amp;</span><span class="s2">\n                        </span><span class="s1">nextNode.data === 'teleport end') {</span><span class="s2">\n                        </span><span class="s1">nextNode = nextSibling(nextNode);</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">// #3787</span><span class="s2">\n                    </span><span class="s1">// if component is async, it may get moved / unmounted before its</span><span class="s2">\n                    </span><span class="s1">// inner component is loaded, so we need to give it a placeholder</span><span class="s2">\n                    </span><span class="s1">// vnode that matches its adopted DOM.</span><span class="s2">\n                    </span><span class="s1">if (isAsyncWrapper(vnode)) {</span><span class="s2">\n                        </span><span class="s1">let subTree;</span><span class="s2">\n                        </span><span class="s1">if (isFragmentStart) {</span><span class="s2">\n                            </span><span class="s1">subTree = createVNode(Fragment);</span><span class="s2">\n                            </span><span class="s1">subTree.anchor = nextNode</span><span class="s2">\n                                </span><span class="s1">? nextNode.previousSibling</span><span class="s2">\n                                </span><span class="s1">: container.lastChild;</span><span class="s2">\n                        </span><span class="s1">}</span><span class="s2">\n                        </span><span class="s1">else {</span><span class="s2">\n                            </span><span class="s1">subTree =</span><span class="s2">\n                                </span><span class="s1">node.nodeType === 3 ? createTextVNode('') : createVNode('div');</span><span class="s2">\n                        </span><span class="s1">}</span><span class="s2">\n                        </span><span class="s1">subTree.el = node;</span><span class="s2">\n                        </span><span class="s1">vnode.component.subTree = subTree;</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else if (shapeFlag &amp; 64 /* ShapeFlags.TELEPORT */) {</span><span class="s2">\n                    </span><span class="s1">if (domType !== 8 /* DOMNodeTypes.COMMENT */) {</span><span class="s2">\n                        </span><span class="s1">nextNode = onMismatch();</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">else {</span><span class="s2">\n                        </span><span class="s1">nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, rendererInternals, hydrateChildren);</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else if (shapeFlag &amp; 128 /* ShapeFlags.SUSPENSE */) {</span><span class="s2">\n                    </span><span class="s1">nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, isSVGContainer(parentNode(node)), slotScopeIds, optimized, rendererInternals, hydrateNode);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n                    </span><span class="s1">warn('Invalid HostVNode type:', type, `(${typeof type})`);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (ref != null) {</span><span class="s2">\n            </span><span class="s1">setRef(ref, null, parentSuspense, vnode);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return nextNode;</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">const hydrateElement = (el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) =&gt; {</span><span class="s2">\n        </span><span class="s1">optimized = optimized || !!vnode.dynamicChildren;</span><span class="s2">\n        </span><span class="s1">const { type, props, patchFlag, shapeFlag, dirs } = vnode;</span><span class="s2">\n        </span><span class="s1">// #4006 for form elements with non-string v-model value bindings</span><span class="s2">\n        </span><span class="s1">// e.g. &lt;option :value=</span><span class="s2">\&quot;</span><span class="s1">obj</span><span class="s2">\&quot;</span><span class="s1">&gt;, &lt;input type=</span><span class="s2">\&quot;</span><span class="s1">checkbox</span><span class="s2">\&quot; </span><span class="s1">:true-value=</span><span class="s2">\&quot;</span><span class="s1">1</span><span class="s2">\&quot;</span><span class="s1">&gt;</span><span class="s2">\n        </span><span class="s1">const forcePatchValue = (type === 'input' &amp;&amp; dirs) || type === 'option';</span><span class="s2">\n        </span><span class="s1">// skip props &amp; children if this is hoisted static nodes</span><span class="s2">\n        </span><span class="s1">// #5405 in dev, always hydrate children for HMR</span><span class="s2">\n        </span><span class="s1">if ((process.env.NODE_ENV !== 'production') || forcePatchValue || patchFlag !== -1 /* PatchFlags.HOISTED */) {</span><span class="s2">\n            </span><span class="s1">if (dirs) {</span><span class="s2">\n                </span><span class="s1">invokeDirectiveHook(vnode, null, parentComponent, 'created');</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">// props</span><span class="s2">\n            </span><span class="s1">if (props) {</span><span class="s2">\n                </span><span class="s1">if (forcePatchValue ||</span><span class="s2">\n                    </span><span class="s1">!optimized ||</span><span class="s2">\n                    </span><span class="s1">patchFlag &amp; (16 /* PatchFlags.FULL_PROPS */ | 32 /* PatchFlags.HYDRATE_EVENTS */)) {</span><span class="s2">\n                    </span><span class="s1">for (const key in props) {</span><span class="s2">\n                        </span><span class="s1">if ((forcePatchValue &amp;&amp; key.endsWith('value')) ||</span><span class="s2">\n                            </span><span class="s1">(isOn(key) &amp;&amp; !isReservedProp(key))) {</span><span class="s2">\n                            </span><span class="s1">patchProp(el, key, null, props[key], false, undefined, parentComponent);</span><span class="s2">\n                        </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else if (props.onClick) {</span><span class="s2">\n                    </span><span class="s1">// Fast path for click listeners (which is most often) to avoid</span><span class="s2">\n                    </span><span class="s1">// iterating through props.</span><span class="s2">\n                    </span><span class="s1">patchProp(el, 'onClick', null, props.onClick, false, undefined, parentComponent);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">// vnode / directive hooks</span><span class="s2">\n            </span><span class="s1">let vnodeHooks;</span><span class="s2">\n            </span><span class="s1">if ((vnodeHooks = props &amp;&amp; props.onVnodeBeforeMount)) {</span><span class="s2">\n                </span><span class="s1">invokeVNodeHook(vnodeHooks, parentComponent, vnode);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">if (dirs) {</span><span class="s2">\n                </span><span class="s1">invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount');</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">if ((vnodeHooks = props &amp;&amp; props.onVnodeMounted) || dirs) {</span><span class="s2">\n                </span><span class="s1">queueEffectWithSuspense(() =&gt; {</span><span class="s2">\n                    </span><span class="s1">vnodeHooks &amp;&amp; invokeVNodeHook(vnodeHooks, parentComponent, vnode);</span><span class="s2">\n                    </span><span class="s1">dirs &amp;&amp; invokeDirectiveHook(vnode, null, parentComponent, 'mounted');</span><span class="s2">\n                </span><span class="s1">}, parentSuspense);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">// children</span><span class="s2">\n            </span><span class="s1">if (shapeFlag &amp; 16 /* ShapeFlags.ARRAY_CHILDREN */ &amp;&amp;</span><span class="s2">\n                </span><span class="s1">// skip if element has innerHTML / textContent</span><span class="s2">\n                </span><span class="s1">!(props &amp;&amp; (props.innerHTML || props.textContent))) {</span><span class="s2">\n                </span><span class="s1">let next = hydrateChildren(el.firstChild, vnode, el, parentComponent, parentSuspense, slotScopeIds, optimized);</span><span class="s2">\n                </span><span class="s1">let hasWarned = false;</span><span class="s2">\n                </span><span class="s1">while (next) {</span><span class="s2">\n                    </span><span class="s1">hasMismatch = true;</span><span class="s2">\n                    </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp; !hasWarned) {</span><span class="s2">\n                        </span><span class="s1">warn(`Hydration children mismatch in &lt;${vnode.type}&gt;: ` +</span><span class="s2">\n                            </span><span class="s1">`server rendered element contains more child nodes than client vdom.`);</span><span class="s2">\n                        </span><span class="s1">hasWarned = true;</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">// The SSRed DOM contains more nodes than it should. Remove them.</span><span class="s2">\n                    </span><span class="s1">const cur = next;</span><span class="s2">\n                    </span><span class="s1">next = next.nextSibling;</span><span class="s2">\n                    </span><span class="s1">remove(cur);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else if (shapeFlag &amp; 8 /* ShapeFlags.TEXT_CHILDREN */) {</span><span class="s2">\n                </span><span class="s1">if (el.textContent !== vnode.children) {</span><span class="s2">\n                    </span><span class="s1">hasMismatch = true;</span><span class="s2">\n                    </span><span class="s1">(process.env.NODE_ENV !== 'production') &amp;&amp;</span><span class="s2">\n                        </span><span class="s1">warn(`Hydration text content mismatch in &lt;${vnode.type}&gt;:</span><span class="s2">\\</span><span class="s1">n` +</span><span class="s2">\n                            </span><span class="s1">`- Client: ${el.textContent}</span><span class="s2">\\</span><span class="s1">n` +</span><span class="s2">\n                            </span><span class="s1">`- Server: ${vnode.children}`);</span><span class="s2">\n                    </span><span class="s1">el.textContent = vnode.children;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return el.nextSibling;</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) =&gt; {</span><span class="s2">\n        </span><span class="s1">optimized = optimized || !!parentVNode.dynamicChildren;</span><span class="s2">\n        </span><span class="s1">const children = parentVNode.children;</span><span class="s2">\n        </span><span class="s1">const l = children.length;</span><span class="s2">\n        </span><span class="s1">let hasWarned = false;</span><span class="s2">\n        </span><span class="s1">for (let i = 0; i &lt; l; i++) {</span><span class="s2">\n            </span><span class="s1">const vnode = optimized</span><span class="s2">\n                </span><span class="s1">? children[i]</span><span class="s2">\n                </span><span class="s1">: (children[i] = normalizeVNode(children[i]));</span><span class="s2">\n            </span><span class="s1">if (node) {</span><span class="s2">\n                </span><span class="s1">node = hydrateNode(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else if (vnode.type === Text &amp;&amp; !vnode.children) {</span><span class="s2">\n                </span><span class="s1">continue;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">hasMismatch = true;</span><span class="s2">\n                </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp; !hasWarned) {</span><span class="s2">\n                    </span><span class="s1">warn(`Hydration children mismatch in &lt;${container.tagName.toLowerCase()}&gt;: ` +</span><span class="s2">\n                        </span><span class="s1">`server rendered element contains fewer child nodes than client vdom.`);</span><span class="s2">\n                    </span><span class="s1">hasWarned = true;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">// the SSRed DOM didn't contain enough nodes. Mount the missing ones.</span><span class="s2">\n                </span><span class="s1">patch(null, vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return node;</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">const hydrateFragment = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) =&gt; {</span><span class="s2">\n        </span><span class="s1">const { slotScopeIds: fragmentSlotScopeIds } = vnode;</span><span class="s2">\n        </span><span class="s1">if (fragmentSlotScopeIds) {</span><span class="s2">\n            </span><span class="s1">slotScopeIds = slotScopeIds</span><span class="s2">\n                </span><span class="s1">? slotScopeIds.concat(fragmentSlotScopeIds)</span><span class="s2">\n                </span><span class="s1">: fragmentSlotScopeIds;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">const container = parentNode(node);</span><span class="s2">\n        </span><span class="s1">const next = hydrateChildren(nextSibling(node), vnode, container, parentComponent, parentSuspense, slotScopeIds, optimized);</span><span class="s2">\n        </span><span class="s1">if (next &amp;&amp; isComment(next) &amp;&amp; next.data === ']') {</span><span class="s2">\n            </span><span class="s1">return nextSibling((vnode.anchor = next));</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">// fragment didn't hydrate successfully, since we didn't get a end anchor</span><span class="s2">\n            </span><span class="s1">// back. This should have led to node/children mismatch warnings.</span><span class="s2">\n            </span><span class="s1">hasMismatch = true;</span><span class="s2">\n            </span><span class="s1">// since the anchor is missing, we need to create one and insert it</span><span class="s2">\n            </span><span class="s1">insert((vnode.anchor = createComment(`]`)), container, next);</span><span class="s2">\n            </span><span class="s1">return next;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">const handleMismatch = (node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) =&gt; {</span><span class="s2">\n        </span><span class="s1">hasMismatch = true;</span><span class="s2">\n        </span><span class="s1">(process.env.NODE_ENV !== 'production') &amp;&amp;</span><span class="s2">\n            </span><span class="s1">warn(`Hydration node mismatch:</span><span class="s2">\\</span><span class="s1">n- Client vnode:`, vnode.type, `</span><span class="s2">\\</span><span class="s1">n- Server rendered DOM:`, node, node.nodeType === 3 /* DOMNodeTypes.TEXT */</span><span class="s2">\n                </span><span class="s1">? `(text)`</span><span class="s2">\n                </span><span class="s1">: isComment(node) &amp;&amp; node.data === '['</span><span class="s2">\n                    </span><span class="s1">? `(start of fragment)`</span><span class="s2">\n                    </span><span class="s1">: ``);</span><span class="s2">\n        </span><span class="s1">vnode.el = null;</span><span class="s2">\n        </span><span class="s1">if (isFragment) {</span><span class="s2">\n            </span><span class="s1">// remove excessive fragment nodes</span><span class="s2">\n            </span><span class="s1">const end = locateClosingAsyncAnchor(node);</span><span class="s2">\n            </span><span class="s1">while (true) {</span><span class="s2">\n                </span><span class="s1">const next = nextSibling(node);</span><span class="s2">\n                </span><span class="s1">if (next &amp;&amp; next !== end) {</span><span class="s2">\n                    </span><span class="s1">remove(next);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else {</span><span class="s2">\n                    </span><span class="s1">break;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">const next = nextSibling(node);</span><span class="s2">\n        </span><span class="s1">const container = parentNode(node);</span><span class="s2">\n        </span><span class="s1">remove(node);</span><span class="s2">\n        </span><span class="s1">patch(null, vnode, container, next, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);</span><span class="s2">\n        </span><span class="s1">return next;</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">const locateClosingAsyncAnchor = (node) =&gt; {</span><span class="s2">\n        </span><span class="s1">let match = 0;</span><span class="s2">\n        </span><span class="s1">while (node) {</span><span class="s2">\n            </span><span class="s1">node = nextSibling(node);</span><span class="s2">\n            </span><span class="s1">if (node &amp;&amp; isComment(node)) {</span><span class="s2">\n                </span><span class="s1">if (node.data === '[')</span><span class="s2">\n                    </span><span class="s1">match++;</span><span class="s2">\n                </span><span class="s1">if (node.data === ']') {</span><span class="s2">\n                    </span><span class="s1">if (match === 0) {</span><span class="s2">\n                        </span><span class="s1">return nextSibling(node);</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">else {</span><span class="s2">\n                        </span><span class="s1">match--;</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return node;</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">return [hydrate, hydrateNode];</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/* eslint-disable no-restricted-globals */</span><span class="s2">\n</span><span class="s1">let supported;</span><span class="s2">\n</span><span class="s1">let perf;</span><span class="s2">\n</span><span class="s1">function startMeasure(instance, type) {</span><span class="s2">\n    </span><span class="s1">if (instance.appContext.config.performance &amp;&amp; isSupported()) {</span><span class="s2">\n        </span><span class="s1">perf.mark(`vue-${type}-${instance.uid}`);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if ((process.env.NODE_ENV !== 'production') || __VUE_PROD_DEVTOOLS__) {</span><span class="s2">\n        </span><span class="s1">devtoolsPerfStart(instance, type, isSupported() ? perf.now() : Date.now());</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function endMeasure(instance, type) {</span><span class="s2">\n    </span><span class="s1">if (instance.appContext.config.performance &amp;&amp; isSupported()) {</span><span class="s2">\n        </span><span class="s1">const startTag = `vue-${type}-${instance.uid}`;</span><span class="s2">\n        </span><span class="s1">const endTag = startTag + `:end`;</span><span class="s2">\n        </span><span class="s1">perf.mark(endTag);</span><span class="s2">\n        </span><span class="s1">perf.measure(`&lt;${formatComponentName(instance, instance.type)}&gt; ${type}`, startTag, endTag);</span><span class="s2">\n        </span><span class="s1">perf.clearMarks(startTag);</span><span class="s2">\n        </span><span class="s1">perf.clearMarks(endTag);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if ((process.env.NODE_ENV !== 'production') || __VUE_PROD_DEVTOOLS__) {</span><span class="s2">\n        </span><span class="s1">devtoolsPerfEnd(instance, type, isSupported() ? perf.now() : Date.now());</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isSupported() {</span><span class="s2">\n    </span><span class="s1">if (supported !== undefined) {</span><span class="s2">\n        </span><span class="s1">return supported;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (typeof window !== 'undefined' &amp;&amp; window.performance) {</span><span class="s2">\n        </span><span class="s1">supported = true;</span><span class="s2">\n        </span><span class="s1">perf = window.performance;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">supported = false;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return supported;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* This is only called in esm-bundler builds.</span><span class="s2">\n </span><span class="s1">* It is called when a renderer is created, in `baseCreateRenderer` so that</span><span class="s2">\n </span><span class="s1">* importing runtime-core is side-effects free.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* istanbul-ignore-next</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function initFeatureFlags() {</span><span class="s2">\n    </span><span class="s1">const needWarn = [];</span><span class="s2">\n    </span><span class="s1">if (typeof __VUE_OPTIONS_API__ !== 'boolean') {</span><span class="s2">\n        </span><span class="s1">(process.env.NODE_ENV !== 'production') &amp;&amp; needWarn.push(`__VUE_OPTIONS_API__`);</span><span class="s2">\n        </span><span class="s1">getGlobalThis().__VUE_OPTIONS_API__ = true;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (typeof __VUE_PROD_DEVTOOLS__ !== 'boolean') {</span><span class="s2">\n        </span><span class="s1">(process.env.NODE_ENV !== 'production') &amp;&amp; needWarn.push(`__VUE_PROD_DEVTOOLS__`);</span><span class="s2">\n        </span><span class="s1">getGlobalThis().__VUE_PROD_DEVTOOLS__ = false;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp; needWarn.length) {</span><span class="s2">\n        </span><span class="s1">const multi = needWarn.length &gt; 1;</span><span class="s2">\n        </span><span class="s1">console.warn(`Feature flag${multi ? `s` : ``} ${needWarn.join(', ')} ${multi ? `are` : `is`} not explicitly defined. You are running the esm-bundler build of Vue, ` +</span><span class="s2">\n            </span><span class="s1">`which expects these compile-time feature flags to be globally injected ` +</span><span class="s2">\n            </span><span class="s1">`via the bundler config in order to get better tree-shaking in the ` +</span><span class="s2">\n            </span><span class="s1">`production bundle.</span><span class="s2">\\</span><span class="s1">n</span><span class="s2">\\</span><span class="s1">n` +</span><span class="s2">\n            </span><span class="s1">`For more details, see https://link.vuejs.org/feature-flags.`);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">const queuePostRenderEffect = queueEffectWithSuspense</span><span class="s2">\n    </span><span class="s1">;</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* The createRenderer function accepts two generic arguments:</span><span class="s2">\n </span><span class="s1">* HostNode and HostElement, corresponding to Node and Element types in the</span><span class="s2">\n </span><span class="s1">* host environment. For example, for runtime-dom, HostNode would be the DOM</span><span class="s2">\n </span><span class="s1">* `Node` interface and HostElement would be the DOM `Element` interface.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* Custom renderers can pass in the platform specific types like this:</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* ``` js</span><span class="s2">\n </span><span class="s1">* const { render, createApp } = createRenderer&lt;Node, Element&gt;({</span><span class="s2">\n </span><span class="s1">*   patchProp,</span><span class="s2">\n </span><span class="s1">*   ...nodeOps</span><span class="s2">\n </span><span class="s1">* })</span><span class="s2">\n </span><span class="s1">* ```</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function createRenderer(options) {</span><span class="s2">\n    </span><span class="s1">return baseCreateRenderer(options);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// Separate API for creating hydration-enabled renderer.</span><span class="s2">\n</span><span class="s1">// Hydration logic is only used when calling this function, making it</span><span class="s2">\n</span><span class="s1">// tree-shakable.</span><span class="s2">\n</span><span class="s1">function createHydrationRenderer(options) {</span><span class="s2">\n    </span><span class="s1">return baseCreateRenderer(options, createHydrationFunctions);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// implementation</span><span class="s2">\n</span><span class="s1">function baseCreateRenderer(options, createHydrationFns) {</span><span class="s2">\n    </span><span class="s1">// compile-time feature flags check</span><span class="s2">\n    </span><span class="s1">{</span><span class="s2">\n        </span><span class="s1">initFeatureFlags();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">const target = getGlobalThis();</span><span class="s2">\n    </span><span class="s1">target.__VUE__ = true;</span><span class="s2">\n    </span><span class="s1">if ((process.env.NODE_ENV !== 'production') || __VUE_PROD_DEVTOOLS__) {</span><span class="s2">\n        </span><span class="s1">setDevtoolsHook(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">const { insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, setScopeId: hostSetScopeId = NOOP, insertStaticContent: hostInsertStaticContent } = options;</span><span class="s2">\n    </span><span class="s1">// Note: functions inside this closure should use `const xxx = () =&gt; {}`</span><span class="s2">\n    </span><span class="s1">// style in order to prevent being inlined by minifiers.</span><span class="s2">\n    </span><span class="s1">const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = (process.env.NODE_ENV !== 'production') &amp;&amp; isHmrUpdating ? false : !!n2.dynamicChildren) =&gt; {</span><span class="s2">\n        </span><span class="s1">if (n1 === n2) {</span><span class="s2">\n            </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// patching &amp; not same type, unmount old tree</span><span class="s2">\n        </span><span class="s1">if (n1 &amp;&amp; !isSameVNodeType(n1, n2)) {</span><span class="s2">\n            </span><span class="s1">anchor = getNextHostNode(n1);</span><span class="s2">\n            </span><span class="s1">unmount(n1, parentComponent, parentSuspense, true);</span><span class="s2">\n            </span><span class="s1">n1 = null;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (n2.patchFlag === -2 /* PatchFlags.BAIL */) {</span><span class="s2">\n            </span><span class="s1">optimized = false;</span><span class="s2">\n            </span><span class="s1">n2.dynamicChildren = null;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">const { type, ref, shapeFlag } = n2;</span><span class="s2">\n        </span><span class="s1">switch (type) {</span><span class="s2">\n            </span><span class="s1">case Text:</span><span class="s2">\n                </span><span class="s1">processText(n1, n2, container, anchor);</span><span class="s2">\n                </span><span class="s1">break;</span><span class="s2">\n            </span><span class="s1">case Comment:</span><span class="s2">\n                </span><span class="s1">processCommentNode(n1, n2, container, anchor);</span><span class="s2">\n                </span><span class="s1">break;</span><span class="s2">\n            </span><span class="s1">case Static:</span><span class="s2">\n                </span><span class="s1">if (n1 == null) {</span><span class="s2">\n                    </span><span class="s1">mountStaticNode(n2, container, anchor, isSVG);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n                    </span><span class="s1">patchStaticNode(n1, n2, container, isSVG);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">break;</span><span class="s2">\n            </span><span class="s1">case Fragment:</span><span class="s2">\n                </span><span class="s1">processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);</span><span class="s2">\n                </span><span class="s1">break;</span><span class="s2">\n            </span><span class="s1">default:</span><span class="s2">\n                </span><span class="s1">if (shapeFlag &amp; 1 /* ShapeFlags.ELEMENT */) {</span><span class="s2">\n                    </span><span class="s1">processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else if (shapeFlag &amp; 6 /* ShapeFlags.COMPONENT */) {</span><span class="s2">\n                    </span><span class="s1">processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else if (shapeFlag &amp; 64 /* ShapeFlags.TELEPORT */) {</span><span class="s2">\n                    </span><span class="s1">type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else if (shapeFlag &amp; 128 /* ShapeFlags.SUSPENSE */) {</span><span class="s2">\n                    </span><span class="s1">type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n                    </span><span class="s1">warn('Invalid VNode type:', type, `(${typeof type})`);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// set ref</span><span class="s2">\n        </span><span class="s1">if (ref != null &amp;&amp; parentComponent) {</span><span class="s2">\n            </span><span class="s1">setRef(ref, n1 &amp;&amp; n1.ref, parentSuspense, n2 || n1, !n2);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">const processText = (n1, n2, container, anchor) =&gt; {</span><span class="s2">\n        </span><span class="s1">if (n1 == null) {</span><span class="s2">\n            </span><span class="s1">hostInsert((n2.el = hostCreateText(n2.children)), container, anchor);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">const el = (n2.el = n1.el);</span><span class="s2">\n            </span><span class="s1">if (n2.children !== n1.children) {</span><span class="s2">\n                </span><span class="s1">hostSetText(el, n2.children);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">const processCommentNode = (n1, n2, container, anchor) =&gt; {</span><span class="s2">\n        </span><span class="s1">if (n1 == null) {</span><span class="s2">\n            </span><span class="s1">hostInsert((n2.el = hostCreateComment(n2.children || '')), container, anchor);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">// there's no support for dynamic comments</span><span class="s2">\n            </span><span class="s1">n2.el = n1.el;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">const mountStaticNode = (n2, container, anchor, isSVG) =&gt; {</span><span class="s2">\n        </span><span class="s1">[n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG, n2.el, n2.anchor);</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">/**</span><span class="s2">\n     </span><span class="s1">* Dev / HMR only</span><span class="s2">\n     </span><span class="s1">*/</span><span class="s2">\n    </span><span class="s1">const patchStaticNode = (n1, n2, container, isSVG) =&gt; {</span><span class="s2">\n        </span><span class="s1">// static nodes are only patched during dev for HMR</span><span class="s2">\n        </span><span class="s1">if (n2.children !== n1.children) {</span><span class="s2">\n            </span><span class="s1">const anchor = hostNextSibling(n1.anchor);</span><span class="s2">\n            </span><span class="s1">// remove existing</span><span class="s2">\n            </span><span class="s1">removeStaticNode(n1);</span><span class="s2">\n            </span><span class="s1">[n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">n2.el = n1.el;</span><span class="s2">\n            </span><span class="s1">n2.anchor = n1.anchor;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">const moveStaticNode = ({ el, anchor }, container, nextSibling) =&gt; {</span><span class="s2">\n        </span><span class="s1">let next;</span><span class="s2">\n        </span><span class="s1">while (el &amp;&amp; el !== anchor) {</span><span class="s2">\n            </span><span class="s1">next = hostNextSibling(el);</span><span class="s2">\n            </span><span class="s1">hostInsert(el, container, nextSibling);</span><span class="s2">\n            </span><span class="s1">el = next;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">hostInsert(anchor, container, nextSibling);</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">const removeStaticNode = ({ el, anchor }) =&gt; {</span><span class="s2">\n        </span><span class="s1">let next;</span><span class="s2">\n        </span><span class="s1">while (el &amp;&amp; el !== anchor) {</span><span class="s2">\n            </span><span class="s1">next = hostNextSibling(el);</span><span class="s2">\n            </span><span class="s1">hostRemove(el);</span><span class="s2">\n            </span><span class="s1">el = next;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">hostRemove(anchor);</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) =&gt; {</span><span class="s2">\n        </span><span class="s1">isSVG = isSVG || n2.type === 'svg';</span><span class="s2">\n        </span><span class="s1">if (n1 == null) {</span><span class="s2">\n            </span><span class="s1">mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">patchElement(n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) =&gt; {</span><span class="s2">\n        </span><span class="s1">let el;</span><span class="s2">\n        </span><span class="s1">let vnodeHook;</span><span class="s2">\n        </span><span class="s1">const { type, props, shapeFlag, transition, dirs } = vnode;</span><span class="s2">\n        </span><span class="s1">el = vnode.el = hostCreateElement(vnode.type, isSVG, props &amp;&amp; props.is, props);</span><span class="s2">\n        </span><span class="s1">// mount children first, since some props may rely on child content</span><span class="s2">\n        </span><span class="s1">// being already rendered, e.g. `&lt;select value&gt;`</span><span class="s2">\n        </span><span class="s1">if (shapeFlag &amp; 8 /* ShapeFlags.TEXT_CHILDREN */) {</span><span class="s2">\n            </span><span class="s1">hostSetElementText(el, vnode.children);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (shapeFlag &amp; 16 /* ShapeFlags.ARRAY_CHILDREN */) {</span><span class="s2">\n            </span><span class="s1">mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG &amp;&amp; type !== 'foreignObject', slotScopeIds, optimized);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (dirs) {</span><span class="s2">\n            </span><span class="s1">invokeDirectiveHook(vnode, null, parentComponent, 'created');</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// scopeId</span><span class="s2">\n        </span><span class="s1">setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);</span><span class="s2">\n        </span><span class="s1">// props</span><span class="s2">\n        </span><span class="s1">if (props) {</span><span class="s2">\n            </span><span class="s1">for (const key in props) {</span><span class="s2">\n                </span><span class="s1">if (key !== 'value' &amp;&amp; !isReservedProp(key)) {</span><span class="s2">\n                    </span><span class="s1">hostPatchProp(el, key, null, props[key], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">/**</span><span class="s2">\n             </span><span class="s1">* Special case for setting value on DOM elements:</span><span class="s2">\n             </span><span class="s1">* - it can be order-sensitive (e.g. should be set *after* min/max, #2325, #4024)</span><span class="s2">\n             </span><span class="s1">* - it needs to be forced (#1471)</span><span class="s2">\n             </span><span class="s1">* #2353 proposes adding another renderer option to configure this, but</span><span class="s2">\n             </span><span class="s1">* the properties affects are so finite it is worth special casing it</span><span class="s2">\n             </span><span class="s1">* here to reduce the complexity. (Special casing it also should not</span><span class="s2">\n             </span><span class="s1">* affect non-DOM renderers)</span><span class="s2">\n             </span><span class="s1">*/</span><span class="s2">\n            </span><span class="s1">if ('value' in props) {</span><span class="s2">\n                </span><span class="s1">hostPatchProp(el, 'value', null, props.value);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">if ((vnodeHook = props.onVnodeBeforeMount)) {</span><span class="s2">\n                </span><span class="s1">invokeVNodeHook(vnodeHook, parentComponent, vnode);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if ((process.env.NODE_ENV !== 'production') || __VUE_PROD_DEVTOOLS__) {</span><span class="s2">\n            </span><span class="s1">Object.defineProperty(el, '__vnode', {</span><span class="s2">\n                </span><span class="s1">value: vnode,</span><span class="s2">\n                </span><span class="s1">enumerable: false</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n            </span><span class="s1">Object.defineProperty(el, '__vueParentComponent', {</span><span class="s2">\n                </span><span class="s1">value: parentComponent,</span><span class="s2">\n                </span><span class="s1">enumerable: false</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (dirs) {</span><span class="s2">\n            </span><span class="s1">invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount');</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// #1583 For inside suspense + suspense not resolved case, enter hook should call when suspense resolved</span><span class="s2">\n        </span><span class="s1">// #1689 For inside suspense + suspense resolved case, just call it</span><span class="s2">\n        </span><span class="s1">const needCallTransitionHooks = (!parentSuspense || (parentSuspense &amp;&amp; !parentSuspense.pendingBranch)) &amp;&amp;</span><span class="s2">\n            </span><span class="s1">transition &amp;&amp;</span><span class="s2">\n            </span><span class="s1">!transition.persisted;</span><span class="s2">\n        </span><span class="s1">if (needCallTransitionHooks) {</span><span class="s2">\n            </span><span class="s1">transition.beforeEnter(el);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">hostInsert(el, container, anchor);</span><span class="s2">\n        </span><span class="s1">if ((vnodeHook = props &amp;&amp; props.onVnodeMounted) ||</span><span class="s2">\n            </span><span class="s1">needCallTransitionHooks ||</span><span class="s2">\n            </span><span class="s1">dirs) {</span><span class="s2">\n            </span><span class="s1">queuePostRenderEffect(() =&gt; {</span><span class="s2">\n                </span><span class="s1">vnodeHook &amp;&amp; invokeVNodeHook(vnodeHook, parentComponent, vnode);</span><span class="s2">\n                </span><span class="s1">needCallTransitionHooks &amp;&amp; transition.enter(el);</span><span class="s2">\n                </span><span class="s1">dirs &amp;&amp; invokeDirectiveHook(vnode, null, parentComponent, 'mounted');</span><span class="s2">\n            </span><span class="s1">}, parentSuspense);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) =&gt; {</span><span class="s2">\n        </span><span class="s1">if (scopeId) {</span><span class="s2">\n            </span><span class="s1">hostSetScopeId(el, scopeId);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (slotScopeIds) {</span><span class="s2">\n            </span><span class="s1">for (let i = 0; i &lt; slotScopeIds.length; i++) {</span><span class="s2">\n                </span><span class="s1">hostSetScopeId(el, slotScopeIds[i]);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (parentComponent) {</span><span class="s2">\n            </span><span class="s1">let subTree = parentComponent.subTree;</span><span class="s2">\n            </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp;</span><span class="s2">\n                </span><span class="s1">subTree.patchFlag &gt; 0 &amp;&amp;</span><span class="s2">\n                </span><span class="s1">subTree.patchFlag &amp; 2048 /* PatchFlags.DEV_ROOT_FRAGMENT */) {</span><span class="s2">\n                </span><span class="s1">subTree =</span><span class="s2">\n                    </span><span class="s1">filterSingleRoot(subTree.children) || subTree;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">if (vnode === subTree) {</span><span class="s2">\n                </span><span class="s1">const parentVNode = parentComponent.vnode;</span><span class="s2">\n                </span><span class="s1">setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0) =&gt; {</span><span class="s2">\n        </span><span class="s1">for (let i = start; i &lt; children.length; i++) {</span><span class="s2">\n            </span><span class="s1">const child = (children[i] = optimized</span><span class="s2">\n                </span><span class="s1">? cloneIfMounted(children[i])</span><span class="s2">\n                </span><span class="s1">: normalizeVNode(children[i]));</span><span class="s2">\n            </span><span class="s1">patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) =&gt; {</span><span class="s2">\n        </span><span class="s1">const el = (n2.el = n1.el);</span><span class="s2">\n        </span><span class="s1">let { patchFlag, dynamicChildren, dirs } = n2;</span><span class="s2">\n        </span><span class="s1">// #1426 take the old vnode's patch flag into account since user may clone a</span><span class="s2">\n        </span><span class="s1">// compiler-generated vnode, which de-opts to FULL_PROPS</span><span class="s2">\n        </span><span class="s1">patchFlag |= n1.patchFlag &amp; 16 /* PatchFlags.FULL_PROPS */;</span><span class="s2">\n        </span><span class="s1">const oldProps = n1.props || EMPTY_OBJ;</span><span class="s2">\n        </span><span class="s1">const newProps = n2.props || EMPTY_OBJ;</span><span class="s2">\n        </span><span class="s1">let vnodeHook;</span><span class="s2">\n        </span><span class="s1">// disable recurse in beforeUpdate hooks</span><span class="s2">\n        </span><span class="s1">parentComponent &amp;&amp; toggleRecurse(parentComponent, false);</span><span class="s2">\n        </span><span class="s1">if ((vnodeHook = newProps.onVnodeBeforeUpdate)) {</span><span class="s2">\n            </span><span class="s1">invokeVNodeHook(vnodeHook, parentComponent, n2, n1);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (dirs) {</span><span class="s2">\n            </span><span class="s1">invokeDirectiveHook(n2, n1, parentComponent, 'beforeUpdate');</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">parentComponent &amp;&amp; toggleRecurse(parentComponent, true);</span><span class="s2">\n        </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp; isHmrUpdating) {</span><span class="s2">\n            </span><span class="s1">// HMR updated, force full diff</span><span class="s2">\n            </span><span class="s1">patchFlag = 0;</span><span class="s2">\n            </span><span class="s1">optimized = false;</span><span class="s2">\n            </span><span class="s1">dynamicChildren = null;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">const areChildrenSVG = isSVG &amp;&amp; n2.type !== 'foreignObject';</span><span class="s2">\n        </span><span class="s1">if (dynamicChildren) {</span><span class="s2">\n            </span><span class="s1">patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);</span><span class="s2">\n            </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp; parentComponent &amp;&amp; parentComponent.type.__hmrId) {</span><span class="s2">\n                </span><span class="s1">traverseStaticChildren(n1, n2);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (!optimized) {</span><span class="s2">\n            </span><span class="s1">// full diff</span><span class="s2">\n            </span><span class="s1">patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (patchFlag &gt; 0) {</span><span class="s2">\n            </span><span class="s1">// the presence of a patchFlag means this element's render code was</span><span class="s2">\n            </span><span class="s1">// generated by the compiler and can take the fast path.</span><span class="s2">\n            </span><span class="s1">// in this path old node and new node are guaranteed to have the same shape</span><span class="s2">\n            </span><span class="s1">// (i.e. at the exact same position in the source template)</span><span class="s2">\n            </span><span class="s1">if (patchFlag &amp; 16 /* PatchFlags.FULL_PROPS */) {</span><span class="s2">\n                </span><span class="s1">// element props contain dynamic keys, full diff needed</span><span class="s2">\n                </span><span class="s1">patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">// class</span><span class="s2">\n                </span><span class="s1">// this flag is matched when the element has dynamic class bindings.</span><span class="s2">\n                </span><span class="s1">if (patchFlag &amp; 2 /* PatchFlags.CLASS */) {</span><span class="s2">\n                    </span><span class="s1">if (oldProps.class !== newProps.class) {</span><span class="s2">\n                        </span><span class="s1">hostPatchProp(el, 'class', null, newProps.class, isSVG);</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">// style</span><span class="s2">\n                </span><span class="s1">// this flag is matched when the element has dynamic style bindings</span><span class="s2">\n                </span><span class="s1">if (patchFlag &amp; 4 /* PatchFlags.STYLE */) {</span><span class="s2">\n                    </span><span class="s1">hostPatchProp(el, 'style', oldProps.style, newProps.style, isSVG);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">// props</span><span class="s2">\n                </span><span class="s1">// This flag is matched when the element has dynamic prop/attr bindings</span><span class="s2">\n                </span><span class="s1">// other than class and style. The keys of dynamic prop/attrs are saved for</span><span class="s2">\n                </span><span class="s1">// faster iteration.</span><span class="s2">\n                </span><span class="s1">// Note dynamic keys like :[foo]=</span><span class="s2">\&quot;</span><span class="s1">bar</span><span class="s2">\&quot; </span><span class="s1">will cause this optimization to</span><span class="s2">\n                </span><span class="s1">// bail out and go through a full diff because we need to unset the old key</span><span class="s2">\n                </span><span class="s1">if (patchFlag &amp; 8 /* PatchFlags.PROPS */) {</span><span class="s2">\n                    </span><span class="s1">// if the flag is present then dynamicProps must be non-null</span><span class="s2">\n                    </span><span class="s1">const propsToUpdate = n2.dynamicProps;</span><span class="s2">\n                    </span><span class="s1">for (let i = 0; i &lt; propsToUpdate.length; i++) {</span><span class="s2">\n                        </span><span class="s1">const key = propsToUpdate[i];</span><span class="s2">\n                        </span><span class="s1">const prev = oldProps[key];</span><span class="s2">\n                        </span><span class="s1">const next = newProps[key];</span><span class="s2">\n                        </span><span class="s1">// #1471 force patch value</span><span class="s2">\n                        </span><span class="s1">if (next !== prev || key === 'value') {</span><span class="s2">\n                            </span><span class="s1">hostPatchProp(el, key, prev, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);</span><span class="s2">\n                        </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">// text</span><span class="s2">\n            </span><span class="s1">// This flag is matched when the element has only dynamic text children.</span><span class="s2">\n            </span><span class="s1">if (patchFlag &amp; 1 /* PatchFlags.TEXT */) {</span><span class="s2">\n                </span><span class="s1">if (n1.children !== n2.children) {</span><span class="s2">\n                    </span><span class="s1">hostSetElementText(el, n2.children);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (!optimized &amp;&amp; dynamicChildren == null) {</span><span class="s2">\n            </span><span class="s1">// unoptimized, full diff</span><span class="s2">\n            </span><span class="s1">patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {</span><span class="s2">\n            </span><span class="s1">queuePostRenderEffect(() =&gt; {</span><span class="s2">\n                </span><span class="s1">vnodeHook &amp;&amp; invokeVNodeHook(vnodeHook, parentComponent, n2, n1);</span><span class="s2">\n                </span><span class="s1">dirs &amp;&amp; invokeDirectiveHook(n2, n1, parentComponent, 'updated');</span><span class="s2">\n            </span><span class="s1">}, parentSuspense);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">// The fast path for blocks.</span><span class="s2">\n    </span><span class="s1">const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) =&gt; {</span><span class="s2">\n        </span><span class="s1">for (let i = 0; i &lt; newChildren.length; i++) {</span><span class="s2">\n            </span><span class="s1">const oldVNode = oldChildren[i];</span><span class="s2">\n            </span><span class="s1">const newVNode = newChildren[i];</span><span class="s2">\n            </span><span class="s1">// Determine the container (parent element) for the patch.</span><span class="s2">\n            </span><span class="s1">const container = </span><span class="s2">\n            </span><span class="s1">// oldVNode may be an errored async setup() component inside Suspense</span><span class="s2">\n            </span><span class="s1">// which will not have a mounted element</span><span class="s2">\n            </span><span class="s1">oldVNode.el &amp;&amp;</span><span class="s2">\n                </span><span class="s1">// - In the case of a Fragment, we need to provide the actual parent</span><span class="s2">\n                </span><span class="s1">// of the Fragment itself so it can move its children.</span><span class="s2">\n                </span><span class="s1">(oldVNode.type === Fragment ||</span><span class="s2">\n                    </span><span class="s1">// - In the case of different nodes, there is going to be a replacement</span><span class="s2">\n                    </span><span class="s1">// which also requires the correct parent container</span><span class="s2">\n                    </span><span class="s1">!isSameVNodeType(oldVNode, newVNode) ||</span><span class="s2">\n                    </span><span class="s1">// - In the case of a component, it could contain anything.</span><span class="s2">\n                    </span><span class="s1">oldVNode.shapeFlag &amp; (6 /* ShapeFlags.COMPONENT */ | 64 /* ShapeFlags.TELEPORT */))</span><span class="s2">\n                </span><span class="s1">? hostParentNode(oldVNode.el)</span><span class="s2">\n                </span><span class="s1">: // In other cases, the parent container is not actually used so we</span><span class="s2">\n                    </span><span class="s1">// just pass the block element here to avoid a DOM parentNode call.</span><span class="s2">\n                    </span><span class="s1">fallbackContainer;</span><span class="s2">\n            </span><span class="s1">patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, true);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) =&gt; {</span><span class="s2">\n        </span><span class="s1">if (oldProps !== newProps) {</span><span class="s2">\n            </span><span class="s1">if (oldProps !== EMPTY_OBJ) {</span><span class="s2">\n                </span><span class="s1">for (const key in oldProps) {</span><span class="s2">\n                    </span><span class="s1">if (!isReservedProp(key) &amp;&amp; !(key in newProps)) {</span><span class="s2">\n                        </span><span class="s1">hostPatchProp(el, key, oldProps[key], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">for (const key in newProps) {</span><span class="s2">\n                </span><span class="s1">// empty string is not valid prop</span><span class="s2">\n                </span><span class="s1">if (isReservedProp(key))</span><span class="s2">\n                    </span><span class="s1">continue;</span><span class="s2">\n                </span><span class="s1">const next = newProps[key];</span><span class="s2">\n                </span><span class="s1">const prev = oldProps[key];</span><span class="s2">\n                </span><span class="s1">// defer patching value</span><span class="s2">\n                </span><span class="s1">if (next !== prev &amp;&amp; key !== 'value') {</span><span class="s2">\n                    </span><span class="s1">hostPatchProp(el, key, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">if ('value' in newProps) {</span><span class="s2">\n                </span><span class="s1">hostPatchProp(el, 'value', oldProps.value, newProps.value);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) =&gt; {</span><span class="s2">\n        </span><span class="s1">const fragmentStartAnchor = (n2.el = n1 ? n1.el : hostCreateText(''));</span><span class="s2">\n        </span><span class="s1">const fragmentEndAnchor = (n2.anchor = n1 ? n1.anchor : hostCreateText(''));</span><span class="s2">\n        </span><span class="s1">let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;</span><span class="s2">\n        </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp;</span><span class="s2">\n            </span><span class="s1">// #5523 dev root fragment may inherit directives</span><span class="s2">\n            </span><span class="s1">(isHmrUpdating || patchFlag &amp; 2048 /* PatchFlags.DEV_ROOT_FRAGMENT */)) {</span><span class="s2">\n            </span><span class="s1">// HMR updated / Dev root fragment (w/ comments), force full diff</span><span class="s2">\n            </span><span class="s1">patchFlag = 0;</span><span class="s2">\n            </span><span class="s1">optimized = false;</span><span class="s2">\n            </span><span class="s1">dynamicChildren = null;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// check if this is a slot fragment with :slotted scope ids</span><span class="s2">\n        </span><span class="s1">if (fragmentSlotScopeIds) {</span><span class="s2">\n            </span><span class="s1">slotScopeIds = slotScopeIds</span><span class="s2">\n                </span><span class="s1">? slotScopeIds.concat(fragmentSlotScopeIds)</span><span class="s2">\n                </span><span class="s1">: fragmentSlotScopeIds;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (n1 == null) {</span><span class="s2">\n            </span><span class="s1">hostInsert(fragmentStartAnchor, container, anchor);</span><span class="s2">\n            </span><span class="s1">hostInsert(fragmentEndAnchor, container, anchor);</span><span class="s2">\n            </span><span class="s1">// a fragment can only have array children</span><span class="s2">\n            </span><span class="s1">// since they are either generated by the compiler, or implicitly created</span><span class="s2">\n            </span><span class="s1">// from arrays.</span><span class="s2">\n            </span><span class="s1">mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">if (patchFlag &gt; 0 &amp;&amp;</span><span class="s2">\n                </span><span class="s1">patchFlag &amp; 64 /* PatchFlags.STABLE_FRAGMENT */ &amp;&amp;</span><span class="s2">\n                </span><span class="s1">dynamicChildren &amp;&amp;</span><span class="s2">\n                </span><span class="s1">// #2715 the previous fragment could've been a BAILed one as a result</span><span class="s2">\n                </span><span class="s1">// of renderSlot() with no valid children</span><span class="s2">\n                </span><span class="s1">n1.dynamicChildren) {</span><span class="s2">\n                </span><span class="s1">// a stable fragment (template root or &lt;template v-for&gt;) doesn't need to</span><span class="s2">\n                </span><span class="s1">// patch children order, but it may contain dynamicChildren.</span><span class="s2">\n                </span><span class="s1">patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG, slotScopeIds);</span><span class="s2">\n                </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp; parentComponent &amp;&amp; parentComponent.type.__hmrId) {</span><span class="s2">\n                    </span><span class="s1">traverseStaticChildren(n1, n2);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else if (</span><span class="s2">\n                </span><span class="s1">// #2080 if the stable fragment has a key, it's a &lt;template v-for&gt; that may</span><span class="s2">\n                </span><span class="s1">//  get moved around. Make sure all root level vnodes inherit el.</span><span class="s2">\n                </span><span class="s1">// #2134 or if it's a component root, it may also get moved around</span><span class="s2">\n                </span><span class="s1">// as the component is being moved.</span><span class="s2">\n                </span><span class="s1">n2.key != null ||</span><span class="s2">\n                    </span><span class="s1">(parentComponent &amp;&amp; n2 === parentComponent.subTree)) {</span><span class="s2">\n                    </span><span class="s1">traverseStaticChildren(n1, n2, true /* shallow */);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">// keyed / unkeyed, or manual fragments.</span><span class="s2">\n                </span><span class="s1">// for keyed &amp; unkeyed, since they are compiler generated from v-for,</span><span class="s2">\n                </span><span class="s1">// each child is guaranteed to be a block so the fragment will never</span><span class="s2">\n                </span><span class="s1">// have dynamicChildren.</span><span class="s2">\n                </span><span class="s1">patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) =&gt; {</span><span class="s2">\n        </span><span class="s1">n2.slotScopeIds = slotScopeIds;</span><span class="s2">\n        </span><span class="s1">if (n1 == null) {</span><span class="s2">\n            </span><span class="s1">if (n2.shapeFlag &amp; 512 /* ShapeFlags.COMPONENT_KEPT_ALIVE */) {</span><span class="s2">\n                </span><span class="s1">parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">updateComponent(n1, n2, optimized);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) =&gt; {</span><span class="s2">\n        </span><span class="s1">const instance = (initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense));</span><span class="s2">\n        </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp; instance.type.__hmrId) {</span><span class="s2">\n            </span><span class="s1">registerHMR(instance);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n            </span><span class="s1">pushWarningContext(initialVNode);</span><span class="s2">\n            </span><span class="s1">startMeasure(instance, `mount`);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// inject renderer internals for keepAlive</span><span class="s2">\n        </span><span class="s1">if (isKeepAlive(initialVNode)) {</span><span class="s2">\n            </span><span class="s1">instance.ctx.renderer = internals;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// resolve props and slots for setup context</span><span class="s2">\n        </span><span class="s1">{</span><span class="s2">\n            </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n                </span><span class="s1">startMeasure(instance, `init`);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">setupComponent(instance);</span><span class="s2">\n            </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n                </span><span class="s1">endMeasure(instance, `init`);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// setup() is async. This component relies on async logic to be resolved</span><span class="s2">\n        </span><span class="s1">// before proceeding</span><span class="s2">\n        </span><span class="s1">if (instance.asyncDep) {</span><span class="s2">\n            </span><span class="s1">parentSuspense &amp;&amp; parentSuspense.registerDep(instance, setupRenderEffect);</span><span class="s2">\n            </span><span class="s1">// Give it a placeholder if this is not hydration</span><span class="s2">\n            </span><span class="s1">// TODO handle self-defined fallback</span><span class="s2">\n            </span><span class="s1">if (!initialVNode.el) {</span><span class="s2">\n                </span><span class="s1">const placeholder = (instance.subTree = createVNode(Comment));</span><span class="s2">\n                </span><span class="s1">processCommentNode(null, placeholder, container, anchor);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);</span><span class="s2">\n        </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n            </span><span class="s1">popWarningContext();</span><span class="s2">\n            </span><span class="s1">endMeasure(instance, `mount`);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">const updateComponent = (n1, n2, optimized) =&gt; {</span><span class="s2">\n        </span><span class="s1">const instance = (n2.component = n1.component);</span><span class="s2">\n        </span><span class="s1">if (shouldUpdateComponent(n1, n2, optimized)) {</span><span class="s2">\n            </span><span class="s1">if (instance.asyncDep &amp;&amp;</span><span class="s2">\n                </span><span class="s1">!instance.asyncResolved) {</span><span class="s2">\n                </span><span class="s1">// async &amp; still pending - just update props and slots</span><span class="s2">\n                </span><span class="s1">// since the component's reactive effect for render isn't set-up yet</span><span class="s2">\n                </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n                    </span><span class="s1">pushWarningContext(n2);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">updateComponentPreRender(instance, n2, optimized);</span><span class="s2">\n                </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n                    </span><span class="s1">popWarningContext();</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">return;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">// normal update</span><span class="s2">\n                </span><span class="s1">instance.next = n2;</span><span class="s2">\n                </span><span class="s1">// in case the child component is also queued, remove it to avoid</span><span class="s2">\n                </span><span class="s1">// double updating the same child component in the same flush.</span><span class="s2">\n                </span><span class="s1">invalidateJob(instance.update);</span><span class="s2">\n                </span><span class="s1">// instance.update is the reactive effect.</span><span class="s2">\n                </span><span class="s1">instance.update();</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">// no update needed. just copy over properties</span><span class="s2">\n            </span><span class="s1">n2.el = n1.el;</span><span class="s2">\n            </span><span class="s1">instance.vnode = n2;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) =&gt; {</span><span class="s2">\n        </span><span class="s1">const componentUpdateFn = () =&gt; {</span><span class="s2">\n            </span><span class="s1">if (!instance.isMounted) {</span><span class="s2">\n                </span><span class="s1">let vnodeHook;</span><span class="s2">\n                </span><span class="s1">const { el, props } = initialVNode;</span><span class="s2">\n                </span><span class="s1">const { bm, m, parent } = instance;</span><span class="s2">\n                </span><span class="s1">const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);</span><span class="s2">\n                </span><span class="s1">toggleRecurse(instance, false);</span><span class="s2">\n                </span><span class="s1">// beforeMount hook</span><span class="s2">\n                </span><span class="s1">if (bm) {</span><span class="s2">\n                    </span><span class="s1">invokeArrayFns(bm);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">// onVnodeBeforeMount</span><span class="s2">\n                </span><span class="s1">if (!isAsyncWrapperVNode &amp;&amp;</span><span class="s2">\n                    </span><span class="s1">(vnodeHook = props &amp;&amp; props.onVnodeBeforeMount)) {</span><span class="s2">\n                    </span><span class="s1">invokeVNodeHook(vnodeHook, parent, initialVNode);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">toggleRecurse(instance, true);</span><span class="s2">\n                </span><span class="s1">if (el &amp;&amp; hydrateNode) {</span><span class="s2">\n                    </span><span class="s1">// vnode has adopted host node - perform hydration instead of mount.</span><span class="s2">\n                    </span><span class="s1">const hydrateSubTree = () =&gt; {</span><span class="s2">\n                        </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n                            </span><span class="s1">startMeasure(instance, `render`);</span><span class="s2">\n                        </span><span class="s1">}</span><span class="s2">\n                        </span><span class="s1">instance.subTree = renderComponentRoot(instance);</span><span class="s2">\n                        </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n                            </span><span class="s1">endMeasure(instance, `render`);</span><span class="s2">\n                        </span><span class="s1">}</span><span class="s2">\n                        </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n                            </span><span class="s1">startMeasure(instance, `hydrate`);</span><span class="s2">\n                        </span><span class="s1">}</span><span class="s2">\n                        </span><span class="s1">hydrateNode(el, instance.subTree, instance, parentSuspense, null);</span><span class="s2">\n                        </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n                            </span><span class="s1">endMeasure(instance, `hydrate`);</span><span class="s2">\n                        </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">};</span><span class="s2">\n                    </span><span class="s1">if (isAsyncWrapperVNode) {</span><span class="s2">\n                        </span><span class="s1">initialVNode.type.__asyncLoader().then(</span><span class="s2">\n                        </span><span class="s1">// note: we are moving the render call into an async callback,</span><span class="s2">\n                        </span><span class="s1">// which means it won't track dependencies - but it's ok because</span><span class="s2">\n                        </span><span class="s1">// a server-rendered async wrapper is already in resolved state</span><span class="s2">\n                        </span><span class="s1">// and it will never need to change.</span><span class="s2">\n                        </span><span class="s1">() =&gt; !instance.isUnmounted &amp;&amp; hydrateSubTree());</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">else {</span><span class="s2">\n                        </span><span class="s1">hydrateSubTree();</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else {</span><span class="s2">\n                    </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n                        </span><span class="s1">startMeasure(instance, `render`);</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">const subTree = (instance.subTree = renderComponentRoot(instance));</span><span class="s2">\n                    </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n                        </span><span class="s1">endMeasure(instance, `render`);</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n                        </span><span class="s1">startMeasure(instance, `patch`);</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);</span><span class="s2">\n                    </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n                        </span><span class="s1">endMeasure(instance, `patch`);</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">initialVNode.el = subTree.el;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">// mounted hook</span><span class="s2">\n                </span><span class="s1">if (m) {</span><span class="s2">\n                    </span><span class="s1">queuePostRenderEffect(m, parentSuspense);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">// onVnodeMounted</span><span class="s2">\n                </span><span class="s1">if (!isAsyncWrapperVNode &amp;&amp;</span><span class="s2">\n                    </span><span class="s1">(vnodeHook = props &amp;&amp; props.onVnodeMounted)) {</span><span class="s2">\n                    </span><span class="s1">const scopedInitialVNode = initialVNode;</span><span class="s2">\n                    </span><span class="s1">queuePostRenderEffect(() =&gt; invokeVNodeHook(vnodeHook, parent, scopedInitialVNode), parentSuspense);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">// activated hook for keep-alive roots.</span><span class="s2">\n                </span><span class="s1">// #1742 activated hook must be accessed after first render</span><span class="s2">\n                </span><span class="s1">// since the hook may be injected by a child keep-alive</span><span class="s2">\n                </span><span class="s1">if (initialVNode.shapeFlag &amp; 256 /* ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE */ ||</span><span class="s2">\n                    </span><span class="s1">(parent &amp;&amp;</span><span class="s2">\n                        </span><span class="s1">isAsyncWrapper(parent.vnode) &amp;&amp;</span><span class="s2">\n                        </span><span class="s1">parent.vnode.shapeFlag &amp; 256 /* ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE */)) {</span><span class="s2">\n                    </span><span class="s1">instance.a &amp;&amp; queuePostRenderEffect(instance.a, parentSuspense);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">instance.isMounted = true;</span><span class="s2">\n                </span><span class="s1">if ((process.env.NODE_ENV !== 'production') || __VUE_PROD_DEVTOOLS__) {</span><span class="s2">\n                    </span><span class="s1">devtoolsComponentAdded(instance);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">// #2458: deference mount-only object parameters to prevent memleaks</span><span class="s2">\n                </span><span class="s1">initialVNode = container = anchor = null;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">// updateComponent</span><span class="s2">\n                </span><span class="s1">// This is triggered by mutation of component's own state (next: null)</span><span class="s2">\n                </span><span class="s1">// OR parent calling processComponent (next: VNode)</span><span class="s2">\n                </span><span class="s1">let { next, bu, u, parent, vnode } = instance;</span><span class="s2">\n                </span><span class="s1">let originNext = next;</span><span class="s2">\n                </span><span class="s1">let vnodeHook;</span><span class="s2">\n                </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n                    </span><span class="s1">pushWarningContext(next || instance.vnode);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">// Disallow component effect recursion during pre-lifecycle hooks.</span><span class="s2">\n                </span><span class="s1">toggleRecurse(instance, false);</span><span class="s2">\n                </span><span class="s1">if (next) {</span><span class="s2">\n                    </span><span class="s1">next.el = vnode.el;</span><span class="s2">\n                    </span><span class="s1">updateComponentPreRender(instance, next, optimized);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else {</span><span class="s2">\n                    </span><span class="s1">next = vnode;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">// beforeUpdate hook</span><span class="s2">\n                </span><span class="s1">if (bu) {</span><span class="s2">\n                    </span><span class="s1">invokeArrayFns(bu);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">// onVnodeBeforeUpdate</span><span class="s2">\n                </span><span class="s1">if ((vnodeHook = next.props &amp;&amp; next.props.onVnodeBeforeUpdate)) {</span><span class="s2">\n                    </span><span class="s1">invokeVNodeHook(vnodeHook, parent, next, vnode);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">toggleRecurse(instance, true);</span><span class="s2">\n                </span><span class="s1">// render</span><span class="s2">\n                </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n                    </span><span class="s1">startMeasure(instance, `render`);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">const nextTree = renderComponentRoot(instance);</span><span class="s2">\n                </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n                    </span><span class="s1">endMeasure(instance, `render`);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">const prevTree = instance.subTree;</span><span class="s2">\n                </span><span class="s1">instance.subTree = nextTree;</span><span class="s2">\n                </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n                    </span><span class="s1">startMeasure(instance, `patch`);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">patch(prevTree, nextTree, </span><span class="s2">\n                </span><span class="s1">// parent may have changed if it's in a teleport</span><span class="s2">\n                </span><span class="s1">hostParentNode(prevTree.el), </span><span class="s2">\n                </span><span class="s1">// anchor may have changed if it's in a fragment</span><span class="s2">\n                </span><span class="s1">getNextHostNode(prevTree), instance, parentSuspense, isSVG);</span><span class="s2">\n                </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n                    </span><span class="s1">endMeasure(instance, `patch`);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">next.el = nextTree.el;</span><span class="s2">\n                </span><span class="s1">if (originNext === null) {</span><span class="s2">\n                    </span><span class="s1">// self-triggered update. In case of HOC, update parent component</span><span class="s2">\n                    </span><span class="s1">// vnode el. HOC is indicated by parent instance's subTree pointing</span><span class="s2">\n                    </span><span class="s1">// to child component's vnode</span><span class="s2">\n                    </span><span class="s1">updateHOCHostEl(instance, nextTree.el);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">// updated hook</span><span class="s2">\n                </span><span class="s1">if (u) {</span><span class="s2">\n                    </span><span class="s1">queuePostRenderEffect(u, parentSuspense);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">// onVnodeUpdated</span><span class="s2">\n                </span><span class="s1">if ((vnodeHook = next.props &amp;&amp; next.props.onVnodeUpdated)) {</span><span class="s2">\n                    </span><span class="s1">queuePostRenderEffect(() =&gt; invokeVNodeHook(vnodeHook, parent, next, vnode), parentSuspense);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">if ((process.env.NODE_ENV !== 'production') || __VUE_PROD_DEVTOOLS__) {</span><span class="s2">\n                    </span><span class="s1">devtoolsComponentUpdated(instance);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n                    </span><span class="s1">popWarningContext();</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n        </span><span class="s1">// create reactive effect for rendering</span><span class="s2">\n        </span><span class="s1">const effect = (instance.effect = new ReactiveEffect(componentUpdateFn, () =&gt; queueJob(update), instance.scope // track it in component's effect scope</span><span class="s2">\n        </span><span class="s1">));</span><span class="s2">\n        </span><span class="s1">const update = (instance.update = () =&gt; effect.run());</span><span class="s2">\n        </span><span class="s1">update.id = instance.uid;</span><span class="s2">\n        </span><span class="s1">// allowRecurse</span><span class="s2">\n        </span><span class="s1">// #1801, #2043 component render effects should allow recursive updates</span><span class="s2">\n        </span><span class="s1">toggleRecurse(instance, true);</span><span class="s2">\n        </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n            </span><span class="s1">effect.onTrack = instance.rtc</span><span class="s2">\n                </span><span class="s1">? e =&gt; invokeArrayFns(instance.rtc, e)</span><span class="s2">\n                </span><span class="s1">: void 0;</span><span class="s2">\n            </span><span class="s1">effect.onTrigger = instance.rtg</span><span class="s2">\n                </span><span class="s1">? e =&gt; invokeArrayFns(instance.rtg, e)</span><span class="s2">\n                </span><span class="s1">: void 0;</span><span class="s2">\n            </span><span class="s1">update.ownerInstance = instance;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">update();</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">const updateComponentPreRender = (instance, nextVNode, optimized) =&gt; {</span><span class="s2">\n        </span><span class="s1">nextVNode.component = instance;</span><span class="s2">\n        </span><span class="s1">const prevProps = instance.vnode.props;</span><span class="s2">\n        </span><span class="s1">instance.vnode = nextVNode;</span><span class="s2">\n        </span><span class="s1">instance.next = null;</span><span class="s2">\n        </span><span class="s1">updateProps(instance, nextVNode.props, prevProps, optimized);</span><span class="s2">\n        </span><span class="s1">updateSlots(instance, nextVNode.children, optimized);</span><span class="s2">\n        </span><span class="s1">pauseTracking();</span><span class="s2">\n        </span><span class="s1">// props update may have triggered pre-flush watchers.</span><span class="s2">\n        </span><span class="s1">// flush them before the render update.</span><span class="s2">\n        </span><span class="s1">flushPreFlushCbs();</span><span class="s2">\n        </span><span class="s1">resetTracking();</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) =&gt; {</span><span class="s2">\n        </span><span class="s1">const c1 = n1 &amp;&amp; n1.children;</span><span class="s2">\n        </span><span class="s1">const prevShapeFlag = n1 ? n1.shapeFlag : 0;</span><span class="s2">\n        </span><span class="s1">const c2 = n2.children;</span><span class="s2">\n        </span><span class="s1">const { patchFlag, shapeFlag } = n2;</span><span class="s2">\n        </span><span class="s1">// fast path</span><span class="s2">\n        </span><span class="s1">if (patchFlag &gt; 0) {</span><span class="s2">\n            </span><span class="s1">if (patchFlag &amp; 128 /* PatchFlags.KEYED_FRAGMENT */) {</span><span class="s2">\n                </span><span class="s1">// this could be either fully-keyed or mixed (some keyed some not)</span><span class="s2">\n                </span><span class="s1">// presence of patchFlag means children are guaranteed to be arrays</span><span class="s2">\n                </span><span class="s1">patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);</span><span class="s2">\n                </span><span class="s1">return;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else if (patchFlag &amp; 256 /* PatchFlags.UNKEYED_FRAGMENT */) {</span><span class="s2">\n                </span><span class="s1">// unkeyed</span><span class="s2">\n                </span><span class="s1">patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);</span><span class="s2">\n                </span><span class="s1">return;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// children has 3 possibilities: text, array or no children.</span><span class="s2">\n        </span><span class="s1">if (shapeFlag &amp; 8 /* ShapeFlags.TEXT_CHILDREN */) {</span><span class="s2">\n            </span><span class="s1">// text children fast path</span><span class="s2">\n            </span><span class="s1">if (prevShapeFlag &amp; 16 /* ShapeFlags.ARRAY_CHILDREN */) {</span><span class="s2">\n                </span><span class="s1">unmountChildren(c1, parentComponent, parentSuspense);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">if (c2 !== c1) {</span><span class="s2">\n                </span><span class="s1">hostSetElementText(container, c2);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">if (prevShapeFlag &amp; 16 /* ShapeFlags.ARRAY_CHILDREN */) {</span><span class="s2">\n                </span><span class="s1">// prev children was array</span><span class="s2">\n                </span><span class="s1">if (shapeFlag &amp; 16 /* ShapeFlags.ARRAY_CHILDREN */) {</span><span class="s2">\n                    </span><span class="s1">// two arrays, cannot assume anything, do full diff</span><span class="s2">\n                    </span><span class="s1">patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else {</span><span class="s2">\n                    </span><span class="s1">// no new children, just unmount old</span><span class="s2">\n                    </span><span class="s1">unmountChildren(c1, parentComponent, parentSuspense, true);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">// prev children was text OR null</span><span class="s2">\n                </span><span class="s1">// new children is array OR null</span><span class="s2">\n                </span><span class="s1">if (prevShapeFlag &amp; 8 /* ShapeFlags.TEXT_CHILDREN */) {</span><span class="s2">\n                    </span><span class="s1">hostSetElementText(container, '');</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">// mount new if array</span><span class="s2">\n                </span><span class="s1">if (shapeFlag &amp; 16 /* ShapeFlags.ARRAY_CHILDREN */) {</span><span class="s2">\n                    </span><span class="s1">mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) =&gt; {</span><span class="s2">\n        </span><span class="s1">c1 = c1 || EMPTY_ARR;</span><span class="s2">\n        </span><span class="s1">c2 = c2 || EMPTY_ARR;</span><span class="s2">\n        </span><span class="s1">const oldLength = c1.length;</span><span class="s2">\n        </span><span class="s1">const newLength = c2.length;</span><span class="s2">\n        </span><span class="s1">const commonLength = Math.min(oldLength, newLength);</span><span class="s2">\n        </span><span class="s1">let i;</span><span class="s2">\n        </span><span class="s1">for (i = 0; i &lt; commonLength; i++) {</span><span class="s2">\n            </span><span class="s1">const nextChild = (c2[i] = optimized</span><span class="s2">\n                </span><span class="s1">? cloneIfMounted(c2[i])</span><span class="s2">\n                </span><span class="s1">: normalizeVNode(c2[i]));</span><span class="s2">\n            </span><span class="s1">patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (oldLength &gt; newLength) {</span><span class="s2">\n            </span><span class="s1">// remove old</span><span class="s2">\n            </span><span class="s1">unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">// mount new</span><span class="s2">\n            </span><span class="s1">mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">// can be all-keyed or mixed</span><span class="s2">\n    </span><span class="s1">const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) =&gt; {</span><span class="s2">\n        </span><span class="s1">let i = 0;</span><span class="s2">\n        </span><span class="s1">const l2 = c2.length;</span><span class="s2">\n        </span><span class="s1">let e1 = c1.length - 1; // prev ending index</span><span class="s2">\n        </span><span class="s1">let e2 = l2 - 1; // next ending index</span><span class="s2">\n        </span><span class="s1">// 1. sync from start</span><span class="s2">\n        </span><span class="s1">// (a b) c</span><span class="s2">\n        </span><span class="s1">// (a b) d e</span><span class="s2">\n        </span><span class="s1">while (i &lt;= e1 &amp;&amp; i &lt;= e2) {</span><span class="s2">\n            </span><span class="s1">const n1 = c1[i];</span><span class="s2">\n            </span><span class="s1">const n2 = (c2[i] = optimized</span><span class="s2">\n                </span><span class="s1">? cloneIfMounted(c2[i])</span><span class="s2">\n                </span><span class="s1">: normalizeVNode(c2[i]));</span><span class="s2">\n            </span><span class="s1">if (isSameVNodeType(n1, n2)) {</span><span class="s2">\n                </span><span class="s1">patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">break;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">i++;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// 2. sync from end</span><span class="s2">\n        </span><span class="s1">// a (b c)</span><span class="s2">\n        </span><span class="s1">// d e (b c)</span><span class="s2">\n        </span><span class="s1">while (i &lt;= e1 &amp;&amp; i &lt;= e2) {</span><span class="s2">\n            </span><span class="s1">const n1 = c1[e1];</span><span class="s2">\n            </span><span class="s1">const n2 = (c2[e2] = optimized</span><span class="s2">\n                </span><span class="s1">? cloneIfMounted(c2[e2])</span><span class="s2">\n                </span><span class="s1">: normalizeVNode(c2[e2]));</span><span class="s2">\n            </span><span class="s1">if (isSameVNodeType(n1, n2)) {</span><span class="s2">\n                </span><span class="s1">patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">break;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">e1--;</span><span class="s2">\n            </span><span class="s1">e2--;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// 3. common sequence + mount</span><span class="s2">\n        </span><span class="s1">// (a b)</span><span class="s2">\n        </span><span class="s1">// (a b) c</span><span class="s2">\n        </span><span class="s1">// i = 2, e1 = 1, e2 = 2</span><span class="s2">\n        </span><span class="s1">// (a b)</span><span class="s2">\n        </span><span class="s1">// c (a b)</span><span class="s2">\n        </span><span class="s1">// i = 0, e1 = -1, e2 = 0</span><span class="s2">\n        </span><span class="s1">if (i &gt; e1) {</span><span class="s2">\n            </span><span class="s1">if (i &lt;= e2) {</span><span class="s2">\n                </span><span class="s1">const nextPos = e2 + 1;</span><span class="s2">\n                </span><span class="s1">const anchor = nextPos &lt; l2 ? c2[nextPos].el : parentAnchor;</span><span class="s2">\n                </span><span class="s1">while (i &lt;= e2) {</span><span class="s2">\n                    </span><span class="s1">patch(null, (c2[i] = optimized</span><span class="s2">\n                        </span><span class="s1">? cloneIfMounted(c2[i])</span><span class="s2">\n                        </span><span class="s1">: normalizeVNode(c2[i])), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);</span><span class="s2">\n                    </span><span class="s1">i++;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// 4. common sequence + unmount</span><span class="s2">\n        </span><span class="s1">// (a b) c</span><span class="s2">\n        </span><span class="s1">// (a b)</span><span class="s2">\n        </span><span class="s1">// i = 2, e1 = 2, e2 = 1</span><span class="s2">\n        </span><span class="s1">// a (b c)</span><span class="s2">\n        </span><span class="s1">// (b c)</span><span class="s2">\n        </span><span class="s1">// i = 0, e1 = 0, e2 = -1</span><span class="s2">\n        </span><span class="s1">else if (i &gt; e2) {</span><span class="s2">\n            </span><span class="s1">while (i &lt;= e1) {</span><span class="s2">\n                </span><span class="s1">unmount(c1[i], parentComponent, parentSuspense, true);</span><span class="s2">\n                </span><span class="s1">i++;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// 5. unknown sequence</span><span class="s2">\n        </span><span class="s1">// [i ... e1 + 1]: a b [c d e] f g</span><span class="s2">\n        </span><span class="s1">// [i ... e2 + 1]: a b [e d c h] f g</span><span class="s2">\n        </span><span class="s1">// i = 2, e1 = 4, e2 = 5</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">const s1 = i; // prev starting index</span><span class="s2">\n            </span><span class="s1">const s2 = i; // next starting index</span><span class="s2">\n            </span><span class="s1">// 5.1 build key:index map for newChildren</span><span class="s2">\n            </span><span class="s1">const keyToNewIndexMap = new Map();</span><span class="s2">\n            </span><span class="s1">for (i = s2; i &lt;= e2; i++) {</span><span class="s2">\n                </span><span class="s1">const nextChild = (c2[i] = optimized</span><span class="s2">\n                    </span><span class="s1">? cloneIfMounted(c2[i])</span><span class="s2">\n                    </span><span class="s1">: normalizeVNode(c2[i]));</span><span class="s2">\n                </span><span class="s1">if (nextChild.key != null) {</span><span class="s2">\n                    </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp; keyToNewIndexMap.has(nextChild.key)) {</span><span class="s2">\n                        </span><span class="s1">warn(`Duplicate keys found during update:`, JSON.stringify(nextChild.key), `Make sure keys are unique.`);</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">keyToNewIndexMap.set(nextChild.key, i);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">// 5.2 loop through old children left to be patched and try to patch</span><span class="s2">\n            </span><span class="s1">// matching nodes &amp; remove nodes that are no longer present</span><span class="s2">\n            </span><span class="s1">let j;</span><span class="s2">\n            </span><span class="s1">let patched = 0;</span><span class="s2">\n            </span><span class="s1">const toBePatched = e2 - s2 + 1;</span><span class="s2">\n            </span><span class="s1">let moved = false;</span><span class="s2">\n            </span><span class="s1">// used to track whether any node has moved</span><span class="s2">\n            </span><span class="s1">let maxNewIndexSoFar = 0;</span><span class="s2">\n            </span><span class="s1">// works as Map&lt;newIndex, oldIndex&gt;</span><span class="s2">\n            </span><span class="s1">// Note that oldIndex is offset by +1</span><span class="s2">\n            </span><span class="s1">// and oldIndex = 0 is a special value indicating the new node has</span><span class="s2">\n            </span><span class="s1">// no corresponding old node.</span><span class="s2">\n            </span><span class="s1">// used for determining longest stable subsequence</span><span class="s2">\n            </span><span class="s1">const newIndexToOldIndexMap = new Array(toBePatched);</span><span class="s2">\n            </span><span class="s1">for (i = 0; i &lt; toBePatched; i++)</span><span class="s2">\n                </span><span class="s1">newIndexToOldIndexMap[i] = 0;</span><span class="s2">\n            </span><span class="s1">for (i = s1; i &lt;= e1; i++) {</span><span class="s2">\n                </span><span class="s1">const prevChild = c1[i];</span><span class="s2">\n                </span><span class="s1">if (patched &gt;= toBePatched) {</span><span class="s2">\n                    </span><span class="s1">// all new children have been patched so this can only be a removal</span><span class="s2">\n                    </span><span class="s1">unmount(prevChild, parentComponent, parentSuspense, true);</span><span class="s2">\n                    </span><span class="s1">continue;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">let newIndex;</span><span class="s2">\n                </span><span class="s1">if (prevChild.key != null) {</span><span class="s2">\n                    </span><span class="s1">newIndex = keyToNewIndexMap.get(prevChild.key);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else {</span><span class="s2">\n                    </span><span class="s1">// key-less node, try to locate a key-less node of the same type</span><span class="s2">\n                    </span><span class="s1">for (j = s2; j &lt;= e2; j++) {</span><span class="s2">\n                        </span><span class="s1">if (newIndexToOldIndexMap[j - s2] === 0 &amp;&amp;</span><span class="s2">\n                            </span><span class="s1">isSameVNodeType(prevChild, c2[j])) {</span><span class="s2">\n                            </span><span class="s1">newIndex = j;</span><span class="s2">\n                            </span><span class="s1">break;</span><span class="s2">\n                        </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">if (newIndex === undefined) {</span><span class="s2">\n                    </span><span class="s1">unmount(prevChild, parentComponent, parentSuspense, true);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else {</span><span class="s2">\n                    </span><span class="s1">newIndexToOldIndexMap[newIndex - s2] = i + 1;</span><span class="s2">\n                    </span><span class="s1">if (newIndex &gt;= maxNewIndexSoFar) {</span><span class="s2">\n                        </span><span class="s1">maxNewIndexSoFar = newIndex;</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">else {</span><span class="s2">\n                        </span><span class="s1">moved = true;</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);</span><span class="s2">\n                    </span><span class="s1">patched++;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">// 5.3 move and mount</span><span class="s2">\n            </span><span class="s1">// generate longest stable subsequence only when nodes have moved</span><span class="s2">\n            </span><span class="s1">const increasingNewIndexSequence = moved</span><span class="s2">\n                </span><span class="s1">? getSequence(newIndexToOldIndexMap)</span><span class="s2">\n                </span><span class="s1">: EMPTY_ARR;</span><span class="s2">\n            </span><span class="s1">j = increasingNewIndexSequence.length - 1;</span><span class="s2">\n            </span><span class="s1">// looping backwards so that we can use last patched node as anchor</span><span class="s2">\n            </span><span class="s1">for (i = toBePatched - 1; i &gt;= 0; i--) {</span><span class="s2">\n                </span><span class="s1">const nextIndex = s2 + i;</span><span class="s2">\n                </span><span class="s1">const nextChild = c2[nextIndex];</span><span class="s2">\n                </span><span class="s1">const anchor = nextIndex + 1 &lt; l2 ? c2[nextIndex + 1].el : parentAnchor;</span><span class="s2">\n                </span><span class="s1">if (newIndexToOldIndexMap[i] === 0) {</span><span class="s2">\n                    </span><span class="s1">// mount new</span><span class="s2">\n                    </span><span class="s1">patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else if (moved) {</span><span class="s2">\n                    </span><span class="s1">// move if:</span><span class="s2">\n                    </span><span class="s1">// There is no stable subsequence (e.g. a reverse)</span><span class="s2">\n                    </span><span class="s1">// OR current node is not among the stable sequence</span><span class="s2">\n                    </span><span class="s1">if (j &lt; 0 || i !== increasingNewIndexSequence[j]) {</span><span class="s2">\n                        </span><span class="s1">move(nextChild, container, anchor, 2 /* MoveType.REORDER */);</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">else {</span><span class="s2">\n                        </span><span class="s1">j--;</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">const move = (vnode, container, anchor, moveType, parentSuspense = null) =&gt; {</span><span class="s2">\n        </span><span class="s1">const { el, type, transition, children, shapeFlag } = vnode;</span><span class="s2">\n        </span><span class="s1">if (shapeFlag &amp; 6 /* ShapeFlags.COMPONENT */) {</span><span class="s2">\n            </span><span class="s1">move(vnode.component.subTree, container, anchor, moveType);</span><span class="s2">\n            </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (shapeFlag &amp; 128 /* ShapeFlags.SUSPENSE */) {</span><span class="s2">\n            </span><span class="s1">vnode.suspense.move(container, anchor, moveType);</span><span class="s2">\n            </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (shapeFlag &amp; 64 /* ShapeFlags.TELEPORT */) {</span><span class="s2">\n            </span><span class="s1">type.move(vnode, container, anchor, internals);</span><span class="s2">\n            </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (type === Fragment) {</span><span class="s2">\n            </span><span class="s1">hostInsert(el, container, anchor);</span><span class="s2">\n            </span><span class="s1">for (let i = 0; i &lt; children.length; i++) {</span><span class="s2">\n                </span><span class="s1">move(children[i], container, anchor, moveType);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">hostInsert(vnode.anchor, container, anchor);</span><span class="s2">\n            </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (type === Static) {</span><span class="s2">\n            </span><span class="s1">moveStaticNode(vnode, container, anchor);</span><span class="s2">\n            </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// single nodes</span><span class="s2">\n        </span><span class="s1">const needTransition = moveType !== 2 /* MoveType.REORDER */ &amp;&amp;</span><span class="s2">\n            </span><span class="s1">shapeFlag &amp; 1 /* ShapeFlags.ELEMENT */ &amp;&amp;</span><span class="s2">\n            </span><span class="s1">transition;</span><span class="s2">\n        </span><span class="s1">if (needTransition) {</span><span class="s2">\n            </span><span class="s1">if (moveType === 0 /* MoveType.ENTER */) {</span><span class="s2">\n                </span><span class="s1">transition.beforeEnter(el);</span><span class="s2">\n                </span><span class="s1">hostInsert(el, container, anchor);</span><span class="s2">\n                </span><span class="s1">queuePostRenderEffect(() =&gt; transition.enter(el), parentSuspense);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">const { leave, delayLeave, afterLeave } = transition;</span><span class="s2">\n                </span><span class="s1">const remove = () =&gt; hostInsert(el, container, anchor);</span><span class="s2">\n                </span><span class="s1">const performLeave = () =&gt; {</span><span class="s2">\n                    </span><span class="s1">leave(el, () =&gt; {</span><span class="s2">\n                        </span><span class="s1">remove();</span><span class="s2">\n                        </span><span class="s1">afterLeave &amp;&amp; afterLeave();</span><span class="s2">\n                    </span><span class="s1">});</span><span class="s2">\n                </span><span class="s1">};</span><span class="s2">\n                </span><span class="s1">if (delayLeave) {</span><span class="s2">\n                    </span><span class="s1">delayLeave(el, remove, performLeave);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else {</span><span class="s2">\n                    </span><span class="s1">performLeave();</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">hostInsert(el, container, anchor);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) =&gt; {</span><span class="s2">\n        </span><span class="s1">const { type, props, ref, children, dynamicChildren, shapeFlag, patchFlag, dirs } = vnode;</span><span class="s2">\n        </span><span class="s1">// unset ref</span><span class="s2">\n        </span><span class="s1">if (ref != null) {</span><span class="s2">\n            </span><span class="s1">setRef(ref, null, parentSuspense, vnode, true);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (shapeFlag &amp; 256 /* ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE */) {</span><span class="s2">\n            </span><span class="s1">parentComponent.ctx.deactivate(vnode);</span><span class="s2">\n            </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">const shouldInvokeDirs = shapeFlag &amp; 1 /* ShapeFlags.ELEMENT */ &amp;&amp; dirs;</span><span class="s2">\n        </span><span class="s1">const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);</span><span class="s2">\n        </span><span class="s1">let vnodeHook;</span><span class="s2">\n        </span><span class="s1">if (shouldInvokeVnodeHook &amp;&amp;</span><span class="s2">\n            </span><span class="s1">(vnodeHook = props &amp;&amp; props.onVnodeBeforeUnmount)) {</span><span class="s2">\n            </span><span class="s1">invokeVNodeHook(vnodeHook, parentComponent, vnode);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (shapeFlag &amp; 6 /* ShapeFlags.COMPONENT */) {</span><span class="s2">\n            </span><span class="s1">unmountComponent(vnode.component, parentSuspense, doRemove);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">if (shapeFlag &amp; 128 /* ShapeFlags.SUSPENSE */) {</span><span class="s2">\n                </span><span class="s1">vnode.suspense.unmount(parentSuspense, doRemove);</span><span class="s2">\n                </span><span class="s1">return;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">if (shouldInvokeDirs) {</span><span class="s2">\n                </span><span class="s1">invokeDirectiveHook(vnode, null, parentComponent, 'beforeUnmount');</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">if (shapeFlag &amp; 64 /* ShapeFlags.TELEPORT */) {</span><span class="s2">\n                </span><span class="s1">vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else if (dynamicChildren &amp;&amp;</span><span class="s2">\n                </span><span class="s1">// #1153: fast path should not be taken for non-stable (v-for) fragments</span><span class="s2">\n                </span><span class="s1">(type !== Fragment ||</span><span class="s2">\n                    </span><span class="s1">(patchFlag &gt; 0 &amp;&amp; patchFlag &amp; 64 /* PatchFlags.STABLE_FRAGMENT */))) {</span><span class="s2">\n                </span><span class="s1">// fast path for block nodes: only need to unmount dynamic children.</span><span class="s2">\n                </span><span class="s1">unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else if ((type === Fragment &amp;&amp;</span><span class="s2">\n                </span><span class="s1">patchFlag &amp;</span><span class="s2">\n                    </span><span class="s1">(128 /* PatchFlags.KEYED_FRAGMENT */ | 256 /* PatchFlags.UNKEYED_FRAGMENT */)) ||</span><span class="s2">\n                </span><span class="s1">(!optimized &amp;&amp; shapeFlag &amp; 16 /* ShapeFlags.ARRAY_CHILDREN */)) {</span><span class="s2">\n                </span><span class="s1">unmountChildren(children, parentComponent, parentSuspense);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">if (doRemove) {</span><span class="s2">\n                </span><span class="s1">remove(vnode);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if ((shouldInvokeVnodeHook &amp;&amp;</span><span class="s2">\n            </span><span class="s1">(vnodeHook = props &amp;&amp; props.onVnodeUnmounted)) ||</span><span class="s2">\n            </span><span class="s1">shouldInvokeDirs) {</span><span class="s2">\n            </span><span class="s1">queuePostRenderEffect(() =&gt; {</span><span class="s2">\n                </span><span class="s1">vnodeHook &amp;&amp; invokeVNodeHook(vnodeHook, parentComponent, vnode);</span><span class="s2">\n                </span><span class="s1">shouldInvokeDirs &amp;&amp;</span><span class="s2">\n                    </span><span class="s1">invokeDirectiveHook(vnode, null, parentComponent, 'unmounted');</span><span class="s2">\n            </span><span class="s1">}, parentSuspense);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">const remove = vnode =&gt; {</span><span class="s2">\n        </span><span class="s1">const { type, el, anchor, transition } = vnode;</span><span class="s2">\n        </span><span class="s1">if (type === Fragment) {</span><span class="s2">\n            </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp;</span><span class="s2">\n                </span><span class="s1">vnode.patchFlag &gt; 0 &amp;&amp;</span><span class="s2">\n                </span><span class="s1">vnode.patchFlag &amp; 2048 /* PatchFlags.DEV_ROOT_FRAGMENT */ &amp;&amp;</span><span class="s2">\n                </span><span class="s1">transition &amp;&amp;</span><span class="s2">\n                </span><span class="s1">!transition.persisted) {</span><span class="s2">\n                </span><span class="s1">vnode.children.forEach(child =&gt; {</span><span class="s2">\n                    </span><span class="s1">if (child.type === Comment) {</span><span class="s2">\n                        </span><span class="s1">hostRemove(child.el);</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">else {</span><span class="s2">\n                        </span><span class="s1">remove(child);</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">});</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">removeFragment(el, anchor);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (type === Static) {</span><span class="s2">\n            </span><span class="s1">removeStaticNode(vnode);</span><span class="s2">\n            </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">const performRemove = () =&gt; {</span><span class="s2">\n            </span><span class="s1">hostRemove(el);</span><span class="s2">\n            </span><span class="s1">if (transition &amp;&amp; !transition.persisted &amp;&amp; transition.afterLeave) {</span><span class="s2">\n                </span><span class="s1">transition.afterLeave();</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n        </span><span class="s1">if (vnode.shapeFlag &amp; 1 /* ShapeFlags.ELEMENT */ &amp;&amp;</span><span class="s2">\n            </span><span class="s1">transition &amp;&amp;</span><span class="s2">\n            </span><span class="s1">!transition.persisted) {</span><span class="s2">\n            </span><span class="s1">const { leave, delayLeave } = transition;</span><span class="s2">\n            </span><span class="s1">const performLeave = () =&gt; leave(el, performRemove);</span><span class="s2">\n            </span><span class="s1">if (delayLeave) {</span><span class="s2">\n                </span><span class="s1">delayLeave(vnode.el, performRemove, performLeave);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">performLeave();</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">performRemove();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">const removeFragment = (cur, end) =&gt; {</span><span class="s2">\n        </span><span class="s1">// For fragments, directly remove all contained DOM nodes.</span><span class="s2">\n        </span><span class="s1">// (fragment child nodes cannot have transition)</span><span class="s2">\n        </span><span class="s1">let next;</span><span class="s2">\n        </span><span class="s1">while (cur !== end) {</span><span class="s2">\n            </span><span class="s1">next = hostNextSibling(cur);</span><span class="s2">\n            </span><span class="s1">hostRemove(cur);</span><span class="s2">\n            </span><span class="s1">cur = next;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">hostRemove(end);</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">const unmountComponent = (instance, parentSuspense, doRemove) =&gt; {</span><span class="s2">\n        </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp; instance.type.__hmrId) {</span><span class="s2">\n            </span><span class="s1">unregisterHMR(instance);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">const { bum, scope, update, subTree, um } = instance;</span><span class="s2">\n        </span><span class="s1">// beforeUnmount hook</span><span class="s2">\n        </span><span class="s1">if (bum) {</span><span class="s2">\n            </span><span class="s1">invokeArrayFns(bum);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// stop effects in component scope</span><span class="s2">\n        </span><span class="s1">scope.stop();</span><span class="s2">\n        </span><span class="s1">// update may be null if a component is unmounted before its async</span><span class="s2">\n        </span><span class="s1">// setup has resolved.</span><span class="s2">\n        </span><span class="s1">if (update) {</span><span class="s2">\n            </span><span class="s1">// so that scheduler will no longer invoke it</span><span class="s2">\n            </span><span class="s1">update.active = false;</span><span class="s2">\n            </span><span class="s1">unmount(subTree, instance, parentSuspense, doRemove);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// unmounted hook</span><span class="s2">\n        </span><span class="s1">if (um) {</span><span class="s2">\n            </span><span class="s1">queuePostRenderEffect(um, parentSuspense);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">queuePostRenderEffect(() =&gt; {</span><span class="s2">\n            </span><span class="s1">instance.isUnmounted = true;</span><span class="s2">\n        </span><span class="s1">}, parentSuspense);</span><span class="s2">\n        </span><span class="s1">// A component with async dep inside a pending suspense is unmounted before</span><span class="s2">\n        </span><span class="s1">// its async dep resolves. This should remove the dep from the suspense, and</span><span class="s2">\n        </span><span class="s1">// cause the suspense to resolve immediately if that was the last dep.</span><span class="s2">\n        </span><span class="s1">if (parentSuspense &amp;&amp;</span><span class="s2">\n            </span><span class="s1">parentSuspense.pendingBranch &amp;&amp;</span><span class="s2">\n            </span><span class="s1">!parentSuspense.isUnmounted &amp;&amp;</span><span class="s2">\n            </span><span class="s1">instance.asyncDep &amp;&amp;</span><span class="s2">\n            </span><span class="s1">!instance.asyncResolved &amp;&amp;</span><span class="s2">\n            </span><span class="s1">instance.suspenseId === parentSuspense.pendingId) {</span><span class="s2">\n            </span><span class="s1">parentSuspense.deps--;</span><span class="s2">\n            </span><span class="s1">if (parentSuspense.deps === 0) {</span><span class="s2">\n                </span><span class="s1">parentSuspense.resolve();</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if ((process.env.NODE_ENV !== 'production') || __VUE_PROD_DEVTOOLS__) {</span><span class="s2">\n            </span><span class="s1">devtoolsComponentRemoved(instance);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) =&gt; {</span><span class="s2">\n        </span><span class="s1">for (let i = start; i &lt; children.length; i++) {</span><span class="s2">\n            </span><span class="s1">unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">const getNextHostNode = vnode =&gt; {</span><span class="s2">\n        </span><span class="s1">if (vnode.shapeFlag &amp; 6 /* ShapeFlags.COMPONENT */) {</span><span class="s2">\n            </span><span class="s1">return getNextHostNode(vnode.component.subTree);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (vnode.shapeFlag &amp; 128 /* ShapeFlags.SUSPENSE */) {</span><span class="s2">\n            </span><span class="s1">return vnode.suspense.next();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return hostNextSibling((vnode.anchor || vnode.el));</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">const render = (vnode, container, isSVG) =&gt; {</span><span class="s2">\n        </span><span class="s1">if (vnode == null) {</span><span class="s2">\n            </span><span class="s1">if (container._vnode) {</span><span class="s2">\n                </span><span class="s1">unmount(container._vnode, null, null, true);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">patch(container._vnode || null, vnode, container, null, null, null, isSVG);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">flushPreFlushCbs();</span><span class="s2">\n        </span><span class="s1">flushPostFlushCbs();</span><span class="s2">\n        </span><span class="s1">container._vnode = vnode;</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">const internals = {</span><span class="s2">\n        </span><span class="s1">p: patch,</span><span class="s2">\n        </span><span class="s1">um: unmount,</span><span class="s2">\n        </span><span class="s1">m: move,</span><span class="s2">\n        </span><span class="s1">r: remove,</span><span class="s2">\n        </span><span class="s1">mt: mountComponent,</span><span class="s2">\n        </span><span class="s1">mc: mountChildren,</span><span class="s2">\n        </span><span class="s1">pc: patchChildren,</span><span class="s2">\n        </span><span class="s1">pbc: patchBlockChildren,</span><span class="s2">\n        </span><span class="s1">n: getNextHostNode,</span><span class="s2">\n        </span><span class="s1">o: options</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">let hydrate;</span><span class="s2">\n    </span><span class="s1">let hydrateNode;</span><span class="s2">\n    </span><span class="s1">if (createHydrationFns) {</span><span class="s2">\n        </span><span class="s1">[hydrate, hydrateNode] = createHydrationFns(internals);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n        </span><span class="s1">render,</span><span class="s2">\n        </span><span class="s1">hydrate,</span><span class="s2">\n        </span><span class="s1">createApp: createAppAPI(render, hydrate)</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function toggleRecurse({ effect, update }, allowed) {</span><span class="s2">\n    </span><span class="s1">effect.allowRecurse = update.allowRecurse = allowed;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* #1156</span><span class="s2">\n </span><span class="s1">* When a component is HMR-enabled, we need to make sure that all static nodes</span><span class="s2">\n </span><span class="s1">* inside a block also inherit the DOM element from the previous tree so that</span><span class="s2">\n </span><span class="s1">* HMR updates (which are full updates) can retrieve the element for patching.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* #2080</span><span class="s2">\n </span><span class="s1">* Inside keyed `template` fragment static children, if a fragment is moved,</span><span class="s2">\n </span><span class="s1">* the children will always be moved. Therefore, in order to ensure correct move</span><span class="s2">\n </span><span class="s1">* position, el should be inherited from previous nodes.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function traverseStaticChildren(n1, n2, shallow = false) {</span><span class="s2">\n    </span><span class="s1">const ch1 = n1.children;</span><span class="s2">\n    </span><span class="s1">const ch2 = n2.children;</span><span class="s2">\n    </span><span class="s1">if (isArray(ch1) &amp;&amp; isArray(ch2)) {</span><span class="s2">\n        </span><span class="s1">for (let i = 0; i &lt; ch1.length; i++) {</span><span class="s2">\n            </span><span class="s1">// this is only called in the optimized path so array children are</span><span class="s2">\n            </span><span class="s1">// guaranteed to be vnodes</span><span class="s2">\n            </span><span class="s1">const c1 = ch1[i];</span><span class="s2">\n            </span><span class="s1">let c2 = ch2[i];</span><span class="s2">\n            </span><span class="s1">if (c2.shapeFlag &amp; 1 /* ShapeFlags.ELEMENT */ &amp;&amp; !c2.dynamicChildren) {</span><span class="s2">\n                </span><span class="s1">if (c2.patchFlag &lt;= 0 || c2.patchFlag === 32 /* PatchFlags.HYDRATE_EVENTS */) {</span><span class="s2">\n                    </span><span class="s1">c2 = ch2[i] = cloneIfMounted(ch2[i]);</span><span class="s2">\n                    </span><span class="s1">c2.el = c1.el;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">if (!shallow)</span><span class="s2">\n                    </span><span class="s1">traverseStaticChildren(c1, c2);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">// #6852 also inherit for text nodes</span><span class="s2">\n            </span><span class="s1">if (c2.type === Text) {</span><span class="s2">\n                </span><span class="s1">c2.el = c1.el;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">// also inherit for comment nodes, but not placeholders (e.g. v-if which</span><span class="s2">\n            </span><span class="s1">// would have received .el during block patch)</span><span class="s2">\n            </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp; c2.type === Comment &amp;&amp; !c2.el) {</span><span class="s2">\n                </span><span class="s1">c2.el = c1.el;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// https://en.wikipedia.org/wiki/Longest_increasing_subsequence</span><span class="s2">\n</span><span class="s1">function getSequence(arr) {</span><span class="s2">\n    </span><span class="s1">const p = arr.slice();</span><span class="s2">\n    </span><span class="s1">const result = [0];</span><span class="s2">\n    </span><span class="s1">let i, j, u, v, c;</span><span class="s2">\n    </span><span class="s1">const len = arr.length;</span><span class="s2">\n    </span><span class="s1">for (i = 0; i &lt; len; i++) {</span><span class="s2">\n        </span><span class="s1">const arrI = arr[i];</span><span class="s2">\n        </span><span class="s1">if (arrI !== 0) {</span><span class="s2">\n            </span><span class="s1">j = result[result.length - 1];</span><span class="s2">\n            </span><span class="s1">if (arr[j] &lt; arrI) {</span><span class="s2">\n                </span><span class="s1">p[i] = j;</span><span class="s2">\n                </span><span class="s1">result.push(i);</span><span class="s2">\n                </span><span class="s1">continue;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">u = 0;</span><span class="s2">\n            </span><span class="s1">v = result.length - 1;</span><span class="s2">\n            </span><span class="s1">while (u &lt; v) {</span><span class="s2">\n                </span><span class="s1">c = (u + v) &gt;&gt; 1;</span><span class="s2">\n                </span><span class="s1">if (arr[result[c]] &lt; arrI) {</span><span class="s2">\n                    </span><span class="s1">u = c + 1;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else {</span><span class="s2">\n                    </span><span class="s1">v = c;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">if (arrI &lt; arr[result[u]]) {</span><span class="s2">\n                </span><span class="s1">if (u &gt; 0) {</span><span class="s2">\n                    </span><span class="s1">p[i] = result[u - 1];</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">result[u] = i;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">u = result.length;</span><span class="s2">\n    </span><span class="s1">v = result[u - 1];</span><span class="s2">\n    </span><span class="s1">while (u-- &gt; 0) {</span><span class="s2">\n        </span><span class="s1">result[u] = v;</span><span class="s2">\n        </span><span class="s1">v = p[v];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return result;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">const isTeleport = (type) =&gt; type.__isTeleport;</span><span class="s2">\n</span><span class="s1">const isTeleportDisabled = (props) =&gt; props &amp;&amp; (props.disabled || props.disabled === '');</span><span class="s2">\n</span><span class="s1">const isTargetSVG = (target) =&gt; typeof SVGElement !== 'undefined' &amp;&amp; target instanceof SVGElement;</span><span class="s2">\n</span><span class="s1">const resolveTarget = (props, select) =&gt; {</span><span class="s2">\n    </span><span class="s1">const targetSelector = props &amp;&amp; props.to;</span><span class="s2">\n    </span><span class="s1">if (isString(targetSelector)) {</span><span class="s2">\n        </span><span class="s1">if (!select) {</span><span class="s2">\n            </span><span class="s1">(process.env.NODE_ENV !== 'production') &amp;&amp;</span><span class="s2">\n                </span><span class="s1">warn(`Current renderer does not support string target for Teleports. ` +</span><span class="s2">\n                    </span><span class="s1">`(missing querySelector renderer option)`);</span><span class="s2">\n            </span><span class="s1">return null;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">const target = select(targetSelector);</span><span class="s2">\n            </span><span class="s1">if (!target) {</span><span class="s2">\n                </span><span class="s1">(process.env.NODE_ENV !== 'production') &amp;&amp;</span><span class="s2">\n                    </span><span class="s1">warn(`Failed to locate Teleport target with selector </span><span class="s2">\&quot;</span><span class="s1">${targetSelector}</span><span class="s2">\&quot;</span><span class="s1">. ` +</span><span class="s2">\n                        </span><span class="s1">`Note the target element must exist before the component is mounted - ` +</span><span class="s2">\n                        </span><span class="s1">`i.e. the target cannot be rendered by the component itself, and ` +</span><span class="s2">\n                        </span><span class="s1">`ideally should be outside of the entire Vue component tree.`);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">return target;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp; !targetSelector &amp;&amp; !isTeleportDisabled(props)) {</span><span class="s2">\n            </span><span class="s1">warn(`Invalid Teleport target: ${targetSelector}`);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return targetSelector;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">const TeleportImpl = {</span><span class="s2">\n    </span><span class="s1">__isTeleport: true,</span><span class="s2">\n    </span><span class="s1">process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {</span><span class="s2">\n        </span><span class="s1">const { mc: mountChildren, pc: patchChildren, pbc: patchBlockChildren, o: { insert, querySelector, createText, createComment } } = internals;</span><span class="s2">\n        </span><span class="s1">const disabled = isTeleportDisabled(n2.props);</span><span class="s2">\n        </span><span class="s1">let { shapeFlag, children, dynamicChildren } = n2;</span><span class="s2">\n        </span><span class="s1">// #3302</span><span class="s2">\n        </span><span class="s1">// HMR updated, force full diff</span><span class="s2">\n        </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp; isHmrUpdating) {</span><span class="s2">\n            </span><span class="s1">optimized = false;</span><span class="s2">\n            </span><span class="s1">dynamicChildren = null;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (n1 == null) {</span><span class="s2">\n            </span><span class="s1">// insert anchors in the main view</span><span class="s2">\n            </span><span class="s1">const placeholder = (n2.el = (process.env.NODE_ENV !== 'production')</span><span class="s2">\n                </span><span class="s1">? createComment('teleport start')</span><span class="s2">\n                </span><span class="s1">: createText(''));</span><span class="s2">\n            </span><span class="s1">const mainAnchor = (n2.anchor = (process.env.NODE_ENV !== 'production')</span><span class="s2">\n                </span><span class="s1">? createComment('teleport end')</span><span class="s2">\n                </span><span class="s1">: createText(''));</span><span class="s2">\n            </span><span class="s1">insert(placeholder, container, anchor);</span><span class="s2">\n            </span><span class="s1">insert(mainAnchor, container, anchor);</span><span class="s2">\n            </span><span class="s1">const target = (n2.target = resolveTarget(n2.props, querySelector));</span><span class="s2">\n            </span><span class="s1">const targetAnchor = (n2.targetAnchor = createText(''));</span><span class="s2">\n            </span><span class="s1">if (target) {</span><span class="s2">\n                </span><span class="s1">insert(targetAnchor, target);</span><span class="s2">\n                </span><span class="s1">// #2652 we could be teleporting from a non-SVG tree into an SVG tree</span><span class="s2">\n                </span><span class="s1">isSVG = isSVG || isTargetSVG(target);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else if ((process.env.NODE_ENV !== 'production') &amp;&amp; !disabled) {</span><span class="s2">\n                </span><span class="s1">warn('Invalid Teleport target on mount:', target, `(${typeof target})`);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">const mount = (container, anchor) =&gt; {</span><span class="s2">\n                </span><span class="s1">// Teleport *always* has Array children. This is enforced in both the</span><span class="s2">\n                </span><span class="s1">// compiler and vnode children normalization.</span><span class="s2">\n                </span><span class="s1">if (shapeFlag &amp; 16 /* ShapeFlags.ARRAY_CHILDREN */) {</span><span class="s2">\n                    </span><span class="s1">mountChildren(children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">};</span><span class="s2">\n            </span><span class="s1">if (disabled) {</span><span class="s2">\n                </span><span class="s1">mount(container, mainAnchor);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else if (target) {</span><span class="s2">\n                </span><span class="s1">mount(target, targetAnchor);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">// update content</span><span class="s2">\n            </span><span class="s1">n2.el = n1.el;</span><span class="s2">\n            </span><span class="s1">const mainAnchor = (n2.anchor = n1.anchor);</span><span class="s2">\n            </span><span class="s1">const target = (n2.target = n1.target);</span><span class="s2">\n            </span><span class="s1">const targetAnchor = (n2.targetAnchor = n1.targetAnchor);</span><span class="s2">\n            </span><span class="s1">const wasDisabled = isTeleportDisabled(n1.props);</span><span class="s2">\n            </span><span class="s1">const currentContainer = wasDisabled ? container : target;</span><span class="s2">\n            </span><span class="s1">const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;</span><span class="s2">\n            </span><span class="s1">isSVG = isSVG || isTargetSVG(target);</span><span class="s2">\n            </span><span class="s1">if (dynamicChildren) {</span><span class="s2">\n                </span><span class="s1">// fast path when the teleport happens to be a block root</span><span class="s2">\n                </span><span class="s1">patchBlockChildren(n1.dynamicChildren, dynamicChildren, currentContainer, parentComponent, parentSuspense, isSVG, slotScopeIds);</span><span class="s2">\n                </span><span class="s1">// even in block tree mode we need to make sure all root-level nodes</span><span class="s2">\n                </span><span class="s1">// in the teleport inherit previous DOM references so that they can</span><span class="s2">\n                </span><span class="s1">// be moved in future patches.</span><span class="s2">\n                </span><span class="s1">traverseStaticChildren(n1, n2, true);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else if (!optimized) {</span><span class="s2">\n                </span><span class="s1">patchChildren(n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, false);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">if (disabled) {</span><span class="s2">\n                </span><span class="s1">if (!wasDisabled) {</span><span class="s2">\n                    </span><span class="s1">// enabled -&gt; disabled</span><span class="s2">\n                    </span><span class="s1">// move into main container</span><span class="s2">\n                    </span><span class="s1">moveTeleport(n2, container, mainAnchor, internals, 1 /* TeleportMoveTypes.TOGGLE */);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">// target changed</span><span class="s2">\n                </span><span class="s1">if ((n2.props &amp;&amp; n2.props.to) !== (n1.props &amp;&amp; n1.props.to)) {</span><span class="s2">\n                    </span><span class="s1">const nextTarget = (n2.target = resolveTarget(n2.props, querySelector));</span><span class="s2">\n                    </span><span class="s1">if (nextTarget) {</span><span class="s2">\n                        </span><span class="s1">moveTeleport(n2, nextTarget, null, internals, 0 /* TeleportMoveTypes.TARGET_CHANGE */);</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">else if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n                        </span><span class="s1">warn('Invalid Teleport target on update:', target, `(${typeof target})`);</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else if (wasDisabled) {</span><span class="s2">\n                    </span><span class="s1">// disabled -&gt; enabled</span><span class="s2">\n                    </span><span class="s1">// move into teleport target</span><span class="s2">\n                    </span><span class="s1">moveTeleport(n2, target, targetAnchor, internals, 1 /* TeleportMoveTypes.TOGGLE */);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">updateCssVars(n2);</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {</span><span class="s2">\n        </span><span class="s1">const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode;</span><span class="s2">\n        </span><span class="s1">if (target) {</span><span class="s2">\n            </span><span class="s1">hostRemove(targetAnchor);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// an unmounted teleport should always remove its children if not disabled</span><span class="s2">\n        </span><span class="s1">if (doRemove || !isTeleportDisabled(props)) {</span><span class="s2">\n            </span><span class="s1">hostRemove(anchor);</span><span class="s2">\n            </span><span class="s1">if (shapeFlag &amp; 16 /* ShapeFlags.ARRAY_CHILDREN */) {</span><span class="s2">\n                </span><span class="s1">for (let i = 0; i &lt; children.length; i++) {</span><span class="s2">\n                    </span><span class="s1">const child = children[i];</span><span class="s2">\n                    </span><span class="s1">unmount(child, parentComponent, parentSuspense, true, !!child.dynamicChildren);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">move: moveTeleport,</span><span class="s2">\n    </span><span class="s1">hydrate: hydrateTeleport</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2 /* TeleportMoveTypes.REORDER */) {</span><span class="s2">\n    </span><span class="s1">// move target anchor if this is a target change.</span><span class="s2">\n    </span><span class="s1">if (moveType === 0 /* TeleportMoveTypes.TARGET_CHANGE */) {</span><span class="s2">\n        </span><span class="s1">insert(vnode.targetAnchor, container, parentAnchor);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">const { el, anchor, shapeFlag, children, props } = vnode;</span><span class="s2">\n    </span><span class="s1">const isReorder = moveType === 2 /* TeleportMoveTypes.REORDER */;</span><span class="s2">\n    </span><span class="s1">// move main view anchor if this is a re-order.</span><span class="s2">\n    </span><span class="s1">if (isReorder) {</span><span class="s2">\n        </span><span class="s1">insert(el, container, parentAnchor);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// if this is a re-order and teleport is enabled (content is in target)</span><span class="s2">\n    </span><span class="s1">// do not move children. So the opposite is: only move children if this</span><span class="s2">\n    </span><span class="s1">// is not a reorder, or the teleport is disabled</span><span class="s2">\n    </span><span class="s1">if (!isReorder || isTeleportDisabled(props)) {</span><span class="s2">\n        </span><span class="s1">// Teleport has either Array children or no children.</span><span class="s2">\n        </span><span class="s1">if (shapeFlag &amp; 16 /* ShapeFlags.ARRAY_CHILDREN */) {</span><span class="s2">\n            </span><span class="s1">for (let i = 0; i &lt; children.length; i++) {</span><span class="s2">\n                </span><span class="s1">move(children[i], container, parentAnchor, 2 /* MoveType.REORDER */);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// move main view anchor if this is a re-order.</span><span class="s2">\n    </span><span class="s1">if (isReorder) {</span><span class="s2">\n        </span><span class="s1">insert(anchor, container, parentAnchor);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, { o: { nextSibling, parentNode, querySelector } }, hydrateChildren) {</span><span class="s2">\n    </span><span class="s1">const target = (vnode.target = resolveTarget(vnode.props, querySelector));</span><span class="s2">\n    </span><span class="s1">if (target) {</span><span class="s2">\n        </span><span class="s1">// if multiple teleports rendered to the same target element, we need to</span><span class="s2">\n        </span><span class="s1">// pick up from where the last teleport finished instead of the first node</span><span class="s2">\n        </span><span class="s1">const targetNode = target._lpa || target.firstChild;</span><span class="s2">\n        </span><span class="s1">if (vnode.shapeFlag &amp; 16 /* ShapeFlags.ARRAY_CHILDREN */) {</span><span class="s2">\n            </span><span class="s1">if (isTeleportDisabled(vnode.props)) {</span><span class="s2">\n                </span><span class="s1">vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode(node), parentComponent, parentSuspense, slotScopeIds, optimized);</span><span class="s2">\n                </span><span class="s1">vnode.targetAnchor = targetNode;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">vnode.anchor = nextSibling(node);</span><span class="s2">\n                </span><span class="s1">// lookahead until we find the target anchor</span><span class="s2">\n                </span><span class="s1">// we cannot rely on return value of hydrateChildren() because there</span><span class="s2">\n                </span><span class="s1">// could be nested teleports</span><span class="s2">\n                </span><span class="s1">let targetAnchor = targetNode;</span><span class="s2">\n                </span><span class="s1">while (targetAnchor) {</span><span class="s2">\n                    </span><span class="s1">targetAnchor = nextSibling(targetAnchor);</span><span class="s2">\n                    </span><span class="s1">if (targetAnchor &amp;&amp;</span><span class="s2">\n                        </span><span class="s1">targetAnchor.nodeType === 8 &amp;&amp;</span><span class="s2">\n                        </span><span class="s1">targetAnchor.data === 'teleport anchor') {</span><span class="s2">\n                        </span><span class="s1">vnode.targetAnchor = targetAnchor;</span><span class="s2">\n                        </span><span class="s1">target._lpa =</span><span class="s2">\n                            </span><span class="s1">vnode.targetAnchor &amp;&amp; nextSibling(vnode.targetAnchor);</span><span class="s2">\n                        </span><span class="s1">break;</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">hydrateChildren(targetNode, vnode, target, parentComponent, parentSuspense, slotScopeIds, optimized);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">updateCssVars(vnode);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return vnode.anchor &amp;&amp; nextSibling(vnode.anchor);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// Force-casted public typing for h and TSX props inference</span><span class="s2">\n</span><span class="s1">const Teleport = TeleportImpl;</span><span class="s2">\n</span><span class="s1">function updateCssVars(vnode) {</span><span class="s2">\n    </span><span class="s1">// presence of .ut method indicates owner component uses css vars.</span><span class="s2">\n    </span><span class="s1">// code path here can assume browser environment.</span><span class="s2">\n    </span><span class="s1">const ctx = vnode.ctx;</span><span class="s2">\n    </span><span class="s1">if (ctx &amp;&amp; ctx.ut) {</span><span class="s2">\n        </span><span class="s1">let node = vnode.children[0].el;</span><span class="s2">\n        </span><span class="s1">while (node !== vnode.targetAnchor) {</span><span class="s2">\n            </span><span class="s1">if (node.nodeType === 1)</span><span class="s2">\n                </span><span class="s1">node.setAttribute('data-v-owner', ctx.uid);</span><span class="s2">\n            </span><span class="s1">node = node.nextSibling;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">ctx.ut();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">const Fragment = Symbol((process.env.NODE_ENV !== 'production') ? 'Fragment' : undefined);</span><span class="s2">\n</span><span class="s1">const Text = Symbol((process.env.NODE_ENV !== 'production') ? 'Text' : undefined);</span><span class="s2">\n</span><span class="s1">const Comment = Symbol((process.env.NODE_ENV !== 'production') ? 'Comment' : undefined);</span><span class="s2">\n</span><span class="s1">const Static = Symbol((process.env.NODE_ENV !== 'production') ? 'Static' : undefined);</span><span class="s2">\n</span><span class="s1">// Since v-if and v-for are the two possible ways node structure can dynamically</span><span class="s2">\n</span><span class="s1">// change, once we consider v-if branches and each v-for fragment a block, we</span><span class="s2">\n</span><span class="s1">// can divide a template into nested blocks, and within each block the node</span><span class="s2">\n</span><span class="s1">// structure would be stable. This allows us to skip most children diffing</span><span class="s2">\n</span><span class="s1">// and only worry about the dynamic nodes (indicated by patch flags).</span><span class="s2">\n</span><span class="s1">const blockStack = [];</span><span class="s2">\n</span><span class="s1">let currentBlock = null;</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Open a block.</span><span class="s2">\n </span><span class="s1">* This must be called before `createBlock`. It cannot be part of `createBlock`</span><span class="s2">\n </span><span class="s1">* because the children of the block are evaluated before `createBlock` itself</span><span class="s2">\n </span><span class="s1">* is called. The generated code typically looks like this:</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* ```js</span><span class="s2">\n </span><span class="s1">* function render() {</span><span class="s2">\n </span><span class="s1">*   return (openBlock(),createBlock('div', null, [...]))</span><span class="s2">\n </span><span class="s1">* }</span><span class="s2">\n </span><span class="s1">* ```</span><span class="s2">\n </span><span class="s1">* disableTracking is true when creating a v-for fragment block, since a v-for</span><span class="s2">\n </span><span class="s1">* fragment always diffs its children.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @private</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function openBlock(disableTracking = false) {</span><span class="s2">\n    </span><span class="s1">blockStack.push((currentBlock = disableTracking ? null : []));</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function closeBlock() {</span><span class="s2">\n    </span><span class="s1">blockStack.pop();</span><span class="s2">\n    </span><span class="s1">currentBlock = blockStack[blockStack.length - 1] || null;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// Whether we should be tracking dynamic child nodes inside a block.</span><span class="s2">\n</span><span class="s1">// Only tracks when this value is &gt; 0</span><span class="s2">\n</span><span class="s1">// We are not using a simple boolean because this value may need to be</span><span class="s2">\n</span><span class="s1">// incremented/decremented by nested usage of v-once (see below)</span><span class="s2">\n</span><span class="s1">let isBlockTreeEnabled = 1;</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Block tracking sometimes needs to be disabled, for example during the</span><span class="s2">\n </span><span class="s1">* creation of a tree that needs to be cached by v-once. The compiler generates</span><span class="s2">\n </span><span class="s1">* code like this:</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* ``` js</span><span class="s2">\n </span><span class="s1">* _cache[1] || (</span><span class="s2">\n </span><span class="s1">*   setBlockTracking(-1),</span><span class="s2">\n </span><span class="s1">*   _cache[1] = createVNode(...),</span><span class="s2">\n </span><span class="s1">*   setBlockTracking(1),</span><span class="s2">\n </span><span class="s1">*   _cache[1]</span><span class="s2">\n </span><span class="s1">* )</span><span class="s2">\n </span><span class="s1">* ```</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @private</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function setBlockTracking(value) {</span><span class="s2">\n    </span><span class="s1">isBlockTreeEnabled += value;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function setupBlock(vnode) {</span><span class="s2">\n    </span><span class="s1">// save current block children on the block vnode</span><span class="s2">\n    </span><span class="s1">vnode.dynamicChildren =</span><span class="s2">\n        </span><span class="s1">isBlockTreeEnabled &gt; 0 ? currentBlock || EMPTY_ARR : null;</span><span class="s2">\n    </span><span class="s1">// close block</span><span class="s2">\n    </span><span class="s1">closeBlock();</span><span class="s2">\n    </span><span class="s1">// a block is always going to be patched, so track it as a child of its</span><span class="s2">\n    </span><span class="s1">// parent block</span><span class="s2">\n    </span><span class="s1">if (isBlockTreeEnabled &gt; 0 &amp;&amp; currentBlock) {</span><span class="s2">\n        </span><span class="s1">currentBlock.push(vnode);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return vnode;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* @private</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {</span><span class="s2">\n    </span><span class="s1">return setupBlock(createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, true /* isBlock */));</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Create a block root vnode. Takes the same exact arguments as `createVNode`.</span><span class="s2">\n </span><span class="s1">* A block root keeps track of dynamic nodes within the block in the</span><span class="s2">\n </span><span class="s1">* `dynamicChildren` array.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* @private</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function createBlock(type, props, children, patchFlag, dynamicProps) {</span><span class="s2">\n    </span><span class="s1">return setupBlock(createVNode(type, props, children, patchFlag, dynamicProps, true /* isBlock: prevent a block from tracking itself */));</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isVNode(value) {</span><span class="s2">\n    </span><span class="s1">return value ? value.__v_isVNode === true : false;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isSameVNodeType(n1, n2) {</span><span class="s2">\n    </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp;</span><span class="s2">\n        </span><span class="s1">n2.shapeFlag &amp; 6 /* ShapeFlags.COMPONENT */ &amp;&amp;</span><span class="s2">\n        </span><span class="s1">hmrDirtyComponents.has(n2.type)) {</span><span class="s2">\n        </span><span class="s1">// #7042, ensure the vnode being unmounted during HMR</span><span class="s2">\n        </span><span class="s1">// bitwise operations to remove keep alive flags</span><span class="s2">\n        </span><span class="s1">n1.shapeFlag &amp;= ~256 /* ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE */;</span><span class="s2">\n        </span><span class="s1">n2.shapeFlag &amp;= ~512 /* ShapeFlags.COMPONENT_KEPT_ALIVE */;</span><span class="s2">\n        </span><span class="s1">// HMR only: if the component has been hot-updated, force a reload.</span><span class="s2">\n        </span><span class="s1">return false;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return n1.type === n2.type &amp;&amp; n1.key === n2.key;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">let vnodeArgsTransformer;</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Internal API for registering an arguments transform for createVNode</span><span class="s2">\n </span><span class="s1">* used for creating stubs in the test-utils</span><span class="s2">\n </span><span class="s1">* It is *internal* but needs to be exposed for test-utils to pick up proper</span><span class="s2">\n </span><span class="s1">* typings</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function transformVNodeArgs(transformer) {</span><span class="s2">\n    </span><span class="s1">vnodeArgsTransformer = transformer;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">const createVNodeWithArgsTransform = (...args) =&gt; {</span><span class="s2">\n    </span><span class="s1">return _createVNode(...(vnodeArgsTransformer</span><span class="s2">\n        </span><span class="s1">? vnodeArgsTransformer(args, currentRenderingInstance)</span><span class="s2">\n        </span><span class="s1">: args));</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">const InternalObjectKey = `__vInternal`;</span><span class="s2">\n</span><span class="s1">const normalizeKey = ({ key }) =&gt; key != null ? key : null;</span><span class="s2">\n</span><span class="s1">const normalizeRef = ({ ref, ref_key, ref_for }) =&gt; {</span><span class="s2">\n    </span><span class="s1">return (ref != null</span><span class="s2">\n        </span><span class="s1">? isString(ref) || isRef(ref) || isFunction(ref)</span><span class="s2">\n            </span><span class="s1">? { i: currentRenderingInstance, r: ref, k: ref_key, f: !!ref_for }</span><span class="s2">\n            </span><span class="s1">: ref</span><span class="s2">\n        </span><span class="s1">: null);</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1 /* ShapeFlags.ELEMENT */, isBlockNode = false, needFullChildrenNormalization = false) {</span><span class="s2">\n    </span><span class="s1">const vnode = {</span><span class="s2">\n        </span><span class="s1">__v_isVNode: true,</span><span class="s2">\n        </span><span class="s1">__v_skip: true,</span><span class="s2">\n        </span><span class="s1">type,</span><span class="s2">\n        </span><span class="s1">props,</span><span class="s2">\n        </span><span class="s1">key: props &amp;&amp; normalizeKey(props),</span><span class="s2">\n        </span><span class="s1">ref: props &amp;&amp; normalizeRef(props),</span><span class="s2">\n        </span><span class="s1">scopeId: currentScopeId,</span><span class="s2">\n        </span><span class="s1">slotScopeIds: null,</span><span class="s2">\n        </span><span class="s1">children,</span><span class="s2">\n        </span><span class="s1">component: null,</span><span class="s2">\n        </span><span class="s1">suspense: null,</span><span class="s2">\n        </span><span class="s1">ssContent: null,</span><span class="s2">\n        </span><span class="s1">ssFallback: null,</span><span class="s2">\n        </span><span class="s1">dirs: null,</span><span class="s2">\n        </span><span class="s1">transition: null,</span><span class="s2">\n        </span><span class="s1">el: null,</span><span class="s2">\n        </span><span class="s1">anchor: null,</span><span class="s2">\n        </span><span class="s1">target: null,</span><span class="s2">\n        </span><span class="s1">targetAnchor: null,</span><span class="s2">\n        </span><span class="s1">staticCount: 0,</span><span class="s2">\n        </span><span class="s1">shapeFlag,</span><span class="s2">\n        </span><span class="s1">patchFlag,</span><span class="s2">\n        </span><span class="s1">dynamicProps,</span><span class="s2">\n        </span><span class="s1">dynamicChildren: null,</span><span class="s2">\n        </span><span class="s1">appContext: null,</span><span class="s2">\n        </span><span class="s1">ctx: currentRenderingInstance</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">if (needFullChildrenNormalization) {</span><span class="s2">\n        </span><span class="s1">normalizeChildren(vnode, children);</span><span class="s2">\n        </span><span class="s1">// normalize suspense children</span><span class="s2">\n        </span><span class="s1">if (shapeFlag &amp; 128 /* ShapeFlags.SUSPENSE */) {</span><span class="s2">\n            </span><span class="s1">type.normalize(vnode);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (children) {</span><span class="s2">\n        </span><span class="s1">// compiled element vnode - if children is passed, only possible types are</span><span class="s2">\n        </span><span class="s1">// string or Array.</span><span class="s2">\n        </span><span class="s1">vnode.shapeFlag |= isString(children)</span><span class="s2">\n            </span><span class="s1">? 8 /* ShapeFlags.TEXT_CHILDREN */</span><span class="s2">\n            </span><span class="s1">: 16 /* ShapeFlags.ARRAY_CHILDREN */;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// validate key</span><span class="s2">\n    </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp; vnode.key !== vnode.key) {</span><span class="s2">\n        </span><span class="s1">warn(`VNode created with invalid key (NaN). VNode type:`, vnode.type);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// track vnode for block tree</span><span class="s2">\n    </span><span class="s1">if (isBlockTreeEnabled &gt; 0 &amp;&amp;</span><span class="s2">\n        </span><span class="s1">// avoid a block node from tracking itself</span><span class="s2">\n        </span><span class="s1">!isBlockNode &amp;&amp;</span><span class="s2">\n        </span><span class="s1">// has current parent block</span><span class="s2">\n        </span><span class="s1">currentBlock &amp;&amp;</span><span class="s2">\n        </span><span class="s1">// presence of a patch flag indicates this node needs patching on updates.</span><span class="s2">\n        </span><span class="s1">// component nodes also should always be patched, because even if the</span><span class="s2">\n        </span><span class="s1">// component doesn't need to update, it needs to persist the instance on to</span><span class="s2">\n        </span><span class="s1">// the next vnode so that it can be properly unmounted later.</span><span class="s2">\n        </span><span class="s1">(vnode.patchFlag &gt; 0 || shapeFlag &amp; 6 /* ShapeFlags.COMPONENT */) &amp;&amp;</span><span class="s2">\n        </span><span class="s1">// the EVENTS flag is only for hydration and if it is the only flag, the</span><span class="s2">\n        </span><span class="s1">// vnode should not be considered dynamic due to handler caching.</span><span class="s2">\n        </span><span class="s1">vnode.patchFlag !== 32 /* PatchFlags.HYDRATE_EVENTS */) {</span><span class="s2">\n        </span><span class="s1">currentBlock.push(vnode);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return vnode;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">const createVNode = ((process.env.NODE_ENV !== 'production') ? createVNodeWithArgsTransform : _createVNode);</span><span class="s2">\n</span><span class="s1">function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {</span><span class="s2">\n    </span><span class="s1">if (!type || type === NULL_DYNAMIC_COMPONENT) {</span><span class="s2">\n        </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp; !type) {</span><span class="s2">\n            </span><span class="s1">warn(`Invalid vnode type when creating vnode: ${type}.`);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">type = Comment;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (isVNode(type)) {</span><span class="s2">\n        </span><span class="s1">// createVNode receiving an existing vnode. This happens in cases like</span><span class="s2">\n        </span><span class="s1">// &lt;component :is=</span><span class="s2">\&quot;</span><span class="s1">vnode</span><span class="s2">\&quot;</span><span class="s1">/&gt;</span><span class="s2">\n        </span><span class="s1">// #2078 make sure to merge refs during the clone instead of overwriting it</span><span class="s2">\n        </span><span class="s1">const cloned = cloneVNode(type, props, true /* mergeRef: true */);</span><span class="s2">\n        </span><span class="s1">if (children) {</span><span class="s2">\n            </span><span class="s1">normalizeChildren(cloned, children);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (isBlockTreeEnabled &gt; 0 &amp;&amp; !isBlockNode &amp;&amp; currentBlock) {</span><span class="s2">\n            </span><span class="s1">if (cloned.shapeFlag &amp; 6 /* ShapeFlags.COMPONENT */) {</span><span class="s2">\n                </span><span class="s1">currentBlock[currentBlock.indexOf(type)] = cloned;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">currentBlock.push(cloned);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">cloned.patchFlag |= -2 /* PatchFlags.BAIL */;</span><span class="s2">\n        </span><span class="s1">return cloned;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// class component normalization.</span><span class="s2">\n    </span><span class="s1">if (isClassComponent(type)) {</span><span class="s2">\n        </span><span class="s1">type = type.__vccOpts;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// class &amp; style normalization.</span><span class="s2">\n    </span><span class="s1">if (props) {</span><span class="s2">\n        </span><span class="s1">// for reactive or proxy objects, we need to clone it to enable mutation.</span><span class="s2">\n        </span><span class="s1">props = guardReactiveProps(props);</span><span class="s2">\n        </span><span class="s1">let { class: klass, style } = props;</span><span class="s2">\n        </span><span class="s1">if (klass &amp;&amp; !isString(klass)) {</span><span class="s2">\n            </span><span class="s1">props.class = normalizeClass(klass);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (isObject(style)) {</span><span class="s2">\n            </span><span class="s1">// reactive state objects need to be cloned since they are likely to be</span><span class="s2">\n            </span><span class="s1">// mutated</span><span class="s2">\n            </span><span class="s1">if (isProxy(style) &amp;&amp; !isArray(style)) {</span><span class="s2">\n                </span><span class="s1">style = extend({}, style);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">props.style = normalizeStyle(style);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// encode the vnode type information into a bitmap</span><span class="s2">\n    </span><span class="s1">const shapeFlag = isString(type)</span><span class="s2">\n        </span><span class="s1">? 1 /* ShapeFlags.ELEMENT */</span><span class="s2">\n        </span><span class="s1">: isSuspense(type)</span><span class="s2">\n            </span><span class="s1">? 128 /* ShapeFlags.SUSPENSE */</span><span class="s2">\n            </span><span class="s1">: isTeleport(type)</span><span class="s2">\n                </span><span class="s1">? 64 /* ShapeFlags.TELEPORT */</span><span class="s2">\n                </span><span class="s1">: isObject(type)</span><span class="s2">\n                    </span><span class="s1">? 4 /* ShapeFlags.STATEFUL_COMPONENT */</span><span class="s2">\n                    </span><span class="s1">: isFunction(type)</span><span class="s2">\n                        </span><span class="s1">? 2 /* ShapeFlags.FUNCTIONAL_COMPONENT */</span><span class="s2">\n                        </span><span class="s1">: 0;</span><span class="s2">\n    </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp; shapeFlag &amp; 4 /* ShapeFlags.STATEFUL_COMPONENT */ &amp;&amp; isProxy(type)) {</span><span class="s2">\n        </span><span class="s1">type = toRaw(type);</span><span class="s2">\n        </span><span class="s1">warn(`Vue received a Component which was made a reactive object. This can ` +</span><span class="s2">\n            </span><span class="s1">`lead to unnecessary performance overhead, and should be avoided by ` +</span><span class="s2">\n            </span><span class="s1">`marking the component with </span><span class="s2">\\</span><span class="s1">`markRaw</span><span class="s2">\\</span><span class="s1">` or using </span><span class="s2">\\</span><span class="s1">`shallowRef</span><span class="s2">\\</span><span class="s1">` ` +</span><span class="s2">\n            </span><span class="s1">`instead of </span><span class="s2">\\</span><span class="s1">`ref</span><span class="s2">\\</span><span class="s1">`.`, `</span><span class="s2">\\</span><span class="s1">nComponent that was made reactive: `, type);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function guardReactiveProps(props) {</span><span class="s2">\n    </span><span class="s1">if (!props)</span><span class="s2">\n        </span><span class="s1">return null;</span><span class="s2">\n    </span><span class="s1">return isProxy(props) || InternalObjectKey in props</span><span class="s2">\n        </span><span class="s1">? extend({}, props)</span><span class="s2">\n        </span><span class="s1">: props;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function cloneVNode(vnode, extraProps, mergeRef = false) {</span><span class="s2">\n    </span><span class="s1">// This is intentionally NOT using spread or extend to avoid the runtime</span><span class="s2">\n    </span><span class="s1">// key enumeration cost.</span><span class="s2">\n    </span><span class="s1">const { props, ref, patchFlag, children } = vnode;</span><span class="s2">\n    </span><span class="s1">const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;</span><span class="s2">\n    </span><span class="s1">const cloned = {</span><span class="s2">\n        </span><span class="s1">__v_isVNode: true,</span><span class="s2">\n        </span><span class="s1">__v_skip: true,</span><span class="s2">\n        </span><span class="s1">type: vnode.type,</span><span class="s2">\n        </span><span class="s1">props: mergedProps,</span><span class="s2">\n        </span><span class="s1">key: mergedProps &amp;&amp; normalizeKey(mergedProps),</span><span class="s2">\n        </span><span class="s1">ref: extraProps &amp;&amp; extraProps.ref</span><span class="s2">\n            </span><span class="s1">? // #2078 in the case of &lt;component :is=</span><span class="s2">\&quot;</span><span class="s1">vnode</span><span class="s2">\&quot; </span><span class="s1">ref=</span><span class="s2">\&quot;</span><span class="s1">extra</span><span class="s2">\&quot;</span><span class="s1">/&gt;</span><span class="s2">\n                </span><span class="s1">// if the vnode itself already has a ref, cloneVNode will need to merge</span><span class="s2">\n                </span><span class="s1">// the refs so the single vnode can be set on multiple refs</span><span class="s2">\n                </span><span class="s1">mergeRef &amp;&amp; ref</span><span class="s2">\n                    </span><span class="s1">? isArray(ref)</span><span class="s2">\n                        </span><span class="s1">? ref.concat(normalizeRef(extraProps))</span><span class="s2">\n                        </span><span class="s1">: [ref, normalizeRef(extraProps)]</span><span class="s2">\n                    </span><span class="s1">: normalizeRef(extraProps)</span><span class="s2">\n            </span><span class="s1">: ref,</span><span class="s2">\n        </span><span class="s1">scopeId: vnode.scopeId,</span><span class="s2">\n        </span><span class="s1">slotScopeIds: vnode.slotScopeIds,</span><span class="s2">\n        </span><span class="s1">children: (process.env.NODE_ENV !== 'production') &amp;&amp; patchFlag === -1 /* PatchFlags.HOISTED */ &amp;&amp; isArray(children)</span><span class="s2">\n            </span><span class="s1">? children.map(deepCloneVNode)</span><span class="s2">\n            </span><span class="s1">: children,</span><span class="s2">\n        </span><span class="s1">target: vnode.target,</span><span class="s2">\n        </span><span class="s1">targetAnchor: vnode.targetAnchor,</span><span class="s2">\n        </span><span class="s1">staticCount: vnode.staticCount,</span><span class="s2">\n        </span><span class="s1">shapeFlag: vnode.shapeFlag,</span><span class="s2">\n        </span><span class="s1">// if the vnode is cloned with extra props, we can no longer assume its</span><span class="s2">\n        </span><span class="s1">// existing patch flag to be reliable and need to add the FULL_PROPS flag.</span><span class="s2">\n        </span><span class="s1">// note: preserve flag for fragments since they use the flag for children</span><span class="s2">\n        </span><span class="s1">// fast paths only.</span><span class="s2">\n        </span><span class="s1">patchFlag: extraProps &amp;&amp; vnode.type !== Fragment</span><span class="s2">\n            </span><span class="s1">? patchFlag === -1 // hoisted node</span><span class="s2">\n                </span><span class="s1">? 16 /* PatchFlags.FULL_PROPS */</span><span class="s2">\n                </span><span class="s1">: patchFlag | 16 /* PatchFlags.FULL_PROPS */</span><span class="s2">\n            </span><span class="s1">: patchFlag,</span><span class="s2">\n        </span><span class="s1">dynamicProps: vnode.dynamicProps,</span><span class="s2">\n        </span><span class="s1">dynamicChildren: vnode.dynamicChildren,</span><span class="s2">\n        </span><span class="s1">appContext: vnode.appContext,</span><span class="s2">\n        </span><span class="s1">dirs: vnode.dirs,</span><span class="s2">\n        </span><span class="s1">transition: vnode.transition,</span><span class="s2">\n        </span><span class="s1">// These should technically only be non-null on mounted VNodes. However,</span><span class="s2">\n        </span><span class="s1">// they *should* be copied for kept-alive vnodes. So we just always copy</span><span class="s2">\n        </span><span class="s1">// them since them being non-null during a mount doesn't affect the logic as</span><span class="s2">\n        </span><span class="s1">// they will simply be overwritten.</span><span class="s2">\n        </span><span class="s1">component: vnode.component,</span><span class="s2">\n        </span><span class="s1">suspense: vnode.suspense,</span><span class="s2">\n        </span><span class="s1">ssContent: vnode.ssContent &amp;&amp; cloneVNode(vnode.ssContent),</span><span class="s2">\n        </span><span class="s1">ssFallback: vnode.ssFallback &amp;&amp; cloneVNode(vnode.ssFallback),</span><span class="s2">\n        </span><span class="s1">el: vnode.el,</span><span class="s2">\n        </span><span class="s1">anchor: vnode.anchor,</span><span class="s2">\n        </span><span class="s1">ctx: vnode.ctx,</span><span class="s2">\n        </span><span class="s1">ce: vnode.ce</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">return cloned;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Dev only, for HMR of hoisted vnodes reused in v-for</span><span class="s2">\n </span><span class="s1">* https://github.com/vitejs/vite/issues/2022</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function deepCloneVNode(vnode) {</span><span class="s2">\n    </span><span class="s1">const cloned = cloneVNode(vnode);</span><span class="s2">\n    </span><span class="s1">if (isArray(vnode.children)) {</span><span class="s2">\n        </span><span class="s1">cloned.children = vnode.children.map(deepCloneVNode);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return cloned;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* @private</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function createTextVNode(text = ' ', flag = 0) {</span><span class="s2">\n    </span><span class="s1">return createVNode(Text, null, text, flag);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* @private</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function createStaticVNode(content, numberOfNodes) {</span><span class="s2">\n    </span><span class="s1">// A static vnode can contain multiple stringified elements, and the number</span><span class="s2">\n    </span><span class="s1">// of elements is necessary for hydration.</span><span class="s2">\n    </span><span class="s1">const vnode = createVNode(Static, null, content);</span><span class="s2">\n    </span><span class="s1">vnode.staticCount = numberOfNodes;</span><span class="s2">\n    </span><span class="s1">return vnode;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* @private</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function createCommentVNode(text = '', </span><span class="s2">\n</span><span class="s1">// when used as the v-else branch, the comment node must be created as a</span><span class="s2">\n</span><span class="s1">// block to ensure correct updates.</span><span class="s2">\n</span><span class="s1">asBlock = false) {</span><span class="s2">\n    </span><span class="s1">return asBlock</span><span class="s2">\n        </span><span class="s1">? (openBlock(), createBlock(Comment, null, text))</span><span class="s2">\n        </span><span class="s1">: createVNode(Comment, null, text);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function normalizeVNode(child) {</span><span class="s2">\n    </span><span class="s1">if (child == null || typeof child === 'boolean') {</span><span class="s2">\n        </span><span class="s1">// empty placeholder</span><span class="s2">\n        </span><span class="s1">return createVNode(Comment);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (isArray(child)) {</span><span class="s2">\n        </span><span class="s1">// fragment</span><span class="s2">\n        </span><span class="s1">return createVNode(Fragment, null, </span><span class="s2">\n        </span><span class="s1">// #3666, avoid reference pollution when reusing vnode</span><span class="s2">\n        </span><span class="s1">child.slice());</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (typeof child === 'object') {</span><span class="s2">\n        </span><span class="s1">// already vnode, this should be the most common since compiled templates</span><span class="s2">\n        </span><span class="s1">// always produce all-vnode children arrays</span><span class="s2">\n        </span><span class="s1">return cloneIfMounted(child);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">// strings and numbers</span><span class="s2">\n        </span><span class="s1">return createVNode(Text, null, String(child));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// optimized normalization for template-compiled render fns</span><span class="s2">\n</span><span class="s1">function cloneIfMounted(child) {</span><span class="s2">\n    </span><span class="s1">return (child.el === null &amp;&amp; child.patchFlag !== -1 /* PatchFlags.HOISTED */) ||</span><span class="s2">\n        </span><span class="s1">child.memo</span><span class="s2">\n        </span><span class="s1">? child</span><span class="s2">\n        </span><span class="s1">: cloneVNode(child);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function normalizeChildren(vnode, children) {</span><span class="s2">\n    </span><span class="s1">let type = 0;</span><span class="s2">\n    </span><span class="s1">const { shapeFlag } = vnode;</span><span class="s2">\n    </span><span class="s1">if (children == null) {</span><span class="s2">\n        </span><span class="s1">children = null;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (isArray(children)) {</span><span class="s2">\n        </span><span class="s1">type = 16 /* ShapeFlags.ARRAY_CHILDREN */;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (typeof children === 'object') {</span><span class="s2">\n        </span><span class="s1">if (shapeFlag &amp; (1 /* ShapeFlags.ELEMENT */ | 64 /* ShapeFlags.TELEPORT */)) {</span><span class="s2">\n            </span><span class="s1">// Normalize slot to plain children for plain element and Teleport</span><span class="s2">\n            </span><span class="s1">const slot = children.default;</span><span class="s2">\n            </span><span class="s1">if (slot) {</span><span class="s2">\n                </span><span class="s1">// _c marker is added by withCtx() indicating this is a compiled slot</span><span class="s2">\n                </span><span class="s1">slot._c &amp;&amp; (slot._d = false);</span><span class="s2">\n                </span><span class="s1">normalizeChildren(vnode, slot());</span><span class="s2">\n                </span><span class="s1">slot._c &amp;&amp; (slot._d = true);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">type = 32 /* ShapeFlags.SLOTS_CHILDREN */;</span><span class="s2">\n            </span><span class="s1">const slotFlag = children._;</span><span class="s2">\n            </span><span class="s1">if (!slotFlag &amp;&amp; !(InternalObjectKey in children)) {</span><span class="s2">\n                </span><span class="s1">children._ctx = currentRenderingInstance;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else if (slotFlag === 3 /* SlotFlags.FORWARDED */ &amp;&amp; currentRenderingInstance) {</span><span class="s2">\n                </span><span class="s1">// a child component receives forwarded slots from the parent.</span><span class="s2">\n                </span><span class="s1">// its slot type is determined by its parent's slot type.</span><span class="s2">\n                </span><span class="s1">if (currentRenderingInstance.slots._ === 1 /* SlotFlags.STABLE */) {</span><span class="s2">\n                    </span><span class="s1">children._ = 1 /* SlotFlags.STABLE */;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else {</span><span class="s2">\n                    </span><span class="s1">children._ = 2 /* SlotFlags.DYNAMIC */;</span><span class="s2">\n                    </span><span class="s1">vnode.patchFlag |= 1024 /* PatchFlags.DYNAMIC_SLOTS */;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (isFunction(children)) {</span><span class="s2">\n        </span><span class="s1">children = { default: children, _ctx: currentRenderingInstance };</span><span class="s2">\n        </span><span class="s1">type = 32 /* ShapeFlags.SLOTS_CHILDREN */;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">children = String(children);</span><span class="s2">\n        </span><span class="s1">// force teleport children to array so it can be moved around</span><span class="s2">\n        </span><span class="s1">if (shapeFlag &amp; 64 /* ShapeFlags.TELEPORT */) {</span><span class="s2">\n            </span><span class="s1">type = 16 /* ShapeFlags.ARRAY_CHILDREN */;</span><span class="s2">\n            </span><span class="s1">children = [createTextVNode(children)];</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">type = 8 /* ShapeFlags.TEXT_CHILDREN */;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">vnode.children = children;</span><span class="s2">\n    </span><span class="s1">vnode.shapeFlag |= type;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function mergeProps(...args) {</span><span class="s2">\n    </span><span class="s1">const ret = {};</span><span class="s2">\n    </span><span class="s1">for (let i = 0; i &lt; args.length; i++) {</span><span class="s2">\n        </span><span class="s1">const toMerge = args[i];</span><span class="s2">\n        </span><span class="s1">for (const key in toMerge) {</span><span class="s2">\n            </span><span class="s1">if (key === 'class') {</span><span class="s2">\n                </span><span class="s1">if (ret.class !== toMerge.class) {</span><span class="s2">\n                    </span><span class="s1">ret.class = normalizeClass([ret.class, toMerge.class]);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else if (key === 'style') {</span><span class="s2">\n                </span><span class="s1">ret.style = normalizeStyle([ret.style, toMerge.style]);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else if (isOn(key)) {</span><span class="s2">\n                </span><span class="s1">const existing = ret[key];</span><span class="s2">\n                </span><span class="s1">const incoming = toMerge[key];</span><span class="s2">\n                </span><span class="s1">if (incoming &amp;&amp;</span><span class="s2">\n                    </span><span class="s1">existing !== incoming &amp;&amp;</span><span class="s2">\n                    </span><span class="s1">!(isArray(existing) &amp;&amp; existing.includes(incoming))) {</span><span class="s2">\n                    </span><span class="s1">ret[key] = existing</span><span class="s2">\n                        </span><span class="s1">? [].concat(existing, incoming)</span><span class="s2">\n                        </span><span class="s1">: incoming;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else if (key !== '') {</span><span class="s2">\n                </span><span class="s1">ret[key] = toMerge[key];</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return ret;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {</span><span class="s2">\n    </span><span class="s1">callWithAsyncErrorHandling(hook, instance, 7 /* ErrorCodes.VNODE_HOOK */, [</span><span class="s2">\n        </span><span class="s1">vnode,</span><span class="s2">\n        </span><span class="s1">prevVNode</span><span class="s2">\n    </span><span class="s1">]);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">const emptyAppContext = createAppContext();</span><span class="s2">\n</span><span class="s1">let uid = 0;</span><span class="s2">\n</span><span class="s1">function createComponentInstance(vnode, parent, suspense) {</span><span class="s2">\n    </span><span class="s1">const type = vnode.type;</span><span class="s2">\n    </span><span class="s1">// inherit parent app context - or - if root, adopt from root vnode</span><span class="s2">\n    </span><span class="s1">const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;</span><span class="s2">\n    </span><span class="s1">const instance = {</span><span class="s2">\n        </span><span class="s1">uid: uid++,</span><span class="s2">\n        </span><span class="s1">vnode,</span><span class="s2">\n        </span><span class="s1">type,</span><span class="s2">\n        </span><span class="s1">parent,</span><span class="s2">\n        </span><span class="s1">appContext,</span><span class="s2">\n        </span><span class="s1">root: null,</span><span class="s2">\n        </span><span class="s1">next: null,</span><span class="s2">\n        </span><span class="s1">subTree: null,</span><span class="s2">\n        </span><span class="s1">effect: null,</span><span class="s2">\n        </span><span class="s1">update: null,</span><span class="s2">\n        </span><span class="s1">scope: new EffectScope(true /* detached */),</span><span class="s2">\n        </span><span class="s1">render: null,</span><span class="s2">\n        </span><span class="s1">proxy: null,</span><span class="s2">\n        </span><span class="s1">exposed: null,</span><span class="s2">\n        </span><span class="s1">exposeProxy: null,</span><span class="s2">\n        </span><span class="s1">withProxy: null,</span><span class="s2">\n        </span><span class="s1">provides: parent ? parent.provides : Object.create(appContext.provides),</span><span class="s2">\n        </span><span class="s1">accessCache: null,</span><span class="s2">\n        </span><span class="s1">renderCache: [],</span><span class="s2">\n        </span><span class="s1">// local resolved assets</span><span class="s2">\n        </span><span class="s1">components: null,</span><span class="s2">\n        </span><span class="s1">directives: null,</span><span class="s2">\n        </span><span class="s1">// resolved props and emits options</span><span class="s2">\n        </span><span class="s1">propsOptions: normalizePropsOptions(type, appContext),</span><span class="s2">\n        </span><span class="s1">emitsOptions: normalizeEmitsOptions(type, appContext),</span><span class="s2">\n        </span><span class="s1">// emit</span><span class="s2">\n        </span><span class="s1">emit: null,</span><span class="s2">\n        </span><span class="s1">emitted: null,</span><span class="s2">\n        </span><span class="s1">// props default value</span><span class="s2">\n        </span><span class="s1">propsDefaults: EMPTY_OBJ,</span><span class="s2">\n        </span><span class="s1">// inheritAttrs</span><span class="s2">\n        </span><span class="s1">inheritAttrs: type.inheritAttrs,</span><span class="s2">\n        </span><span class="s1">// state</span><span class="s2">\n        </span><span class="s1">ctx: EMPTY_OBJ,</span><span class="s2">\n        </span><span class="s1">data: EMPTY_OBJ,</span><span class="s2">\n        </span><span class="s1">props: EMPTY_OBJ,</span><span class="s2">\n        </span><span class="s1">attrs: EMPTY_OBJ,</span><span class="s2">\n        </span><span class="s1">slots: EMPTY_OBJ,</span><span class="s2">\n        </span><span class="s1">refs: EMPTY_OBJ,</span><span class="s2">\n        </span><span class="s1">setupState: EMPTY_OBJ,</span><span class="s2">\n        </span><span class="s1">setupContext: null,</span><span class="s2">\n        </span><span class="s1">// suspense related</span><span class="s2">\n        </span><span class="s1">suspense,</span><span class="s2">\n        </span><span class="s1">suspenseId: suspense ? suspense.pendingId : 0,</span><span class="s2">\n        </span><span class="s1">asyncDep: null,</span><span class="s2">\n        </span><span class="s1">asyncResolved: false,</span><span class="s2">\n        </span><span class="s1">// lifecycle hooks</span><span class="s2">\n        </span><span class="s1">// not using enums here because it results in computed properties</span><span class="s2">\n        </span><span class="s1">isMounted: false,</span><span class="s2">\n        </span><span class="s1">isUnmounted: false,</span><span class="s2">\n        </span><span class="s1">isDeactivated: false,</span><span class="s2">\n        </span><span class="s1">bc: null,</span><span class="s2">\n        </span><span class="s1">c: null,</span><span class="s2">\n        </span><span class="s1">bm: null,</span><span class="s2">\n        </span><span class="s1">m: null,</span><span class="s2">\n        </span><span class="s1">bu: null,</span><span class="s2">\n        </span><span class="s1">u: null,</span><span class="s2">\n        </span><span class="s1">um: null,</span><span class="s2">\n        </span><span class="s1">bum: null,</span><span class="s2">\n        </span><span class="s1">da: null,</span><span class="s2">\n        </span><span class="s1">a: null,</span><span class="s2">\n        </span><span class="s1">rtg: null,</span><span class="s2">\n        </span><span class="s1">rtc: null,</span><span class="s2">\n        </span><span class="s1">ec: null,</span><span class="s2">\n        </span><span class="s1">sp: null</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n        </span><span class="s1">instance.ctx = createDevRenderContext(instance);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">instance.ctx = { _: instance };</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">instance.root = parent ? parent.root : instance;</span><span class="s2">\n    </span><span class="s1">instance.emit = emit.bind(null, instance);</span><span class="s2">\n    </span><span class="s1">// apply custom element special handling</span><span class="s2">\n    </span><span class="s1">if (vnode.ce) {</span><span class="s2">\n        </span><span class="s1">vnode.ce(instance);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return instance;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">let currentInstance = null;</span><span class="s2">\n</span><span class="s1">const getCurrentInstance = () =&gt; currentInstance || currentRenderingInstance;</span><span class="s2">\n</span><span class="s1">const setCurrentInstance = (instance) =&gt; {</span><span class="s2">\n    </span><span class="s1">currentInstance = instance;</span><span class="s2">\n    </span><span class="s1">instance.scope.on();</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">const unsetCurrentInstance = () =&gt; {</span><span class="s2">\n    </span><span class="s1">currentInstance &amp;&amp; currentInstance.scope.off();</span><span class="s2">\n    </span><span class="s1">currentInstance = null;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">const isBuiltInTag = /*#__PURE__*/ makeMap('slot,component');</span><span class="s2">\n</span><span class="s1">function validateComponentName(name, config) {</span><span class="s2">\n    </span><span class="s1">const appIsNativeTag = config.isNativeTag || NO;</span><span class="s2">\n    </span><span class="s1">if (isBuiltInTag(name) || appIsNativeTag(name)) {</span><span class="s2">\n        </span><span class="s1">warn('Do not use built-in or reserved HTML elements as component id: ' + name);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isStatefulComponent(instance) {</span><span class="s2">\n    </span><span class="s1">return instance.vnode.shapeFlag &amp; 4 /* ShapeFlags.STATEFUL_COMPONENT */;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">let isInSSRComponentSetup = false;</span><span class="s2">\n</span><span class="s1">function setupComponent(instance, isSSR = false) {</span><span class="s2">\n    </span><span class="s1">isInSSRComponentSetup = isSSR;</span><span class="s2">\n    </span><span class="s1">const { props, children } = instance.vnode;</span><span class="s2">\n    </span><span class="s1">const isStateful = isStatefulComponent(instance);</span><span class="s2">\n    </span><span class="s1">initProps(instance, props, isStateful, isSSR);</span><span class="s2">\n    </span><span class="s1">initSlots(instance, children);</span><span class="s2">\n    </span><span class="s1">const setupResult = isStateful</span><span class="s2">\n        </span><span class="s1">? setupStatefulComponent(instance, isSSR)</span><span class="s2">\n        </span><span class="s1">: undefined;</span><span class="s2">\n    </span><span class="s1">isInSSRComponentSetup = false;</span><span class="s2">\n    </span><span class="s1">return setupResult;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function setupStatefulComponent(instance, isSSR) {</span><span class="s2">\n    </span><span class="s1">var _a;</span><span class="s2">\n    </span><span class="s1">const Component = instance.type;</span><span class="s2">\n    </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n        </span><span class="s1">if (Component.name) {</span><span class="s2">\n            </span><span class="s1">validateComponentName(Component.name, instance.appContext.config);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (Component.components) {</span><span class="s2">\n            </span><span class="s1">const names = Object.keys(Component.components);</span><span class="s2">\n            </span><span class="s1">for (let i = 0; i &lt; names.length; i++) {</span><span class="s2">\n                </span><span class="s1">validateComponentName(names[i], instance.appContext.config);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (Component.directives) {</span><span class="s2">\n            </span><span class="s1">const names = Object.keys(Component.directives);</span><span class="s2">\n            </span><span class="s1">for (let i = 0; i &lt; names.length; i++) {</span><span class="s2">\n                </span><span class="s1">validateDirectiveName(names[i]);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (Component.compilerOptions &amp;&amp; isRuntimeOnly()) {</span><span class="s2">\n            </span><span class="s1">warn(`</span><span class="s2">\&quot;</span><span class="s1">compilerOptions</span><span class="s2">\&quot; </span><span class="s1">is only supported when using a build of Vue that ` +</span><span class="s2">\n                </span><span class="s1">`includes the runtime compiler. Since you are using a runtime-only ` +</span><span class="s2">\n                </span><span class="s1">`build, the options should be passed via your build tool config instead.`);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// 0. create render proxy property access cache</span><span class="s2">\n    </span><span class="s1">instance.accessCache = Object.create(null);</span><span class="s2">\n    </span><span class="s1">// 1. create public instance / render proxy</span><span class="s2">\n    </span><span class="s1">// also mark it raw so it's never observed</span><span class="s2">\n    </span><span class="s1">instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));</span><span class="s2">\n    </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n        </span><span class="s1">exposePropsOnRenderContext(instance);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// 2. call setup()</span><span class="s2">\n    </span><span class="s1">const { setup } = Component;</span><span class="s2">\n    </span><span class="s1">if (setup) {</span><span class="s2">\n        </span><span class="s1">const setupContext = (instance.setupContext =</span><span class="s2">\n            </span><span class="s1">setup.length &gt; 1 ? createSetupContext(instance) : null);</span><span class="s2">\n        </span><span class="s1">setCurrentInstance(instance);</span><span class="s2">\n        </span><span class="s1">pauseTracking();</span><span class="s2">\n        </span><span class="s1">const setupResult = callWithErrorHandling(setup, instance, 0 /* ErrorCodes.SETUP_FUNCTION */, [(process.env.NODE_ENV !== 'production') ? shallowReadonly(instance.props) : instance.props, setupContext]);</span><span class="s2">\n        </span><span class="s1">resetTracking();</span><span class="s2">\n        </span><span class="s1">unsetCurrentInstance();</span><span class="s2">\n        </span><span class="s1">if (isPromise(setupResult)) {</span><span class="s2">\n            </span><span class="s1">setupResult.then(unsetCurrentInstance, unsetCurrentInstance);</span><span class="s2">\n            </span><span class="s1">if (isSSR) {</span><span class="s2">\n                </span><span class="s1">// return the promise so server-renderer can wait on it</span><span class="s2">\n                </span><span class="s1">return setupResult</span><span class="s2">\n                    </span><span class="s1">.then((resolvedResult) =&gt; {</span><span class="s2">\n                    </span><span class="s1">handleSetupResult(instance, resolvedResult, isSSR);</span><span class="s2">\n                </span><span class="s1">})</span><span class="s2">\n                    </span><span class="s1">.catch(e =&gt; {</span><span class="s2">\n                    </span><span class="s1">handleError(e, instance, 0 /* ErrorCodes.SETUP_FUNCTION */);</span><span class="s2">\n                </span><span class="s1">});</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">// async setup returned Promise.</span><span class="s2">\n                </span><span class="s1">// bail here and wait for re-entry.</span><span class="s2">\n                </span><span class="s1">instance.asyncDep = setupResult;</span><span class="s2">\n                </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp; !instance.suspense) {</span><span class="s2">\n                    </span><span class="s1">const name = (_a = Component.name) !== null &amp;&amp; _a !== void 0 ? _a : 'Anonymous';</span><span class="s2">\n                    </span><span class="s1">warn(`Component &lt;${name}&gt;: setup function returned a promise, but no ` +</span><span class="s2">\n                        </span><span class="s1">`&lt;Suspense&gt; boundary was found in the parent component tree. ` +</span><span class="s2">\n                        </span><span class="s1">`A component with async setup() must be nested in a &lt;Suspense&gt; ` +</span><span class="s2">\n                        </span><span class="s1">`in order to be rendered.`);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">handleSetupResult(instance, setupResult, isSSR);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">finishComponentSetup(instance, isSSR);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function handleSetupResult(instance, setupResult, isSSR) {</span><span class="s2">\n    </span><span class="s1">if (isFunction(setupResult)) {</span><span class="s2">\n        </span><span class="s1">// setup returned an inline render function</span><span class="s2">\n        </span><span class="s1">if (instance.type.__ssrInlineRender) {</span><span class="s2">\n            </span><span class="s1">// when the function's name is `ssrRender` (compiled by SFC inline mode),</span><span class="s2">\n            </span><span class="s1">// set it as ssrRender instead.</span><span class="s2">\n            </span><span class="s1">instance.ssrRender = setupResult;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">instance.render = setupResult;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (isObject(setupResult)) {</span><span class="s2">\n        </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp; isVNode(setupResult)) {</span><span class="s2">\n            </span><span class="s1">warn(`setup() should not return VNodes directly - ` +</span><span class="s2">\n                </span><span class="s1">`return a render function instead.`);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// setup returned bindings.</span><span class="s2">\n        </span><span class="s1">// assuming a render function compiled from template is present.</span><span class="s2">\n        </span><span class="s1">if ((process.env.NODE_ENV !== 'production') || __VUE_PROD_DEVTOOLS__) {</span><span class="s2">\n            </span><span class="s1">instance.devtoolsRawSetupState = setupResult;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">instance.setupState = proxyRefs(setupResult);</span><span class="s2">\n        </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n            </span><span class="s1">exposeSetupStateOnRenderContext(instance);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if ((process.env.NODE_ENV !== 'production') &amp;&amp; setupResult !== undefined) {</span><span class="s2">\n        </span><span class="s1">warn(`setup() should return an object. Received: ${setupResult === null ? 'null' : typeof setupResult}`);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">finishComponentSetup(instance, isSSR);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">let compile;</span><span class="s2">\n</span><span class="s1">let installWithProxy;</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* For runtime-dom to register the compiler.</span><span class="s2">\n </span><span class="s1">* Note the exported method uses any to avoid d.ts relying on the compiler types.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function registerRuntimeCompiler(_compile) {</span><span class="s2">\n    </span><span class="s1">compile = _compile;</span><span class="s2">\n    </span><span class="s1">installWithProxy = i =&gt; {</span><span class="s2">\n        </span><span class="s1">if (i.render._rc) {</span><span class="s2">\n            </span><span class="s1">i.withProxy = new Proxy(i.ctx, RuntimeCompiledPublicInstanceProxyHandlers);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// dev only</span><span class="s2">\n</span><span class="s1">const isRuntimeOnly = () =&gt; !compile;</span><span class="s2">\n</span><span class="s1">function finishComponentSetup(instance, isSSR, skipOptions) {</span><span class="s2">\n    </span><span class="s1">const Component = instance.type;</span><span class="s2">\n    </span><span class="s1">// template / render function normalization</span><span class="s2">\n    </span><span class="s1">// could be already set when returned from setup()</span><span class="s2">\n    </span><span class="s1">if (!instance.render) {</span><span class="s2">\n        </span><span class="s1">// only do on-the-fly compile if not in SSR - SSR on-the-fly compilation</span><span class="s2">\n        </span><span class="s1">// is done by server-renderer</span><span class="s2">\n        </span><span class="s1">if (!isSSR &amp;&amp; compile &amp;&amp; !Component.render) {</span><span class="s2">\n            </span><span class="s1">const template = Component.template ||</span><span class="s2">\n                </span><span class="s1">resolveMergedOptions(instance).template;</span><span class="s2">\n            </span><span class="s1">if (template) {</span><span class="s2">\n                </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n                    </span><span class="s1">startMeasure(instance, `compile`);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">const { isCustomElement, compilerOptions } = instance.appContext.config;</span><span class="s2">\n                </span><span class="s1">const { delimiters, compilerOptions: componentCompilerOptions } = Component;</span><span class="s2">\n                </span><span class="s1">const finalCompilerOptions = extend(extend({</span><span class="s2">\n                    </span><span class="s1">isCustomElement,</span><span class="s2">\n                    </span><span class="s1">delimiters</span><span class="s2">\n                </span><span class="s1">}, compilerOptions), componentCompilerOptions);</span><span class="s2">\n                </span><span class="s1">Component.render = compile(template, finalCompilerOptions);</span><span class="s2">\n                </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n                    </span><span class="s1">endMeasure(instance, `compile`);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">instance.render = (Component.render || NOOP);</span><span class="s2">\n        </span><span class="s1">// for runtime-compiled render functions using `with` blocks, the render</span><span class="s2">\n        </span><span class="s1">// proxy used needs a different `has` handler which is more performant and</span><span class="s2">\n        </span><span class="s1">// also only allows a whitelist of globals to fallthrough.</span><span class="s2">\n        </span><span class="s1">if (installWithProxy) {</span><span class="s2">\n            </span><span class="s1">installWithProxy(instance);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// support for 2.x options</span><span class="s2">\n    </span><span class="s1">if (__VUE_OPTIONS_API__ &amp;&amp; !(false )) {</span><span class="s2">\n        </span><span class="s1">setCurrentInstance(instance);</span><span class="s2">\n        </span><span class="s1">pauseTracking();</span><span class="s2">\n        </span><span class="s1">applyOptions(instance);</span><span class="s2">\n        </span><span class="s1">resetTracking();</span><span class="s2">\n        </span><span class="s1">unsetCurrentInstance();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// warn missing template/render</span><span class="s2">\n    </span><span class="s1">// the runtime compilation of template in SSR is done by server-render</span><span class="s2">\n    </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp; !Component.render &amp;&amp; instance.render === NOOP &amp;&amp; !isSSR) {</span><span class="s2">\n        </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n        </span><span class="s1">if (!compile &amp;&amp; Component.template) {</span><span class="s2">\n            </span><span class="s1">warn(`Component provided template option but ` +</span><span class="s2">\n                </span><span class="s1">`runtime compilation is not supported in this build of Vue.` +</span><span class="s2">\n                </span><span class="s1">(` Configure your bundler to alias </span><span class="s2">\&quot;</span><span class="s1">vue</span><span class="s2">\&quot; </span><span class="s1">to </span><span class="s2">\&quot;</span><span class="s1">vue/dist/vue.esm-bundler.js</span><span class="s2">\&quot;</span><span class="s1">.`</span><span class="s2">\n                    </span><span class="s1">) /* should not happen */);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">warn(`Component is missing template or render function.`);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createAttrsProxy(instance) {</span><span class="s2">\n    </span><span class="s1">return new Proxy(instance.attrs, (process.env.NODE_ENV !== 'production')</span><span class="s2">\n        </span><span class="s1">? {</span><span class="s2">\n            </span><span class="s1">get(target, key) {</span><span class="s2">\n                </span><span class="s1">markAttrsAccessed();</span><span class="s2">\n                </span><span class="s1">track(instance, </span><span class="s2">\&quot;</span><span class="s1">get</span><span class="s2">\&quot; </span><span class="s1">/* TrackOpTypes.GET */, '$attrs');</span><span class="s2">\n                </span><span class="s1">return target[key];</span><span class="s2">\n            </span><span class="s1">},</span><span class="s2">\n            </span><span class="s1">set() {</span><span class="s2">\n                </span><span class="s1">warn(`setupContext.attrs is readonly.`);</span><span class="s2">\n                </span><span class="s1">return false;</span><span class="s2">\n            </span><span class="s1">},</span><span class="s2">\n            </span><span class="s1">deleteProperty() {</span><span class="s2">\n                </span><span class="s1">warn(`setupContext.attrs is readonly.`);</span><span class="s2">\n                </span><span class="s1">return false;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">: {</span><span class="s2">\n            </span><span class="s1">get(target, key) {</span><span class="s2">\n                </span><span class="s1">track(instance, </span><span class="s2">\&quot;</span><span class="s1">get</span><span class="s2">\&quot; </span><span class="s1">/* TrackOpTypes.GET */, '$attrs');</span><span class="s2">\n                </span><span class="s1">return target[key];</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function createSetupContext(instance) {</span><span class="s2">\n    </span><span class="s1">const expose = exposed =&gt; {</span><span class="s2">\n        </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n            </span><span class="s1">if (instance.exposed) {</span><span class="s2">\n                </span><span class="s1">warn(`expose() should be called only once per setup().`);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">if (exposed != null) {</span><span class="s2">\n                </span><span class="s1">let exposedType = typeof exposed;</span><span class="s2">\n                </span><span class="s1">if (exposedType === 'object') {</span><span class="s2">\n                    </span><span class="s1">if (isArray(exposed)) {</span><span class="s2">\n                        </span><span class="s1">exposedType = 'array';</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">else if (isRef(exposed)) {</span><span class="s2">\n                        </span><span class="s1">exposedType = 'ref';</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">if (exposedType !== 'object') {</span><span class="s2">\n                    </span><span class="s1">warn(`expose() should be passed a plain object, received ${exposedType}.`);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">instance.exposed = exposed || {};</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">let attrs;</span><span class="s2">\n    </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n        </span><span class="s1">// We use getters in dev in case libs like test-utils overwrite instance</span><span class="s2">\n        </span><span class="s1">// properties (overwrites should not be done in prod)</span><span class="s2">\n        </span><span class="s1">return Object.freeze({</span><span class="s2">\n            </span><span class="s1">get attrs() {</span><span class="s2">\n                </span><span class="s1">return attrs || (attrs = createAttrsProxy(instance));</span><span class="s2">\n            </span><span class="s1">},</span><span class="s2">\n            </span><span class="s1">get slots() {</span><span class="s2">\n                </span><span class="s1">return shallowReadonly(instance.slots);</span><span class="s2">\n            </span><span class="s1">},</span><span class="s2">\n            </span><span class="s1">get emit() {</span><span class="s2">\n                </span><span class="s1">return (event, ...args) =&gt; instance.emit(event, ...args);</span><span class="s2">\n            </span><span class="s1">},</span><span class="s2">\n            </span><span class="s1">expose</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">return {</span><span class="s2">\n            </span><span class="s1">get attrs() {</span><span class="s2">\n                </span><span class="s1">return attrs || (attrs = createAttrsProxy(instance));</span><span class="s2">\n            </span><span class="s1">},</span><span class="s2">\n            </span><span class="s1">slots: instance.slots,</span><span class="s2">\n            </span><span class="s1">emit: instance.emit,</span><span class="s2">\n            </span><span class="s1">expose</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getExposeProxy(instance) {</span><span class="s2">\n    </span><span class="s1">if (instance.exposed) {</span><span class="s2">\n        </span><span class="s1">return (instance.exposeProxy ||</span><span class="s2">\n            </span><span class="s1">(instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {</span><span class="s2">\n                </span><span class="s1">get(target, key) {</span><span class="s2">\n                    </span><span class="s1">if (key in target) {</span><span class="s2">\n                        </span><span class="s1">return target[key];</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">else if (key in publicPropertiesMap) {</span><span class="s2">\n                        </span><span class="s1">return publicPropertiesMap[key](instance);</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">},</span><span class="s2">\n                </span><span class="s1">has(target, key) {</span><span class="s2">\n                    </span><span class="s1">return key in target || key in publicPropertiesMap;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">})));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">const classifyRE = /(?:^|[-_])(</span><span class="s2">\\</span><span class="s1">w)/g;</span><span class="s2">\n</span><span class="s1">const classify = (str) =&gt; str.replace(classifyRE, c =&gt; c.toUpperCase()).replace(/[-_]/g, '');</span><span class="s2">\n</span><span class="s1">function getComponentName(Component, includeInferred = true) {</span><span class="s2">\n    </span><span class="s1">return isFunction(Component)</span><span class="s2">\n        </span><span class="s1">? Component.displayName || Component.name</span><span class="s2">\n        </span><span class="s1">: Component.name || (includeInferred &amp;&amp; Component.__name);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/* istanbul ignore next */</span><span class="s2">\n</span><span class="s1">function formatComponentName(instance, Component, isRoot = false) {</span><span class="s2">\n    </span><span class="s1">let name = getComponentName(Component);</span><span class="s2">\n    </span><span class="s1">if (!name &amp;&amp; Component.__file) {</span><span class="s2">\n        </span><span class="s1">const match = Component.__file.match(/([^/</span><span class="s2">\\\\</span><span class="s1">]+)</span><span class="s2">\\</span><span class="s1">.</span><span class="s2">\\</span><span class="s1">w+$/);</span><span class="s2">\n        </span><span class="s1">if (match) {</span><span class="s2">\n            </span><span class="s1">name = match[1];</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (!name &amp;&amp; instance &amp;&amp; instance.parent) {</span><span class="s2">\n        </span><span class="s1">// try to infer the name based on reverse resolution</span><span class="s2">\n        </span><span class="s1">const inferFromRegistry = (registry) =&gt; {</span><span class="s2">\n            </span><span class="s1">for (const key in registry) {</span><span class="s2">\n                </span><span class="s1">if (registry[key] === Component) {</span><span class="s2">\n                    </span><span class="s1">return key;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n        </span><span class="s1">name =</span><span class="s2">\n            </span><span class="s1">inferFromRegistry(instance.components ||</span><span class="s2">\n                </span><span class="s1">instance.parent.type.components) || inferFromRegistry(instance.appContext.components);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return name ? classify(name) : isRoot ? `App` : `Anonymous`;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isClassComponent(value) {</span><span class="s2">\n    </span><span class="s1">return isFunction(value) &amp;&amp; '__vccOpts' in value;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">const computed = ((getterOrOptions, debugOptions) =&gt; {</span><span class="s2">\n    </span><span class="s1">// @ts-ignore</span><span class="s2">\n    </span><span class="s1">return computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);</span><span class="s2">\n</span><span class="s1">});</span><span class="s2">\n\n</span><span class="s1">// dev only</span><span class="s2">\n</span><span class="s1">const warnRuntimeUsage = (method) =&gt; warn(`${method}() is a compiler-hint helper that is only usable inside ` +</span><span class="s2">\n    </span><span class="s1">`&lt;script setup&gt; of a single file component. Its arguments should be ` +</span><span class="s2">\n    </span><span class="s1">`compiled away and passing it at runtime has no effect.`);</span><span class="s2">\n</span><span class="s1">// implementation</span><span class="s2">\n</span><span class="s1">function defineProps() {</span><span class="s2">\n    </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n        </span><span class="s1">warnRuntimeUsage(`defineProps`);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return null;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// implementation</span><span class="s2">\n</span><span class="s1">function defineEmits() {</span><span class="s2">\n    </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n        </span><span class="s1">warnRuntimeUsage(`defineEmits`);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return null;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Vue `&lt;script setup&gt;` compiler macro for declaring a component's exposed</span><span class="s2">\n </span><span class="s1">* instance properties when it is accessed by a parent component via template</span><span class="s2">\n </span><span class="s1">* refs.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* `&lt;script setup&gt;` components are closed by default - i.e. variables inside</span><span class="s2">\n </span><span class="s1">* the `&lt;script setup&gt;` scope is not exposed to parent unless explicitly exposed</span><span class="s2">\n </span><span class="s1">* via `defineExpose`.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* This is only usable inside `&lt;script setup&gt;`, is compiled away in the</span><span class="s2">\n </span><span class="s1">* output and should **not** be actually called at runtime.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function defineExpose(exposed) {</span><span class="s2">\n    </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n        </span><span class="s1">warnRuntimeUsage(`defineExpose`);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Vue `&lt;script setup&gt;` compiler macro for providing props default values when</span><span class="s2">\n </span><span class="s1">* using type-based `defineProps` declaration.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* Example usage:</span><span class="s2">\n </span><span class="s1">* ```ts</span><span class="s2">\n </span><span class="s1">* withDefaults(defineProps&lt;{</span><span class="s2">\n </span><span class="s1">*   size?: number</span><span class="s2">\n </span><span class="s1">*   labels?: string[]</span><span class="s2">\n </span><span class="s1">* }&gt;(), {</span><span class="s2">\n </span><span class="s1">*   size: 3,</span><span class="s2">\n </span><span class="s1">*   labels: () =&gt; ['default label']</span><span class="s2">\n </span><span class="s1">* })</span><span class="s2">\n </span><span class="s1">* ```</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* This is only usable inside `&lt;script setup&gt;`, is compiled away in the output</span><span class="s2">\n </span><span class="s1">* and should **not** be actually called at runtime.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function withDefaults(props, defaults) {</span><span class="s2">\n    </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n        </span><span class="s1">warnRuntimeUsage(`withDefaults`);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return null;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useSlots() {</span><span class="s2">\n    </span><span class="s1">return getContext().slots;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function useAttrs() {</span><span class="s2">\n    </span><span class="s1">return getContext().attrs;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getContext() {</span><span class="s2">\n    </span><span class="s1">const i = getCurrentInstance();</span><span class="s2">\n    </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp; !i) {</span><span class="s2">\n        </span><span class="s1">warn(`useContext() called without active instance.`);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return i.setupContext || (i.setupContext = createSetupContext(i));</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Runtime helper for merging default declarations. Imported by compiled code</span><span class="s2">\n </span><span class="s1">* only.</span><span class="s2">\n </span><span class="s1">* @internal</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function mergeDefaults(raw, defaults) {</span><span class="s2">\n    </span><span class="s1">const props = isArray(raw)</span><span class="s2">\n        </span><span class="s1">? raw.reduce((normalized, p) =&gt; ((normalized[p] = {}), normalized), {})</span><span class="s2">\n        </span><span class="s1">: raw;</span><span class="s2">\n    </span><span class="s1">for (const key in defaults) {</span><span class="s2">\n        </span><span class="s1">const opt = props[key];</span><span class="s2">\n        </span><span class="s1">if (opt) {</span><span class="s2">\n            </span><span class="s1">if (isArray(opt) || isFunction(opt)) {</span><span class="s2">\n                </span><span class="s1">props[key] = { type: opt, default: defaults[key] };</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">opt.default = defaults[key];</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (opt === null) {</span><span class="s2">\n            </span><span class="s1">props[key] = { default: defaults[key] };</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n            </span><span class="s1">warn(`props default key </span><span class="s2">\&quot;</span><span class="s1">${key}</span><span class="s2">\&quot; </span><span class="s1">has no corresponding declaration.`);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return props;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Used to create a proxy for the rest element when destructuring props with</span><span class="s2">\n </span><span class="s1">* defineProps().</span><span class="s2">\n </span><span class="s1">* @internal</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function createPropsRestProxy(props, excludedKeys) {</span><span class="s2">\n    </span><span class="s1">const ret = {};</span><span class="s2">\n    </span><span class="s1">for (const key in props) {</span><span class="s2">\n        </span><span class="s1">if (!excludedKeys.includes(key)) {</span><span class="s2">\n            </span><span class="s1">Object.defineProperty(ret, key, {</span><span class="s2">\n                </span><span class="s1">enumerable: true,</span><span class="s2">\n                </span><span class="s1">get: () =&gt; props[key]</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return ret;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* `&lt;script setup&gt;` helper for persisting the current instance context over</span><span class="s2">\n </span><span class="s1">* async/await flows.</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* `@vue/compiler-sfc` converts the following:</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* ```ts</span><span class="s2">\n </span><span class="s1">* const x = await foo()</span><span class="s2">\n </span><span class="s1">* ```</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* into:</span><span class="s2">\n </span><span class="s1">*</span><span class="s2">\n </span><span class="s1">* ```ts</span><span class="s2">\n </span><span class="s1">* let __temp, __restore</span><span class="s2">\n </span><span class="s1">* const x = (([__temp, __restore] = withAsyncContext(() =&gt; foo())),__temp=await __temp,__restore(),__temp)</span><span class="s2">\n </span><span class="s1">* ```</span><span class="s2">\n </span><span class="s1">* @internal</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function withAsyncContext(getAwaitable) {</span><span class="s2">\n    </span><span class="s1">const ctx = getCurrentInstance();</span><span class="s2">\n    </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp; !ctx) {</span><span class="s2">\n        </span><span class="s1">warn(`withAsyncContext called without active current instance. ` +</span><span class="s2">\n            </span><span class="s1">`This is likely a bug.`);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let awaitable = getAwaitable();</span><span class="s2">\n    </span><span class="s1">unsetCurrentInstance();</span><span class="s2">\n    </span><span class="s1">if (isPromise(awaitable)) {</span><span class="s2">\n        </span><span class="s1">awaitable = awaitable.catch(e =&gt; {</span><span class="s2">\n            </span><span class="s1">setCurrentInstance(ctx);</span><span class="s2">\n            </span><span class="s1">throw e;</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return [awaitable, () =&gt; setCurrentInstance(ctx)];</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// Actual implementation</span><span class="s2">\n</span><span class="s1">function h(type, propsOrChildren, children) {</span><span class="s2">\n    </span><span class="s1">const l = arguments.length;</span><span class="s2">\n    </span><span class="s1">if (l === 2) {</span><span class="s2">\n        </span><span class="s1">if (isObject(propsOrChildren) &amp;&amp; !isArray(propsOrChildren)) {</span><span class="s2">\n            </span><span class="s1">// single vnode without props</span><span class="s2">\n            </span><span class="s1">if (isVNode(propsOrChildren)) {</span><span class="s2">\n                </span><span class="s1">return createVNode(type, null, [propsOrChildren]);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">// props without children</span><span class="s2">\n            </span><span class="s1">return createVNode(type, propsOrChildren);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">// omit props</span><span class="s2">\n            </span><span class="s1">return createVNode(type, null, propsOrChildren);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">if (l &gt; 3) {</span><span class="s2">\n            </span><span class="s1">children = Array.prototype.slice.call(arguments, 2);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (l === 3 &amp;&amp; isVNode(children)) {</span><span class="s2">\n            </span><span class="s1">children = [children];</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return createVNode(type, propsOrChildren, children);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">const ssrContextKey = Symbol((process.env.NODE_ENV !== 'production') ? `ssrContext` : ``);</span><span class="s2">\n</span><span class="s1">const useSSRContext = () =&gt; {</span><span class="s2">\n    </span><span class="s1">{</span><span class="s2">\n        </span><span class="s1">const ctx = inject(ssrContextKey);</span><span class="s2">\n        </span><span class="s1">if (!ctx) {</span><span class="s2">\n            </span><span class="s1">(process.env.NODE_ENV !== 'production') &amp;&amp;</span><span class="s2">\n                </span><span class="s1">warn(`Server rendering context not provided. Make sure to only call ` +</span><span class="s2">\n                    </span><span class="s1">`useSSRContext() conditionally in the server build.`);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return ctx;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">function isShallow(value) {</span><span class="s2">\n    </span><span class="s1">return !!(value &amp;&amp; value[</span><span class="s2">\&quot;</span><span class="s1">__v_isShallow</span><span class="s2">\&quot; </span><span class="s1">/* ReactiveFlags.IS_SHALLOW */]);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function initCustomFormatter() {</span><span class="s2">\n    </span><span class="s1">/* eslint-disable no-restricted-globals */</span><span class="s2">\n    </span><span class="s1">if (!(process.env.NODE_ENV !== 'production') || typeof window === 'undefined') {</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">const vueStyle = { style: 'color:#3ba776' };</span><span class="s2">\n    </span><span class="s1">const numberStyle = { style: 'color:#0b1bc9' };</span><span class="s2">\n    </span><span class="s1">const stringStyle = { style: 'color:#b62e24' };</span><span class="s2">\n    </span><span class="s1">const keywordStyle = { style: 'color:#9d288c' };</span><span class="s2">\n    </span><span class="s1">// custom formatter for Chrome</span><span class="s2">\n    </span><span class="s1">// https://www.mattzeunert.com/2016/02/19/custom-chrome-devtools-object-formatters.html</span><span class="s2">\n    </span><span class="s1">const formatter = {</span><span class="s2">\n        </span><span class="s1">header(obj) {</span><span class="s2">\n            </span><span class="s1">// TODO also format ComponentPublicInstance &amp; ctx.slots/attrs in setup</span><span class="s2">\n            </span><span class="s1">if (!isObject(obj)) {</span><span class="s2">\n                </span><span class="s1">return null;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">if (obj.__isVue) {</span><span class="s2">\n                </span><span class="s1">return ['div', vueStyle, `VueInstance`];</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else if (isRef(obj)) {</span><span class="s2">\n                </span><span class="s1">return [</span><span class="s2">\n                    </span><span class="s1">'div',</span><span class="s2">\n                    </span><span class="s1">{},</span><span class="s2">\n                    </span><span class="s1">['span', vueStyle, genRefFlag(obj)],</span><span class="s2">\n                    </span><span class="s1">'&lt;',</span><span class="s2">\n                    </span><span class="s1">formatValue(obj.value),</span><span class="s2">\n                    </span><span class="s1">`&gt;`</span><span class="s2">\n                </span><span class="s1">];</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else if (isReactive(obj)) {</span><span class="s2">\n                </span><span class="s1">return [</span><span class="s2">\n                    </span><span class="s1">'div',</span><span class="s2">\n                    </span><span class="s1">{},</span><span class="s2">\n                    </span><span class="s1">['span', vueStyle, isShallow(obj) ? 'ShallowReactive' : 'Reactive'],</span><span class="s2">\n                    </span><span class="s1">'&lt;',</span><span class="s2">\n                    </span><span class="s1">formatValue(obj),</span><span class="s2">\n                    </span><span class="s1">`&gt;${isReadonly(obj) ? ` (readonly)` : ``}`</span><span class="s2">\n                </span><span class="s1">];</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else if (isReadonly(obj)) {</span><span class="s2">\n                </span><span class="s1">return [</span><span class="s2">\n                    </span><span class="s1">'div',</span><span class="s2">\n                    </span><span class="s1">{},</span><span class="s2">\n                    </span><span class="s1">['span', vueStyle, isShallow(obj) ? 'ShallowReadonly' : 'Readonly'],</span><span class="s2">\n                    </span><span class="s1">'&lt;',</span><span class="s2">\n                    </span><span class="s1">formatValue(obj),</span><span class="s2">\n                    </span><span class="s1">'&gt;'</span><span class="s2">\n                </span><span class="s1">];</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">return null;</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">hasBody(obj) {</span><span class="s2">\n            </span><span class="s1">return obj &amp;&amp; obj.__isVue;</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">body(obj) {</span><span class="s2">\n            </span><span class="s1">if (obj &amp;&amp; obj.__isVue) {</span><span class="s2">\n                </span><span class="s1">return [</span><span class="s2">\n                    </span><span class="s1">'div',</span><span class="s2">\n                    </span><span class="s1">{},</span><span class="s2">\n                    </span><span class="s1">...formatInstance(obj.$)</span><span class="s2">\n                </span><span class="s1">];</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">function formatInstance(instance) {</span><span class="s2">\n        </span><span class="s1">const blocks = [];</span><span class="s2">\n        </span><span class="s1">if (instance.type.props &amp;&amp; instance.props) {</span><span class="s2">\n            </span><span class="s1">blocks.push(createInstanceBlock('props', toRaw(instance.props)));</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (instance.setupState !== EMPTY_OBJ) {</span><span class="s2">\n            </span><span class="s1">blocks.push(createInstanceBlock('setup', instance.setupState));</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (instance.data !== EMPTY_OBJ) {</span><span class="s2">\n            </span><span class="s1">blocks.push(createInstanceBlock('data', toRaw(instance.data)));</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">const computed = extractKeys(instance, 'computed');</span><span class="s2">\n        </span><span class="s1">if (computed) {</span><span class="s2">\n            </span><span class="s1">blocks.push(createInstanceBlock('computed', computed));</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">const injected = extractKeys(instance, 'inject');</span><span class="s2">\n        </span><span class="s1">if (injected) {</span><span class="s2">\n            </span><span class="s1">blocks.push(createInstanceBlock('injected', injected));</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">blocks.push([</span><span class="s2">\n            </span><span class="s1">'div',</span><span class="s2">\n            </span><span class="s1">{},</span><span class="s2">\n            </span><span class="s1">[</span><span class="s2">\n                </span><span class="s1">'span',</span><span class="s2">\n                </span><span class="s1">{</span><span class="s2">\n                    </span><span class="s1">style: keywordStyle.style + ';opacity:0.66'</span><span class="s2">\n                </span><span class="s1">},</span><span class="s2">\n                </span><span class="s1">'$ (internal): '</span><span class="s2">\n            </span><span class="s1">],</span><span class="s2">\n            </span><span class="s1">['object', { object: instance }]</span><span class="s2">\n        </span><span class="s1">]);</span><span class="s2">\n        </span><span class="s1">return blocks;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">function createInstanceBlock(type, target) {</span><span class="s2">\n        </span><span class="s1">target = extend({}, target);</span><span class="s2">\n        </span><span class="s1">if (!Object.keys(target).length) {</span><span class="s2">\n            </span><span class="s1">return ['span', {}];</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return [</span><span class="s2">\n            </span><span class="s1">'div',</span><span class="s2">\n            </span><span class="s1">{ style: 'line-height:1.25em;margin-bottom:0.6em' },</span><span class="s2">\n            </span><span class="s1">[</span><span class="s2">\n                </span><span class="s1">'div',</span><span class="s2">\n                </span><span class="s1">{</span><span class="s2">\n                    </span><span class="s1">style: 'color:#476582'</span><span class="s2">\n                </span><span class="s1">},</span><span class="s2">\n                </span><span class="s1">type</span><span class="s2">\n            </span><span class="s1">],</span><span class="s2">\n            </span><span class="s1">[</span><span class="s2">\n                </span><span class="s1">'div',</span><span class="s2">\n                </span><span class="s1">{</span><span class="s2">\n                    </span><span class="s1">style: 'padding-left:1.25em'</span><span class="s2">\n                </span><span class="s1">},</span><span class="s2">\n                </span><span class="s1">...Object.keys(target).map(key =&gt; {</span><span class="s2">\n                    </span><span class="s1">return [</span><span class="s2">\n                        </span><span class="s1">'div',</span><span class="s2">\n                        </span><span class="s1">{},</span><span class="s2">\n                        </span><span class="s1">['span', keywordStyle, key + ': '],</span><span class="s2">\n                        </span><span class="s1">formatValue(target[key], false)</span><span class="s2">\n                    </span><span class="s1">];</span><span class="s2">\n                </span><span class="s1">})</span><span class="s2">\n            </span><span class="s1">]</span><span class="s2">\n        </span><span class="s1">];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">function formatValue(v, asRaw = true) {</span><span class="s2">\n        </span><span class="s1">if (typeof v === 'number') {</span><span class="s2">\n            </span><span class="s1">return ['span', numberStyle, v];</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (typeof v === 'string') {</span><span class="s2">\n            </span><span class="s1">return ['span', stringStyle, JSON.stringify(v)];</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (typeof v === 'boolean') {</span><span class="s2">\n            </span><span class="s1">return ['span', keywordStyle, v];</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (isObject(v)) {</span><span class="s2">\n            </span><span class="s1">return ['object', { object: asRaw ? toRaw(v) : v }];</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">return ['span', stringStyle, String(v)];</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">function extractKeys(instance, type) {</span><span class="s2">\n        </span><span class="s1">const Comp = instance.type;</span><span class="s2">\n        </span><span class="s1">if (isFunction(Comp)) {</span><span class="s2">\n            </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">const extracted = {};</span><span class="s2">\n        </span><span class="s1">for (const key in instance.ctx) {</span><span class="s2">\n            </span><span class="s1">if (isKeyOfType(Comp, key, type)) {</span><span class="s2">\n                </span><span class="s1">extracted[key] = instance.ctx[key];</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return extracted;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">function isKeyOfType(Comp, key, type) {</span><span class="s2">\n        </span><span class="s1">const opts = Comp[type];</span><span class="s2">\n        </span><span class="s1">if ((isArray(opts) &amp;&amp; opts.includes(key)) ||</span><span class="s2">\n            </span><span class="s1">(isObject(opts) &amp;&amp; key in opts)) {</span><span class="s2">\n            </span><span class="s1">return true;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (Comp.extends &amp;&amp; isKeyOfType(Comp.extends, key, type)) {</span><span class="s2">\n            </span><span class="s1">return true;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (Comp.mixins &amp;&amp; Comp.mixins.some(m =&gt; isKeyOfType(m, key, type))) {</span><span class="s2">\n            </span><span class="s1">return true;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">function genRefFlag(v) {</span><span class="s2">\n        </span><span class="s1">if (isShallow(v)) {</span><span class="s2">\n            </span><span class="s1">return `ShallowRef`;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (v.effect) {</span><span class="s2">\n            </span><span class="s1">return `ComputedRef`;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return `Ref`;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (window.devtoolsFormatters) {</span><span class="s2">\n        </span><span class="s1">window.devtoolsFormatters.push(formatter);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">window.devtoolsFormatters = [formatter];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function withMemo(memo, render, cache, index) {</span><span class="s2">\n    </span><span class="s1">const cached = cache[index];</span><span class="s2">\n    </span><span class="s1">if (cached &amp;&amp; isMemoSame(cached, memo)) {</span><span class="s2">\n        </span><span class="s1">return cached;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">const ret = render();</span><span class="s2">\n    </span><span class="s1">// shallow clone</span><span class="s2">\n    </span><span class="s1">ret.memo = memo.slice();</span><span class="s2">\n    </span><span class="s1">return (cache[index] = ret);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function isMemoSame(cached, memo) {</span><span class="s2">\n    </span><span class="s1">const prev = cached.memo;</span><span class="s2">\n    </span><span class="s1">if (prev.length != memo.length) {</span><span class="s2">\n        </span><span class="s1">return false;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">for (let i = 0; i &lt; prev.length; i++) {</span><span class="s2">\n        </span><span class="s1">if (hasChanged(prev[i], memo[i])) {</span><span class="s2">\n            </span><span class="s1">return false;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// make sure to let parent block track it when returning cached</span><span class="s2">\n    </span><span class="s1">if (isBlockTreeEnabled &gt; 0 &amp;&amp; currentBlock) {</span><span class="s2">\n        </span><span class="s1">currentBlock.push(cached);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return true;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// Core API ------------------------------------------------------------------</span><span class="s2">\n</span><span class="s1">const version = </span><span class="s2">\&quot;</span><span class="s1">3.2.47</span><span class="s2">\&quot;</span><span class="s1">;</span><span class="s2">\n</span><span class="s1">const _ssrUtils = {</span><span class="s2">\n    </span><span class="s1">createComponentInstance,</span><span class="s2">\n    </span><span class="s1">setupComponent,</span><span class="s2">\n    </span><span class="s1">renderComponentRoot,</span><span class="s2">\n    </span><span class="s1">setCurrentRenderingInstance,</span><span class="s2">\n    </span><span class="s1">isVNode,</span><span class="s2">\n    </span><span class="s1">normalizeVNode</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* SSR utils for </span><span class="s2">\\</span><span class="s1">@vue/server-renderer. Only exposed in ssr-possible builds.</span><span class="s2">\n </span><span class="s1">* @internal</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const ssrUtils = (_ssrUtils );</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* @internal only exposed in compat builds</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const resolveFilter = null;</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* @internal only exposed in compat builds.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const compatUtils = (null);</span><span class="s2">\n\n</span><span class="s1">export { BaseTransition, Comment, Fragment, KeepAlive, Static, Suspense, Teleport, Text, assertNumber, callWithAsyncErrorHandling, callWithErrorHandling, cloneVNode, compatUtils, computed, createBlock, createCommentVNode, createElementBlock, createBaseVNode as createElementVNode, createHydrationRenderer, createPropsRestProxy, createRenderer, createSlots, createStaticVNode, createTextVNode, createVNode, defineAsyncComponent, defineComponent, defineEmits, defineExpose, defineProps, devtools, getCurrentInstance, getTransitionRawChildren, guardReactiveProps, h, handleError, initCustomFormatter, inject, isMemoSame, isRuntimeOnly, isVNode, mergeDefaults, mergeProps, nextTick, onActivated, onBeforeMount, onBeforeUnmount, onBeforeUpdate, onDeactivated, onErrorCaptured, onMounted, onRenderTracked, onRenderTriggered, onServerPrefetch, onUnmounted, onUpdated, openBlock, popScopeId, provide, pushScopeId, queuePostFlushCb, registerRuntimeCompiler, renderList, renderSlot, resolveComponent, resolveDirective, resolveDynamicComponent, resolveFilter, resolveTransitionHooks, setBlockTracking, setDevtoolsHook, setTransitionHooks, ssrContextKey, ssrUtils, toHandlers, transformVNodeArgs, useAttrs, useSSRContext, useSlots, useTransitionState, version, warn, watch, watchEffect, watchPostEffect, watchSyncEffect, withAsyncContext, withCtx, withDefaults, withDirectives, withMemo, withScopeId };</span><span class="s2">\n</span><span class="s1">&quot;</span><span class="s2">, </span><span class="s1">&quot;import { warn, camelize, callWithAsyncErrorHandling, defineComponent, nextTick, createVNode, getCurrentInstance, watchPostEffect, onMounted, onUnmounted, Fragment, Static, h, BaseTransition, assertNumber, useTransitionState, onUpdated, toRaw, getTransitionRawChildren, setTransitionHooks, resolveTransitionHooks, isRuntimeOnly, createRenderer, createHydrationRenderer } from '@vue/runtime-core';</span><span class="s2">\n</span><span class="s1">export * from '@vue/runtime-core';</span><span class="s2">\n</span><span class="s1">import { isString, isArray, hyphenate, capitalize, isSpecialBooleanAttr, includeBooleanAttr, isOn, isModelListener, isFunction, camelize as camelize$1, toNumber, extend, EMPTY_OBJ, isObject, looseToNumber, looseIndexOf, isSet, looseEqual, invokeArrayFns, isHTMLTag, isSVGTag } from '@vue/shared';</span><span class="s2">\n\n</span><span class="s1">const svgNS = 'http://www.w3.org/2000/svg';</span><span class="s2">\n</span><span class="s1">const doc = (typeof document !== 'undefined' ? document : null);</span><span class="s2">\n</span><span class="s1">const templateContainer = doc &amp;&amp; /*#__PURE__*/ doc.createElement('template');</span><span class="s2">\n</span><span class="s1">const nodeOps = {</span><span class="s2">\n    </span><span class="s1">insert: (child, parent, anchor) =&gt; {</span><span class="s2">\n        </span><span class="s1">parent.insertBefore(child, anchor || null);</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">remove: child =&gt; {</span><span class="s2">\n        </span><span class="s1">const parent = child.parentNode;</span><span class="s2">\n        </span><span class="s1">if (parent) {</span><span class="s2">\n            </span><span class="s1">parent.removeChild(child);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">createElement: (tag, isSVG, is, props) =&gt; {</span><span class="s2">\n        </span><span class="s1">const el = isSVG</span><span class="s2">\n            </span><span class="s1">? doc.createElementNS(svgNS, tag)</span><span class="s2">\n            </span><span class="s1">: doc.createElement(tag, is ? { is } : undefined);</span><span class="s2">\n        </span><span class="s1">if (tag === 'select' &amp;&amp; props &amp;&amp; props.multiple != null) {</span><span class="s2">\n            </span><span class="s1">el.setAttribute('multiple', props.multiple);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return el;</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">createText: text =&gt; doc.createTextNode(text),</span><span class="s2">\n    </span><span class="s1">createComment: text =&gt; doc.createComment(text),</span><span class="s2">\n    </span><span class="s1">setText: (node, text) =&gt; {</span><span class="s2">\n        </span><span class="s1">node.nodeValue = text;</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">setElementText: (el, text) =&gt; {</span><span class="s2">\n        </span><span class="s1">el.textContent = text;</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">parentNode: node =&gt; node.parentNode,</span><span class="s2">\n    </span><span class="s1">nextSibling: node =&gt; node.nextSibling,</span><span class="s2">\n    </span><span class="s1">querySelector: selector =&gt; doc.querySelector(selector),</span><span class="s2">\n    </span><span class="s1">setScopeId(el, id) {</span><span class="s2">\n        </span><span class="s1">el.setAttribute(id, '');</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">// __UNSAFE__</span><span class="s2">\n    </span><span class="s1">// Reason: innerHTML.</span><span class="s2">\n    </span><span class="s1">// Static content here can only come from compiled templates.</span><span class="s2">\n    </span><span class="s1">// As long as the user only uses trusted templates, this is safe.</span><span class="s2">\n    </span><span class="s1">insertStaticContent(content, parent, anchor, isSVG, start, end) {</span><span class="s2">\n        </span><span class="s1">// &lt;parent&gt; before | first ... last | anchor &lt;/parent&gt;</span><span class="s2">\n        </span><span class="s1">const before = anchor ? anchor.previousSibling : parent.lastChild;</span><span class="s2">\n        </span><span class="s1">// #5308 can only take cached path if:</span><span class="s2">\n        </span><span class="s1">// - has a single root node</span><span class="s2">\n        </span><span class="s1">// - nextSibling info is still available</span><span class="s2">\n        </span><span class="s1">if (start &amp;&amp; (start === end || start.nextSibling)) {</span><span class="s2">\n            </span><span class="s1">// cached</span><span class="s2">\n            </span><span class="s1">while (true) {</span><span class="s2">\n                </span><span class="s1">parent.insertBefore(start.cloneNode(true), anchor);</span><span class="s2">\n                </span><span class="s1">if (start === end || !(start = start.nextSibling))</span><span class="s2">\n                    </span><span class="s1">break;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">// fresh insert</span><span class="s2">\n            </span><span class="s1">templateContainer.innerHTML = isSVG ? `&lt;svg&gt;${content}&lt;/svg&gt;` : content;</span><span class="s2">\n            </span><span class="s1">const template = templateContainer.content;</span><span class="s2">\n            </span><span class="s1">if (isSVG) {</span><span class="s2">\n                </span><span class="s1">// remove outer svg wrapper</span><span class="s2">\n                </span><span class="s1">const wrapper = template.firstChild;</span><span class="s2">\n                </span><span class="s1">while (wrapper.firstChild) {</span><span class="s2">\n                    </span><span class="s1">template.appendChild(wrapper.firstChild);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">template.removeChild(wrapper);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">parent.insertBefore(template, anchor);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return [</span><span class="s2">\n            </span><span class="s1">// first</span><span class="s2">\n            </span><span class="s1">before ? before.nextSibling : parent.firstChild,</span><span class="s2">\n            </span><span class="s1">// last</span><span class="s2">\n            </span><span class="s1">anchor ? anchor.previousSibling : parent.lastChild</span><span class="s2">\n        </span><span class="s1">];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">// compiler should normalize class + :class bindings on the same element</span><span class="s2">\n</span><span class="s1">// into a single binding ['staticClass', dynamic]</span><span class="s2">\n</span><span class="s1">function patchClass(el, value, isSVG) {</span><span class="s2">\n    </span><span class="s1">// directly setting className should be faster than setAttribute in theory</span><span class="s2">\n    </span><span class="s1">// if this is an element during a transition, take the temporary transition</span><span class="s2">\n    </span><span class="s1">// classes into account.</span><span class="s2">\n    </span><span class="s1">const transitionClasses = el._vtc;</span><span class="s2">\n    </span><span class="s1">if (transitionClasses) {</span><span class="s2">\n        </span><span class="s1">value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(' ');</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (value == null) {</span><span class="s2">\n        </span><span class="s1">el.removeAttribute('class');</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (isSVG) {</span><span class="s2">\n        </span><span class="s1">el.setAttribute('class', value);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">el.className = value;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function patchStyle(el, prev, next) {</span><span class="s2">\n    </span><span class="s1">const style = el.style;</span><span class="s2">\n    </span><span class="s1">const isCssString = isString(next);</span><span class="s2">\n    </span><span class="s1">if (next &amp;&amp; !isCssString) {</span><span class="s2">\n        </span><span class="s1">if (prev &amp;&amp; !isString(prev)) {</span><span class="s2">\n            </span><span class="s1">for (const key in prev) {</span><span class="s2">\n                </span><span class="s1">if (next[key] == null) {</span><span class="s2">\n                    </span><span class="s1">setStyle(style, key, '');</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">for (const key in next) {</span><span class="s2">\n            </span><span class="s1">setStyle(style, key, next[key]);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">const currentDisplay = style.display;</span><span class="s2">\n        </span><span class="s1">if (isCssString) {</span><span class="s2">\n            </span><span class="s1">if (prev !== next) {</span><span class="s2">\n                </span><span class="s1">style.cssText = next;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (prev) {</span><span class="s2">\n            </span><span class="s1">el.removeAttribute('style');</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// indicates that the `display` of the element is controlled by `v-show`,</span><span class="s2">\n        </span><span class="s1">// so we always keep the current `display` value regardless of the `style`</span><span class="s2">\n        </span><span class="s1">// value, thus handing over control to `v-show`.</span><span class="s2">\n        </span><span class="s1">if ('_vod' in el) {</span><span class="s2">\n            </span><span class="s1">style.display = currentDisplay;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">const semicolonRE = /[^</span><span class="s2">\\\\</span><span class="s1">];</span><span class="s2">\\</span><span class="s1">s*$/;</span><span class="s2">\n</span><span class="s1">const importantRE = /</span><span class="s2">\\</span><span class="s1">s*!important$/;</span><span class="s2">\n</span><span class="s1">function setStyle(style, name, val) {</span><span class="s2">\n    </span><span class="s1">if (isArray(val)) {</span><span class="s2">\n        </span><span class="s1">val.forEach(v =&gt; setStyle(style, name, v));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">if (val == null)</span><span class="s2">\n            </span><span class="s1">val = '';</span><span class="s2">\n        </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n            </span><span class="s1">if (semicolonRE.test(val)) {</span><span class="s2">\n                </span><span class="s1">warn(`Unexpected semicolon at the end of '${name}' style value: '${val}'`);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (name.startsWith('--')) {</span><span class="s2">\n            </span><span class="s1">// custom property definition</span><span class="s2">\n            </span><span class="s1">style.setProperty(name, val);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">const prefixed = autoPrefix(style, name);</span><span class="s2">\n            </span><span class="s1">if (importantRE.test(val)) {</span><span class="s2">\n                </span><span class="s1">// !important</span><span class="s2">\n                </span><span class="s1">style.setProperty(hyphenate(prefixed), val.replace(importantRE, ''), 'important');</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">style[prefixed] = val;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">const prefixes = ['Webkit', 'Moz', 'ms'];</span><span class="s2">\n</span><span class="s1">const prefixCache = {};</span><span class="s2">\n</span><span class="s1">function autoPrefix(style, rawName) {</span><span class="s2">\n    </span><span class="s1">const cached = prefixCache[rawName];</span><span class="s2">\n    </span><span class="s1">if (cached) {</span><span class="s2">\n        </span><span class="s1">return cached;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let name = camelize(rawName);</span><span class="s2">\n    </span><span class="s1">if (name !== 'filter' &amp;&amp; name in style) {</span><span class="s2">\n        </span><span class="s1">return (prefixCache[rawName] = name);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">name = capitalize(name);</span><span class="s2">\n    </span><span class="s1">for (let i = 0; i &lt; prefixes.length; i++) {</span><span class="s2">\n        </span><span class="s1">const prefixed = prefixes[i] + name;</span><span class="s2">\n        </span><span class="s1">if (prefixed in style) {</span><span class="s2">\n            </span><span class="s1">return (prefixCache[rawName] = prefixed);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return rawName;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">const xlinkNS = 'http://www.w3.org/1999/xlink';</span><span class="s2">\n</span><span class="s1">function patchAttr(el, key, value, isSVG, instance) {</span><span class="s2">\n    </span><span class="s1">if (isSVG &amp;&amp; key.startsWith('xlink:')) {</span><span class="s2">\n        </span><span class="s1">if (value == null) {</span><span class="s2">\n            </span><span class="s1">el.removeAttributeNS(xlinkNS, key.slice(6, key.length));</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">el.setAttributeNS(xlinkNS, key, value);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">// note we are only checking boolean attributes that don't have a</span><span class="s2">\n        </span><span class="s1">// corresponding dom prop of the same name here.</span><span class="s2">\n        </span><span class="s1">const isBoolean = isSpecialBooleanAttr(key);</span><span class="s2">\n        </span><span class="s1">if (value == null || (isBoolean &amp;&amp; !includeBooleanAttr(value))) {</span><span class="s2">\n            </span><span class="s1">el.removeAttribute(key);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">el.setAttribute(key, isBoolean ? '' : value);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// __UNSAFE__</span><span class="s2">\n</span><span class="s1">// functions. The user is responsible for using them with only trusted content.</span><span class="s2">\n</span><span class="s1">function patchDOMProp(el, key, value, </span><span class="s2">\n</span><span class="s1">// the following args are passed only due to potential innerHTML/textContent</span><span class="s2">\n</span><span class="s1">// overriding existing VNodes, in which case the old tree must be properly</span><span class="s2">\n</span><span class="s1">// unmounted.</span><span class="s2">\n</span><span class="s1">prevChildren, parentComponent, parentSuspense, unmountChildren) {</span><span class="s2">\n    </span><span class="s1">if (key === 'innerHTML' || key === 'textContent') {</span><span class="s2">\n        </span><span class="s1">if (prevChildren) {</span><span class="s2">\n            </span><span class="s1">unmountChildren(prevChildren, parentComponent, parentSuspense);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">el[key] = value == null ? '' : value;</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (key === 'value' &amp;&amp;</span><span class="s2">\n        </span><span class="s1">el.tagName !== 'PROGRESS' &amp;&amp;</span><span class="s2">\n        </span><span class="s1">// custom elements may use _value internally</span><span class="s2">\n        </span><span class="s1">!el.tagName.includes('-')) {</span><span class="s2">\n        </span><span class="s1">// store value as _value as well since</span><span class="s2">\n        </span><span class="s1">// non-string values will be stringified.</span><span class="s2">\n        </span><span class="s1">el._value = value;</span><span class="s2">\n        </span><span class="s1">const newValue = value == null ? '' : value;</span><span class="s2">\n        </span><span class="s1">if (el.value !== newValue ||</span><span class="s2">\n            </span><span class="s1">// #4956: always set for OPTION elements because its value falls back to</span><span class="s2">\n            </span><span class="s1">// textContent if no value attribute is present. And setting .value for</span><span class="s2">\n            </span><span class="s1">// OPTION has no side effect</span><span class="s2">\n            </span><span class="s1">el.tagName === 'OPTION') {</span><span class="s2">\n            </span><span class="s1">el.value = newValue;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (value == null) {</span><span class="s2">\n            </span><span class="s1">el.removeAttribute(key);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">let needRemove = false;</span><span class="s2">\n    </span><span class="s1">if (value === '' || value == null) {</span><span class="s2">\n        </span><span class="s1">const type = typeof el[key];</span><span class="s2">\n        </span><span class="s1">if (type === 'boolean') {</span><span class="s2">\n            </span><span class="s1">// e.g. &lt;select multiple&gt; compiles to { multiple: '' }</span><span class="s2">\n            </span><span class="s1">value = includeBooleanAttr(value);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (value == null &amp;&amp; type === 'string') {</span><span class="s2">\n            </span><span class="s1">// e.g. &lt;div :id=</span><span class="s2">\&quot;</span><span class="s1">null</span><span class="s2">\&quot;</span><span class="s1">&gt;</span><span class="s2">\n            </span><span class="s1">value = '';</span><span class="s2">\n            </span><span class="s1">needRemove = true;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (type === 'number') {</span><span class="s2">\n            </span><span class="s1">// e.g. &lt;img :width=</span><span class="s2">\&quot;</span><span class="s1">null</span><span class="s2">\&quot;</span><span class="s1">&gt;</span><span class="s2">\n            </span><span class="s1">value = 0;</span><span class="s2">\n            </span><span class="s1">needRemove = true;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// some properties perform value validation and throw,</span><span class="s2">\n    </span><span class="s1">// some properties has getter, no setter, will error in 'use strict'</span><span class="s2">\n    </span><span class="s1">// eg. &lt;select :type=</span><span class="s2">\&quot;</span><span class="s1">null</span><span class="s2">\&quot;</span><span class="s1">&gt;&lt;/select&gt; &lt;select :willValidate=</span><span class="s2">\&quot;</span><span class="s1">null</span><span class="s2">\&quot;</span><span class="s1">&gt;&lt;/select&gt;</span><span class="s2">\n    </span><span class="s1">try {</span><span class="s2">\n        </span><span class="s1">el[key] = value;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">catch (e) {</span><span class="s2">\n        </span><span class="s1">// do not warn if value is auto-coerced from nullish values</span><span class="s2">\n        </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp; !needRemove) {</span><span class="s2">\n            </span><span class="s1">warn(`Failed setting prop </span><span class="s2">\&quot;</span><span class="s1">${key}</span><span class="s2">\&quot; </span><span class="s1">on &lt;${el.tagName.toLowerCase()}&gt;: ` +</span><span class="s2">\n                </span><span class="s1">`value ${value} is invalid.`, e);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">needRemove &amp;&amp; el.removeAttribute(key);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function addEventListener(el, event, handler, options) {</span><span class="s2">\n    </span><span class="s1">el.addEventListener(event, handler, options);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function removeEventListener(el, event, handler, options) {</span><span class="s2">\n    </span><span class="s1">el.removeEventListener(event, handler, options);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function patchEvent(el, rawName, prevValue, nextValue, instance = null) {</span><span class="s2">\n    </span><span class="s1">// vei = vue event invokers</span><span class="s2">\n    </span><span class="s1">const invokers = el._vei || (el._vei = {});</span><span class="s2">\n    </span><span class="s1">const existingInvoker = invokers[rawName];</span><span class="s2">\n    </span><span class="s1">if (nextValue &amp;&amp; existingInvoker) {</span><span class="s2">\n        </span><span class="s1">// patch</span><span class="s2">\n        </span><span class="s1">existingInvoker.value = nextValue;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">const [name, options] = parseName(rawName);</span><span class="s2">\n        </span><span class="s1">if (nextValue) {</span><span class="s2">\n            </span><span class="s1">// add</span><span class="s2">\n            </span><span class="s1">const invoker = (invokers[rawName] = createInvoker(nextValue, instance));</span><span class="s2">\n            </span><span class="s1">addEventListener(el, name, invoker, options);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (existingInvoker) {</span><span class="s2">\n            </span><span class="s1">// remove</span><span class="s2">\n            </span><span class="s1">removeEventListener(el, name, existingInvoker, options);</span><span class="s2">\n            </span><span class="s1">invokers[rawName] = undefined;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">const optionsModifierRE = /(?:Once|Passive|Capture)$/;</span><span class="s2">\n</span><span class="s1">function parseName(name) {</span><span class="s2">\n    </span><span class="s1">let options;</span><span class="s2">\n    </span><span class="s1">if (optionsModifierRE.test(name)) {</span><span class="s2">\n        </span><span class="s1">options = {};</span><span class="s2">\n        </span><span class="s1">let m;</span><span class="s2">\n        </span><span class="s1">while ((m = name.match(optionsModifierRE))) {</span><span class="s2">\n            </span><span class="s1">name = name.slice(0, name.length - m[0].length);</span><span class="s2">\n            </span><span class="s1">options[m[0].toLowerCase()] = true;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">const event = name[2] === ':' ? name.slice(3) : hyphenate(name.slice(2));</span><span class="s2">\n    </span><span class="s1">return [event, options];</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// To avoid the overhead of repeatedly calling Date.now(), we cache</span><span class="s2">\n</span><span class="s1">// and use the same timestamp for all event listeners attached in the same tick.</span><span class="s2">\n</span><span class="s1">let cachedNow = 0;</span><span class="s2">\n</span><span class="s1">const p = /*#__PURE__*/ Promise.resolve();</span><span class="s2">\n</span><span class="s1">const getNow = () =&gt; cachedNow || (p.then(() =&gt; (cachedNow = 0)), (cachedNow = Date.now()));</span><span class="s2">\n</span><span class="s1">function createInvoker(initialValue, instance) {</span><span class="s2">\n    </span><span class="s1">const invoker = (e) =&gt; {</span><span class="s2">\n        </span><span class="s1">// async edge case vuejs/vue#6566</span><span class="s2">\n        </span><span class="s1">// inner click event triggers patch, event handler</span><span class="s2">\n        </span><span class="s1">// attached to outer element during patch, and triggered again. This</span><span class="s2">\n        </span><span class="s1">// happens because browsers fire microtask ticks between event propagation.</span><span class="s2">\n        </span><span class="s1">// this no longer happens for templates in Vue 3, but could still be</span><span class="s2">\n        </span><span class="s1">// theoretically possible for hand-written render functions.</span><span class="s2">\n        </span><span class="s1">// the solution: we save the timestamp when a handler is attached,</span><span class="s2">\n        </span><span class="s1">// and also attach the timestamp to any event that was handled by vue</span><span class="s2">\n        </span><span class="s1">// for the first time (to avoid inconsistent event timestamp implementations</span><span class="s2">\n        </span><span class="s1">// or events fired from iframes, e.g. #2513)</span><span class="s2">\n        </span><span class="s1">// The handler would only fire if the event passed to it was fired</span><span class="s2">\n        </span><span class="s1">// AFTER it was attached.</span><span class="s2">\n        </span><span class="s1">if (!e._vts) {</span><span class="s2">\n            </span><span class="s1">e._vts = Date.now();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (e._vts &lt;= invoker.attached) {</span><span class="s2">\n            </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">callWithAsyncErrorHandling(patchStopImmediatePropagation(e, invoker.value), instance, 5 /* ErrorCodes.NATIVE_EVENT_HANDLER */, [e]);</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">invoker.value = initialValue;</span><span class="s2">\n    </span><span class="s1">invoker.attached = getNow();</span><span class="s2">\n    </span><span class="s1">return invoker;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function patchStopImmediatePropagation(e, value) {</span><span class="s2">\n    </span><span class="s1">if (isArray(value)) {</span><span class="s2">\n        </span><span class="s1">const originalStop = e.stopImmediatePropagation;</span><span class="s2">\n        </span><span class="s1">e.stopImmediatePropagation = () =&gt; {</span><span class="s2">\n            </span><span class="s1">originalStop.call(e);</span><span class="s2">\n            </span><span class="s1">e._stopped = true;</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n        </span><span class="s1">return value.map(fn =&gt; (e) =&gt; !e._stopped &amp;&amp; fn &amp;&amp; fn(e));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">return value;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">const nativeOnRE = /^on[a-z]/;</span><span class="s2">\n</span><span class="s1">const patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) =&gt; {</span><span class="s2">\n    </span><span class="s1">if (key === 'class') {</span><span class="s2">\n        </span><span class="s1">patchClass(el, nextValue, isSVG);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (key === 'style') {</span><span class="s2">\n        </span><span class="s1">patchStyle(el, prevValue, nextValue);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (isOn(key)) {</span><span class="s2">\n        </span><span class="s1">// ignore v-model listeners</span><span class="s2">\n        </span><span class="s1">if (!isModelListener(key)) {</span><span class="s2">\n            </span><span class="s1">patchEvent(el, key, prevValue, nextValue, parentComponent);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (key[0] === '.'</span><span class="s2">\n        </span><span class="s1">? ((key = key.slice(1)), true)</span><span class="s2">\n        </span><span class="s1">: key[0] === '^'</span><span class="s2">\n            </span><span class="s1">? ((key = key.slice(1)), false)</span><span class="s2">\n            </span><span class="s1">: shouldSetAsProp(el, key, nextValue, isSVG)) {</span><span class="s2">\n        </span><span class="s1">patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">// special case for &lt;input v-model type=</span><span class="s2">\&quot;</span><span class="s1">checkbox</span><span class="s2">\&quot;</span><span class="s1">&gt; with</span><span class="s2">\n        </span><span class="s1">// :true-value &amp; :false-value</span><span class="s2">\n        </span><span class="s1">// store value as dom properties since non-string values will be</span><span class="s2">\n        </span><span class="s1">// stringified.</span><span class="s2">\n        </span><span class="s1">if (key === 'true-value') {</span><span class="s2">\n            </span><span class="s1">el._trueValue = nextValue;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (key === 'false-value') {</span><span class="s2">\n            </span><span class="s1">el._falseValue = nextValue;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">patchAttr(el, key, nextValue, isSVG);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">function shouldSetAsProp(el, key, value, isSVG) {</span><span class="s2">\n    </span><span class="s1">if (isSVG) {</span><span class="s2">\n        </span><span class="s1">// most keys must be set as attribute on svg elements to work</span><span class="s2">\n        </span><span class="s1">// ...except innerHTML &amp; textContent</span><span class="s2">\n        </span><span class="s1">if (key === 'innerHTML' || key === 'textContent') {</span><span class="s2">\n            </span><span class="s1">return true;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// or native onclick with function values</span><span class="s2">\n        </span><span class="s1">if (key in el &amp;&amp; nativeOnRE.test(key) &amp;&amp; isFunction(value)) {</span><span class="s2">\n            </span><span class="s1">return true;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return false;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// these are enumerated attrs, however their corresponding DOM properties</span><span class="s2">\n    </span><span class="s1">// are actually booleans - this leads to setting it with a string </span><span class="s2">\&quot;</span><span class="s1">false</span><span class="s2">\&quot;\n    </span><span class="s1">// value leading it to be coerced to `true`, so we need to always treat</span><span class="s2">\n    </span><span class="s1">// them as attributes.</span><span class="s2">\n    </span><span class="s1">// Note that `contentEditable` doesn't have this problem: its DOM</span><span class="s2">\n    </span><span class="s1">// property is also enumerated string values.</span><span class="s2">\n    </span><span class="s1">if (key === 'spellcheck' || key === 'draggable' || key === 'translate') {</span><span class="s2">\n        </span><span class="s1">return false;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// #1787, #2840 form property on form elements is readonly and must be set as</span><span class="s2">\n    </span><span class="s1">// attribute.</span><span class="s2">\n    </span><span class="s1">if (key === 'form') {</span><span class="s2">\n        </span><span class="s1">return false;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// #1526 &lt;input list&gt; must be set as attribute</span><span class="s2">\n    </span><span class="s1">if (key === 'list' &amp;&amp; el.tagName === 'INPUT') {</span><span class="s2">\n        </span><span class="s1">return false;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// #2766 &lt;textarea type&gt; must be set as attribute</span><span class="s2">\n    </span><span class="s1">if (key === 'type' &amp;&amp; el.tagName === 'TEXTAREA') {</span><span class="s2">\n        </span><span class="s1">return false;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// native onclick with string value, must be set as attribute</span><span class="s2">\n    </span><span class="s1">if (nativeOnRE.test(key) &amp;&amp; isString(value)) {</span><span class="s2">\n        </span><span class="s1">return false;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return key in el;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function defineCustomElement(options, hydrate) {</span><span class="s2">\n    </span><span class="s1">const Comp = defineComponent(options);</span><span class="s2">\n    </span><span class="s1">class VueCustomElement extends VueElement {</span><span class="s2">\n        </span><span class="s1">constructor(initialProps) {</span><span class="s2">\n            </span><span class="s1">super(Comp, initialProps, hydrate);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">VueCustomElement.def = Comp;</span><span class="s2">\n    </span><span class="s1">return VueCustomElement;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">const defineSSRCustomElement = ((options) =&gt; {</span><span class="s2">\n    </span><span class="s1">// @ts-ignore</span><span class="s2">\n    </span><span class="s1">return defineCustomElement(options, hydrate);</span><span class="s2">\n</span><span class="s1">});</span><span class="s2">\n</span><span class="s1">const BaseClass = (typeof HTMLElement !== 'undefined' ? HTMLElement : class {</span><span class="s2">\n</span><span class="s1">});</span><span class="s2">\n</span><span class="s1">class VueElement extends BaseClass {</span><span class="s2">\n    </span><span class="s1">constructor(_def, _props = {}, hydrate) {</span><span class="s2">\n        </span><span class="s1">super();</span><span class="s2">\n        </span><span class="s1">this._def = _def;</span><span class="s2">\n        </span><span class="s1">this._props = _props;</span><span class="s2">\n        </span><span class="s1">/**</span><span class="s2">\n         </span><span class="s1">* @internal</span><span class="s2">\n         </span><span class="s1">*/</span><span class="s2">\n        </span><span class="s1">this._instance = null;</span><span class="s2">\n        </span><span class="s1">this._connected = false;</span><span class="s2">\n        </span><span class="s1">this._resolved = false;</span><span class="s2">\n        </span><span class="s1">this._numberProps = null;</span><span class="s2">\n        </span><span class="s1">if (this.shadowRoot &amp;&amp; hydrate) {</span><span class="s2">\n            </span><span class="s1">hydrate(this._createVNode(), this.shadowRoot);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp; this.shadowRoot) {</span><span class="s2">\n                </span><span class="s1">warn(`Custom element has pre-rendered declarative shadow root but is not ` +</span><span class="s2">\n                    </span><span class="s1">`defined as hydratable. Use </span><span class="s2">\\</span><span class="s1">`defineSSRCustomElement</span><span class="s2">\\</span><span class="s1">`.`);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">this.attachShadow({ mode: 'open' });</span><span class="s2">\n            </span><span class="s1">if (!this._def.__asyncLoader) {</span><span class="s2">\n                </span><span class="s1">// for sync component defs we can immediately resolve props</span><span class="s2">\n                </span><span class="s1">this._resolveProps(this._def);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">connectedCallback() {</span><span class="s2">\n        </span><span class="s1">this._connected = true;</span><span class="s2">\n        </span><span class="s1">if (!this._instance) {</span><span class="s2">\n            </span><span class="s1">if (this._resolved) {</span><span class="s2">\n                </span><span class="s1">this._update();</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">this._resolveDef();</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">disconnectedCallback() {</span><span class="s2">\n        </span><span class="s1">this._connected = false;</span><span class="s2">\n        </span><span class="s1">nextTick(() =&gt; {</span><span class="s2">\n            </span><span class="s1">if (!this._connected) {</span><span class="s2">\n                </span><span class="s1">render(null, this.shadowRoot);</span><span class="s2">\n                </span><span class="s1">this._instance = null;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">/**</span><span class="s2">\n     </span><span class="s1">* resolve inner component definition (handle possible async component)</span><span class="s2">\n     </span><span class="s1">*/</span><span class="s2">\n    </span><span class="s1">_resolveDef() {</span><span class="s2">\n        </span><span class="s1">this._resolved = true;</span><span class="s2">\n        </span><span class="s1">// set initial attrs</span><span class="s2">\n        </span><span class="s1">for (let i = 0; i &lt; this.attributes.length; i++) {</span><span class="s2">\n            </span><span class="s1">this._setAttr(this.attributes[i].name);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// watch future attr changes</span><span class="s2">\n        </span><span class="s1">new MutationObserver(mutations =&gt; {</span><span class="s2">\n            </span><span class="s1">for (const m of mutations) {</span><span class="s2">\n                </span><span class="s1">this._setAttr(m.attributeName);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}).observe(this, { attributes: true });</span><span class="s2">\n        </span><span class="s1">const resolve = (def, isAsync = false) =&gt; {</span><span class="s2">\n            </span><span class="s1">const { props, styles } = def;</span><span class="s2">\n            </span><span class="s1">// cast Number-type props set before resolve</span><span class="s2">\n            </span><span class="s1">let numberProps;</span><span class="s2">\n            </span><span class="s1">if (props &amp;&amp; !isArray(props)) {</span><span class="s2">\n                </span><span class="s1">for (const key in props) {</span><span class="s2">\n                    </span><span class="s1">const opt = props[key];</span><span class="s2">\n                    </span><span class="s1">if (opt === Number || (opt &amp;&amp; opt.type === Number)) {</span><span class="s2">\n                        </span><span class="s1">if (key in this._props) {</span><span class="s2">\n                            </span><span class="s1">this._props[key] = toNumber(this._props[key]);</span><span class="s2">\n                        </span><span class="s1">}</span><span class="s2">\n                        </span><span class="s1">(numberProps || (numberProps = Object.create(null)))[camelize$1(key)] = true;</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">this._numberProps = numberProps;</span><span class="s2">\n            </span><span class="s1">if (isAsync) {</span><span class="s2">\n                </span><span class="s1">// defining getter/setters on prototype</span><span class="s2">\n                </span><span class="s1">// for sync defs, this already happened in the constructor</span><span class="s2">\n                </span><span class="s1">this._resolveProps(def);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">// apply CSS</span><span class="s2">\n            </span><span class="s1">this._applyStyles(styles);</span><span class="s2">\n            </span><span class="s1">// initial render</span><span class="s2">\n            </span><span class="s1">this._update();</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n        </span><span class="s1">const asyncDef = this._def.__asyncLoader;</span><span class="s2">\n        </span><span class="s1">if (asyncDef) {</span><span class="s2">\n            </span><span class="s1">asyncDef().then(def =&gt; resolve(def, true));</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">resolve(this._def);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">_resolveProps(def) {</span><span class="s2">\n        </span><span class="s1">const { props } = def;</span><span class="s2">\n        </span><span class="s1">const declaredPropKeys = isArray(props) ? props : Object.keys(props || {});</span><span class="s2">\n        </span><span class="s1">// check if there are props set pre-upgrade or connect</span><span class="s2">\n        </span><span class="s1">for (const key of Object.keys(this)) {</span><span class="s2">\n            </span><span class="s1">if (key[0] !== '_' &amp;&amp; declaredPropKeys.includes(key)) {</span><span class="s2">\n                </span><span class="s1">this._setProp(key, this[key], true, false);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// defining getter/setters on prototype</span><span class="s2">\n        </span><span class="s1">for (const key of declaredPropKeys.map(camelize$1)) {</span><span class="s2">\n            </span><span class="s1">Object.defineProperty(this, key, {</span><span class="s2">\n                </span><span class="s1">get() {</span><span class="s2">\n                    </span><span class="s1">return this._getProp(key);</span><span class="s2">\n                </span><span class="s1">},</span><span class="s2">\n                </span><span class="s1">set(val) {</span><span class="s2">\n                    </span><span class="s1">this._setProp(key, val);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">_setAttr(key) {</span><span class="s2">\n        </span><span class="s1">let value = this.getAttribute(key);</span><span class="s2">\n        </span><span class="s1">const camelKey = camelize$1(key);</span><span class="s2">\n        </span><span class="s1">if (this._numberProps &amp;&amp; this._numberProps[camelKey]) {</span><span class="s2">\n            </span><span class="s1">value = toNumber(value);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">this._setProp(camelKey, value, false);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">/**</span><span class="s2">\n     </span><span class="s1">* @internal</span><span class="s2">\n     </span><span class="s1">*/</span><span class="s2">\n    </span><span class="s1">_getProp(key) {</span><span class="s2">\n        </span><span class="s1">return this._props[key];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">/**</span><span class="s2">\n     </span><span class="s1">* @internal</span><span class="s2">\n     </span><span class="s1">*/</span><span class="s2">\n    </span><span class="s1">_setProp(key, val, shouldReflect = true, shouldUpdate = true) {</span><span class="s2">\n        </span><span class="s1">if (val !== this._props[key]) {</span><span class="s2">\n            </span><span class="s1">this._props[key] = val;</span><span class="s2">\n            </span><span class="s1">if (shouldUpdate &amp;&amp; this._instance) {</span><span class="s2">\n                </span><span class="s1">this._update();</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">// reflect</span><span class="s2">\n            </span><span class="s1">if (shouldReflect) {</span><span class="s2">\n                </span><span class="s1">if (val === true) {</span><span class="s2">\n                    </span><span class="s1">this.setAttribute(hyphenate(key), '');</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else if (typeof val === 'string' || typeof val === 'number') {</span><span class="s2">\n                    </span><span class="s1">this.setAttribute(hyphenate(key), val + '');</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else if (!val) {</span><span class="s2">\n                    </span><span class="s1">this.removeAttribute(hyphenate(key));</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">_update() {</span><span class="s2">\n        </span><span class="s1">render(this._createVNode(), this.shadowRoot);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">_createVNode() {</span><span class="s2">\n        </span><span class="s1">const vnode = createVNode(this._def, extend({}, this._props));</span><span class="s2">\n        </span><span class="s1">if (!this._instance) {</span><span class="s2">\n            </span><span class="s1">vnode.ce = instance =&gt; {</span><span class="s2">\n                </span><span class="s1">this._instance = instance;</span><span class="s2">\n                </span><span class="s1">instance.isCE = true;</span><span class="s2">\n                </span><span class="s1">// HMR</span><span class="s2">\n                </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n                    </span><span class="s1">instance.ceReload = newStyles =&gt; {</span><span class="s2">\n                        </span><span class="s1">// always reset styles</span><span class="s2">\n                        </span><span class="s1">if (this._styles) {</span><span class="s2">\n                            </span><span class="s1">this._styles.forEach(s =&gt; this.shadowRoot.removeChild(s));</span><span class="s2">\n                            </span><span class="s1">this._styles.length = 0;</span><span class="s2">\n                        </span><span class="s1">}</span><span class="s2">\n                        </span><span class="s1">this._applyStyles(newStyles);</span><span class="s2">\n                        </span><span class="s1">this._instance = null;</span><span class="s2">\n                        </span><span class="s1">this._update();</span><span class="s2">\n                    </span><span class="s1">};</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">const dispatch = (event, args) =&gt; {</span><span class="s2">\n                    </span><span class="s1">this.dispatchEvent(new CustomEvent(event, {</span><span class="s2">\n                        </span><span class="s1">detail: args</span><span class="s2">\n                    </span><span class="s1">}));</span><span class="s2">\n                </span><span class="s1">};</span><span class="s2">\n                </span><span class="s1">// intercept emit</span><span class="s2">\n                </span><span class="s1">instance.emit = (event, ...args) =&gt; {</span><span class="s2">\n                    </span><span class="s1">// dispatch both the raw and hyphenated versions of an event</span><span class="s2">\n                    </span><span class="s1">// to match Vue behavior</span><span class="s2">\n                    </span><span class="s1">dispatch(event, args);</span><span class="s2">\n                    </span><span class="s1">if (hyphenate(event) !== event) {</span><span class="s2">\n                        </span><span class="s1">dispatch(hyphenate(event), args);</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">};</span><span class="s2">\n                </span><span class="s1">// locate nearest Vue custom element parent for provide/inject</span><span class="s2">\n                </span><span class="s1">let parent = this;</span><span class="s2">\n                </span><span class="s1">while ((parent =</span><span class="s2">\n                    </span><span class="s1">parent &amp;&amp; (parent.parentNode || parent.host))) {</span><span class="s2">\n                    </span><span class="s1">if (parent instanceof VueElement) {</span><span class="s2">\n                        </span><span class="s1">instance.parent = parent._instance;</span><span class="s2">\n                        </span><span class="s1">instance.provides = parent._instance.provides;</span><span class="s2">\n                        </span><span class="s1">break;</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">};</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return vnode;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">_applyStyles(styles) {</span><span class="s2">\n        </span><span class="s1">if (styles) {</span><span class="s2">\n            </span><span class="s1">styles.forEach(css =&gt; {</span><span class="s2">\n                </span><span class="s1">const s = document.createElement('style');</span><span class="s2">\n                </span><span class="s1">s.textContent = css;</span><span class="s2">\n                </span><span class="s1">this.shadowRoot.appendChild(s);</span><span class="s2">\n                </span><span class="s1">// record for HMR</span><span class="s2">\n                </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n                    </span><span class="s1">(this._styles || (this._styles = [])).push(s);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">function useCssModule(name = '$style') {</span><span class="s2">\n    </span><span class="s1">/* istanbul ignore else */</span><span class="s2">\n    </span><span class="s1">{</span><span class="s2">\n        </span><span class="s1">const instance = getCurrentInstance();</span><span class="s2">\n        </span><span class="s1">if (!instance) {</span><span class="s2">\n            </span><span class="s1">(process.env.NODE_ENV !== 'production') &amp;&amp; warn(`useCssModule must be called inside setup()`);</span><span class="s2">\n            </span><span class="s1">return EMPTY_OBJ;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">const modules = instance.type.__cssModules;</span><span class="s2">\n        </span><span class="s1">if (!modules) {</span><span class="s2">\n            </span><span class="s1">(process.env.NODE_ENV !== 'production') &amp;&amp; warn(`Current instance does not have CSS modules injected.`);</span><span class="s2">\n            </span><span class="s1">return EMPTY_OBJ;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">const mod = modules[name];</span><span class="s2">\n        </span><span class="s1">if (!mod) {</span><span class="s2">\n            </span><span class="s1">(process.env.NODE_ENV !== 'production') &amp;&amp;</span><span class="s2">\n                </span><span class="s1">warn(`Current instance does not have CSS module named </span><span class="s2">\&quot;</span><span class="s1">${name}</span><span class="s2">\&quot;</span><span class="s1">.`);</span><span class="s2">\n            </span><span class="s1">return EMPTY_OBJ;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return mod;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Runtime helper for SFC's CSS variable injection feature.</span><span class="s2">\n </span><span class="s1">* @private</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">function useCssVars(getter) {</span><span class="s2">\n    </span><span class="s1">const instance = getCurrentInstance();</span><span class="s2">\n    </span><span class="s1">/* istanbul ignore next */</span><span class="s2">\n    </span><span class="s1">if (!instance) {</span><span class="s2">\n        </span><span class="s1">(process.env.NODE_ENV !== 'production') &amp;&amp;</span><span class="s2">\n            </span><span class="s1">warn(`useCssVars is called without current active component instance.`);</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">const updateTeleports = (instance.ut = (vars = getter(instance.proxy)) =&gt; {</span><span class="s2">\n        </span><span class="s1">Array.from(document.querySelectorAll(`[data-v-owner=</span><span class="s2">\&quot;</span><span class="s1">${instance.uid}</span><span class="s2">\&quot;</span><span class="s1">]`)).forEach(node =&gt; setVarsOnNode(node, vars));</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">const setVars = () =&gt; {</span><span class="s2">\n        </span><span class="s1">const vars = getter(instance.proxy);</span><span class="s2">\n        </span><span class="s1">setVarsOnVNode(instance.subTree, vars);</span><span class="s2">\n        </span><span class="s1">updateTeleports(vars);</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">watchPostEffect(setVars);</span><span class="s2">\n    </span><span class="s1">onMounted(() =&gt; {</span><span class="s2">\n        </span><span class="s1">const ob = new MutationObserver(setVars);</span><span class="s2">\n        </span><span class="s1">ob.observe(instance.subTree.el.parentNode, { childList: true });</span><span class="s2">\n        </span><span class="s1">onUnmounted(() =&gt; ob.disconnect());</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function setVarsOnVNode(vnode, vars) {</span><span class="s2">\n    </span><span class="s1">if (vnode.shapeFlag &amp; 128 /* ShapeFlags.SUSPENSE */) {</span><span class="s2">\n        </span><span class="s1">const suspense = vnode.suspense;</span><span class="s2">\n        </span><span class="s1">vnode = suspense.activeBranch;</span><span class="s2">\n        </span><span class="s1">if (suspense.pendingBranch &amp;&amp; !suspense.isHydrating) {</span><span class="s2">\n            </span><span class="s1">suspense.effects.push(() =&gt; {</span><span class="s2">\n                </span><span class="s1">setVarsOnVNode(suspense.activeBranch, vars);</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">// drill down HOCs until it's a non-component vnode</span><span class="s2">\n    </span><span class="s1">while (vnode.component) {</span><span class="s2">\n        </span><span class="s1">vnode = vnode.component.subTree;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (vnode.shapeFlag &amp; 1 /* ShapeFlags.ELEMENT */ &amp;&amp; vnode.el) {</span><span class="s2">\n        </span><span class="s1">setVarsOnNode(vnode.el, vars);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (vnode.type === Fragment) {</span><span class="s2">\n        </span><span class="s1">vnode.children.forEach(c =&gt; setVarsOnVNode(c, vars));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (vnode.type === Static) {</span><span class="s2">\n        </span><span class="s1">let { el, anchor } = vnode;</span><span class="s2">\n        </span><span class="s1">while (el) {</span><span class="s2">\n            </span><span class="s1">setVarsOnNode(el, vars);</span><span class="s2">\n            </span><span class="s1">if (el === anchor)</span><span class="s2">\n                </span><span class="s1">break;</span><span class="s2">\n            </span><span class="s1">el = el.nextSibling;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function setVarsOnNode(el, vars) {</span><span class="s2">\n    </span><span class="s1">if (el.nodeType === 1) {</span><span class="s2">\n        </span><span class="s1">const style = el.style;</span><span class="s2">\n        </span><span class="s1">for (const key in vars) {</span><span class="s2">\n            </span><span class="s1">style.setProperty(`--${key}`, vars[key]);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">const TRANSITION = 'transition';</span><span class="s2">\n</span><span class="s1">const ANIMATION = 'animation';</span><span class="s2">\n</span><span class="s1">// DOM Transition is a higher-order-component based on the platform-agnostic</span><span class="s2">\n</span><span class="s1">// base Transition component, with DOM-specific logic.</span><span class="s2">\n</span><span class="s1">const Transition = (props, { slots }) =&gt; h(BaseTransition, resolveTransitionProps(props), slots);</span><span class="s2">\n</span><span class="s1">Transition.displayName = 'Transition';</span><span class="s2">\n</span><span class="s1">const DOMTransitionPropsValidators = {</span><span class="s2">\n    </span><span class="s1">name: String,</span><span class="s2">\n    </span><span class="s1">type: String,</span><span class="s2">\n    </span><span class="s1">css: {</span><span class="s2">\n        </span><span class="s1">type: Boolean,</span><span class="s2">\n        </span><span class="s1">default: true</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">duration: [String, Number, Object],</span><span class="s2">\n    </span><span class="s1">enterFromClass: String,</span><span class="s2">\n    </span><span class="s1">enterActiveClass: String,</span><span class="s2">\n    </span><span class="s1">enterToClass: String,</span><span class="s2">\n    </span><span class="s1">appearFromClass: String,</span><span class="s2">\n    </span><span class="s1">appearActiveClass: String,</span><span class="s2">\n    </span><span class="s1">appearToClass: String,</span><span class="s2">\n    </span><span class="s1">leaveFromClass: String,</span><span class="s2">\n    </span><span class="s1">leaveActiveClass: String,</span><span class="s2">\n    </span><span class="s1">leaveToClass: String</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">const TransitionPropsValidators = (Transition.props =</span><span class="s2">\n    </span><span class="s1">/*#__PURE__*/ extend({}, BaseTransition.props, DOMTransitionPropsValidators));</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* #3227 Incoming hooks may be merged into arrays when wrapping Transition</span><span class="s2">\n </span><span class="s1">* with custom HOCs.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const callHook = (hook, args = []) =&gt; {</span><span class="s2">\n    </span><span class="s1">if (isArray(hook)) {</span><span class="s2">\n        </span><span class="s1">hook.forEach(h =&gt; h(...args));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (hook) {</span><span class="s2">\n        </span><span class="s1">hook(...args);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* Check if a hook expects a callback (2nd arg), which means the user</span><span class="s2">\n </span><span class="s1">* intends to explicitly control the end of the transition.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const hasExplicitCallback = (hook) =&gt; {</span><span class="s2">\n    </span><span class="s1">return hook</span><span class="s2">\n        </span><span class="s1">? isArray(hook)</span><span class="s2">\n            </span><span class="s1">? hook.some(h =&gt; h.length &gt; 1)</span><span class="s2">\n            </span><span class="s1">: hook.length &gt; 1</span><span class="s2">\n        </span><span class="s1">: false;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">function resolveTransitionProps(rawProps) {</span><span class="s2">\n    </span><span class="s1">const baseProps = {};</span><span class="s2">\n    </span><span class="s1">for (const key in rawProps) {</span><span class="s2">\n        </span><span class="s1">if (!(key in DOMTransitionPropsValidators)) {</span><span class="s2">\n            </span><span class="s1">baseProps[key] = rawProps[key];</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (rawProps.css === false) {</span><span class="s2">\n        </span><span class="s1">return baseProps;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">const { name = 'v', type, duration, enterFromClass = `${name}-enter-from`, enterActiveClass = `${name}-enter-active`, enterToClass = `${name}-enter-to`, appearFromClass = enterFromClass, appearActiveClass = enterActiveClass, appearToClass = enterToClass, leaveFromClass = `${name}-leave-from`, leaveActiveClass = `${name}-leave-active`, leaveToClass = `${name}-leave-to` } = rawProps;</span><span class="s2">\n    </span><span class="s1">const durations = normalizeDuration(duration);</span><span class="s2">\n    </span><span class="s1">const enterDuration = durations &amp;&amp; durations[0];</span><span class="s2">\n    </span><span class="s1">const leaveDuration = durations &amp;&amp; durations[1];</span><span class="s2">\n    </span><span class="s1">const { onBeforeEnter, onEnter, onEnterCancelled, onLeave, onLeaveCancelled, onBeforeAppear = onBeforeEnter, onAppear = onEnter, onAppearCancelled = onEnterCancelled } = baseProps;</span><span class="s2">\n    </span><span class="s1">const finishEnter = (el, isAppear, done) =&gt; {</span><span class="s2">\n        </span><span class="s1">removeTransitionClass(el, isAppear ? appearToClass : enterToClass);</span><span class="s2">\n        </span><span class="s1">removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);</span><span class="s2">\n        </span><span class="s1">done &amp;&amp; done();</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">const finishLeave = (el, done) =&gt; {</span><span class="s2">\n        </span><span class="s1">el._isLeaving = false;</span><span class="s2">\n        </span><span class="s1">removeTransitionClass(el, leaveFromClass);</span><span class="s2">\n        </span><span class="s1">removeTransitionClass(el, leaveToClass);</span><span class="s2">\n        </span><span class="s1">removeTransitionClass(el, leaveActiveClass);</span><span class="s2">\n        </span><span class="s1">done &amp;&amp; done();</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">const makeEnterHook = (isAppear) =&gt; {</span><span class="s2">\n        </span><span class="s1">return (el, done) =&gt; {</span><span class="s2">\n            </span><span class="s1">const hook = isAppear ? onAppear : onEnter;</span><span class="s2">\n            </span><span class="s1">const resolve = () =&gt; finishEnter(el, isAppear, done);</span><span class="s2">\n            </span><span class="s1">callHook(hook, [el, resolve]);</span><span class="s2">\n            </span><span class="s1">nextFrame(() =&gt; {</span><span class="s2">\n                </span><span class="s1">removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);</span><span class="s2">\n                </span><span class="s1">addTransitionClass(el, isAppear ? appearToClass : enterToClass);</span><span class="s2">\n                </span><span class="s1">if (!hasExplicitCallback(hook)) {</span><span class="s2">\n                    </span><span class="s1">whenTransitionEnds(el, type, enterDuration, resolve);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">return extend(baseProps, {</span><span class="s2">\n        </span><span class="s1">onBeforeEnter(el) {</span><span class="s2">\n            </span><span class="s1">callHook(onBeforeEnter, [el]);</span><span class="s2">\n            </span><span class="s1">addTransitionClass(el, enterFromClass);</span><span class="s2">\n            </span><span class="s1">addTransitionClass(el, enterActiveClass);</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">onBeforeAppear(el) {</span><span class="s2">\n            </span><span class="s1">callHook(onBeforeAppear, [el]);</span><span class="s2">\n            </span><span class="s1">addTransitionClass(el, appearFromClass);</span><span class="s2">\n            </span><span class="s1">addTransitionClass(el, appearActiveClass);</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">onEnter: makeEnterHook(false),</span><span class="s2">\n        </span><span class="s1">onAppear: makeEnterHook(true),</span><span class="s2">\n        </span><span class="s1">onLeave(el, done) {</span><span class="s2">\n            </span><span class="s1">el._isLeaving = true;</span><span class="s2">\n            </span><span class="s1">const resolve = () =&gt; finishLeave(el, done);</span><span class="s2">\n            </span><span class="s1">addTransitionClass(el, leaveFromClass);</span><span class="s2">\n            </span><span class="s1">// force reflow so *-leave-from classes immediately take effect (#2593)</span><span class="s2">\n            </span><span class="s1">forceReflow();</span><span class="s2">\n            </span><span class="s1">addTransitionClass(el, leaveActiveClass);</span><span class="s2">\n            </span><span class="s1">nextFrame(() =&gt; {</span><span class="s2">\n                </span><span class="s1">if (!el._isLeaving) {</span><span class="s2">\n                    </span><span class="s1">// cancelled</span><span class="s2">\n                    </span><span class="s1">return;</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">removeTransitionClass(el, leaveFromClass);</span><span class="s2">\n                </span><span class="s1">addTransitionClass(el, leaveToClass);</span><span class="s2">\n                </span><span class="s1">if (!hasExplicitCallback(onLeave)) {</span><span class="s2">\n                    </span><span class="s1">whenTransitionEnds(el, type, leaveDuration, resolve);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n            </span><span class="s1">callHook(onLeave, [el, resolve]);</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">onEnterCancelled(el) {</span><span class="s2">\n            </span><span class="s1">finishEnter(el, false);</span><span class="s2">\n            </span><span class="s1">callHook(onEnterCancelled, [el]);</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">onAppearCancelled(el) {</span><span class="s2">\n            </span><span class="s1">finishEnter(el, true);</span><span class="s2">\n            </span><span class="s1">callHook(onAppearCancelled, [el]);</span><span class="s2">\n        </span><span class="s1">},</span><span class="s2">\n        </span><span class="s1">onLeaveCancelled(el) {</span><span class="s2">\n            </span><span class="s1">finishLeave(el);</span><span class="s2">\n            </span><span class="s1">callHook(onLeaveCancelled, [el]);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function normalizeDuration(duration) {</span><span class="s2">\n    </span><span class="s1">if (duration == null) {</span><span class="s2">\n        </span><span class="s1">return null;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (isObject(duration)) {</span><span class="s2">\n        </span><span class="s1">return [NumberOf(duration.enter), NumberOf(duration.leave)];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">const n = NumberOf(duration);</span><span class="s2">\n        </span><span class="s1">return [n, n];</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function NumberOf(val) {</span><span class="s2">\n    </span><span class="s1">const res = toNumber(val);</span><span class="s2">\n    </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n        </span><span class="s1">assertNumber(res, '&lt;transition&gt; explicit duration');</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return res;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function addTransitionClass(el, cls) {</span><span class="s2">\n    </span><span class="s1">cls.split(/</span><span class="s2">\\</span><span class="s1">s+/).forEach(c =&gt; c &amp;&amp; el.classList.add(c));</span><span class="s2">\n    </span><span class="s1">(el._vtc ||</span><span class="s2">\n        </span><span class="s1">(el._vtc = new Set())).add(cls);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function removeTransitionClass(el, cls) {</span><span class="s2">\n    </span><span class="s1">cls.split(/</span><span class="s2">\\</span><span class="s1">s+/).forEach(c =&gt; c &amp;&amp; el.classList.remove(c));</span><span class="s2">\n    </span><span class="s1">const { _vtc } = el;</span><span class="s2">\n    </span><span class="s1">if (_vtc) {</span><span class="s2">\n        </span><span class="s1">_vtc.delete(cls);</span><span class="s2">\n        </span><span class="s1">if (!_vtc.size) {</span><span class="s2">\n            </span><span class="s1">el._vtc = undefined;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function nextFrame(cb) {</span><span class="s2">\n    </span><span class="s1">requestAnimationFrame(() =&gt; {</span><span class="s2">\n        </span><span class="s1">requestAnimationFrame(cb);</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">let endId = 0;</span><span class="s2">\n</span><span class="s1">function whenTransitionEnds(el, expectedType, explicitTimeout, resolve) {</span><span class="s2">\n    </span><span class="s1">const id = (el._endId = ++endId);</span><span class="s2">\n    </span><span class="s1">const resolveIfNotStale = () =&gt; {</span><span class="s2">\n        </span><span class="s1">if (id === el._endId) {</span><span class="s2">\n            </span><span class="s1">resolve();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">if (explicitTimeout) {</span><span class="s2">\n        </span><span class="s1">return setTimeout(resolveIfNotStale, explicitTimeout);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">const { type, timeout, propCount } = getTransitionInfo(el, expectedType);</span><span class="s2">\n    </span><span class="s1">if (!type) {</span><span class="s2">\n        </span><span class="s1">return resolve();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">const endEvent = type + 'end';</span><span class="s2">\n    </span><span class="s1">let ended = 0;</span><span class="s2">\n    </span><span class="s1">const end = () =&gt; {</span><span class="s2">\n        </span><span class="s1">el.removeEventListener(endEvent, onEnd);</span><span class="s2">\n        </span><span class="s1">resolveIfNotStale();</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">const onEnd = (e) =&gt; {</span><span class="s2">\n        </span><span class="s1">if (e.target === el &amp;&amp; ++ended &gt;= propCount) {</span><span class="s2">\n            </span><span class="s1">end();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">setTimeout(() =&gt; {</span><span class="s2">\n        </span><span class="s1">if (ended &lt; propCount) {</span><span class="s2">\n            </span><span class="s1">end();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}, timeout + 1);</span><span class="s2">\n    </span><span class="s1">el.addEventListener(endEvent, onEnd);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getTransitionInfo(el, expectedType) {</span><span class="s2">\n    </span><span class="s1">const styles = window.getComputedStyle(el);</span><span class="s2">\n    </span><span class="s1">// JSDOM may return undefined for transition properties</span><span class="s2">\n    </span><span class="s1">const getStyleProperties = (key) =&gt; (styles[key] || '').split(', ');</span><span class="s2">\n    </span><span class="s1">const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);</span><span class="s2">\n    </span><span class="s1">const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);</span><span class="s2">\n    </span><span class="s1">const transitionTimeout = getTimeout(transitionDelays, transitionDurations);</span><span class="s2">\n    </span><span class="s1">const animationDelays = getStyleProperties(`${ANIMATION}Delay`);</span><span class="s2">\n    </span><span class="s1">const animationDurations = getStyleProperties(`${ANIMATION}Duration`);</span><span class="s2">\n    </span><span class="s1">const animationTimeout = getTimeout(animationDelays, animationDurations);</span><span class="s2">\n    </span><span class="s1">let type = null;</span><span class="s2">\n    </span><span class="s1">let timeout = 0;</span><span class="s2">\n    </span><span class="s1">let propCount = 0;</span><span class="s2">\n    </span><span class="s1">/* istanbul ignore if */</span><span class="s2">\n    </span><span class="s1">if (expectedType === TRANSITION) {</span><span class="s2">\n        </span><span class="s1">if (transitionTimeout &gt; 0) {</span><span class="s2">\n            </span><span class="s1">type = TRANSITION;</span><span class="s2">\n            </span><span class="s1">timeout = transitionTimeout;</span><span class="s2">\n            </span><span class="s1">propCount = transitionDurations.length;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (expectedType === ANIMATION) {</span><span class="s2">\n        </span><span class="s1">if (animationTimeout &gt; 0) {</span><span class="s2">\n            </span><span class="s1">type = ANIMATION;</span><span class="s2">\n            </span><span class="s1">timeout = animationTimeout;</span><span class="s2">\n            </span><span class="s1">propCount = animationDurations.length;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else {</span><span class="s2">\n        </span><span class="s1">timeout = Math.max(transitionTimeout, animationTimeout);</span><span class="s2">\n        </span><span class="s1">type =</span><span class="s2">\n            </span><span class="s1">timeout &gt; 0</span><span class="s2">\n                </span><span class="s1">? transitionTimeout &gt; animationTimeout</span><span class="s2">\n                    </span><span class="s1">? TRANSITION</span><span class="s2">\n                    </span><span class="s1">: ANIMATION</span><span class="s2">\n                </span><span class="s1">: null;</span><span class="s2">\n        </span><span class="s1">propCount = type</span><span class="s2">\n            </span><span class="s1">? type === TRANSITION</span><span class="s2">\n                </span><span class="s1">? transitionDurations.length</span><span class="s2">\n                </span><span class="s1">: animationDurations.length</span><span class="s2">\n            </span><span class="s1">: 0;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">const hasTransform = type === TRANSITION &amp;&amp;</span><span class="s2">\n        </span><span class="s1">/</span><span class="s2">\\</span><span class="s1">b(transform|all)(,|$)/.test(getStyleProperties(`${TRANSITION}Property`).toString());</span><span class="s2">\n    </span><span class="s1">return {</span><span class="s2">\n        </span><span class="s1">type,</span><span class="s2">\n        </span><span class="s1">timeout,</span><span class="s2">\n        </span><span class="s1">propCount,</span><span class="s2">\n        </span><span class="s1">hasTransform</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function getTimeout(delays, durations) {</span><span class="s2">\n    </span><span class="s1">while (delays.length &lt; durations.length) {</span><span class="s2">\n        </span><span class="s1">delays = delays.concat(delays);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return Math.max(...durations.map((d, i) =&gt; toMs(d) + toMs(delays[i])));</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// Old versions of Chromium (below 61.0.3163.100) formats floating pointer</span><span class="s2">\n</span><span class="s1">// numbers in a locale-dependent way, using a comma instead of a dot.</span><span class="s2">\n</span><span class="s1">// If comma is not replaced with a dot, the input will be rounded down</span><span class="s2">\n</span><span class="s1">// (i.e. acting as a floor function) causing unexpected behaviors</span><span class="s2">\n</span><span class="s1">function toMs(s) {</span><span class="s2">\n    </span><span class="s1">return Number(s.slice(0, -1).replace(',', '.')) * 1000;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// synchronously force layout to put elements into a certain state</span><span class="s2">\n</span><span class="s1">function forceReflow() {</span><span class="s2">\n    </span><span class="s1">return document.body.offsetHeight;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">const positionMap = new WeakMap();</span><span class="s2">\n</span><span class="s1">const newPositionMap = new WeakMap();</span><span class="s2">\n</span><span class="s1">const TransitionGroupImpl = {</span><span class="s2">\n    </span><span class="s1">name: 'TransitionGroup',</span><span class="s2">\n    </span><span class="s1">props: /*#__PURE__*/ extend({}, TransitionPropsValidators, {</span><span class="s2">\n        </span><span class="s1">tag: String,</span><span class="s2">\n        </span><span class="s1">moveClass: String</span><span class="s2">\n    </span><span class="s1">}),</span><span class="s2">\n    </span><span class="s1">setup(props, { slots }) {</span><span class="s2">\n        </span><span class="s1">const instance = getCurrentInstance();</span><span class="s2">\n        </span><span class="s1">const state = useTransitionState();</span><span class="s2">\n        </span><span class="s1">let prevChildren;</span><span class="s2">\n        </span><span class="s1">let children;</span><span class="s2">\n        </span><span class="s1">onUpdated(() =&gt; {</span><span class="s2">\n            </span><span class="s1">// children is guaranteed to exist after initial render</span><span class="s2">\n            </span><span class="s1">if (!prevChildren.length) {</span><span class="s2">\n                </span><span class="s1">return;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">const moveClass = props.moveClass || `${props.name || 'v'}-move`;</span><span class="s2">\n            </span><span class="s1">if (!hasCSSTransform(prevChildren[0].el, instance.vnode.el, moveClass)) {</span><span class="s2">\n                </span><span class="s1">return;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">// we divide the work into three loops to avoid mixing DOM reads and writes</span><span class="s2">\n            </span><span class="s1">// in each iteration - which helps prevent layout thrashing.</span><span class="s2">\n            </span><span class="s1">prevChildren.forEach(callPendingCbs);</span><span class="s2">\n            </span><span class="s1">prevChildren.forEach(recordPosition);</span><span class="s2">\n            </span><span class="s1">const movedChildren = prevChildren.filter(applyTranslation);</span><span class="s2">\n            </span><span class="s1">// force reflow to put everything in position</span><span class="s2">\n            </span><span class="s1">forceReflow();</span><span class="s2">\n            </span><span class="s1">movedChildren.forEach(c =&gt; {</span><span class="s2">\n                </span><span class="s1">const el = c.el;</span><span class="s2">\n                </span><span class="s1">const style = el.style;</span><span class="s2">\n                </span><span class="s1">addTransitionClass(el, moveClass);</span><span class="s2">\n                </span><span class="s1">style.transform = style.webkitTransform = style.transitionDuration = '';</span><span class="s2">\n                </span><span class="s1">const cb = (el._moveCb = (e) =&gt; {</span><span class="s2">\n                    </span><span class="s1">if (e &amp;&amp; e.target !== el) {</span><span class="s2">\n                        </span><span class="s1">return;</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                    </span><span class="s1">if (!e || /transform$/.test(e.propertyName)) {</span><span class="s2">\n                        </span><span class="s1">el.removeEventListener('transitionend', cb);</span><span class="s2">\n                        </span><span class="s1">el._moveCb = null;</span><span class="s2">\n                        </span><span class="s1">removeTransitionClass(el, moveClass);</span><span class="s2">\n                    </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">});</span><span class="s2">\n                </span><span class="s1">el.addEventListener('transitionend', cb);</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">return () =&gt; {</span><span class="s2">\n            </span><span class="s1">const rawProps = toRaw(props);</span><span class="s2">\n            </span><span class="s1">const cssTransitionProps = resolveTransitionProps(rawProps);</span><span class="s2">\n            </span><span class="s1">let tag = rawProps.tag || Fragment;</span><span class="s2">\n            </span><span class="s1">prevChildren = children;</span><span class="s2">\n            </span><span class="s1">children = slots.default ? getTransitionRawChildren(slots.default()) : [];</span><span class="s2">\n            </span><span class="s1">for (let i = 0; i &lt; children.length; i++) {</span><span class="s2">\n                </span><span class="s1">const child = children[i];</span><span class="s2">\n                </span><span class="s1">if (child.key != null) {</span><span class="s2">\n                    </span><span class="s1">setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state, instance));</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n                    </span><span class="s1">warn(`&lt;TransitionGroup&gt; children must be keyed.`);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">if (prevChildren) {</span><span class="s2">\n                </span><span class="s1">for (let i = 0; i &lt; prevChildren.length; i++) {</span><span class="s2">\n                    </span><span class="s1">const child = prevChildren[i];</span><span class="s2">\n                    </span><span class="s1">setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state, instance));</span><span class="s2">\n                    </span><span class="s1">positionMap.set(child, child.el.getBoundingClientRect());</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">return createVNode(tag, null, children);</span><span class="s2">\n        </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* TransitionGroup does not support </span><span class="s2">\&quot;</span><span class="s1">mode</span><span class="s2">\&quot; </span><span class="s1">so we need to remove it from the</span><span class="s2">\n </span><span class="s1">* props declarations, but direct delete operation is considered a side effect</span><span class="s2">\n </span><span class="s1">* and will make the entire transition feature non-tree-shakeable, so we do it</span><span class="s2">\n </span><span class="s1">* in a function and mark the function's invocation as pure.</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const removeMode = (props) =&gt; delete props.mode;</span><span class="s2">\n</span><span class="s1">/*#__PURE__*/ removeMode(TransitionGroupImpl.props);</span><span class="s2">\n</span><span class="s1">const TransitionGroup = TransitionGroupImpl;</span><span class="s2">\n</span><span class="s1">function callPendingCbs(c) {</span><span class="s2">\n    </span><span class="s1">const el = c.el;</span><span class="s2">\n    </span><span class="s1">if (el._moveCb) {</span><span class="s2">\n        </span><span class="s1">el._moveCb();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (el._enterCb) {</span><span class="s2">\n        </span><span class="s1">el._enterCb();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function recordPosition(c) {</span><span class="s2">\n    </span><span class="s1">newPositionMap.set(c, c.el.getBoundingClientRect());</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function applyTranslation(c) {</span><span class="s2">\n    </span><span class="s1">const oldPos = positionMap.get(c);</span><span class="s2">\n    </span><span class="s1">const newPos = newPositionMap.get(c);</span><span class="s2">\n    </span><span class="s1">const dx = oldPos.left - newPos.left;</span><span class="s2">\n    </span><span class="s1">const dy = oldPos.top - newPos.top;</span><span class="s2">\n    </span><span class="s1">if (dx || dy) {</span><span class="s2">\n        </span><span class="s1">const s = c.el.style;</span><span class="s2">\n        </span><span class="s1">s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;</span><span class="s2">\n        </span><span class="s1">s.transitionDuration = '0s';</span><span class="s2">\n        </span><span class="s1">return c;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function hasCSSTransform(el, root, moveClass) {</span><span class="s2">\n    </span><span class="s1">// Detect whether an element with the move class applied has</span><span class="s2">\n    </span><span class="s1">// CSS transitions. Since the element may be inside an entering</span><span class="s2">\n    </span><span class="s1">// transition at this very moment, we make a clone of it and remove</span><span class="s2">\n    </span><span class="s1">// all other transition classes applied to ensure only the move class</span><span class="s2">\n    </span><span class="s1">// is applied.</span><span class="s2">\n    </span><span class="s1">const clone = el.cloneNode();</span><span class="s2">\n    </span><span class="s1">if (el._vtc) {</span><span class="s2">\n        </span><span class="s1">el._vtc.forEach(cls =&gt; {</span><span class="s2">\n            </span><span class="s1">cls.split(/</span><span class="s2">\\</span><span class="s1">s+/).forEach(c =&gt; c &amp;&amp; clone.classList.remove(c));</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">moveClass.split(/</span><span class="s2">\\</span><span class="s1">s+/).forEach(c =&gt; c &amp;&amp; clone.classList.add(c));</span><span class="s2">\n    </span><span class="s1">clone.style.display = 'none';</span><span class="s2">\n    </span><span class="s1">const container = (root.nodeType === 1 ? root : root.parentNode);</span><span class="s2">\n    </span><span class="s1">container.appendChild(clone);</span><span class="s2">\n    </span><span class="s1">const { hasTransform } = getTransitionInfo(clone);</span><span class="s2">\n    </span><span class="s1">container.removeChild(clone);</span><span class="s2">\n    </span><span class="s1">return hasTransform;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">const getModelAssigner = (vnode) =&gt; {</span><span class="s2">\n    </span><span class="s1">const fn = vnode.props['onUpdate:modelValue'] ||</span><span class="s2">\n        </span><span class="s1">(false );</span><span class="s2">\n    </span><span class="s1">return isArray(fn) ? value =&gt; invokeArrayFns(fn, value) : fn;</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">function onCompositionStart(e) {</span><span class="s2">\n    </span><span class="s1">e.target.composing = true;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function onCompositionEnd(e) {</span><span class="s2">\n    </span><span class="s1">const target = e.target;</span><span class="s2">\n    </span><span class="s1">if (target.composing) {</span><span class="s2">\n        </span><span class="s1">target.composing = false;</span><span class="s2">\n        </span><span class="s1">target.dispatchEvent(new Event('input'));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// We are exporting the v-model runtime directly as vnode hooks so that it can</span><span class="s2">\n</span><span class="s1">// be tree-shaken in case v-model is never used.</span><span class="s2">\n</span><span class="s1">const vModelText = {</span><span class="s2">\n    </span><span class="s1">created(el, { modifiers: { lazy, trim, number } }, vnode) {</span><span class="s2">\n        </span><span class="s1">el._assign = getModelAssigner(vnode);</span><span class="s2">\n        </span><span class="s1">const castToNumber = number || (vnode.props &amp;&amp; vnode.props.type === 'number');</span><span class="s2">\n        </span><span class="s1">addEventListener(el, lazy ? 'change' : 'input', e =&gt; {</span><span class="s2">\n            </span><span class="s1">if (e.target.composing)</span><span class="s2">\n                </span><span class="s1">return;</span><span class="s2">\n            </span><span class="s1">let domValue = el.value;</span><span class="s2">\n            </span><span class="s1">if (trim) {</span><span class="s2">\n                </span><span class="s1">domValue = domValue.trim();</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">if (castToNumber) {</span><span class="s2">\n                </span><span class="s1">domValue = looseToNumber(domValue);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">el._assign(domValue);</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">if (trim) {</span><span class="s2">\n            </span><span class="s1">addEventListener(el, 'change', () =&gt; {</span><span class="s2">\n                </span><span class="s1">el.value = el.value.trim();</span><span class="s2">\n            </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">if (!lazy) {</span><span class="s2">\n            </span><span class="s1">addEventListener(el, 'compositionstart', onCompositionStart);</span><span class="s2">\n            </span><span class="s1">addEventListener(el, 'compositionend', onCompositionEnd);</span><span class="s2">\n            </span><span class="s1">// Safari &lt; 10.2 &amp; UIWebView doesn't fire compositionend when</span><span class="s2">\n            </span><span class="s1">// switching focus before confirming composition choice</span><span class="s2">\n            </span><span class="s1">// this also fixes the issue where some browsers e.g. iOS Chrome</span><span class="s2">\n            </span><span class="s1">// fires </span><span class="s2">\&quot;</span><span class="s1">change</span><span class="s2">\&quot; </span><span class="s1">instead of </span><span class="s2">\&quot;</span><span class="s1">input</span><span class="s2">\&quot; </span><span class="s1">on autocomplete.</span><span class="s2">\n            </span><span class="s1">addEventListener(el, 'change', onCompositionEnd);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">// set value on mounted so it's after min/max for type=</span><span class="s2">\&quot;</span><span class="s1">range</span><span class="s2">\&quot;\n    </span><span class="s1">mounted(el, { value }) {</span><span class="s2">\n        </span><span class="s1">el.value = value == null ? '' : value;</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">beforeUpdate(el, { value, modifiers: { lazy, trim, number } }, vnode) {</span><span class="s2">\n        </span><span class="s1">el._assign = getModelAssigner(vnode);</span><span class="s2">\n        </span><span class="s1">// avoid clearing unresolved text. #2302</span><span class="s2">\n        </span><span class="s1">if (el.composing)</span><span class="s2">\n            </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">if (document.activeElement === el &amp;&amp; el.type !== 'range') {</span><span class="s2">\n            </span><span class="s1">if (lazy) {</span><span class="s2">\n                </span><span class="s1">return;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">if (trim &amp;&amp; el.value.trim() === value) {</span><span class="s2">\n                </span><span class="s1">return;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">if ((number || el.type === 'number') &amp;&amp;</span><span class="s2">\n                </span><span class="s1">looseToNumber(el.value) === value) {</span><span class="s2">\n                </span><span class="s1">return;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">const newValue = value == null ? '' : value;</span><span class="s2">\n        </span><span class="s1">if (el.value !== newValue) {</span><span class="s2">\n            </span><span class="s1">el.value = newValue;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">const vModelCheckbox = {</span><span class="s2">\n    </span><span class="s1">// #4096 array checkboxes need to be deep traversed</span><span class="s2">\n    </span><span class="s1">deep: true,</span><span class="s2">\n    </span><span class="s1">created(el, _, vnode) {</span><span class="s2">\n        </span><span class="s1">el._assign = getModelAssigner(vnode);</span><span class="s2">\n        </span><span class="s1">addEventListener(el, 'change', () =&gt; {</span><span class="s2">\n            </span><span class="s1">const modelValue = el._modelValue;</span><span class="s2">\n            </span><span class="s1">const elementValue = getValue(el);</span><span class="s2">\n            </span><span class="s1">const checked = el.checked;</span><span class="s2">\n            </span><span class="s1">const assign = el._assign;</span><span class="s2">\n            </span><span class="s1">if (isArray(modelValue)) {</span><span class="s2">\n                </span><span class="s1">const index = looseIndexOf(modelValue, elementValue);</span><span class="s2">\n                </span><span class="s1">const found = index !== -1;</span><span class="s2">\n                </span><span class="s1">if (checked &amp;&amp; !found) {</span><span class="s2">\n                    </span><span class="s1">assign(modelValue.concat(elementValue));</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else if (!checked &amp;&amp; found) {</span><span class="s2">\n                    </span><span class="s1">const filtered = [...modelValue];</span><span class="s2">\n                    </span><span class="s1">filtered.splice(index, 1);</span><span class="s2">\n                    </span><span class="s1">assign(filtered);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else if (isSet(modelValue)) {</span><span class="s2">\n                </span><span class="s1">const cloned = new Set(modelValue);</span><span class="s2">\n                </span><span class="s1">if (checked) {</span><span class="s2">\n                    </span><span class="s1">cloned.add(elementValue);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">else {</span><span class="s2">\n                    </span><span class="s1">cloned.delete(elementValue);</span><span class="s2">\n                </span><span class="s1">}</span><span class="s2">\n                </span><span class="s1">assign(cloned);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">assign(getCheckboxValue(el, checked));</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">// set initial checked on mount to wait for true-value/false-value</span><span class="s2">\n    </span><span class="s1">mounted: setChecked,</span><span class="s2">\n    </span><span class="s1">beforeUpdate(el, binding, vnode) {</span><span class="s2">\n        </span><span class="s1">el._assign = getModelAssigner(vnode);</span><span class="s2">\n        </span><span class="s1">setChecked(el, binding, vnode);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">function setChecked(el, { value, oldValue }, vnode) {</span><span class="s2">\n    </span><span class="s1">el._modelValue = value;</span><span class="s2">\n    </span><span class="s1">if (isArray(value)) {</span><span class="s2">\n        </span><span class="s1">el.checked = looseIndexOf(value, vnode.props.value) &gt; -1;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (isSet(value)) {</span><span class="s2">\n        </span><span class="s1">el.checked = value.has(vnode.props.value);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">else if (value !== oldValue) {</span><span class="s2">\n        </span><span class="s1">el.checked = looseEqual(value, getCheckboxValue(el, true));</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">const vModelRadio = {</span><span class="s2">\n    </span><span class="s1">created(el, { value }, vnode) {</span><span class="s2">\n        </span><span class="s1">el.checked = looseEqual(value, vnode.props.value);</span><span class="s2">\n        </span><span class="s1">el._assign = getModelAssigner(vnode);</span><span class="s2">\n        </span><span class="s1">addEventListener(el, 'change', () =&gt; {</span><span class="s2">\n            </span><span class="s1">el._assign(getValue(el));</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">beforeUpdate(el, { value, oldValue }, vnode) {</span><span class="s2">\n        </span><span class="s1">el._assign = getModelAssigner(vnode);</span><span class="s2">\n        </span><span class="s1">if (value !== oldValue) {</span><span class="s2">\n            </span><span class="s1">el.checked = looseEqual(value, vnode.props.value);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">const vModelSelect = {</span><span class="s2">\n    </span><span class="s1">// &lt;select multiple&gt; value need to be deep traversed</span><span class="s2">\n    </span><span class="s1">deep: true,</span><span class="s2">\n    </span><span class="s1">created(el, { value, modifiers: { number } }, vnode) {</span><span class="s2">\n        </span><span class="s1">const isSetModel = isSet(value);</span><span class="s2">\n        </span><span class="s1">addEventListener(el, 'change', () =&gt; {</span><span class="s2">\n            </span><span class="s1">const selectedVal = Array.prototype.filter</span><span class="s2">\n                </span><span class="s1">.call(el.options, (o) =&gt; o.selected)</span><span class="s2">\n                </span><span class="s1">.map((o) =&gt; number ? looseToNumber(getValue(o)) : getValue(o));</span><span class="s2">\n            </span><span class="s1">el._assign(el.multiple</span><span class="s2">\n                </span><span class="s1">? isSetModel</span><span class="s2">\n                    </span><span class="s1">? new Set(selectedVal)</span><span class="s2">\n                    </span><span class="s1">: selectedVal</span><span class="s2">\n                </span><span class="s1">: selectedVal[0]);</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">el._assign = getModelAssigner(vnode);</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">// set value in mounted &amp; updated because &lt;select&gt; relies on its children</span><span class="s2">\n    </span><span class="s1">// &lt;option&gt;s.</span><span class="s2">\n    </span><span class="s1">mounted(el, { value }) {</span><span class="s2">\n        </span><span class="s1">setSelected(el, value);</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">beforeUpdate(el, _binding, vnode) {</span><span class="s2">\n        </span><span class="s1">el._assign = getModelAssigner(vnode);</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">updated(el, { value }) {</span><span class="s2">\n        </span><span class="s1">setSelected(el, value);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">function setSelected(el, value) {</span><span class="s2">\n    </span><span class="s1">const isMultiple = el.multiple;</span><span class="s2">\n    </span><span class="s1">if (isMultiple &amp;&amp; !isArray(value) &amp;&amp; !isSet(value)) {</span><span class="s2">\n        </span><span class="s1">(process.env.NODE_ENV !== 'production') &amp;&amp;</span><span class="s2">\n            </span><span class="s1">warn(`&lt;select multiple v-model&gt; expects an Array or Set value for its binding, ` +</span><span class="s2">\n                </span><span class="s1">`but got ${Object.prototype.toString.call(value).slice(8, -1)}.`);</span><span class="s2">\n        </span><span class="s1">return;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">for (let i = 0, l = el.options.length; i &lt; l; i++) {</span><span class="s2">\n        </span><span class="s1">const option = el.options[i];</span><span class="s2">\n        </span><span class="s1">const optionValue = getValue(option);</span><span class="s2">\n        </span><span class="s1">if (isMultiple) {</span><span class="s2">\n            </span><span class="s1">if (isArray(value)) {</span><span class="s2">\n                </span><span class="s1">option.selected = looseIndexOf(value, optionValue) &gt; -1;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">option.selected = value.has(optionValue);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">if (looseEqual(getValue(option), value)) {</span><span class="s2">\n                </span><span class="s1">if (el.selectedIndex !== i)</span><span class="s2">\n                    </span><span class="s1">el.selectedIndex = i;</span><span class="s2">\n                </span><span class="s1">return;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if (!isMultiple &amp;&amp; el.selectedIndex !== -1) {</span><span class="s2">\n        </span><span class="s1">el.selectedIndex = -1;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// retrieve raw value set via :value bindings</span><span class="s2">\n</span><span class="s1">function getValue(el) {</span><span class="s2">\n    </span><span class="s1">return '_value' in el ? el._value : el.value;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// retrieve raw value for true-value and false-value set via :true-value or :false-value bindings</span><span class="s2">\n</span><span class="s1">function getCheckboxValue(el, checked) {</span><span class="s2">\n    </span><span class="s1">const key = checked ? '_trueValue' : '_falseValue';</span><span class="s2">\n    </span><span class="s1">return key in el ? el[key] : checked;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">const vModelDynamic = {</span><span class="s2">\n    </span><span class="s1">created(el, binding, vnode) {</span><span class="s2">\n        </span><span class="s1">callModelHook(el, binding, vnode, null, 'created');</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">mounted(el, binding, vnode) {</span><span class="s2">\n        </span><span class="s1">callModelHook(el, binding, vnode, null, 'mounted');</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">beforeUpdate(el, binding, vnode, prevVNode) {</span><span class="s2">\n        </span><span class="s1">callModelHook(el, binding, vnode, prevVNode, 'beforeUpdate');</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">updated(el, binding, vnode, prevVNode) {</span><span class="s2">\n        </span><span class="s1">callModelHook(el, binding, vnode, prevVNode, 'updated');</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">function resolveDynamicModel(tagName, type) {</span><span class="s2">\n    </span><span class="s1">switch (tagName) {</span><span class="s2">\n        </span><span class="s1">case 'SELECT':</span><span class="s2">\n            </span><span class="s1">return vModelSelect;</span><span class="s2">\n        </span><span class="s1">case 'TEXTAREA':</span><span class="s2">\n            </span><span class="s1">return vModelText;</span><span class="s2">\n        </span><span class="s1">default:</span><span class="s2">\n            </span><span class="s1">switch (type) {</span><span class="s2">\n                </span><span class="s1">case 'checkbox':</span><span class="s2">\n                    </span><span class="s1">return vModelCheckbox;</span><span class="s2">\n                </span><span class="s1">case 'radio':</span><span class="s2">\n                    </span><span class="s1">return vModelRadio;</span><span class="s2">\n                </span><span class="s1">default:</span><span class="s2">\n                    </span><span class="s1">return vModelText;</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function callModelHook(el, binding, vnode, prevVNode, hook) {</span><span class="s2">\n    </span><span class="s1">const modelToUse = resolveDynamicModel(el.tagName, vnode.props &amp;&amp; vnode.props.type);</span><span class="s2">\n    </span><span class="s1">const fn = modelToUse[hook];</span><span class="s2">\n    </span><span class="s1">fn &amp;&amp; fn(el, binding, vnode, prevVNode);</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// SSR vnode transforms, only used when user includes client-oriented render</span><span class="s2">\n</span><span class="s1">// function in SSR</span><span class="s2">\n</span><span class="s1">function initVModelForSSR() {</span><span class="s2">\n    </span><span class="s1">vModelText.getSSRProps = ({ value }) =&gt; ({ value });</span><span class="s2">\n    </span><span class="s1">vModelRadio.getSSRProps = ({ value }, vnode) =&gt; {</span><span class="s2">\n        </span><span class="s1">if (vnode.props &amp;&amp; looseEqual(vnode.props.value, value)) {</span><span class="s2">\n            </span><span class="s1">return { checked: true };</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">vModelCheckbox.getSSRProps = ({ value }, vnode) =&gt; {</span><span class="s2">\n        </span><span class="s1">if (isArray(value)) {</span><span class="s2">\n            </span><span class="s1">if (vnode.props &amp;&amp; looseIndexOf(value, vnode.props.value) &gt; -1) {</span><span class="s2">\n                </span><span class="s1">return { checked: true };</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (isSet(value)) {</span><span class="s2">\n            </span><span class="s1">if (vnode.props &amp;&amp; value.has(vnode.props.value)) {</span><span class="s2">\n                </span><span class="s1">return { checked: true };</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else if (value) {</span><span class="s2">\n            </span><span class="s1">return { checked: true };</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">vModelDynamic.getSSRProps = (binding, vnode) =&gt; {</span><span class="s2">\n        </span><span class="s1">if (typeof vnode.type !== 'string') {</span><span class="s2">\n            </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">const modelToUse = resolveDynamicModel(</span><span class="s2">\n        </span><span class="s1">// resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase</span><span class="s2">\n        </span><span class="s1">vnode.type.toUpperCase(), vnode.props &amp;&amp; vnode.props.type);</span><span class="s2">\n        </span><span class="s1">if (modelToUse.getSSRProps) {</span><span class="s2">\n            </span><span class="s1">return modelToUse.getSSRProps(binding, vnode);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">const systemModifiers = ['ctrl', 'shift', 'alt', 'meta'];</span><span class="s2">\n</span><span class="s1">const modifierGuards = {</span><span class="s2">\n    </span><span class="s1">stop: e =&gt; e.stopPropagation(),</span><span class="s2">\n    </span><span class="s1">prevent: e =&gt; e.preventDefault(),</span><span class="s2">\n    </span><span class="s1">self: e =&gt; e.target !== e.currentTarget,</span><span class="s2">\n    </span><span class="s1">ctrl: e =&gt; !e.ctrlKey,</span><span class="s2">\n    </span><span class="s1">shift: e =&gt; !e.shiftKey,</span><span class="s2">\n    </span><span class="s1">alt: e =&gt; !e.altKey,</span><span class="s2">\n    </span><span class="s1">meta: e =&gt; !e.metaKey,</span><span class="s2">\n    </span><span class="s1">left: e =&gt; 'button' in e &amp;&amp; e.button !== 0,</span><span class="s2">\n    </span><span class="s1">middle: e =&gt; 'button' in e &amp;&amp; e.button !== 1,</span><span class="s2">\n    </span><span class="s1">right: e =&gt; 'button' in e &amp;&amp; e.button !== 2,</span><span class="s2">\n    </span><span class="s1">exact: (e, modifiers) =&gt; systemModifiers.some(m =&gt; e[`${m}Key`] &amp;&amp; !modifiers.includes(m))</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* @private</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const withModifiers = (fn, modifiers) =&gt; {</span><span class="s2">\n    </span><span class="s1">return (event, ...args) =&gt; {</span><span class="s2">\n        </span><span class="s1">for (let i = 0; i &lt; modifiers.length; i++) {</span><span class="s2">\n            </span><span class="s1">const guard = modifierGuards[modifiers[i]];</span><span class="s2">\n            </span><span class="s1">if (guard &amp;&amp; guard(event, modifiers))</span><span class="s2">\n                </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return fn(event, ...args);</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">// Kept for 2.x compat.</span><span class="s2">\n</span><span class="s1">// Note: IE11 compat for `spacebar` and `del` is removed for now.</span><span class="s2">\n</span><span class="s1">const keyNames = {</span><span class="s2">\n    </span><span class="s1">esc: 'escape',</span><span class="s2">\n    </span><span class="s1">space: ' ',</span><span class="s2">\n    </span><span class="s1">up: 'arrow-up',</span><span class="s2">\n    </span><span class="s1">left: 'arrow-left',</span><span class="s2">\n    </span><span class="s1">right: 'arrow-right',</span><span class="s2">\n    </span><span class="s1">down: 'arrow-down',</span><span class="s2">\n    </span><span class="s1">delete: 'backspace'</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* @private</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const withKeys = (fn, modifiers) =&gt; {</span><span class="s2">\n    </span><span class="s1">return (event) =&gt; {</span><span class="s2">\n        </span><span class="s1">if (!('key' in event)) {</span><span class="s2">\n            </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">const eventKey = hyphenate(event.key);</span><span class="s2">\n        </span><span class="s1">if (modifiers.some(k =&gt; k === eventKey || keyNames[k] === eventKey)) {</span><span class="s2">\n            </span><span class="s1">return fn(event);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">const vShow = {</span><span class="s2">\n    </span><span class="s1">beforeMount(el, { value }, { transition }) {</span><span class="s2">\n        </span><span class="s1">el._vod = el.style.display === 'none' ? '' : el.style.display;</span><span class="s2">\n        </span><span class="s1">if (transition &amp;&amp; value) {</span><span class="s2">\n            </span><span class="s1">transition.beforeEnter(el);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">setDisplay(el, value);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">mounted(el, { value }, { transition }) {</span><span class="s2">\n        </span><span class="s1">if (transition &amp;&amp; value) {</span><span class="s2">\n            </span><span class="s1">transition.enter(el);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">updated(el, { value, oldValue }, { transition }) {</span><span class="s2">\n        </span><span class="s1">if (!value === !oldValue)</span><span class="s2">\n            </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">if (transition) {</span><span class="s2">\n            </span><span class="s1">if (value) {</span><span class="s2">\n                </span><span class="s1">transition.beforeEnter(el);</span><span class="s2">\n                </span><span class="s1">setDisplay(el, true);</span><span class="s2">\n                </span><span class="s1">transition.enter(el);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n            </span><span class="s1">else {</span><span class="s2">\n                </span><span class="s1">transition.leave(el, () =&gt; {</span><span class="s2">\n                    </span><span class="s1">setDisplay(el, false);</span><span class="s2">\n                </span><span class="s1">});</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">else {</span><span class="s2">\n            </span><span class="s1">setDisplay(el, value);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">},</span><span class="s2">\n    </span><span class="s1">beforeUnmount(el, { value }) {</span><span class="s2">\n        </span><span class="s1">setDisplay(el, value);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n</span><span class="s1">function setDisplay(el, value) {</span><span class="s2">\n    </span><span class="s1">el.style.display = value ? el._vod : 'none';</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// SSR vnode transforms, only used when user includes client-oriented render</span><span class="s2">\n</span><span class="s1">// function in SSR</span><span class="s2">\n</span><span class="s1">function initVShowForSSR() {</span><span class="s2">\n    </span><span class="s1">vShow.getSSRProps = ({ value }) =&gt; {</span><span class="s2">\n        </span><span class="s1">if (!value) {</span><span class="s2">\n            </span><span class="s1">return { style: { display: 'none' } };</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">const rendererOptions = /*#__PURE__*/ extend({ patchProp }, nodeOps);</span><span class="s2">\n</span><span class="s1">// lazy create the renderer - this makes core renderer logic tree-shakable</span><span class="s2">\n</span><span class="s1">// in case the user only imports reactivity utilities from Vue.</span><span class="s2">\n</span><span class="s1">let renderer;</span><span class="s2">\n</span><span class="s1">let enabledHydration = false;</span><span class="s2">\n</span><span class="s1">function ensureRenderer() {</span><span class="s2">\n    </span><span class="s1">return (renderer ||</span><span class="s2">\n        </span><span class="s1">(renderer = createRenderer(rendererOptions)));</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function ensureHydrationRenderer() {</span><span class="s2">\n    </span><span class="s1">renderer = enabledHydration</span><span class="s2">\n        </span><span class="s1">? renderer</span><span class="s2">\n        </span><span class="s1">: createHydrationRenderer(rendererOptions);</span><span class="s2">\n    </span><span class="s1">enabledHydration = true;</span><span class="s2">\n    </span><span class="s1">return renderer;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// use explicit type casts here to avoid import() calls in rolled-up d.ts</span><span class="s2">\n</span><span class="s1">const render = ((...args) =&gt; {</span><span class="s2">\n    </span><span class="s1">ensureRenderer().render(...args);</span><span class="s2">\n</span><span class="s1">});</span><span class="s2">\n</span><span class="s1">const hydrate = ((...args) =&gt; {</span><span class="s2">\n    </span><span class="s1">ensureHydrationRenderer().hydrate(...args);</span><span class="s2">\n</span><span class="s1">});</span><span class="s2">\n</span><span class="s1">const createApp = ((...args) =&gt; {</span><span class="s2">\n    </span><span class="s1">const app = ensureRenderer().createApp(...args);</span><span class="s2">\n    </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n        </span><span class="s1">injectNativeTagCheck(app);</span><span class="s2">\n        </span><span class="s1">injectCompilerOptionsCheck(app);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">const { mount } = app;</span><span class="s2">\n    </span><span class="s1">app.mount = (containerOrSelector) =&gt; {</span><span class="s2">\n        </span><span class="s1">const container = normalizeContainer(containerOrSelector);</span><span class="s2">\n        </span><span class="s1">if (!container)</span><span class="s2">\n            </span><span class="s1">return;</span><span class="s2">\n        </span><span class="s1">const component = app._component;</span><span class="s2">\n        </span><span class="s1">if (!isFunction(component) &amp;&amp; !component.render &amp;&amp; !component.template) {</span><span class="s2">\n            </span><span class="s1">// __UNSAFE__</span><span class="s2">\n            </span><span class="s1">// Reason: potential execution of JS expressions in in-DOM template.</span><span class="s2">\n            </span><span class="s1">// The user must make sure the in-DOM template is trusted. If it's</span><span class="s2">\n            </span><span class="s1">// rendered by the server, the template should not contain any user data.</span><span class="s2">\n            </span><span class="s1">component.template = container.innerHTML;</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">// clear content before mounting</span><span class="s2">\n        </span><span class="s1">container.innerHTML = '';</span><span class="s2">\n        </span><span class="s1">const proxy = mount(container, false, container instanceof SVGElement);</span><span class="s2">\n        </span><span class="s1">if (container instanceof Element) {</span><span class="s2">\n            </span><span class="s1">container.removeAttribute('v-cloak');</span><span class="s2">\n            </span><span class="s1">container.setAttribute('data-v-app', '');</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return proxy;</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">return app;</span><span class="s2">\n</span><span class="s1">});</span><span class="s2">\n</span><span class="s1">const createSSRApp = ((...args) =&gt; {</span><span class="s2">\n    </span><span class="s1">const app = ensureHydrationRenderer().createApp(...args);</span><span class="s2">\n    </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n        </span><span class="s1">injectNativeTagCheck(app);</span><span class="s2">\n        </span><span class="s1">injectCompilerOptionsCheck(app);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">const { mount } = app;</span><span class="s2">\n    </span><span class="s1">app.mount = (containerOrSelector) =&gt; {</span><span class="s2">\n        </span><span class="s1">const container = normalizeContainer(containerOrSelector);</span><span class="s2">\n        </span><span class="s1">if (container) {</span><span class="s2">\n            </span><span class="s1">return mount(container, true, container instanceof SVGElement);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">};</span><span class="s2">\n    </span><span class="s1">return app;</span><span class="s2">\n</span><span class="s1">});</span><span class="s2">\n</span><span class="s1">function injectNativeTagCheck(app) {</span><span class="s2">\n    </span><span class="s1">// Inject `isNativeTag`</span><span class="s2">\n    </span><span class="s1">// this is used for component name validation (dev only)</span><span class="s2">\n    </span><span class="s1">Object.defineProperty(app.config, 'isNativeTag', {</span><span class="s2">\n        </span><span class="s1">value: (tag) =&gt; isHTMLTag(tag) || isSVGTag(tag),</span><span class="s2">\n        </span><span class="s1">writable: false</span><span class="s2">\n    </span><span class="s1">});</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">// dev only</span><span class="s2">\n</span><span class="s1">function injectCompilerOptionsCheck(app) {</span><span class="s2">\n    </span><span class="s1">if (isRuntimeOnly()) {</span><span class="s2">\n        </span><span class="s1">const isCustomElement = app.config.isCustomElement;</span><span class="s2">\n        </span><span class="s1">Object.defineProperty(app.config, 'isCustomElement', {</span><span class="s2">\n            </span><span class="s1">get() {</span><span class="s2">\n                </span><span class="s1">return isCustomElement;</span><span class="s2">\n            </span><span class="s1">},</span><span class="s2">\n            </span><span class="s1">set() {</span><span class="s2">\n                </span><span class="s1">warn(`The </span><span class="s2">\\</span><span class="s1">`isCustomElement</span><span class="s2">\\</span><span class="s1">` config option is deprecated. Use ` +</span><span class="s2">\n                    </span><span class="s1">`</span><span class="s2">\\</span><span class="s1">`compilerOptions.isCustomElement</span><span class="s2">\\</span><span class="s1">` instead.`);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n        </span><span class="s1">const compilerOptions = app.config.compilerOptions;</span><span class="s2">\n        </span><span class="s1">const msg = `The </span><span class="s2">\\</span><span class="s1">`compilerOptions</span><span class="s2">\\</span><span class="s1">` config option is only respected when using ` +</span><span class="s2">\n            </span><span class="s1">`a build of Vue.js that includes the runtime compiler (aka </span><span class="s2">\&quot;</span><span class="s1">full build</span><span class="s2">\&quot;</span><span class="s1">). ` +</span><span class="s2">\n            </span><span class="s1">`Since you are using the runtime-only build, </span><span class="s2">\\</span><span class="s1">`compilerOptions</span><span class="s2">\\</span><span class="s1">` ` +</span><span class="s2">\n            </span><span class="s1">`must be passed to </span><span class="s2">\\</span><span class="s1">`@vue/compiler-dom</span><span class="s2">\\</span><span class="s1">` in the build setup instead.</span><span class="s2">\\</span><span class="s1">n` +</span><span class="s2">\n            </span><span class="s1">`- For vue-loader: pass it via vue-loader's </span><span class="s2">\\</span><span class="s1">`compilerOptions</span><span class="s2">\\</span><span class="s1">` loader option.</span><span class="s2">\\</span><span class="s1">n` +</span><span class="s2">\n            </span><span class="s1">`- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader</span><span class="s2">\\</span><span class="s1">n` +</span><span class="s2">\n            </span><span class="s1">`- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-dom`;</span><span class="s2">\n        </span><span class="s1">Object.defineProperty(app.config, 'compilerOptions', {</span><span class="s2">\n            </span><span class="s1">get() {</span><span class="s2">\n                </span><span class="s1">warn(msg);</span><span class="s2">\n                </span><span class="s1">return compilerOptions;</span><span class="s2">\n            </span><span class="s1">},</span><span class="s2">\n            </span><span class="s1">set() {</span><span class="s2">\n                </span><span class="s1">warn(msg);</span><span class="s2">\n            </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">});</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">function normalizeContainer(container) {</span><span class="s2">\n    </span><span class="s1">if (isString(container)) {</span><span class="s2">\n        </span><span class="s1">const res = document.querySelector(container);</span><span class="s2">\n        </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp; !res) {</span><span class="s2">\n            </span><span class="s1">warn(`Failed to mount app: mount target selector </span><span class="s2">\&quot;</span><span class="s1">${container}</span><span class="s2">\&quot; </span><span class="s1">returned null.`);</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n        </span><span class="s1">return res;</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">if ((process.env.NODE_ENV !== 'production') &amp;&amp;</span><span class="s2">\n        </span><span class="s1">window.ShadowRoot &amp;&amp;</span><span class="s2">\n        </span><span class="s1">container instanceof window.ShadowRoot &amp;&amp;</span><span class="s2">\n        </span><span class="s1">container.mode === 'closed') {</span><span class="s2">\n        </span><span class="s1">warn(`mounting on a ShadowRoot with </span><span class="s2">\\</span><span class="s1">`{mode: </span><span class="s2">\&quot;</span><span class="s1">closed</span><span class="s2">\&quot;</span><span class="s1">}</span><span class="s2">\\</span><span class="s1">` may lead to unpredictable bugs`);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">return container;</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">let ssrDirectiveInitialized = false;</span><span class="s2">\n</span><span class="s1">/**</span><span class="s2">\n </span><span class="s1">* @internal</span><span class="s2">\n </span><span class="s1">*/</span><span class="s2">\n</span><span class="s1">const initDirectivesForSSR = () =&gt; {</span><span class="s2">\n        </span><span class="s1">if (!ssrDirectiveInitialized) {</span><span class="s2">\n            </span><span class="s1">ssrDirectiveInitialized = true;</span><span class="s2">\n            </span><span class="s1">initVModelForSSR();</span><span class="s2">\n            </span><span class="s1">initVShowForSSR();</span><span class="s2">\n        </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n    </span><span class="s1">;</span><span class="s2">\n\n</span><span class="s1">export { Transition, TransitionGroup, VueElement, createApp, createSSRApp, defineCustomElement, defineSSRCustomElement, hydrate, initDirectivesForSSR, render, useCssModule, useCssVars, vModelCheckbox, vModelDynamic, vModelRadio, vModelSelect, vModelText, vShow, withKeys, withModifiers };</span><span class="s2">\n</span><span class="s1">&quot;</span><span class="s2">, </span><span class="s1">&quot;import { initCustomFormatter, warn } from '@vue/runtime-dom';</span><span class="s2">\n</span><span class="s1">export * from '@vue/runtime-dom';</span><span class="s2">\n\n</span><span class="s1">function initDev() {</span><span class="s2">\n    </span><span class="s1">{</span><span class="s2">\n        </span><span class="s1">initCustomFormatter();</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n\n</span><span class="s1">// This entry exports the runtime only, and is built as</span><span class="s2">\n</span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n    </span><span class="s1">initDev();</span><span class="s2">\n</span><span class="s1">}</span><span class="s2">\n</span><span class="s1">const compile = () =&gt; {</span><span class="s2">\n    </span><span class="s1">if ((process.env.NODE_ENV !== 'production')) {</span><span class="s2">\n        </span><span class="s1">warn(`Runtime compilation is not supported in this build of Vue.` +</span><span class="s2">\n            </span><span class="s1">(` Configure your bundler to alias </span><span class="s2">\&quot;</span><span class="s1">vue</span><span class="s2">\&quot; </span><span class="s1">to </span><span class="s2">\&quot;</span><span class="s1">vue/dist/vue.esm-bundler.js</span><span class="s2">\&quot;</span><span class="s1">.`</span><span class="s2">\n                </span><span class="s1">) /* should not happen */);</span><span class="s2">\n    </span><span class="s1">}</span><span class="s2">\n</span><span class="s1">};</span><span class="s2">\n\n</span><span class="s1">export { compile };</span><span class="s2">\n</span><span class="s1">&quot;</span><span class="s0">]</span><span class="s2">,</span>
  <span class="s1">&quot;mappings&quot;</span><span class="s2">: </span><span class="s1">&quot;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&quot;</span><span class="s2">,</span>
  <span class="s1">&quot;names&quot;</span><span class="s2">: </span><span class="s0">[</span><span class="s1">&quot;map&quot;</span><span class="s2">, </span><span class="s1">&quot;val&quot;</span><span class="s2">, </span><span class="s1">&quot;effect&quot;</span><span class="s2">, </span><span class="s1">&quot;shouldTrack&quot;</span><span class="s2">, </span><span class="s1">&quot;key&quot;</span><span class="s2">, </span><span class="s1">&quot;effect&quot;</span><span class="s2">, </span><span class="s1">&quot;_a&quot;</span><span class="s2">, </span><span class="s1">&quot;hasOwnProperty&quot;</span><span class="s2">, </span><span class="s1">&quot;isReadonly&quot;</span><span class="s2">, </span><span class="s1">&quot;get&quot;</span><span class="s2">, </span><span class="s1">&quot;set&quot;</span><span class="s2">, </span><span class="s1">&quot;isShallow&quot;</span><span class="s2">, </span><span class="s1">&quot;has&quot;</span><span class="s2">, </span><span class="s1">&quot;mutableInstrumentations&quot;</span><span class="s2">, </span><span class="s1">&quot;shallowInstrumentations&quot;</span><span class="s2">, </span><span class="s1">&quot;readonlyInstrumentations&quot;</span><span class="s2">, </span><span class="s1">&quot;shallowReadonlyInstrumentations&quot;</span><span class="s2">, </span><span class="s1">&quot;ref&quot;</span><span class="s2">, </span><span class="s1">&quot;self&quot;</span><span class="s2">, </span><span class="s1">&quot;warn&quot;</span><span class="s2">, </span><span class="s1">&quot;p&quot;</span><span class="s2">, </span><span class="s1">&quot;_a&quot;</span><span class="s2">, </span><span class="s1">&quot;version&quot;</span><span class="s2">, </span><span class="s1">&quot;isModelListener&quot;</span><span class="s2">, </span><span class="s1">&quot;raw&quot;</span><span class="s2">, </span><span class="s1">&quot;emit&quot;</span><span class="s2">, </span><span class="s1">&quot;render&quot;</span><span class="s2">, </span><span class="s1">&quot;remove&quot;</span><span class="s2">, </span><span class="s1">&quot;vnode&quot;</span><span class="s2">, </span><span class="s1">&quot;parentComponent&quot;</span><span class="s2">, </span><span class="s1">&quot;container&quot;</span><span class="s2">, </span><span class="s1">&quot;anchor&quot;</span><span class="s2">, </span><span class="s1">&quot;parent&quot;</span><span class="s2">, </span><span class="s1">&quot;isSVG&quot;</span><span class="s2">, </span><span class="s1">&quot;effect&quot;</span><span class="s2">, </span><span class="s1">&quot;callHook&quot;</span><span class="s2">, </span><span class="s1">&quot;hook&quot;</span><span class="s2">, </span><span class="s1">&quot;key&quot;</span><span class="s2">, </span><span class="s1">&quot;resolve&quot;</span><span class="s2">, </span><span class="s1">&quot;ref&quot;</span><span class="s2">, </span><span class="s1">&quot;instance&quot;</span><span class="s2">, </span><span class="s1">&quot;has&quot;</span><span class="s2">, </span><span class="s1">&quot;get&quot;</span><span class="s2">, </span><span class="s1">&quot;set&quot;</span><span class="s2">, </span><span class="s1">&quot;computed&quot;</span><span class="s2">, </span><span class="s1">&quot;h&quot;</span><span class="s2">, </span><span class="s1">&quot;hydrate&quot;</span><span class="s2">, </span><span class="s1">&quot;createApp&quot;</span><span class="s2">, </span><span class="s1">&quot;patchProp&quot;</span><span class="s2">, </span><span class="s1">&quot;hasWarned&quot;</span><span class="s2">, </span><span class="s1">&quot;next&quot;</span><span class="s2">, </span><span class="s1">&quot;isShallow&quot;</span><span class="s2">, </span><span class="s1">&quot;warn&quot;</span><span class="s2">, </span><span class="s1">&quot;isBoolean&quot;</span><span class="s2">, </span><span class="s1">&quot;e&quot;</span><span class="s2">, </span><span class="s1">&quot;hydrate&quot;</span><span class="s2">, </span><span class="s1">&quot;resolve&quot;</span><span class="s2">, </span><span class="s1">&quot;def&quot;</span><span class="s2">, </span><span class="s1">&quot;callHook&quot;</span><span class="s2">, </span><span class="s1">&quot;h&quot;</span><span class="s2">, </span><span class="s1">&quot;compile&quot;</span><span class="s2">, </span><span class="s1">&quot;warn&quot;</span><span class="s0">]</span>
<span class="s0">}</span>
</pre>
</body>
</html>