<html>
<head>
<title>dep-17ff486c.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
.s5 { color: #629755; font-style: italic;}
.s6 { color: #629755; font-weight: bold; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
dep-17ff486c.js</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">require$$0__default from </span><span class="s2">'fs'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">require$$0 from </span><span class="s2">'postcss'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ E as commonjsGlobal } from </span><span class="s2">'./dep-24daf00c.js'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">require$$0$1 from </span><span class="s2">'path'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">require$$5 from </span><span class="s2">'crypto'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">require$$0$2 from </span><span class="s2">'util'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ l as lib } from </span><span class="s2">'./dep-c423598f.js'</span><span class="s0">;</span>

<span class="s0">import </span><span class="s1">{ fileURLToPath as __cjs_fileURLToPath } from </span><span class="s2">'node:url'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ dirname as __cjs_dirname } from </span><span class="s2">'node:path'</span><span class="s0">;</span>
<span class="s0">import </span><span class="s1">{ createRequire as __cjs_createRequire } from </span><span class="s2">'node:module'</span><span class="s0">;</span>

<span class="s0">const </span><span class="s1">__filename = __cjs_fileURLToPath(</span><span class="s0">import</span><span class="s1">.meta.url)</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">__dirname = __cjs_dirname(__filename)</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">require = __cjs_createRequire(</span><span class="s0">import</span><span class="s1">.meta.url)</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">__require = require</span><span class="s0">;</span>
<span class="s0">function </span><span class="s1">_mergeNamespaces(n</span><span class="s0">, </span><span class="s1">m) {</span>
  <span class="s0">for </span><span class="s1">(</span><span class="s0">var </span><span class="s1">i = </span><span class="s3">0</span><span class="s0">; </span><span class="s1">i &lt; m.length</span><span class="s0">; </span><span class="s1">i++) {</span>
    <span class="s0">var </span><span class="s1">e = m[i]</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">e !== </span><span class="s2">'string' </span><span class="s1">&amp;&amp; !Array.isArray(e)) { </span><span class="s0">for </span><span class="s1">(</span><span class="s0">var </span><span class="s1">k </span><span class="s0">in </span><span class="s1">e) {</span>
      <span class="s0">if </span><span class="s1">(k !== </span><span class="s2">'default' </span><span class="s1">&amp;&amp; !(k </span><span class="s0">in </span><span class="s1">n)) {</span>
        <span class="s1">n[k] = e[k]</span><span class="s0">;</span>
      <span class="s1">}</span>
    <span class="s1">} }</span>
  <span class="s1">}</span>
  <span class="s0">return </span><span class="s1">n</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">var </span><span class="s1">buildExports = {}</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">build = {</span>
  <span class="s1">get exports(){ </span><span class="s0">return </span><span class="s1">buildExports</span><span class="s0">; </span><span class="s1">}</span><span class="s0">,</span>
  <span class="s1">set exports(v){ buildExports = v</span><span class="s0">; </span><span class="s1">}</span><span class="s0">,</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">fs = {}</span><span class="s0">;</span>

<span class="s1">Object.defineProperty(fs</span><span class="s0">, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, </span><span class="s1">{</span>
  <span class="s1">value: </span><span class="s0">true</span>
<span class="s1">})</span><span class="s0">;</span>
<span class="s1">fs.getFileSystem = getFileSystem</span><span class="s0">;</span>
<span class="s1">fs.setFileSystem = setFileSystem</span><span class="s0">;</span>
<span class="s0">let </span><span class="s1">fileSystem = {</span>
  <span class="s1">readFile: () =&gt; {</span>
    <span class="s0">throw </span><span class="s1">Error(</span><span class="s2">&quot;readFile not implemented&quot;</span><span class="s1">)</span><span class="s0">;</span>
  <span class="s1">}</span><span class="s0">,</span>
  <span class="s1">writeFile: () =&gt; {</span>
    <span class="s0">throw </span><span class="s1">Error(</span><span class="s2">&quot;writeFile not implemented&quot;</span><span class="s1">)</span><span class="s0">;</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s0">function </span><span class="s1">setFileSystem(fs) {</span>
  <span class="s1">fileSystem.readFile = fs.readFile</span><span class="s0">;</span>
  <span class="s1">fileSystem.writeFile = fs.writeFile</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">getFileSystem() {</span>
  <span class="s0">return </span><span class="s1">fileSystem</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">var </span><span class="s1">pluginFactory = {}</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">unquote$1 = {}</span><span class="s0">;</span>

<span class="s1">Object.defineProperty(unquote$1</span><span class="s0">, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, </span><span class="s1">{</span>
  <span class="s1">value: </span><span class="s0">true</span>
<span class="s1">})</span><span class="s0">;</span>
<span class="s1">unquote$1.default = unquote</span><span class="s0">;</span>
<span class="s4">// copied from https://github.com/lakenen/node-unquote</span>
<span class="s0">const </span><span class="s1">reg = </span><span class="s3">/['&quot;]/</span><span class="s0">;</span>

<span class="s0">function </span><span class="s1">unquote(str) {</span>
  <span class="s0">if </span><span class="s1">(!str) {</span>
    <span class="s0">return </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
  <span class="s1">}</span>

  <span class="s0">if </span><span class="s1">(reg.test(str.charAt(</span><span class="s3">0</span><span class="s1">))) {</span>
    <span class="s1">str = str.substr(</span><span class="s3">1</span><span class="s1">)</span><span class="s0">;</span>
  <span class="s1">}</span>

  <span class="s0">if </span><span class="s1">(reg.test(str.charAt(str.length - </span><span class="s3">1</span><span class="s1">))) {</span>
    <span class="s1">str = str.substr(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">str.length - </span><span class="s3">1</span><span class="s1">)</span><span class="s0">;</span>
  <span class="s1">}</span>

  <span class="s0">return </span><span class="s1">str</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">var </span><span class="s1">Parser$1 = {}</span><span class="s0">;</span>

<span class="s0">const </span><span class="s1">matchValueName = </span><span class="s3">/[$]?[\w-]+/g</span><span class="s0">;</span>

<span class="s0">const </span><span class="s1">replaceValueSymbols$2 = (value</span><span class="s0">, </span><span class="s1">replacements) =&gt; {</span>
  <span class="s0">let </span><span class="s1">matches</span><span class="s0">;</span>

  <span class="s0">while </span><span class="s1">((matches = matchValueName.exec(value))) {</span>
    <span class="s0">const </span><span class="s1">replacement = replacements[matches[</span><span class="s3">0</span><span class="s1">]]</span><span class="s0">;</span>

    <span class="s0">if </span><span class="s1">(replacement) {</span>
      <span class="s1">value =</span>
        <span class="s1">value.slice(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">matches.index) +</span>
        <span class="s1">replacement +</span>
        <span class="s1">value.slice(matchValueName.lastIndex)</span><span class="s0">;</span>

      <span class="s1">matchValueName.lastIndex -= matches[</span><span class="s3">0</span><span class="s1">].length - replacement.length</span><span class="s0">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">return </span><span class="s1">value</span><span class="s0">;</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">replaceValueSymbols_1 = replaceValueSymbols$2</span><span class="s0">;</span>

<span class="s0">const </span><span class="s1">replaceValueSymbols$1 = replaceValueSymbols_1</span><span class="s0">;</span>

<span class="s0">const </span><span class="s1">replaceSymbols$1 = (css</span><span class="s0">, </span><span class="s1">replacements) =&gt; {</span>
  <span class="s1">css.walk((node) =&gt; {</span>
    <span class="s0">if </span><span class="s1">(node.type === </span><span class="s2">&quot;decl&quot; </span><span class="s1">&amp;&amp; node.value) {</span>
      <span class="s1">node.value = replaceValueSymbols$1(node.value.toString()</span><span class="s0">, </span><span class="s1">replacements)</span><span class="s0">;</span>
    <span class="s1">} </span><span class="s0">else if </span><span class="s1">(node.type === </span><span class="s2">&quot;rule&quot; </span><span class="s1">&amp;&amp; node.selector) {</span>
      <span class="s1">node.selector = replaceValueSymbols$1(</span>
        <span class="s1">node.selector.toString()</span><span class="s0">,</span>
        <span class="s1">replacements</span>
      <span class="s1">)</span><span class="s0">;</span>
    <span class="s1">} </span><span class="s0">else if </span><span class="s1">(node.type === </span><span class="s2">&quot;atrule&quot; </span><span class="s1">&amp;&amp; node.params) {</span>
      <span class="s1">node.params = replaceValueSymbols$1(node.params.toString()</span><span class="s0">, </span><span class="s1">replacements)</span><span class="s0">;</span>
    <span class="s1">}</span>
  <span class="s1">})</span><span class="s0">;</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">replaceSymbols_1 = replaceSymbols$1</span><span class="s0">;</span>

<span class="s0">const </span><span class="s1">importPattern = </span><span class="s3">/^:import\((&quot;[^&quot;]*&quot;|'[^']*'|[^&quot;']+)\)$/</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">balancedQuotes = </span><span class="s3">/^(&quot;[^&quot;]*&quot;|'[^']*'|[^&quot;']+)$/</span><span class="s0">;</span>

<span class="s0">const </span><span class="s1">getDeclsObject = (rule) =&gt; {</span>
  <span class="s0">const </span><span class="s1">object = {}</span><span class="s0">;</span>

  <span class="s1">rule.walkDecls((decl) =&gt; {</span>
    <span class="s0">const </span><span class="s1">before = decl.raws.before ? decl.raws.before.trim() : </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>

    <span class="s1">object[before + decl.prop] = decl.value</span><span class="s0">;</span>
  <span class="s1">})</span><span class="s0">;</span>

  <span class="s0">return </span><span class="s1">object</span><span class="s0">;</span>
<span class="s1">}</span><span class="s0">;</span>
<span class="s5">/**</span>
 <span class="s5">*</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string} css</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{boolean} removeRules</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{'auto' | 'rule' | 'at-rule'} mode</span>
 <span class="s5">*/</span>
<span class="s0">const </span><span class="s1">extractICSS$2 = (css</span><span class="s0">, </span><span class="s1">removeRules = </span><span class="s0">true, </span><span class="s1">mode = </span><span class="s2">&quot;auto&quot;</span><span class="s1">) =&gt; {</span>
  <span class="s0">const </span><span class="s1">icssImports = {}</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">icssExports = {}</span><span class="s0">;</span>

  <span class="s0">function </span><span class="s1">addImports(node</span><span class="s0">, </span><span class="s1">path) {</span>
    <span class="s0">const </span><span class="s1">unquoted = path.replace(</span><span class="s3">/'|&quot;/g</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s1">icssImports[unquoted] = Object.assign(</span>
      <span class="s1">icssImports[unquoted] || {}</span><span class="s0">,</span>
      <span class="s1">getDeclsObject(node)</span>
    <span class="s1">)</span><span class="s0">;</span>

    <span class="s0">if </span><span class="s1">(removeRules) {</span>
      <span class="s1">node.remove()</span><span class="s0">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">function </span><span class="s1">addExports(node) {</span>
    <span class="s1">Object.assign(icssExports</span><span class="s0">, </span><span class="s1">getDeclsObject(node))</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(removeRules) {</span>
      <span class="s1">node.remove()</span><span class="s0">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">css.each((node) =&gt; {</span>
    <span class="s0">if </span><span class="s1">(node.type === </span><span class="s2">&quot;rule&quot; </span><span class="s1">&amp;&amp; mode !== </span><span class="s2">&quot;at-rule&quot;</span><span class="s1">) {</span>
      <span class="s0">if </span><span class="s1">(node.selector.slice(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">7</span><span class="s1">) === </span><span class="s2">&quot;:import&quot;</span><span class="s1">) {</span>
        <span class="s0">const </span><span class="s1">matches = importPattern.exec(node.selector)</span><span class="s0">;</span>

        <span class="s0">if </span><span class="s1">(matches) {</span>
          <span class="s1">addImports(node</span><span class="s0">, </span><span class="s1">matches[</span><span class="s3">1</span><span class="s1">])</span><span class="s0">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s0">if </span><span class="s1">(node.selector === </span><span class="s2">&quot;:export&quot;</span><span class="s1">) {</span>
        <span class="s1">addExports(node)</span><span class="s0">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s0">if </span><span class="s1">(node.type === </span><span class="s2">&quot;atrule&quot; </span><span class="s1">&amp;&amp; mode !== </span><span class="s2">&quot;rule&quot;</span><span class="s1">) {</span>
      <span class="s0">if </span><span class="s1">(node.name === </span><span class="s2">&quot;icss-import&quot;</span><span class="s1">) {</span>
        <span class="s0">const </span><span class="s1">matches = balancedQuotes.exec(node.params)</span><span class="s0">;</span>

        <span class="s0">if </span><span class="s1">(matches) {</span>
          <span class="s1">addImports(node</span><span class="s0">, </span><span class="s1">matches[</span><span class="s3">1</span><span class="s1">])</span><span class="s0">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(node.name === </span><span class="s2">&quot;icss-export&quot;</span><span class="s1">) {</span>
        <span class="s1">addExports(node)</span><span class="s0">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">})</span><span class="s0">;</span>

  <span class="s0">return </span><span class="s1">{ icssImports</span><span class="s0">, </span><span class="s1">icssExports }</span><span class="s0">;</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">extractICSS_1 = extractICSS$2</span><span class="s0">;</span>

<span class="s0">const </span><span class="s1">createImports = (imports</span><span class="s0">, </span><span class="s1">postcss</span><span class="s0">, </span><span class="s1">mode = </span><span class="s2">&quot;rule&quot;</span><span class="s1">) =&gt; {</span>
  <span class="s0">return </span><span class="s1">Object.keys(imports).map((path) =&gt; {</span>
    <span class="s0">const </span><span class="s1">aliases = imports[path]</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">declarations = Object.keys(aliases).map((key) =&gt;</span>
      <span class="s1">postcss.decl({</span>
        <span class="s1">prop: key</span><span class="s0">,</span>
        <span class="s1">value: aliases[key]</span><span class="s0">,</span>
        <span class="s1">raws: { before: </span><span class="s2">&quot;</span><span class="s0">\n  </span><span class="s2">&quot; </span><span class="s1">}</span><span class="s0">,</span>
      <span class="s1">})</span>
    <span class="s1">)</span><span class="s0">;</span>

    <span class="s0">const </span><span class="s1">hasDeclarations = declarations.length &gt; </span><span class="s3">0</span><span class="s0">;</span>

    <span class="s0">const </span><span class="s1">rule =</span>
      <span class="s1">mode === </span><span class="s2">&quot;rule&quot;</span>
        <span class="s1">? postcss.rule({</span>
            <span class="s1">selector: </span><span class="s2">`:import('</span><span class="s1">${path}</span><span class="s2">')`</span><span class="s0">,</span>
            <span class="s1">raws: { after: hasDeclarations ? </span><span class="s2">&quot;</span><span class="s0">\n</span><span class="s2">&quot; </span><span class="s1">: </span><span class="s2">&quot;&quot; </span><span class="s1">}</span><span class="s0">,</span>
          <span class="s1">})</span>
        <span class="s1">: postcss.atRule({</span>
            <span class="s1">name: </span><span class="s2">&quot;icss-import&quot;</span><span class="s0">,</span>
            <span class="s1">params: </span><span class="s2">`'</span><span class="s1">${path}</span><span class="s2">'`</span><span class="s0">,</span>
            <span class="s1">raws: { after: hasDeclarations ? </span><span class="s2">&quot;</span><span class="s0">\n</span><span class="s2">&quot; </span><span class="s1">: </span><span class="s2">&quot;&quot; </span><span class="s1">}</span><span class="s0">,</span>
          <span class="s1">})</span><span class="s0">;</span>

    <span class="s0">if </span><span class="s1">(hasDeclarations) {</span>
      <span class="s1">rule.append(declarations)</span><span class="s0">;</span>
    <span class="s1">}</span>

    <span class="s0">return </span><span class="s1">rule</span><span class="s0">;</span>
  <span class="s1">})</span><span class="s0">;</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s0">const </span><span class="s1">createExports = (exports</span><span class="s0">, </span><span class="s1">postcss</span><span class="s0">, </span><span class="s1">mode = </span><span class="s2">&quot;rule&quot;</span><span class="s1">) =&gt; {</span>
  <span class="s0">const </span><span class="s1">declarations = Object.keys(exports).map((key) =&gt;</span>
    <span class="s1">postcss.decl({</span>
      <span class="s1">prop: key</span><span class="s0">,</span>
      <span class="s1">value: exports[key]</span><span class="s0">,</span>
      <span class="s1">raws: { before: </span><span class="s2">&quot;</span><span class="s0">\n  </span><span class="s2">&quot; </span><span class="s1">}</span><span class="s0">,</span>
    <span class="s1">})</span>
  <span class="s1">)</span><span class="s0">;</span>

  <span class="s0">if </span><span class="s1">(declarations.length === </span><span class="s3">0</span><span class="s1">) {</span>
    <span class="s0">return </span><span class="s1">[]</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">const </span><span class="s1">rule =</span>
    <span class="s1">mode === </span><span class="s2">&quot;rule&quot;</span>
      <span class="s1">? postcss.rule({</span>
          <span class="s1">selector: </span><span class="s2">`:export`</span><span class="s0">,</span>
          <span class="s1">raws: { after: </span><span class="s2">&quot;</span><span class="s0">\n</span><span class="s2">&quot; </span><span class="s1">}</span><span class="s0">,</span>
        <span class="s1">})</span>
      <span class="s1">: postcss.atRule({</span>
          <span class="s1">name: </span><span class="s2">&quot;icss-export&quot;</span><span class="s0">,</span>
          <span class="s1">raws: { after: </span><span class="s2">&quot;</span><span class="s0">\n</span><span class="s2">&quot; </span><span class="s1">}</span><span class="s0">,</span>
        <span class="s1">})</span><span class="s0">;</span>

  <span class="s1">rule.append(declarations)</span><span class="s0">;</span>

  <span class="s0">return </span><span class="s1">[rule]</span><span class="s0">;</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s0">const </span><span class="s1">createICSSRules$1 = (imports</span><span class="s0">, </span><span class="s1">exports</span><span class="s0">, </span><span class="s1">postcss</span><span class="s0">, </span><span class="s1">mode) =&gt; [</span>
  <span class="s1">...createImports(imports</span><span class="s0">, </span><span class="s1">postcss</span><span class="s0">, </span><span class="s1">mode)</span><span class="s0">,</span>
  <span class="s1">...createExports(exports</span><span class="s0">, </span><span class="s1">postcss</span><span class="s0">, </span><span class="s1">mode)</span><span class="s0">,</span>
<span class="s1">]</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">createICSSRules_1 = createICSSRules$1</span><span class="s0">;</span>

<span class="s0">const </span><span class="s1">replaceValueSymbols = replaceValueSymbols_1</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">replaceSymbols = replaceSymbols_1</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">extractICSS$1 = extractICSS_1</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">createICSSRules = createICSSRules_1</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">src$4 = {</span>
  <span class="s1">replaceValueSymbols</span><span class="s0">,</span>
  <span class="s1">replaceSymbols</span><span class="s0">,</span>
  <span class="s1">extractICSS: extractICSS$1</span><span class="s0">,</span>
  <span class="s1">createICSSRules</span><span class="s0">,</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s1">Object.defineProperty(Parser$1</span><span class="s0">, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, </span><span class="s1">{</span>
  <span class="s1">value: </span><span class="s0">true</span>
<span class="s1">})</span><span class="s0">;</span>
<span class="s1">Parser$1.default = </span><span class="s0">void </span><span class="s3">0</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">_icssUtils = src$4</span><span class="s0">;</span>

<span class="s4">// Initially copied from https://github.com/css-modules/css-modules-loader-core</span>
<span class="s0">const </span><span class="s1">importRegexp = </span><span class="s3">/^:import\((.+)\)$/</span><span class="s0">;</span>

<span class="s0">class </span><span class="s1">Parser {</span>
  <span class="s1">constructor(pathFetcher</span><span class="s0">, </span><span class="s1">trace) {</span>
    <span class="s0">this</span><span class="s1">.pathFetcher = pathFetcher</span><span class="s0">;</span>
    <span class="s0">this</span><span class="s1">.plugin = </span><span class="s0">this</span><span class="s1">.plugin.bind(</span><span class="s0">this</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s0">this</span><span class="s1">.exportTokens = {}</span><span class="s0">;</span>
    <span class="s0">this</span><span class="s1">.translations = {}</span><span class="s0">;</span>
    <span class="s0">this</span><span class="s1">.trace = trace</span><span class="s0">;</span>
  <span class="s1">}</span>

  <span class="s1">plugin() {</span>
    <span class="s0">const </span><span class="s1">parser = </span><span class="s0">this;</span>
    <span class="s0">return </span><span class="s1">{</span>
      <span class="s1">postcssPlugin: </span><span class="s2">&quot;css-modules-parser&quot;</span><span class="s0">,</span>

      <span class="s1">async OnceExit(css) {</span>
        <span class="s0">await </span><span class="s1">Promise.all(parser.fetchAllImports(css))</span><span class="s0">;</span>
        <span class="s1">parser.linkImportedSymbols(css)</span><span class="s0">;</span>
        <span class="s0">return </span><span class="s1">parser.extractExports(css)</span><span class="s0">;</span>
      <span class="s1">}</span>

    <span class="s1">}</span><span class="s0">;</span>
  <span class="s1">}</span>

  <span class="s1">fetchAllImports(css) {</span>
    <span class="s0">let </span><span class="s1">imports = []</span><span class="s0">;</span>
    <span class="s1">css.each(node =&gt; {</span>
      <span class="s0">if </span><span class="s1">(node.type == </span><span class="s2">&quot;rule&quot; </span><span class="s1">&amp;&amp; node.selector.match(importRegexp)) {</span>
        <span class="s1">imports.push(</span><span class="s0">this</span><span class="s1">.fetchImport(node</span><span class="s0">, </span><span class="s1">css.source.input.from</span><span class="s0">, </span><span class="s1">imports.length))</span><span class="s0">;</span>
      <span class="s1">}</span>
    <span class="s1">})</span><span class="s0">;</span>
    <span class="s0">return </span><span class="s1">imports</span><span class="s0">;</span>
  <span class="s1">}</span>

  <span class="s1">linkImportedSymbols(css) {</span>
    <span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">_icssUtils.replaceSymbols)(css</span><span class="s0">, this</span><span class="s1">.translations)</span><span class="s0">;</span>
  <span class="s1">}</span>

  <span class="s1">extractExports(css) {</span>
    <span class="s1">css.each(node =&gt; {</span>
      <span class="s0">if </span><span class="s1">(node.type == </span><span class="s2">&quot;rule&quot; </span><span class="s1">&amp;&amp; node.selector == </span><span class="s2">&quot;:export&quot;</span><span class="s1">) </span><span class="s0">this</span><span class="s1">.handleExport(node)</span><span class="s0">;</span>
    <span class="s1">})</span><span class="s0">;</span>
  <span class="s1">}</span>

  <span class="s1">handleExport(exportNode) {</span>
    <span class="s1">exportNode.each(decl =&gt; {</span>
      <span class="s0">if </span><span class="s1">(decl.type == </span><span class="s2">&quot;decl&quot;</span><span class="s1">) {</span>
        <span class="s1">Object.keys(</span><span class="s0">this</span><span class="s1">.translations).forEach(translation =&gt; {</span>
          <span class="s1">decl.value = decl.value.replace(translation</span><span class="s0">, this</span><span class="s1">.translations[translation])</span><span class="s0">;</span>
        <span class="s1">})</span><span class="s0">;</span>
        <span class="s0">this</span><span class="s1">.exportTokens[decl.prop] = decl.value</span><span class="s0">;</span>
      <span class="s1">}</span>
    <span class="s1">})</span><span class="s0">;</span>
    <span class="s1">exportNode.remove()</span><span class="s0">;</span>
  <span class="s1">}</span>

  <span class="s1">async fetchImport(importNode</span><span class="s0">, </span><span class="s1">relativeTo</span><span class="s0">, </span><span class="s1">depNr) {</span>
    <span class="s0">const </span><span class="s1">file = importNode.selector.match(importRegexp)[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">depTrace = </span><span class="s0">this</span><span class="s1">.trace + String.fromCharCode(depNr)</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">exports = </span><span class="s0">await this</span><span class="s1">.pathFetcher(file</span><span class="s0">, </span><span class="s1">relativeTo</span><span class="s0">, </span><span class="s1">depTrace)</span><span class="s0">;</span>

    <span class="s0">try </span><span class="s1">{</span>
      <span class="s1">importNode.each(decl =&gt; {</span>
        <span class="s0">if </span><span class="s1">(decl.type == </span><span class="s2">&quot;decl&quot;</span><span class="s1">) {</span>
          <span class="s0">this</span><span class="s1">.translations[decl.prop] = exports[decl.value]</span><span class="s0">;</span>
        <span class="s1">}</span>
      <span class="s1">})</span><span class="s0">;</span>
      <span class="s1">importNode.remove()</span><span class="s0">;</span>
    <span class="s1">} </span><span class="s0">catch </span><span class="s1">(err) {</span>
      <span class="s1">console.log(err)</span><span class="s0">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

<span class="s1">}</span>

<span class="s1">Parser$1.default = Parser</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">saveJSON$1 = {}</span><span class="s0">;</span>

<span class="s1">Object.defineProperty(saveJSON$1</span><span class="s0">, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, </span><span class="s1">{</span>
  <span class="s1">value: </span><span class="s0">true</span>
<span class="s1">})</span><span class="s0">;</span>
<span class="s1">saveJSON$1.default = saveJSON</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">_fs$2 = fs</span><span class="s0">;</span>

<span class="s0">function </span><span class="s1">saveJSON(cssFile</span><span class="s0">, </span><span class="s1">json) {</span>
  <span class="s0">return new </span><span class="s1">Promise((resolve</span><span class="s0">, </span><span class="s1">reject) =&gt; {</span>
    <span class="s0">const </span><span class="s1">{</span>
      <span class="s1">writeFile</span>
    <span class="s1">} = (</span><span class="s3">0</span><span class="s0">, </span><span class="s1">_fs$2.getFileSystem)()</span><span class="s0">;</span>
    <span class="s1">writeFile(</span><span class="s2">`</span><span class="s1">${cssFile}</span><span class="s2">.json`</span><span class="s0">, </span><span class="s1">JSON.stringify(json)</span><span class="s0">, </span><span class="s1">e =&gt; e ? reject(e) : resolve(json))</span><span class="s0">;</span>
  <span class="s1">})</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">var </span><span class="s1">localsConvention = {}</span><span class="s0">;</span>

<span class="s5">/**</span>
 <span class="s5">* lodash (Custom Build) &lt;https://lodash.com/&gt;</span>
 <span class="s5">* Build: `lodash modularize exports=&quot;npm&quot; -o ./`</span>
 <span class="s5">* Copyright jQuery Foundation and other contributors &lt;https://jquery.org/&gt;</span>
 <span class="s5">* Released under MIT license &lt;https://lodash.com/license&gt;</span>
 <span class="s5">* Based on Underscore.js 1.8.3 &lt;http://underscorejs.org/LICENSE&gt;</span>
 <span class="s5">* Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters &amp; Editors</span>
 <span class="s5">*/</span>

<span class="s5">/** Used as references for various `Number` constants. */</span>
<span class="s0">var </span><span class="s1">INFINITY = </span><span class="s3">1 </span><span class="s1">/ </span><span class="s3">0</span><span class="s0">;</span>

<span class="s5">/** `Object#toString` result references. */</span>
<span class="s0">var </span><span class="s1">symbolTag = </span><span class="s2">'[object Symbol]'</span><span class="s0">;</span>

<span class="s5">/** Used to match words composed of alphanumeric characters. */</span>
<span class="s0">var </span><span class="s1">reAsciiWord = </span><span class="s3">/[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g</span><span class="s0">;</span>

<span class="s5">/** Used to match Latin Unicode letters (excluding mathematical operators). */</span>
<span class="s0">var </span><span class="s1">reLatin = </span><span class="s3">/[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g</span><span class="s0">;</span>

<span class="s5">/** Used to compose unicode character classes. */</span>
<span class="s0">var </span><span class="s1">rsAstralRange = </span><span class="s2">'</span><span class="s0">\\</span><span class="s2">ud800-</span><span class="s0">\\</span><span class="s2">udfff'</span><span class="s0">,</span>
    <span class="s1">rsComboMarksRange = </span><span class="s2">'</span><span class="s0">\\</span><span class="s2">u0300-</span><span class="s0">\\</span><span class="s2">u036f</span><span class="s0">\\</span><span class="s2">ufe20-</span><span class="s0">\\</span><span class="s2">ufe23'</span><span class="s0">,</span>
    <span class="s1">rsComboSymbolsRange = </span><span class="s2">'</span><span class="s0">\\</span><span class="s2">u20d0-</span><span class="s0">\\</span><span class="s2">u20f0'</span><span class="s0">,</span>
    <span class="s1">rsDingbatRange = </span><span class="s2">'</span><span class="s0">\\</span><span class="s2">u2700-</span><span class="s0">\\</span><span class="s2">u27bf'</span><span class="s0">,</span>
    <span class="s1">rsLowerRange = </span><span class="s2">'a-z</span><span class="s0">\\</span><span class="s2">xdf-</span><span class="s0">\\</span><span class="s2">xf6</span><span class="s0">\\</span><span class="s2">xf8-</span><span class="s0">\\</span><span class="s2">xff'</span><span class="s0">,</span>
    <span class="s1">rsMathOpRange = </span><span class="s2">'</span><span class="s0">\\</span><span class="s2">xac</span><span class="s0">\\</span><span class="s2">xb1</span><span class="s0">\\</span><span class="s2">xd7</span><span class="s0">\\</span><span class="s2">xf7'</span><span class="s0">,</span>
    <span class="s1">rsNonCharRange = </span><span class="s2">'</span><span class="s0">\\</span><span class="s2">x00-</span><span class="s0">\\</span><span class="s2">x2f</span><span class="s0">\\</span><span class="s2">x3a-</span><span class="s0">\\</span><span class="s2">x40</span><span class="s0">\\</span><span class="s2">x5b-</span><span class="s0">\\</span><span class="s2">x60</span><span class="s0">\\</span><span class="s2">x7b-</span><span class="s0">\\</span><span class="s2">xbf'</span><span class="s0">,</span>
    <span class="s1">rsPunctuationRange = </span><span class="s2">'</span><span class="s0">\\</span><span class="s2">u2000-</span><span class="s0">\\</span><span class="s2">u206f'</span><span class="s0">,</span>
    <span class="s1">rsSpaceRange = </span><span class="s2">' </span><span class="s0">\\</span><span class="s2">t</span><span class="s0">\\</span><span class="s2">x0b</span><span class="s0">\\</span><span class="s2">f</span><span class="s0">\\</span><span class="s2">xa0</span><span class="s0">\\</span><span class="s2">ufeff</span><span class="s0">\\</span><span class="s2">n</span><span class="s0">\\</span><span class="s2">r</span><span class="s0">\\</span><span class="s2">u2028</span><span class="s0">\\</span><span class="s2">u2029</span><span class="s0">\\</span><span class="s2">u1680</span><span class="s0">\\</span><span class="s2">u180e</span><span class="s0">\\</span><span class="s2">u2000</span><span class="s0">\\</span><span class="s2">u2001</span><span class="s0">\\</span><span class="s2">u2002</span><span class="s0">\\</span><span class="s2">u2003</span><span class="s0">\\</span><span class="s2">u2004</span><span class="s0">\\</span><span class="s2">u2005</span><span class="s0">\\</span><span class="s2">u2006</span><span class="s0">\\</span><span class="s2">u2007</span><span class="s0">\\</span><span class="s2">u2008</span><span class="s0">\\</span><span class="s2">u2009</span><span class="s0">\\</span><span class="s2">u200a</span><span class="s0">\\</span><span class="s2">u202f</span><span class="s0">\\</span><span class="s2">u205f</span><span class="s0">\\</span><span class="s2">u3000'</span><span class="s0">,</span>
    <span class="s1">rsUpperRange = </span><span class="s2">'A-Z</span><span class="s0">\\</span><span class="s2">xc0-</span><span class="s0">\\</span><span class="s2">xd6</span><span class="s0">\\</span><span class="s2">xd8-</span><span class="s0">\\</span><span class="s2">xde'</span><span class="s0">,</span>
    <span class="s1">rsVarRange = </span><span class="s2">'</span><span class="s0">\\</span><span class="s2">ufe0e</span><span class="s0">\\</span><span class="s2">ufe0f'</span><span class="s0">,</span>
    <span class="s1">rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange</span><span class="s0">;</span>

<span class="s5">/** Used to compose unicode capture groups. */</span>
<span class="s0">var </span><span class="s1">rsApos = </span><span class="s2">&quot;['</span><span class="s0">\u2019</span><span class="s2">]&quot;</span><span class="s0">,</span>
    <span class="s1">rsAstral = </span><span class="s2">'[' </span><span class="s1">+ rsAstralRange + </span><span class="s2">']'</span><span class="s0">,</span>
    <span class="s1">rsBreak = </span><span class="s2">'[' </span><span class="s1">+ rsBreakRange + </span><span class="s2">']'</span><span class="s0">,</span>
    <span class="s1">rsCombo = </span><span class="s2">'[' </span><span class="s1">+ rsComboMarksRange + rsComboSymbolsRange + </span><span class="s2">']'</span><span class="s0">,</span>
    <span class="s1">rsDigits = </span><span class="s2">'</span><span class="s0">\\</span><span class="s2">d+'</span><span class="s0">,</span>
    <span class="s1">rsDingbat = </span><span class="s2">'[' </span><span class="s1">+ rsDingbatRange + </span><span class="s2">']'</span><span class="s0">,</span>
    <span class="s1">rsLower = </span><span class="s2">'[' </span><span class="s1">+ rsLowerRange + </span><span class="s2">']'</span><span class="s0">,</span>
    <span class="s1">rsMisc = </span><span class="s2">'[^' </span><span class="s1">+ rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + </span><span class="s2">']'</span><span class="s0">,</span>
    <span class="s1">rsFitz = </span><span class="s2">'</span><span class="s0">\\</span><span class="s2">ud83c[</span><span class="s0">\\</span><span class="s2">udffb-</span><span class="s0">\\</span><span class="s2">udfff]'</span><span class="s0">,</span>
    <span class="s1">rsModifier = </span><span class="s2">'(?:' </span><span class="s1">+ rsCombo + </span><span class="s2">'|' </span><span class="s1">+ rsFitz + </span><span class="s2">')'</span><span class="s0">,</span>
    <span class="s1">rsNonAstral = </span><span class="s2">'[^' </span><span class="s1">+ rsAstralRange + </span><span class="s2">']'</span><span class="s0">,</span>
    <span class="s1">rsRegional = </span><span class="s2">'(?:</span><span class="s0">\\</span><span class="s2">ud83c[</span><span class="s0">\\</span><span class="s2">udde6-</span><span class="s0">\\</span><span class="s2">uddff]){2}'</span><span class="s0">,</span>
    <span class="s1">rsSurrPair = </span><span class="s2">'[</span><span class="s0">\\</span><span class="s2">ud800-</span><span class="s0">\\</span><span class="s2">udbff][</span><span class="s0">\\</span><span class="s2">udc00-</span><span class="s0">\\</span><span class="s2">udfff]'</span><span class="s0">,</span>
    <span class="s1">rsUpper = </span><span class="s2">'[' </span><span class="s1">+ rsUpperRange + </span><span class="s2">']'</span><span class="s0">,</span>
    <span class="s1">rsZWJ = </span><span class="s2">'</span><span class="s0">\\</span><span class="s2">u200d'</span><span class="s0">;</span>

<span class="s5">/** Used to compose unicode regexes. */</span>
<span class="s0">var </span><span class="s1">rsLowerMisc = </span><span class="s2">'(?:' </span><span class="s1">+ rsLower + </span><span class="s2">'|' </span><span class="s1">+ rsMisc + </span><span class="s2">')'</span><span class="s0">,</span>
    <span class="s1">rsUpperMisc = </span><span class="s2">'(?:' </span><span class="s1">+ rsUpper + </span><span class="s2">'|' </span><span class="s1">+ rsMisc + </span><span class="s2">')'</span><span class="s0">,</span>
    <span class="s1">rsOptLowerContr = </span><span class="s2">'(?:' </span><span class="s1">+ rsApos + </span><span class="s2">'(?:d|ll|m|re|s|t|ve))?'</span><span class="s0">,</span>
    <span class="s1">rsOptUpperContr = </span><span class="s2">'(?:' </span><span class="s1">+ rsApos + </span><span class="s2">'(?:D|LL|M|RE|S|T|VE))?'</span><span class="s0">,</span>
    <span class="s1">reOptMod = rsModifier + </span><span class="s2">'?'</span><span class="s0">,</span>
    <span class="s1">rsOptVar = </span><span class="s2">'[' </span><span class="s1">+ rsVarRange + </span><span class="s2">']?'</span><span class="s0">,</span>
    <span class="s1">rsOptJoin = </span><span class="s2">'(?:' </span><span class="s1">+ rsZWJ + </span><span class="s2">'(?:' </span><span class="s1">+ [rsNonAstral</span><span class="s0">, </span><span class="s1">rsRegional</span><span class="s0">, </span><span class="s1">rsSurrPair].join(</span><span class="s2">'|'</span><span class="s1">) + </span><span class="s2">')' </span><span class="s1">+ rsOptVar + reOptMod + </span><span class="s2">')*'</span><span class="s0">,</span>
    <span class="s1">rsSeq = rsOptVar + reOptMod + rsOptJoin</span><span class="s0">,</span>
    <span class="s1">rsEmoji = </span><span class="s2">'(?:' </span><span class="s1">+ [rsDingbat</span><span class="s0">, </span><span class="s1">rsRegional</span><span class="s0">, </span><span class="s1">rsSurrPair].join(</span><span class="s2">'|'</span><span class="s1">) + </span><span class="s2">')' </span><span class="s1">+ rsSeq</span><span class="s0">,</span>
    <span class="s1">rsSymbol = </span><span class="s2">'(?:' </span><span class="s1">+ [rsNonAstral + rsCombo + </span><span class="s2">'?'</span><span class="s0">, </span><span class="s1">rsCombo</span><span class="s0">, </span><span class="s1">rsRegional</span><span class="s0">, </span><span class="s1">rsSurrPair</span><span class="s0">, </span><span class="s1">rsAstral].join(</span><span class="s2">'|'</span><span class="s1">) + </span><span class="s2">')'</span><span class="s0">;</span>

<span class="s5">/** Used to match apostrophes. */</span>
<span class="s0">var </span><span class="s1">reApos = RegExp(rsApos</span><span class="s0">, </span><span class="s2">'g'</span><span class="s1">)</span><span class="s0">;</span>

<span class="s5">/**</span>
 <span class="s5">* Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and</span>
 <span class="s5">* [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).</span>
 <span class="s5">*/</span>
<span class="s0">var </span><span class="s1">reComboMark = RegExp(rsCombo</span><span class="s0">, </span><span class="s2">'g'</span><span class="s1">)</span><span class="s0">;</span>

<span class="s5">/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */</span>
<span class="s0">var </span><span class="s1">reUnicode = RegExp(rsFitz + </span><span class="s2">'(?=' </span><span class="s1">+ rsFitz + </span><span class="s2">')|' </span><span class="s1">+ rsSymbol + rsSeq</span><span class="s0">, </span><span class="s2">'g'</span><span class="s1">)</span><span class="s0">;</span>

<span class="s5">/** Used to match complex or compound words. */</span>
<span class="s0">var </span><span class="s1">reUnicodeWord = RegExp([</span>
  <span class="s1">rsUpper + </span><span class="s2">'?' </span><span class="s1">+ rsLower + </span><span class="s2">'+' </span><span class="s1">+ rsOptLowerContr + </span><span class="s2">'(?=' </span><span class="s1">+ [rsBreak</span><span class="s0">, </span><span class="s1">rsUpper</span><span class="s0">, </span><span class="s2">'$'</span><span class="s1">].join(</span><span class="s2">'|'</span><span class="s1">) + </span><span class="s2">')'</span><span class="s0">,</span>
  <span class="s1">rsUpperMisc + </span><span class="s2">'+' </span><span class="s1">+ rsOptUpperContr + </span><span class="s2">'(?=' </span><span class="s1">+ [rsBreak</span><span class="s0">, </span><span class="s1">rsUpper + rsLowerMisc</span><span class="s0">, </span><span class="s2">'$'</span><span class="s1">].join(</span><span class="s2">'|'</span><span class="s1">) + </span><span class="s2">')'</span><span class="s0">,</span>
  <span class="s1">rsUpper + </span><span class="s2">'?' </span><span class="s1">+ rsLowerMisc + </span><span class="s2">'+' </span><span class="s1">+ rsOptLowerContr</span><span class="s0">,</span>
  <span class="s1">rsUpper + </span><span class="s2">'+' </span><span class="s1">+ rsOptUpperContr</span><span class="s0">,</span>
  <span class="s1">rsDigits</span><span class="s0">,</span>
  <span class="s1">rsEmoji</span>
<span class="s1">].join(</span><span class="s2">'|'</span><span class="s1">)</span><span class="s0">, </span><span class="s2">'g'</span><span class="s1">)</span><span class="s0">;</span>

<span class="s5">/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */</span>
<span class="s0">var </span><span class="s1">reHasUnicode = RegExp(</span><span class="s2">'[' </span><span class="s1">+ rsZWJ + rsAstralRange  + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + </span><span class="s2">']'</span><span class="s1">)</span><span class="s0">;</span>

<span class="s5">/** Used to detect strings that need a more robust regexp to match words. */</span>
<span class="s0">var </span><span class="s1">reHasUnicodeWord = </span><span class="s3">/[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/</span><span class="s0">;</span>

<span class="s5">/** Used to map Latin Unicode letters to basic Latin letters. */</span>
<span class="s0">var </span><span class="s1">deburredLetters = {</span>
  <span class="s4">// Latin-1 Supplement block.</span>
  <span class="s2">'</span><span class="s0">\xc0</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'A'</span><span class="s0">,  </span><span class="s2">'</span><span class="s0">\xc1</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'A'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\xc2</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'A'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\xc3</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'A'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\xc4</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'A'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\xc5</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'A'</span><span class="s0">,</span>
  <span class="s2">'</span><span class="s0">\xe0</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'a'</span><span class="s0">,  </span><span class="s2">'</span><span class="s0">\xe1</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'a'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\xe2</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'a'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\xe3</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'a'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\xe4</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'a'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\xe5</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'a'</span><span class="s0">,</span>
  <span class="s2">'</span><span class="s0">\xc7</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'C'</span><span class="s0">,  </span><span class="s2">'</span><span class="s0">\xe7</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'c'</span><span class="s0">,</span>
  <span class="s2">'</span><span class="s0">\xd0</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'D'</span><span class="s0">,  </span><span class="s2">'</span><span class="s0">\xf0</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'d'</span><span class="s0">,</span>
  <span class="s2">'</span><span class="s0">\xc8</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'E'</span><span class="s0">,  </span><span class="s2">'</span><span class="s0">\xc9</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'E'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\xca</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'E'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\xcb</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'E'</span><span class="s0">,</span>
  <span class="s2">'</span><span class="s0">\xe8</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'e'</span><span class="s0">,  </span><span class="s2">'</span><span class="s0">\xe9</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'e'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\xea</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'e'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\xeb</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'e'</span><span class="s0">,</span>
  <span class="s2">'</span><span class="s0">\xcc</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'I'</span><span class="s0">,  </span><span class="s2">'</span><span class="s0">\xcd</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'I'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\xce</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'I'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\xcf</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'I'</span><span class="s0">,</span>
  <span class="s2">'</span><span class="s0">\xec</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'i'</span><span class="s0">,  </span><span class="s2">'</span><span class="s0">\xed</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'i'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\xee</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'i'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\xef</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'i'</span><span class="s0">,</span>
  <span class="s2">'</span><span class="s0">\xd1</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'N'</span><span class="s0">,  </span><span class="s2">'</span><span class="s0">\xf1</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'n'</span><span class="s0">,</span>
  <span class="s2">'</span><span class="s0">\xd2</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'O'</span><span class="s0">,  </span><span class="s2">'</span><span class="s0">\xd3</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'O'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\xd4</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'O'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\xd5</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'O'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\xd6</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'O'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\xd8</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'O'</span><span class="s0">,</span>
  <span class="s2">'</span><span class="s0">\xf2</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'o'</span><span class="s0">,  </span><span class="s2">'</span><span class="s0">\xf3</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'o'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\xf4</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'o'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\xf5</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'o'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\xf6</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'o'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\xf8</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'o'</span><span class="s0">,</span>
  <span class="s2">'</span><span class="s0">\xd9</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'U'</span><span class="s0">,  </span><span class="s2">'</span><span class="s0">\xda</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'U'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\xdb</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'U'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\xdc</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'U'</span><span class="s0">,</span>
  <span class="s2">'</span><span class="s0">\xf9</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'u'</span><span class="s0">,  </span><span class="s2">'</span><span class="s0">\xfa</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'u'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\xfb</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'u'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\xfc</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'u'</span><span class="s0">,</span>
  <span class="s2">'</span><span class="s0">\xdd</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'Y'</span><span class="s0">,  </span><span class="s2">'</span><span class="s0">\xfd</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'y'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\xff</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'y'</span><span class="s0">,</span>
  <span class="s2">'</span><span class="s0">\xc6</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'Ae'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\xe6</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'ae'</span><span class="s0">,</span>
  <span class="s2">'</span><span class="s0">\xde</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'Th'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\xfe</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'th'</span><span class="s0">,</span>
  <span class="s2">'</span><span class="s0">\xdf</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'ss'</span><span class="s0">,</span>
  <span class="s4">// Latin Extended-A block.</span>
  <span class="s2">'</span><span class="s0">\u0100</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'A'</span><span class="s0">,  </span><span class="s2">'</span><span class="s0">\u0102</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'A'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\u0104</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'A'</span><span class="s0">,</span>
  <span class="s2">'</span><span class="s0">\u0101</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'a'</span><span class="s0">,  </span><span class="s2">'</span><span class="s0">\u0103</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'a'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\u0105</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'a'</span><span class="s0">,</span>
  <span class="s2">'</span><span class="s0">\u0106</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'C'</span><span class="s0">,  </span><span class="s2">'</span><span class="s0">\u0108</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'C'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\u010a</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'C'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\u010c</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'C'</span><span class="s0">,</span>
  <span class="s2">'</span><span class="s0">\u0107</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'c'</span><span class="s0">,  </span><span class="s2">'</span><span class="s0">\u0109</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'c'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\u010b</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'c'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\u010d</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'c'</span><span class="s0">,</span>
  <span class="s2">'</span><span class="s0">\u010e</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'D'</span><span class="s0">,  </span><span class="s2">'</span><span class="s0">\u0110</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'D'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\u010f</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'d'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\u0111</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'d'</span><span class="s0">,</span>
  <span class="s2">'</span><span class="s0">\u0112</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'E'</span><span class="s0">,  </span><span class="s2">'</span><span class="s0">\u0114</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'E'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\u0116</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'E'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\u0118</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'E'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\u011a</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'E'</span><span class="s0">,</span>
  <span class="s2">'</span><span class="s0">\u0113</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'e'</span><span class="s0">,  </span><span class="s2">'</span><span class="s0">\u0115</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'e'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\u0117</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'e'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\u0119</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'e'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\u011b</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'e'</span><span class="s0">,</span>
  <span class="s2">'</span><span class="s0">\u011c</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'G'</span><span class="s0">,  </span><span class="s2">'</span><span class="s0">\u011e</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'G'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\u0120</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'G'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\u0122</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'G'</span><span class="s0">,</span>
  <span class="s2">'</span><span class="s0">\u011d</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'g'</span><span class="s0">,  </span><span class="s2">'</span><span class="s0">\u011f</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'g'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\u0121</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'g'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\u0123</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'g'</span><span class="s0">,</span>
  <span class="s2">'</span><span class="s0">\u0124</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'H'</span><span class="s0">,  </span><span class="s2">'</span><span class="s0">\u0126</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'H'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\u0125</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'h'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\u0127</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'h'</span><span class="s0">,</span>
  <span class="s2">'</span><span class="s0">\u0128</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'I'</span><span class="s0">,  </span><span class="s2">'</span><span class="s0">\u012a</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'I'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\u012c</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'I'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\u012e</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'I'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\u0130</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'I'</span><span class="s0">,</span>
  <span class="s2">'</span><span class="s0">\u0129</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'i'</span><span class="s0">,  </span><span class="s2">'</span><span class="s0">\u012b</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'i'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\u012d</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'i'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\u012f</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'i'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\u0131</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'i'</span><span class="s0">,</span>
  <span class="s2">'</span><span class="s0">\u0134</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'J'</span><span class="s0">,  </span><span class="s2">'</span><span class="s0">\u0135</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'j'</span><span class="s0">,</span>
  <span class="s2">'</span><span class="s0">\u0136</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'K'</span><span class="s0">,  </span><span class="s2">'</span><span class="s0">\u0137</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'k'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\u0138</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'k'</span><span class="s0">,</span>
  <span class="s2">'</span><span class="s0">\u0139</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'L'</span><span class="s0">,  </span><span class="s2">'</span><span class="s0">\u013b</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'L'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\u013d</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'L'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\u013f</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'L'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\u0141</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'L'</span><span class="s0">,</span>
  <span class="s2">'</span><span class="s0">\u013a</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'l'</span><span class="s0">,  </span><span class="s2">'</span><span class="s0">\u013c</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'l'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\u013e</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'l'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\u0140</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'l'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\u0142</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'l'</span><span class="s0">,</span>
  <span class="s2">'</span><span class="s0">\u0143</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'N'</span><span class="s0">,  </span><span class="s2">'</span><span class="s0">\u0145</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'N'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\u0147</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'N'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\u014a</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'N'</span><span class="s0">,</span>
  <span class="s2">'</span><span class="s0">\u0144</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'n'</span><span class="s0">,  </span><span class="s2">'</span><span class="s0">\u0146</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'n'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\u0148</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'n'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\u014b</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'n'</span><span class="s0">,</span>
  <span class="s2">'</span><span class="s0">\u014c</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'O'</span><span class="s0">,  </span><span class="s2">'</span><span class="s0">\u014e</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'O'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\u0150</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'O'</span><span class="s0">,</span>
  <span class="s2">'</span><span class="s0">\u014d</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'o'</span><span class="s0">,  </span><span class="s2">'</span><span class="s0">\u014f</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'o'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\u0151</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'o'</span><span class="s0">,</span>
  <span class="s2">'</span><span class="s0">\u0154</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'R'</span><span class="s0">,  </span><span class="s2">'</span><span class="s0">\u0156</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'R'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\u0158</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'R'</span><span class="s0">,</span>
  <span class="s2">'</span><span class="s0">\u0155</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'r'</span><span class="s0">,  </span><span class="s2">'</span><span class="s0">\u0157</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'r'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\u0159</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'r'</span><span class="s0">,</span>
  <span class="s2">'</span><span class="s0">\u015a</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'S'</span><span class="s0">,  </span><span class="s2">'</span><span class="s0">\u015c</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'S'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\u015e</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'S'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\u0160</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'S'</span><span class="s0">,</span>
  <span class="s2">'</span><span class="s0">\u015b</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'s'</span><span class="s0">,  </span><span class="s2">'</span><span class="s0">\u015d</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'s'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\u015f</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'s'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\u0161</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'s'</span><span class="s0">,</span>
  <span class="s2">'</span><span class="s0">\u0162</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'T'</span><span class="s0">,  </span><span class="s2">'</span><span class="s0">\u0164</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'T'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\u0166</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'T'</span><span class="s0">,</span>
  <span class="s2">'</span><span class="s0">\u0163</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'t'</span><span class="s0">,  </span><span class="s2">'</span><span class="s0">\u0165</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'t'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\u0167</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'t'</span><span class="s0">,</span>
  <span class="s2">'</span><span class="s0">\u0168</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'U'</span><span class="s0">,  </span><span class="s2">'</span><span class="s0">\u016a</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'U'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\u016c</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'U'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\u016e</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'U'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\u0170</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'U'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\u0172</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'U'</span><span class="s0">,</span>
  <span class="s2">'</span><span class="s0">\u0169</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'u'</span><span class="s0">,  </span><span class="s2">'</span><span class="s0">\u016b</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'u'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\u016d</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'u'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\u016f</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'u'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\u0171</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'u'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\u0173</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'u'</span><span class="s0">,</span>
  <span class="s2">'</span><span class="s0">\u0174</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'W'</span><span class="s0">,  </span><span class="s2">'</span><span class="s0">\u0175</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'w'</span><span class="s0">,</span>
  <span class="s2">'</span><span class="s0">\u0176</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'Y'</span><span class="s0">,  </span><span class="s2">'</span><span class="s0">\u0177</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'y'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\u0178</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'Y'</span><span class="s0">,</span>
  <span class="s2">'</span><span class="s0">\u0179</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'Z'</span><span class="s0">,  </span><span class="s2">'</span><span class="s0">\u017b</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'Z'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\u017d</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'Z'</span><span class="s0">,</span>
  <span class="s2">'</span><span class="s0">\u017a</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'z'</span><span class="s0">,  </span><span class="s2">'</span><span class="s0">\u017c</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'z'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\u017e</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'z'</span><span class="s0">,</span>
  <span class="s2">'</span><span class="s0">\u0132</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'IJ'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\u0133</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'ij'</span><span class="s0">,</span>
  <span class="s2">'</span><span class="s0">\u0152</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'Oe'</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\u0153</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'oe'</span><span class="s0">,</span>
  <span class="s2">'</span><span class="s0">\u0149</span><span class="s2">'</span><span class="s1">: </span><span class="s2">&quot;'n&quot;</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\u017f</span><span class="s2">'</span><span class="s1">: </span><span class="s2">'ss'</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s5">/** Detect free variable `global` from Node.js. */</span>
<span class="s0">var </span><span class="s1">freeGlobal = </span><span class="s0">typeof </span><span class="s1">commonjsGlobal == </span><span class="s2">'object' </span><span class="s1">&amp;&amp; commonjsGlobal &amp;&amp; commonjsGlobal.Object === Object &amp;&amp; commonjsGlobal</span><span class="s0">;</span>

<span class="s5">/** Detect free variable `self`. */</span>
<span class="s0">var </span><span class="s1">freeSelf = </span><span class="s0">typeof </span><span class="s1">self == </span><span class="s2">'object' </span><span class="s1">&amp;&amp; self &amp;&amp; self.Object === Object &amp;&amp; self</span><span class="s0">;</span>

<span class="s5">/** Used as a reference to the global object. */</span>
<span class="s0">var </span><span class="s1">root$2 = freeGlobal || freeSelf || Function(</span><span class="s2">'return this'</span><span class="s1">)()</span><span class="s0">;</span>

<span class="s5">/**</span>
 <span class="s5">* A specialized version of `_.reduce` for arrays without support for</span>
 <span class="s5">* iteratee shorthands.</span>
 <span class="s5">*</span>
 <span class="s5">* </span><span class="s6">@private</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Array} [array] The array to iterate over.</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Function} iteratee The function invoked per iteration.</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{*} [accumulator] The initial value.</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{boolean} [initAccum] Specify using the first element of `array` as</span>
 <span class="s5">*  the initial value.</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{*} Returns the accumulated value.</span>
 <span class="s5">*/</span>
<span class="s0">function </span><span class="s1">arrayReduce(array</span><span class="s0">, </span><span class="s1">iteratee</span><span class="s0">, </span><span class="s1">accumulator</span><span class="s0">, </span><span class="s1">initAccum) {</span>
  <span class="s0">var </span><span class="s1">index = -</span><span class="s3">1</span><span class="s0">,</span>
      <span class="s1">length = array ? array.length : </span><span class="s3">0</span><span class="s0">;</span>

  <span class="s0">if </span><span class="s1">(initAccum &amp;&amp; length) {</span>
    <span class="s1">accumulator = array[++index]</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">while </span><span class="s1">(++index &lt; length) {</span>
    <span class="s1">accumulator = iteratee(accumulator</span><span class="s0">, </span><span class="s1">array[index]</span><span class="s0">, </span><span class="s1">index</span><span class="s0">, </span><span class="s1">array)</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">return </span><span class="s1">accumulator</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s5">/**</span>
 <span class="s5">* Converts an ASCII `string` to an array.</span>
 <span class="s5">*</span>
 <span class="s5">* </span><span class="s6">@private</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string} string The string to convert.</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{Array} Returns the converted array.</span>
 <span class="s5">*/</span>
<span class="s0">function </span><span class="s1">asciiToArray(string) {</span>
  <span class="s0">return </span><span class="s1">string.split(</span><span class="s2">''</span><span class="s1">)</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s5">/**</span>
 <span class="s5">* Splits an ASCII `string` into an array of its words.</span>
 <span class="s5">*</span>
 <span class="s5">* </span><span class="s6">@private</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string} The string to inspect.</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{Array} Returns the words of `string`.</span>
 <span class="s5">*/</span>
<span class="s0">function </span><span class="s1">asciiWords(string) {</span>
  <span class="s0">return </span><span class="s1">string.match(reAsciiWord) || []</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s5">/**</span>
 <span class="s5">* The base implementation of `_.propertyOf` without support for deep paths.</span>
 <span class="s5">*</span>
 <span class="s5">* </span><span class="s6">@private</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Object} object The object to query.</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{Function} Returns the new accessor function.</span>
 <span class="s5">*/</span>
<span class="s0">function </span><span class="s1">basePropertyOf(object) {</span>
  <span class="s0">return function</span><span class="s1">(key) {</span>
    <span class="s0">return </span><span class="s1">object == </span><span class="s0">null </span><span class="s1">? undefined : object[key]</span><span class="s0">;</span>
  <span class="s1">}</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s5">/**</span>
 <span class="s5">* Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A</span>
 <span class="s5">* letters to basic Latin letters.</span>
 <span class="s5">*</span>
 <span class="s5">* </span><span class="s6">@private</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string} letter The matched letter to deburr.</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{string} Returns the deburred letter.</span>
 <span class="s5">*/</span>
<span class="s0">var </span><span class="s1">deburrLetter = basePropertyOf(deburredLetters)</span><span class="s0">;</span>

<span class="s5">/**</span>
 <span class="s5">* Checks if `string` contains Unicode symbols.</span>
 <span class="s5">*</span>
 <span class="s5">* </span><span class="s6">@private</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string} string The string to inspect.</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{boolean} Returns `true` if a symbol is found, else `false`.</span>
 <span class="s5">*/</span>
<span class="s0">function </span><span class="s1">hasUnicode(string) {</span>
  <span class="s0">return </span><span class="s1">reHasUnicode.test(string)</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s5">/**</span>
 <span class="s5">* Checks if `string` contains a word composed of Unicode symbols.</span>
 <span class="s5">*</span>
 <span class="s5">* </span><span class="s6">@private</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string} string The string to inspect.</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{boolean} Returns `true` if a word is found, else `false`.</span>
 <span class="s5">*/</span>
<span class="s0">function </span><span class="s1">hasUnicodeWord(string) {</span>
  <span class="s0">return </span><span class="s1">reHasUnicodeWord.test(string)</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s5">/**</span>
 <span class="s5">* Converts `string` to an array.</span>
 <span class="s5">*</span>
 <span class="s5">* </span><span class="s6">@private</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string} string The string to convert.</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{Array} Returns the converted array.</span>
 <span class="s5">*/</span>
<span class="s0">function </span><span class="s1">stringToArray(string) {</span>
  <span class="s0">return </span><span class="s1">hasUnicode(string)</span>
    <span class="s1">? unicodeToArray(string)</span>
    <span class="s1">: asciiToArray(string)</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s5">/**</span>
 <span class="s5">* Converts a Unicode `string` to an array.</span>
 <span class="s5">*</span>
 <span class="s5">* </span><span class="s6">@private</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string} string The string to convert.</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{Array} Returns the converted array.</span>
 <span class="s5">*/</span>
<span class="s0">function </span><span class="s1">unicodeToArray(string) {</span>
  <span class="s0">return </span><span class="s1">string.match(reUnicode) || []</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s5">/**</span>
 <span class="s5">* Splits a Unicode `string` into an array of its words.</span>
 <span class="s5">*</span>
 <span class="s5">* </span><span class="s6">@private</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string} The string to inspect.</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{Array} Returns the words of `string`.</span>
 <span class="s5">*/</span>
<span class="s0">function </span><span class="s1">unicodeWords(string) {</span>
  <span class="s0">return </span><span class="s1">string.match(reUnicodeWord) || []</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s5">/** Used for built-in method references. */</span>
<span class="s0">var </span><span class="s1">objectProto = Object.prototype</span><span class="s0">;</span>

<span class="s5">/**</span>
 <span class="s5">* Used to resolve the</span>
 <span class="s5">* [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)</span>
 <span class="s5">* of values.</span>
 <span class="s5">*/</span>
<span class="s0">var </span><span class="s1">objectToString = objectProto.toString</span><span class="s0">;</span>

<span class="s5">/** Built-in value references. */</span>
<span class="s0">var </span><span class="s1">Symbol$1 = root$2.Symbol</span><span class="s0">;</span>

<span class="s5">/** Used to convert symbols to primitives and strings. */</span>
<span class="s0">var </span><span class="s1">symbolProto = Symbol$1 ? Symbol$1.prototype : undefined</span><span class="s0">,</span>
    <span class="s1">symbolToString = symbolProto ? symbolProto.toString : undefined</span><span class="s0">;</span>

<span class="s5">/**</span>
 <span class="s5">* The base implementation of `_.slice` without an iteratee call guard.</span>
 <span class="s5">*</span>
 <span class="s5">* </span><span class="s6">@private</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Array} array The array to slice.</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{number} [start=0] The start position.</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{number} [end=array.length] The end position.</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{Array} Returns the slice of `array`.</span>
 <span class="s5">*/</span>
<span class="s0">function </span><span class="s1">baseSlice(array</span><span class="s0">, </span><span class="s1">start</span><span class="s0">, </span><span class="s1">end) {</span>
  <span class="s0">var </span><span class="s1">index = -</span><span class="s3">1</span><span class="s0">,</span>
      <span class="s1">length = array.length</span><span class="s0">;</span>

  <span class="s0">if </span><span class="s1">(start &lt; </span><span class="s3">0</span><span class="s1">) {</span>
    <span class="s1">start = -start &gt; length ? </span><span class="s3">0 </span><span class="s1">: (length + start)</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s1">end = end &gt; length ? length : end</span><span class="s0">;</span>
  <span class="s0">if </span><span class="s1">(end &lt; </span><span class="s3">0</span><span class="s1">) {</span>
    <span class="s1">end += length</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s1">length = start &gt; end ? </span><span class="s3">0 </span><span class="s1">: ((end - start) &gt;&gt;&gt; </span><span class="s3">0</span><span class="s1">)</span><span class="s0">;</span>
  <span class="s1">start &gt;&gt;&gt;= </span><span class="s3">0</span><span class="s0">;</span>

  <span class="s0">var </span><span class="s1">result = Array(length)</span><span class="s0">;</span>
  <span class="s0">while </span><span class="s1">(++index &lt; length) {</span>
    <span class="s1">result[index] = array[index + start]</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">return </span><span class="s1">result</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s5">/**</span>
 <span class="s5">* The base implementation of `_.toString` which doesn't convert nullish</span>
 <span class="s5">* values to empty strings.</span>
 <span class="s5">*</span>
 <span class="s5">* </span><span class="s6">@private</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{*} value The value to process.</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{string} Returns the string.</span>
 <span class="s5">*/</span>
<span class="s0">function </span><span class="s1">baseToString(value) {</span>
  <span class="s4">// Exit early for strings to avoid a performance hit in some environments.</span>
  <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">value == </span><span class="s2">'string'</span><span class="s1">) {</span>
    <span class="s0">return </span><span class="s1">value</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">if </span><span class="s1">(isSymbol(value)) {</span>
    <span class="s0">return </span><span class="s1">symbolToString ? symbolToString.call(value) : </span><span class="s2">''</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">var </span><span class="s1">result = (value + </span><span class="s2">''</span><span class="s1">)</span><span class="s0">;</span>
  <span class="s0">return </span><span class="s1">(result == </span><span class="s2">'0' </span><span class="s1">&amp;&amp; (</span><span class="s3">1 </span><span class="s1">/ value) == -INFINITY) ? </span><span class="s2">'-0' </span><span class="s1">: result</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s5">/**</span>
 <span class="s5">* Casts `array` to a slice if it's needed.</span>
 <span class="s5">*</span>
 <span class="s5">* </span><span class="s6">@private</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Array} array The array to inspect.</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{number} start The start position.</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{number} [end=array.length] The end position.</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{Array} Returns the cast slice.</span>
 <span class="s5">*/</span>
<span class="s0">function </span><span class="s1">castSlice(array</span><span class="s0">, </span><span class="s1">start</span><span class="s0">, </span><span class="s1">end) {</span>
  <span class="s0">var </span><span class="s1">length = array.length</span><span class="s0">;</span>
  <span class="s1">end = end === undefined ? length : end</span><span class="s0">;</span>
  <span class="s0">return </span><span class="s1">(!start &amp;&amp; end &gt;= length) ? array : baseSlice(array</span><span class="s0">, </span><span class="s1">start</span><span class="s0">, </span><span class="s1">end)</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s5">/**</span>
 <span class="s5">* Creates a function like `_.lowerFirst`.</span>
 <span class="s5">*</span>
 <span class="s5">* </span><span class="s6">@private</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string} methodName The name of the `String` case method to use.</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{Function} Returns the new case function.</span>
 <span class="s5">*/</span>
<span class="s0">function </span><span class="s1">createCaseFirst(methodName) {</span>
  <span class="s0">return function</span><span class="s1">(string) {</span>
    <span class="s1">string = toString(string)</span><span class="s0">;</span>

    <span class="s0">var </span><span class="s1">strSymbols = hasUnicode(string)</span>
      <span class="s1">? stringToArray(string)</span>
      <span class="s1">: undefined</span><span class="s0">;</span>

    <span class="s0">var </span><span class="s1">chr = strSymbols</span>
      <span class="s1">? strSymbols[</span><span class="s3">0</span><span class="s1">]</span>
      <span class="s1">: string.charAt(</span><span class="s3">0</span><span class="s1">)</span><span class="s0">;</span>

    <span class="s0">var </span><span class="s1">trailing = strSymbols</span>
      <span class="s1">? castSlice(strSymbols</span><span class="s0">, </span><span class="s3">1</span><span class="s1">).join(</span><span class="s2">''</span><span class="s1">)</span>
      <span class="s1">: string.slice(</span><span class="s3">1</span><span class="s1">)</span><span class="s0">;</span>

    <span class="s0">return </span><span class="s1">chr[methodName]() + trailing</span><span class="s0">;</span>
  <span class="s1">}</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s5">/**</span>
 <span class="s5">* Creates a function like `_.camelCase`.</span>
 <span class="s5">*</span>
 <span class="s5">* </span><span class="s6">@private</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Function} callback The function to combine each word.</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{Function} Returns the new compounder function.</span>
 <span class="s5">*/</span>
<span class="s0">function </span><span class="s1">createCompounder(callback) {</span>
  <span class="s0">return function</span><span class="s1">(string) {</span>
    <span class="s0">return </span><span class="s1">arrayReduce(words(deburr(string).replace(reApos</span><span class="s0">, </span><span class="s2">''</span><span class="s1">))</span><span class="s0">, </span><span class="s1">callback</span><span class="s0">, </span><span class="s2">''</span><span class="s1">)</span><span class="s0">;</span>
  <span class="s1">}</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s5">/**</span>
 <span class="s5">* Checks if `value` is object-like. A value is object-like if it's not `null`</span>
 <span class="s5">* and has a `typeof` result of &quot;object&quot;.</span>
 <span class="s5">*</span>
 <span class="s5">* </span><span class="s6">@static</span>
 <span class="s5">* </span><span class="s6">@memberOf </span><span class="s5">_</span>
 <span class="s5">* </span><span class="s6">@since </span><span class="s5">4.0.0</span>
 <span class="s5">* </span><span class="s6">@category </span><span class="s5">Lang</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{*} value The value to check.</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{boolean} Returns `true` if `value` is object-like, else `false`.</span>
 <span class="s5">* </span><span class="s6">@example</span>
 <span class="s5">*</span>
 <span class="s5">* _.isObjectLike({});</span>
 <span class="s5">* // =&gt; true</span>
 <span class="s5">*</span>
 <span class="s5">* _.isObjectLike([1, 2, 3]);</span>
 <span class="s5">* // =&gt; true</span>
 <span class="s5">*</span>
 <span class="s5">* _.isObjectLike(_.noop);</span>
 <span class="s5">* // =&gt; false</span>
 <span class="s5">*</span>
 <span class="s5">* _.isObjectLike(null);</span>
 <span class="s5">* // =&gt; false</span>
 <span class="s5">*/</span>
<span class="s0">function </span><span class="s1">isObjectLike(value) {</span>
  <span class="s0">return </span><span class="s1">!!value &amp;&amp; </span><span class="s0">typeof </span><span class="s1">value == </span><span class="s2">'object'</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s5">/**</span>
 <span class="s5">* Checks if `value` is classified as a `Symbol` primitive or object.</span>
 <span class="s5">*</span>
 <span class="s5">* </span><span class="s6">@static</span>
 <span class="s5">* </span><span class="s6">@memberOf </span><span class="s5">_</span>
 <span class="s5">* </span><span class="s6">@since </span><span class="s5">4.0.0</span>
 <span class="s5">* </span><span class="s6">@category </span><span class="s5">Lang</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{*} value The value to check.</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{boolean} Returns `true` if `value` is a symbol, else `false`.</span>
 <span class="s5">* </span><span class="s6">@example</span>
 <span class="s5">*</span>
 <span class="s5">* _.isSymbol(Symbol.iterator);</span>
 <span class="s5">* // =&gt; true</span>
 <span class="s5">*</span>
 <span class="s5">* _.isSymbol('abc');</span>
 <span class="s5">* // =&gt; false</span>
 <span class="s5">*/</span>
<span class="s0">function </span><span class="s1">isSymbol(value) {</span>
  <span class="s0">return typeof </span><span class="s1">value == </span><span class="s2">'symbol' </span><span class="s1">||</span>
    <span class="s1">(isObjectLike(value) &amp;&amp; objectToString.call(value) == symbolTag)</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s5">/**</span>
 <span class="s5">* Converts `value` to a string. An empty string is returned for `null`</span>
 <span class="s5">* and `undefined` values. The sign of `-0` is preserved.</span>
 <span class="s5">*</span>
 <span class="s5">* </span><span class="s6">@static</span>
 <span class="s5">* </span><span class="s6">@memberOf </span><span class="s5">_</span>
 <span class="s5">* </span><span class="s6">@since </span><span class="s5">4.0.0</span>
 <span class="s5">* </span><span class="s6">@category </span><span class="s5">Lang</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{*} value The value to process.</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{string} Returns the string.</span>
 <span class="s5">* </span><span class="s6">@example</span>
 <span class="s5">*</span>
 <span class="s5">* _.toString(null);</span>
 <span class="s5">* // =&gt; ''</span>
 <span class="s5">*</span>
 <span class="s5">* _.toString(-0);</span>
 <span class="s5">* // =&gt; '-0'</span>
 <span class="s5">*</span>
 <span class="s5">* _.toString([1, 2, 3]);</span>
 <span class="s5">* // =&gt; '1,2,3'</span>
 <span class="s5">*/</span>
<span class="s0">function </span><span class="s1">toString(value) {</span>
  <span class="s0">return </span><span class="s1">value == </span><span class="s0">null </span><span class="s1">? </span><span class="s2">'' </span><span class="s1">: baseToString(value)</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s5">/**</span>
 <span class="s5">* Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).</span>
 <span class="s5">*</span>
 <span class="s5">* </span><span class="s6">@static</span>
 <span class="s5">* </span><span class="s6">@memberOf </span><span class="s5">_</span>
 <span class="s5">* </span><span class="s6">@since </span><span class="s5">3.0.0</span>
 <span class="s5">* </span><span class="s6">@category </span><span class="s5">String</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string} [string=''] The string to convert.</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{string} Returns the camel cased string.</span>
 <span class="s5">* </span><span class="s6">@example</span>
 <span class="s5">*</span>
 <span class="s5">* _.camelCase('Foo Bar');</span>
 <span class="s5">* // =&gt; 'fooBar'</span>
 <span class="s5">*</span>
 <span class="s5">* _.camelCase('--foo-bar--');</span>
 <span class="s5">* // =&gt; 'fooBar'</span>
 <span class="s5">*</span>
 <span class="s5">* _.camelCase('__FOO_BAR__');</span>
 <span class="s5">* // =&gt; 'fooBar'</span>
 <span class="s5">*/</span>
<span class="s0">var </span><span class="s1">camelCase = createCompounder(</span><span class="s0">function</span><span class="s1">(result</span><span class="s0">, </span><span class="s1">word</span><span class="s0">, </span><span class="s1">index) {</span>
  <span class="s1">word = word.toLowerCase()</span><span class="s0">;</span>
  <span class="s0">return </span><span class="s1">result + (index ? capitalize(word) : word)</span><span class="s0">;</span>
<span class="s1">})</span><span class="s0">;</span>

<span class="s5">/**</span>
 <span class="s5">* Converts the first character of `string` to upper case and the remaining</span>
 <span class="s5">* to lower case.</span>
 <span class="s5">*</span>
 <span class="s5">* </span><span class="s6">@static</span>
 <span class="s5">* </span><span class="s6">@memberOf </span><span class="s5">_</span>
 <span class="s5">* </span><span class="s6">@since </span><span class="s5">3.0.0</span>
 <span class="s5">* </span><span class="s6">@category </span><span class="s5">String</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string} [string=''] The string to capitalize.</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{string} Returns the capitalized string.</span>
 <span class="s5">* </span><span class="s6">@example</span>
 <span class="s5">*</span>
 <span class="s5">* _.capitalize('FRED');</span>
 <span class="s5">* // =&gt; 'Fred'</span>
 <span class="s5">*/</span>
<span class="s0">function </span><span class="s1">capitalize(string) {</span>
  <span class="s0">return </span><span class="s1">upperFirst(toString(string).toLowerCase())</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s5">/**</span>
 <span class="s5">* Deburrs `string` by converting</span>
 <span class="s5">* [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)</span>
 <span class="s5">* and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)</span>
 <span class="s5">* letters to basic Latin letters and removing</span>
 <span class="s5">* [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).</span>
 <span class="s5">*</span>
 <span class="s5">* </span><span class="s6">@static</span>
 <span class="s5">* </span><span class="s6">@memberOf </span><span class="s5">_</span>
 <span class="s5">* </span><span class="s6">@since </span><span class="s5">3.0.0</span>
 <span class="s5">* </span><span class="s6">@category </span><span class="s5">String</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string} [string=''] The string to deburr.</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{string} Returns the deburred string.</span>
 <span class="s5">* </span><span class="s6">@example</span>
 <span class="s5">*</span>
 <span class="s5">* _.deburr('dj vu');</span>
 <span class="s5">* // =&gt; 'deja vu'</span>
 <span class="s5">*/</span>
<span class="s0">function </span><span class="s1">deburr(string) {</span>
  <span class="s1">string = toString(string)</span><span class="s0">;</span>
  <span class="s0">return </span><span class="s1">string &amp;&amp; string.replace(reLatin</span><span class="s0">, </span><span class="s1">deburrLetter).replace(reComboMark</span><span class="s0">, </span><span class="s2">''</span><span class="s1">)</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s5">/**</span>
 <span class="s5">* Converts the first character of `string` to upper case.</span>
 <span class="s5">*</span>
 <span class="s5">* </span><span class="s6">@static</span>
 <span class="s5">* </span><span class="s6">@memberOf </span><span class="s5">_</span>
 <span class="s5">* </span><span class="s6">@since </span><span class="s5">4.0.0</span>
 <span class="s5">* </span><span class="s6">@category </span><span class="s5">String</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string} [string=''] The string to convert.</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{string} Returns the converted string.</span>
 <span class="s5">* </span><span class="s6">@example</span>
 <span class="s5">*</span>
 <span class="s5">* _.upperFirst('fred');</span>
 <span class="s5">* // =&gt; 'Fred'</span>
 <span class="s5">*</span>
 <span class="s5">* _.upperFirst('FRED');</span>
 <span class="s5">* // =&gt; 'FRED'</span>
 <span class="s5">*/</span>
<span class="s0">var </span><span class="s1">upperFirst = createCaseFirst(</span><span class="s2">'toUpperCase'</span><span class="s1">)</span><span class="s0">;</span>

<span class="s5">/**</span>
 <span class="s5">* Splits `string` into an array of its words.</span>
 <span class="s5">*</span>
 <span class="s5">* </span><span class="s6">@static</span>
 <span class="s5">* </span><span class="s6">@memberOf </span><span class="s5">_</span>
 <span class="s5">* </span><span class="s6">@since </span><span class="s5">3.0.0</span>
 <span class="s5">* </span><span class="s6">@category </span><span class="s5">String</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string} [string=''] The string to inspect.</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{RegExp|string} [pattern] The pattern to match words.</span>
 <span class="s5">* </span><span class="s6">@param- </span><span class="s5">{Object} [guard] Enables use as an iteratee for methods like `_.map`.</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{Array} Returns the words of `string`.</span>
 <span class="s5">* </span><span class="s6">@example</span>
 <span class="s5">*</span>
 <span class="s5">* _.words('fred, barney, &amp; pebbles');</span>
 <span class="s5">* // =&gt; ['fred', 'barney', 'pebbles']</span>
 <span class="s5">*</span>
 <span class="s5">* _.words('fred, barney, &amp; pebbles', /[^, ]+/g);</span>
 <span class="s5">* // =&gt; ['fred', 'barney', '&amp;', 'pebbles']</span>
 <span class="s5">*/</span>
<span class="s0">function </span><span class="s1">words(string</span><span class="s0">, </span><span class="s1">pattern</span><span class="s0">, </span><span class="s1">guard) {</span>
  <span class="s1">string = toString(string)</span><span class="s0">;</span>
  <span class="s1">pattern = guard ? undefined : pattern</span><span class="s0">;</span>

  <span class="s0">if </span><span class="s1">(pattern === undefined) {</span>
    <span class="s0">return </span><span class="s1">hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string)</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">return </span><span class="s1">string.match(pattern) || []</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">var </span><span class="s1">lodash_camelcase = camelCase</span><span class="s0">;</span>

<span class="s1">Object.defineProperty(localsConvention</span><span class="s0">, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, </span><span class="s1">{</span>
  <span class="s1">value: </span><span class="s0">true</span>
<span class="s1">})</span><span class="s0">;</span>
<span class="s1">localsConvention.makeLocalsConventionReducer = makeLocalsConventionReducer</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">_lodash = _interopRequireDefault$5(lodash_camelcase)</span><span class="s0">;</span>

<span class="s0">function </span><span class="s1">_interopRequireDefault$5(obj) { </span><span class="s0">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : { </span><span class="s0">default</span><span class="s1">: obj }</span><span class="s0">; </span><span class="s1">}</span>

<span class="s0">function </span><span class="s1">dashesCamelCase(string) {</span>
  <span class="s0">return </span><span class="s1">string.replace(</span><span class="s3">/-+(\w)/g</span><span class="s0">, </span><span class="s1">(_</span><span class="s0">, </span><span class="s1">firstLetter) =&gt; firstLetter.toUpperCase())</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">makeLocalsConventionReducer(localsConvention</span><span class="s0">, </span><span class="s1">inputFile) {</span>
  <span class="s0">const </span><span class="s1">isFunc = </span><span class="s0">typeof </span><span class="s1">localsConvention === </span><span class="s2">&quot;function&quot;</span><span class="s0">;</span>
  <span class="s0">return </span><span class="s1">(tokens</span><span class="s0">, </span><span class="s1">[className</span><span class="s0">, </span><span class="s1">value]) =&gt; {</span>
    <span class="s0">if </span><span class="s1">(isFunc) {</span>
      <span class="s0">const </span><span class="s1">convention = localsConvention(className</span><span class="s0">, </span><span class="s1">value</span><span class="s0">, </span><span class="s1">inputFile)</span><span class="s0">;</span>
      <span class="s1">tokens[convention] = value</span><span class="s0">;</span>
      <span class="s0">return </span><span class="s1">tokens</span><span class="s0">;</span>
    <span class="s1">}</span>

    <span class="s0">switch </span><span class="s1">(localsConvention) {</span>
      <span class="s0">case </span><span class="s2">&quot;camelCase&quot;</span><span class="s1">:</span>
        <span class="s1">tokens[className] = value</span><span class="s0">;</span>
        <span class="s1">tokens[(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">_lodash.default)(className)] = value</span><span class="s0">;</span>
        <span class="s0">break;</span>

      <span class="s0">case </span><span class="s2">&quot;camelCaseOnly&quot;</span><span class="s1">:</span>
        <span class="s1">tokens[(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">_lodash.default)(className)] = value</span><span class="s0">;</span>
        <span class="s0">break;</span>

      <span class="s0">case </span><span class="s2">&quot;dashes&quot;</span><span class="s1">:</span>
        <span class="s1">tokens[className] = value</span><span class="s0">;</span>
        <span class="s1">tokens[dashesCamelCase(className)] = value</span><span class="s0">;</span>
        <span class="s0">break;</span>

      <span class="s0">case </span><span class="s2">&quot;dashesOnly&quot;</span><span class="s1">:</span>
        <span class="s1">tokens[dashesCamelCase(className)] = value</span><span class="s0">;</span>
        <span class="s0">break;</span>
    <span class="s1">}</span>

    <span class="s0">return </span><span class="s1">tokens</span><span class="s0">;</span>
  <span class="s1">}</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">var </span><span class="s1">FileSystemLoader$1 = {}</span><span class="s0">;</span>

<span class="s1">Object.defineProperty(FileSystemLoader$1</span><span class="s0">, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, </span><span class="s1">{</span>
  <span class="s1">value: </span><span class="s0">true</span>
<span class="s1">})</span><span class="s0">;</span>
<span class="s1">FileSystemLoader$1.default = </span><span class="s0">void </span><span class="s3">0</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">_postcss$1 = _interopRequireDefault$4(require$$0)</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">_path = _interopRequireDefault$4(require$$0$1)</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">_Parser$1 = _interopRequireDefault$4(Parser$1)</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">_fs$1 = fs</span><span class="s0">;</span>

<span class="s0">function </span><span class="s1">_interopRequireDefault$4(obj) { </span><span class="s0">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : { </span><span class="s0">default</span><span class="s1">: obj }</span><span class="s0">; </span><span class="s1">}</span>

<span class="s4">// Initially copied from https://github.com/css-modules/css-modules-loader-core</span>
<span class="s0">class </span><span class="s1">Core {</span>
  <span class="s1">constructor(plugins) {</span>
    <span class="s0">this</span><span class="s1">.plugins = plugins || Core.defaultPlugins</span><span class="s0">;</span>
  <span class="s1">}</span>

  <span class="s1">async load(sourceString</span><span class="s0">, </span><span class="s1">sourcePath</span><span class="s0">, </span><span class="s1">trace</span><span class="s0">, </span><span class="s1">pathFetcher) {</span>
    <span class="s0">const </span><span class="s1">parser = </span><span class="s0">new </span><span class="s1">_Parser$1.default(pathFetcher</span><span class="s0">, </span><span class="s1">trace)</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">plugins = </span><span class="s0">this</span><span class="s1">.plugins.concat([parser.plugin()])</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">result = </span><span class="s0">await </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">_postcss$1.default)(plugins).process(sourceString</span><span class="s0">, </span><span class="s1">{</span>
      <span class="s1">from: sourcePath</span>
    <span class="s1">})</span><span class="s0">;</span>
    <span class="s0">return </span><span class="s1">{</span>
      <span class="s1">injectableSource: result.css</span><span class="s0">,</span>
      <span class="s1">exportTokens: parser.exportTokens</span>
    <span class="s1">}</span><span class="s0">;</span>
  <span class="s1">}</span>

<span class="s1">} </span><span class="s4">// Sorts dependencies in the following way:</span>
<span class="s4">// AAA comes before AA and A</span>
<span class="s4">// AB comes after AA and before A</span>
<span class="s4">// All Bs come after all As</span>
<span class="s4">// This ensures that the files are always returned in the following order:</span>
<span class="s4">// - In the order they were required, except</span>
<span class="s4">// - After all their dependencies</span>


<span class="s0">const </span><span class="s1">traceKeySorter = (a</span><span class="s0">, </span><span class="s1">b) =&gt; {</span>
  <span class="s0">if </span><span class="s1">(a.length &lt; b.length) {</span>
    <span class="s0">return </span><span class="s1">a &lt; b.substring(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">a.length) ? -</span><span class="s3">1 </span><span class="s1">: </span><span class="s3">1</span><span class="s0">;</span>
  <span class="s1">}</span>

  <span class="s0">if </span><span class="s1">(a.length &gt; b.length) {</span>
    <span class="s0">return </span><span class="s1">a.substring(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">b.length) &lt;= b ? -</span><span class="s3">1 </span><span class="s1">: </span><span class="s3">1</span><span class="s0">;</span>
  <span class="s1">}</span>

  <span class="s0">return </span><span class="s1">a &lt; b ? -</span><span class="s3">1 </span><span class="s1">: </span><span class="s3">1</span><span class="s0">;</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s0">class </span><span class="s1">FileSystemLoader {</span>
  <span class="s1">constructor(root</span><span class="s0">, </span><span class="s1">plugins</span><span class="s0">, </span><span class="s1">fileResolve) {</span>
    <span class="s0">if </span><span class="s1">(root === </span><span class="s2">&quot;/&quot; </span><span class="s1">&amp;&amp; process.platform === </span><span class="s2">&quot;win32&quot;</span><span class="s1">) {</span>
      <span class="s0">const </span><span class="s1">cwdDrive = process.cwd().slice(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span><span class="s0">;</span>

      <span class="s0">if </span><span class="s1">(!</span><span class="s3">/^[A-Za-z]:\\$/</span><span class="s1">.test(cwdDrive)) {</span>
        <span class="s0">throw new </span><span class="s1">Error(</span><span class="s2">`Failed to obtain root from &quot;</span><span class="s1">${process.cwd()}</span><span class="s2">&quot;.`</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s1">}</span>

      <span class="s1">root = cwdDrive</span><span class="s0">;</span>
    <span class="s1">}</span>

    <span class="s0">this</span><span class="s1">.root = root</span><span class="s0">;</span>
    <span class="s0">this</span><span class="s1">.fileResolve = fileResolve</span><span class="s0">;</span>
    <span class="s0">this</span><span class="s1">.sources = {}</span><span class="s0">;</span>
    <span class="s0">this</span><span class="s1">.traces = {}</span><span class="s0">;</span>
    <span class="s0">this</span><span class="s1">.importNr = </span><span class="s3">0</span><span class="s0">;</span>
    <span class="s0">this</span><span class="s1">.core = </span><span class="s0">new </span><span class="s1">Core(plugins)</span><span class="s0">;</span>
    <span class="s0">this</span><span class="s1">.tokensByFile = {}</span><span class="s0">;</span>
    <span class="s0">this</span><span class="s1">.fs = (</span><span class="s3">0</span><span class="s0">, </span><span class="s1">_fs$1.getFileSystem)()</span><span class="s0">;</span>
  <span class="s1">}</span>

  <span class="s1">async fetch(_newPath</span><span class="s0">, </span><span class="s1">relativeTo</span><span class="s0">, </span><span class="s1">_trace) {</span>
    <span class="s0">const </span><span class="s1">newPath = _newPath.replace(</span><span class="s3">/^[&quot;']|[&quot;']$/g</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s1">)</span><span class="s0">;</span>

    <span class="s0">const </span><span class="s1">trace = _trace || String.fromCharCode(</span><span class="s0">this</span><span class="s1">.importNr++)</span><span class="s0">;</span>

    <span class="s0">const </span><span class="s1">useFileResolve = </span><span class="s0">typeof this</span><span class="s1">.fileResolve === </span><span class="s2">&quot;function&quot;</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">fileResolvedPath = useFileResolve ? </span><span class="s0">await this</span><span class="s1">.fileResolve(newPath</span><span class="s0">, </span><span class="s1">relativeTo) : </span><span class="s0">await </span><span class="s1">Promise.resolve()</span><span class="s0">;</span>

    <span class="s0">if </span><span class="s1">(fileResolvedPath &amp;&amp; !_path.default.isAbsolute(fileResolvedPath)) {</span>
      <span class="s0">throw new </span><span class="s1">Error(</span><span class="s2">'The returned path from the &quot;fileResolve&quot; option must be absolute.'</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s1">}</span>

    <span class="s0">const </span><span class="s1">relativeDir = _path.default.dirname(relativeTo)</span><span class="s0">;</span>

    <span class="s0">const </span><span class="s1">rootRelativePath = fileResolvedPath || _path.default.resolve(relativeDir</span><span class="s0">, </span><span class="s1">newPath)</span><span class="s0">;</span>

    <span class="s0">let </span><span class="s1">fileRelativePath = fileResolvedPath || _path.default.resolve(_path.default.resolve(</span><span class="s0">this</span><span class="s1">.root</span><span class="s0">, </span><span class="s1">relativeDir)</span><span class="s0">, </span><span class="s1">newPath)</span><span class="s0">; </span><span class="s4">// if the path is not relative or absolute, try to resolve it in node_modules</span>


    <span class="s0">if </span><span class="s1">(!useFileResolve &amp;&amp; newPath[</span><span class="s3">0</span><span class="s1">] !== </span><span class="s2">&quot;.&quot; </span><span class="s1">&amp;&amp; !_path.default.isAbsolute(newPath)) {</span>
      <span class="s0">try </span><span class="s1">{</span>
        <span class="s1">fileRelativePath = require.resolve(newPath)</span><span class="s0">;</span>
      <span class="s1">} </span><span class="s0">catch </span><span class="s1">(e) {</span><span class="s4">// noop</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s0">const </span><span class="s1">tokens = </span><span class="s0">this</span><span class="s1">.tokensByFile[fileRelativePath]</span><span class="s0">;</span>
    <span class="s0">if </span><span class="s1">(tokens) </span><span class="s0">return </span><span class="s1">tokens</span><span class="s0">;</span>
    <span class="s0">return new </span><span class="s1">Promise((resolve</span><span class="s0">, </span><span class="s1">reject) =&gt; {</span>
      <span class="s0">this</span><span class="s1">.fs.readFile(fileRelativePath</span><span class="s0">, </span><span class="s2">&quot;utf-8&quot;</span><span class="s0">, </span><span class="s1">async (err</span><span class="s0">, </span><span class="s1">source) =&gt; {</span>
        <span class="s0">if </span><span class="s1">(err) reject(err)</span><span class="s0">;</span>
        <span class="s0">const </span><span class="s1">{</span>
          <span class="s1">injectableSource</span><span class="s0">,</span>
          <span class="s1">exportTokens</span>
        <span class="s1">} = </span><span class="s0">await this</span><span class="s1">.core.load(source</span><span class="s0">, </span><span class="s1">rootRelativePath</span><span class="s0">, </span><span class="s1">trace</span><span class="s0">, this</span><span class="s1">.fetch.bind(</span><span class="s0">this</span><span class="s1">))</span><span class="s0">;</span>
        <span class="s0">this</span><span class="s1">.sources[fileRelativePath] = injectableSource</span><span class="s0">;</span>
        <span class="s0">this</span><span class="s1">.traces[trace] = fileRelativePath</span><span class="s0">;</span>
        <span class="s0">this</span><span class="s1">.tokensByFile[fileRelativePath] = exportTokens</span><span class="s0">;</span>
        <span class="s1">resolve(exportTokens)</span><span class="s0">;</span>
      <span class="s1">})</span><span class="s0">;</span>
    <span class="s1">})</span><span class="s0">;</span>
  <span class="s1">}</span>

  <span class="s1">get finalSource() {</span>
    <span class="s0">const </span><span class="s1">traces = </span><span class="s0">this</span><span class="s1">.traces</span><span class="s0">;</span>
    <span class="s0">const </span><span class="s1">sources = </span><span class="s0">this</span><span class="s1">.sources</span><span class="s0">;</span>
    <span class="s0">let </span><span class="s1">written = </span><span class="s0">new </span><span class="s1">Set()</span><span class="s0">;</span>
    <span class="s0">return </span><span class="s1">Object.keys(traces).sort(traceKeySorter).map(key =&gt; {</span>
      <span class="s0">const </span><span class="s1">filename = traces[key]</span><span class="s0">;</span>

      <span class="s0">if </span><span class="s1">(written.has(filename)) {</span>
        <span class="s0">return null;</span>
      <span class="s1">}</span>

      <span class="s1">written.add(filename)</span><span class="s0">;</span>
      <span class="s0">return </span><span class="s1">sources[filename]</span><span class="s0">;</span>
    <span class="s1">}).join(</span><span class="s2">&quot;&quot;</span><span class="s1">)</span><span class="s0">;</span>
  <span class="s1">}</span>

<span class="s1">}</span>

<span class="s1">FileSystemLoader$1.default = FileSystemLoader</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">scoping = {}</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">srcExports$2 = {}</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">src$3 = {</span>
  <span class="s1">get exports(){ </span><span class="s0">return </span><span class="s1">srcExports$2</span><span class="s0">; </span><span class="s1">}</span><span class="s0">,</span>
  <span class="s1">set exports(v){ srcExports$2 = v</span><span class="s0">; </span><span class="s1">}</span><span class="s0">,</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s0">const </span><span class="s1">PERMANENT_MARKER = </span><span class="s3">2</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">TEMPORARY_MARKER = </span><span class="s3">1</span><span class="s0">;</span>

<span class="s0">function </span><span class="s1">createError(node</span><span class="s0">, </span><span class="s1">graph) {</span>
  <span class="s0">const </span><span class="s1">er = </span><span class="s0">new </span><span class="s1">Error(</span><span class="s2">&quot;Nondeterministic import's order&quot;</span><span class="s1">)</span><span class="s0">;</span>

  <span class="s0">const </span><span class="s1">related = graph[node]</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">relatedNode = related.find(</span>
    <span class="s1">(relatedNode) =&gt; graph[relatedNode].indexOf(node) &gt; -</span><span class="s3">1</span>
  <span class="s1">)</span><span class="s0">;</span>

  <span class="s1">er.nodes = [node</span><span class="s0">, </span><span class="s1">relatedNode]</span><span class="s0">;</span>

  <span class="s0">return </span><span class="s1">er</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">walkGraph(node</span><span class="s0">, </span><span class="s1">graph</span><span class="s0">, </span><span class="s1">state</span><span class="s0">, </span><span class="s1">result</span><span class="s0">, </span><span class="s1">strict) {</span>
  <span class="s0">if </span><span class="s1">(state[node] === PERMANENT_MARKER) {</span>
    <span class="s0">return;</span>
  <span class="s1">}</span>

  <span class="s0">if </span><span class="s1">(state[node] === TEMPORARY_MARKER) {</span>
    <span class="s0">if </span><span class="s1">(strict) {</span>
      <span class="s0">return </span><span class="s1">createError(node</span><span class="s0">, </span><span class="s1">graph)</span><span class="s0">;</span>
    <span class="s1">}</span>

    <span class="s0">return;</span>
  <span class="s1">}</span>

  <span class="s1">state[node] = TEMPORARY_MARKER</span><span class="s0">;</span>

  <span class="s0">const </span><span class="s1">children = graph[node]</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">length = children.length</span><span class="s0">;</span>

  <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s3">0</span><span class="s0">; </span><span class="s1">i &lt; length</span><span class="s0">; </span><span class="s1">++i) {</span>
    <span class="s0">const </span><span class="s1">error = walkGraph(children[i]</span><span class="s0">, </span><span class="s1">graph</span><span class="s0">, </span><span class="s1">state</span><span class="s0">, </span><span class="s1">result</span><span class="s0">, </span><span class="s1">strict)</span><span class="s0">;</span>

    <span class="s0">if </span><span class="s1">(error </span><span class="s0">instanceof </span><span class="s1">Error) {</span>
      <span class="s0">return </span><span class="s1">error</span><span class="s0">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">state[node] = PERMANENT_MARKER</span><span class="s0">;</span>

  <span class="s1">result.push(node)</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">topologicalSort$1(graph</span><span class="s0">, </span><span class="s1">strict) {</span>
  <span class="s0">const </span><span class="s1">result = []</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">state = {}</span><span class="s0">;</span>

  <span class="s0">const </span><span class="s1">nodes = Object.keys(graph)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">length = nodes.length</span><span class="s0">;</span>

  <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s3">0</span><span class="s0">; </span><span class="s1">i &lt; length</span><span class="s0">; </span><span class="s1">++i) {</span>
    <span class="s0">const </span><span class="s1">er = walkGraph(nodes[i]</span><span class="s0">, </span><span class="s1">graph</span><span class="s0">, </span><span class="s1">state</span><span class="s0">, </span><span class="s1">result</span><span class="s0">, </span><span class="s1">strict)</span><span class="s0">;</span>

    <span class="s0">if </span><span class="s1">(er </span><span class="s0">instanceof </span><span class="s1">Error) {</span>
      <span class="s0">return </span><span class="s1">er</span><span class="s0">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">return </span><span class="s1">result</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">var </span><span class="s1">topologicalSort_1 = topologicalSort$1</span><span class="s0">;</span>

<span class="s0">const </span><span class="s1">topologicalSort = topologicalSort_1</span><span class="s0">;</span>

<span class="s0">const </span><span class="s1">matchImports$1 = </span><span class="s3">/^(.+?)\s+from\s+(?:&quot;([^&quot;]+)&quot;|'([^']+)'|(global))$/</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">icssImport = </span><span class="s3">/^:import\((?:&quot;([^&quot;]+)&quot;|'([^']+)')\)/</span><span class="s0">;</span>

<span class="s0">const </span><span class="s1">VISITED_MARKER = </span><span class="s3">1</span><span class="s0">;</span>

<span class="s5">/**</span>
 <span class="s5">* :import('G') {}</span>
 <span class="s5">*</span>
 <span class="s5">* Rule</span>
 <span class="s5">*   composes: ... from 'A'</span>
 <span class="s5">*   composes: ... from 'B'</span>

 <span class="s5">* Rule</span>
 <span class="s5">*   composes: ... from 'A'</span>
 <span class="s5">*   composes: ... from 'A'</span>
 <span class="s5">*   composes: ... from 'C'</span>
 <span class="s5">*</span>
 <span class="s5">* Results in:</span>
 <span class="s5">*</span>
 <span class="s5">* graph: {</span>
 <span class="s5">*   G: [],</span>
 <span class="s5">*   A: [],</span>
 <span class="s5">*   B: ['A'],</span>
 <span class="s5">*   C: ['A'],</span>
 <span class="s5">* }</span>
 <span class="s5">*/</span>
<span class="s0">function </span><span class="s1">addImportToGraph(importId</span><span class="s0">, </span><span class="s1">parentId</span><span class="s0">, </span><span class="s1">graph</span><span class="s0">, </span><span class="s1">visited) {</span>
  <span class="s0">const </span><span class="s1">siblingsId = parentId + </span><span class="s2">&quot;_&quot; </span><span class="s1">+ </span><span class="s2">&quot;siblings&quot;</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">visitedId = parentId + </span><span class="s2">&quot;_&quot; </span><span class="s1">+ importId</span><span class="s0">;</span>

  <span class="s0">if </span><span class="s1">(visited[visitedId] !== VISITED_MARKER) {</span>
    <span class="s0">if </span><span class="s1">(!Array.isArray(visited[siblingsId])) {</span>
      <span class="s1">visited[siblingsId] = []</span><span class="s0">;</span>
    <span class="s1">}</span>

    <span class="s0">const </span><span class="s1">siblings = visited[siblingsId]</span><span class="s0">;</span>

    <span class="s0">if </span><span class="s1">(Array.isArray(graph[importId])) {</span>
      <span class="s1">graph[importId] = graph[importId].concat(siblings)</span><span class="s0">;</span>
    <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
      <span class="s1">graph[importId] = siblings.slice()</span><span class="s0">;</span>
    <span class="s1">}</span>

    <span class="s1">visited[visitedId] = VISITED_MARKER</span><span class="s0">;</span>

    <span class="s1">siblings.push(importId)</span><span class="s0">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">src$3.exports = (options = {}) =&gt; {</span>
  <span class="s0">let </span><span class="s1">importIndex = </span><span class="s3">0</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">createImportedName =</span>
    <span class="s0">typeof </span><span class="s1">options.createImportedName !== </span><span class="s2">&quot;function&quot;</span>
      <span class="s1">? (importName </span><span class="s4">/*, path*/</span><span class="s1">) =&gt;</span>
          <span class="s2">`i__imported_</span><span class="s1">${importName.replace(</span><span class="s3">/\W/g</span><span class="s0">, </span><span class="s2">&quot;_&quot;</span><span class="s1">)}</span><span class="s2">_</span><span class="s1">${importIndex++}</span><span class="s2">`</span>
      <span class="s1">: options.createImportedName</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">failOnWrongOrder = options.failOnWrongOrder</span><span class="s0">;</span>

  <span class="s0">return </span><span class="s1">{</span>
    <span class="s1">postcssPlugin: </span><span class="s2">&quot;postcss-modules-extract-imports&quot;</span><span class="s0">,</span>
    <span class="s1">prepare() {</span>
      <span class="s0">const </span><span class="s1">graph = {}</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">visited = {}</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">existingImports = {}</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">importDecls = {}</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">imports = {}</span><span class="s0">;</span>

      <span class="s0">return </span><span class="s1">{</span>
        <span class="s1">Once(root</span><span class="s0">, </span><span class="s1">postcss) {</span>
          <span class="s4">// Check the existing imports order and save refs</span>
          <span class="s1">root.walkRules((rule) =&gt; {</span>
            <span class="s0">const </span><span class="s1">matches = icssImport.exec(rule.selector)</span><span class="s0">;</span>

            <span class="s0">if </span><span class="s1">(matches) {</span>
              <span class="s0">const </span><span class="s1">[</span><span class="s0">, </span><span class="s4">/*match*/ </span><span class="s1">doubleQuotePath</span><span class="s0">, </span><span class="s1">singleQuotePath] = matches</span><span class="s0">;</span>
              <span class="s0">const </span><span class="s1">importPath = doubleQuotePath || singleQuotePath</span><span class="s0">;</span>

              <span class="s1">addImportToGraph(importPath</span><span class="s0">, </span><span class="s2">&quot;root&quot;</span><span class="s0">, </span><span class="s1">graph</span><span class="s0">, </span><span class="s1">visited)</span><span class="s0">;</span>

              <span class="s1">existingImports[importPath] = rule</span><span class="s0">;</span>
            <span class="s1">}</span>
          <span class="s1">})</span><span class="s0">;</span>

          <span class="s1">root.walkDecls(</span><span class="s3">/^composes$/</span><span class="s0">, </span><span class="s1">(declaration) =&gt; {</span>
            <span class="s0">const </span><span class="s1">matches = declaration.value.match(matchImports$1)</span><span class="s0">;</span>

            <span class="s0">if </span><span class="s1">(!matches) {</span>
              <span class="s0">return;</span>
            <span class="s1">}</span>

            <span class="s0">let </span><span class="s1">tmpSymbols</span><span class="s0">;</span>
            <span class="s0">let </span><span class="s1">[</span>
              <span class="s0">,</span>
              <span class="s4">/*match*/ </span><span class="s1">symbols</span><span class="s0">,</span>
              <span class="s1">doubleQuotePath</span><span class="s0">,</span>
              <span class="s1">singleQuotePath</span><span class="s0">,</span>
              <span class="s1">global</span><span class="s0">,</span>
            <span class="s1">] = matches</span><span class="s0">;</span>

            <span class="s0">if </span><span class="s1">(global) {</span>
              <span class="s4">// Composing globals simply means changing these classes to wrap them in global(name)</span>
              <span class="s1">tmpSymbols = symbols.split(</span><span class="s3">/\s+/</span><span class="s1">).map((s) =&gt; </span><span class="s2">`global(</span><span class="s1">${s}</span><span class="s2">)`</span><span class="s1">)</span><span class="s0">;</span>
            <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
              <span class="s0">const </span><span class="s1">importPath = doubleQuotePath || singleQuotePath</span><span class="s0">;</span>

              <span class="s0">let </span><span class="s1">parent = declaration.parent</span><span class="s0">;</span>
              <span class="s0">let </span><span class="s1">parentIndexes = </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>

              <span class="s0">while </span><span class="s1">(parent.type !== </span><span class="s2">&quot;root&quot;</span><span class="s1">) {</span>
                <span class="s1">parentIndexes =</span>
                  <span class="s1">parent.parent.index(parent) + </span><span class="s2">&quot;_&quot; </span><span class="s1">+ parentIndexes</span><span class="s0">;</span>
                <span class="s1">parent = parent.parent</span><span class="s0">;</span>
              <span class="s1">}</span>

              <span class="s0">const </span><span class="s1">{ selector } = declaration.parent</span><span class="s0">;</span>
              <span class="s0">const </span><span class="s1">parentRule = </span><span class="s2">`_</span><span class="s1">${parentIndexes}${selector}</span><span class="s2">`</span><span class="s0">;</span>

              <span class="s1">addImportToGraph(importPath</span><span class="s0">, </span><span class="s1">parentRule</span><span class="s0">, </span><span class="s1">graph</span><span class="s0">, </span><span class="s1">visited)</span><span class="s0">;</span>

              <span class="s1">importDecls[importPath] = declaration</span><span class="s0">;</span>
              <span class="s1">imports[importPath] = imports[importPath] || {}</span><span class="s0">;</span>

              <span class="s1">tmpSymbols = symbols.split(</span><span class="s3">/\s+/</span><span class="s1">).map((s) =&gt; {</span>
                <span class="s0">if </span><span class="s1">(!imports[importPath][s]) {</span>
                  <span class="s1">imports[importPath][s] = createImportedName(s</span><span class="s0">, </span><span class="s1">importPath)</span><span class="s0">;</span>
                <span class="s1">}</span>

                <span class="s0">return </span><span class="s1">imports[importPath][s]</span><span class="s0">;</span>
              <span class="s1">})</span><span class="s0">;</span>
            <span class="s1">}</span>

            <span class="s1">declaration.value = tmpSymbols.join(</span><span class="s2">&quot; &quot;</span><span class="s1">)</span><span class="s0">;</span>
          <span class="s1">})</span><span class="s0">;</span>

          <span class="s0">const </span><span class="s1">importsOrder = topologicalSort(graph</span><span class="s0">, </span><span class="s1">failOnWrongOrder)</span><span class="s0">;</span>

          <span class="s0">if </span><span class="s1">(importsOrder </span><span class="s0">instanceof </span><span class="s1">Error) {</span>
            <span class="s0">const </span><span class="s1">importPath = importsOrder.nodes.find((importPath) =&gt;</span>
              <span class="s4">// eslint-disable-next-line no-prototype-builtins</span>
              <span class="s1">importDecls.hasOwnProperty(importPath)</span>
            <span class="s1">)</span><span class="s0">;</span>
            <span class="s0">const </span><span class="s1">decl = importDecls[importPath]</span><span class="s0">;</span>

            <span class="s0">throw </span><span class="s1">decl.error(</span>
              <span class="s2">&quot;Failed to resolve order of composed modules &quot; </span><span class="s1">+</span>
                <span class="s1">importsOrder.nodes</span>
                  <span class="s1">.map((importPath) =&gt; </span><span class="s2">&quot;`&quot; </span><span class="s1">+ importPath + </span><span class="s2">&quot;`&quot;</span><span class="s1">)</span>
                  <span class="s1">.join(</span><span class="s2">&quot;, &quot;</span><span class="s1">) +</span>
                <span class="s2">&quot;.&quot;</span><span class="s0">,</span>
              <span class="s1">{</span>
                <span class="s1">plugin: </span><span class="s2">&quot;postcss-modules-extract-imports&quot;</span><span class="s0">,</span>
                <span class="s1">word: </span><span class="s2">&quot;composes&quot;</span><span class="s0">,</span>
              <span class="s1">}</span>
            <span class="s1">)</span><span class="s0">;</span>
          <span class="s1">}</span>

          <span class="s0">let </span><span class="s1">lastImportRule</span><span class="s0">;</span>

          <span class="s1">importsOrder.forEach((path) =&gt; {</span>
            <span class="s0">const </span><span class="s1">importedSymbols = imports[path]</span><span class="s0">;</span>
            <span class="s0">let </span><span class="s1">rule = existingImports[path]</span><span class="s0">;</span>

            <span class="s0">if </span><span class="s1">(!rule &amp;&amp; importedSymbols) {</span>
              <span class="s1">rule = postcss.rule({</span>
                <span class="s1">selector: </span><span class="s2">`:import(&quot;</span><span class="s1">${path}</span><span class="s2">&quot;)`</span><span class="s0">,</span>
                <span class="s1">raws: { after: </span><span class="s2">&quot;</span><span class="s0">\n</span><span class="s2">&quot; </span><span class="s1">}</span><span class="s0">,</span>
              <span class="s1">})</span><span class="s0">;</span>

              <span class="s0">if </span><span class="s1">(lastImportRule) {</span>
                <span class="s1">root.insertAfter(lastImportRule</span><span class="s0">, </span><span class="s1">rule)</span><span class="s0">;</span>
              <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
                <span class="s1">root.prepend(rule)</span><span class="s0">;</span>
              <span class="s1">}</span>
            <span class="s1">}</span>

            <span class="s1">lastImportRule = rule</span><span class="s0">;</span>

            <span class="s0">if </span><span class="s1">(!importedSymbols) {</span>
              <span class="s0">return;</span>
            <span class="s1">}</span>

            <span class="s1">Object.keys(importedSymbols).forEach((importedSymbol) =&gt; {</span>
              <span class="s1">rule.append(</span>
                <span class="s1">postcss.decl({</span>
                  <span class="s1">value: importedSymbol</span><span class="s0">,</span>
                  <span class="s1">prop: importedSymbols[importedSymbol]</span><span class="s0">,</span>
                  <span class="s1">raws: { before: </span><span class="s2">&quot;</span><span class="s0">\n  </span><span class="s2">&quot; </span><span class="s1">}</span><span class="s0">,</span>
                <span class="s1">})</span>
              <span class="s1">)</span><span class="s0">;</span>
            <span class="s1">})</span><span class="s0">;</span>
          <span class="s1">})</span><span class="s0">;</span>
        <span class="s1">}</span><span class="s0">,</span>
      <span class="s1">}</span><span class="s0">;</span>
    <span class="s1">}</span><span class="s0">,</span>
  <span class="s1">}</span><span class="s0">;</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s1">srcExports$2.postcss = </span><span class="s0">true;</span>

<span class="s0">var </span><span class="s1">wasmHashExports = {}</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">wasmHash = {</span>
  <span class="s1">get exports(){ </span><span class="s0">return </span><span class="s1">wasmHashExports</span><span class="s0">; </span><span class="s1">}</span><span class="s0">,</span>
  <span class="s1">set exports(v){ wasmHashExports = v</span><span class="s0">; </span><span class="s1">}</span><span class="s0">,</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s4">/* 
    MIT License http://www.opensource.org/licenses/mit-license.php 
    Author Tobias Koppers @sokra 
*/</span>

<span class="s0">var </span><span class="s1">hasRequiredWasmHash</span><span class="s0">;</span>

<span class="s0">function </span><span class="s1">requireWasmHash () {</span>
	<span class="s0">if </span><span class="s1">(hasRequiredWasmHash) </span><span class="s0">return </span><span class="s1">wasmHashExports</span><span class="s0">;</span>
	<span class="s1">hasRequiredWasmHash = </span><span class="s3">1</span><span class="s0">;</span>

	<span class="s4">// 65536 is the size of a wasm memory page</span>
	<span class="s4">// 64 is the maximum chunk size for every possible wasm hash implementation</span>
	<span class="s4">// 4 is the maximum number of bytes per char for string encoding (max is utf-8)</span>
	<span class="s4">// ~3 makes sure that it's always a block of 4 chars, so avoid partially encoded bytes for base64</span>
	<span class="s0">const </span><span class="s1">MAX_SHORT_STRING = Math.floor((</span><span class="s3">65536 </span><span class="s1">- </span><span class="s3">64</span><span class="s1">) / </span><span class="s3">4</span><span class="s1">) &amp; ~</span><span class="s3">3</span><span class="s0">;</span>

	<span class="s0">class </span><span class="s1">WasmHash {</span>
	  <span class="s5">/**</span>
	   <span class="s5">* </span><span class="s6">@param </span><span class="s5">{WebAssembly.Instance} instance wasm instance</span>
	   <span class="s5">* </span><span class="s6">@param </span><span class="s5">{WebAssembly.Instance[]} instancesPool pool of instances</span>
	   <span class="s5">* </span><span class="s6">@param </span><span class="s5">{number} chunkSize size of data chunks passed to wasm</span>
	   <span class="s5">* </span><span class="s6">@param </span><span class="s5">{number} digestSize size of digest returned by wasm</span>
	   <span class="s5">*/</span>
	  <span class="s1">constructor(instance</span><span class="s0">, </span><span class="s1">instancesPool</span><span class="s0">, </span><span class="s1">chunkSize</span><span class="s0">, </span><span class="s1">digestSize) {</span>
	    <span class="s0">const </span><span class="s1">exports = </span><span class="s5">/** </span><span class="s6">@type </span><span class="s5">{any} */ </span><span class="s1">(instance.exports)</span><span class="s0">;</span>

	    <span class="s1">exports.init()</span><span class="s0">;</span>

	    <span class="s0">this</span><span class="s1">.exports = exports</span><span class="s0">;</span>
	    <span class="s0">this</span><span class="s1">.mem = Buffer.from(exports.memory.buffer</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">65536</span><span class="s1">)</span><span class="s0">;</span>
	    <span class="s0">this</span><span class="s1">.buffered = </span><span class="s3">0</span><span class="s0">;</span>
	    <span class="s0">this</span><span class="s1">.instancesPool = instancesPool</span><span class="s0">;</span>
	    <span class="s0">this</span><span class="s1">.chunkSize = chunkSize</span><span class="s0">;</span>
	    <span class="s0">this</span><span class="s1">.digestSize = digestSize</span><span class="s0">;</span>
	  <span class="s1">}</span>

	  <span class="s1">reset() {</span>
	    <span class="s0">this</span><span class="s1">.buffered = </span><span class="s3">0</span><span class="s0">;</span>
	    <span class="s0">this</span><span class="s1">.exports.init()</span><span class="s0">;</span>
	  <span class="s1">}</span>

	  <span class="s5">/**</span>
	   <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Buffer | string} data data</span>
	   <span class="s5">* </span><span class="s6">@param </span><span class="s5">{BufferEncoding=} encoding encoding</span>
	   <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{this} itself</span>
	   <span class="s5">*/</span>
	  <span class="s1">update(data</span><span class="s0">, </span><span class="s1">encoding) {</span>
	    <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">data === </span><span class="s2">&quot;string&quot;</span><span class="s1">) {</span>
	      <span class="s0">while </span><span class="s1">(data.length &gt; MAX_SHORT_STRING) {</span>
	        <span class="s0">this</span><span class="s1">._updateWithShortString(data.slice(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">MAX_SHORT_STRING)</span><span class="s0">, </span><span class="s1">encoding)</span><span class="s0">;</span>
	        <span class="s1">data = data.slice(MAX_SHORT_STRING)</span><span class="s0">;</span>
	      <span class="s1">}</span>

	      <span class="s0">this</span><span class="s1">._updateWithShortString(data</span><span class="s0">, </span><span class="s1">encoding)</span><span class="s0">;</span>

	      <span class="s0">return this;</span>
	    <span class="s1">}</span>

	    <span class="s0">this</span><span class="s1">._updateWithBuffer(data)</span><span class="s0">;</span>

	    <span class="s0">return this;</span>
	  <span class="s1">}</span>

	  <span class="s5">/**</span>
	   <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string} data data</span>
	   <span class="s5">* </span><span class="s6">@param </span><span class="s5">{BufferEncoding=} encoding encoding</span>
	   <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
	   <span class="s5">*/</span>
	  <span class="s1">_updateWithShortString(data</span><span class="s0">, </span><span class="s1">encoding) {</span>
	    <span class="s0">const </span><span class="s1">{ exports</span><span class="s0">, </span><span class="s1">buffered</span><span class="s0">, </span><span class="s1">mem</span><span class="s0">, </span><span class="s1">chunkSize } = </span><span class="s0">this;</span>

	    <span class="s0">let </span><span class="s1">endPos</span><span class="s0">;</span>

	    <span class="s0">if </span><span class="s1">(data.length &lt; </span><span class="s3">70</span><span class="s1">) {</span>
	      <span class="s0">if </span><span class="s1">(!encoding || encoding === </span><span class="s2">&quot;utf-8&quot; </span><span class="s1">|| encoding === </span><span class="s2">&quot;utf8&quot;</span><span class="s1">) {</span>
	        <span class="s1">endPos = buffered</span><span class="s0">;</span>
	        <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s3">0</span><span class="s0">; </span><span class="s1">i &lt; data.length</span><span class="s0">; </span><span class="s1">i++) {</span>
	          <span class="s0">const </span><span class="s1">cc = data.charCodeAt(i)</span><span class="s0">;</span>

	          <span class="s0">if </span><span class="s1">(cc &lt; </span><span class="s3">0x80</span><span class="s1">) {</span>
	            <span class="s1">mem[endPos++] = cc</span><span class="s0">;</span>
	          <span class="s1">} </span><span class="s0">else if </span><span class="s1">(cc &lt; </span><span class="s3">0x800</span><span class="s1">) {</span>
	            <span class="s1">mem[endPos] = (cc &gt;&gt; </span><span class="s3">6</span><span class="s1">) | </span><span class="s3">0xc0</span><span class="s0">;</span>
	            <span class="s1">mem[endPos + </span><span class="s3">1</span><span class="s1">] = (cc &amp; </span><span class="s3">0x3f</span><span class="s1">) | </span><span class="s3">0x80</span><span class="s0">;</span>
	            <span class="s1">endPos += </span><span class="s3">2</span><span class="s0">;</span>
	          <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
	            <span class="s4">// bail-out for weird chars</span>
	            <span class="s1">endPos += mem.write(data.slice(i)</span><span class="s0">, </span><span class="s1">endPos</span><span class="s0">, </span><span class="s1">encoding)</span><span class="s0">;</span>
	            <span class="s0">break;</span>
	          <span class="s1">}</span>
	        <span class="s1">}</span>
	      <span class="s1">} </span><span class="s0">else if </span><span class="s1">(encoding === </span><span class="s2">&quot;latin1&quot;</span><span class="s1">) {</span>
	        <span class="s1">endPos = buffered</span><span class="s0">;</span>

	        <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s3">0</span><span class="s0">; </span><span class="s1">i &lt; data.length</span><span class="s0">; </span><span class="s1">i++) {</span>
	          <span class="s0">const </span><span class="s1">cc = data.charCodeAt(i)</span><span class="s0">;</span>

	          <span class="s1">mem[endPos++] = cc</span><span class="s0">;</span>
	        <span class="s1">}</span>
	      <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
	        <span class="s1">endPos = buffered + mem.write(data</span><span class="s0">, </span><span class="s1">buffered</span><span class="s0">, </span><span class="s1">encoding)</span><span class="s0">;</span>
	      <span class="s1">}</span>
	    <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
	      <span class="s1">endPos = buffered + mem.write(data</span><span class="s0">, </span><span class="s1">buffered</span><span class="s0">, </span><span class="s1">encoding)</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">if </span><span class="s1">(endPos &lt; chunkSize) {</span>
	      <span class="s0">this</span><span class="s1">.buffered = endPos</span><span class="s0">;</span>
	    <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
	      <span class="s0">const </span><span class="s1">l = endPos &amp; ~(</span><span class="s0">this</span><span class="s1">.chunkSize - </span><span class="s3">1</span><span class="s1">)</span><span class="s0">;</span>

	      <span class="s1">exports.update(l)</span><span class="s0">;</span>

	      <span class="s0">const </span><span class="s1">newBuffered = endPos - l</span><span class="s0">;</span>

	      <span class="s0">this</span><span class="s1">.buffered = newBuffered</span><span class="s0">;</span>

	      <span class="s0">if </span><span class="s1">(newBuffered &gt; </span><span class="s3">0</span><span class="s1">) {</span>
	        <span class="s1">mem.copyWithin(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">l</span><span class="s0">, </span><span class="s1">endPos)</span><span class="s0">;</span>
	      <span class="s1">}</span>
	    <span class="s1">}</span>
	  <span class="s1">}</span>

	  <span class="s5">/**</span>
	   <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Buffer} data data</span>
	   <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{void}</span>
	   <span class="s5">*/</span>
	  <span class="s1">_updateWithBuffer(data) {</span>
	    <span class="s0">const </span><span class="s1">{ exports</span><span class="s0">, </span><span class="s1">buffered</span><span class="s0">, </span><span class="s1">mem } = </span><span class="s0">this;</span>
	    <span class="s0">const </span><span class="s1">length = data.length</span><span class="s0">;</span>

	    <span class="s0">if </span><span class="s1">(buffered + length &lt; </span><span class="s0">this</span><span class="s1">.chunkSize) {</span>
	      <span class="s1">data.copy(mem</span><span class="s0">, </span><span class="s1">buffered</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">length)</span><span class="s0">;</span>

	      <span class="s0">this</span><span class="s1">.buffered += length</span><span class="s0">;</span>
	    <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
	      <span class="s0">const </span><span class="s1">l = (buffered + length) &amp; ~(</span><span class="s0">this</span><span class="s1">.chunkSize - </span><span class="s3">1</span><span class="s1">)</span><span class="s0">;</span>

	      <span class="s0">if </span><span class="s1">(l &gt; </span><span class="s3">65536</span><span class="s1">) {</span>
	        <span class="s0">let </span><span class="s1">i = </span><span class="s3">65536 </span><span class="s1">- buffered</span><span class="s0">;</span>

	        <span class="s1">data.copy(mem</span><span class="s0">, </span><span class="s1">buffered</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">i)</span><span class="s0">;</span>
	        <span class="s1">exports.update(</span><span class="s3">65536</span><span class="s1">)</span><span class="s0">;</span>

	        <span class="s0">const </span><span class="s1">stop = l - buffered - </span><span class="s3">65536</span><span class="s0">;</span>

	        <span class="s0">while </span><span class="s1">(i &lt; stop) {</span>
	          <span class="s1">data.copy(mem</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">i</span><span class="s0">, </span><span class="s1">i + </span><span class="s3">65536</span><span class="s1">)</span><span class="s0">;</span>
	          <span class="s1">exports.update(</span><span class="s3">65536</span><span class="s1">)</span><span class="s0">;</span>
	          <span class="s1">i += </span><span class="s3">65536</span><span class="s0">;</span>
	        <span class="s1">}</span>

	        <span class="s1">data.copy(mem</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">i</span><span class="s0">, </span><span class="s1">l - buffered)</span><span class="s0">;</span>

	        <span class="s1">exports.update(l - buffered - i)</span><span class="s0">;</span>
	      <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
	        <span class="s1">data.copy(mem</span><span class="s0">, </span><span class="s1">buffered</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">l - buffered)</span><span class="s0">;</span>

	        <span class="s1">exports.update(l)</span><span class="s0">;</span>
	      <span class="s1">}</span>

	      <span class="s0">const </span><span class="s1">newBuffered = length + buffered - l</span><span class="s0">;</span>

	      <span class="s0">this</span><span class="s1">.buffered = newBuffered</span><span class="s0">;</span>

	      <span class="s0">if </span><span class="s1">(newBuffered &gt; </span><span class="s3">0</span><span class="s1">) {</span>
	        <span class="s1">data.copy(mem</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">length - newBuffered</span><span class="s0">, </span><span class="s1">length)</span><span class="s0">;</span>
	      <span class="s1">}</span>
	    <span class="s1">}</span>
	  <span class="s1">}</span>

	  <span class="s1">digest(type) {</span>
	    <span class="s0">const </span><span class="s1">{ exports</span><span class="s0">, </span><span class="s1">buffered</span><span class="s0">, </span><span class="s1">mem</span><span class="s0">, </span><span class="s1">digestSize } = </span><span class="s0">this;</span>

	    <span class="s1">exports.final(buffered)</span><span class="s0">;</span>

	    <span class="s0">this</span><span class="s1">.instancesPool.push(</span><span class="s0">this</span><span class="s1">)</span><span class="s0">;</span>

	    <span class="s0">const </span><span class="s1">hex = mem.toString(</span><span class="s2">&quot;latin1&quot;</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">digestSize)</span><span class="s0">;</span>

	    <span class="s0">if </span><span class="s1">(type === </span><span class="s2">&quot;hex&quot;</span><span class="s1">) {</span>
	      <span class="s0">return </span><span class="s1">hex</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">if </span><span class="s1">(type === </span><span class="s2">&quot;binary&quot; </span><span class="s1">|| !type) {</span>
	      <span class="s0">return </span><span class="s1">Buffer.from(hex</span><span class="s0">, </span><span class="s2">&quot;hex&quot;</span><span class="s1">)</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">return </span><span class="s1">Buffer.from(hex</span><span class="s0">, </span><span class="s2">&quot;hex&quot;</span><span class="s1">).toString(type)</span><span class="s0">;</span>
	  <span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s0">const </span><span class="s1">create = (wasmModule</span><span class="s0">, </span><span class="s1">instancesPool</span><span class="s0">, </span><span class="s1">chunkSize</span><span class="s0">, </span><span class="s1">digestSize) =&gt; {</span>
	  <span class="s0">if </span><span class="s1">(instancesPool.length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
	    <span class="s0">const </span><span class="s1">old = instancesPool.pop()</span><span class="s0">;</span>

	    <span class="s1">old.reset()</span><span class="s0">;</span>

	    <span class="s0">return </span><span class="s1">old</span><span class="s0">;</span>
	  <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
	    <span class="s0">return new </span><span class="s1">WasmHash(</span>
	      <span class="s0">new </span><span class="s1">WebAssembly.Instance(wasmModule)</span><span class="s0">,</span>
	      <span class="s1">instancesPool</span><span class="s0">,</span>
	      <span class="s1">chunkSize</span><span class="s0">,</span>
	      <span class="s1">digestSize</span>
	    <span class="s1">)</span><span class="s0">;</span>
	  <span class="s1">}</span>
	<span class="s1">}</span><span class="s0">;</span>

	<span class="s1">wasmHash.exports = create</span><span class="s0">;</span>
	<span class="s1">wasmHashExports.MAX_SHORT_STRING = MAX_SHORT_STRING</span><span class="s0">;</span>
	<span class="s0">return </span><span class="s1">wasmHashExports</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s4">/* 
    MIT License http://www.opensource.org/licenses/mit-license.php 
    Author Tobias Koppers @sokra 
*/</span>

<span class="s0">var </span><span class="s1">xxhash64_1</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">hasRequiredXxhash64</span><span class="s0">;</span>

<span class="s0">function </span><span class="s1">requireXxhash64 () {</span>
	<span class="s0">if </span><span class="s1">(hasRequiredXxhash64) </span><span class="s0">return </span><span class="s1">xxhash64_1</span><span class="s0">;</span>
	<span class="s1">hasRequiredXxhash64 = </span><span class="s3">1</span><span class="s0">;</span>

	<span class="s0">const </span><span class="s1">create = requireWasmHash()</span><span class="s0">;</span>

	<span class="s4">//#region wasm code: xxhash64 (../../../assembly/hash/xxhash64.asm.ts) --initialMemory 1</span>
	<span class="s0">const </span><span class="s1">xxhash64 = </span><span class="s0">new </span><span class="s1">WebAssembly.Module(</span>
	  <span class="s1">Buffer.from(</span>
	    <span class="s4">// 1173 bytes</span>
	    <span class="s2">&quot;AGFzbQEAAAABCAJgAX8AYAAAAwQDAQAABQMBAAEGGgV+AUIAC34BQgALfgFCAAt+AUIAC34BQgALByIEBGluaXQAAAZ1cGRhdGUAAQVmaW5hbAACBm1lbW9yeQIACrUIAzAAQtbrgu7q/Yn14AAkAELP1tO+0ser2UIkAUIAJAJC+erQ0OfJoeThACQDQgAkBAvUAQIBfwR+IABFBEAPCyMEIACtfCQEIwAhAiMBIQMjAiEEIwMhBQNAIAIgASkDAELP1tO+0ser2UJ+fEIfiUKHla+vmLbem55/fiECIAMgASkDCELP1tO+0ser2UJ+fEIfiUKHla+vmLbem55/fiEDIAQgASkDEELP1tO+0ser2UJ+fEIfiUKHla+vmLbem55/fiEEIAUgASkDGELP1tO+0ser2UJ+fEIfiUKHla+vmLbem55/fiEFIAAgAUEgaiIBSw0ACyACJAAgAyQBIAQkAiAFJAMLqwYCAX8EfiMEQgBSBH4jACICQgGJIwEiA0IHiXwjAiIEQgyJfCMDIgVCEol8IAJCz9bTvtLHq9lCfkIfiUKHla+vmLbem55/foVCh5Wvr5i23puef35CnaO16oOxjYr6AH0gA0LP1tO+0ser2UJ+Qh+JQoeVr6+Ytt6bnn9+hUKHla+vmLbem55/fkKdo7Xqg7GNivoAfSAEQs/W077Sx6vZQn5CH4lCh5Wvr5i23puef36FQoeVr6+Ytt6bnn9+Qp2jteqDsY2K+gB9IAVCz9bTvtLHq9lCfkIfiUKHla+vmLbem55/foVCh5Wvr5i23puef35CnaO16oOxjYr6AH0FQsXP2bLx5brqJwsjBCAArXx8IQIDQCABQQhqIABNBEAgAiABKQMAQs/W077Sx6vZQn5CH4lCh5Wvr5i23puef36FQhuJQoeVr6+Ytt6bnn9+Qp2jteqDsY2K+gB9IQIgAUEIaiEBDAELCyABQQRqIABNBEACfyACIAE1AgBCh5Wvr5i23puef36FQheJQs/W077Sx6vZQn5C+fPd8Zn2masWfCECIAFBBGoLIQELA0AgACABRwRAIAIgATEAAELFz9my8eW66id+hUILiUKHla+vmLbem55/fiECIAFBAWohAQwBCwtBACACIAJCIYiFQs/W077Sx6vZQn4iAiACQh2IhUL5893xmfaZqxZ+IgIgAkIgiIUiAkIgiCIDQv//A4NCIIYgA0KAgPz/D4NCEIiEIgNC/4GAgPAfg0IQhiADQoD+g4CA4D+DQgiIhCIDQo+AvIDwgcAHg0IIhiADQvCBwIeAnoD4AINCBIiEIgNChoyYsODAgYMGfEIEiEKBgoSIkKDAgAGDQid+IANCsODAgYOGjJgwhHw3AwBBCCACQv////8PgyICQv//A4NCIIYgAkKAgPz/D4NCEIiEIgJC/4GAgPAfg0IQhiACQoD+g4CA4D+DQgiIhCICQo+AvIDwgcAHg0IIhiACQvCBwIeAnoD4AINCBIiEIgJChoyYsODAgYMGfEIEiEKBgoSIkKDAgAGDQid+IAJCsODAgYOGjJgwhHw3AwAL&quot;</span><span class="s0">,</span>
	    <span class="s2">&quot;base64&quot;</span>
	  <span class="s1">)</span>
	<span class="s1">)</span><span class="s0">;</span>
	<span class="s4">//#endregion</span>

	<span class="s1">xxhash64_1 = create.bind(</span><span class="s0">null, </span><span class="s1">xxhash64</span><span class="s0">, </span><span class="s1">[]</span><span class="s0">, </span><span class="s3">32</span><span class="s0">, </span><span class="s3">16</span><span class="s1">)</span><span class="s0">;</span>
	<span class="s0">return </span><span class="s1">xxhash64_1</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">var </span><span class="s1">BatchedHash_1</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">hasRequiredBatchedHash</span><span class="s0">;</span>

<span class="s0">function </span><span class="s1">requireBatchedHash () {</span>
	<span class="s0">if </span><span class="s1">(hasRequiredBatchedHash) </span><span class="s0">return </span><span class="s1">BatchedHash_1</span><span class="s0">;</span>
	<span class="s1">hasRequiredBatchedHash = </span><span class="s3">1</span><span class="s0">;</span>
	<span class="s0">const </span><span class="s1">MAX_SHORT_STRING = requireWasmHash().MAX_SHORT_STRING</span><span class="s0">;</span>

	<span class="s0">class </span><span class="s1">BatchedHash {</span>
	  <span class="s1">constructor(hash) {</span>
	    <span class="s0">this</span><span class="s1">.string = undefined</span><span class="s0">;</span>
	    <span class="s0">this</span><span class="s1">.encoding = undefined</span><span class="s0">;</span>
	    <span class="s0">this</span><span class="s1">.hash = hash</span><span class="s0">;</span>
	  <span class="s1">}</span>

	  <span class="s5">/**</span>
	   <span class="s5">* Update hash {</span><span class="s6">@link </span><span class="s5">https://nodejs.org/api/crypto.html#crypto_hash_update_data_inputencoding}</span>
	   <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string|Buffer} data data</span>
	   <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string=} inputEncoding data encoding</span>
	   <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{this} updated hash</span>
	   <span class="s5">*/</span>
	  <span class="s1">update(data</span><span class="s0">, </span><span class="s1">inputEncoding) {</span>
	    <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.string !== undefined) {</span>
	      <span class="s0">if </span><span class="s1">(</span>
	        <span class="s0">typeof </span><span class="s1">data === </span><span class="s2">&quot;string&quot; </span><span class="s1">&amp;&amp;</span>
	        <span class="s1">inputEncoding === </span><span class="s0">this</span><span class="s1">.encoding &amp;&amp;</span>
	        <span class="s0">this</span><span class="s1">.string.length + data.length &lt; MAX_SHORT_STRING</span>
	      <span class="s1">) {</span>
	        <span class="s0">this</span><span class="s1">.string += data</span><span class="s0">;</span>

	        <span class="s0">return this;</span>
	      <span class="s1">}</span>

	      <span class="s0">this</span><span class="s1">.hash.update(</span><span class="s0">this</span><span class="s1">.string</span><span class="s0">, this</span><span class="s1">.encoding)</span><span class="s0">;</span>
	      <span class="s0">this</span><span class="s1">.string = undefined</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">data === </span><span class="s2">&quot;string&quot;</span><span class="s1">) {</span>
	      <span class="s0">if </span><span class="s1">(</span>
	        <span class="s1">data.length &lt; MAX_SHORT_STRING &amp;&amp;</span>
	        <span class="s4">// base64 encoding is not valid since it may contain padding chars</span>
	        <span class="s1">(!inputEncoding || !inputEncoding.startsWith(</span><span class="s2">&quot;ba&quot;</span><span class="s1">))</span>
	      <span class="s1">) {</span>
	        <span class="s0">this</span><span class="s1">.string = data</span><span class="s0">;</span>
	        <span class="s0">this</span><span class="s1">.encoding = inputEncoding</span><span class="s0">;</span>
	      <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
	        <span class="s0">this</span><span class="s1">.hash.update(data</span><span class="s0">, </span><span class="s1">inputEncoding)</span><span class="s0">;</span>
	      <span class="s1">}</span>
	    <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
	      <span class="s0">this</span><span class="s1">.hash.update(data)</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">return this;</span>
	  <span class="s1">}</span>

	  <span class="s5">/**</span>
	   <span class="s5">* Calculates the digest {</span><span class="s6">@link </span><span class="s5">https://nodejs.org/api/crypto.html#crypto_hash_digest_encoding}</span>
	   <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string=} encoding encoding of the return value</span>
	   <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{string|Buffer} digest</span>
	   <span class="s5">*/</span>
	  <span class="s1">digest(encoding) {</span>
	    <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.string !== undefined) {</span>
	      <span class="s0">this</span><span class="s1">.hash.update(</span><span class="s0">this</span><span class="s1">.string</span><span class="s0">, this</span><span class="s1">.encoding)</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">return this</span><span class="s1">.hash.digest(encoding)</span><span class="s0">;</span>
	  <span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s1">BatchedHash_1 = BatchedHash</span><span class="s0">;</span>
	<span class="s0">return </span><span class="s1">BatchedHash_1</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s4">/* 
    MIT License http://www.opensource.org/licenses/mit-license.php 
    Author Tobias Koppers @sokra 
*/</span>

<span class="s0">var </span><span class="s1">md4_1</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">hasRequiredMd4</span><span class="s0">;</span>

<span class="s0">function </span><span class="s1">requireMd4 () {</span>
	<span class="s0">if </span><span class="s1">(hasRequiredMd4) </span><span class="s0">return </span><span class="s1">md4_1</span><span class="s0">;</span>
	<span class="s1">hasRequiredMd4 = </span><span class="s3">1</span><span class="s0">;</span>

	<span class="s0">const </span><span class="s1">create = requireWasmHash()</span><span class="s0">;</span>

	<span class="s4">//#region wasm code: md4 (../../../assembly/hash/md4.asm.ts) --initialMemory 1</span>
	<span class="s0">const </span><span class="s1">md4 = </span><span class="s0">new </span><span class="s1">WebAssembly.Module(</span>
	  <span class="s1">Buffer.from(</span>
	    <span class="s4">// 2150 bytes</span>
	    <span class="s2">&quot;AGFzbQEAAAABCAJgAX8AYAAAAwUEAQAAAAUDAQABBhoFfwFBAAt/AUEAC38BQQALfwFBAAt/AUEACwciBARpbml0AAAGdXBkYXRlAAIFZmluYWwAAwZtZW1vcnkCAAqFEAQmAEGBxpS6BiQBQYnXtv5+JAJB/rnrxXkkA0H2qMmBASQEQQAkAAvMCgEYfyMBIQojAiEGIwMhByMEIQgDQCAAIAVLBEAgBSgCCCINIAcgBiAFKAIEIgsgCCAHIAUoAgAiDCAKIAggBiAHIAhzcXNqakEDdyIDIAYgB3Nxc2pqQQd3IgEgAyAGc3FzampBC3chAiAFKAIUIg8gASACIAUoAhAiCSADIAEgBSgCDCIOIAYgAyACIAEgA3Nxc2pqQRN3IgQgASACc3FzampBA3ciAyACIARzcXNqakEHdyEBIAUoAiAiEiADIAEgBSgCHCIRIAQgAyAFKAIYIhAgAiAEIAEgAyAEc3FzampBC3ciAiABIANzcXNqakETdyIEIAEgAnNxc2pqQQN3IQMgBSgCLCIVIAQgAyAFKAIoIhQgAiAEIAUoAiQiEyABIAIgAyACIARzcXNqakEHdyIBIAMgBHNxc2pqQQt3IgIgASADc3FzampBE3chBCAPIBAgCSAVIBQgEyAFKAI4IhYgAiAEIAUoAjQiFyABIAIgBSgCMCIYIAMgASAEIAEgAnNxc2pqQQN3IgEgAiAEc3FzampBB3ciAiABIARzcXNqakELdyIDIAkgAiAMIAEgBSgCPCIJIAQgASADIAEgAnNxc2pqQRN3IgEgAiADcnEgAiADcXJqakGZ84nUBWpBA3ciAiABIANycSABIANxcmpqQZnzidQFakEFdyIEIAEgAnJxIAEgAnFyaiASakGZ84nUBWpBCXciAyAPIAQgCyACIBggASADIAIgBHJxIAIgBHFyampBmfOJ1AVqQQ13IgEgAyAEcnEgAyAEcXJqakGZ84nUBWpBA3ciAiABIANycSABIANxcmpqQZnzidQFakEFdyIEIAEgAnJxIAEgAnFyampBmfOJ1AVqQQl3IgMgECAEIAIgFyABIAMgAiAEcnEgAiAEcXJqakGZ84nUBWpBDXciASADIARycSADIARxcmogDWpBmfOJ1AVqQQN3IgIgASADcnEgASADcXJqakGZ84nUBWpBBXciBCABIAJycSABIAJxcmpqQZnzidQFakEJdyIDIBEgBCAOIAIgFiABIAMgAiAEcnEgAiAEcXJqakGZ84nUBWpBDXciASADIARycSADIARxcmpqQZnzidQFakEDdyICIAEgA3JxIAEgA3FyampBmfOJ1AVqQQV3IgQgASACcnEgASACcXJqakGZ84nUBWpBCXciAyAMIAIgAyAJIAEgAyACIARycSACIARxcmpqQZnzidQFakENdyIBcyAEc2pqQaHX5/YGakEDdyICIAQgASACcyADc2ogEmpBodfn9gZqQQl3IgRzIAFzampBodfn9gZqQQt3IgMgAiADIBggASADIARzIAJzampBodfn9gZqQQ93IgFzIARzaiANakGh1+f2BmpBA3ciAiAUIAQgASACcyADc2pqQaHX5/YGakEJdyIEcyABc2pqQaHX5/YGakELdyIDIAsgAiADIBYgASADIARzIAJzampBodfn9gZqQQ93IgFzIARzampBodfn9gZqQQN3IgIgEyAEIAEgAnMgA3NqakGh1+f2BmpBCXciBHMgAXNqakGh1+f2BmpBC3chAyAKIA4gAiADIBcgASADIARzIAJzampBodfn9gZqQQ93IgFzIARzampBodfn9gZqQQN3IgJqIQogBiAJIAEgESADIAIgFSAEIAEgAnMgA3NqakGh1+f2BmpBCXciBHMgAXNqakGh1+f2BmpBC3ciAyAEcyACc2pqQaHX5/YGakEPd2ohBiADIAdqIQcgBCAIaiEIIAVBQGshBQwBCwsgCiQBIAYkAiAHJAMgCCQECw0AIAAQASMAIABqJAAL/wQCA38BfiMAIABqrUIDhiEEIABByABqQUBxIgJBCGshAyAAIgFBAWohACABQYABOgAAA0AgACACSUEAIABBB3EbBEAgAEEAOgAAIABBAWohAAwBCwsDQCAAIAJJBEAgAEIANwMAIABBCGohAAwBCwsgAyAENwMAIAIQAUEAIwGtIgRC//8DgyAEQoCA/P8Pg0IQhoQiBEL/gYCA8B+DIARCgP6DgIDgP4NCCIaEIgRCj4C8gPCBwAeDQgiGIARC8IHAh4CegPgAg0IEiIQiBEKGjJiw4MCBgwZ8QgSIQoGChIiQoMCAAYNCJ34gBEKw4MCBg4aMmDCEfDcDAEEIIwKtIgRC//8DgyAEQoCA/P8Pg0IQhoQiBEL/gYCA8B+DIARCgP6DgIDgP4NCCIaEIgRCj4C8gPCBwAeDQgiGIARC8IHAh4CegPgAg0IEiIQiBEKGjJiw4MCBgwZ8QgSIQoGChIiQoMCAAYNCJ34gBEKw4MCBg4aMmDCEfDcDAEEQIwOtIgRC//8DgyAEQoCA/P8Pg0IQhoQiBEL/gYCA8B+DIARCgP6DgIDgP4NCCIaEIgRCj4C8gPCBwAeDQgiGIARC8IHAh4CegPgAg0IEiIQiBEKGjJiw4MCBgwZ8QgSIQoGChIiQoMCAAYNCJ34gBEKw4MCBg4aMmDCEfDcDAEEYIwStIgRC//8DgyAEQoCA/P8Pg0IQhoQiBEL/gYCA8B+DIARCgP6DgIDgP4NCCIaEIgRCj4C8gPCBwAeDQgiGIARC8IHAh4CegPgAg0IEiIQiBEKGjJiw4MCBgwZ8QgSIQoGChIiQoMCAAYNCJ34gBEKw4MCBg4aMmDCEfDcDAAs=&quot;</span><span class="s0">,</span>
	    <span class="s2">&quot;base64&quot;</span>
	  <span class="s1">)</span>
	<span class="s1">)</span><span class="s0">;</span>
	<span class="s4">//#endregion</span>

	<span class="s1">md4_1 = create.bind(</span><span class="s0">null, </span><span class="s1">md4</span><span class="s0">, </span><span class="s1">[]</span><span class="s0">, </span><span class="s3">64</span><span class="s0">, </span><span class="s3">32</span><span class="s1">)</span><span class="s0">;</span>
	<span class="s0">return </span><span class="s1">md4_1</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">var </span><span class="s1">BulkUpdateDecorator_1</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">hasRequiredBulkUpdateDecorator</span><span class="s0">;</span>

<span class="s0">function </span><span class="s1">requireBulkUpdateDecorator () {</span>
	<span class="s0">if </span><span class="s1">(hasRequiredBulkUpdateDecorator) </span><span class="s0">return </span><span class="s1">BulkUpdateDecorator_1</span><span class="s0">;</span>
	<span class="s1">hasRequiredBulkUpdateDecorator = </span><span class="s3">1</span><span class="s0">;</span>
	<span class="s0">const </span><span class="s1">BULK_SIZE = </span><span class="s3">2000</span><span class="s0">;</span>

	<span class="s4">// We are using an object instead of a Map as this will stay static during the runtime</span>
	<span class="s4">// so access to it can be optimized by v8</span>
	<span class="s0">const </span><span class="s1">digestCaches = {}</span><span class="s0">;</span>

	<span class="s0">class </span><span class="s1">BulkUpdateDecorator {</span>
	  <span class="s5">/**</span>
	   <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Hash | function(): Hash} hashOrFactory function to create a hash</span>
	   <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string=} hashKey key for caching</span>
	   <span class="s5">*/</span>
	  <span class="s1">constructor(hashOrFactory</span><span class="s0">, </span><span class="s1">hashKey) {</span>
	    <span class="s0">this</span><span class="s1">.hashKey = hashKey</span><span class="s0">;</span>

	    <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">hashOrFactory === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
	      <span class="s0">this</span><span class="s1">.hashFactory = hashOrFactory</span><span class="s0">;</span>
	      <span class="s0">this</span><span class="s1">.hash = undefined</span><span class="s0">;</span>
	    <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
	      <span class="s0">this</span><span class="s1">.hashFactory = undefined</span><span class="s0">;</span>
	      <span class="s0">this</span><span class="s1">.hash = hashOrFactory</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">this</span><span class="s1">.buffer = </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
	  <span class="s1">}</span>

	  <span class="s5">/**</span>
	   <span class="s5">* Update hash {</span><span class="s6">@link </span><span class="s5">https://nodejs.org/api/crypto.html#crypto_hash_update_data_inputencoding}</span>
	   <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string|Buffer} data data</span>
	   <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string=} inputEncoding data encoding</span>
	   <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{this} updated hash</span>
	   <span class="s5">*/</span>
	  <span class="s1">update(data</span><span class="s0">, </span><span class="s1">inputEncoding) {</span>
	    <span class="s0">if </span><span class="s1">(</span>
	      <span class="s1">inputEncoding !== undefined ||</span>
	      <span class="s0">typeof </span><span class="s1">data !== </span><span class="s2">&quot;string&quot; </span><span class="s1">||</span>
	      <span class="s1">data.length &gt; BULK_SIZE</span>
	    <span class="s1">) {</span>
	      <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.hash === undefined) {</span>
	        <span class="s0">this</span><span class="s1">.hash = </span><span class="s0">this</span><span class="s1">.hashFactory()</span><span class="s0">;</span>
	      <span class="s1">}</span>

	      <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.buffer.length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
	        <span class="s0">this</span><span class="s1">.hash.update(</span><span class="s0">this</span><span class="s1">.buffer)</span><span class="s0">;</span>
	        <span class="s0">this</span><span class="s1">.buffer = </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
	      <span class="s1">}</span>

	      <span class="s0">this</span><span class="s1">.hash.update(data</span><span class="s0">, </span><span class="s1">inputEncoding)</span><span class="s0">;</span>
	    <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
	      <span class="s0">this</span><span class="s1">.buffer += data</span><span class="s0">;</span>

	      <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.buffer.length &gt; BULK_SIZE) {</span>
	        <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.hash === undefined) {</span>
	          <span class="s0">this</span><span class="s1">.hash = </span><span class="s0">this</span><span class="s1">.hashFactory()</span><span class="s0">;</span>
	        <span class="s1">}</span>

	        <span class="s0">this</span><span class="s1">.hash.update(</span><span class="s0">this</span><span class="s1">.buffer)</span><span class="s0">;</span>
	        <span class="s0">this</span><span class="s1">.buffer = </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
	      <span class="s1">}</span>
	    <span class="s1">}</span>

	    <span class="s0">return this;</span>
	  <span class="s1">}</span>

	  <span class="s5">/**</span>
	   <span class="s5">* Calculates the digest {</span><span class="s6">@link </span><span class="s5">https://nodejs.org/api/crypto.html#crypto_hash_digest_encoding}</span>
	   <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string=} encoding encoding of the return value</span>
	   <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{string|Buffer} digest</span>
	   <span class="s5">*/</span>
	  <span class="s1">digest(encoding) {</span>
	    <span class="s0">let </span><span class="s1">digestCache</span><span class="s0">;</span>

	    <span class="s0">const </span><span class="s1">buffer = </span><span class="s0">this</span><span class="s1">.buffer</span><span class="s0">;</span>

	    <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.hash === undefined) {</span>
	      <span class="s4">// short data for hash, we can use caching</span>
	      <span class="s0">const </span><span class="s1">cacheKey = </span><span class="s2">`</span><span class="s1">${</span><span class="s0">this</span><span class="s1">.hashKey}</span><span class="s2">-</span><span class="s1">${encoding}</span><span class="s2">`</span><span class="s0">;</span>

	      <span class="s1">digestCache = digestCaches[cacheKey]</span><span class="s0">;</span>

	      <span class="s0">if </span><span class="s1">(digestCache === undefined) {</span>
	        <span class="s1">digestCache = digestCaches[cacheKey] = </span><span class="s0">new </span><span class="s1">Map()</span><span class="s0">;</span>
	      <span class="s1">}</span>

	      <span class="s0">const </span><span class="s1">cacheEntry = digestCache.get(buffer)</span><span class="s0">;</span>

	      <span class="s0">if </span><span class="s1">(cacheEntry !== undefined) {</span>
	        <span class="s0">return </span><span class="s1">cacheEntry</span><span class="s0">;</span>
	      <span class="s1">}</span>

	      <span class="s0">this</span><span class="s1">.hash = </span><span class="s0">this</span><span class="s1">.hashFactory()</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">if </span><span class="s1">(buffer.length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
	      <span class="s0">this</span><span class="s1">.hash.update(buffer)</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">const </span><span class="s1">digestResult = </span><span class="s0">this</span><span class="s1">.hash.digest(encoding)</span><span class="s0">;</span>

	    <span class="s0">if </span><span class="s1">(digestCache !== undefined) {</span>
	      <span class="s1">digestCache.set(buffer</span><span class="s0">, </span><span class="s1">digestResult)</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">return </span><span class="s1">digestResult</span><span class="s0">;</span>
	  <span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s1">BulkUpdateDecorator_1 = BulkUpdateDecorator</span><span class="s0">;</span>
	<span class="s0">return </span><span class="s1">BulkUpdateDecorator_1</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">const </span><span class="s1">baseEncodeTables = {</span>
  <span class="s3">26</span><span class="s1">: </span><span class="s2">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span><span class="s0">,</span>
  <span class="s3">32</span><span class="s1">: </span><span class="s2">&quot;123456789abcdefghjkmnpqrstuvwxyz&quot;</span><span class="s0">, </span><span class="s4">// no 0lio</span>
  <span class="s3">36</span><span class="s1">: </span><span class="s2">&quot;0123456789abcdefghijklmnopqrstuvwxyz&quot;</span><span class="s0">,</span>
  <span class="s3">49</span><span class="s1">: </span><span class="s2">&quot;abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ&quot;</span><span class="s0">, </span><span class="s4">// no lIO</span>
  <span class="s3">52</span><span class="s1">: </span><span class="s2">&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span><span class="s0">,</span>
  <span class="s3">58</span><span class="s1">: </span><span class="s2">&quot;123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ&quot;</span><span class="s0">, </span><span class="s4">// no 0lIO</span>
  <span class="s3">62</span><span class="s1">: </span><span class="s2">&quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span><span class="s0">,</span>
  <span class="s3">64</span><span class="s1">: </span><span class="s2">&quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_&quot;</span><span class="s0">,</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Uint32Array} uint32Array Treated as a long base-0x100000000 number, little endian</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{number} divisor The divisor</span>
 <span class="s5">* </span><span class="s6">@return </span><span class="s5">{number} Modulo (remainder) of the division</span>
 <span class="s5">*/</span>
<span class="s0">function </span><span class="s1">divmod32(uint32Array</span><span class="s0">, </span><span class="s1">divisor) {</span>
  <span class="s0">let </span><span class="s1">carry = </span><span class="s3">0</span><span class="s0">;</span>
  <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = uint32Array.length - </span><span class="s3">1</span><span class="s0">; </span><span class="s1">i &gt;= </span><span class="s3">0</span><span class="s0">; </span><span class="s1">i--) {</span>
    <span class="s0">const </span><span class="s1">value = carry * </span><span class="s3">0x100000000 </span><span class="s1">+ uint32Array[i]</span><span class="s0">;</span>
    <span class="s1">carry = value % divisor</span><span class="s0">;</span>
    <span class="s1">uint32Array[i] = Math.floor(value / divisor)</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">return </span><span class="s1">carry</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">encodeBufferToBase(buffer</span><span class="s0">, </span><span class="s1">base</span><span class="s0">, </span><span class="s1">length) {</span>
  <span class="s0">const </span><span class="s1">encodeTable = baseEncodeTables[base]</span><span class="s0">;</span>

  <span class="s0">if </span><span class="s1">(!encodeTable) {</span>
    <span class="s0">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Unknown encoding base&quot; </span><span class="s1">+ base)</span><span class="s0">;</span>
  <span class="s1">}</span>

  <span class="s4">// Input bits are only enough to generate this many characters</span>
  <span class="s0">const </span><span class="s1">limit = Math.ceil((buffer.length * </span><span class="s3">8</span><span class="s1">) / Math.log2(base))</span><span class="s0">;</span>
  <span class="s1">length = Math.min(length</span><span class="s0">, </span><span class="s1">limit)</span><span class="s0">;</span>

  <span class="s4">// Most of the crypto digests (if not all) has length a multiple of 4 bytes.</span>
  <span class="s4">// Fewer numbers in the array means faster math.</span>
  <span class="s0">const </span><span class="s1">uint32Array = </span><span class="s0">new </span><span class="s1">Uint32Array(Math.ceil(buffer.length / </span><span class="s3">4</span><span class="s1">))</span><span class="s0">;</span>

  <span class="s4">// Make sure the input buffer data is copied and is not mutated by reference.</span>
  <span class="s4">// divmod32() would corrupt the BulkUpdateDecorator cache otherwise.</span>
  <span class="s1">buffer.copy(Buffer.from(uint32Array.buffer))</span><span class="s0">;</span>

  <span class="s0">let </span><span class="s1">output = </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>

  <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s3">0</span><span class="s0">; </span><span class="s1">i &lt; length</span><span class="s0">; </span><span class="s1">i++) {</span>
    <span class="s1">output = encodeTable[divmod32(uint32Array</span><span class="s0">, </span><span class="s1">base)] + output</span><span class="s0">;</span>
  <span class="s1">}</span>

  <span class="s0">return </span><span class="s1">output</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">let </span><span class="s1">crypto = undefined</span><span class="s0">;</span>
<span class="s0">let </span><span class="s1">createXXHash64 = undefined</span><span class="s0">;</span>
<span class="s0">let </span><span class="s1">createMd4 = undefined</span><span class="s0">;</span>
<span class="s0">let </span><span class="s1">BatchedHash = undefined</span><span class="s0">;</span>
<span class="s0">let </span><span class="s1">BulkUpdateDecorator = undefined</span><span class="s0">;</span>

<span class="s0">function </span><span class="s1">getHashDigest$1(buffer</span><span class="s0">, </span><span class="s1">algorithm</span><span class="s0">, </span><span class="s1">digestType</span><span class="s0">, </span><span class="s1">maxLength) {</span>
  <span class="s1">algorithm = algorithm || </span><span class="s2">&quot;xxhash64&quot;</span><span class="s0">;</span>
  <span class="s1">maxLength = maxLength || </span><span class="s3">9999</span><span class="s0">;</span>

  <span class="s0">let </span><span class="s1">hash</span><span class="s0">;</span>

  <span class="s0">if </span><span class="s1">(algorithm === </span><span class="s2">&quot;xxhash64&quot;</span><span class="s1">) {</span>
    <span class="s0">if </span><span class="s1">(createXXHash64 === undefined) {</span>
      <span class="s1">createXXHash64 = requireXxhash64()</span><span class="s0">;</span>

      <span class="s0">if </span><span class="s1">(BatchedHash === undefined) {</span>
        <span class="s1">BatchedHash = requireBatchedHash()</span><span class="s0">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">hash = </span><span class="s0">new </span><span class="s1">BatchedHash(createXXHash64())</span><span class="s0">;</span>
  <span class="s1">} </span><span class="s0">else if </span><span class="s1">(algorithm === </span><span class="s2">&quot;md4&quot;</span><span class="s1">) {</span>
    <span class="s0">if </span><span class="s1">(createMd4 === undefined) {</span>
      <span class="s1">createMd4 = requireMd4()</span><span class="s0">;</span>

      <span class="s0">if </span><span class="s1">(BatchedHash === undefined) {</span>
        <span class="s1">BatchedHash = requireBatchedHash()</span><span class="s0">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">hash = </span><span class="s0">new </span><span class="s1">BatchedHash(createMd4())</span><span class="s0">;</span>
  <span class="s1">} </span><span class="s0">else if </span><span class="s1">(algorithm === </span><span class="s2">&quot;native-md4&quot;</span><span class="s1">) {</span>
    <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">crypto === </span><span class="s2">&quot;undefined&quot;</span><span class="s1">) {</span>
      <span class="s1">crypto = require$$5</span><span class="s0">;</span>

      <span class="s0">if </span><span class="s1">(BulkUpdateDecorator === undefined) {</span>
        <span class="s1">BulkUpdateDecorator = requireBulkUpdateDecorator()</span><span class="s0">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">hash = </span><span class="s0">new </span><span class="s1">BulkUpdateDecorator(() =&gt; crypto.createHash(</span><span class="s2">&quot;md4&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s2">&quot;md4&quot;</span><span class="s1">)</span><span class="s0">;</span>
  <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
    <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">crypto === </span><span class="s2">&quot;undefined&quot;</span><span class="s1">) {</span>
      <span class="s1">crypto = require$$5</span><span class="s0">;</span>

      <span class="s0">if </span><span class="s1">(BulkUpdateDecorator === undefined) {</span>
        <span class="s1">BulkUpdateDecorator = requireBulkUpdateDecorator()</span><span class="s0">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">hash = </span><span class="s0">new </span><span class="s1">BulkUpdateDecorator(</span>
      <span class="s1">() =&gt; crypto.createHash(algorithm)</span><span class="s0">,</span>
      <span class="s1">algorithm</span>
    <span class="s1">)</span><span class="s0">;</span>
  <span class="s1">}</span>

  <span class="s1">hash.update(buffer)</span><span class="s0">;</span>

  <span class="s0">if </span><span class="s1">(</span>
    <span class="s1">digestType === </span><span class="s2">&quot;base26&quot; </span><span class="s1">||</span>
    <span class="s1">digestType === </span><span class="s2">&quot;base32&quot; </span><span class="s1">||</span>
    <span class="s1">digestType === </span><span class="s2">&quot;base36&quot; </span><span class="s1">||</span>
    <span class="s1">digestType === </span><span class="s2">&quot;base49&quot; </span><span class="s1">||</span>
    <span class="s1">digestType === </span><span class="s2">&quot;base52&quot; </span><span class="s1">||</span>
    <span class="s1">digestType === </span><span class="s2">&quot;base58&quot; </span><span class="s1">||</span>
    <span class="s1">digestType === </span><span class="s2">&quot;base62&quot;</span>
  <span class="s1">) {</span>
    <span class="s0">return </span><span class="s1">encodeBufferToBase(hash.digest()</span><span class="s0">, </span><span class="s1">digestType.substr(</span><span class="s3">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">maxLength)</span><span class="s0">;</span>
  <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
    <span class="s0">return </span><span class="s1">hash.digest(digestType || </span><span class="s2">&quot;hex&quot;</span><span class="s1">).substr(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">maxLength)</span><span class="s0">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">var </span><span class="s1">getHashDigest_1 = getHashDigest$1</span><span class="s0">;</span>

<span class="s0">const </span><span class="s1">path$1 = require$$0$1</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">getHashDigest = getHashDigest_1</span><span class="s0">;</span>

<span class="s0">function </span><span class="s1">interpolateName$1(loaderContext</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">options = {}) {</span>
  <span class="s0">let </span><span class="s1">filename</span><span class="s0">;</span>

  <span class="s0">const </span><span class="s1">hasQuery =</span>
    <span class="s1">loaderContext.resourceQuery &amp;&amp; loaderContext.resourceQuery.length &gt; </span><span class="s3">1</span><span class="s0">;</span>

  <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">name === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
    <span class="s1">filename = name(</span>
      <span class="s1">loaderContext.resourcePath</span><span class="s0">,</span>
      <span class="s1">hasQuery ? loaderContext.resourceQuery : undefined</span>
    <span class="s1">)</span><span class="s0">;</span>
  <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
    <span class="s1">filename = name || </span><span class="s2">&quot;[hash].[ext]&quot;</span><span class="s0">;</span>
  <span class="s1">}</span>

  <span class="s0">const </span><span class="s1">context = options.context</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">content = options.content</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">regExp = options.regExp</span><span class="s0">;</span>

  <span class="s0">let </span><span class="s1">ext = </span><span class="s2">&quot;bin&quot;</span><span class="s0">;</span>
  <span class="s0">let </span><span class="s1">basename = </span><span class="s2">&quot;file&quot;</span><span class="s0">;</span>
  <span class="s0">let </span><span class="s1">directory = </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
  <span class="s0">let </span><span class="s1">folder = </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
  <span class="s0">let </span><span class="s1">query = </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>

  <span class="s0">if </span><span class="s1">(loaderContext.resourcePath) {</span>
    <span class="s0">const </span><span class="s1">parsed = path$1.parse(loaderContext.resourcePath)</span><span class="s0">;</span>
    <span class="s0">let </span><span class="s1">resourcePath = loaderContext.resourcePath</span><span class="s0">;</span>

    <span class="s0">if </span><span class="s1">(parsed.ext) {</span>
      <span class="s1">ext = parsed.ext.substr(</span><span class="s3">1</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s1">}</span>

    <span class="s0">if </span><span class="s1">(parsed.dir) {</span>
      <span class="s1">basename = parsed.name</span><span class="s0">;</span>
      <span class="s1">resourcePath = parsed.dir + path$1.sep</span><span class="s0">;</span>
    <span class="s1">}</span>

    <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">context !== </span><span class="s2">&quot;undefined&quot;</span><span class="s1">) {</span>
      <span class="s1">directory = path$1</span>
        <span class="s1">.relative(context</span><span class="s0">, </span><span class="s1">resourcePath + </span><span class="s2">&quot;_&quot;</span><span class="s1">)</span>
        <span class="s1">.replace(</span><span class="s3">/\\/g</span><span class="s0">, </span><span class="s2">&quot;/&quot;</span><span class="s1">)</span>
        <span class="s1">.replace(</span><span class="s3">/\.\.(\/)?/g</span><span class="s0">, </span><span class="s2">&quot;_$1&quot;</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s1">directory = directory.substr(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">directory.length - </span><span class="s3">1</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
      <span class="s1">directory = resourcePath.replace(</span><span class="s3">/\\/g</span><span class="s0">, </span><span class="s2">&quot;/&quot;</span><span class="s1">).replace(</span><span class="s3">/\.\.(\/)?/g</span><span class="s0">, </span><span class="s2">&quot;_$1&quot;</span><span class="s1">)</span><span class="s0">;</span>
    <span class="s1">}</span>

    <span class="s0">if </span><span class="s1">(directory.length === </span><span class="s3">1</span><span class="s1">) {</span>
      <span class="s1">directory = </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
    <span class="s1">} </span><span class="s0">else if </span><span class="s1">(directory.length &gt; </span><span class="s3">1</span><span class="s1">) {</span>
      <span class="s1">folder = path$1.basename(directory)</span><span class="s0">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">if </span><span class="s1">(loaderContext.resourceQuery &amp;&amp; loaderContext.resourceQuery.length &gt; </span><span class="s3">1</span><span class="s1">) {</span>
    <span class="s1">query = loaderContext.resourceQuery</span><span class="s0">;</span>

    <span class="s0">const </span><span class="s1">hashIdx = query.indexOf(</span><span class="s2">&quot;#&quot;</span><span class="s1">)</span><span class="s0">;</span>

    <span class="s0">if </span><span class="s1">(hashIdx &gt;= </span><span class="s3">0</span><span class="s1">) {</span>
      <span class="s1">query = query.substr(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">hashIdx)</span><span class="s0">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">let </span><span class="s1">url = filename</span><span class="s0">;</span>

  <span class="s0">if </span><span class="s1">(content) {</span>
    <span class="s4">// Match hash template</span>
    <span class="s1">url = url</span>
      <span class="s4">// `hash` and `contenthash` are same in `loader-utils` context</span>
      <span class="s4">// let's keep `hash` for backward compatibility</span>
      <span class="s1">.replace(</span>
        <span class="s3">/\[(?:([^:\]]+):)?(?:hash|contenthash)(?::([a-z]+\d*))?(?::(\d+))?\]/gi</span><span class="s0">,</span>
        <span class="s1">(all</span><span class="s0">, </span><span class="s1">hashType</span><span class="s0">, </span><span class="s1">digestType</span><span class="s0">, </span><span class="s1">maxLength) =&gt;</span>
          <span class="s1">getHashDigest(content</span><span class="s0">, </span><span class="s1">hashType</span><span class="s0">, </span><span class="s1">digestType</span><span class="s0">, </span><span class="s1">parseInt(maxLength</span><span class="s0">, </span><span class="s3">10</span><span class="s1">))</span>
      <span class="s1">)</span><span class="s0">;</span>
  <span class="s1">}</span>

  <span class="s1">url = url</span>
    <span class="s1">.replace(</span><span class="s3">/\[ext\]/gi</span><span class="s0">, </span><span class="s1">() =&gt; ext)</span>
    <span class="s1">.replace(</span><span class="s3">/\[name\]/gi</span><span class="s0">, </span><span class="s1">() =&gt; basename)</span>
    <span class="s1">.replace(</span><span class="s3">/\[path\]/gi</span><span class="s0">, </span><span class="s1">() =&gt; directory)</span>
    <span class="s1">.replace(</span><span class="s3">/\[folder\]/gi</span><span class="s0">, </span><span class="s1">() =&gt; folder)</span>
    <span class="s1">.replace(</span><span class="s3">/\[query\]/gi</span><span class="s0">, </span><span class="s1">() =&gt; query)</span><span class="s0">;</span>

  <span class="s0">if </span><span class="s1">(regExp &amp;&amp; loaderContext.resourcePath) {</span>
    <span class="s0">const </span><span class="s1">match = loaderContext.resourcePath.match(</span><span class="s0">new </span><span class="s1">RegExp(regExp))</span><span class="s0">;</span>

    <span class="s1">match &amp;&amp;</span>
      <span class="s1">match.forEach((matched</span><span class="s0">, </span><span class="s1">i) =&gt; {</span>
        <span class="s1">url = url.replace(</span><span class="s0">new </span><span class="s1">RegExp(</span><span class="s2">&quot;</span><span class="s0">\\</span><span class="s2">[&quot; </span><span class="s1">+ i + </span><span class="s2">&quot;</span><span class="s0">\\</span><span class="s2">]&quot;</span><span class="s0">, </span><span class="s2">&quot;ig&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">matched)</span><span class="s0">;</span>
      <span class="s1">})</span><span class="s0">;</span>
  <span class="s1">}</span>

  <span class="s0">if </span><span class="s1">(</span>
    <span class="s0">typeof </span><span class="s1">loaderContext.options === </span><span class="s2">&quot;object&quot; </span><span class="s1">&amp;&amp;</span>
    <span class="s0">typeof </span><span class="s1">loaderContext.options.customInterpolateName === </span><span class="s2">&quot;function&quot;</span>
  <span class="s1">) {</span>
    <span class="s1">url = loaderContext.options.customInterpolateName.call(</span>
      <span class="s1">loaderContext</span><span class="s0">,</span>
      <span class="s1">url</span><span class="s0">,</span>
      <span class="s1">name</span><span class="s0">,</span>
      <span class="s1">options</span>
    <span class="s1">)</span><span class="s0">;</span>
  <span class="s1">}</span>

  <span class="s0">return </span><span class="s1">url</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">var </span><span class="s1">interpolateName_1 = interpolateName$1</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">interpolateName = interpolateName_1</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">path = require$$0$1</span><span class="s0">;</span>

<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@param  </span><span class="s5">{string} pattern</span>
 <span class="s5">* </span><span class="s6">@param  </span><span class="s5">{object} options</span>
 <span class="s5">* </span><span class="s6">@param  </span><span class="s5">{string} options.context</span>
 <span class="s5">* </span><span class="s6">@param  </span><span class="s5">{string} options.hashPrefix</span>
 <span class="s5">* </span><span class="s6">@return </span><span class="s5">{function}</span>
 <span class="s5">*/</span>
<span class="s0">var </span><span class="s1">genericNames = </span><span class="s0">function </span><span class="s1">createGenerator(pattern</span><span class="s0">, </span><span class="s1">options) {</span>
  <span class="s1">options = options || {}</span><span class="s0">;</span>
  <span class="s0">var </span><span class="s1">context =</span>
    <span class="s1">options &amp;&amp; </span><span class="s0">typeof </span><span class="s1">options.context === </span><span class="s2">&quot;string&quot;</span>
      <span class="s1">? options.context</span>
      <span class="s1">: process.cwd()</span><span class="s0">;</span>
  <span class="s0">var </span><span class="s1">hashPrefix =</span>
    <span class="s1">options &amp;&amp; </span><span class="s0">typeof </span><span class="s1">options.hashPrefix === </span><span class="s2">&quot;string&quot; </span><span class="s1">? options.hashPrefix : </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>

  <span class="s5">/**</span>
   <span class="s5">* </span><span class="s6">@param  </span><span class="s5">{string} localName Usually a class name</span>
   <span class="s5">* </span><span class="s6">@param  </span><span class="s5">{string} filepath  Absolute path</span>
   <span class="s5">* </span><span class="s6">@return </span><span class="s5">{string}</span>
   <span class="s5">*/</span>
  <span class="s0">return function </span><span class="s1">generate(localName</span><span class="s0">, </span><span class="s1">filepath) {</span>
    <span class="s0">var </span><span class="s1">name = pattern.replace(</span><span class="s3">/\[local\]/gi</span><span class="s0">, </span><span class="s1">localName)</span><span class="s0">;</span>
    <span class="s0">var </span><span class="s1">loaderContext = {</span>
      <span class="s1">resourcePath: filepath</span><span class="s0">,</span>
    <span class="s1">}</span><span class="s0">;</span>

    <span class="s0">var </span><span class="s1">loaderOptions = {</span>
      <span class="s1">content:</span>
        <span class="s1">hashPrefix +</span>
        <span class="s1">path.relative(context</span><span class="s0">, </span><span class="s1">filepath).replace(</span><span class="s3">/\\/g</span><span class="s0">, </span><span class="s2">&quot;/&quot;</span><span class="s1">) +</span>
        <span class="s2">&quot;</span><span class="s0">\x00</span><span class="s2">&quot; </span><span class="s1">+</span>
        <span class="s1">localName</span><span class="s0">,</span>
      <span class="s1">context: context</span><span class="s0">,</span>
    <span class="s1">}</span><span class="s0">;</span>

    <span class="s0">var </span><span class="s1">genericName = interpolateName(loaderContext</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">loaderOptions)</span><span class="s0">;</span>
    <span class="s0">return </span><span class="s1">genericName</span>
      <span class="s1">.replace(</span><span class="s0">new </span><span class="s1">RegExp(</span><span class="s2">&quot;[^a-zA-Z0-9</span><span class="s0">\\</span><span class="s2">-_</span><span class="s0">\u00A0</span><span class="s2">-</span><span class="s0">\uFFFF</span><span class="s2">]&quot;</span><span class="s0">, </span><span class="s2">&quot;g&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s2">&quot;-&quot;</span><span class="s1">)</span>
      <span class="s1">.replace(</span><span class="s3">/^((-?[0-9])|--)/</span><span class="s0">, </span><span class="s2">&quot;_$1&quot;</span><span class="s1">)</span><span class="s0">;</span>
  <span class="s1">}</span><span class="s0">;</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">srcExports$1 = {}</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">src$2 = {</span>
  <span class="s1">get exports(){ </span><span class="s0">return </span><span class="s1">srcExports$1</span><span class="s0">; </span><span class="s1">}</span><span class="s0">,</span>
  <span class="s1">set exports(v){ srcExports$1 = v</span><span class="s0">; </span><span class="s1">}</span><span class="s0">,</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">distExports = {}</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">dist = {</span>
  <span class="s1">get exports(){ </span><span class="s0">return </span><span class="s1">distExports</span><span class="s0">; </span><span class="s1">}</span><span class="s0">,</span>
  <span class="s1">set exports(v){ distExports = v</span><span class="s0">; </span><span class="s1">}</span><span class="s0">,</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">processorExports = {}</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">processor = {</span>
  <span class="s1">get exports(){ </span><span class="s0">return </span><span class="s1">processorExports</span><span class="s0">; </span><span class="s1">}</span><span class="s0">,</span>
  <span class="s1">set exports(v){ processorExports = v</span><span class="s0">; </span><span class="s1">}</span><span class="s0">,</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">parserExports = {}</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">parser = {</span>
  <span class="s1">get exports(){ </span><span class="s0">return </span><span class="s1">parserExports</span><span class="s0">; </span><span class="s1">}</span><span class="s0">,</span>
  <span class="s1">set exports(v){ parserExports = v</span><span class="s0">; </span><span class="s1">}</span><span class="s0">,</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">rootExports = {}</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">root$1 = {</span>
  <span class="s1">get exports(){ </span><span class="s0">return </span><span class="s1">rootExports</span><span class="s0">; </span><span class="s1">}</span><span class="s0">,</span>
  <span class="s1">set exports(v){ rootExports = v</span><span class="s0">; </span><span class="s1">}</span><span class="s0">,</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">containerExports = {}</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">container = {</span>
  <span class="s1">get exports(){ </span><span class="s0">return </span><span class="s1">containerExports</span><span class="s0">; </span><span class="s1">}</span><span class="s0">,</span>
  <span class="s1">set exports(v){ containerExports = v</span><span class="s0">; </span><span class="s1">}</span><span class="s0">,</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">nodeExports = {}</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">node$1 = {</span>
  <span class="s1">get exports(){ </span><span class="s0">return </span><span class="s1">nodeExports</span><span class="s0">; </span><span class="s1">}</span><span class="s0">,</span>
  <span class="s1">set exports(v){ nodeExports = v</span><span class="s0">; </span><span class="s1">}</span><span class="s0">,</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">util = {}</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">unescExports = {}</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">unesc = {</span>
  <span class="s1">get exports(){ </span><span class="s0">return </span><span class="s1">unescExports</span><span class="s0">; </span><span class="s1">}</span><span class="s0">,</span>
  <span class="s1">set exports(v){ unescExports = v</span><span class="s0">; </span><span class="s1">}</span><span class="s0">,</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s1">(</span><span class="s0">function </span><span class="s1">(module</span><span class="s0">, </span><span class="s1">exports) {</span>

	<span class="s1">exports.__esModule = </span><span class="s0">true;</span>
	<span class="s1">exports[</span><span class="s2">&quot;default&quot;</span><span class="s1">] = unesc</span><span class="s0">;</span>

	<span class="s4">// Many thanks for this post which made this migration much easier.</span>
	<span class="s4">// https://mathiasbynens.be/notes/css-escapes</span>

	<span class="s5">/**</span>
	 <span class="s5">* </span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string} str </span>
	 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{[string, number]|undefined}</span>
	 <span class="s5">*/</span>
	<span class="s0">function </span><span class="s1">gobbleHex(str) {</span>
	  <span class="s0">var </span><span class="s1">lower = str.toLowerCase()</span><span class="s0">;</span>
	  <span class="s0">var </span><span class="s1">hex = </span><span class="s2">''</span><span class="s0">;</span>
	  <span class="s0">var </span><span class="s1">spaceTerminated = </span><span class="s0">false;</span>

	  <span class="s0">for </span><span class="s1">(</span><span class="s0">var </span><span class="s1">i = </span><span class="s3">0</span><span class="s0">; </span><span class="s1">i &lt; </span><span class="s3">6 </span><span class="s1">&amp;&amp; lower[i] !== undefined</span><span class="s0">; </span><span class="s1">i++) {</span>
	    <span class="s0">var </span><span class="s1">code = lower.charCodeAt(i)</span><span class="s0">; </span><span class="s4">// check to see if we are dealing with a valid hex char [a-f|0-9]</span>

	    <span class="s0">var </span><span class="s1">valid = code &gt;= </span><span class="s3">97 </span><span class="s1">&amp;&amp; code &lt;= </span><span class="s3">102 </span><span class="s1">|| code &gt;= </span><span class="s3">48 </span><span class="s1">&amp;&amp; code &lt;= </span><span class="s3">57</span><span class="s0">; </span><span class="s4">// https://drafts.csswg.org/css-syntax/#consume-escaped-code-point</span>

	    <span class="s1">spaceTerminated = code === </span><span class="s3">32</span><span class="s0">;</span>

	    <span class="s0">if </span><span class="s1">(!valid) {</span>
	      <span class="s0">break;</span>
	    <span class="s1">}</span>

	    <span class="s1">hex += lower[i]</span><span class="s0">;</span>
	  <span class="s1">}</span>

	  <span class="s0">if </span><span class="s1">(hex.length === </span><span class="s3">0</span><span class="s1">) {</span>
	    <span class="s0">return </span><span class="s1">undefined</span><span class="s0">;</span>
	  <span class="s1">}</span>

	  <span class="s0">var </span><span class="s1">codePoint = parseInt(hex</span><span class="s0">, </span><span class="s3">16</span><span class="s1">)</span><span class="s0">;</span>
	  <span class="s0">var </span><span class="s1">isSurrogate = codePoint &gt;= </span><span class="s3">0xD800 </span><span class="s1">&amp;&amp; codePoint &lt;= </span><span class="s3">0xDFFF</span><span class="s0">; </span><span class="s4">// Add special case for</span>
	  <span class="s4">// &quot;If this number is zero, or is for a surrogate, or is greater than the maximum allowed code point&quot;</span>
	  <span class="s4">// https://drafts.csswg.org/css-syntax/#maximum-allowed-code-point</span>

	  <span class="s0">if </span><span class="s1">(isSurrogate || codePoint === </span><span class="s3">0x0000 </span><span class="s1">|| codePoint &gt; </span><span class="s3">0x10FFFF</span><span class="s1">) {</span>
	    <span class="s0">return </span><span class="s1">[</span><span class="s2">&quot;</span><span class="s0">\uFFFD</span><span class="s2">&quot;</span><span class="s0">, </span><span class="s1">hex.length + (spaceTerminated ? </span><span class="s3">1 </span><span class="s1">: </span><span class="s3">0</span><span class="s1">)]</span><span class="s0">;</span>
	  <span class="s1">}</span>

	  <span class="s0">return </span><span class="s1">[String.fromCodePoint(codePoint)</span><span class="s0">, </span><span class="s1">hex.length + (spaceTerminated ? </span><span class="s3">1 </span><span class="s1">: </span><span class="s3">0</span><span class="s1">)]</span><span class="s0">;</span>
	<span class="s1">}</span>

	<span class="s0">var </span><span class="s1">CONTAINS_ESCAPE = </span><span class="s3">/\\/</span><span class="s0">;</span>

	<span class="s0">function </span><span class="s1">unesc(str) {</span>
	  <span class="s0">var </span><span class="s1">needToProcess = CONTAINS_ESCAPE.test(str)</span><span class="s0">;</span>

	  <span class="s0">if </span><span class="s1">(!needToProcess) {</span>
	    <span class="s0">return </span><span class="s1">str</span><span class="s0">;</span>
	  <span class="s1">}</span>

	  <span class="s0">var </span><span class="s1">ret = </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>

	  <span class="s0">for </span><span class="s1">(</span><span class="s0">var </span><span class="s1">i = </span><span class="s3">0</span><span class="s0">; </span><span class="s1">i &lt; str.length</span><span class="s0">; </span><span class="s1">i++) {</span>
	    <span class="s0">if </span><span class="s1">(str[i] === </span><span class="s2">&quot;</span><span class="s0">\\</span><span class="s2">&quot;</span><span class="s1">) {</span>
	      <span class="s0">var </span><span class="s1">gobbled = gobbleHex(str.slice(i + </span><span class="s3">1</span><span class="s0">, </span><span class="s1">i + </span><span class="s3">7</span><span class="s1">))</span><span class="s0">;</span>

	      <span class="s0">if </span><span class="s1">(gobbled !== undefined) {</span>
	        <span class="s1">ret += gobbled[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">;</span>
	        <span class="s1">i += gobbled[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">;</span>
	        <span class="s0">continue;</span>
	      <span class="s1">} </span><span class="s4">// Retain a pair of \\ if double escaped `\\\\`</span>
	      <span class="s4">// https://github.com/postcss/postcss-selector-parser/commit/268c9a7656fb53f543dc620aa5b73a30ec3ff20e</span>


	      <span class="s0">if </span><span class="s1">(str[i + </span><span class="s3">1</span><span class="s1">] === </span><span class="s2">&quot;</span><span class="s0">\\</span><span class="s2">&quot;</span><span class="s1">) {</span>
	        <span class="s1">ret += </span><span class="s2">&quot;</span><span class="s0">\\</span><span class="s2">&quot;</span><span class="s0">;</span>
	        <span class="s1">i++</span><span class="s0">;</span>
	        <span class="s0">continue;</span>
	      <span class="s1">} </span><span class="s4">// if \\ is at the end of the string retain it</span>
	      <span class="s4">// https://github.com/postcss/postcss-selector-parser/commit/01a6b346e3612ce1ab20219acc26abdc259ccefb</span>


	      <span class="s0">if </span><span class="s1">(str.length === i + </span><span class="s3">1</span><span class="s1">) {</span>
	        <span class="s1">ret += str[i]</span><span class="s0">;</span>
	      <span class="s1">}</span>

	      <span class="s0">continue;</span>
	    <span class="s1">}</span>

	    <span class="s1">ret += str[i]</span><span class="s0">;</span>
	  <span class="s1">}</span>

	  <span class="s0">return </span><span class="s1">ret</span><span class="s0">;</span>
	<span class="s1">}</span>

	<span class="s1">module.exports = exports.default</span><span class="s0">;</span>
<span class="s1">} (unesc</span><span class="s0">, </span><span class="s1">unescExports))</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">getPropExports = {}</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">getProp = {</span>
  <span class="s1">get exports(){ </span><span class="s0">return </span><span class="s1">getPropExports</span><span class="s0">; </span><span class="s1">}</span><span class="s0">,</span>
  <span class="s1">set exports(v){ getPropExports = v</span><span class="s0">; </span><span class="s1">}</span><span class="s0">,</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s1">(</span><span class="s0">function </span><span class="s1">(module</span><span class="s0">, </span><span class="s1">exports) {</span>

	<span class="s1">exports.__esModule = </span><span class="s0">true;</span>
	<span class="s1">exports[</span><span class="s2">&quot;default&quot;</span><span class="s1">] = getProp</span><span class="s0">;</span>

	<span class="s0">function </span><span class="s1">getProp(obj) {</span>
	  <span class="s0">for </span><span class="s1">(</span><span class="s0">var </span><span class="s1">_len = arguments.length</span><span class="s0">, </span><span class="s1">props = </span><span class="s0">new </span><span class="s1">Array(_len &gt; </span><span class="s3">1 </span><span class="s1">? _len - </span><span class="s3">1 </span><span class="s1">: </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">_key = </span><span class="s3">1</span><span class="s0">; </span><span class="s1">_key &lt; _len</span><span class="s0">; </span><span class="s1">_key++) {</span>
	    <span class="s1">props[_key - </span><span class="s3">1</span><span class="s1">] = arguments[_key]</span><span class="s0">;</span>
	  <span class="s1">}</span>

	  <span class="s0">while </span><span class="s1">(props.length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
	    <span class="s0">var </span><span class="s1">prop = props.shift()</span><span class="s0">;</span>

	    <span class="s0">if </span><span class="s1">(!obj[prop]) {</span>
	      <span class="s0">return </span><span class="s1">undefined</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s1">obj = obj[prop]</span><span class="s0">;</span>
	  <span class="s1">}</span>

	  <span class="s0">return </span><span class="s1">obj</span><span class="s0">;</span>
	<span class="s1">}</span>

	<span class="s1">module.exports = exports.default</span><span class="s0">;</span>
<span class="s1">} (getProp</span><span class="s0">, </span><span class="s1">getPropExports))</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">ensureObjectExports = {}</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">ensureObject = {</span>
  <span class="s1">get exports(){ </span><span class="s0">return </span><span class="s1">ensureObjectExports</span><span class="s0">; </span><span class="s1">}</span><span class="s0">,</span>
  <span class="s1">set exports(v){ ensureObjectExports = v</span><span class="s0">; </span><span class="s1">}</span><span class="s0">,</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s1">(</span><span class="s0">function </span><span class="s1">(module</span><span class="s0">, </span><span class="s1">exports) {</span>

	<span class="s1">exports.__esModule = </span><span class="s0">true;</span>
	<span class="s1">exports[</span><span class="s2">&quot;default&quot;</span><span class="s1">] = ensureObject</span><span class="s0">;</span>

	<span class="s0">function </span><span class="s1">ensureObject(obj) {</span>
	  <span class="s0">for </span><span class="s1">(</span><span class="s0">var </span><span class="s1">_len = arguments.length</span><span class="s0">, </span><span class="s1">props = </span><span class="s0">new </span><span class="s1">Array(_len &gt; </span><span class="s3">1 </span><span class="s1">? _len - </span><span class="s3">1 </span><span class="s1">: </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">_key = </span><span class="s3">1</span><span class="s0">; </span><span class="s1">_key &lt; _len</span><span class="s0">; </span><span class="s1">_key++) {</span>
	    <span class="s1">props[_key - </span><span class="s3">1</span><span class="s1">] = arguments[_key]</span><span class="s0">;</span>
	  <span class="s1">}</span>

	  <span class="s0">while </span><span class="s1">(props.length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
	    <span class="s0">var </span><span class="s1">prop = props.shift()</span><span class="s0">;</span>

	    <span class="s0">if </span><span class="s1">(!obj[prop]) {</span>
	      <span class="s1">obj[prop] = {}</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s1">obj = obj[prop]</span><span class="s0">;</span>
	  <span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s1">module.exports = exports.default</span><span class="s0">;</span>
<span class="s1">} (ensureObject</span><span class="s0">, </span><span class="s1">ensureObjectExports))</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">stripCommentsExports = {}</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">stripComments = {</span>
  <span class="s1">get exports(){ </span><span class="s0">return </span><span class="s1">stripCommentsExports</span><span class="s0">; </span><span class="s1">}</span><span class="s0">,</span>
  <span class="s1">set exports(v){ stripCommentsExports = v</span><span class="s0">; </span><span class="s1">}</span><span class="s0">,</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s1">(</span><span class="s0">function </span><span class="s1">(module</span><span class="s0">, </span><span class="s1">exports) {</span>

	<span class="s1">exports.__esModule = </span><span class="s0">true;</span>
	<span class="s1">exports[</span><span class="s2">&quot;default&quot;</span><span class="s1">] = stripComments</span><span class="s0">;</span>

	<span class="s0">function </span><span class="s1">stripComments(str) {</span>
	  <span class="s0">var </span><span class="s1">s = </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
	  <span class="s0">var </span><span class="s1">commentStart = str.indexOf(</span><span class="s2">&quot;/*&quot;</span><span class="s1">)</span><span class="s0">;</span>
	  <span class="s0">var </span><span class="s1">lastEnd = </span><span class="s3">0</span><span class="s0">;</span>

	  <span class="s0">while </span><span class="s1">(commentStart &gt;= </span><span class="s3">0</span><span class="s1">) {</span>
	    <span class="s1">s = s + str.slice(lastEnd</span><span class="s0">, </span><span class="s1">commentStart)</span><span class="s0">;</span>
	    <span class="s0">var </span><span class="s1">commentEnd = str.indexOf(</span><span class="s2">&quot;*/&quot;</span><span class="s0">, </span><span class="s1">commentStart + </span><span class="s3">2</span><span class="s1">)</span><span class="s0">;</span>

	    <span class="s0">if </span><span class="s1">(commentEnd &lt; </span><span class="s3">0</span><span class="s1">) {</span>
	      <span class="s0">return </span><span class="s1">s</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s1">lastEnd = commentEnd + </span><span class="s3">2</span><span class="s0">;</span>
	    <span class="s1">commentStart = str.indexOf(</span><span class="s2">&quot;/*&quot;</span><span class="s0">, </span><span class="s1">lastEnd)</span><span class="s0">;</span>
	  <span class="s1">}</span>

	  <span class="s1">s = s + str.slice(lastEnd)</span><span class="s0">;</span>
	  <span class="s0">return </span><span class="s1">s</span><span class="s0">;</span>
	<span class="s1">}</span>

	<span class="s1">module.exports = exports.default</span><span class="s0">;</span>
<span class="s1">} (stripComments</span><span class="s0">, </span><span class="s1">stripCommentsExports))</span><span class="s0">;</span>

<span class="s1">util.__esModule = </span><span class="s0">true;</span>
<span class="s1">util.stripComments = util.ensureObject = util.getProp = util.unesc = </span><span class="s0">void </span><span class="s3">0</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">_unesc = _interopRequireDefault$3(unescExports)</span><span class="s0">;</span>

<span class="s1">util.unesc = _unesc[</span><span class="s2">&quot;default&quot;</span><span class="s1">]</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">_getProp = _interopRequireDefault$3(getPropExports)</span><span class="s0">;</span>

<span class="s1">util.getProp = _getProp[</span><span class="s2">&quot;default&quot;</span><span class="s1">]</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">_ensureObject = _interopRequireDefault$3(ensureObjectExports)</span><span class="s0">;</span>

<span class="s1">util.ensureObject = _ensureObject[</span><span class="s2">&quot;default&quot;</span><span class="s1">]</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">_stripComments = _interopRequireDefault$3(stripCommentsExports)</span><span class="s0">;</span>

<span class="s1">util.stripComments = _stripComments[</span><span class="s2">&quot;default&quot;</span><span class="s1">]</span><span class="s0">;</span>

<span class="s0">function </span><span class="s1">_interopRequireDefault$3(obj) { </span><span class="s0">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : { </span><span class="s2">&quot;default&quot;</span><span class="s1">: obj }</span><span class="s0">; </span><span class="s1">}</span>

<span class="s1">(</span><span class="s0">function </span><span class="s1">(module</span><span class="s0">, </span><span class="s1">exports) {</span>

	<span class="s1">exports.__esModule = </span><span class="s0">true;</span>
	<span class="s1">exports[</span><span class="s2">&quot;default&quot;</span><span class="s1">] = </span><span class="s0">void </span><span class="s3">0</span><span class="s0">;</span>

	<span class="s0">var </span><span class="s1">_util = util</span><span class="s0">;</span>

	<span class="s0">function </span><span class="s1">_defineProperties(target</span><span class="s0">, </span><span class="s1">props) { </span><span class="s0">for </span><span class="s1">(</span><span class="s0">var </span><span class="s1">i = </span><span class="s3">0</span><span class="s0">; </span><span class="s1">i &lt; props.length</span><span class="s0">; </span><span class="s1">i++) { </span><span class="s0">var </span><span class="s1">descriptor = props[i]</span><span class="s0">; </span><span class="s1">descriptor.enumerable = descriptor.enumerable || </span><span class="s0">false; </span><span class="s1">descriptor.configurable = </span><span class="s0">true; if </span><span class="s1">(</span><span class="s2">&quot;value&quot; </span><span class="s0">in </span><span class="s1">descriptor) descriptor.writable = </span><span class="s0">true; </span><span class="s1">Object.defineProperty(target</span><span class="s0">, </span><span class="s1">descriptor.key</span><span class="s0">, </span><span class="s1">descriptor)</span><span class="s0">; </span><span class="s1">} }</span>

	<span class="s0">function </span><span class="s1">_createClass(Constructor</span><span class="s0">, </span><span class="s1">protoProps</span><span class="s0">, </span><span class="s1">staticProps) { </span><span class="s0">if </span><span class="s1">(protoProps) _defineProperties(Constructor.prototype</span><span class="s0">, </span><span class="s1">protoProps)</span><span class="s0">; if </span><span class="s1">(staticProps) _defineProperties(Constructor</span><span class="s0">, </span><span class="s1">staticProps)</span><span class="s0">; return </span><span class="s1">Constructor</span><span class="s0">; </span><span class="s1">}</span>

	<span class="s0">var </span><span class="s1">cloneNode = </span><span class="s0">function </span><span class="s1">cloneNode(obj</span><span class="s0">, </span><span class="s1">parent) {</span>
	  <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">obj !== </span><span class="s2">'object' </span><span class="s1">|| obj === </span><span class="s0">null</span><span class="s1">) {</span>
	    <span class="s0">return </span><span class="s1">obj</span><span class="s0">;</span>
	  <span class="s1">}</span>

	  <span class="s0">var </span><span class="s1">cloned = </span><span class="s0">new </span><span class="s1">obj.constructor()</span><span class="s0">;</span>

	  <span class="s0">for </span><span class="s1">(</span><span class="s0">var </span><span class="s1">i </span><span class="s0">in </span><span class="s1">obj) {</span>
	    <span class="s0">if </span><span class="s1">(!obj.hasOwnProperty(i)) {</span>
	      <span class="s0">continue;</span>
	    <span class="s1">}</span>

	    <span class="s0">var </span><span class="s1">value = obj[i]</span><span class="s0">;</span>
	    <span class="s0">var </span><span class="s1">type = </span><span class="s0">typeof </span><span class="s1">value</span><span class="s0">;</span>

	    <span class="s0">if </span><span class="s1">(i === </span><span class="s2">'parent' </span><span class="s1">&amp;&amp; type === </span><span class="s2">'object'</span><span class="s1">) {</span>
	      <span class="s0">if </span><span class="s1">(parent) {</span>
	        <span class="s1">cloned[i] = parent</span><span class="s0">;</span>
	      <span class="s1">}</span>
	    <span class="s1">} </span><span class="s0">else if </span><span class="s1">(value </span><span class="s0">instanceof </span><span class="s1">Array) {</span>
	      <span class="s1">cloned[i] = value.map(</span><span class="s0">function </span><span class="s1">(j) {</span>
	        <span class="s0">return </span><span class="s1">cloneNode(j</span><span class="s0">, </span><span class="s1">cloned)</span><span class="s0">;</span>
	      <span class="s1">})</span><span class="s0">;</span>
	    <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
	      <span class="s1">cloned[i] = cloneNode(value</span><span class="s0">, </span><span class="s1">cloned)</span><span class="s0">;</span>
	    <span class="s1">}</span>
	  <span class="s1">}</span>

	  <span class="s0">return </span><span class="s1">cloned</span><span class="s0">;</span>
	<span class="s1">}</span><span class="s0">;</span>

	<span class="s0">var </span><span class="s1">Node = </span><span class="s4">/*#__PURE__*/</span><span class="s0">function </span><span class="s1">() {</span>
	  <span class="s0">function </span><span class="s1">Node(opts) {</span>
	    <span class="s0">if </span><span class="s1">(opts === </span><span class="s0">void </span><span class="s3">0</span><span class="s1">) {</span>
	      <span class="s1">opts = {}</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s1">Object.assign(</span><span class="s0">this, </span><span class="s1">opts)</span><span class="s0">;</span>
	    <span class="s0">this</span><span class="s1">.spaces = </span><span class="s0">this</span><span class="s1">.spaces || {}</span><span class="s0">;</span>
	    <span class="s0">this</span><span class="s1">.spaces.before = </span><span class="s0">this</span><span class="s1">.spaces.before || </span><span class="s2">''</span><span class="s0">;</span>
	    <span class="s0">this</span><span class="s1">.spaces.after = </span><span class="s0">this</span><span class="s1">.spaces.after || </span><span class="s2">''</span><span class="s0">;</span>
	  <span class="s1">}</span>

	  <span class="s0">var </span><span class="s1">_proto = Node.prototype</span><span class="s0">;</span>

	  <span class="s1">_proto.remove = </span><span class="s0">function </span><span class="s1">remove() {</span>
	    <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.parent) {</span>
	      <span class="s0">this</span><span class="s1">.parent.removeChild(</span><span class="s0">this</span><span class="s1">)</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">this</span><span class="s1">.parent = undefined</span><span class="s0">;</span>
	    <span class="s0">return this;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.replaceWith = </span><span class="s0">function </span><span class="s1">replaceWith() {</span>
	    <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.parent) {</span>
	      <span class="s0">for </span><span class="s1">(</span><span class="s0">var </span><span class="s1">index </span><span class="s0">in </span><span class="s1">arguments) {</span>
	        <span class="s0">this</span><span class="s1">.parent.insertBefore(</span><span class="s0">this, </span><span class="s1">arguments[index])</span><span class="s0">;</span>
	      <span class="s1">}</span>

	      <span class="s0">this</span><span class="s1">.remove()</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">return this;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.next = </span><span class="s0">function </span><span class="s1">next() {</span>
	    <span class="s0">return this</span><span class="s1">.parent.at(</span><span class="s0">this</span><span class="s1">.parent.index(</span><span class="s0">this</span><span class="s1">) + </span><span class="s3">1</span><span class="s1">)</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.prev = </span><span class="s0">function </span><span class="s1">prev() {</span>
	    <span class="s0">return this</span><span class="s1">.parent.at(</span><span class="s0">this</span><span class="s1">.parent.index(</span><span class="s0">this</span><span class="s1">) - </span><span class="s3">1</span><span class="s1">)</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.clone = </span><span class="s0">function </span><span class="s1">clone(overrides) {</span>
	    <span class="s0">if </span><span class="s1">(overrides === </span><span class="s0">void </span><span class="s3">0</span><span class="s1">) {</span>
	      <span class="s1">overrides = {}</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">var </span><span class="s1">cloned = cloneNode(</span><span class="s0">this</span><span class="s1">)</span><span class="s0">;</span>

	    <span class="s0">for </span><span class="s1">(</span><span class="s0">var </span><span class="s1">name </span><span class="s0">in </span><span class="s1">overrides) {</span>
	      <span class="s1">cloned[name] = overrides[name]</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">return </span><span class="s1">cloned</span><span class="s0">;</span>
	  <span class="s1">}</span>
	  <span class="s5">/**</span>
	   <span class="s5">* Some non-standard syntax doesn't follow normal escaping rules for css.</span>
	   <span class="s5">* This allows non standard syntax to be appended to an existing property</span>
	   <span class="s5">* by specifying the escaped value. By specifying the escaped value,</span>
	   <span class="s5">* illegal characters are allowed to be directly inserted into css output.</span>
	   <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string} name the property to set</span>
	   <span class="s5">* </span><span class="s6">@param </span><span class="s5">{any} value the unescaped value of the property</span>
	   <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string} valueEscaped optional. the escaped value of the property.</span>
	   <span class="s5">*/</span>
	  <span class="s0">;</span>

	  <span class="s1">_proto.appendToPropertyAndEscape = </span><span class="s0">function </span><span class="s1">appendToPropertyAndEscape(name</span><span class="s0">, </span><span class="s1">value</span><span class="s0">, </span><span class="s1">valueEscaped) {</span>
	    <span class="s0">if </span><span class="s1">(!</span><span class="s0">this</span><span class="s1">.raws) {</span>
	      <span class="s0">this</span><span class="s1">.raws = {}</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">var </span><span class="s1">originalValue = </span><span class="s0">this</span><span class="s1">[name]</span><span class="s0">;</span>
	    <span class="s0">var </span><span class="s1">originalEscaped = </span><span class="s0">this</span><span class="s1">.raws[name]</span><span class="s0">;</span>
	    <span class="s0">this</span><span class="s1">[name] = originalValue + value</span><span class="s0">; </span><span class="s4">// this may trigger a setter that updates raws, so it has to be set first.</span>

	    <span class="s0">if </span><span class="s1">(originalEscaped || valueEscaped !== value) {</span>
	      <span class="s0">this</span><span class="s1">.raws[name] = (originalEscaped || originalValue) + valueEscaped</span><span class="s0">;</span>
	    <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
	      <span class="s0">delete this</span><span class="s1">.raws[name]</span><span class="s0">; </span><span class="s4">// delete any escaped value that was created by the setter.</span>
	    <span class="s1">}</span>
	  <span class="s1">}</span>
	  <span class="s5">/**</span>
	   <span class="s5">* Some non-standard syntax doesn't follow normal escaping rules for css.</span>
	   <span class="s5">* This allows the escaped value to be specified directly, allowing illegal</span>
	   <span class="s5">* characters to be directly inserted into css output.</span>
	   <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string} name the property to set</span>
	   <span class="s5">* </span><span class="s6">@param </span><span class="s5">{any} value the unescaped value of the property</span>
	   <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string} valueEscaped the escaped value of the property.</span>
	   <span class="s5">*/</span>
	  <span class="s0">;</span>

	  <span class="s1">_proto.setPropertyAndEscape = </span><span class="s0">function </span><span class="s1">setPropertyAndEscape(name</span><span class="s0">, </span><span class="s1">value</span><span class="s0">, </span><span class="s1">valueEscaped) {</span>
	    <span class="s0">if </span><span class="s1">(!</span><span class="s0">this</span><span class="s1">.raws) {</span>
	      <span class="s0">this</span><span class="s1">.raws = {}</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">this</span><span class="s1">[name] = value</span><span class="s0">; </span><span class="s4">// this may trigger a setter that updates raws, so it has to be set first.</span>

	    <span class="s0">this</span><span class="s1">.raws[name] = valueEscaped</span><span class="s0">;</span>
	  <span class="s1">}</span>
	  <span class="s5">/**</span>
	   <span class="s5">* When you want a value to passed through to CSS directly. This method</span>
	   <span class="s5">* deletes the corresponding raw value causing the stringifier to fallback</span>
	   <span class="s5">* to the unescaped value.</span>
	   <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string} name the property to set.</span>
	   <span class="s5">* </span><span class="s6">@param </span><span class="s5">{any} value The value that is both escaped and unescaped.</span>
	   <span class="s5">*/</span>
	  <span class="s0">;</span>

	  <span class="s1">_proto.setPropertyWithoutEscape = </span><span class="s0">function </span><span class="s1">setPropertyWithoutEscape(name</span><span class="s0">, </span><span class="s1">value) {</span>
	    <span class="s0">this</span><span class="s1">[name] = value</span><span class="s0">; </span><span class="s4">// this may trigger a setter that updates raws, so it has to be set first.</span>

	    <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.raws) {</span>
	      <span class="s0">delete this</span><span class="s1">.raws[name]</span><span class="s0">;</span>
	    <span class="s1">}</span>
	  <span class="s1">}</span>
	  <span class="s5">/**</span>
	   <span class="s5">*</span>
	   <span class="s5">* </span><span class="s6">@param </span><span class="s5">{number} line The number (starting with 1)</span>
	   <span class="s5">* </span><span class="s6">@param </span><span class="s5">{number} column The column number (starting with 1)</span>
	   <span class="s5">*/</span>
	  <span class="s0">;</span>

	  <span class="s1">_proto.isAtPosition = </span><span class="s0">function </span><span class="s1">isAtPosition(line</span><span class="s0">, </span><span class="s1">column) {</span>
	    <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.source &amp;&amp; </span><span class="s0">this</span><span class="s1">.source.start &amp;&amp; </span><span class="s0">this</span><span class="s1">.source.end) {</span>
	      <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.source.start.line &gt; line) {</span>
	        <span class="s0">return false;</span>
	      <span class="s1">}</span>

	      <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.source.end.line &lt; line) {</span>
	        <span class="s0">return false;</span>
	      <span class="s1">}</span>

	      <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.source.start.line === line &amp;&amp; </span><span class="s0">this</span><span class="s1">.source.start.column &gt; column) {</span>
	        <span class="s0">return false;</span>
	      <span class="s1">}</span>

	      <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.source.end.line === line &amp;&amp; </span><span class="s0">this</span><span class="s1">.source.end.column &lt; column) {</span>
	        <span class="s0">return false;</span>
	      <span class="s1">}</span>

	      <span class="s0">return true;</span>
	    <span class="s1">}</span>

	    <span class="s0">return </span><span class="s1">undefined</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.stringifyProperty = </span><span class="s0">function </span><span class="s1">stringifyProperty(name) {</span>
	    <span class="s0">return this</span><span class="s1">.raws &amp;&amp; </span><span class="s0">this</span><span class="s1">.raws[name] || </span><span class="s0">this</span><span class="s1">[name]</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.valueToString = </span><span class="s0">function </span><span class="s1">valueToString() {</span>
	    <span class="s0">return </span><span class="s1">String(</span><span class="s0">this</span><span class="s1">.stringifyProperty(</span><span class="s2">&quot;value&quot;</span><span class="s1">))</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.toString = </span><span class="s0">function </span><span class="s1">toString() {</span>
	    <span class="s0">return </span><span class="s1">[</span><span class="s0">this</span><span class="s1">.rawSpaceBefore</span><span class="s0">, this</span><span class="s1">.valueToString()</span><span class="s0">, this</span><span class="s1">.rawSpaceAfter].join(</span><span class="s2">''</span><span class="s1">)</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_createClass(Node</span><span class="s0">, </span><span class="s1">[{</span>
	    <span class="s1">key: </span><span class="s2">&quot;rawSpaceBefore&quot;</span><span class="s0">,</span>
	    <span class="s1">get: </span><span class="s0">function </span><span class="s1">get() {</span>
	      <span class="s0">var </span><span class="s1">rawSpace = </span><span class="s0">this</span><span class="s1">.raws &amp;&amp; </span><span class="s0">this</span><span class="s1">.raws.spaces &amp;&amp; </span><span class="s0">this</span><span class="s1">.raws.spaces.before</span><span class="s0">;</span>

	      <span class="s0">if </span><span class="s1">(rawSpace === undefined) {</span>
	        <span class="s1">rawSpace = </span><span class="s0">this</span><span class="s1">.spaces &amp;&amp; </span><span class="s0">this</span><span class="s1">.spaces.before</span><span class="s0">;</span>
	      <span class="s1">}</span>

	      <span class="s0">return </span><span class="s1">rawSpace || </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
	    <span class="s1">}</span><span class="s0">,</span>
	    <span class="s1">set: </span><span class="s0">function </span><span class="s1">set(raw) {</span>
	      <span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">_util.ensureObject)(</span><span class="s0">this, </span><span class="s2">&quot;raws&quot;</span><span class="s0">, </span><span class="s2">&quot;spaces&quot;</span><span class="s1">)</span><span class="s0">;</span>
	      <span class="s0">this</span><span class="s1">.raws.spaces.before = raw</span><span class="s0">;</span>
	    <span class="s1">}</span>
	  <span class="s1">}</span><span class="s0">, </span><span class="s1">{</span>
	    <span class="s1">key: </span><span class="s2">&quot;rawSpaceAfter&quot;</span><span class="s0">,</span>
	    <span class="s1">get: </span><span class="s0">function </span><span class="s1">get() {</span>
	      <span class="s0">var </span><span class="s1">rawSpace = </span><span class="s0">this</span><span class="s1">.raws &amp;&amp; </span><span class="s0">this</span><span class="s1">.raws.spaces &amp;&amp; </span><span class="s0">this</span><span class="s1">.raws.spaces.after</span><span class="s0">;</span>

	      <span class="s0">if </span><span class="s1">(rawSpace === undefined) {</span>
	        <span class="s1">rawSpace = </span><span class="s0">this</span><span class="s1">.spaces.after</span><span class="s0">;</span>
	      <span class="s1">}</span>

	      <span class="s0">return </span><span class="s1">rawSpace || </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
	    <span class="s1">}</span><span class="s0">,</span>
	    <span class="s1">set: </span><span class="s0">function </span><span class="s1">set(raw) {</span>
	      <span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">_util.ensureObject)(</span><span class="s0">this, </span><span class="s2">&quot;raws&quot;</span><span class="s0">, </span><span class="s2">&quot;spaces&quot;</span><span class="s1">)</span><span class="s0">;</span>
	      <span class="s0">this</span><span class="s1">.raws.spaces.after = raw</span><span class="s0">;</span>
	    <span class="s1">}</span>
	  <span class="s1">}])</span><span class="s0">;</span>

	  <span class="s0">return </span><span class="s1">Node</span><span class="s0">;</span>
	<span class="s1">}()</span><span class="s0">;</span>

	<span class="s1">exports[</span><span class="s2">&quot;default&quot;</span><span class="s1">] = Node</span><span class="s0">;</span>
	<span class="s1">module.exports = exports.default</span><span class="s0">;</span>
<span class="s1">} (node$1</span><span class="s0">, </span><span class="s1">nodeExports))</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">types = {}</span><span class="s0">;</span>

<span class="s1">types.__esModule = </span><span class="s0">true;</span>
<span class="s1">types.UNIVERSAL = types.ATTRIBUTE = types.CLASS = types.COMBINATOR = types.COMMENT = types.ID = types.NESTING = types.PSEUDO = types.ROOT = types.SELECTOR = types.STRING = types.TAG = </span><span class="s0">void </span><span class="s3">0</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">TAG = </span><span class="s2">'tag'</span><span class="s0">;</span>
<span class="s1">types.TAG = TAG</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">STRING = </span><span class="s2">'string'</span><span class="s0">;</span>
<span class="s1">types.STRING = STRING</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">SELECTOR = </span><span class="s2">'selector'</span><span class="s0">;</span>
<span class="s1">types.SELECTOR = SELECTOR</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">ROOT = </span><span class="s2">'root'</span><span class="s0">;</span>
<span class="s1">types.ROOT = ROOT</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">PSEUDO = </span><span class="s2">'pseudo'</span><span class="s0">;</span>
<span class="s1">types.PSEUDO = PSEUDO</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">NESTING = </span><span class="s2">'nesting'</span><span class="s0">;</span>
<span class="s1">types.NESTING = NESTING</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">ID = </span><span class="s2">'id'</span><span class="s0">;</span>
<span class="s1">types.ID = ID</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">COMMENT = </span><span class="s2">'comment'</span><span class="s0">;</span>
<span class="s1">types.COMMENT = COMMENT</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">COMBINATOR = </span><span class="s2">'combinator'</span><span class="s0">;</span>
<span class="s1">types.COMBINATOR = COMBINATOR</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">CLASS = </span><span class="s2">'class'</span><span class="s0">;</span>
<span class="s1">types.CLASS = CLASS</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">ATTRIBUTE = </span><span class="s2">'attribute'</span><span class="s0">;</span>
<span class="s1">types.ATTRIBUTE = ATTRIBUTE</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">UNIVERSAL = </span><span class="s2">'universal'</span><span class="s0">;</span>
<span class="s1">types.UNIVERSAL = UNIVERSAL</span><span class="s0">;</span>

<span class="s1">(</span><span class="s0">function </span><span class="s1">(module</span><span class="s0">, </span><span class="s1">exports) {</span>

	<span class="s1">exports.__esModule = </span><span class="s0">true;</span>
	<span class="s1">exports[</span><span class="s2">&quot;default&quot;</span><span class="s1">] = </span><span class="s0">void </span><span class="s3">0</span><span class="s0">;</span>

	<span class="s0">var </span><span class="s1">_node = _interopRequireDefault(nodeExports)</span><span class="s0">;</span>

	<span class="s0">var </span><span class="s1">types$1 = _interopRequireWildcard(types)</span><span class="s0">;</span>

	<span class="s0">function </span><span class="s1">_getRequireWildcardCache() { </span><span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">WeakMap !== </span><span class="s2">&quot;function&quot;</span><span class="s1">) </span><span class="s0">return null; var </span><span class="s1">cache = </span><span class="s0">new </span><span class="s1">WeakMap()</span><span class="s0">; </span><span class="s1">_getRequireWildcardCache = </span><span class="s0">function </span><span class="s1">_getRequireWildcardCache() { </span><span class="s0">return </span><span class="s1">cache</span><span class="s0">; </span><span class="s1">}</span><span class="s0">; return </span><span class="s1">cache</span><span class="s0">; </span><span class="s1">}</span>

	<span class="s0">function </span><span class="s1">_interopRequireWildcard(obj) { </span><span class="s0">if </span><span class="s1">(obj &amp;&amp; obj.__esModule) { </span><span class="s0">return </span><span class="s1">obj</span><span class="s0">; </span><span class="s1">} </span><span class="s0">if </span><span class="s1">(obj === </span><span class="s0">null </span><span class="s1">|| </span><span class="s0">typeof </span><span class="s1">obj !== </span><span class="s2">&quot;object&quot; </span><span class="s1">&amp;&amp; </span><span class="s0">typeof </span><span class="s1">obj !== </span><span class="s2">&quot;function&quot;</span><span class="s1">) { </span><span class="s0">return </span><span class="s1">{ </span><span class="s2">&quot;default&quot;</span><span class="s1">: obj }</span><span class="s0">; </span><span class="s1">} </span><span class="s0">var </span><span class="s1">cache = _getRequireWildcardCache()</span><span class="s0">; if </span><span class="s1">(cache &amp;&amp; cache.has(obj)) { </span><span class="s0">return </span><span class="s1">cache.get(obj)</span><span class="s0">; </span><span class="s1">} </span><span class="s0">var </span><span class="s1">newObj = {}</span><span class="s0">; var </span><span class="s1">hasPropertyDescriptor = Object.defineProperty &amp;&amp; Object.getOwnPropertyDescriptor</span><span class="s0">; for </span><span class="s1">(</span><span class="s0">var </span><span class="s1">key </span><span class="s0">in </span><span class="s1">obj) { </span><span class="s0">if </span><span class="s1">(Object.prototype.hasOwnProperty.call(obj</span><span class="s0">, </span><span class="s1">key)) { </span><span class="s0">var </span><span class="s1">desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj</span><span class="s0">, </span><span class="s1">key) : </span><span class="s0">null; if </span><span class="s1">(desc &amp;&amp; (desc.get || desc.set)) { Object.defineProperty(newObj</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">desc)</span><span class="s0">; </span><span class="s1">} </span><span class="s0">else </span><span class="s1">{ newObj[key] = obj[key]</span><span class="s0">; </span><span class="s1">} } } newObj[</span><span class="s2">&quot;default&quot;</span><span class="s1">] = obj</span><span class="s0">; if </span><span class="s1">(cache) { cache.set(obj</span><span class="s0">, </span><span class="s1">newObj)</span><span class="s0">; </span><span class="s1">} </span><span class="s0">return </span><span class="s1">newObj</span><span class="s0">; </span><span class="s1">}</span>

	<span class="s0">function </span><span class="s1">_interopRequireDefault(obj) { </span><span class="s0">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : { </span><span class="s2">&quot;default&quot;</span><span class="s1">: obj }</span><span class="s0">; </span><span class="s1">}</span>

	<span class="s0">function </span><span class="s1">_createForOfIteratorHelperLoose(o</span><span class="s0">, </span><span class="s1">allowArrayLike) { </span><span class="s0">var </span><span class="s1">it</span><span class="s0">; if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">Symbol === </span><span class="s2">&quot;undefined&quot; </span><span class="s1">|| o[Symbol.iterator] == </span><span class="s0">null</span><span class="s1">) { </span><span class="s0">if </span><span class="s1">(Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike &amp;&amp; o &amp;&amp; </span><span class="s0">typeof </span><span class="s1">o.length === </span><span class="s2">&quot;number&quot;</span><span class="s1">) { </span><span class="s0">if </span><span class="s1">(it) o = it</span><span class="s0">; var </span><span class="s1">i = </span><span class="s3">0</span><span class="s0">; return function </span><span class="s1">() { </span><span class="s0">if </span><span class="s1">(i &gt;= o.length) </span><span class="s0">return </span><span class="s1">{ done: </span><span class="s0">true </span><span class="s1">}</span><span class="s0">; return </span><span class="s1">{ done: </span><span class="s0">false, </span><span class="s1">value: o[i++] }</span><span class="s0">; </span><span class="s1">}</span><span class="s0">; </span><span class="s1">} </span><span class="s0">throw new </span><span class="s1">TypeError(</span><span class="s2">&quot;Invalid attempt to iterate non-iterable instance.</span><span class="s0">\n</span><span class="s2">In order to be iterable, non-array objects must have a [Symbol.iterator]() method.&quot;</span><span class="s1">)</span><span class="s0">; </span><span class="s1">} it = o[Symbol.iterator]()</span><span class="s0">; return </span><span class="s1">it.next.bind(it)</span><span class="s0">; </span><span class="s1">}</span>

	<span class="s0">function </span><span class="s1">_unsupportedIterableToArray(o</span><span class="s0">, </span><span class="s1">minLen) { </span><span class="s0">if </span><span class="s1">(!o) </span><span class="s0">return; if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">o === </span><span class="s2">&quot;string&quot;</span><span class="s1">) </span><span class="s0">return </span><span class="s1">_arrayLikeToArray(o</span><span class="s0">, </span><span class="s1">minLen)</span><span class="s0">; var </span><span class="s1">n = Object.prototype.toString.call(o).slice(</span><span class="s3">8</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)</span><span class="s0">; if </span><span class="s1">(n === </span><span class="s2">&quot;Object&quot; </span><span class="s1">&amp;&amp; o.constructor) n = o.constructor.name</span><span class="s0">; if </span><span class="s1">(n === </span><span class="s2">&quot;Map&quot; </span><span class="s1">|| n === </span><span class="s2">&quot;Set&quot;</span><span class="s1">) </span><span class="s0">return </span><span class="s1">Array.from(o)</span><span class="s0">; if </span><span class="s1">(n === </span><span class="s2">&quot;Arguments&quot; </span><span class="s1">|| </span><span class="s3">/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/</span><span class="s1">.test(n)) </span><span class="s0">return </span><span class="s1">_arrayLikeToArray(o</span><span class="s0">, </span><span class="s1">minLen)</span><span class="s0">; </span><span class="s1">}</span>

	<span class="s0">function </span><span class="s1">_arrayLikeToArray(arr</span><span class="s0">, </span><span class="s1">len) { </span><span class="s0">if </span><span class="s1">(len == </span><span class="s0">null </span><span class="s1">|| len &gt; arr.length) len = arr.length</span><span class="s0">; for </span><span class="s1">(</span><span class="s0">var </span><span class="s1">i = </span><span class="s3">0</span><span class="s0">, </span><span class="s1">arr2 = </span><span class="s0">new </span><span class="s1">Array(len)</span><span class="s0">; </span><span class="s1">i &lt; len</span><span class="s0">; </span><span class="s1">i++) { arr2[i] = arr[i]</span><span class="s0">; </span><span class="s1">} </span><span class="s0">return </span><span class="s1">arr2</span><span class="s0">; </span><span class="s1">}</span>

	<span class="s0">function </span><span class="s1">_defineProperties(target</span><span class="s0">, </span><span class="s1">props) { </span><span class="s0">for </span><span class="s1">(</span><span class="s0">var </span><span class="s1">i = </span><span class="s3">0</span><span class="s0">; </span><span class="s1">i &lt; props.length</span><span class="s0">; </span><span class="s1">i++) { </span><span class="s0">var </span><span class="s1">descriptor = props[i]</span><span class="s0">; </span><span class="s1">descriptor.enumerable = descriptor.enumerable || </span><span class="s0">false; </span><span class="s1">descriptor.configurable = </span><span class="s0">true; if </span><span class="s1">(</span><span class="s2">&quot;value&quot; </span><span class="s0">in </span><span class="s1">descriptor) descriptor.writable = </span><span class="s0">true; </span><span class="s1">Object.defineProperty(target</span><span class="s0">, </span><span class="s1">descriptor.key</span><span class="s0">, </span><span class="s1">descriptor)</span><span class="s0">; </span><span class="s1">} }</span>

	<span class="s0">function </span><span class="s1">_createClass(Constructor</span><span class="s0">, </span><span class="s1">protoProps</span><span class="s0">, </span><span class="s1">staticProps) { </span><span class="s0">if </span><span class="s1">(protoProps) _defineProperties(Constructor.prototype</span><span class="s0">, </span><span class="s1">protoProps)</span><span class="s0">; if </span><span class="s1">(staticProps) _defineProperties(Constructor</span><span class="s0">, </span><span class="s1">staticProps)</span><span class="s0">; return </span><span class="s1">Constructor</span><span class="s0">; </span><span class="s1">}</span>

	<span class="s0">function </span><span class="s1">_inheritsLoose(subClass</span><span class="s0">, </span><span class="s1">superClass) { subClass.prototype = Object.create(superClass.prototype)</span><span class="s0">; </span><span class="s1">subClass.prototype.constructor = subClass</span><span class="s0">; </span><span class="s1">_setPrototypeOf(subClass</span><span class="s0">, </span><span class="s1">superClass)</span><span class="s0">; </span><span class="s1">}</span>

	<span class="s0">function </span><span class="s1">_setPrototypeOf(o</span><span class="s0">, </span><span class="s1">p) { _setPrototypeOf = Object.setPrototypeOf || </span><span class="s0">function </span><span class="s1">_setPrototypeOf(o</span><span class="s0">, </span><span class="s1">p) { o.__proto__ = p</span><span class="s0">; return </span><span class="s1">o</span><span class="s0">; </span><span class="s1">}</span><span class="s0">; return </span><span class="s1">_setPrototypeOf(o</span><span class="s0">, </span><span class="s1">p)</span><span class="s0">; </span><span class="s1">}</span>

	<span class="s0">var </span><span class="s1">Container = </span><span class="s4">/*#__PURE__*/</span><span class="s0">function </span><span class="s1">(_Node) {</span>
	  <span class="s1">_inheritsLoose(Container</span><span class="s0">, </span><span class="s1">_Node)</span><span class="s0">;</span>

	  <span class="s0">function </span><span class="s1">Container(opts) {</span>
	    <span class="s0">var </span><span class="s1">_this</span><span class="s0">;</span>

	    <span class="s1">_this = _Node.call(</span><span class="s0">this, </span><span class="s1">opts) || </span><span class="s0">this;</span>

	    <span class="s0">if </span><span class="s1">(!_this.nodes) {</span>
	      <span class="s1">_this.nodes = []</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">return </span><span class="s1">_this</span><span class="s0">;</span>
	  <span class="s1">}</span>

	  <span class="s0">var </span><span class="s1">_proto = Container.prototype</span><span class="s0">;</span>

	  <span class="s1">_proto.append = </span><span class="s0">function </span><span class="s1">append(selector) {</span>
	    <span class="s1">selector.parent = </span><span class="s0">this;</span>
	    <span class="s0">this</span><span class="s1">.nodes.push(selector)</span><span class="s0">;</span>
	    <span class="s0">return this;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.prepend = </span><span class="s0">function </span><span class="s1">prepend(selector) {</span>
	    <span class="s1">selector.parent = </span><span class="s0">this;</span>
	    <span class="s0">this</span><span class="s1">.nodes.unshift(selector)</span><span class="s0">;</span>
	    <span class="s0">return this;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.at = </span><span class="s0">function </span><span class="s1">at(index) {</span>
	    <span class="s0">return this</span><span class="s1">.nodes[index]</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.index = </span><span class="s0">function </span><span class="s1">index(child) {</span>
	    <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">child === </span><span class="s2">'number'</span><span class="s1">) {</span>
	      <span class="s0">return </span><span class="s1">child</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">return this</span><span class="s1">.nodes.indexOf(child)</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.removeChild = </span><span class="s0">function </span><span class="s1">removeChild(child) {</span>
	    <span class="s1">child = </span><span class="s0">this</span><span class="s1">.index(child)</span><span class="s0">;</span>
	    <span class="s0">this</span><span class="s1">.at(child).parent = undefined</span><span class="s0">;</span>
	    <span class="s0">this</span><span class="s1">.nodes.splice(child</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">;</span>
	    <span class="s0">var </span><span class="s1">index</span><span class="s0">;</span>

	    <span class="s0">for </span><span class="s1">(</span><span class="s0">var </span><span class="s1">id </span><span class="s0">in this</span><span class="s1">.indexes) {</span>
	      <span class="s1">index = </span><span class="s0">this</span><span class="s1">.indexes[id]</span><span class="s0">;</span>

	      <span class="s0">if </span><span class="s1">(index &gt;= child) {</span>
	        <span class="s0">this</span><span class="s1">.indexes[id] = index - </span><span class="s3">1</span><span class="s0">;</span>
	      <span class="s1">}</span>
	    <span class="s1">}</span>

	    <span class="s0">return this;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.removeAll = </span><span class="s0">function </span><span class="s1">removeAll() {</span>
	    <span class="s0">for </span><span class="s1">(</span><span class="s0">var </span><span class="s1">_iterator = _createForOfIteratorHelperLoose(</span><span class="s0">this</span><span class="s1">.nodes)</span><span class="s0">, </span><span class="s1">_step</span><span class="s0">; </span><span class="s1">!(_step = _iterator()).done</span><span class="s0">;</span><span class="s1">) {</span>
	      <span class="s0">var </span><span class="s1">node = _step.value</span><span class="s0">;</span>
	      <span class="s1">node.parent = undefined</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">this</span><span class="s1">.nodes = []</span><span class="s0">;</span>
	    <span class="s0">return this;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.empty = </span><span class="s0">function </span><span class="s1">empty() {</span>
	    <span class="s0">return this</span><span class="s1">.removeAll()</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.insertAfter = </span><span class="s0">function </span><span class="s1">insertAfter(oldNode</span><span class="s0">, </span><span class="s1">newNode) {</span>
	    <span class="s1">newNode.parent = </span><span class="s0">this;</span>
	    <span class="s0">var </span><span class="s1">oldIndex = </span><span class="s0">this</span><span class="s1">.index(oldNode)</span><span class="s0">;</span>
	    <span class="s0">this</span><span class="s1">.nodes.splice(oldIndex + </span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">newNode)</span><span class="s0">;</span>
	    <span class="s1">newNode.parent = </span><span class="s0">this;</span>
	    <span class="s0">var </span><span class="s1">index</span><span class="s0">;</span>

	    <span class="s0">for </span><span class="s1">(</span><span class="s0">var </span><span class="s1">id </span><span class="s0">in this</span><span class="s1">.indexes) {</span>
	      <span class="s1">index = </span><span class="s0">this</span><span class="s1">.indexes[id]</span><span class="s0">;</span>

	      <span class="s0">if </span><span class="s1">(oldIndex &lt;= index) {</span>
	        <span class="s0">this</span><span class="s1">.indexes[id] = index + </span><span class="s3">1</span><span class="s0">;</span>
	      <span class="s1">}</span>
	    <span class="s1">}</span>

	    <span class="s0">return this;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.insertBefore = </span><span class="s0">function </span><span class="s1">insertBefore(oldNode</span><span class="s0">, </span><span class="s1">newNode) {</span>
	    <span class="s1">newNode.parent = </span><span class="s0">this;</span>
	    <span class="s0">var </span><span class="s1">oldIndex = </span><span class="s0">this</span><span class="s1">.index(oldNode)</span><span class="s0">;</span>
	    <span class="s0">this</span><span class="s1">.nodes.splice(oldIndex</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">newNode)</span><span class="s0">;</span>
	    <span class="s1">newNode.parent = </span><span class="s0">this;</span>
	    <span class="s0">var </span><span class="s1">index</span><span class="s0">;</span>

	    <span class="s0">for </span><span class="s1">(</span><span class="s0">var </span><span class="s1">id </span><span class="s0">in this</span><span class="s1">.indexes) {</span>
	      <span class="s1">index = </span><span class="s0">this</span><span class="s1">.indexes[id]</span><span class="s0">;</span>

	      <span class="s0">if </span><span class="s1">(index &lt;= oldIndex) {</span>
	        <span class="s0">this</span><span class="s1">.indexes[id] = index + </span><span class="s3">1</span><span class="s0">;</span>
	      <span class="s1">}</span>
	    <span class="s1">}</span>

	    <span class="s0">return this;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto._findChildAtPosition = </span><span class="s0">function </span><span class="s1">_findChildAtPosition(line</span><span class="s0">, </span><span class="s1">col) {</span>
	    <span class="s0">var </span><span class="s1">found = undefined</span><span class="s0">;</span>
	    <span class="s0">this</span><span class="s1">.each(</span><span class="s0">function </span><span class="s1">(node) {</span>
	      <span class="s0">if </span><span class="s1">(node.atPosition) {</span>
	        <span class="s0">var </span><span class="s1">foundChild = node.atPosition(line</span><span class="s0">, </span><span class="s1">col)</span><span class="s0">;</span>

	        <span class="s0">if </span><span class="s1">(foundChild) {</span>
	          <span class="s1">found = foundChild</span><span class="s0">;</span>
	          <span class="s0">return false;</span>
	        <span class="s1">}</span>
	      <span class="s1">} </span><span class="s0">else if </span><span class="s1">(node.isAtPosition(line</span><span class="s0">, </span><span class="s1">col)) {</span>
	        <span class="s1">found = node</span><span class="s0">;</span>
	        <span class="s0">return false;</span>
	      <span class="s1">}</span>
	    <span class="s1">})</span><span class="s0">;</span>
	    <span class="s0">return </span><span class="s1">found</span><span class="s0">;</span>
	  <span class="s1">}</span>
	  <span class="s5">/**</span>
	   <span class="s5">* Return the most specific node at the line and column number given.</span>
	   <span class="s5">* The source location is based on the original parsed location, locations aren't</span>
	   <span class="s5">* updated as selector nodes are mutated.</span>
	   <span class="s5">* </span>
	   <span class="s5">* Note that this location is relative to the location of the first character</span>
	   <span class="s5">* of the selector, and not the location of the selector in the overall document</span>
	   <span class="s5">* when used in conjunction with postcss.</span>
	   <span class="s5">*</span>
	   <span class="s5">* If not found, returns undefined.</span>
	   <span class="s5">* </span><span class="s6">@param </span><span class="s5">{number} line The line number of the node to find. (1-based index)</span>
	   <span class="s5">* </span><span class="s6">@param </span><span class="s5">{number} col  The column number of the node to find. (1-based index)</span>
	   <span class="s5">*/</span>
	  <span class="s0">;</span>

	  <span class="s1">_proto.atPosition = </span><span class="s0">function </span><span class="s1">atPosition(line</span><span class="s0">, </span><span class="s1">col) {</span>
	    <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.isAtPosition(line</span><span class="s0">, </span><span class="s1">col)) {</span>
	      <span class="s0">return this</span><span class="s1">._findChildAtPosition(line</span><span class="s0">, </span><span class="s1">col) || </span><span class="s0">this;</span>
	    <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
	      <span class="s0">return </span><span class="s1">undefined</span><span class="s0">;</span>
	    <span class="s1">}</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto._inferEndPosition = </span><span class="s0">function </span><span class="s1">_inferEndPosition() {</span>
	    <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.last &amp;&amp; </span><span class="s0">this</span><span class="s1">.last.source &amp;&amp; </span><span class="s0">this</span><span class="s1">.last.source.end) {</span>
	      <span class="s0">this</span><span class="s1">.source = </span><span class="s0">this</span><span class="s1">.source || {}</span><span class="s0">;</span>
	      <span class="s0">this</span><span class="s1">.source.end = </span><span class="s0">this</span><span class="s1">.source.end || {}</span><span class="s0">;</span>
	      <span class="s1">Object.assign(</span><span class="s0">this</span><span class="s1">.source.end</span><span class="s0">, this</span><span class="s1">.last.source.end)</span><span class="s0">;</span>
	    <span class="s1">}</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.each = </span><span class="s0">function </span><span class="s1">each(callback) {</span>
	    <span class="s0">if </span><span class="s1">(!</span><span class="s0">this</span><span class="s1">.lastEach) {</span>
	      <span class="s0">this</span><span class="s1">.lastEach = </span><span class="s3">0</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">if </span><span class="s1">(!</span><span class="s0">this</span><span class="s1">.indexes) {</span>
	      <span class="s0">this</span><span class="s1">.indexes = {}</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">this</span><span class="s1">.lastEach++</span><span class="s0">;</span>
	    <span class="s0">var </span><span class="s1">id = </span><span class="s0">this</span><span class="s1">.lastEach</span><span class="s0">;</span>
	    <span class="s0">this</span><span class="s1">.indexes[id] = </span><span class="s3">0</span><span class="s0">;</span>

	    <span class="s0">if </span><span class="s1">(!</span><span class="s0">this</span><span class="s1">.length) {</span>
	      <span class="s0">return </span><span class="s1">undefined</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">var </span><span class="s1">index</span><span class="s0">, </span><span class="s1">result</span><span class="s0">;</span>

	    <span class="s0">while </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.indexes[id] &lt; </span><span class="s0">this</span><span class="s1">.length) {</span>
	      <span class="s1">index = </span><span class="s0">this</span><span class="s1">.indexes[id]</span><span class="s0">;</span>
	      <span class="s1">result = callback(</span><span class="s0">this</span><span class="s1">.at(index)</span><span class="s0">, </span><span class="s1">index)</span><span class="s0">;</span>

	      <span class="s0">if </span><span class="s1">(result === </span><span class="s0">false</span><span class="s1">) {</span>
	        <span class="s0">break;</span>
	      <span class="s1">}</span>

	      <span class="s0">this</span><span class="s1">.indexes[id] += </span><span class="s3">1</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">delete this</span><span class="s1">.indexes[id]</span><span class="s0">;</span>

	    <span class="s0">if </span><span class="s1">(result === </span><span class="s0">false</span><span class="s1">) {</span>
	      <span class="s0">return false;</span>
	    <span class="s1">}</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.walk = </span><span class="s0">function </span><span class="s1">walk(callback) {</span>
	    <span class="s0">return this</span><span class="s1">.each(</span><span class="s0">function </span><span class="s1">(node</span><span class="s0">, </span><span class="s1">i) {</span>
	      <span class="s0">var </span><span class="s1">result = callback(node</span><span class="s0">, </span><span class="s1">i)</span><span class="s0">;</span>

	      <span class="s0">if </span><span class="s1">(result !== </span><span class="s0">false </span><span class="s1">&amp;&amp; node.length) {</span>
	        <span class="s1">result = node.walk(callback)</span><span class="s0">;</span>
	      <span class="s1">}</span>

	      <span class="s0">if </span><span class="s1">(result === </span><span class="s0">false</span><span class="s1">) {</span>
	        <span class="s0">return false;</span>
	      <span class="s1">}</span>
	    <span class="s1">})</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.walkAttributes = </span><span class="s0">function </span><span class="s1">walkAttributes(callback) {</span>
	    <span class="s0">var </span><span class="s1">_this2 = </span><span class="s0">this;</span>

	    <span class="s0">return this</span><span class="s1">.walk(</span><span class="s0">function </span><span class="s1">(selector) {</span>
	      <span class="s0">if </span><span class="s1">(selector.type === types$1.ATTRIBUTE) {</span>
	        <span class="s0">return </span><span class="s1">callback.call(_this2</span><span class="s0">, </span><span class="s1">selector)</span><span class="s0">;</span>
	      <span class="s1">}</span>
	    <span class="s1">})</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.walkClasses = </span><span class="s0">function </span><span class="s1">walkClasses(callback) {</span>
	    <span class="s0">var </span><span class="s1">_this3 = </span><span class="s0">this;</span>

	    <span class="s0">return this</span><span class="s1">.walk(</span><span class="s0">function </span><span class="s1">(selector) {</span>
	      <span class="s0">if </span><span class="s1">(selector.type === types$1.CLASS) {</span>
	        <span class="s0">return </span><span class="s1">callback.call(_this3</span><span class="s0">, </span><span class="s1">selector)</span><span class="s0">;</span>
	      <span class="s1">}</span>
	    <span class="s1">})</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.walkCombinators = </span><span class="s0">function </span><span class="s1">walkCombinators(callback) {</span>
	    <span class="s0">var </span><span class="s1">_this4 = </span><span class="s0">this;</span>

	    <span class="s0">return this</span><span class="s1">.walk(</span><span class="s0">function </span><span class="s1">(selector) {</span>
	      <span class="s0">if </span><span class="s1">(selector.type === types$1.COMBINATOR) {</span>
	        <span class="s0">return </span><span class="s1">callback.call(_this4</span><span class="s0">, </span><span class="s1">selector)</span><span class="s0">;</span>
	      <span class="s1">}</span>
	    <span class="s1">})</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.walkComments = </span><span class="s0">function </span><span class="s1">walkComments(callback) {</span>
	    <span class="s0">var </span><span class="s1">_this5 = </span><span class="s0">this;</span>

	    <span class="s0">return this</span><span class="s1">.walk(</span><span class="s0">function </span><span class="s1">(selector) {</span>
	      <span class="s0">if </span><span class="s1">(selector.type === types$1.COMMENT) {</span>
	        <span class="s0">return </span><span class="s1">callback.call(_this5</span><span class="s0">, </span><span class="s1">selector)</span><span class="s0">;</span>
	      <span class="s1">}</span>
	    <span class="s1">})</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.walkIds = </span><span class="s0">function </span><span class="s1">walkIds(callback) {</span>
	    <span class="s0">var </span><span class="s1">_this6 = </span><span class="s0">this;</span>

	    <span class="s0">return this</span><span class="s1">.walk(</span><span class="s0">function </span><span class="s1">(selector) {</span>
	      <span class="s0">if </span><span class="s1">(selector.type === types$1.ID) {</span>
	        <span class="s0">return </span><span class="s1">callback.call(_this6</span><span class="s0">, </span><span class="s1">selector)</span><span class="s0">;</span>
	      <span class="s1">}</span>
	    <span class="s1">})</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.walkNesting = </span><span class="s0">function </span><span class="s1">walkNesting(callback) {</span>
	    <span class="s0">var </span><span class="s1">_this7 = </span><span class="s0">this;</span>

	    <span class="s0">return this</span><span class="s1">.walk(</span><span class="s0">function </span><span class="s1">(selector) {</span>
	      <span class="s0">if </span><span class="s1">(selector.type === types$1.NESTING) {</span>
	        <span class="s0">return </span><span class="s1">callback.call(_this7</span><span class="s0">, </span><span class="s1">selector)</span><span class="s0">;</span>
	      <span class="s1">}</span>
	    <span class="s1">})</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.walkPseudos = </span><span class="s0">function </span><span class="s1">walkPseudos(callback) {</span>
	    <span class="s0">var </span><span class="s1">_this8 = </span><span class="s0">this;</span>

	    <span class="s0">return this</span><span class="s1">.walk(</span><span class="s0">function </span><span class="s1">(selector) {</span>
	      <span class="s0">if </span><span class="s1">(selector.type === types$1.PSEUDO) {</span>
	        <span class="s0">return </span><span class="s1">callback.call(_this8</span><span class="s0">, </span><span class="s1">selector)</span><span class="s0">;</span>
	      <span class="s1">}</span>
	    <span class="s1">})</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.walkTags = </span><span class="s0">function </span><span class="s1">walkTags(callback) {</span>
	    <span class="s0">var </span><span class="s1">_this9 = </span><span class="s0">this;</span>

	    <span class="s0">return this</span><span class="s1">.walk(</span><span class="s0">function </span><span class="s1">(selector) {</span>
	      <span class="s0">if </span><span class="s1">(selector.type === types$1.TAG) {</span>
	        <span class="s0">return </span><span class="s1">callback.call(_this9</span><span class="s0">, </span><span class="s1">selector)</span><span class="s0">;</span>
	      <span class="s1">}</span>
	    <span class="s1">})</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.walkUniversals = </span><span class="s0">function </span><span class="s1">walkUniversals(callback) {</span>
	    <span class="s0">var </span><span class="s1">_this10 = </span><span class="s0">this;</span>

	    <span class="s0">return this</span><span class="s1">.walk(</span><span class="s0">function </span><span class="s1">(selector) {</span>
	      <span class="s0">if </span><span class="s1">(selector.type === types$1.UNIVERSAL) {</span>
	        <span class="s0">return </span><span class="s1">callback.call(_this10</span><span class="s0">, </span><span class="s1">selector)</span><span class="s0">;</span>
	      <span class="s1">}</span>
	    <span class="s1">})</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.split = </span><span class="s0">function </span><span class="s1">split(callback) {</span>
	    <span class="s0">var </span><span class="s1">_this11 = </span><span class="s0">this;</span>

	    <span class="s0">var </span><span class="s1">current = []</span><span class="s0">;</span>
	    <span class="s0">return this</span><span class="s1">.reduce(</span><span class="s0">function </span><span class="s1">(memo</span><span class="s0">, </span><span class="s1">node</span><span class="s0">, </span><span class="s1">index) {</span>
	      <span class="s0">var </span><span class="s1">split = callback.call(_this11</span><span class="s0">, </span><span class="s1">node)</span><span class="s0">;</span>
	      <span class="s1">current.push(node)</span><span class="s0">;</span>

	      <span class="s0">if </span><span class="s1">(split) {</span>
	        <span class="s1">memo.push(current)</span><span class="s0">;</span>
	        <span class="s1">current = []</span><span class="s0">;</span>
	      <span class="s1">} </span><span class="s0">else if </span><span class="s1">(index === _this11.length - </span><span class="s3">1</span><span class="s1">) {</span>
	        <span class="s1">memo.push(current)</span><span class="s0">;</span>
	      <span class="s1">}</span>

	      <span class="s0">return </span><span class="s1">memo</span><span class="s0">;</span>
	    <span class="s1">}</span><span class="s0">, </span><span class="s1">[])</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.map = </span><span class="s0">function </span><span class="s1">map(callback) {</span>
	    <span class="s0">return this</span><span class="s1">.nodes.map(callback)</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.reduce = </span><span class="s0">function </span><span class="s1">reduce(callback</span><span class="s0">, </span><span class="s1">memo) {</span>
	    <span class="s0">return this</span><span class="s1">.nodes.reduce(callback</span><span class="s0">, </span><span class="s1">memo)</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.every = </span><span class="s0">function </span><span class="s1">every(callback) {</span>
	    <span class="s0">return this</span><span class="s1">.nodes.every(callback)</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.some = </span><span class="s0">function </span><span class="s1">some(callback) {</span>
	    <span class="s0">return this</span><span class="s1">.nodes.some(callback)</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.filter = </span><span class="s0">function </span><span class="s1">filter(callback) {</span>
	    <span class="s0">return this</span><span class="s1">.nodes.filter(callback)</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.sort = </span><span class="s0">function </span><span class="s1">sort(callback) {</span>
	    <span class="s0">return this</span><span class="s1">.nodes.sort(callback)</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.toString = </span><span class="s0">function </span><span class="s1">toString() {</span>
	    <span class="s0">return this</span><span class="s1">.map(String).join(</span><span class="s2">''</span><span class="s1">)</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_createClass(Container</span><span class="s0">, </span><span class="s1">[{</span>
	    <span class="s1">key: </span><span class="s2">&quot;first&quot;</span><span class="s0">,</span>
	    <span class="s1">get: </span><span class="s0">function </span><span class="s1">get() {</span>
	      <span class="s0">return this</span><span class="s1">.at(</span><span class="s3">0</span><span class="s1">)</span><span class="s0">;</span>
	    <span class="s1">}</span>
	  <span class="s1">}</span><span class="s0">, </span><span class="s1">{</span>
	    <span class="s1">key: </span><span class="s2">&quot;last&quot;</span><span class="s0">,</span>
	    <span class="s1">get: </span><span class="s0">function </span><span class="s1">get() {</span>
	      <span class="s0">return this</span><span class="s1">.at(</span><span class="s0">this</span><span class="s1">.length - </span><span class="s3">1</span><span class="s1">)</span><span class="s0">;</span>
	    <span class="s1">}</span>
	  <span class="s1">}</span><span class="s0">, </span><span class="s1">{</span>
	    <span class="s1">key: </span><span class="s2">&quot;length&quot;</span><span class="s0">,</span>
	    <span class="s1">get: </span><span class="s0">function </span><span class="s1">get() {</span>
	      <span class="s0">return this</span><span class="s1">.nodes.length</span><span class="s0">;</span>
	    <span class="s1">}</span>
	  <span class="s1">}])</span><span class="s0">;</span>

	  <span class="s0">return </span><span class="s1">Container</span><span class="s0">;</span>
	<span class="s1">}(_node[</span><span class="s2">&quot;default&quot;</span><span class="s1">])</span><span class="s0">;</span>

	<span class="s1">exports[</span><span class="s2">&quot;default&quot;</span><span class="s1">] = Container</span><span class="s0">;</span>
	<span class="s1">module.exports = exports.default</span><span class="s0">;</span>
<span class="s1">} (container</span><span class="s0">, </span><span class="s1">containerExports))</span><span class="s0">;</span>

<span class="s1">(</span><span class="s0">function </span><span class="s1">(module</span><span class="s0">, </span><span class="s1">exports) {</span>

	<span class="s1">exports.__esModule = </span><span class="s0">true;</span>
	<span class="s1">exports[</span><span class="s2">&quot;default&quot;</span><span class="s1">] = </span><span class="s0">void </span><span class="s3">0</span><span class="s0">;</span>

	<span class="s0">var </span><span class="s1">_container = _interopRequireDefault(containerExports)</span><span class="s0">;</span>

	<span class="s0">var </span><span class="s1">_types = types</span><span class="s0">;</span>

	<span class="s0">function </span><span class="s1">_interopRequireDefault(obj) { </span><span class="s0">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : { </span><span class="s2">&quot;default&quot;</span><span class="s1">: obj }</span><span class="s0">; </span><span class="s1">}</span>

	<span class="s0">function </span><span class="s1">_defineProperties(target</span><span class="s0">, </span><span class="s1">props) { </span><span class="s0">for </span><span class="s1">(</span><span class="s0">var </span><span class="s1">i = </span><span class="s3">0</span><span class="s0">; </span><span class="s1">i &lt; props.length</span><span class="s0">; </span><span class="s1">i++) { </span><span class="s0">var </span><span class="s1">descriptor = props[i]</span><span class="s0">; </span><span class="s1">descriptor.enumerable = descriptor.enumerable || </span><span class="s0">false; </span><span class="s1">descriptor.configurable = </span><span class="s0">true; if </span><span class="s1">(</span><span class="s2">&quot;value&quot; </span><span class="s0">in </span><span class="s1">descriptor) descriptor.writable = </span><span class="s0">true; </span><span class="s1">Object.defineProperty(target</span><span class="s0">, </span><span class="s1">descriptor.key</span><span class="s0">, </span><span class="s1">descriptor)</span><span class="s0">; </span><span class="s1">} }</span>

	<span class="s0">function </span><span class="s1">_createClass(Constructor</span><span class="s0">, </span><span class="s1">protoProps</span><span class="s0">, </span><span class="s1">staticProps) { </span><span class="s0">if </span><span class="s1">(protoProps) _defineProperties(Constructor.prototype</span><span class="s0">, </span><span class="s1">protoProps)</span><span class="s0">; if </span><span class="s1">(staticProps) _defineProperties(Constructor</span><span class="s0">, </span><span class="s1">staticProps)</span><span class="s0">; return </span><span class="s1">Constructor</span><span class="s0">; </span><span class="s1">}</span>

	<span class="s0">function </span><span class="s1">_inheritsLoose(subClass</span><span class="s0">, </span><span class="s1">superClass) { subClass.prototype = Object.create(superClass.prototype)</span><span class="s0">; </span><span class="s1">subClass.prototype.constructor = subClass</span><span class="s0">; </span><span class="s1">_setPrototypeOf(subClass</span><span class="s0">, </span><span class="s1">superClass)</span><span class="s0">; </span><span class="s1">}</span>

	<span class="s0">function </span><span class="s1">_setPrototypeOf(o</span><span class="s0">, </span><span class="s1">p) { _setPrototypeOf = Object.setPrototypeOf || </span><span class="s0">function </span><span class="s1">_setPrototypeOf(o</span><span class="s0">, </span><span class="s1">p) { o.__proto__ = p</span><span class="s0">; return </span><span class="s1">o</span><span class="s0">; </span><span class="s1">}</span><span class="s0">; return </span><span class="s1">_setPrototypeOf(o</span><span class="s0">, </span><span class="s1">p)</span><span class="s0">; </span><span class="s1">}</span>

	<span class="s0">var </span><span class="s1">Root = </span><span class="s4">/*#__PURE__*/</span><span class="s0">function </span><span class="s1">(_Container) {</span>
	  <span class="s1">_inheritsLoose(Root</span><span class="s0">, </span><span class="s1">_Container)</span><span class="s0">;</span>

	  <span class="s0">function </span><span class="s1">Root(opts) {</span>
	    <span class="s0">var </span><span class="s1">_this</span><span class="s0">;</span>

	    <span class="s1">_this = _Container.call(</span><span class="s0">this, </span><span class="s1">opts) || </span><span class="s0">this;</span>
	    <span class="s1">_this.type = _types.ROOT</span><span class="s0">;</span>
	    <span class="s0">return </span><span class="s1">_this</span><span class="s0">;</span>
	  <span class="s1">}</span>

	  <span class="s0">var </span><span class="s1">_proto = Root.prototype</span><span class="s0">;</span>

	  <span class="s1">_proto.toString = </span><span class="s0">function </span><span class="s1">toString() {</span>
	    <span class="s0">var </span><span class="s1">str = </span><span class="s0">this</span><span class="s1">.reduce(</span><span class="s0">function </span><span class="s1">(memo</span><span class="s0">, </span><span class="s1">selector) {</span>
	      <span class="s1">memo.push(String(selector))</span><span class="s0">;</span>
	      <span class="s0">return </span><span class="s1">memo</span><span class="s0">;</span>
	    <span class="s1">}</span><span class="s0">, </span><span class="s1">[]).join(</span><span class="s2">','</span><span class="s1">)</span><span class="s0">;</span>
	    <span class="s0">return this</span><span class="s1">.trailingComma ? str + </span><span class="s2">',' </span><span class="s1">: str</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.error = </span><span class="s0">function </span><span class="s1">error(message</span><span class="s0">, </span><span class="s1">options) {</span>
	    <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">._error) {</span>
	      <span class="s0">return this</span><span class="s1">._error(message</span><span class="s0">, </span><span class="s1">options)</span><span class="s0">;</span>
	    <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
	      <span class="s0">return new </span><span class="s1">Error(message)</span><span class="s0">;</span>
	    <span class="s1">}</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_createClass(Root</span><span class="s0">, </span><span class="s1">[{</span>
	    <span class="s1">key: </span><span class="s2">&quot;errorGenerator&quot;</span><span class="s0">,</span>
	    <span class="s1">set: </span><span class="s0">function </span><span class="s1">set(handler) {</span>
	      <span class="s0">this</span><span class="s1">._error = handler</span><span class="s0">;</span>
	    <span class="s1">}</span>
	  <span class="s1">}])</span><span class="s0">;</span>

	  <span class="s0">return </span><span class="s1">Root</span><span class="s0">;</span>
	<span class="s1">}(_container[</span><span class="s2">&quot;default&quot;</span><span class="s1">])</span><span class="s0">;</span>

	<span class="s1">exports[</span><span class="s2">&quot;default&quot;</span><span class="s1">] = Root</span><span class="s0">;</span>
	<span class="s1">module.exports = exports.default</span><span class="s0">;</span>
<span class="s1">} (root$1</span><span class="s0">, </span><span class="s1">rootExports))</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">selectorExports = {}</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">selector$1 = {</span>
  <span class="s1">get exports(){ </span><span class="s0">return </span><span class="s1">selectorExports</span><span class="s0">; </span><span class="s1">}</span><span class="s0">,</span>
  <span class="s1">set exports(v){ selectorExports = v</span><span class="s0">; </span><span class="s1">}</span><span class="s0">,</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s1">(</span><span class="s0">function </span><span class="s1">(module</span><span class="s0">, </span><span class="s1">exports) {</span>

	<span class="s1">exports.__esModule = </span><span class="s0">true;</span>
	<span class="s1">exports[</span><span class="s2">&quot;default&quot;</span><span class="s1">] = </span><span class="s0">void </span><span class="s3">0</span><span class="s0">;</span>

	<span class="s0">var </span><span class="s1">_container = _interopRequireDefault(containerExports)</span><span class="s0">;</span>

	<span class="s0">var </span><span class="s1">_types = types</span><span class="s0">;</span>

	<span class="s0">function </span><span class="s1">_interopRequireDefault(obj) { </span><span class="s0">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : { </span><span class="s2">&quot;default&quot;</span><span class="s1">: obj }</span><span class="s0">; </span><span class="s1">}</span>

	<span class="s0">function </span><span class="s1">_inheritsLoose(subClass</span><span class="s0">, </span><span class="s1">superClass) { subClass.prototype = Object.create(superClass.prototype)</span><span class="s0">; </span><span class="s1">subClass.prototype.constructor = subClass</span><span class="s0">; </span><span class="s1">_setPrototypeOf(subClass</span><span class="s0">, </span><span class="s1">superClass)</span><span class="s0">; </span><span class="s1">}</span>

	<span class="s0">function </span><span class="s1">_setPrototypeOf(o</span><span class="s0">, </span><span class="s1">p) { _setPrototypeOf = Object.setPrototypeOf || </span><span class="s0">function </span><span class="s1">_setPrototypeOf(o</span><span class="s0">, </span><span class="s1">p) { o.__proto__ = p</span><span class="s0">; return </span><span class="s1">o</span><span class="s0">; </span><span class="s1">}</span><span class="s0">; return </span><span class="s1">_setPrototypeOf(o</span><span class="s0">, </span><span class="s1">p)</span><span class="s0">; </span><span class="s1">}</span>

	<span class="s0">var </span><span class="s1">Selector = </span><span class="s4">/*#__PURE__*/</span><span class="s0">function </span><span class="s1">(_Container) {</span>
	  <span class="s1">_inheritsLoose(Selector</span><span class="s0">, </span><span class="s1">_Container)</span><span class="s0">;</span>

	  <span class="s0">function </span><span class="s1">Selector(opts) {</span>
	    <span class="s0">var </span><span class="s1">_this</span><span class="s0">;</span>

	    <span class="s1">_this = _Container.call(</span><span class="s0">this, </span><span class="s1">opts) || </span><span class="s0">this;</span>
	    <span class="s1">_this.type = _types.SELECTOR</span><span class="s0">;</span>
	    <span class="s0">return </span><span class="s1">_this</span><span class="s0">;</span>
	  <span class="s1">}</span>

	  <span class="s0">return </span><span class="s1">Selector</span><span class="s0">;</span>
	<span class="s1">}(_container[</span><span class="s2">&quot;default&quot;</span><span class="s1">])</span><span class="s0">;</span>

	<span class="s1">exports[</span><span class="s2">&quot;default&quot;</span><span class="s1">] = Selector</span><span class="s0">;</span>
	<span class="s1">module.exports = exports.default</span><span class="s0">;</span>
<span class="s1">} (selector$1</span><span class="s0">, </span><span class="s1">selectorExports))</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">classNameExports = {}</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">className$1 = {</span>
  <span class="s1">get exports(){ </span><span class="s0">return </span><span class="s1">classNameExports</span><span class="s0">; </span><span class="s1">}</span><span class="s0">,</span>
  <span class="s1">set exports(v){ classNameExports = v</span><span class="s0">; </span><span class="s1">}</span><span class="s0">,</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s4">/*! https://mths.be/cssesc v3.0.0 by @mathias */</span>

<span class="s0">var </span><span class="s1">object = {}</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">hasOwnProperty$1 = object.hasOwnProperty</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">merge = </span><span class="s0">function </span><span class="s1">merge(options</span><span class="s0">, </span><span class="s1">defaults) {</span>
	<span class="s0">if </span><span class="s1">(!options) {</span>
		<span class="s0">return </span><span class="s1">defaults</span><span class="s0">;</span>
	<span class="s1">}</span>
	<span class="s0">var </span><span class="s1">result = {}</span><span class="s0">;</span>
	<span class="s0">for </span><span class="s1">(</span><span class="s0">var </span><span class="s1">key </span><span class="s0">in </span><span class="s1">defaults) {</span>
		<span class="s4">// `if (defaults.hasOwnProperty(key) {  }` is not needed here, since</span>
		<span class="s4">// only recognized option names are used.</span>
		<span class="s1">result[key] = hasOwnProperty$1.call(options</span><span class="s0">, </span><span class="s1">key) ? options[key] : defaults[key]</span><span class="s0">;</span>
	<span class="s1">}</span>
	<span class="s0">return </span><span class="s1">result</span><span class="s0">;</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">regexAnySingleEscape = </span><span class="s3">/[ -,\.\/:-@\[-\^`\{-~]/</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">regexSingleEscape = </span><span class="s3">/[ -,\.\/:-@\[\]\^`\{-~]/</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">regexExcessiveSpaces = </span><span class="s3">/(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g</span><span class="s0">;</span>

<span class="s4">// https://mathiasbynens.be/notes/css-escapes#css</span>
<span class="s0">var </span><span class="s1">cssesc = </span><span class="s0">function </span><span class="s1">cssesc(string</span><span class="s0">, </span><span class="s1">options) {</span>
	<span class="s1">options = merge(options</span><span class="s0">, </span><span class="s1">cssesc.options)</span><span class="s0">;</span>
	<span class="s0">if </span><span class="s1">(options.quotes != </span><span class="s2">'single' </span><span class="s1">&amp;&amp; options.quotes != </span><span class="s2">'double'</span><span class="s1">) {</span>
		<span class="s1">options.quotes = </span><span class="s2">'single'</span><span class="s0">;</span>
	<span class="s1">}</span>
	<span class="s0">var </span><span class="s1">quote = options.quotes == </span><span class="s2">'double' </span><span class="s1">? </span><span class="s2">'&quot;' </span><span class="s1">: </span><span class="s2">'</span><span class="s0">\'</span><span class="s2">'</span><span class="s0">;</span>
	<span class="s0">var </span><span class="s1">isIdentifier = options.isIdentifier</span><span class="s0">;</span>

	<span class="s0">var </span><span class="s1">firstChar = string.charAt(</span><span class="s3">0</span><span class="s1">)</span><span class="s0">;</span>
	<span class="s0">var </span><span class="s1">output = </span><span class="s2">''</span><span class="s0">;</span>
	<span class="s0">var </span><span class="s1">counter = </span><span class="s3">0</span><span class="s0">;</span>
	<span class="s0">var </span><span class="s1">length = string.length</span><span class="s0">;</span>
	<span class="s0">while </span><span class="s1">(counter &lt; length) {</span>
		<span class="s0">var </span><span class="s1">character = string.charAt(counter++)</span><span class="s0">;</span>
		<span class="s0">var </span><span class="s1">codePoint = character.charCodeAt()</span><span class="s0">;</span>
		<span class="s0">var </span><span class="s1">value = </span><span class="s0">void </span><span class="s3">0</span><span class="s0">;</span>
		<span class="s4">// If its not a printable ASCII character</span>
		<span class="s0">if </span><span class="s1">(codePoint &lt; </span><span class="s3">0x20 </span><span class="s1">|| codePoint &gt; </span><span class="s3">0x7E</span><span class="s1">) {</span>
			<span class="s0">if </span><span class="s1">(codePoint &gt;= </span><span class="s3">0xD800 </span><span class="s1">&amp;&amp; codePoint &lt;= </span><span class="s3">0xDBFF </span><span class="s1">&amp;&amp; counter &lt; length) {</span>
				<span class="s4">// Its a high surrogate, and there is a next character.</span>
				<span class="s0">var </span><span class="s1">extra = string.charCodeAt(counter++)</span><span class="s0">;</span>
				<span class="s0">if </span><span class="s1">((extra &amp; </span><span class="s3">0xFC00</span><span class="s1">) == </span><span class="s3">0xDC00</span><span class="s1">) {</span>
					<span class="s4">// next character is low surrogate</span>
					<span class="s1">codePoint = ((codePoint &amp; </span><span class="s3">0x3FF</span><span class="s1">) &lt;&lt; </span><span class="s3">10</span><span class="s1">) + (extra &amp; </span><span class="s3">0x3FF</span><span class="s1">) + </span><span class="s3">0x10000</span><span class="s0">;</span>
				<span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
					<span class="s4">// Its an unmatched surrogate; only append this code unit, in case</span>
					<span class="s4">// the next code unit is the high surrogate of a surrogate pair.</span>
					<span class="s1">counter--</span><span class="s0">;</span>
				<span class="s1">}</span>
			<span class="s1">}</span>
			<span class="s1">value = </span><span class="s2">'</span><span class="s0">\\</span><span class="s2">' </span><span class="s1">+ codePoint.toString(</span><span class="s3">16</span><span class="s1">).toUpperCase() + </span><span class="s2">' '</span><span class="s0">;</span>
		<span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
			<span class="s0">if </span><span class="s1">(options.escapeEverything) {</span>
				<span class="s0">if </span><span class="s1">(regexAnySingleEscape.test(character)) {</span>
					<span class="s1">value = </span><span class="s2">'</span><span class="s0">\\</span><span class="s2">' </span><span class="s1">+ character</span><span class="s0">;</span>
				<span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
					<span class="s1">value = </span><span class="s2">'</span><span class="s0">\\</span><span class="s2">' </span><span class="s1">+ codePoint.toString(</span><span class="s3">16</span><span class="s1">).toUpperCase() + </span><span class="s2">' '</span><span class="s0">;</span>
				<span class="s1">}</span>
			<span class="s1">} </span><span class="s0">else if </span><span class="s1">(</span><span class="s3">/[\t\n\f\r\x0B]/</span><span class="s1">.test(character)) {</span>
				<span class="s1">value = </span><span class="s2">'</span><span class="s0">\\</span><span class="s2">' </span><span class="s1">+ codePoint.toString(</span><span class="s3">16</span><span class="s1">).toUpperCase() + </span><span class="s2">' '</span><span class="s0">;</span>
			<span class="s1">} </span><span class="s0">else if </span><span class="s1">(character == </span><span class="s2">'</span><span class="s0">\\</span><span class="s2">' </span><span class="s1">|| !isIdentifier &amp;&amp; (character == </span><span class="s2">'&quot;' </span><span class="s1">&amp;&amp; quote == character || character == </span><span class="s2">'</span><span class="s0">\'</span><span class="s2">' </span><span class="s1">&amp;&amp; quote == character) || isIdentifier &amp;&amp; regexSingleEscape.test(character)) {</span>
				<span class="s1">value = </span><span class="s2">'</span><span class="s0">\\</span><span class="s2">' </span><span class="s1">+ character</span><span class="s0">;</span>
			<span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
				<span class="s1">value = character</span><span class="s0">;</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
		<span class="s1">output += value</span><span class="s0">;</span>
	<span class="s1">}</span>

	<span class="s0">if </span><span class="s1">(isIdentifier) {</span>
		<span class="s0">if </span><span class="s1">(</span><span class="s3">/^-[-\d]/</span><span class="s1">.test(output)) {</span>
			<span class="s1">output = </span><span class="s2">'</span><span class="s0">\\</span><span class="s2">-' </span><span class="s1">+ output.slice(</span><span class="s3">1</span><span class="s1">)</span><span class="s0">;</span>
		<span class="s1">} </span><span class="s0">else if </span><span class="s1">(</span><span class="s3">/\d/</span><span class="s1">.test(firstChar)) {</span>
			<span class="s1">output = </span><span class="s2">'</span><span class="s0">\\</span><span class="s2">3' </span><span class="s1">+ firstChar + </span><span class="s2">' ' </span><span class="s1">+ output.slice(</span><span class="s3">1</span><span class="s1">)</span><span class="s0">;</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s4">// Remove spaces after `\HEX` escapes that are not followed by a hex digit,</span>
	<span class="s4">// since theyre redundant. Note that this is only possible if the escape</span>
	<span class="s4">// sequence isnt preceded by an odd number of backslashes.</span>
	<span class="s1">output = output.replace(regexExcessiveSpaces</span><span class="s0">, function </span><span class="s1">($0</span><span class="s0">, </span><span class="s1">$1</span><span class="s0">, </span><span class="s1">$2) {</span>
		<span class="s0">if </span><span class="s1">($1 &amp;&amp; $1.length % </span><span class="s3">2</span><span class="s1">) {</span>
			<span class="s4">// Its not safe to remove the space, so dont.</span>
			<span class="s0">return </span><span class="s1">$0</span><span class="s0">;</span>
		<span class="s1">}</span>
		<span class="s4">// Strip the space.</span>
		<span class="s0">return </span><span class="s1">($1 || </span><span class="s2">''</span><span class="s1">) + $2</span><span class="s0">;</span>
	<span class="s1">})</span><span class="s0">;</span>

	<span class="s0">if </span><span class="s1">(!isIdentifier &amp;&amp; options.wrap) {</span>
		<span class="s0">return </span><span class="s1">quote + output + quote</span><span class="s0">;</span>
	<span class="s1">}</span>
	<span class="s0">return </span><span class="s1">output</span><span class="s0">;</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s4">// Expose default options (so they can be overridden globally).</span>
<span class="s1">cssesc.options = {</span>
	<span class="s2">'escapeEverything'</span><span class="s1">: </span><span class="s0">false,</span>
	<span class="s2">'isIdentifier'</span><span class="s1">: </span><span class="s0">false,</span>
	<span class="s2">'quotes'</span><span class="s1">: </span><span class="s2">'single'</span><span class="s0">,</span>
	<span class="s2">'wrap'</span><span class="s1">: </span><span class="s0">false</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s1">cssesc.version = </span><span class="s2">'3.0.0'</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">cssesc_1 = cssesc</span><span class="s0">;</span>

<span class="s1">(</span><span class="s0">function </span><span class="s1">(module</span><span class="s0">, </span><span class="s1">exports) {</span>

	<span class="s1">exports.__esModule = </span><span class="s0">true;</span>
	<span class="s1">exports[</span><span class="s2">&quot;default&quot;</span><span class="s1">] = </span><span class="s0">void </span><span class="s3">0</span><span class="s0">;</span>

	<span class="s0">var </span><span class="s1">_cssesc = _interopRequireDefault(cssesc_1)</span><span class="s0">;</span>

	<span class="s0">var </span><span class="s1">_util = util</span><span class="s0">;</span>

	<span class="s0">var </span><span class="s1">_node = _interopRequireDefault(nodeExports)</span><span class="s0">;</span>

	<span class="s0">var </span><span class="s1">_types = types</span><span class="s0">;</span>

	<span class="s0">function </span><span class="s1">_interopRequireDefault(obj) { </span><span class="s0">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : { </span><span class="s2">&quot;default&quot;</span><span class="s1">: obj }</span><span class="s0">; </span><span class="s1">}</span>

	<span class="s0">function </span><span class="s1">_defineProperties(target</span><span class="s0">, </span><span class="s1">props) { </span><span class="s0">for </span><span class="s1">(</span><span class="s0">var </span><span class="s1">i = </span><span class="s3">0</span><span class="s0">; </span><span class="s1">i &lt; props.length</span><span class="s0">; </span><span class="s1">i++) { </span><span class="s0">var </span><span class="s1">descriptor = props[i]</span><span class="s0">; </span><span class="s1">descriptor.enumerable = descriptor.enumerable || </span><span class="s0">false; </span><span class="s1">descriptor.configurable = </span><span class="s0">true; if </span><span class="s1">(</span><span class="s2">&quot;value&quot; </span><span class="s0">in </span><span class="s1">descriptor) descriptor.writable = </span><span class="s0">true; </span><span class="s1">Object.defineProperty(target</span><span class="s0">, </span><span class="s1">descriptor.key</span><span class="s0">, </span><span class="s1">descriptor)</span><span class="s0">; </span><span class="s1">} }</span>

	<span class="s0">function </span><span class="s1">_createClass(Constructor</span><span class="s0">, </span><span class="s1">protoProps</span><span class="s0">, </span><span class="s1">staticProps) { </span><span class="s0">if </span><span class="s1">(protoProps) _defineProperties(Constructor.prototype</span><span class="s0">, </span><span class="s1">protoProps)</span><span class="s0">; if </span><span class="s1">(staticProps) _defineProperties(Constructor</span><span class="s0">, </span><span class="s1">staticProps)</span><span class="s0">; return </span><span class="s1">Constructor</span><span class="s0">; </span><span class="s1">}</span>

	<span class="s0">function </span><span class="s1">_inheritsLoose(subClass</span><span class="s0">, </span><span class="s1">superClass) { subClass.prototype = Object.create(superClass.prototype)</span><span class="s0">; </span><span class="s1">subClass.prototype.constructor = subClass</span><span class="s0">; </span><span class="s1">_setPrototypeOf(subClass</span><span class="s0">, </span><span class="s1">superClass)</span><span class="s0">; </span><span class="s1">}</span>

	<span class="s0">function </span><span class="s1">_setPrototypeOf(o</span><span class="s0">, </span><span class="s1">p) { _setPrototypeOf = Object.setPrototypeOf || </span><span class="s0">function </span><span class="s1">_setPrototypeOf(o</span><span class="s0">, </span><span class="s1">p) { o.__proto__ = p</span><span class="s0">; return </span><span class="s1">o</span><span class="s0">; </span><span class="s1">}</span><span class="s0">; return </span><span class="s1">_setPrototypeOf(o</span><span class="s0">, </span><span class="s1">p)</span><span class="s0">; </span><span class="s1">}</span>

	<span class="s0">var </span><span class="s1">ClassName = </span><span class="s4">/*#__PURE__*/</span><span class="s0">function </span><span class="s1">(_Node) {</span>
	  <span class="s1">_inheritsLoose(ClassName</span><span class="s0">, </span><span class="s1">_Node)</span><span class="s0">;</span>

	  <span class="s0">function </span><span class="s1">ClassName(opts) {</span>
	    <span class="s0">var </span><span class="s1">_this</span><span class="s0">;</span>

	    <span class="s1">_this = _Node.call(</span><span class="s0">this, </span><span class="s1">opts) || </span><span class="s0">this;</span>
	    <span class="s1">_this.type = _types.CLASS</span><span class="s0">;</span>
	    <span class="s1">_this._constructed = </span><span class="s0">true;</span>
	    <span class="s0">return </span><span class="s1">_this</span><span class="s0">;</span>
	  <span class="s1">}</span>

	  <span class="s0">var </span><span class="s1">_proto = ClassName.prototype</span><span class="s0">;</span>

	  <span class="s1">_proto.valueToString = </span><span class="s0">function </span><span class="s1">valueToString() {</span>
	    <span class="s0">return </span><span class="s2">'.' </span><span class="s1">+ _Node.prototype.valueToString.call(</span><span class="s0">this</span><span class="s1">)</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_createClass(ClassName</span><span class="s0">, </span><span class="s1">[{</span>
	    <span class="s1">key: </span><span class="s2">&quot;value&quot;</span><span class="s0">,</span>
	    <span class="s1">get: </span><span class="s0">function </span><span class="s1">get() {</span>
	      <span class="s0">return this</span><span class="s1">._value</span><span class="s0">;</span>
	    <span class="s1">}</span><span class="s0">,</span>
	    <span class="s1">set: </span><span class="s0">function </span><span class="s1">set(v) {</span>
	      <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">._constructed) {</span>
	        <span class="s0">var </span><span class="s1">escaped = (</span><span class="s3">0</span><span class="s0">, </span><span class="s1">_cssesc[</span><span class="s2">&quot;default&quot;</span><span class="s1">])(v</span><span class="s0">, </span><span class="s1">{</span>
	          <span class="s1">isIdentifier: </span><span class="s0">true</span>
	        <span class="s1">})</span><span class="s0">;</span>

	        <span class="s0">if </span><span class="s1">(escaped !== v) {</span>
	          <span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">_util.ensureObject)(</span><span class="s0">this, </span><span class="s2">&quot;raws&quot;</span><span class="s1">)</span><span class="s0">;</span>
	          <span class="s0">this</span><span class="s1">.raws.value = escaped</span><span class="s0">;</span>
	        <span class="s1">} </span><span class="s0">else if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.raws) {</span>
	          <span class="s0">delete this</span><span class="s1">.raws.value</span><span class="s0">;</span>
	        <span class="s1">}</span>
	      <span class="s1">}</span>

	      <span class="s0">this</span><span class="s1">._value = v</span><span class="s0">;</span>
	    <span class="s1">}</span>
	  <span class="s1">}])</span><span class="s0">;</span>

	  <span class="s0">return </span><span class="s1">ClassName</span><span class="s0">;</span>
	<span class="s1">}(_node[</span><span class="s2">&quot;default&quot;</span><span class="s1">])</span><span class="s0">;</span>

	<span class="s1">exports[</span><span class="s2">&quot;default&quot;</span><span class="s1">] = ClassName</span><span class="s0">;</span>
	<span class="s1">module.exports = exports.default</span><span class="s0">;</span>
<span class="s1">} (className$1</span><span class="s0">, </span><span class="s1">classNameExports))</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">commentExports = {}</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">comment$2 = {</span>
  <span class="s1">get exports(){ </span><span class="s0">return </span><span class="s1">commentExports</span><span class="s0">; </span><span class="s1">}</span><span class="s0">,</span>
  <span class="s1">set exports(v){ commentExports = v</span><span class="s0">; </span><span class="s1">}</span><span class="s0">,</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s1">(</span><span class="s0">function </span><span class="s1">(module</span><span class="s0">, </span><span class="s1">exports) {</span>

	<span class="s1">exports.__esModule = </span><span class="s0">true;</span>
	<span class="s1">exports[</span><span class="s2">&quot;default&quot;</span><span class="s1">] = </span><span class="s0">void </span><span class="s3">0</span><span class="s0">;</span>

	<span class="s0">var </span><span class="s1">_node = _interopRequireDefault(nodeExports)</span><span class="s0">;</span>

	<span class="s0">var </span><span class="s1">_types = types</span><span class="s0">;</span>

	<span class="s0">function </span><span class="s1">_interopRequireDefault(obj) { </span><span class="s0">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : { </span><span class="s2">&quot;default&quot;</span><span class="s1">: obj }</span><span class="s0">; </span><span class="s1">}</span>

	<span class="s0">function </span><span class="s1">_inheritsLoose(subClass</span><span class="s0">, </span><span class="s1">superClass) { subClass.prototype = Object.create(superClass.prototype)</span><span class="s0">; </span><span class="s1">subClass.prototype.constructor = subClass</span><span class="s0">; </span><span class="s1">_setPrototypeOf(subClass</span><span class="s0">, </span><span class="s1">superClass)</span><span class="s0">; </span><span class="s1">}</span>

	<span class="s0">function </span><span class="s1">_setPrototypeOf(o</span><span class="s0">, </span><span class="s1">p) { _setPrototypeOf = Object.setPrototypeOf || </span><span class="s0">function </span><span class="s1">_setPrototypeOf(o</span><span class="s0">, </span><span class="s1">p) { o.__proto__ = p</span><span class="s0">; return </span><span class="s1">o</span><span class="s0">; </span><span class="s1">}</span><span class="s0">; return </span><span class="s1">_setPrototypeOf(o</span><span class="s0">, </span><span class="s1">p)</span><span class="s0">; </span><span class="s1">}</span>

	<span class="s0">var </span><span class="s1">Comment = </span><span class="s4">/*#__PURE__*/</span><span class="s0">function </span><span class="s1">(_Node) {</span>
	  <span class="s1">_inheritsLoose(Comment</span><span class="s0">, </span><span class="s1">_Node)</span><span class="s0">;</span>

	  <span class="s0">function </span><span class="s1">Comment(opts) {</span>
	    <span class="s0">var </span><span class="s1">_this</span><span class="s0">;</span>

	    <span class="s1">_this = _Node.call(</span><span class="s0">this, </span><span class="s1">opts) || </span><span class="s0">this;</span>
	    <span class="s1">_this.type = _types.COMMENT</span><span class="s0">;</span>
	    <span class="s0">return </span><span class="s1">_this</span><span class="s0">;</span>
	  <span class="s1">}</span>

	  <span class="s0">return </span><span class="s1">Comment</span><span class="s0">;</span>
	<span class="s1">}(_node[</span><span class="s2">&quot;default&quot;</span><span class="s1">])</span><span class="s0">;</span>

	<span class="s1">exports[</span><span class="s2">&quot;default&quot;</span><span class="s1">] = Comment</span><span class="s0">;</span>
	<span class="s1">module.exports = exports.default</span><span class="s0">;</span>
<span class="s1">} (comment$2</span><span class="s0">, </span><span class="s1">commentExports))</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">idExports = {}</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">id$1 = {</span>
  <span class="s1">get exports(){ </span><span class="s0">return </span><span class="s1">idExports</span><span class="s0">; </span><span class="s1">}</span><span class="s0">,</span>
  <span class="s1">set exports(v){ idExports = v</span><span class="s0">; </span><span class="s1">}</span><span class="s0">,</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s1">(</span><span class="s0">function </span><span class="s1">(module</span><span class="s0">, </span><span class="s1">exports) {</span>

	<span class="s1">exports.__esModule = </span><span class="s0">true;</span>
	<span class="s1">exports[</span><span class="s2">&quot;default&quot;</span><span class="s1">] = </span><span class="s0">void </span><span class="s3">0</span><span class="s0">;</span>

	<span class="s0">var </span><span class="s1">_node = _interopRequireDefault(nodeExports)</span><span class="s0">;</span>

	<span class="s0">var </span><span class="s1">_types = types</span><span class="s0">;</span>

	<span class="s0">function </span><span class="s1">_interopRequireDefault(obj) { </span><span class="s0">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : { </span><span class="s2">&quot;default&quot;</span><span class="s1">: obj }</span><span class="s0">; </span><span class="s1">}</span>

	<span class="s0">function </span><span class="s1">_inheritsLoose(subClass</span><span class="s0">, </span><span class="s1">superClass) { subClass.prototype = Object.create(superClass.prototype)</span><span class="s0">; </span><span class="s1">subClass.prototype.constructor = subClass</span><span class="s0">; </span><span class="s1">_setPrototypeOf(subClass</span><span class="s0">, </span><span class="s1">superClass)</span><span class="s0">; </span><span class="s1">}</span>

	<span class="s0">function </span><span class="s1">_setPrototypeOf(o</span><span class="s0">, </span><span class="s1">p) { _setPrototypeOf = Object.setPrototypeOf || </span><span class="s0">function </span><span class="s1">_setPrototypeOf(o</span><span class="s0">, </span><span class="s1">p) { o.__proto__ = p</span><span class="s0">; return </span><span class="s1">o</span><span class="s0">; </span><span class="s1">}</span><span class="s0">; return </span><span class="s1">_setPrototypeOf(o</span><span class="s0">, </span><span class="s1">p)</span><span class="s0">; </span><span class="s1">}</span>

	<span class="s0">var </span><span class="s1">ID = </span><span class="s4">/*#__PURE__*/</span><span class="s0">function </span><span class="s1">(_Node) {</span>
	  <span class="s1">_inheritsLoose(ID</span><span class="s0">, </span><span class="s1">_Node)</span><span class="s0">;</span>

	  <span class="s0">function </span><span class="s1">ID(opts) {</span>
	    <span class="s0">var </span><span class="s1">_this</span><span class="s0">;</span>

	    <span class="s1">_this = _Node.call(</span><span class="s0">this, </span><span class="s1">opts) || </span><span class="s0">this;</span>
	    <span class="s1">_this.type = _types.ID</span><span class="s0">;</span>
	    <span class="s0">return </span><span class="s1">_this</span><span class="s0">;</span>
	  <span class="s1">}</span>

	  <span class="s0">var </span><span class="s1">_proto = ID.prototype</span><span class="s0">;</span>

	  <span class="s1">_proto.valueToString = </span><span class="s0">function </span><span class="s1">valueToString() {</span>
	    <span class="s0">return </span><span class="s2">'#' </span><span class="s1">+ _Node.prototype.valueToString.call(</span><span class="s0">this</span><span class="s1">)</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s0">return </span><span class="s1">ID</span><span class="s0">;</span>
	<span class="s1">}(_node[</span><span class="s2">&quot;default&quot;</span><span class="s1">])</span><span class="s0">;</span>

	<span class="s1">exports[</span><span class="s2">&quot;default&quot;</span><span class="s1">] = ID</span><span class="s0">;</span>
	<span class="s1">module.exports = exports.default</span><span class="s0">;</span>
<span class="s1">} (id$1</span><span class="s0">, </span><span class="s1">idExports))</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">tagExports = {}</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">tag$1 = {</span>
  <span class="s1">get exports(){ </span><span class="s0">return </span><span class="s1">tagExports</span><span class="s0">; </span><span class="s1">}</span><span class="s0">,</span>
  <span class="s1">set exports(v){ tagExports = v</span><span class="s0">; </span><span class="s1">}</span><span class="s0">,</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">namespaceExports = {}</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">namespace = {</span>
  <span class="s1">get exports(){ </span><span class="s0">return </span><span class="s1">namespaceExports</span><span class="s0">; </span><span class="s1">}</span><span class="s0">,</span>
  <span class="s1">set exports(v){ namespaceExports = v</span><span class="s0">; </span><span class="s1">}</span><span class="s0">,</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s1">(</span><span class="s0">function </span><span class="s1">(module</span><span class="s0">, </span><span class="s1">exports) {</span>

	<span class="s1">exports.__esModule = </span><span class="s0">true;</span>
	<span class="s1">exports[</span><span class="s2">&quot;default&quot;</span><span class="s1">] = </span><span class="s0">void </span><span class="s3">0</span><span class="s0">;</span>

	<span class="s0">var </span><span class="s1">_cssesc = _interopRequireDefault(cssesc_1)</span><span class="s0">;</span>

	<span class="s0">var </span><span class="s1">_util = util</span><span class="s0">;</span>

	<span class="s0">var </span><span class="s1">_node = _interopRequireDefault(nodeExports)</span><span class="s0">;</span>

	<span class="s0">function </span><span class="s1">_interopRequireDefault(obj) { </span><span class="s0">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : { </span><span class="s2">&quot;default&quot;</span><span class="s1">: obj }</span><span class="s0">; </span><span class="s1">}</span>

	<span class="s0">function </span><span class="s1">_defineProperties(target</span><span class="s0">, </span><span class="s1">props) { </span><span class="s0">for </span><span class="s1">(</span><span class="s0">var </span><span class="s1">i = </span><span class="s3">0</span><span class="s0">; </span><span class="s1">i &lt; props.length</span><span class="s0">; </span><span class="s1">i++) { </span><span class="s0">var </span><span class="s1">descriptor = props[i]</span><span class="s0">; </span><span class="s1">descriptor.enumerable = descriptor.enumerable || </span><span class="s0">false; </span><span class="s1">descriptor.configurable = </span><span class="s0">true; if </span><span class="s1">(</span><span class="s2">&quot;value&quot; </span><span class="s0">in </span><span class="s1">descriptor) descriptor.writable = </span><span class="s0">true; </span><span class="s1">Object.defineProperty(target</span><span class="s0">, </span><span class="s1">descriptor.key</span><span class="s0">, </span><span class="s1">descriptor)</span><span class="s0">; </span><span class="s1">} }</span>

	<span class="s0">function </span><span class="s1">_createClass(Constructor</span><span class="s0">, </span><span class="s1">protoProps</span><span class="s0">, </span><span class="s1">staticProps) { </span><span class="s0">if </span><span class="s1">(protoProps) _defineProperties(Constructor.prototype</span><span class="s0">, </span><span class="s1">protoProps)</span><span class="s0">; if </span><span class="s1">(staticProps) _defineProperties(Constructor</span><span class="s0">, </span><span class="s1">staticProps)</span><span class="s0">; return </span><span class="s1">Constructor</span><span class="s0">; </span><span class="s1">}</span>

	<span class="s0">function </span><span class="s1">_inheritsLoose(subClass</span><span class="s0">, </span><span class="s1">superClass) { subClass.prototype = Object.create(superClass.prototype)</span><span class="s0">; </span><span class="s1">subClass.prototype.constructor = subClass</span><span class="s0">; </span><span class="s1">_setPrototypeOf(subClass</span><span class="s0">, </span><span class="s1">superClass)</span><span class="s0">; </span><span class="s1">}</span>

	<span class="s0">function </span><span class="s1">_setPrototypeOf(o</span><span class="s0">, </span><span class="s1">p) { _setPrototypeOf = Object.setPrototypeOf || </span><span class="s0">function </span><span class="s1">_setPrototypeOf(o</span><span class="s0">, </span><span class="s1">p) { o.__proto__ = p</span><span class="s0">; return </span><span class="s1">o</span><span class="s0">; </span><span class="s1">}</span><span class="s0">; return </span><span class="s1">_setPrototypeOf(o</span><span class="s0">, </span><span class="s1">p)</span><span class="s0">; </span><span class="s1">}</span>

	<span class="s0">var </span><span class="s1">Namespace = </span><span class="s4">/*#__PURE__*/</span><span class="s0">function </span><span class="s1">(_Node) {</span>
	  <span class="s1">_inheritsLoose(Namespace</span><span class="s0">, </span><span class="s1">_Node)</span><span class="s0">;</span>

	  <span class="s0">function </span><span class="s1">Namespace() {</span>
	    <span class="s0">return </span><span class="s1">_Node.apply(</span><span class="s0">this, </span><span class="s1">arguments) || </span><span class="s0">this;</span>
	  <span class="s1">}</span>

	  <span class="s0">var </span><span class="s1">_proto = Namespace.prototype</span><span class="s0">;</span>

	  <span class="s1">_proto.qualifiedName = </span><span class="s0">function </span><span class="s1">qualifiedName(value) {</span>
	    <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.namespace) {</span>
	      <span class="s0">return this</span><span class="s1">.namespaceString + </span><span class="s2">&quot;|&quot; </span><span class="s1">+ value</span><span class="s0">;</span>
	    <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
	      <span class="s0">return </span><span class="s1">value</span><span class="s0">;</span>
	    <span class="s1">}</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.valueToString = </span><span class="s0">function </span><span class="s1">valueToString() {</span>
	    <span class="s0">return this</span><span class="s1">.qualifiedName(_Node.prototype.valueToString.call(</span><span class="s0">this</span><span class="s1">))</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_createClass(Namespace</span><span class="s0">, </span><span class="s1">[{</span>
	    <span class="s1">key: </span><span class="s2">&quot;namespace&quot;</span><span class="s0">,</span>
	    <span class="s1">get: </span><span class="s0">function </span><span class="s1">get() {</span>
	      <span class="s0">return this</span><span class="s1">._namespace</span><span class="s0">;</span>
	    <span class="s1">}</span><span class="s0">,</span>
	    <span class="s1">set: </span><span class="s0">function </span><span class="s1">set(namespace) {</span>
	      <span class="s0">if </span><span class="s1">(namespace === </span><span class="s0">true </span><span class="s1">|| namespace === </span><span class="s2">&quot;*&quot; </span><span class="s1">|| namespace === </span><span class="s2">&quot;&amp;&quot;</span><span class="s1">) {</span>
	        <span class="s0">this</span><span class="s1">._namespace = namespace</span><span class="s0">;</span>

	        <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.raws) {</span>
	          <span class="s0">delete this</span><span class="s1">.raws.namespace</span><span class="s0">;</span>
	        <span class="s1">}</span>

	        <span class="s0">return;</span>
	      <span class="s1">}</span>

	      <span class="s0">var </span><span class="s1">escaped = (</span><span class="s3">0</span><span class="s0">, </span><span class="s1">_cssesc[</span><span class="s2">&quot;default&quot;</span><span class="s1">])(namespace</span><span class="s0">, </span><span class="s1">{</span>
	        <span class="s1">isIdentifier: </span><span class="s0">true</span>
	      <span class="s1">})</span><span class="s0">;</span>
	      <span class="s0">this</span><span class="s1">._namespace = namespace</span><span class="s0">;</span>

	      <span class="s0">if </span><span class="s1">(escaped !== namespace) {</span>
	        <span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">_util.ensureObject)(</span><span class="s0">this, </span><span class="s2">&quot;raws&quot;</span><span class="s1">)</span><span class="s0">;</span>
	        <span class="s0">this</span><span class="s1">.raws.namespace = escaped</span><span class="s0">;</span>
	      <span class="s1">} </span><span class="s0">else if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.raws) {</span>
	        <span class="s0">delete this</span><span class="s1">.raws.namespace</span><span class="s0">;</span>
	      <span class="s1">}</span>
	    <span class="s1">}</span>
	  <span class="s1">}</span><span class="s0">, </span><span class="s1">{</span>
	    <span class="s1">key: </span><span class="s2">&quot;ns&quot;</span><span class="s0">,</span>
	    <span class="s1">get: </span><span class="s0">function </span><span class="s1">get() {</span>
	      <span class="s0">return this</span><span class="s1">._namespace</span><span class="s0">;</span>
	    <span class="s1">}</span><span class="s0">,</span>
	    <span class="s1">set: </span><span class="s0">function </span><span class="s1">set(namespace) {</span>
	      <span class="s0">this</span><span class="s1">.namespace = namespace</span><span class="s0">;</span>
	    <span class="s1">}</span>
	  <span class="s1">}</span><span class="s0">, </span><span class="s1">{</span>
	    <span class="s1">key: </span><span class="s2">&quot;namespaceString&quot;</span><span class="s0">,</span>
	    <span class="s1">get: </span><span class="s0">function </span><span class="s1">get() {</span>
	      <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.namespace) {</span>
	        <span class="s0">var </span><span class="s1">ns = </span><span class="s0">this</span><span class="s1">.stringifyProperty(</span><span class="s2">&quot;namespace&quot;</span><span class="s1">)</span><span class="s0">;</span>

	        <span class="s0">if </span><span class="s1">(ns === </span><span class="s0">true</span><span class="s1">) {</span>
	          <span class="s0">return </span><span class="s2">''</span><span class="s0">;</span>
	        <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
	          <span class="s0">return </span><span class="s1">ns</span><span class="s0">;</span>
	        <span class="s1">}</span>
	      <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
	        <span class="s0">return </span><span class="s2">''</span><span class="s0">;</span>
	      <span class="s1">}</span>
	    <span class="s1">}</span>
	  <span class="s1">}])</span><span class="s0">;</span>

	  <span class="s0">return </span><span class="s1">Namespace</span><span class="s0">;</span>
	<span class="s1">}(_node[</span><span class="s2">&quot;default&quot;</span><span class="s1">])</span><span class="s0">;</span>

	<span class="s1">exports[</span><span class="s2">&quot;default&quot;</span><span class="s1">] = Namespace</span><span class="s0">;</span>
	<span class="s1">module.exports = exports.default</span><span class="s0">;</span>
<span class="s1">} (namespace</span><span class="s0">, </span><span class="s1">namespaceExports))</span><span class="s0">;</span>

<span class="s1">(</span><span class="s0">function </span><span class="s1">(module</span><span class="s0">, </span><span class="s1">exports) {</span>

	<span class="s1">exports.__esModule = </span><span class="s0">true;</span>
	<span class="s1">exports[</span><span class="s2">&quot;default&quot;</span><span class="s1">] = </span><span class="s0">void </span><span class="s3">0</span><span class="s0">;</span>

	<span class="s0">var </span><span class="s1">_namespace = _interopRequireDefault(namespaceExports)</span><span class="s0">;</span>

	<span class="s0">var </span><span class="s1">_types = types</span><span class="s0">;</span>

	<span class="s0">function </span><span class="s1">_interopRequireDefault(obj) { </span><span class="s0">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : { </span><span class="s2">&quot;default&quot;</span><span class="s1">: obj }</span><span class="s0">; </span><span class="s1">}</span>

	<span class="s0">function </span><span class="s1">_inheritsLoose(subClass</span><span class="s0">, </span><span class="s1">superClass) { subClass.prototype = Object.create(superClass.prototype)</span><span class="s0">; </span><span class="s1">subClass.prototype.constructor = subClass</span><span class="s0">; </span><span class="s1">_setPrototypeOf(subClass</span><span class="s0">, </span><span class="s1">superClass)</span><span class="s0">; </span><span class="s1">}</span>

	<span class="s0">function </span><span class="s1">_setPrototypeOf(o</span><span class="s0">, </span><span class="s1">p) { _setPrototypeOf = Object.setPrototypeOf || </span><span class="s0">function </span><span class="s1">_setPrototypeOf(o</span><span class="s0">, </span><span class="s1">p) { o.__proto__ = p</span><span class="s0">; return </span><span class="s1">o</span><span class="s0">; </span><span class="s1">}</span><span class="s0">; return </span><span class="s1">_setPrototypeOf(o</span><span class="s0">, </span><span class="s1">p)</span><span class="s0">; </span><span class="s1">}</span>

	<span class="s0">var </span><span class="s1">Tag = </span><span class="s4">/*#__PURE__*/</span><span class="s0">function </span><span class="s1">(_Namespace) {</span>
	  <span class="s1">_inheritsLoose(Tag</span><span class="s0">, </span><span class="s1">_Namespace)</span><span class="s0">;</span>

	  <span class="s0">function </span><span class="s1">Tag(opts) {</span>
	    <span class="s0">var </span><span class="s1">_this</span><span class="s0">;</span>

	    <span class="s1">_this = _Namespace.call(</span><span class="s0">this, </span><span class="s1">opts) || </span><span class="s0">this;</span>
	    <span class="s1">_this.type = _types.TAG</span><span class="s0">;</span>
	    <span class="s0">return </span><span class="s1">_this</span><span class="s0">;</span>
	  <span class="s1">}</span>

	  <span class="s0">return </span><span class="s1">Tag</span><span class="s0">;</span>
	<span class="s1">}(_namespace[</span><span class="s2">&quot;default&quot;</span><span class="s1">])</span><span class="s0">;</span>

	<span class="s1">exports[</span><span class="s2">&quot;default&quot;</span><span class="s1">] = Tag</span><span class="s0">;</span>
	<span class="s1">module.exports = exports.default</span><span class="s0">;</span>
<span class="s1">} (tag$1</span><span class="s0">, </span><span class="s1">tagExports))</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">stringExports = {}</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">string$1 = {</span>
  <span class="s1">get exports(){ </span><span class="s0">return </span><span class="s1">stringExports</span><span class="s0">; </span><span class="s1">}</span><span class="s0">,</span>
  <span class="s1">set exports(v){ stringExports = v</span><span class="s0">; </span><span class="s1">}</span><span class="s0">,</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s1">(</span><span class="s0">function </span><span class="s1">(module</span><span class="s0">, </span><span class="s1">exports) {</span>

	<span class="s1">exports.__esModule = </span><span class="s0">true;</span>
	<span class="s1">exports[</span><span class="s2">&quot;default&quot;</span><span class="s1">] = </span><span class="s0">void </span><span class="s3">0</span><span class="s0">;</span>

	<span class="s0">var </span><span class="s1">_node = _interopRequireDefault(nodeExports)</span><span class="s0">;</span>

	<span class="s0">var </span><span class="s1">_types = types</span><span class="s0">;</span>

	<span class="s0">function </span><span class="s1">_interopRequireDefault(obj) { </span><span class="s0">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : { </span><span class="s2">&quot;default&quot;</span><span class="s1">: obj }</span><span class="s0">; </span><span class="s1">}</span>

	<span class="s0">function </span><span class="s1">_inheritsLoose(subClass</span><span class="s0">, </span><span class="s1">superClass) { subClass.prototype = Object.create(superClass.prototype)</span><span class="s0">; </span><span class="s1">subClass.prototype.constructor = subClass</span><span class="s0">; </span><span class="s1">_setPrototypeOf(subClass</span><span class="s0">, </span><span class="s1">superClass)</span><span class="s0">; </span><span class="s1">}</span>

	<span class="s0">function </span><span class="s1">_setPrototypeOf(o</span><span class="s0">, </span><span class="s1">p) { _setPrototypeOf = Object.setPrototypeOf || </span><span class="s0">function </span><span class="s1">_setPrototypeOf(o</span><span class="s0">, </span><span class="s1">p) { o.__proto__ = p</span><span class="s0">; return </span><span class="s1">o</span><span class="s0">; </span><span class="s1">}</span><span class="s0">; return </span><span class="s1">_setPrototypeOf(o</span><span class="s0">, </span><span class="s1">p)</span><span class="s0">; </span><span class="s1">}</span>

	<span class="s0">var </span><span class="s1">String = </span><span class="s4">/*#__PURE__*/</span><span class="s0">function </span><span class="s1">(_Node) {</span>
	  <span class="s1">_inheritsLoose(String</span><span class="s0">, </span><span class="s1">_Node)</span><span class="s0">;</span>

	  <span class="s0">function </span><span class="s1">String(opts) {</span>
	    <span class="s0">var </span><span class="s1">_this</span><span class="s0">;</span>

	    <span class="s1">_this = _Node.call(</span><span class="s0">this, </span><span class="s1">opts) || </span><span class="s0">this;</span>
	    <span class="s1">_this.type = _types.STRING</span><span class="s0">;</span>
	    <span class="s0">return </span><span class="s1">_this</span><span class="s0">;</span>
	  <span class="s1">}</span>

	  <span class="s0">return </span><span class="s1">String</span><span class="s0">;</span>
	<span class="s1">}(_node[</span><span class="s2">&quot;default&quot;</span><span class="s1">])</span><span class="s0">;</span>

	<span class="s1">exports[</span><span class="s2">&quot;default&quot;</span><span class="s1">] = String</span><span class="s0">;</span>
	<span class="s1">module.exports = exports.default</span><span class="s0">;</span>
<span class="s1">} (string$1</span><span class="s0">, </span><span class="s1">stringExports))</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">pseudoExports = {}</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">pseudo$1 = {</span>
  <span class="s1">get exports(){ </span><span class="s0">return </span><span class="s1">pseudoExports</span><span class="s0">; </span><span class="s1">}</span><span class="s0">,</span>
  <span class="s1">set exports(v){ pseudoExports = v</span><span class="s0">; </span><span class="s1">}</span><span class="s0">,</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s1">(</span><span class="s0">function </span><span class="s1">(module</span><span class="s0">, </span><span class="s1">exports) {</span>

	<span class="s1">exports.__esModule = </span><span class="s0">true;</span>
	<span class="s1">exports[</span><span class="s2">&quot;default&quot;</span><span class="s1">] = </span><span class="s0">void </span><span class="s3">0</span><span class="s0">;</span>

	<span class="s0">var </span><span class="s1">_container = _interopRequireDefault(containerExports)</span><span class="s0">;</span>

	<span class="s0">var </span><span class="s1">_types = types</span><span class="s0">;</span>

	<span class="s0">function </span><span class="s1">_interopRequireDefault(obj) { </span><span class="s0">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : { </span><span class="s2">&quot;default&quot;</span><span class="s1">: obj }</span><span class="s0">; </span><span class="s1">}</span>

	<span class="s0">function </span><span class="s1">_inheritsLoose(subClass</span><span class="s0">, </span><span class="s1">superClass) { subClass.prototype = Object.create(superClass.prototype)</span><span class="s0">; </span><span class="s1">subClass.prototype.constructor = subClass</span><span class="s0">; </span><span class="s1">_setPrototypeOf(subClass</span><span class="s0">, </span><span class="s1">superClass)</span><span class="s0">; </span><span class="s1">}</span>

	<span class="s0">function </span><span class="s1">_setPrototypeOf(o</span><span class="s0">, </span><span class="s1">p) { _setPrototypeOf = Object.setPrototypeOf || </span><span class="s0">function </span><span class="s1">_setPrototypeOf(o</span><span class="s0">, </span><span class="s1">p) { o.__proto__ = p</span><span class="s0">; return </span><span class="s1">o</span><span class="s0">; </span><span class="s1">}</span><span class="s0">; return </span><span class="s1">_setPrototypeOf(o</span><span class="s0">, </span><span class="s1">p)</span><span class="s0">; </span><span class="s1">}</span>

	<span class="s0">var </span><span class="s1">Pseudo = </span><span class="s4">/*#__PURE__*/</span><span class="s0">function </span><span class="s1">(_Container) {</span>
	  <span class="s1">_inheritsLoose(Pseudo</span><span class="s0">, </span><span class="s1">_Container)</span><span class="s0">;</span>

	  <span class="s0">function </span><span class="s1">Pseudo(opts) {</span>
	    <span class="s0">var </span><span class="s1">_this</span><span class="s0">;</span>

	    <span class="s1">_this = _Container.call(</span><span class="s0">this, </span><span class="s1">opts) || </span><span class="s0">this;</span>
	    <span class="s1">_this.type = _types.PSEUDO</span><span class="s0">;</span>
	    <span class="s0">return </span><span class="s1">_this</span><span class="s0">;</span>
	  <span class="s1">}</span>

	  <span class="s0">var </span><span class="s1">_proto = Pseudo.prototype</span><span class="s0">;</span>

	  <span class="s1">_proto.toString = </span><span class="s0">function </span><span class="s1">toString() {</span>
	    <span class="s0">var </span><span class="s1">params = </span><span class="s0">this</span><span class="s1">.length ? </span><span class="s2">'(' </span><span class="s1">+ </span><span class="s0">this</span><span class="s1">.map(String).join(</span><span class="s2">','</span><span class="s1">) + </span><span class="s2">')' </span><span class="s1">: </span><span class="s2">''</span><span class="s0">;</span>
	    <span class="s0">return </span><span class="s1">[</span><span class="s0">this</span><span class="s1">.rawSpaceBefore</span><span class="s0">, this</span><span class="s1">.stringifyProperty(</span><span class="s2">&quot;value&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">params</span><span class="s0">, this</span><span class="s1">.rawSpaceAfter].join(</span><span class="s2">''</span><span class="s1">)</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s0">return </span><span class="s1">Pseudo</span><span class="s0">;</span>
	<span class="s1">}(_container[</span><span class="s2">&quot;default&quot;</span><span class="s1">])</span><span class="s0">;</span>

	<span class="s1">exports[</span><span class="s2">&quot;default&quot;</span><span class="s1">] = Pseudo</span><span class="s0">;</span>
	<span class="s1">module.exports = exports.default</span><span class="s0">;</span>
<span class="s1">} (pseudo$1</span><span class="s0">, </span><span class="s1">pseudoExports))</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">attribute$1 = {}</span><span class="s0">;</span>

<span class="s5">/**</span>
 <span class="s5">* For Node.js, simply re-export the core `util.deprecate` function.</span>
 <span class="s5">*/</span>

<span class="s0">var </span><span class="s1">node = require$$0$2.deprecate</span><span class="s0">;</span>

<span class="s1">(</span><span class="s0">function </span><span class="s1">(exports) {</span>

	<span class="s1">exports.__esModule = </span><span class="s0">true;</span>
	<span class="s1">exports.unescapeValue = unescapeValue</span><span class="s0">;</span>
	<span class="s1">exports[</span><span class="s2">&quot;default&quot;</span><span class="s1">] = </span><span class="s0">void </span><span class="s3">0</span><span class="s0">;</span>

	<span class="s0">var </span><span class="s1">_cssesc = _interopRequireDefault(cssesc_1)</span><span class="s0">;</span>

	<span class="s0">var </span><span class="s1">_unesc = _interopRequireDefault(unescExports)</span><span class="s0">;</span>

	<span class="s0">var </span><span class="s1">_namespace = _interopRequireDefault(namespaceExports)</span><span class="s0">;</span>

	<span class="s0">var </span><span class="s1">_types = types</span><span class="s0">;</span>

	<span class="s0">var </span><span class="s1">_CSSESC_QUOTE_OPTIONS</span><span class="s0">;</span>

	<span class="s0">function </span><span class="s1">_interopRequireDefault(obj) { </span><span class="s0">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : { </span><span class="s2">&quot;default&quot;</span><span class="s1">: obj }</span><span class="s0">; </span><span class="s1">}</span>

	<span class="s0">function </span><span class="s1">_defineProperties(target</span><span class="s0">, </span><span class="s1">props) { </span><span class="s0">for </span><span class="s1">(</span><span class="s0">var </span><span class="s1">i = </span><span class="s3">0</span><span class="s0">; </span><span class="s1">i &lt; props.length</span><span class="s0">; </span><span class="s1">i++) { </span><span class="s0">var </span><span class="s1">descriptor = props[i]</span><span class="s0">; </span><span class="s1">descriptor.enumerable = descriptor.enumerable || </span><span class="s0">false; </span><span class="s1">descriptor.configurable = </span><span class="s0">true; if </span><span class="s1">(</span><span class="s2">&quot;value&quot; </span><span class="s0">in </span><span class="s1">descriptor) descriptor.writable = </span><span class="s0">true; </span><span class="s1">Object.defineProperty(target</span><span class="s0">, </span><span class="s1">descriptor.key</span><span class="s0">, </span><span class="s1">descriptor)</span><span class="s0">; </span><span class="s1">} }</span>

	<span class="s0">function </span><span class="s1">_createClass(Constructor</span><span class="s0">, </span><span class="s1">protoProps</span><span class="s0">, </span><span class="s1">staticProps) { </span><span class="s0">if </span><span class="s1">(protoProps) _defineProperties(Constructor.prototype</span><span class="s0">, </span><span class="s1">protoProps)</span><span class="s0">; if </span><span class="s1">(staticProps) _defineProperties(Constructor</span><span class="s0">, </span><span class="s1">staticProps)</span><span class="s0">; return </span><span class="s1">Constructor</span><span class="s0">; </span><span class="s1">}</span>

	<span class="s0">function </span><span class="s1">_inheritsLoose(subClass</span><span class="s0">, </span><span class="s1">superClass) { subClass.prototype = Object.create(superClass.prototype)</span><span class="s0">; </span><span class="s1">subClass.prototype.constructor = subClass</span><span class="s0">; </span><span class="s1">_setPrototypeOf(subClass</span><span class="s0">, </span><span class="s1">superClass)</span><span class="s0">; </span><span class="s1">}</span>

	<span class="s0">function </span><span class="s1">_setPrototypeOf(o</span><span class="s0">, </span><span class="s1">p) { _setPrototypeOf = Object.setPrototypeOf || </span><span class="s0">function </span><span class="s1">_setPrototypeOf(o</span><span class="s0">, </span><span class="s1">p) { o.__proto__ = p</span><span class="s0">; return </span><span class="s1">o</span><span class="s0">; </span><span class="s1">}</span><span class="s0">; return </span><span class="s1">_setPrototypeOf(o</span><span class="s0">, </span><span class="s1">p)</span><span class="s0">; </span><span class="s1">}</span>

	<span class="s0">var </span><span class="s1">deprecate = node</span><span class="s0">;</span>

	<span class="s0">var </span><span class="s1">WRAPPED_IN_QUOTES = </span><span class="s3">/^('|&quot;)([^]*)\1$/</span><span class="s0">;</span>
	<span class="s0">var </span><span class="s1">warnOfDeprecatedValueAssignment = deprecate(</span><span class="s0">function </span><span class="s1">() {}</span><span class="s0">, </span><span class="s2">&quot;Assigning an attribute a value containing characters that might need to be escaped is deprecated. &quot; </span><span class="s1">+ </span><span class="s2">&quot;Call attribute.setValue() instead.&quot;</span><span class="s1">)</span><span class="s0">;</span>
	<span class="s0">var </span><span class="s1">warnOfDeprecatedQuotedAssignment = deprecate(</span><span class="s0">function </span><span class="s1">() {}</span><span class="s0">, </span><span class="s2">&quot;Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead.&quot;</span><span class="s1">)</span><span class="s0">;</span>
	<span class="s0">var </span><span class="s1">warnOfDeprecatedConstructor = deprecate(</span><span class="s0">function </span><span class="s1">() {}</span><span class="s0">, </span><span class="s2">&quot;Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.&quot;</span><span class="s1">)</span><span class="s0">;</span>

	<span class="s0">function </span><span class="s1">unescapeValue(value) {</span>
	  <span class="s0">var </span><span class="s1">deprecatedUsage = </span><span class="s0">false;</span>
	  <span class="s0">var </span><span class="s1">quoteMark = </span><span class="s0">null;</span>
	  <span class="s0">var </span><span class="s1">unescaped = value</span><span class="s0">;</span>
	  <span class="s0">var </span><span class="s1">m = unescaped.match(WRAPPED_IN_QUOTES)</span><span class="s0">;</span>

	  <span class="s0">if </span><span class="s1">(m) {</span>
	    <span class="s1">quoteMark = m[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">;</span>
	    <span class="s1">unescaped = m[</span><span class="s3">2</span><span class="s1">]</span><span class="s0">;</span>
	  <span class="s1">}</span>

	  <span class="s1">unescaped = (</span><span class="s3">0</span><span class="s0">, </span><span class="s1">_unesc[</span><span class="s2">&quot;default&quot;</span><span class="s1">])(unescaped)</span><span class="s0">;</span>

	  <span class="s0">if </span><span class="s1">(unescaped !== value) {</span>
	    <span class="s1">deprecatedUsage = </span><span class="s0">true;</span>
	  <span class="s1">}</span>

	  <span class="s0">return </span><span class="s1">{</span>
	    <span class="s1">deprecatedUsage: deprecatedUsage</span><span class="s0">,</span>
	    <span class="s1">unescaped: unescaped</span><span class="s0">,</span>
	    <span class="s1">quoteMark: quoteMark</span>
	  <span class="s1">}</span><span class="s0">;</span>
	<span class="s1">}</span>

	<span class="s0">function </span><span class="s1">handleDeprecatedContructorOpts(opts) {</span>
	  <span class="s0">if </span><span class="s1">(opts.quoteMark !== undefined) {</span>
	    <span class="s0">return </span><span class="s1">opts</span><span class="s0">;</span>
	  <span class="s1">}</span>

	  <span class="s0">if </span><span class="s1">(opts.value === undefined) {</span>
	    <span class="s0">return </span><span class="s1">opts</span><span class="s0">;</span>
	  <span class="s1">}</span>

	  <span class="s1">warnOfDeprecatedConstructor()</span><span class="s0">;</span>

	  <span class="s0">var </span><span class="s1">_unescapeValue = unescapeValue(opts.value)</span><span class="s0">,</span>
	      <span class="s1">quoteMark = _unescapeValue.quoteMark</span><span class="s0">,</span>
	      <span class="s1">unescaped = _unescapeValue.unescaped</span><span class="s0">;</span>

	  <span class="s0">if </span><span class="s1">(!opts.raws) {</span>
	    <span class="s1">opts.raws = {}</span><span class="s0">;</span>
	  <span class="s1">}</span>

	  <span class="s0">if </span><span class="s1">(opts.raws.value === undefined) {</span>
	    <span class="s1">opts.raws.value = opts.value</span><span class="s0">;</span>
	  <span class="s1">}</span>

	  <span class="s1">opts.value = unescaped</span><span class="s0">;</span>
	  <span class="s1">opts.quoteMark = quoteMark</span><span class="s0">;</span>
	  <span class="s0">return </span><span class="s1">opts</span><span class="s0">;</span>
	<span class="s1">}</span>

	<span class="s0">var </span><span class="s1">Attribute = </span><span class="s4">/*#__PURE__*/</span><span class="s0">function </span><span class="s1">(_Namespace) {</span>
	  <span class="s1">_inheritsLoose(Attribute</span><span class="s0">, </span><span class="s1">_Namespace)</span><span class="s0">;</span>

	  <span class="s0">function </span><span class="s1">Attribute(opts) {</span>
	    <span class="s0">var </span><span class="s1">_this</span><span class="s0">;</span>

	    <span class="s0">if </span><span class="s1">(opts === </span><span class="s0">void </span><span class="s3">0</span><span class="s1">) {</span>
	      <span class="s1">opts = {}</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s1">_this = _Namespace.call(</span><span class="s0">this, </span><span class="s1">handleDeprecatedContructorOpts(opts)) || </span><span class="s0">this;</span>
	    <span class="s1">_this.type = _types.ATTRIBUTE</span><span class="s0">;</span>
	    <span class="s1">_this.raws = _this.raws || {}</span><span class="s0">;</span>
	    <span class="s1">Object.defineProperty(_this.raws</span><span class="s0">, </span><span class="s2">'unquoted'</span><span class="s0">, </span><span class="s1">{</span>
	      <span class="s1">get: deprecate(</span><span class="s0">function </span><span class="s1">() {</span>
	        <span class="s0">return </span><span class="s1">_this.value</span><span class="s0">;</span>
	      <span class="s1">}</span><span class="s0">, </span><span class="s2">&quot;attr.raws.unquoted is deprecated. Call attr.value instead.&quot;</span><span class="s1">)</span><span class="s0">,</span>
	      <span class="s1">set: deprecate(</span><span class="s0">function </span><span class="s1">() {</span>
	        <span class="s0">return </span><span class="s1">_this.value</span><span class="s0">;</span>
	      <span class="s1">}</span><span class="s0">, </span><span class="s2">&quot;Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.&quot;</span><span class="s1">)</span>
	    <span class="s1">})</span><span class="s0">;</span>
	    <span class="s1">_this._constructed = </span><span class="s0">true;</span>
	    <span class="s0">return </span><span class="s1">_this</span><span class="s0">;</span>
	  <span class="s1">}</span>
	  <span class="s5">/**</span>
	   <span class="s5">* Returns the Attribute's value quoted such that it would be legal to use</span>
	   <span class="s5">* in the value of a css file. The original value's quotation setting</span>
	   <span class="s5">* used for stringification is left unchanged. See `setValue(value, options)`</span>
	   <span class="s5">* if you want to control the quote settings of a new value for the attribute.</span>
	   <span class="s5">*</span>
	   <span class="s5">* You can also change the quotation used for the current value by setting quoteMark.</span>
	   <span class="s5">*</span>
	   <span class="s5">* Options:</span>
	   <span class="s5">*   * quoteMark {'&quot;' | &quot;'&quot; | null} - Use this value to quote the value. If this</span>
	   <span class="s5">*     option is not set, the original value for quoteMark will be used. If</span>
	   <span class="s5">*     indeterminate, a double quote is used. The legal values are:</span>
	   <span class="s5">*     * `null` - the value will be unquoted and characters will be escaped as necessary.</span>
	   <span class="s5">*     * `'` - the value will be quoted with a single quote and single quotes are escaped.</span>
	   <span class="s5">*     * `&quot;` - the value will be quoted with a double quote and double quotes are escaped.</span>
	   <span class="s5">*   * preferCurrentQuoteMark {boolean} - if true, prefer the source quote mark</span>
	   <span class="s5">*     over the quoteMark option value.</span>
	   <span class="s5">*   * smart {boolean} - if true, will select a quote mark based on the value</span>
	   <span class="s5">*     and the other options specified here. See the `smartQuoteMark()`</span>
	   <span class="s5">*     method.</span>
	   <span class="s5">**/</span>


	  <span class="s0">var </span><span class="s1">_proto = Attribute.prototype</span><span class="s0">;</span>

	  <span class="s1">_proto.getQuotedValue = </span><span class="s0">function </span><span class="s1">getQuotedValue(options) {</span>
	    <span class="s0">if </span><span class="s1">(options === </span><span class="s0">void </span><span class="s3">0</span><span class="s1">) {</span>
	      <span class="s1">options = {}</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">var </span><span class="s1">quoteMark = </span><span class="s0">this</span><span class="s1">._determineQuoteMark(options)</span><span class="s0">;</span>

	    <span class="s0">var </span><span class="s1">cssescopts = CSSESC_QUOTE_OPTIONS[quoteMark]</span><span class="s0">;</span>
	    <span class="s0">var </span><span class="s1">escaped = (</span><span class="s3">0</span><span class="s0">, </span><span class="s1">_cssesc[</span><span class="s2">&quot;default&quot;</span><span class="s1">])(</span><span class="s0">this</span><span class="s1">._value</span><span class="s0">, </span><span class="s1">cssescopts)</span><span class="s0">;</span>
	    <span class="s0">return </span><span class="s1">escaped</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto._determineQuoteMark = </span><span class="s0">function </span><span class="s1">_determineQuoteMark(options) {</span>
	    <span class="s0">return </span><span class="s1">options.smart ? </span><span class="s0">this</span><span class="s1">.smartQuoteMark(options) : </span><span class="s0">this</span><span class="s1">.preferredQuoteMark(options)</span><span class="s0">;</span>
	  <span class="s1">}</span>
	  <span class="s5">/**</span>
	   <span class="s5">* Set the unescaped value with the specified quotation options. The value</span>
	   <span class="s5">* provided must not include any wrapping quote marks -- those quotes will</span>
	   <span class="s5">* be interpreted as part of the value and escaped accordingly.</span>
	   <span class="s5">*/</span>
	  <span class="s0">;</span>

	  <span class="s1">_proto.setValue = </span><span class="s0">function </span><span class="s1">setValue(value</span><span class="s0">, </span><span class="s1">options) {</span>
	    <span class="s0">if </span><span class="s1">(options === </span><span class="s0">void </span><span class="s3">0</span><span class="s1">) {</span>
	      <span class="s1">options = {}</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">this</span><span class="s1">._value = value</span><span class="s0">;</span>
	    <span class="s0">this</span><span class="s1">._quoteMark = </span><span class="s0">this</span><span class="s1">._determineQuoteMark(options)</span><span class="s0">;</span>

	    <span class="s0">this</span><span class="s1">._syncRawValue()</span><span class="s0">;</span>
	  <span class="s1">}</span>
	  <span class="s5">/**</span>
	   <span class="s5">* Intelligently select a quoteMark value based on the value's contents. If</span>
	   <span class="s5">* the value is a legal CSS ident, it will not be quoted. Otherwise a quote</span>
	   <span class="s5">* mark will be picked that minimizes the number of escapes.</span>
	   <span class="s5">*</span>
	   <span class="s5">* If there's no clear winner, the quote mark from these options is used,</span>
	   <span class="s5">* then the source quote mark (this is inverted if `preferCurrentQuoteMark` is</span>
	   <span class="s5">* true). If the quoteMark is unspecified, a double quote is used.</span>
	   <span class="s5">*</span>
	   <span class="s5">* </span><span class="s6">@param </span><span class="s5">options This takes the quoteMark and preferCurrentQuoteMark options</span>
	   <span class="s5">* from the quoteValue method.</span>
	   <span class="s5">*/</span>
	  <span class="s0">;</span>

	  <span class="s1">_proto.smartQuoteMark = </span><span class="s0">function </span><span class="s1">smartQuoteMark(options) {</span>
	    <span class="s0">var </span><span class="s1">v = </span><span class="s0">this</span><span class="s1">.value</span><span class="s0">;</span>
	    <span class="s0">var </span><span class="s1">numSingleQuotes = v.replace(</span><span class="s3">/[^']/g</span><span class="s0">, </span><span class="s2">''</span><span class="s1">).length</span><span class="s0">;</span>
	    <span class="s0">var </span><span class="s1">numDoubleQuotes = v.replace(</span><span class="s3">/[^&quot;]/g</span><span class="s0">, </span><span class="s2">''</span><span class="s1">).length</span><span class="s0">;</span>

	    <span class="s0">if </span><span class="s1">(numSingleQuotes + numDoubleQuotes === </span><span class="s3">0</span><span class="s1">) {</span>
	      <span class="s0">var </span><span class="s1">escaped = (</span><span class="s3">0</span><span class="s0">, </span><span class="s1">_cssesc[</span><span class="s2">&quot;default&quot;</span><span class="s1">])(v</span><span class="s0">, </span><span class="s1">{</span>
	        <span class="s1">isIdentifier: </span><span class="s0">true</span>
	      <span class="s1">})</span><span class="s0">;</span>

	      <span class="s0">if </span><span class="s1">(escaped === v) {</span>
	        <span class="s0">return </span><span class="s1">Attribute.NO_QUOTE</span><span class="s0">;</span>
	      <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
	        <span class="s0">var </span><span class="s1">pref = </span><span class="s0">this</span><span class="s1">.preferredQuoteMark(options)</span><span class="s0">;</span>

	        <span class="s0">if </span><span class="s1">(pref === Attribute.NO_QUOTE) {</span>
	          <span class="s4">// pick a quote mark that isn't none and see if it's smaller</span>
	          <span class="s0">var </span><span class="s1">quote = </span><span class="s0">this</span><span class="s1">.quoteMark || options.quoteMark || Attribute.DOUBLE_QUOTE</span><span class="s0">;</span>
	          <span class="s0">var </span><span class="s1">opts = CSSESC_QUOTE_OPTIONS[quote]</span><span class="s0">;</span>
	          <span class="s0">var </span><span class="s1">quoteValue = (</span><span class="s3">0</span><span class="s0">, </span><span class="s1">_cssesc[</span><span class="s2">&quot;default&quot;</span><span class="s1">])(v</span><span class="s0">, </span><span class="s1">opts)</span><span class="s0">;</span>

	          <span class="s0">if </span><span class="s1">(quoteValue.length &lt; escaped.length) {</span>
	            <span class="s0">return </span><span class="s1">quote</span><span class="s0">;</span>
	          <span class="s1">}</span>
	        <span class="s1">}</span>

	        <span class="s0">return </span><span class="s1">pref</span><span class="s0">;</span>
	      <span class="s1">}</span>
	    <span class="s1">} </span><span class="s0">else if </span><span class="s1">(numDoubleQuotes === numSingleQuotes) {</span>
	      <span class="s0">return this</span><span class="s1">.preferredQuoteMark(options)</span><span class="s0">;</span>
	    <span class="s1">} </span><span class="s0">else if </span><span class="s1">(numDoubleQuotes &lt; numSingleQuotes) {</span>
	      <span class="s0">return </span><span class="s1">Attribute.DOUBLE_QUOTE</span><span class="s0">;</span>
	    <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
	      <span class="s0">return </span><span class="s1">Attribute.SINGLE_QUOTE</span><span class="s0">;</span>
	    <span class="s1">}</span>
	  <span class="s1">}</span>
	  <span class="s5">/**</span>
	   <span class="s5">* Selects the preferred quote mark based on the options and the current quote mark value.</span>
	   <span class="s5">* If you want the quote mark to depend on the attribute value, call `smartQuoteMark(opts)`</span>
	   <span class="s5">* instead.</span>
	   <span class="s5">*/</span>
	  <span class="s0">;</span>

	  <span class="s1">_proto.preferredQuoteMark = </span><span class="s0">function </span><span class="s1">preferredQuoteMark(options) {</span>
	    <span class="s0">var </span><span class="s1">quoteMark = options.preferCurrentQuoteMark ? </span><span class="s0">this</span><span class="s1">.quoteMark : options.quoteMark</span><span class="s0">;</span>

	    <span class="s0">if </span><span class="s1">(quoteMark === undefined) {</span>
	      <span class="s1">quoteMark = options.preferCurrentQuoteMark ? options.quoteMark : </span><span class="s0">this</span><span class="s1">.quoteMark</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">if </span><span class="s1">(quoteMark === undefined) {</span>
	      <span class="s1">quoteMark = Attribute.DOUBLE_QUOTE</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">return </span><span class="s1">quoteMark</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto._syncRawValue = </span><span class="s0">function </span><span class="s1">_syncRawValue() {</span>
	    <span class="s0">var </span><span class="s1">rawValue = (</span><span class="s3">0</span><span class="s0">, </span><span class="s1">_cssesc[</span><span class="s2">&quot;default&quot;</span><span class="s1">])(</span><span class="s0">this</span><span class="s1">._value</span><span class="s0">, </span><span class="s1">CSSESC_QUOTE_OPTIONS[</span><span class="s0">this</span><span class="s1">.quoteMark])</span><span class="s0">;</span>

	    <span class="s0">if </span><span class="s1">(rawValue === </span><span class="s0">this</span><span class="s1">._value) {</span>
	      <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.raws) {</span>
	        <span class="s0">delete this</span><span class="s1">.raws.value</span><span class="s0">;</span>
	      <span class="s1">}</span>
	    <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
	      <span class="s0">this</span><span class="s1">.raws.value = rawValue</span><span class="s0">;</span>
	    <span class="s1">}</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto._handleEscapes = </span><span class="s0">function </span><span class="s1">_handleEscapes(prop</span><span class="s0">, </span><span class="s1">value) {</span>
	    <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">._constructed) {</span>
	      <span class="s0">var </span><span class="s1">escaped = (</span><span class="s3">0</span><span class="s0">, </span><span class="s1">_cssesc[</span><span class="s2">&quot;default&quot;</span><span class="s1">])(value</span><span class="s0">, </span><span class="s1">{</span>
	        <span class="s1">isIdentifier: </span><span class="s0">true</span>
	      <span class="s1">})</span><span class="s0">;</span>

	      <span class="s0">if </span><span class="s1">(escaped !== value) {</span>
	        <span class="s0">this</span><span class="s1">.raws[prop] = escaped</span><span class="s0">;</span>
	      <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
	        <span class="s0">delete this</span><span class="s1">.raws[prop]</span><span class="s0">;</span>
	      <span class="s1">}</span>
	    <span class="s1">}</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto._spacesFor = </span><span class="s0">function </span><span class="s1">_spacesFor(name) {</span>
	    <span class="s0">var </span><span class="s1">attrSpaces = {</span>
	      <span class="s1">before: </span><span class="s2">''</span><span class="s0">,</span>
	      <span class="s1">after: </span><span class="s2">''</span>
	    <span class="s1">}</span><span class="s0">;</span>
	    <span class="s0">var </span><span class="s1">spaces = </span><span class="s0">this</span><span class="s1">.spaces[name] || {}</span><span class="s0">;</span>
	    <span class="s0">var </span><span class="s1">rawSpaces = </span><span class="s0">this</span><span class="s1">.raws.spaces &amp;&amp; </span><span class="s0">this</span><span class="s1">.raws.spaces[name] || {}</span><span class="s0">;</span>
	    <span class="s0">return </span><span class="s1">Object.assign(attrSpaces</span><span class="s0">, </span><span class="s1">spaces</span><span class="s0">, </span><span class="s1">rawSpaces)</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto._stringFor = </span><span class="s0">function </span><span class="s1">_stringFor(name</span><span class="s0">, </span><span class="s1">spaceName</span><span class="s0">, </span><span class="s1">concat) {</span>
	    <span class="s0">if </span><span class="s1">(spaceName === </span><span class="s0">void </span><span class="s3">0</span><span class="s1">) {</span>
	      <span class="s1">spaceName = name</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">if </span><span class="s1">(concat === </span><span class="s0">void </span><span class="s3">0</span><span class="s1">) {</span>
	      <span class="s1">concat = defaultAttrConcat</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">var </span><span class="s1">attrSpaces = </span><span class="s0">this</span><span class="s1">._spacesFor(spaceName)</span><span class="s0">;</span>

	    <span class="s0">return </span><span class="s1">concat(</span><span class="s0">this</span><span class="s1">.stringifyProperty(name)</span><span class="s0">, </span><span class="s1">attrSpaces)</span><span class="s0">;</span>
	  <span class="s1">}</span>
	  <span class="s5">/**</span>
	   <span class="s5">* returns the offset of the attribute part specified relative to the</span>
	   <span class="s5">* start of the node of the output string.</span>
	   <span class="s5">*</span>
	   <span class="s5">* * &quot;ns&quot; - alias for &quot;namespace&quot;</span>
	   <span class="s5">* * &quot;namespace&quot; - the namespace if it exists.</span>
	   <span class="s5">* * &quot;attribute&quot; - the attribute name</span>
	   <span class="s5">* * &quot;attributeNS&quot; - the start of the attribute or its namespace</span>
	   <span class="s5">* * &quot;operator&quot; - the match operator of the attribute</span>
	   <span class="s5">* * &quot;value&quot; - The value (string or identifier)</span>
	   <span class="s5">* * &quot;insensitive&quot; - the case insensitivity flag;</span>
	   <span class="s5">* </span><span class="s6">@param </span><span class="s5">part One of the possible values inside an attribute.</span>
	   <span class="s5">* </span><span class="s6">@returns </span><span class="s5">-1 if the name is invalid or the value doesn't exist in this attribute.</span>
	   <span class="s5">*/</span>
	  <span class="s0">;</span>

	  <span class="s1">_proto.offsetOf = </span><span class="s0">function </span><span class="s1">offsetOf(name) {</span>
	    <span class="s0">var </span><span class="s1">count = </span><span class="s3">1</span><span class="s0">;</span>

	    <span class="s0">var </span><span class="s1">attributeSpaces = </span><span class="s0">this</span><span class="s1">._spacesFor(</span><span class="s2">&quot;attribute&quot;</span><span class="s1">)</span><span class="s0">;</span>

	    <span class="s1">count += attributeSpaces.before.length</span><span class="s0">;</span>

	    <span class="s0">if </span><span class="s1">(name === </span><span class="s2">&quot;namespace&quot; </span><span class="s1">|| name === </span><span class="s2">&quot;ns&quot;</span><span class="s1">) {</span>
	      <span class="s0">return this</span><span class="s1">.namespace ? count : -</span><span class="s3">1</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">if </span><span class="s1">(name === </span><span class="s2">&quot;attributeNS&quot;</span><span class="s1">) {</span>
	      <span class="s0">return </span><span class="s1">count</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s1">count += </span><span class="s0">this</span><span class="s1">.namespaceString.length</span><span class="s0">;</span>

	    <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.namespace) {</span>
	      <span class="s1">count += </span><span class="s3">1</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">if </span><span class="s1">(name === </span><span class="s2">&quot;attribute&quot;</span><span class="s1">) {</span>
	      <span class="s0">return </span><span class="s1">count</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s1">count += </span><span class="s0">this</span><span class="s1">.stringifyProperty(</span><span class="s2">&quot;attribute&quot;</span><span class="s1">).length</span><span class="s0">;</span>
	    <span class="s1">count += attributeSpaces.after.length</span><span class="s0">;</span>

	    <span class="s0">var </span><span class="s1">operatorSpaces = </span><span class="s0">this</span><span class="s1">._spacesFor(</span><span class="s2">&quot;operator&quot;</span><span class="s1">)</span><span class="s0">;</span>

	    <span class="s1">count += operatorSpaces.before.length</span><span class="s0">;</span>
	    <span class="s0">var </span><span class="s1">operator = </span><span class="s0">this</span><span class="s1">.stringifyProperty(</span><span class="s2">&quot;operator&quot;</span><span class="s1">)</span><span class="s0">;</span>

	    <span class="s0">if </span><span class="s1">(name === </span><span class="s2">&quot;operator&quot;</span><span class="s1">) {</span>
	      <span class="s0">return </span><span class="s1">operator ? count : -</span><span class="s3">1</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s1">count += operator.length</span><span class="s0">;</span>
	    <span class="s1">count += operatorSpaces.after.length</span><span class="s0">;</span>

	    <span class="s0">var </span><span class="s1">valueSpaces = </span><span class="s0">this</span><span class="s1">._spacesFor(</span><span class="s2">&quot;value&quot;</span><span class="s1">)</span><span class="s0">;</span>

	    <span class="s1">count += valueSpaces.before.length</span><span class="s0">;</span>
	    <span class="s0">var </span><span class="s1">value = </span><span class="s0">this</span><span class="s1">.stringifyProperty(</span><span class="s2">&quot;value&quot;</span><span class="s1">)</span><span class="s0">;</span>

	    <span class="s0">if </span><span class="s1">(name === </span><span class="s2">&quot;value&quot;</span><span class="s1">) {</span>
	      <span class="s0">return </span><span class="s1">value ? count : -</span><span class="s3">1</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s1">count += value.length</span><span class="s0">;</span>
	    <span class="s1">count += valueSpaces.after.length</span><span class="s0">;</span>

	    <span class="s0">var </span><span class="s1">insensitiveSpaces = </span><span class="s0">this</span><span class="s1">._spacesFor(</span><span class="s2">&quot;insensitive&quot;</span><span class="s1">)</span><span class="s0">;</span>

	    <span class="s1">count += insensitiveSpaces.before.length</span><span class="s0">;</span>

	    <span class="s0">if </span><span class="s1">(name === </span><span class="s2">&quot;insensitive&quot;</span><span class="s1">) {</span>
	      <span class="s0">return this</span><span class="s1">.insensitive ? count : -</span><span class="s3">1</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">return </span><span class="s1">-</span><span class="s3">1</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.toString = </span><span class="s0">function </span><span class="s1">toString() {</span>
	    <span class="s0">var </span><span class="s1">_this2 = </span><span class="s0">this;</span>

	    <span class="s0">var </span><span class="s1">selector = [</span><span class="s0">this</span><span class="s1">.rawSpaceBefore</span><span class="s0">, </span><span class="s2">'['</span><span class="s1">]</span><span class="s0">;</span>
	    <span class="s1">selector.push(</span><span class="s0">this</span><span class="s1">._stringFor(</span><span class="s2">'qualifiedAttribute'</span><span class="s0">, </span><span class="s2">'attribute'</span><span class="s1">))</span><span class="s0">;</span>

	    <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.operator &amp;&amp; (</span><span class="s0">this</span><span class="s1">.value || </span><span class="s0">this</span><span class="s1">.value === </span><span class="s2">''</span><span class="s1">)) {</span>
	      <span class="s1">selector.push(</span><span class="s0">this</span><span class="s1">._stringFor(</span><span class="s2">'operator'</span><span class="s1">))</span><span class="s0">;</span>
	      <span class="s1">selector.push(</span><span class="s0">this</span><span class="s1">._stringFor(</span><span class="s2">'value'</span><span class="s1">))</span><span class="s0">;</span>
	      <span class="s1">selector.push(</span><span class="s0">this</span><span class="s1">._stringFor(</span><span class="s2">'insensitiveFlag'</span><span class="s0">, </span><span class="s2">'insensitive'</span><span class="s0">, function </span><span class="s1">(attrValue</span><span class="s0">, </span><span class="s1">attrSpaces) {</span>
	        <span class="s0">if </span><span class="s1">(attrValue.length &gt; </span><span class="s3">0 </span><span class="s1">&amp;&amp; !_this2.quoted &amp;&amp; attrSpaces.before.length === </span><span class="s3">0 </span><span class="s1">&amp;&amp; !(_this2.spaces.value &amp;&amp; _this2.spaces.value.after)) {</span>
	          <span class="s1">attrSpaces.before = </span><span class="s2">&quot; &quot;</span><span class="s0">;</span>
	        <span class="s1">}</span>

	        <span class="s0">return </span><span class="s1">defaultAttrConcat(attrValue</span><span class="s0">, </span><span class="s1">attrSpaces)</span><span class="s0">;</span>
	      <span class="s1">}))</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s1">selector.push(</span><span class="s2">']'</span><span class="s1">)</span><span class="s0">;</span>
	    <span class="s1">selector.push(</span><span class="s0">this</span><span class="s1">.rawSpaceAfter)</span><span class="s0">;</span>
	    <span class="s0">return </span><span class="s1">selector.join(</span><span class="s2">''</span><span class="s1">)</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_createClass(Attribute</span><span class="s0">, </span><span class="s1">[{</span>
	    <span class="s1">key: </span><span class="s2">&quot;quoted&quot;</span><span class="s0">,</span>
	    <span class="s1">get: </span><span class="s0">function </span><span class="s1">get() {</span>
	      <span class="s0">var </span><span class="s1">qm = </span><span class="s0">this</span><span class="s1">.quoteMark</span><span class="s0">;</span>
	      <span class="s0">return </span><span class="s1">qm === </span><span class="s2">&quot;'&quot; </span><span class="s1">|| qm === </span><span class="s2">'&quot;'</span><span class="s0">;</span>
	    <span class="s1">}</span><span class="s0">,</span>
	    <span class="s1">set: </span><span class="s0">function </span><span class="s1">set(value) {</span>
	      <span class="s1">warnOfDeprecatedQuotedAssignment()</span><span class="s0">;</span>
	    <span class="s1">}</span>
	    <span class="s5">/**</span>
	     <span class="s5">* returns a single (`'`) or double (`&quot;`) quote character if the value is quoted.</span>
	     <span class="s5">* returns `null` if the value is not quoted.</span>
	     <span class="s5">* returns `undefined` if the quotation state is unknown (this can happen when</span>
	     <span class="s5">* the attribute is constructed without specifying a quote mark.)</span>
	     <span class="s5">*/</span>

	  <span class="s1">}</span><span class="s0">, </span><span class="s1">{</span>
	    <span class="s1">key: </span><span class="s2">&quot;quoteMark&quot;</span><span class="s0">,</span>
	    <span class="s1">get: </span><span class="s0">function </span><span class="s1">get() {</span>
	      <span class="s0">return this</span><span class="s1">._quoteMark</span><span class="s0">;</span>
	    <span class="s1">}</span>
	    <span class="s5">/**</span>
	     <span class="s5">* Set the quote mark to be used by this attribute's value.</span>
	     <span class="s5">* If the quote mark changes, the raw (escaped) value at `attr.raws.value` of the attribute</span>
	     <span class="s5">* value is updated accordingly.</span>
	     <span class="s5">*</span>
	     <span class="s5">* </span><span class="s6">@param </span><span class="s5">{&quot;'&quot; | '&quot;' | null} quoteMark The quote mark or `null` if the value should be unquoted.</span>
	     <span class="s5">*/</span>
	    <span class="s0">,</span>
	    <span class="s1">set: </span><span class="s0">function </span><span class="s1">set(quoteMark) {</span>
	      <span class="s0">if </span><span class="s1">(!</span><span class="s0">this</span><span class="s1">._constructed) {</span>
	        <span class="s0">this</span><span class="s1">._quoteMark = quoteMark</span><span class="s0">;</span>
	        <span class="s0">return;</span>
	      <span class="s1">}</span>

	      <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">._quoteMark !== quoteMark) {</span>
	        <span class="s0">this</span><span class="s1">._quoteMark = quoteMark</span><span class="s0">;</span>

	        <span class="s0">this</span><span class="s1">._syncRawValue()</span><span class="s0">;</span>
	      <span class="s1">}</span>
	    <span class="s1">}</span>
	  <span class="s1">}</span><span class="s0">, </span><span class="s1">{</span>
	    <span class="s1">key: </span><span class="s2">&quot;qualifiedAttribute&quot;</span><span class="s0">,</span>
	    <span class="s1">get: </span><span class="s0">function </span><span class="s1">get() {</span>
	      <span class="s0">return this</span><span class="s1">.qualifiedName(</span><span class="s0">this</span><span class="s1">.raws.attribute || </span><span class="s0">this</span><span class="s1">.attribute)</span><span class="s0">;</span>
	    <span class="s1">}</span>
	  <span class="s1">}</span><span class="s0">, </span><span class="s1">{</span>
	    <span class="s1">key: </span><span class="s2">&quot;insensitiveFlag&quot;</span><span class="s0">,</span>
	    <span class="s1">get: </span><span class="s0">function </span><span class="s1">get() {</span>
	      <span class="s0">return this</span><span class="s1">.insensitive ? </span><span class="s2">'i' </span><span class="s1">: </span><span class="s2">''</span><span class="s0">;</span>
	    <span class="s1">}</span>
	  <span class="s1">}</span><span class="s0">, </span><span class="s1">{</span>
	    <span class="s1">key: </span><span class="s2">&quot;value&quot;</span><span class="s0">,</span>
	    <span class="s1">get: </span><span class="s0">function </span><span class="s1">get() {</span>
	      <span class="s0">return this</span><span class="s1">._value</span><span class="s0">;</span>
	    <span class="s1">}</span>
	    <span class="s5">/**</span>
	     <span class="s5">* Before 3.0, the value had to be set to an escaped value including any wrapped</span>
	     <span class="s5">* quote marks. In 3.0, the semantics of `Attribute.value` changed so that the value</span>
	     <span class="s5">* is unescaped during parsing and any quote marks are removed.</span>
	     <span class="s5">*</span>
	     <span class="s5">* Because the ambiguity of this semantic change, if you set `attr.value = newValue`,</span>
	     <span class="s5">* a deprecation warning is raised when the new value contains any characters that would</span>
	     <span class="s5">* require escaping (including if it contains wrapped quotes).</span>
	     <span class="s5">*</span>
	     <span class="s5">* Instead, you should call `attr.setValue(newValue, opts)` and pass options that describe</span>
	     <span class="s5">* how the new value is quoted.</span>
	     <span class="s5">*/</span>
	    <span class="s0">,</span>
	    <span class="s1">set: </span><span class="s0">function </span><span class="s1">set(v) {</span>
	      <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">._constructed) {</span>
	        <span class="s0">var </span><span class="s1">_unescapeValue2 = unescapeValue(v)</span><span class="s0">,</span>
	            <span class="s1">deprecatedUsage = _unescapeValue2.deprecatedUsage</span><span class="s0">,</span>
	            <span class="s1">unescaped = _unescapeValue2.unescaped</span><span class="s0">,</span>
	            <span class="s1">quoteMark = _unescapeValue2.quoteMark</span><span class="s0">;</span>

	        <span class="s0">if </span><span class="s1">(deprecatedUsage) {</span>
	          <span class="s1">warnOfDeprecatedValueAssignment()</span><span class="s0">;</span>
	        <span class="s1">}</span>

	        <span class="s0">if </span><span class="s1">(unescaped === </span><span class="s0">this</span><span class="s1">._value &amp;&amp; quoteMark === </span><span class="s0">this</span><span class="s1">._quoteMark) {</span>
	          <span class="s0">return;</span>
	        <span class="s1">}</span>

	        <span class="s0">this</span><span class="s1">._value = unescaped</span><span class="s0">;</span>
	        <span class="s0">this</span><span class="s1">._quoteMark = quoteMark</span><span class="s0">;</span>

	        <span class="s0">this</span><span class="s1">._syncRawValue()</span><span class="s0">;</span>
	      <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
	        <span class="s0">this</span><span class="s1">._value = v</span><span class="s0">;</span>
	      <span class="s1">}</span>
	    <span class="s1">}</span>
	  <span class="s1">}</span><span class="s0">, </span><span class="s1">{</span>
	    <span class="s1">key: </span><span class="s2">&quot;attribute&quot;</span><span class="s0">,</span>
	    <span class="s1">get: </span><span class="s0">function </span><span class="s1">get() {</span>
	      <span class="s0">return this</span><span class="s1">._attribute</span><span class="s0">;</span>
	    <span class="s1">}</span><span class="s0">,</span>
	    <span class="s1">set: </span><span class="s0">function </span><span class="s1">set(name) {</span>
	      <span class="s0">this</span><span class="s1">._handleEscapes(</span><span class="s2">&quot;attribute&quot;</span><span class="s0">, </span><span class="s1">name)</span><span class="s0">;</span>

	      <span class="s0">this</span><span class="s1">._attribute = name</span><span class="s0">;</span>
	    <span class="s1">}</span>
	  <span class="s1">}])</span><span class="s0">;</span>

	  <span class="s0">return </span><span class="s1">Attribute</span><span class="s0">;</span>
	<span class="s1">}(_namespace[</span><span class="s2">&quot;default&quot;</span><span class="s1">])</span><span class="s0">;</span>

	<span class="s1">exports[</span><span class="s2">&quot;default&quot;</span><span class="s1">] = Attribute</span><span class="s0">;</span>
	<span class="s1">Attribute.NO_QUOTE = </span><span class="s0">null;</span>
	<span class="s1">Attribute.SINGLE_QUOTE = </span><span class="s2">&quot;'&quot;</span><span class="s0">;</span>
	<span class="s1">Attribute.DOUBLE_QUOTE = </span><span class="s2">'&quot;'</span><span class="s0">;</span>
	<span class="s0">var </span><span class="s1">CSSESC_QUOTE_OPTIONS = (_CSSESC_QUOTE_OPTIONS = {</span>
	  <span class="s2">&quot;'&quot;</span><span class="s1">: {</span>
	    <span class="s1">quotes: </span><span class="s2">'single'</span><span class="s0">,</span>
	    <span class="s1">wrap: </span><span class="s0">true</span>
	  <span class="s1">}</span><span class="s0">,</span>
	  <span class="s2">'&quot;'</span><span class="s1">: {</span>
	    <span class="s1">quotes: </span><span class="s2">'double'</span><span class="s0">,</span>
	    <span class="s1">wrap: </span><span class="s0">true</span>
	  <span class="s1">}</span>
	<span class="s1">}</span><span class="s0">, </span><span class="s1">_CSSESC_QUOTE_OPTIONS[</span><span class="s0">null</span><span class="s1">] = {</span>
	  <span class="s1">isIdentifier: </span><span class="s0">true</span>
	<span class="s1">}</span><span class="s0">, </span><span class="s1">_CSSESC_QUOTE_OPTIONS)</span><span class="s0">;</span>

	<span class="s0">function </span><span class="s1">defaultAttrConcat(attrValue</span><span class="s0">, </span><span class="s1">attrSpaces) {</span>
	  <span class="s0">return </span><span class="s2">&quot;&quot; </span><span class="s1">+ attrSpaces.before + attrValue + attrSpaces.after</span><span class="s0">;</span>
	<span class="s1">}</span>
<span class="s1">} (attribute$1))</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">universalExports = {}</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">universal$1 = {</span>
  <span class="s1">get exports(){ </span><span class="s0">return </span><span class="s1">universalExports</span><span class="s0">; </span><span class="s1">}</span><span class="s0">,</span>
  <span class="s1">set exports(v){ universalExports = v</span><span class="s0">; </span><span class="s1">}</span><span class="s0">,</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s1">(</span><span class="s0">function </span><span class="s1">(module</span><span class="s0">, </span><span class="s1">exports) {</span>

	<span class="s1">exports.__esModule = </span><span class="s0">true;</span>
	<span class="s1">exports[</span><span class="s2">&quot;default&quot;</span><span class="s1">] = </span><span class="s0">void </span><span class="s3">0</span><span class="s0">;</span>

	<span class="s0">var </span><span class="s1">_namespace = _interopRequireDefault(namespaceExports)</span><span class="s0">;</span>

	<span class="s0">var </span><span class="s1">_types = types</span><span class="s0">;</span>

	<span class="s0">function </span><span class="s1">_interopRequireDefault(obj) { </span><span class="s0">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : { </span><span class="s2">&quot;default&quot;</span><span class="s1">: obj }</span><span class="s0">; </span><span class="s1">}</span>

	<span class="s0">function </span><span class="s1">_inheritsLoose(subClass</span><span class="s0">, </span><span class="s1">superClass) { subClass.prototype = Object.create(superClass.prototype)</span><span class="s0">; </span><span class="s1">subClass.prototype.constructor = subClass</span><span class="s0">; </span><span class="s1">_setPrototypeOf(subClass</span><span class="s0">, </span><span class="s1">superClass)</span><span class="s0">; </span><span class="s1">}</span>

	<span class="s0">function </span><span class="s1">_setPrototypeOf(o</span><span class="s0">, </span><span class="s1">p) { _setPrototypeOf = Object.setPrototypeOf || </span><span class="s0">function </span><span class="s1">_setPrototypeOf(o</span><span class="s0">, </span><span class="s1">p) { o.__proto__ = p</span><span class="s0">; return </span><span class="s1">o</span><span class="s0">; </span><span class="s1">}</span><span class="s0">; return </span><span class="s1">_setPrototypeOf(o</span><span class="s0">, </span><span class="s1">p)</span><span class="s0">; </span><span class="s1">}</span>

	<span class="s0">var </span><span class="s1">Universal = </span><span class="s4">/*#__PURE__*/</span><span class="s0">function </span><span class="s1">(_Namespace) {</span>
	  <span class="s1">_inheritsLoose(Universal</span><span class="s0">, </span><span class="s1">_Namespace)</span><span class="s0">;</span>

	  <span class="s0">function </span><span class="s1">Universal(opts) {</span>
	    <span class="s0">var </span><span class="s1">_this</span><span class="s0">;</span>

	    <span class="s1">_this = _Namespace.call(</span><span class="s0">this, </span><span class="s1">opts) || </span><span class="s0">this;</span>
	    <span class="s1">_this.type = _types.UNIVERSAL</span><span class="s0">;</span>
	    <span class="s1">_this.value = </span><span class="s2">'*'</span><span class="s0">;</span>
	    <span class="s0">return </span><span class="s1">_this</span><span class="s0">;</span>
	  <span class="s1">}</span>

	  <span class="s0">return </span><span class="s1">Universal</span><span class="s0">;</span>
	<span class="s1">}(_namespace[</span><span class="s2">&quot;default&quot;</span><span class="s1">])</span><span class="s0">;</span>

	<span class="s1">exports[</span><span class="s2">&quot;default&quot;</span><span class="s1">] = Universal</span><span class="s0">;</span>
	<span class="s1">module.exports = exports.default</span><span class="s0">;</span>
<span class="s1">} (universal$1</span><span class="s0">, </span><span class="s1">universalExports))</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">combinatorExports = {}</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">combinator$2 = {</span>
  <span class="s1">get exports(){ </span><span class="s0">return </span><span class="s1">combinatorExports</span><span class="s0">; </span><span class="s1">}</span><span class="s0">,</span>
  <span class="s1">set exports(v){ combinatorExports = v</span><span class="s0">; </span><span class="s1">}</span><span class="s0">,</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s1">(</span><span class="s0">function </span><span class="s1">(module</span><span class="s0">, </span><span class="s1">exports) {</span>

	<span class="s1">exports.__esModule = </span><span class="s0">true;</span>
	<span class="s1">exports[</span><span class="s2">&quot;default&quot;</span><span class="s1">] = </span><span class="s0">void </span><span class="s3">0</span><span class="s0">;</span>

	<span class="s0">var </span><span class="s1">_node = _interopRequireDefault(nodeExports)</span><span class="s0">;</span>

	<span class="s0">var </span><span class="s1">_types = types</span><span class="s0">;</span>

	<span class="s0">function </span><span class="s1">_interopRequireDefault(obj) { </span><span class="s0">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : { </span><span class="s2">&quot;default&quot;</span><span class="s1">: obj }</span><span class="s0">; </span><span class="s1">}</span>

	<span class="s0">function </span><span class="s1">_inheritsLoose(subClass</span><span class="s0">, </span><span class="s1">superClass) { subClass.prototype = Object.create(superClass.prototype)</span><span class="s0">; </span><span class="s1">subClass.prototype.constructor = subClass</span><span class="s0">; </span><span class="s1">_setPrototypeOf(subClass</span><span class="s0">, </span><span class="s1">superClass)</span><span class="s0">; </span><span class="s1">}</span>

	<span class="s0">function </span><span class="s1">_setPrototypeOf(o</span><span class="s0">, </span><span class="s1">p) { _setPrototypeOf = Object.setPrototypeOf || </span><span class="s0">function </span><span class="s1">_setPrototypeOf(o</span><span class="s0">, </span><span class="s1">p) { o.__proto__ = p</span><span class="s0">; return </span><span class="s1">o</span><span class="s0">; </span><span class="s1">}</span><span class="s0">; return </span><span class="s1">_setPrototypeOf(o</span><span class="s0">, </span><span class="s1">p)</span><span class="s0">; </span><span class="s1">}</span>

	<span class="s0">var </span><span class="s1">Combinator = </span><span class="s4">/*#__PURE__*/</span><span class="s0">function </span><span class="s1">(_Node) {</span>
	  <span class="s1">_inheritsLoose(Combinator</span><span class="s0">, </span><span class="s1">_Node)</span><span class="s0">;</span>

	  <span class="s0">function </span><span class="s1">Combinator(opts) {</span>
	    <span class="s0">var </span><span class="s1">_this</span><span class="s0">;</span>

	    <span class="s1">_this = _Node.call(</span><span class="s0">this, </span><span class="s1">opts) || </span><span class="s0">this;</span>
	    <span class="s1">_this.type = _types.COMBINATOR</span><span class="s0">;</span>
	    <span class="s0">return </span><span class="s1">_this</span><span class="s0">;</span>
	  <span class="s1">}</span>

	  <span class="s0">return </span><span class="s1">Combinator</span><span class="s0">;</span>
	<span class="s1">}(_node[</span><span class="s2">&quot;default&quot;</span><span class="s1">])</span><span class="s0">;</span>

	<span class="s1">exports[</span><span class="s2">&quot;default&quot;</span><span class="s1">] = Combinator</span><span class="s0">;</span>
	<span class="s1">module.exports = exports.default</span><span class="s0">;</span>
<span class="s1">} (combinator$2</span><span class="s0">, </span><span class="s1">combinatorExports))</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">nestingExports = {}</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">nesting$1 = {</span>
  <span class="s1">get exports(){ </span><span class="s0">return </span><span class="s1">nestingExports</span><span class="s0">; </span><span class="s1">}</span><span class="s0">,</span>
  <span class="s1">set exports(v){ nestingExports = v</span><span class="s0">; </span><span class="s1">}</span><span class="s0">,</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s1">(</span><span class="s0">function </span><span class="s1">(module</span><span class="s0">, </span><span class="s1">exports) {</span>

	<span class="s1">exports.__esModule = </span><span class="s0">true;</span>
	<span class="s1">exports[</span><span class="s2">&quot;default&quot;</span><span class="s1">] = </span><span class="s0">void </span><span class="s3">0</span><span class="s0">;</span>

	<span class="s0">var </span><span class="s1">_node = _interopRequireDefault(nodeExports)</span><span class="s0">;</span>

	<span class="s0">var </span><span class="s1">_types = types</span><span class="s0">;</span>

	<span class="s0">function </span><span class="s1">_interopRequireDefault(obj) { </span><span class="s0">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : { </span><span class="s2">&quot;default&quot;</span><span class="s1">: obj }</span><span class="s0">; </span><span class="s1">}</span>

	<span class="s0">function </span><span class="s1">_inheritsLoose(subClass</span><span class="s0">, </span><span class="s1">superClass) { subClass.prototype = Object.create(superClass.prototype)</span><span class="s0">; </span><span class="s1">subClass.prototype.constructor = subClass</span><span class="s0">; </span><span class="s1">_setPrototypeOf(subClass</span><span class="s0">, </span><span class="s1">superClass)</span><span class="s0">; </span><span class="s1">}</span>

	<span class="s0">function </span><span class="s1">_setPrototypeOf(o</span><span class="s0">, </span><span class="s1">p) { _setPrototypeOf = Object.setPrototypeOf || </span><span class="s0">function </span><span class="s1">_setPrototypeOf(o</span><span class="s0">, </span><span class="s1">p) { o.__proto__ = p</span><span class="s0">; return </span><span class="s1">o</span><span class="s0">; </span><span class="s1">}</span><span class="s0">; return </span><span class="s1">_setPrototypeOf(o</span><span class="s0">, </span><span class="s1">p)</span><span class="s0">; </span><span class="s1">}</span>

	<span class="s0">var </span><span class="s1">Nesting = </span><span class="s4">/*#__PURE__*/</span><span class="s0">function </span><span class="s1">(_Node) {</span>
	  <span class="s1">_inheritsLoose(Nesting</span><span class="s0">, </span><span class="s1">_Node)</span><span class="s0">;</span>

	  <span class="s0">function </span><span class="s1">Nesting(opts) {</span>
	    <span class="s0">var </span><span class="s1">_this</span><span class="s0">;</span>

	    <span class="s1">_this = _Node.call(</span><span class="s0">this, </span><span class="s1">opts) || </span><span class="s0">this;</span>
	    <span class="s1">_this.type = _types.NESTING</span><span class="s0">;</span>
	    <span class="s1">_this.value = </span><span class="s2">'&amp;'</span><span class="s0">;</span>
	    <span class="s0">return </span><span class="s1">_this</span><span class="s0">;</span>
	  <span class="s1">}</span>

	  <span class="s0">return </span><span class="s1">Nesting</span><span class="s0">;</span>
	<span class="s1">}(_node[</span><span class="s2">&quot;default&quot;</span><span class="s1">])</span><span class="s0">;</span>

	<span class="s1">exports[</span><span class="s2">&quot;default&quot;</span><span class="s1">] = Nesting</span><span class="s0">;</span>
	<span class="s1">module.exports = exports.default</span><span class="s0">;</span>
<span class="s1">} (nesting$1</span><span class="s0">, </span><span class="s1">nestingExports))</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">sortAscendingExports = {}</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">sortAscending = {</span>
  <span class="s1">get exports(){ </span><span class="s0">return </span><span class="s1">sortAscendingExports</span><span class="s0">; </span><span class="s1">}</span><span class="s0">,</span>
  <span class="s1">set exports(v){ sortAscendingExports = v</span><span class="s0">; </span><span class="s1">}</span><span class="s0">,</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s1">(</span><span class="s0">function </span><span class="s1">(module</span><span class="s0">, </span><span class="s1">exports) {</span>

	<span class="s1">exports.__esModule = </span><span class="s0">true;</span>
	<span class="s1">exports[</span><span class="s2">&quot;default&quot;</span><span class="s1">] = sortAscending</span><span class="s0">;</span>

	<span class="s0">function </span><span class="s1">sortAscending(list) {</span>
	  <span class="s0">return </span><span class="s1">list.sort(</span><span class="s0">function </span><span class="s1">(a</span><span class="s0">, </span><span class="s1">b) {</span>
	    <span class="s0">return </span><span class="s1">a - b</span><span class="s0">;</span>
	  <span class="s1">})</span><span class="s0">;</span>
	<span class="s1">}</span>
	<span class="s1">module.exports = exports.default</span><span class="s0">;</span>
<span class="s1">} (sortAscending</span><span class="s0">, </span><span class="s1">sortAscendingExports))</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">tokenize = {}</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">tokenTypes = {}</span><span class="s0">;</span>

<span class="s1">tokenTypes.__esModule = </span><span class="s0">true;</span>
<span class="s1">tokenTypes.combinator = tokenTypes.word = tokenTypes.comment = tokenTypes.str = tokenTypes.tab = tokenTypes.newline = tokenTypes.feed = tokenTypes.cr = tokenTypes.backslash = tokenTypes.bang = tokenTypes.slash = tokenTypes.doubleQuote = tokenTypes.singleQuote = tokenTypes.space = tokenTypes.greaterThan = tokenTypes.pipe = tokenTypes.equals = tokenTypes.plus = tokenTypes.caret = tokenTypes.tilde = tokenTypes.dollar = tokenTypes.closeSquare = tokenTypes.openSquare = tokenTypes.closeParenthesis = tokenTypes.openParenthesis = tokenTypes.semicolon = tokenTypes.colon = tokenTypes.comma = tokenTypes.at = tokenTypes.asterisk = tokenTypes.ampersand = </span><span class="s0">void </span><span class="s3">0</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">ampersand = </span><span class="s3">38</span><span class="s0">; </span><span class="s4">// `&amp;`.charCodeAt(0);</span>

<span class="s1">tokenTypes.ampersand = ampersand</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">asterisk = </span><span class="s3">42</span><span class="s0">; </span><span class="s4">// `*`.charCodeAt(0);</span>

<span class="s1">tokenTypes.asterisk = asterisk</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">at = </span><span class="s3">64</span><span class="s0">; </span><span class="s4">// `@`.charCodeAt(0);</span>

<span class="s1">tokenTypes.at = at</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">comma = </span><span class="s3">44</span><span class="s0">; </span><span class="s4">// `,`.charCodeAt(0);</span>

<span class="s1">tokenTypes.comma = comma</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">colon = </span><span class="s3">58</span><span class="s0">; </span><span class="s4">// `:`.charCodeAt(0);</span>

<span class="s1">tokenTypes.colon = colon</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">semicolon = </span><span class="s3">59</span><span class="s0">; </span><span class="s4">// `;`.charCodeAt(0);</span>

<span class="s1">tokenTypes.semicolon = semicolon</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">openParenthesis = </span><span class="s3">40</span><span class="s0">; </span><span class="s4">// `(`.charCodeAt(0);</span>

<span class="s1">tokenTypes.openParenthesis = openParenthesis</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">closeParenthesis = </span><span class="s3">41</span><span class="s0">; </span><span class="s4">// `)`.charCodeAt(0);</span>

<span class="s1">tokenTypes.closeParenthesis = closeParenthesis</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">openSquare = </span><span class="s3">91</span><span class="s0">; </span><span class="s4">// `[`.charCodeAt(0);</span>

<span class="s1">tokenTypes.openSquare = openSquare</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">closeSquare = </span><span class="s3">93</span><span class="s0">; </span><span class="s4">// `]`.charCodeAt(0);</span>

<span class="s1">tokenTypes.closeSquare = closeSquare</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">dollar = </span><span class="s3">36</span><span class="s0">; </span><span class="s4">// `$`.charCodeAt(0);</span>

<span class="s1">tokenTypes.dollar = dollar</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">tilde = </span><span class="s3">126</span><span class="s0">; </span><span class="s4">// `~`.charCodeAt(0);</span>

<span class="s1">tokenTypes.tilde = tilde</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">caret = </span><span class="s3">94</span><span class="s0">; </span><span class="s4">// `^`.charCodeAt(0);</span>

<span class="s1">tokenTypes.caret = caret</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">plus = </span><span class="s3">43</span><span class="s0">; </span><span class="s4">// `+`.charCodeAt(0);</span>

<span class="s1">tokenTypes.plus = plus</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">equals = </span><span class="s3">61</span><span class="s0">; </span><span class="s4">// `=`.charCodeAt(0);</span>

<span class="s1">tokenTypes.equals = equals</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">pipe = </span><span class="s3">124</span><span class="s0">; </span><span class="s4">// `|`.charCodeAt(0);</span>

<span class="s1">tokenTypes.pipe = pipe</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">greaterThan = </span><span class="s3">62</span><span class="s0">; </span><span class="s4">// `&gt;`.charCodeAt(0);</span>

<span class="s1">tokenTypes.greaterThan = greaterThan</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">space = </span><span class="s3">32</span><span class="s0">; </span><span class="s4">// ` `.charCodeAt(0);</span>

<span class="s1">tokenTypes.space = space</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">singleQuote = </span><span class="s3">39</span><span class="s0">; </span><span class="s4">// `'`.charCodeAt(0);</span>

<span class="s1">tokenTypes.singleQuote = singleQuote</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">doubleQuote = </span><span class="s3">34</span><span class="s0">; </span><span class="s4">// `&quot;`.charCodeAt(0);</span>

<span class="s1">tokenTypes.doubleQuote = doubleQuote</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">slash = </span><span class="s3">47</span><span class="s0">; </span><span class="s4">// `/`.charCodeAt(0);</span>

<span class="s1">tokenTypes.slash = slash</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">bang = </span><span class="s3">33</span><span class="s0">; </span><span class="s4">// `!`.charCodeAt(0);</span>

<span class="s1">tokenTypes.bang = bang</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">backslash = </span><span class="s3">92</span><span class="s0">; </span><span class="s4">// '\\'.charCodeAt(0);</span>

<span class="s1">tokenTypes.backslash = backslash</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">cr = </span><span class="s3">13</span><span class="s0">; </span><span class="s4">// '\r'.charCodeAt(0);</span>

<span class="s1">tokenTypes.cr = cr</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">feed = </span><span class="s3">12</span><span class="s0">; </span><span class="s4">// '\f'.charCodeAt(0);</span>

<span class="s1">tokenTypes.feed = feed</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">newline = </span><span class="s3">10</span><span class="s0">; </span><span class="s4">// '\n'.charCodeAt(0);</span>

<span class="s1">tokenTypes.newline = newline</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">tab = </span><span class="s3">9</span><span class="s0">; </span><span class="s4">// '\t'.charCodeAt(0);</span>
<span class="s4">// Expose aliases primarily for readability.</span>

<span class="s1">tokenTypes.tab = tab</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">str = singleQuote</span><span class="s0">; </span><span class="s4">// No good single character representation!</span>

<span class="s1">tokenTypes.str = str</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">comment$1 = -</span><span class="s3">1</span><span class="s0">;</span>
<span class="s1">tokenTypes.comment = comment$1</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">word = -</span><span class="s3">2</span><span class="s0">;</span>
<span class="s1">tokenTypes.word = word</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">combinator$1 = -</span><span class="s3">3</span><span class="s0">;</span>
<span class="s1">tokenTypes.combinator = combinator$1</span><span class="s0">;</span>

<span class="s1">(</span><span class="s0">function </span><span class="s1">(exports) {</span>

	<span class="s1">exports.__esModule = </span><span class="s0">true;</span>
	<span class="s1">exports[</span><span class="s2">&quot;default&quot;</span><span class="s1">] = tokenize</span><span class="s0">;</span>
	<span class="s1">exports.FIELDS = </span><span class="s0">void </span><span class="s3">0</span><span class="s0">;</span>

	<span class="s0">var </span><span class="s1">t = _interopRequireWildcard(tokenTypes)</span><span class="s0">;</span>

	<span class="s0">var </span><span class="s1">_unescapable</span><span class="s0">, </span><span class="s1">_wordDelimiters</span><span class="s0">;</span>

	<span class="s0">function </span><span class="s1">_getRequireWildcardCache() { </span><span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">WeakMap !== </span><span class="s2">&quot;function&quot;</span><span class="s1">) </span><span class="s0">return null; var </span><span class="s1">cache = </span><span class="s0">new </span><span class="s1">WeakMap()</span><span class="s0">; </span><span class="s1">_getRequireWildcardCache = </span><span class="s0">function </span><span class="s1">_getRequireWildcardCache() { </span><span class="s0">return </span><span class="s1">cache</span><span class="s0">; </span><span class="s1">}</span><span class="s0">; return </span><span class="s1">cache</span><span class="s0">; </span><span class="s1">}</span>

	<span class="s0">function </span><span class="s1">_interopRequireWildcard(obj) { </span><span class="s0">if </span><span class="s1">(obj &amp;&amp; obj.__esModule) { </span><span class="s0">return </span><span class="s1">obj</span><span class="s0">; </span><span class="s1">} </span><span class="s0">if </span><span class="s1">(obj === </span><span class="s0">null </span><span class="s1">|| </span><span class="s0">typeof </span><span class="s1">obj !== </span><span class="s2">&quot;object&quot; </span><span class="s1">&amp;&amp; </span><span class="s0">typeof </span><span class="s1">obj !== </span><span class="s2">&quot;function&quot;</span><span class="s1">) { </span><span class="s0">return </span><span class="s1">{ </span><span class="s2">&quot;default&quot;</span><span class="s1">: obj }</span><span class="s0">; </span><span class="s1">} </span><span class="s0">var </span><span class="s1">cache = _getRequireWildcardCache()</span><span class="s0">; if </span><span class="s1">(cache &amp;&amp; cache.has(obj)) { </span><span class="s0">return </span><span class="s1">cache.get(obj)</span><span class="s0">; </span><span class="s1">} </span><span class="s0">var </span><span class="s1">newObj = {}</span><span class="s0">; var </span><span class="s1">hasPropertyDescriptor = Object.defineProperty &amp;&amp; Object.getOwnPropertyDescriptor</span><span class="s0">; for </span><span class="s1">(</span><span class="s0">var </span><span class="s1">key </span><span class="s0">in </span><span class="s1">obj) { </span><span class="s0">if </span><span class="s1">(Object.prototype.hasOwnProperty.call(obj</span><span class="s0">, </span><span class="s1">key)) { </span><span class="s0">var </span><span class="s1">desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj</span><span class="s0">, </span><span class="s1">key) : </span><span class="s0">null; if </span><span class="s1">(desc &amp;&amp; (desc.get || desc.set)) { Object.defineProperty(newObj</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">desc)</span><span class="s0">; </span><span class="s1">} </span><span class="s0">else </span><span class="s1">{ newObj[key] = obj[key]</span><span class="s0">; </span><span class="s1">} } } newObj[</span><span class="s2">&quot;default&quot;</span><span class="s1">] = obj</span><span class="s0">; if </span><span class="s1">(cache) { cache.set(obj</span><span class="s0">, </span><span class="s1">newObj)</span><span class="s0">; </span><span class="s1">} </span><span class="s0">return </span><span class="s1">newObj</span><span class="s0">; </span><span class="s1">}</span>

	<span class="s0">var </span><span class="s1">unescapable = (_unescapable = {}</span><span class="s0">, </span><span class="s1">_unescapable[t.tab] = </span><span class="s0">true, </span><span class="s1">_unescapable[t.newline] = </span><span class="s0">true, </span><span class="s1">_unescapable[t.cr] = </span><span class="s0">true, </span><span class="s1">_unescapable[t.feed] = </span><span class="s0">true, </span><span class="s1">_unescapable)</span><span class="s0">;</span>
	<span class="s0">var </span><span class="s1">wordDelimiters = (_wordDelimiters = {}</span><span class="s0">, </span><span class="s1">_wordDelimiters[t.space] = </span><span class="s0">true, </span><span class="s1">_wordDelimiters[t.tab] = </span><span class="s0">true, </span><span class="s1">_wordDelimiters[t.newline] = </span><span class="s0">true, </span><span class="s1">_wordDelimiters[t.cr] = </span><span class="s0">true, </span><span class="s1">_wordDelimiters[t.feed] = </span><span class="s0">true, </span><span class="s1">_wordDelimiters[t.ampersand] = </span><span class="s0">true, </span><span class="s1">_wordDelimiters[t.asterisk] = </span><span class="s0">true, </span><span class="s1">_wordDelimiters[t.bang] = </span><span class="s0">true, </span><span class="s1">_wordDelimiters[t.comma] = </span><span class="s0">true, </span><span class="s1">_wordDelimiters[t.colon] = </span><span class="s0">true, </span><span class="s1">_wordDelimiters[t.semicolon] = </span><span class="s0">true, </span><span class="s1">_wordDelimiters[t.openParenthesis] = </span><span class="s0">true, </span><span class="s1">_wordDelimiters[t.closeParenthesis] = </span><span class="s0">true, </span><span class="s1">_wordDelimiters[t.openSquare] = </span><span class="s0">true, </span><span class="s1">_wordDelimiters[t.closeSquare] = </span><span class="s0">true, </span><span class="s1">_wordDelimiters[t.singleQuote] = </span><span class="s0">true, </span><span class="s1">_wordDelimiters[t.doubleQuote] = </span><span class="s0">true, </span><span class="s1">_wordDelimiters[t.plus] = </span><span class="s0">true, </span><span class="s1">_wordDelimiters[t.pipe] = </span><span class="s0">true, </span><span class="s1">_wordDelimiters[t.tilde] = </span><span class="s0">true, </span><span class="s1">_wordDelimiters[t.greaterThan] = </span><span class="s0">true, </span><span class="s1">_wordDelimiters[t.equals] = </span><span class="s0">true, </span><span class="s1">_wordDelimiters[t.dollar] = </span><span class="s0">true, </span><span class="s1">_wordDelimiters[t.caret] = </span><span class="s0">true, </span><span class="s1">_wordDelimiters[t.slash] = </span><span class="s0">true, </span><span class="s1">_wordDelimiters)</span><span class="s0">;</span>
	<span class="s0">var </span><span class="s1">hex = {}</span><span class="s0">;</span>
	<span class="s0">var </span><span class="s1">hexChars = </span><span class="s2">&quot;0123456789abcdefABCDEF&quot;</span><span class="s0">;</span>

	<span class="s0">for </span><span class="s1">(</span><span class="s0">var </span><span class="s1">i = </span><span class="s3">0</span><span class="s0">; </span><span class="s1">i &lt; hexChars.length</span><span class="s0">; </span><span class="s1">i++) {</span>
	  <span class="s1">hex[hexChars.charCodeAt(i)] = </span><span class="s0">true;</span>
	<span class="s1">}</span>
	<span class="s5">/**</span>
	 <span class="s5">*  Returns the last index of the bar css word</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string} css The string in which the word begins</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{number} start The index into the string where word's first letter occurs</span>
	 <span class="s5">*/</span>


	<span class="s0">function </span><span class="s1">consumeWord(css</span><span class="s0">, </span><span class="s1">start) {</span>
	  <span class="s0">var </span><span class="s1">next = start</span><span class="s0">;</span>
	  <span class="s0">var </span><span class="s1">code</span><span class="s0">;</span>

	  <span class="s0">do </span><span class="s1">{</span>
	    <span class="s1">code = css.charCodeAt(next)</span><span class="s0">;</span>

	    <span class="s0">if </span><span class="s1">(wordDelimiters[code]) {</span>
	      <span class="s0">return </span><span class="s1">next - </span><span class="s3">1</span><span class="s0">;</span>
	    <span class="s1">} </span><span class="s0">else if </span><span class="s1">(code === t.backslash) {</span>
	      <span class="s1">next = consumeEscape(css</span><span class="s0">, </span><span class="s1">next) + </span><span class="s3">1</span><span class="s0">;</span>
	    <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
	      <span class="s4">// All other characters are part of the word</span>
	      <span class="s1">next++</span><span class="s0">;</span>
	    <span class="s1">}</span>
	  <span class="s1">} </span><span class="s0">while </span><span class="s1">(next &lt; css.length)</span><span class="s0">;</span>

	  <span class="s0">return </span><span class="s1">next - </span><span class="s3">1</span><span class="s0">;</span>
	<span class="s1">}</span>
	<span class="s5">/**</span>
	 <span class="s5">*  Returns the last index of the escape sequence</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string} css The string in which the sequence begins</span>
	 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{number} start The index into the string where escape character (`\`) occurs.</span>
	 <span class="s5">*/</span>


	<span class="s0">function </span><span class="s1">consumeEscape(css</span><span class="s0">, </span><span class="s1">start) {</span>
	  <span class="s0">var </span><span class="s1">next = start</span><span class="s0">;</span>
	  <span class="s0">var </span><span class="s1">code = css.charCodeAt(next + </span><span class="s3">1</span><span class="s1">)</span><span class="s0">;</span>

	  <span class="s0">if </span><span class="s1">(unescapable[code]) </span><span class="s0">; else if </span><span class="s1">(hex[code]) {</span>
	    <span class="s0">var </span><span class="s1">hexDigits = </span><span class="s3">0</span><span class="s0">; </span><span class="s4">// consume up to 6 hex chars</span>

	    <span class="s0">do </span><span class="s1">{</span>
	      <span class="s1">next++</span><span class="s0">;</span>
	      <span class="s1">hexDigits++</span><span class="s0">;</span>
	      <span class="s1">code = css.charCodeAt(next + </span><span class="s3">1</span><span class="s1">)</span><span class="s0">;</span>
	    <span class="s1">} </span><span class="s0">while </span><span class="s1">(hex[code] &amp;&amp; hexDigits &lt; </span><span class="s3">6</span><span class="s1">)</span><span class="s0">; </span><span class="s4">// if fewer than 6 hex chars, a trailing space ends the escape</span>


	    <span class="s0">if </span><span class="s1">(hexDigits &lt; </span><span class="s3">6 </span><span class="s1">&amp;&amp; code === t.space) {</span>
	      <span class="s1">next++</span><span class="s0">;</span>
	    <span class="s1">}</span>
	  <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
	    <span class="s4">// the next char is part of the current word</span>
	    <span class="s1">next++</span><span class="s0">;</span>
	  <span class="s1">}</span>

	  <span class="s0">return </span><span class="s1">next</span><span class="s0">;</span>
	<span class="s1">}</span>

	<span class="s0">var </span><span class="s1">FIELDS = {</span>
	  <span class="s1">TYPE: </span><span class="s3">0</span><span class="s0">,</span>
	  <span class="s1">START_LINE: </span><span class="s3">1</span><span class="s0">,</span>
	  <span class="s1">START_COL: </span><span class="s3">2</span><span class="s0">,</span>
	  <span class="s1">END_LINE: </span><span class="s3">3</span><span class="s0">,</span>
	  <span class="s1">END_COL: </span><span class="s3">4</span><span class="s0">,</span>
	  <span class="s1">START_POS: </span><span class="s3">5</span><span class="s0">,</span>
	  <span class="s1">END_POS: </span><span class="s3">6</span>
	<span class="s1">}</span><span class="s0">;</span>
	<span class="s1">exports.FIELDS = FIELDS</span><span class="s0">;</span>

	<span class="s0">function </span><span class="s1">tokenize(input) {</span>
	  <span class="s0">var </span><span class="s1">tokens = []</span><span class="s0">;</span>
	  <span class="s0">var </span><span class="s1">css = input.css.valueOf()</span><span class="s0">;</span>
	  <span class="s0">var </span><span class="s1">_css = css</span><span class="s0">,</span>
	      <span class="s1">length = _css.length</span><span class="s0">;</span>
	  <span class="s0">var </span><span class="s1">offset = -</span><span class="s3">1</span><span class="s0">;</span>
	  <span class="s0">var </span><span class="s1">line = </span><span class="s3">1</span><span class="s0">;</span>
	  <span class="s0">var </span><span class="s1">start = </span><span class="s3">0</span><span class="s0">;</span>
	  <span class="s0">var </span><span class="s1">end = </span><span class="s3">0</span><span class="s0">;</span>
	  <span class="s0">var </span><span class="s1">code</span><span class="s0">, </span><span class="s1">content</span><span class="s0">, </span><span class="s1">endColumn</span><span class="s0">, </span><span class="s1">endLine</span><span class="s0">, </span><span class="s1">escaped</span><span class="s0">, </span><span class="s1">escapePos</span><span class="s0">, </span><span class="s1">last</span><span class="s0">, </span><span class="s1">lines</span><span class="s0">, </span><span class="s1">next</span><span class="s0">, </span><span class="s1">nextLine</span><span class="s0">, </span><span class="s1">nextOffset</span><span class="s0">, </span><span class="s1">quote</span><span class="s0">, </span><span class="s1">tokenType</span><span class="s0">;</span>

	  <span class="s0">function </span><span class="s1">unclosed(what</span><span class="s0">, </span><span class="s1">fix) {</span>
	    <span class="s0">if </span><span class="s1">(input.safe) {</span>
	      <span class="s4">// fyi: this is never set to true.</span>
	      <span class="s1">css += fix</span><span class="s0">;</span>
	      <span class="s1">next = css.length - </span><span class="s3">1</span><span class="s0">;</span>
	    <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
	      <span class="s0">throw </span><span class="s1">input.error(</span><span class="s2">'Unclosed ' </span><span class="s1">+ what</span><span class="s0">, </span><span class="s1">line</span><span class="s0">, </span><span class="s1">start - offset</span><span class="s0">, </span><span class="s1">start)</span><span class="s0">;</span>
	    <span class="s1">}</span>
	  <span class="s1">}</span>

	  <span class="s0">while </span><span class="s1">(start &lt; length) {</span>
	    <span class="s1">code = css.charCodeAt(start)</span><span class="s0">;</span>

	    <span class="s0">if </span><span class="s1">(code === t.newline) {</span>
	      <span class="s1">offset = start</span><span class="s0">;</span>
	      <span class="s1">line += </span><span class="s3">1</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">switch </span><span class="s1">(code) {</span>
	      <span class="s0">case </span><span class="s1">t.space:</span>
	      <span class="s0">case </span><span class="s1">t.tab:</span>
	      <span class="s0">case </span><span class="s1">t.newline:</span>
	      <span class="s0">case </span><span class="s1">t.cr:</span>
	      <span class="s0">case </span><span class="s1">t.feed:</span>
	        <span class="s1">next = start</span><span class="s0">;</span>

	        <span class="s0">do </span><span class="s1">{</span>
	          <span class="s1">next += </span><span class="s3">1</span><span class="s0">;</span>
	          <span class="s1">code = css.charCodeAt(next)</span><span class="s0">;</span>

	          <span class="s0">if </span><span class="s1">(code === t.newline) {</span>
	            <span class="s1">offset = next</span><span class="s0">;</span>
	            <span class="s1">line += </span><span class="s3">1</span><span class="s0">;</span>
	          <span class="s1">}</span>
	        <span class="s1">} </span><span class="s0">while </span><span class="s1">(code === t.space || code === t.newline || code === t.tab || code === t.cr || code === t.feed)</span><span class="s0">;</span>

	        <span class="s1">tokenType = t.space</span><span class="s0">;</span>
	        <span class="s1">endLine = line</span><span class="s0">;</span>
	        <span class="s1">endColumn = next - offset - </span><span class="s3">1</span><span class="s0">;</span>
	        <span class="s1">end = next</span><span class="s0">;</span>
	        <span class="s0">break;</span>

	      <span class="s0">case </span><span class="s1">t.plus:</span>
	      <span class="s0">case </span><span class="s1">t.greaterThan:</span>
	      <span class="s0">case </span><span class="s1">t.tilde:</span>
	      <span class="s0">case </span><span class="s1">t.pipe:</span>
	        <span class="s1">next = start</span><span class="s0">;</span>

	        <span class="s0">do </span><span class="s1">{</span>
	          <span class="s1">next += </span><span class="s3">1</span><span class="s0">;</span>
	          <span class="s1">code = css.charCodeAt(next)</span><span class="s0">;</span>
	        <span class="s1">} </span><span class="s0">while </span><span class="s1">(code === t.plus || code === t.greaterThan || code === t.tilde || code === t.pipe)</span><span class="s0">;</span>

	        <span class="s1">tokenType = t.combinator</span><span class="s0">;</span>
	        <span class="s1">endLine = line</span><span class="s0">;</span>
	        <span class="s1">endColumn = start - offset</span><span class="s0">;</span>
	        <span class="s1">end = next</span><span class="s0">;</span>
	        <span class="s0">break;</span>
	      <span class="s4">// Consume these characters as single tokens.</span>

	      <span class="s0">case </span><span class="s1">t.asterisk:</span>
	      <span class="s0">case </span><span class="s1">t.ampersand:</span>
	      <span class="s0">case </span><span class="s1">t.bang:</span>
	      <span class="s0">case </span><span class="s1">t.comma:</span>
	      <span class="s0">case </span><span class="s1">t.equals:</span>
	      <span class="s0">case </span><span class="s1">t.dollar:</span>
	      <span class="s0">case </span><span class="s1">t.caret:</span>
	      <span class="s0">case </span><span class="s1">t.openSquare:</span>
	      <span class="s0">case </span><span class="s1">t.closeSquare:</span>
	      <span class="s0">case </span><span class="s1">t.colon:</span>
	      <span class="s0">case </span><span class="s1">t.semicolon:</span>
	      <span class="s0">case </span><span class="s1">t.openParenthesis:</span>
	      <span class="s0">case </span><span class="s1">t.closeParenthesis:</span>
	        <span class="s1">next = start</span><span class="s0">;</span>
	        <span class="s1">tokenType = code</span><span class="s0">;</span>
	        <span class="s1">endLine = line</span><span class="s0">;</span>
	        <span class="s1">endColumn = start - offset</span><span class="s0">;</span>
	        <span class="s1">end = next + </span><span class="s3">1</span><span class="s0">;</span>
	        <span class="s0">break;</span>

	      <span class="s0">case </span><span class="s1">t.singleQuote:</span>
	      <span class="s0">case </span><span class="s1">t.doubleQuote:</span>
	        <span class="s1">quote = code === t.singleQuote ? </span><span class="s2">&quot;'&quot; </span><span class="s1">: </span><span class="s2">'&quot;'</span><span class="s0">;</span>
	        <span class="s1">next = start</span><span class="s0">;</span>

	        <span class="s0">do </span><span class="s1">{</span>
	          <span class="s1">escaped = </span><span class="s0">false;</span>
	          <span class="s1">next = css.indexOf(quote</span><span class="s0">, </span><span class="s1">next + </span><span class="s3">1</span><span class="s1">)</span><span class="s0">;</span>

	          <span class="s0">if </span><span class="s1">(next === -</span><span class="s3">1</span><span class="s1">) {</span>
	            <span class="s1">unclosed(</span><span class="s2">'quote'</span><span class="s0">, </span><span class="s1">quote)</span><span class="s0">;</span>
	          <span class="s1">}</span>

	          <span class="s1">escapePos = next</span><span class="s0">;</span>

	          <span class="s0">while </span><span class="s1">(css.charCodeAt(escapePos - </span><span class="s3">1</span><span class="s1">) === t.backslash) {</span>
	            <span class="s1">escapePos -= </span><span class="s3">1</span><span class="s0">;</span>
	            <span class="s1">escaped = !escaped</span><span class="s0">;</span>
	          <span class="s1">}</span>
	        <span class="s1">} </span><span class="s0">while </span><span class="s1">(escaped)</span><span class="s0">;</span>

	        <span class="s1">tokenType = t.str</span><span class="s0">;</span>
	        <span class="s1">endLine = line</span><span class="s0">;</span>
	        <span class="s1">endColumn = start - offset</span><span class="s0">;</span>
	        <span class="s1">end = next + </span><span class="s3">1</span><span class="s0">;</span>
	        <span class="s0">break;</span>

	      <span class="s0">default</span><span class="s1">:</span>
	        <span class="s0">if </span><span class="s1">(code === t.slash &amp;&amp; css.charCodeAt(start + </span><span class="s3">1</span><span class="s1">) === t.asterisk) {</span>
	          <span class="s1">next = css.indexOf(</span><span class="s2">'*/'</span><span class="s0">, </span><span class="s1">start + </span><span class="s3">2</span><span class="s1">) + </span><span class="s3">1</span><span class="s0">;</span>

	          <span class="s0">if </span><span class="s1">(next === </span><span class="s3">0</span><span class="s1">) {</span>
	            <span class="s1">unclosed(</span><span class="s2">'comment'</span><span class="s0">, </span><span class="s2">'*/'</span><span class="s1">)</span><span class="s0">;</span>
	          <span class="s1">}</span>

	          <span class="s1">content = css.slice(start</span><span class="s0">, </span><span class="s1">next + </span><span class="s3">1</span><span class="s1">)</span><span class="s0">;</span>
	          <span class="s1">lines = content.split(</span><span class="s2">'</span><span class="s0">\n</span><span class="s2">'</span><span class="s1">)</span><span class="s0">;</span>
	          <span class="s1">last = lines.length - </span><span class="s3">1</span><span class="s0">;</span>

	          <span class="s0">if </span><span class="s1">(last &gt; </span><span class="s3">0</span><span class="s1">) {</span>
	            <span class="s1">nextLine = line + last</span><span class="s0">;</span>
	            <span class="s1">nextOffset = next - lines[last].length</span><span class="s0">;</span>
	          <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
	            <span class="s1">nextLine = line</span><span class="s0">;</span>
	            <span class="s1">nextOffset = offset</span><span class="s0">;</span>
	          <span class="s1">}</span>

	          <span class="s1">tokenType = t.comment</span><span class="s0">;</span>
	          <span class="s1">line = nextLine</span><span class="s0">;</span>
	          <span class="s1">endLine = nextLine</span><span class="s0">;</span>
	          <span class="s1">endColumn = next - nextOffset</span><span class="s0">;</span>
	        <span class="s1">} </span><span class="s0">else if </span><span class="s1">(code === t.slash) {</span>
	          <span class="s1">next = start</span><span class="s0">;</span>
	          <span class="s1">tokenType = code</span><span class="s0">;</span>
	          <span class="s1">endLine = line</span><span class="s0">;</span>
	          <span class="s1">endColumn = start - offset</span><span class="s0">;</span>
	          <span class="s1">end = next + </span><span class="s3">1</span><span class="s0">;</span>
	        <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
	          <span class="s1">next = consumeWord(css</span><span class="s0">, </span><span class="s1">start)</span><span class="s0">;</span>
	          <span class="s1">tokenType = t.word</span><span class="s0">;</span>
	          <span class="s1">endLine = line</span><span class="s0">;</span>
	          <span class="s1">endColumn = next - offset</span><span class="s0">;</span>
	        <span class="s1">}</span>

	        <span class="s1">end = next + </span><span class="s3">1</span><span class="s0">;</span>
	        <span class="s0">break;</span>
	    <span class="s1">} </span><span class="s4">// Ensure that the token structure remains consistent</span>


	    <span class="s1">tokens.push([tokenType</span><span class="s0">, </span><span class="s4">// [0] Token type</span>
	    <span class="s1">line</span><span class="s0">, </span><span class="s4">// [1] Starting line</span>
	    <span class="s1">start - offset</span><span class="s0">, </span><span class="s4">// [2] Starting column</span>
	    <span class="s1">endLine</span><span class="s0">, </span><span class="s4">// [3] Ending line</span>
	    <span class="s1">endColumn</span><span class="s0">, </span><span class="s4">// [4] Ending column</span>
	    <span class="s1">start</span><span class="s0">, </span><span class="s4">// [5] Start position / Source index</span>
	    <span class="s1">end </span><span class="s4">// [6] End position</span>
	    <span class="s1">])</span><span class="s0">; </span><span class="s4">// Reset offset for the next token</span>

	    <span class="s0">if </span><span class="s1">(nextOffset) {</span>
	      <span class="s1">offset = nextOffset</span><span class="s0">;</span>
	      <span class="s1">nextOffset = </span><span class="s0">null;</span>
	    <span class="s1">}</span>

	    <span class="s1">start = end</span><span class="s0">;</span>
	  <span class="s1">}</span>

	  <span class="s0">return </span><span class="s1">tokens</span><span class="s0">;</span>
	<span class="s1">}</span>
<span class="s1">} (tokenize))</span><span class="s0">;</span>

<span class="s1">(</span><span class="s0">function </span><span class="s1">(module</span><span class="s0">, </span><span class="s1">exports) {</span>

	<span class="s1">exports.__esModule = </span><span class="s0">true;</span>
	<span class="s1">exports[</span><span class="s2">&quot;default&quot;</span><span class="s1">] = </span><span class="s0">void </span><span class="s3">0</span><span class="s0">;</span>

	<span class="s0">var </span><span class="s1">_root = _interopRequireDefault(rootExports)</span><span class="s0">;</span>

	<span class="s0">var </span><span class="s1">_selector = _interopRequireDefault(selectorExports)</span><span class="s0">;</span>

	<span class="s0">var </span><span class="s1">_className = _interopRequireDefault(classNameExports)</span><span class="s0">;</span>

	<span class="s0">var </span><span class="s1">_comment = _interopRequireDefault(commentExports)</span><span class="s0">;</span>

	<span class="s0">var </span><span class="s1">_id = _interopRequireDefault(idExports)</span><span class="s0">;</span>

	<span class="s0">var </span><span class="s1">_tag = _interopRequireDefault(tagExports)</span><span class="s0">;</span>

	<span class="s0">var </span><span class="s1">_string = _interopRequireDefault(stringExports)</span><span class="s0">;</span>

	<span class="s0">var </span><span class="s1">_pseudo = _interopRequireDefault(pseudoExports)</span><span class="s0">;</span>

	<span class="s0">var </span><span class="s1">_attribute = _interopRequireWildcard(attribute$1)</span><span class="s0">;</span>

	<span class="s0">var </span><span class="s1">_universal = _interopRequireDefault(universalExports)</span><span class="s0">;</span>

	<span class="s0">var </span><span class="s1">_combinator = _interopRequireDefault(combinatorExports)</span><span class="s0">;</span>

	<span class="s0">var </span><span class="s1">_nesting = _interopRequireDefault(nestingExports)</span><span class="s0">;</span>

	<span class="s0">var </span><span class="s1">_sortAscending = _interopRequireDefault(sortAscendingExports)</span><span class="s0">;</span>

	<span class="s0">var </span><span class="s1">_tokenize = _interopRequireWildcard(tokenize)</span><span class="s0">;</span>

	<span class="s0">var </span><span class="s1">tokens = _interopRequireWildcard(tokenTypes)</span><span class="s0">;</span>

	<span class="s0">var </span><span class="s1">types$1 = _interopRequireWildcard(types)</span><span class="s0">;</span>

	<span class="s0">var </span><span class="s1">_util = util</span><span class="s0">;</span>

	<span class="s0">var </span><span class="s1">_WHITESPACE_TOKENS</span><span class="s0">, </span><span class="s1">_Object$assign</span><span class="s0">;</span>

	<span class="s0">function </span><span class="s1">_getRequireWildcardCache() { </span><span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">WeakMap !== </span><span class="s2">&quot;function&quot;</span><span class="s1">) </span><span class="s0">return null; var </span><span class="s1">cache = </span><span class="s0">new </span><span class="s1">WeakMap()</span><span class="s0">; </span><span class="s1">_getRequireWildcardCache = </span><span class="s0">function </span><span class="s1">_getRequireWildcardCache() { </span><span class="s0">return </span><span class="s1">cache</span><span class="s0">; </span><span class="s1">}</span><span class="s0">; return </span><span class="s1">cache</span><span class="s0">; </span><span class="s1">}</span>

	<span class="s0">function </span><span class="s1">_interopRequireWildcard(obj) { </span><span class="s0">if </span><span class="s1">(obj &amp;&amp; obj.__esModule) { </span><span class="s0">return </span><span class="s1">obj</span><span class="s0">; </span><span class="s1">} </span><span class="s0">if </span><span class="s1">(obj === </span><span class="s0">null </span><span class="s1">|| </span><span class="s0">typeof </span><span class="s1">obj !== </span><span class="s2">&quot;object&quot; </span><span class="s1">&amp;&amp; </span><span class="s0">typeof </span><span class="s1">obj !== </span><span class="s2">&quot;function&quot;</span><span class="s1">) { </span><span class="s0">return </span><span class="s1">{ </span><span class="s2">&quot;default&quot;</span><span class="s1">: obj }</span><span class="s0">; </span><span class="s1">} </span><span class="s0">var </span><span class="s1">cache = _getRequireWildcardCache()</span><span class="s0">; if </span><span class="s1">(cache &amp;&amp; cache.has(obj)) { </span><span class="s0">return </span><span class="s1">cache.get(obj)</span><span class="s0">; </span><span class="s1">} </span><span class="s0">var </span><span class="s1">newObj = {}</span><span class="s0">; var </span><span class="s1">hasPropertyDescriptor = Object.defineProperty &amp;&amp; Object.getOwnPropertyDescriptor</span><span class="s0">; for </span><span class="s1">(</span><span class="s0">var </span><span class="s1">key </span><span class="s0">in </span><span class="s1">obj) { </span><span class="s0">if </span><span class="s1">(Object.prototype.hasOwnProperty.call(obj</span><span class="s0">, </span><span class="s1">key)) { </span><span class="s0">var </span><span class="s1">desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj</span><span class="s0">, </span><span class="s1">key) : </span><span class="s0">null; if </span><span class="s1">(desc &amp;&amp; (desc.get || desc.set)) { Object.defineProperty(newObj</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">desc)</span><span class="s0">; </span><span class="s1">} </span><span class="s0">else </span><span class="s1">{ newObj[key] = obj[key]</span><span class="s0">; </span><span class="s1">} } } newObj[</span><span class="s2">&quot;default&quot;</span><span class="s1">] = obj</span><span class="s0">; if </span><span class="s1">(cache) { cache.set(obj</span><span class="s0">, </span><span class="s1">newObj)</span><span class="s0">; </span><span class="s1">} </span><span class="s0">return </span><span class="s1">newObj</span><span class="s0">; </span><span class="s1">}</span>

	<span class="s0">function </span><span class="s1">_interopRequireDefault(obj) { </span><span class="s0">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : { </span><span class="s2">&quot;default&quot;</span><span class="s1">: obj }</span><span class="s0">; </span><span class="s1">}</span>

	<span class="s0">function </span><span class="s1">_defineProperties(target</span><span class="s0">, </span><span class="s1">props) { </span><span class="s0">for </span><span class="s1">(</span><span class="s0">var </span><span class="s1">i = </span><span class="s3">0</span><span class="s0">; </span><span class="s1">i &lt; props.length</span><span class="s0">; </span><span class="s1">i++) { </span><span class="s0">var </span><span class="s1">descriptor = props[i]</span><span class="s0">; </span><span class="s1">descriptor.enumerable = descriptor.enumerable || </span><span class="s0">false; </span><span class="s1">descriptor.configurable = </span><span class="s0">true; if </span><span class="s1">(</span><span class="s2">&quot;value&quot; </span><span class="s0">in </span><span class="s1">descriptor) descriptor.writable = </span><span class="s0">true; </span><span class="s1">Object.defineProperty(target</span><span class="s0">, </span><span class="s1">descriptor.key</span><span class="s0">, </span><span class="s1">descriptor)</span><span class="s0">; </span><span class="s1">} }</span>

	<span class="s0">function </span><span class="s1">_createClass(Constructor</span><span class="s0">, </span><span class="s1">protoProps</span><span class="s0">, </span><span class="s1">staticProps) { </span><span class="s0">if </span><span class="s1">(protoProps) _defineProperties(Constructor.prototype</span><span class="s0">, </span><span class="s1">protoProps)</span><span class="s0">; if </span><span class="s1">(staticProps) _defineProperties(Constructor</span><span class="s0">, </span><span class="s1">staticProps)</span><span class="s0">; return </span><span class="s1">Constructor</span><span class="s0">; </span><span class="s1">}</span>

	<span class="s0">var </span><span class="s1">WHITESPACE_TOKENS = (_WHITESPACE_TOKENS = {}</span><span class="s0">, </span><span class="s1">_WHITESPACE_TOKENS[tokens.space] = </span><span class="s0">true, </span><span class="s1">_WHITESPACE_TOKENS[tokens.cr] = </span><span class="s0">true, </span><span class="s1">_WHITESPACE_TOKENS[tokens.feed] = </span><span class="s0">true, </span><span class="s1">_WHITESPACE_TOKENS[tokens.newline] = </span><span class="s0">true, </span><span class="s1">_WHITESPACE_TOKENS[tokens.tab] = </span><span class="s0">true, </span><span class="s1">_WHITESPACE_TOKENS)</span><span class="s0">;</span>
	<span class="s0">var </span><span class="s1">WHITESPACE_EQUIV_TOKENS = Object.assign({}</span><span class="s0">, </span><span class="s1">WHITESPACE_TOKENS</span><span class="s0">, </span><span class="s1">(_Object$assign = {}</span><span class="s0">, </span><span class="s1">_Object$assign[tokens.comment] = </span><span class="s0">true, </span><span class="s1">_Object$assign))</span><span class="s0">;</span>

	<span class="s0">function </span><span class="s1">tokenStart(token) {</span>
	  <span class="s0">return </span><span class="s1">{</span>
	    <span class="s1">line: token[_tokenize.FIELDS.START_LINE]</span><span class="s0">,</span>
	    <span class="s1">column: token[_tokenize.FIELDS.START_COL]</span>
	  <span class="s1">}</span><span class="s0">;</span>
	<span class="s1">}</span>

	<span class="s0">function </span><span class="s1">tokenEnd(token) {</span>
	  <span class="s0">return </span><span class="s1">{</span>
	    <span class="s1">line: token[_tokenize.FIELDS.END_LINE]</span><span class="s0">,</span>
	    <span class="s1">column: token[_tokenize.FIELDS.END_COL]</span>
	  <span class="s1">}</span><span class="s0">;</span>
	<span class="s1">}</span>

	<span class="s0">function </span><span class="s1">getSource(startLine</span><span class="s0">, </span><span class="s1">startColumn</span><span class="s0">, </span><span class="s1">endLine</span><span class="s0">, </span><span class="s1">endColumn) {</span>
	  <span class="s0">return </span><span class="s1">{</span>
	    <span class="s1">start: {</span>
	      <span class="s1">line: startLine</span><span class="s0">,</span>
	      <span class="s1">column: startColumn</span>
	    <span class="s1">}</span><span class="s0">,</span>
	    <span class="s1">end: {</span>
	      <span class="s1">line: endLine</span><span class="s0">,</span>
	      <span class="s1">column: endColumn</span>
	    <span class="s1">}</span>
	  <span class="s1">}</span><span class="s0">;</span>
	<span class="s1">}</span>

	<span class="s0">function </span><span class="s1">getTokenSource(token) {</span>
	  <span class="s0">return </span><span class="s1">getSource(token[_tokenize.FIELDS.START_LINE]</span><span class="s0">, </span><span class="s1">token[_tokenize.FIELDS.START_COL]</span><span class="s0">, </span><span class="s1">token[_tokenize.FIELDS.END_LINE]</span><span class="s0">, </span><span class="s1">token[_tokenize.FIELDS.END_COL])</span><span class="s0">;</span>
	<span class="s1">}</span>

	<span class="s0">function </span><span class="s1">getTokenSourceSpan(startToken</span><span class="s0">, </span><span class="s1">endToken) {</span>
	  <span class="s0">if </span><span class="s1">(!startToken) {</span>
	    <span class="s0">return </span><span class="s1">undefined</span><span class="s0">;</span>
	  <span class="s1">}</span>

	  <span class="s0">return </span><span class="s1">getSource(startToken[_tokenize.FIELDS.START_LINE]</span><span class="s0">, </span><span class="s1">startToken[_tokenize.FIELDS.START_COL]</span><span class="s0">, </span><span class="s1">endToken[_tokenize.FIELDS.END_LINE]</span><span class="s0">, </span><span class="s1">endToken[_tokenize.FIELDS.END_COL])</span><span class="s0">;</span>
	<span class="s1">}</span>

	<span class="s0">function </span><span class="s1">unescapeProp(node</span><span class="s0">, </span><span class="s1">prop) {</span>
	  <span class="s0">var </span><span class="s1">value = node[prop]</span><span class="s0">;</span>

	  <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">value !== </span><span class="s2">&quot;string&quot;</span><span class="s1">) {</span>
	    <span class="s0">return;</span>
	  <span class="s1">}</span>

	  <span class="s0">if </span><span class="s1">(value.indexOf(</span><span class="s2">&quot;</span><span class="s0">\\</span><span class="s2">&quot;</span><span class="s1">) !== -</span><span class="s3">1</span><span class="s1">) {</span>
	    <span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">_util.ensureObject)(node</span><span class="s0">, </span><span class="s2">'raws'</span><span class="s1">)</span><span class="s0">;</span>
	    <span class="s1">node[prop] = (</span><span class="s3">0</span><span class="s0">, </span><span class="s1">_util.unesc)(value)</span><span class="s0">;</span>

	    <span class="s0">if </span><span class="s1">(node.raws[prop] === undefined) {</span>
	      <span class="s1">node.raws[prop] = value</span><span class="s0">;</span>
	    <span class="s1">}</span>
	  <span class="s1">}</span>

	  <span class="s0">return </span><span class="s1">node</span><span class="s0">;</span>
	<span class="s1">}</span>

	<span class="s0">function </span><span class="s1">indexesOf(array</span><span class="s0">, </span><span class="s1">item) {</span>
	  <span class="s0">var </span><span class="s1">i = -</span><span class="s3">1</span><span class="s0">;</span>
	  <span class="s0">var </span><span class="s1">indexes = []</span><span class="s0">;</span>

	  <span class="s0">while </span><span class="s1">((i = array.indexOf(item</span><span class="s0">, </span><span class="s1">i + </span><span class="s3">1</span><span class="s1">)) !== -</span><span class="s3">1</span><span class="s1">) {</span>
	    <span class="s1">indexes.push(i)</span><span class="s0">;</span>
	  <span class="s1">}</span>

	  <span class="s0">return </span><span class="s1">indexes</span><span class="s0">;</span>
	<span class="s1">}</span>

	<span class="s0">function </span><span class="s1">uniqs() {</span>
	  <span class="s0">var </span><span class="s1">list = Array.prototype.concat.apply([]</span><span class="s0">, </span><span class="s1">arguments)</span><span class="s0">;</span>
	  <span class="s0">return </span><span class="s1">list.filter(</span><span class="s0">function </span><span class="s1">(item</span><span class="s0">, </span><span class="s1">i) {</span>
	    <span class="s0">return </span><span class="s1">i === list.indexOf(item)</span><span class="s0">;</span>
	  <span class="s1">})</span><span class="s0">;</span>
	<span class="s1">}</span>

	<span class="s0">var </span><span class="s1">Parser = </span><span class="s4">/*#__PURE__*/</span><span class="s0">function </span><span class="s1">() {</span>
	  <span class="s0">function </span><span class="s1">Parser(rule</span><span class="s0">, </span><span class="s1">options) {</span>
	    <span class="s0">if </span><span class="s1">(options === </span><span class="s0">void </span><span class="s3">0</span><span class="s1">) {</span>
	      <span class="s1">options = {}</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">this</span><span class="s1">.rule = rule</span><span class="s0">;</span>
	    <span class="s0">this</span><span class="s1">.options = Object.assign({</span>
	      <span class="s1">lossy: </span><span class="s0">false,</span>
	      <span class="s1">safe: </span><span class="s0">false</span>
	    <span class="s1">}</span><span class="s0">, </span><span class="s1">options)</span><span class="s0">;</span>
	    <span class="s0">this</span><span class="s1">.position = </span><span class="s3">0</span><span class="s0">;</span>
	    <span class="s0">this</span><span class="s1">.css = </span><span class="s0">typeof this</span><span class="s1">.rule === </span><span class="s2">'string' </span><span class="s1">? </span><span class="s0">this</span><span class="s1">.rule : </span><span class="s0">this</span><span class="s1">.rule.selector</span><span class="s0">;</span>
	    <span class="s0">this</span><span class="s1">.tokens = (</span><span class="s3">0</span><span class="s0">, </span><span class="s1">_tokenize[</span><span class="s2">&quot;default&quot;</span><span class="s1">])({</span>
	      <span class="s1">css: </span><span class="s0">this</span><span class="s1">.css</span><span class="s0">,</span>
	      <span class="s1">error: </span><span class="s0">this</span><span class="s1">._errorGenerator()</span><span class="s0">,</span>
	      <span class="s1">safe: </span><span class="s0">this</span><span class="s1">.options.safe</span>
	    <span class="s1">})</span><span class="s0">;</span>
	    <span class="s0">var </span><span class="s1">rootSource = getTokenSourceSpan(</span><span class="s0">this</span><span class="s1">.tokens[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, this</span><span class="s1">.tokens[</span><span class="s0">this</span><span class="s1">.tokens.length - </span><span class="s3">1</span><span class="s1">])</span><span class="s0">;</span>
	    <span class="s0">this</span><span class="s1">.root = </span><span class="s0">new </span><span class="s1">_root[</span><span class="s2">&quot;default&quot;</span><span class="s1">]({</span>
	      <span class="s1">source: rootSource</span>
	    <span class="s1">})</span><span class="s0">;</span>
	    <span class="s0">this</span><span class="s1">.root.errorGenerator = </span><span class="s0">this</span><span class="s1">._errorGenerator()</span><span class="s0">;</span>
	    <span class="s0">var </span><span class="s1">selector = </span><span class="s0">new </span><span class="s1">_selector[</span><span class="s2">&quot;default&quot;</span><span class="s1">]({</span>
	      <span class="s1">source: {</span>
	        <span class="s1">start: {</span>
	          <span class="s1">line: </span><span class="s3">1</span><span class="s0">,</span>
	          <span class="s1">column: </span><span class="s3">1</span>
	        <span class="s1">}</span>
	      <span class="s1">}</span>
	    <span class="s1">})</span><span class="s0">;</span>
	    <span class="s0">this</span><span class="s1">.root.append(selector)</span><span class="s0">;</span>
	    <span class="s0">this</span><span class="s1">.current = selector</span><span class="s0">;</span>
	    <span class="s0">this</span><span class="s1">.loop()</span><span class="s0">;</span>
	  <span class="s1">}</span>

	  <span class="s0">var </span><span class="s1">_proto = Parser.prototype</span><span class="s0">;</span>

	  <span class="s1">_proto._errorGenerator = </span><span class="s0">function </span><span class="s1">_errorGenerator() {</span>
	    <span class="s0">var </span><span class="s1">_this = </span><span class="s0">this;</span>

	    <span class="s0">return function </span><span class="s1">(message</span><span class="s0">, </span><span class="s1">errorOptions) {</span>
	      <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">_this.rule === </span><span class="s2">'string'</span><span class="s1">) {</span>
	        <span class="s0">return new </span><span class="s1">Error(message)</span><span class="s0">;</span>
	      <span class="s1">}</span>

	      <span class="s0">return </span><span class="s1">_this.rule.error(message</span><span class="s0">, </span><span class="s1">errorOptions)</span><span class="s0">;</span>
	    <span class="s1">}</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.attribute = </span><span class="s0">function </span><span class="s1">attribute() {</span>
	    <span class="s0">var </span><span class="s1">attr = []</span><span class="s0">;</span>
	    <span class="s0">var </span><span class="s1">startingToken = </span><span class="s0">this</span><span class="s1">.currToken</span><span class="s0">;</span>
	    <span class="s0">this</span><span class="s1">.position++</span><span class="s0">;</span>

	    <span class="s0">while </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.position &lt; </span><span class="s0">this</span><span class="s1">.tokens.length &amp;&amp; </span><span class="s0">this</span><span class="s1">.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {</span>
	      <span class="s1">attr.push(</span><span class="s0">this</span><span class="s1">.currToken)</span><span class="s0">;</span>
	      <span class="s0">this</span><span class="s1">.position++</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {</span>
	      <span class="s0">return this</span><span class="s1">.expected(</span><span class="s2">'closing square bracket'</span><span class="s0">, this</span><span class="s1">.currToken[_tokenize.FIELDS.START_POS])</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">var </span><span class="s1">len = attr.length</span><span class="s0">;</span>
	    <span class="s0">var </span><span class="s1">node = {</span>
	      <span class="s1">source: getSource(startingToken[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">startingToken[</span><span class="s3">2</span><span class="s1">]</span><span class="s0">, this</span><span class="s1">.currToken[</span><span class="s3">3</span><span class="s1">]</span><span class="s0">, this</span><span class="s1">.currToken[</span><span class="s3">4</span><span class="s1">])</span><span class="s0">,</span>
	      <span class="s1">sourceIndex: startingToken[_tokenize.FIELDS.START_POS]</span>
	    <span class="s1">}</span><span class="s0">;</span>

	    <span class="s0">if </span><span class="s1">(len === </span><span class="s3">1 </span><span class="s1">&amp;&amp; !~[tokens.word].indexOf(attr[</span><span class="s3">0</span><span class="s1">][_tokenize.FIELDS.TYPE])) {</span>
	      <span class="s0">return this</span><span class="s1">.expected(</span><span class="s2">'attribute'</span><span class="s0">, </span><span class="s1">attr[</span><span class="s3">0</span><span class="s1">][_tokenize.FIELDS.START_POS])</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">var </span><span class="s1">pos = </span><span class="s3">0</span><span class="s0">;</span>
	    <span class="s0">var </span><span class="s1">spaceBefore = </span><span class="s2">''</span><span class="s0">;</span>
	    <span class="s0">var </span><span class="s1">commentBefore = </span><span class="s2">''</span><span class="s0">;</span>
	    <span class="s0">var </span><span class="s1">lastAdded = </span><span class="s0">null;</span>
	    <span class="s0">var </span><span class="s1">spaceAfterMeaningfulToken = </span><span class="s0">false;</span>

	    <span class="s0">while </span><span class="s1">(pos &lt; len) {</span>
	      <span class="s0">var </span><span class="s1">token = attr[pos]</span><span class="s0">;</span>
	      <span class="s0">var </span><span class="s1">content = </span><span class="s0">this</span><span class="s1">.content(token)</span><span class="s0">;</span>
	      <span class="s0">var </span><span class="s1">next = attr[pos + </span><span class="s3">1</span><span class="s1">]</span><span class="s0">;</span>

	      <span class="s0">switch </span><span class="s1">(token[_tokenize.FIELDS.TYPE]) {</span>
	        <span class="s0">case </span><span class="s1">tokens.space:</span>
	          <span class="s4">// if (</span>
	          <span class="s4">//     len === 1 ||</span>
	          <span class="s4">//     pos === 0 &amp;&amp; this.content(next) === '|'</span>
	          <span class="s4">// ) {</span>
	          <span class="s4">//     return this.expected('attribute', token[TOKEN.START_POS], content);</span>
	          <span class="s4">// }</span>
	          <span class="s1">spaceAfterMeaningfulToken = </span><span class="s0">true;</span>

	          <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.options.lossy) {</span>
	            <span class="s0">break;</span>
	          <span class="s1">}</span>

	          <span class="s0">if </span><span class="s1">(lastAdded) {</span>
	            <span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">_util.ensureObject)(node</span><span class="s0">, </span><span class="s2">'spaces'</span><span class="s0">, </span><span class="s1">lastAdded)</span><span class="s0">;</span>
	            <span class="s0">var </span><span class="s1">prevContent = node.spaces[lastAdded].after || </span><span class="s2">''</span><span class="s0">;</span>
	            <span class="s1">node.spaces[lastAdded].after = prevContent + content</span><span class="s0">;</span>
	            <span class="s0">var </span><span class="s1">existingComment = (</span><span class="s3">0</span><span class="s0">, </span><span class="s1">_util.getProp)(node</span><span class="s0">, </span><span class="s2">'raws'</span><span class="s0">, </span><span class="s2">'spaces'</span><span class="s0">, </span><span class="s1">lastAdded</span><span class="s0">, </span><span class="s2">'after'</span><span class="s1">) || </span><span class="s0">null;</span>

	            <span class="s0">if </span><span class="s1">(existingComment) {</span>
	              <span class="s1">node.raws.spaces[lastAdded].after = existingComment + content</span><span class="s0">;</span>
	            <span class="s1">}</span>
	          <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
	            <span class="s1">spaceBefore = spaceBefore + content</span><span class="s0">;</span>
	            <span class="s1">commentBefore = commentBefore + content</span><span class="s0">;</span>
	          <span class="s1">}</span>

	          <span class="s0">break;</span>

	        <span class="s0">case </span><span class="s1">tokens.asterisk:</span>
	          <span class="s0">if </span><span class="s1">(next[_tokenize.FIELDS.TYPE] === tokens.equals) {</span>
	            <span class="s1">node.operator = content</span><span class="s0">;</span>
	            <span class="s1">lastAdded = </span><span class="s2">'operator'</span><span class="s0">;</span>
	          <span class="s1">} </span><span class="s0">else if </span><span class="s1">((!node.namespace || lastAdded === </span><span class="s2">&quot;namespace&quot; </span><span class="s1">&amp;&amp; !spaceAfterMeaningfulToken) &amp;&amp; next) {</span>
	            <span class="s0">if </span><span class="s1">(spaceBefore) {</span>
	              <span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">_util.ensureObject)(node</span><span class="s0">, </span><span class="s2">'spaces'</span><span class="s0">, </span><span class="s2">'attribute'</span><span class="s1">)</span><span class="s0">;</span>
	              <span class="s1">node.spaces.attribute.before = spaceBefore</span><span class="s0">;</span>
	              <span class="s1">spaceBefore = </span><span class="s2">''</span><span class="s0">;</span>
	            <span class="s1">}</span>

	            <span class="s0">if </span><span class="s1">(commentBefore) {</span>
	              <span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">_util.ensureObject)(node</span><span class="s0">, </span><span class="s2">'raws'</span><span class="s0">, </span><span class="s2">'spaces'</span><span class="s0">, </span><span class="s2">'attribute'</span><span class="s1">)</span><span class="s0">;</span>
	              <span class="s1">node.raws.spaces.attribute.before = spaceBefore</span><span class="s0">;</span>
	              <span class="s1">commentBefore = </span><span class="s2">''</span><span class="s0">;</span>
	            <span class="s1">}</span>

	            <span class="s1">node.namespace = (node.namespace || </span><span class="s2">&quot;&quot;</span><span class="s1">) + content</span><span class="s0">;</span>
	            <span class="s0">var </span><span class="s1">rawValue = (</span><span class="s3">0</span><span class="s0">, </span><span class="s1">_util.getProp)(node</span><span class="s0">, </span><span class="s2">'raws'</span><span class="s0">, </span><span class="s2">'namespace'</span><span class="s1">) || </span><span class="s0">null;</span>

	            <span class="s0">if </span><span class="s1">(rawValue) {</span>
	              <span class="s1">node.raws.namespace += content</span><span class="s0">;</span>
	            <span class="s1">}</span>

	            <span class="s1">lastAdded = </span><span class="s2">'namespace'</span><span class="s0">;</span>
	          <span class="s1">}</span>

	          <span class="s1">spaceAfterMeaningfulToken = </span><span class="s0">false;</span>
	          <span class="s0">break;</span>

	        <span class="s0">case </span><span class="s1">tokens.dollar:</span>
	          <span class="s0">if </span><span class="s1">(lastAdded === </span><span class="s2">&quot;value&quot;</span><span class="s1">) {</span>
	            <span class="s0">var </span><span class="s1">oldRawValue = (</span><span class="s3">0</span><span class="s0">, </span><span class="s1">_util.getProp)(node</span><span class="s0">, </span><span class="s2">'raws'</span><span class="s0">, </span><span class="s2">'value'</span><span class="s1">)</span><span class="s0">;</span>
	            <span class="s1">node.value += </span><span class="s2">&quot;$&quot;</span><span class="s0">;</span>

	            <span class="s0">if </span><span class="s1">(oldRawValue) {</span>
	              <span class="s1">node.raws.value = oldRawValue + </span><span class="s2">&quot;$&quot;</span><span class="s0">;</span>
	            <span class="s1">}</span>

	            <span class="s0">break;</span>
	          <span class="s1">}</span>

	        <span class="s4">// Falls through</span>

	        <span class="s0">case </span><span class="s1">tokens.caret:</span>
	          <span class="s0">if </span><span class="s1">(next[_tokenize.FIELDS.TYPE] === tokens.equals) {</span>
	            <span class="s1">node.operator = content</span><span class="s0">;</span>
	            <span class="s1">lastAdded = </span><span class="s2">'operator'</span><span class="s0">;</span>
	          <span class="s1">}</span>

	          <span class="s1">spaceAfterMeaningfulToken = </span><span class="s0">false;</span>
	          <span class="s0">break;</span>

	        <span class="s0">case </span><span class="s1">tokens.combinator:</span>
	          <span class="s0">if </span><span class="s1">(content === </span><span class="s2">'~' </span><span class="s1">&amp;&amp; next[_tokenize.FIELDS.TYPE] === tokens.equals) {</span>
	            <span class="s1">node.operator = content</span><span class="s0">;</span>
	            <span class="s1">lastAdded = </span><span class="s2">'operator'</span><span class="s0">;</span>
	          <span class="s1">}</span>

	          <span class="s0">if </span><span class="s1">(content !== </span><span class="s2">'|'</span><span class="s1">) {</span>
	            <span class="s1">spaceAfterMeaningfulToken = </span><span class="s0">false;</span>
	            <span class="s0">break;</span>
	          <span class="s1">}</span>

	          <span class="s0">if </span><span class="s1">(next[_tokenize.FIELDS.TYPE] === tokens.equals) {</span>
	            <span class="s1">node.operator = content</span><span class="s0">;</span>
	            <span class="s1">lastAdded = </span><span class="s2">'operator'</span><span class="s0">;</span>
	          <span class="s1">} </span><span class="s0">else if </span><span class="s1">(!node.namespace &amp;&amp; !node.attribute) {</span>
	            <span class="s1">node.namespace = </span><span class="s0">true;</span>
	          <span class="s1">}</span>

	          <span class="s1">spaceAfterMeaningfulToken = </span><span class="s0">false;</span>
	          <span class="s0">break;</span>

	        <span class="s0">case </span><span class="s1">tokens.word:</span>
	          <span class="s0">if </span><span class="s1">(next &amp;&amp; </span><span class="s0">this</span><span class="s1">.content(next) === </span><span class="s2">'|' </span><span class="s1">&amp;&amp; attr[pos + </span><span class="s3">2</span><span class="s1">] &amp;&amp; attr[pos + </span><span class="s3">2</span><span class="s1">][_tokenize.FIELDS.TYPE] !== tokens.equals &amp;&amp; </span><span class="s4">// this look-ahead probably fails with comment nodes involved.</span>
	          <span class="s1">!node.operator &amp;&amp; !node.namespace) {</span>
	            <span class="s1">node.namespace = content</span><span class="s0">;</span>
	            <span class="s1">lastAdded = </span><span class="s2">'namespace'</span><span class="s0">;</span>
	          <span class="s1">} </span><span class="s0">else if </span><span class="s1">(!node.attribute || lastAdded === </span><span class="s2">&quot;attribute&quot; </span><span class="s1">&amp;&amp; !spaceAfterMeaningfulToken) {</span>
	            <span class="s0">if </span><span class="s1">(spaceBefore) {</span>
	              <span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">_util.ensureObject)(node</span><span class="s0">, </span><span class="s2">'spaces'</span><span class="s0">, </span><span class="s2">'attribute'</span><span class="s1">)</span><span class="s0">;</span>
	              <span class="s1">node.spaces.attribute.before = spaceBefore</span><span class="s0">;</span>
	              <span class="s1">spaceBefore = </span><span class="s2">''</span><span class="s0">;</span>
	            <span class="s1">}</span>

	            <span class="s0">if </span><span class="s1">(commentBefore) {</span>
	              <span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">_util.ensureObject)(node</span><span class="s0">, </span><span class="s2">'raws'</span><span class="s0">, </span><span class="s2">'spaces'</span><span class="s0">, </span><span class="s2">'attribute'</span><span class="s1">)</span><span class="s0">;</span>
	              <span class="s1">node.raws.spaces.attribute.before = commentBefore</span><span class="s0">;</span>
	              <span class="s1">commentBefore = </span><span class="s2">''</span><span class="s0">;</span>
	            <span class="s1">}</span>

	            <span class="s1">node.attribute = (node.attribute || </span><span class="s2">&quot;&quot;</span><span class="s1">) + content</span><span class="s0">;</span>

	            <span class="s0">var </span><span class="s1">_rawValue = (</span><span class="s3">0</span><span class="s0">, </span><span class="s1">_util.getProp)(node</span><span class="s0">, </span><span class="s2">'raws'</span><span class="s0">, </span><span class="s2">'attribute'</span><span class="s1">) || </span><span class="s0">null;</span>

	            <span class="s0">if </span><span class="s1">(_rawValue) {</span>
	              <span class="s1">node.raws.attribute += content</span><span class="s0">;</span>
	            <span class="s1">}</span>

	            <span class="s1">lastAdded = </span><span class="s2">'attribute'</span><span class="s0">;</span>
	          <span class="s1">} </span><span class="s0">else if </span><span class="s1">(!node.value &amp;&amp; node.value !== </span><span class="s2">&quot;&quot; </span><span class="s1">|| lastAdded === </span><span class="s2">&quot;value&quot; </span><span class="s1">&amp;&amp; !spaceAfterMeaningfulToken) {</span>
	            <span class="s0">var </span><span class="s1">_unescaped = (</span><span class="s3">0</span><span class="s0">, </span><span class="s1">_util.unesc)(content)</span><span class="s0">;</span>

	            <span class="s0">var </span><span class="s1">_oldRawValue = (</span><span class="s3">0</span><span class="s0">, </span><span class="s1">_util.getProp)(node</span><span class="s0">, </span><span class="s2">'raws'</span><span class="s0">, </span><span class="s2">'value'</span><span class="s1">) || </span><span class="s2">''</span><span class="s0">;</span>

	            <span class="s0">var </span><span class="s1">oldValue = node.value || </span><span class="s2">''</span><span class="s0">;</span>
	            <span class="s1">node.value = oldValue + _unescaped</span><span class="s0">;</span>
	            <span class="s1">node.quoteMark = </span><span class="s0">null;</span>

	            <span class="s0">if </span><span class="s1">(_unescaped !== content || _oldRawValue) {</span>
	              <span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">_util.ensureObject)(node</span><span class="s0">, </span><span class="s2">'raws'</span><span class="s1">)</span><span class="s0">;</span>
	              <span class="s1">node.raws.value = (_oldRawValue || oldValue) + content</span><span class="s0">;</span>
	            <span class="s1">}</span>

	            <span class="s1">lastAdded = </span><span class="s2">'value'</span><span class="s0">;</span>
	          <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
	            <span class="s0">var </span><span class="s1">insensitive = content === </span><span class="s2">'i' </span><span class="s1">|| content === </span><span class="s2">&quot;I&quot;</span><span class="s0">;</span>

	            <span class="s0">if </span><span class="s1">((node.value || node.value === </span><span class="s2">''</span><span class="s1">) &amp;&amp; (node.quoteMark || spaceAfterMeaningfulToken)) {</span>
	              <span class="s1">node.insensitive = insensitive</span><span class="s0">;</span>

	              <span class="s0">if </span><span class="s1">(!insensitive || content === </span><span class="s2">&quot;I&quot;</span><span class="s1">) {</span>
	                <span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">_util.ensureObject)(node</span><span class="s0">, </span><span class="s2">'raws'</span><span class="s1">)</span><span class="s0">;</span>
	                <span class="s1">node.raws.insensitiveFlag = content</span><span class="s0">;</span>
	              <span class="s1">}</span>

	              <span class="s1">lastAdded = </span><span class="s2">'insensitive'</span><span class="s0">;</span>

	              <span class="s0">if </span><span class="s1">(spaceBefore) {</span>
	                <span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">_util.ensureObject)(node</span><span class="s0">, </span><span class="s2">'spaces'</span><span class="s0">, </span><span class="s2">'insensitive'</span><span class="s1">)</span><span class="s0">;</span>
	                <span class="s1">node.spaces.insensitive.before = spaceBefore</span><span class="s0">;</span>
	                <span class="s1">spaceBefore = </span><span class="s2">''</span><span class="s0">;</span>
	              <span class="s1">}</span>

	              <span class="s0">if </span><span class="s1">(commentBefore) {</span>
	                <span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">_util.ensureObject)(node</span><span class="s0">, </span><span class="s2">'raws'</span><span class="s0">, </span><span class="s2">'spaces'</span><span class="s0">, </span><span class="s2">'insensitive'</span><span class="s1">)</span><span class="s0">;</span>
	                <span class="s1">node.raws.spaces.insensitive.before = commentBefore</span><span class="s0">;</span>
	                <span class="s1">commentBefore = </span><span class="s2">''</span><span class="s0">;</span>
	              <span class="s1">}</span>
	            <span class="s1">} </span><span class="s0">else if </span><span class="s1">(node.value || node.value === </span><span class="s2">''</span><span class="s1">) {</span>
	              <span class="s1">lastAdded = </span><span class="s2">'value'</span><span class="s0">;</span>
	              <span class="s1">node.value += content</span><span class="s0">;</span>

	              <span class="s0">if </span><span class="s1">(node.raws.value) {</span>
	                <span class="s1">node.raws.value += content</span><span class="s0">;</span>
	              <span class="s1">}</span>
	            <span class="s1">}</span>
	          <span class="s1">}</span>

	          <span class="s1">spaceAfterMeaningfulToken = </span><span class="s0">false;</span>
	          <span class="s0">break;</span>

	        <span class="s0">case </span><span class="s1">tokens.str:</span>
	          <span class="s0">if </span><span class="s1">(!node.attribute || !node.operator) {</span>
	            <span class="s0">return this</span><span class="s1">.error(</span><span class="s2">&quot;Expected an attribute followed by an operator preceding the string.&quot;</span><span class="s0">, </span><span class="s1">{</span>
	              <span class="s1">index: token[_tokenize.FIELDS.START_POS]</span>
	            <span class="s1">})</span><span class="s0">;</span>
	          <span class="s1">}</span>

	          <span class="s0">var </span><span class="s1">_unescapeValue = (</span><span class="s3">0</span><span class="s0">, </span><span class="s1">_attribute.unescapeValue)(content)</span><span class="s0">,</span>
	              <span class="s1">unescaped = _unescapeValue.unescaped</span><span class="s0">,</span>
	              <span class="s1">quoteMark = _unescapeValue.quoteMark</span><span class="s0">;</span>

	          <span class="s1">node.value = unescaped</span><span class="s0">;</span>
	          <span class="s1">node.quoteMark = quoteMark</span><span class="s0">;</span>
	          <span class="s1">lastAdded = </span><span class="s2">'value'</span><span class="s0">;</span>
	          <span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">_util.ensureObject)(node</span><span class="s0">, </span><span class="s2">'raws'</span><span class="s1">)</span><span class="s0">;</span>
	          <span class="s1">node.raws.value = content</span><span class="s0">;</span>
	          <span class="s1">spaceAfterMeaningfulToken = </span><span class="s0">false;</span>
	          <span class="s0">break;</span>

	        <span class="s0">case </span><span class="s1">tokens.equals:</span>
	          <span class="s0">if </span><span class="s1">(!node.attribute) {</span>
	            <span class="s0">return this</span><span class="s1">.expected(</span><span class="s2">'attribute'</span><span class="s0">, </span><span class="s1">token[_tokenize.FIELDS.START_POS]</span><span class="s0">, </span><span class="s1">content)</span><span class="s0">;</span>
	          <span class="s1">}</span>

	          <span class="s0">if </span><span class="s1">(node.value) {</span>
	            <span class="s0">return this</span><span class="s1">.error(</span><span class="s2">'Unexpected &quot;=&quot; found; an operator was already defined.'</span><span class="s0">, </span><span class="s1">{</span>
	              <span class="s1">index: token[_tokenize.FIELDS.START_POS]</span>
	            <span class="s1">})</span><span class="s0">;</span>
	          <span class="s1">}</span>

	          <span class="s1">node.operator = node.operator ? node.operator + content : content</span><span class="s0">;</span>
	          <span class="s1">lastAdded = </span><span class="s2">'operator'</span><span class="s0">;</span>
	          <span class="s1">spaceAfterMeaningfulToken = </span><span class="s0">false;</span>
	          <span class="s0">break;</span>

	        <span class="s0">case </span><span class="s1">tokens.comment:</span>
	          <span class="s0">if </span><span class="s1">(lastAdded) {</span>
	            <span class="s0">if </span><span class="s1">(spaceAfterMeaningfulToken || next &amp;&amp; next[_tokenize.FIELDS.TYPE] === tokens.space || lastAdded === </span><span class="s2">'insensitive'</span><span class="s1">) {</span>
	              <span class="s0">var </span><span class="s1">lastComment = (</span><span class="s3">0</span><span class="s0">, </span><span class="s1">_util.getProp)(node</span><span class="s0">, </span><span class="s2">'spaces'</span><span class="s0">, </span><span class="s1">lastAdded</span><span class="s0">, </span><span class="s2">'after'</span><span class="s1">) || </span><span class="s2">''</span><span class="s0">;</span>
	              <span class="s0">var </span><span class="s1">rawLastComment = (</span><span class="s3">0</span><span class="s0">, </span><span class="s1">_util.getProp)(node</span><span class="s0">, </span><span class="s2">'raws'</span><span class="s0">, </span><span class="s2">'spaces'</span><span class="s0">, </span><span class="s1">lastAdded</span><span class="s0">, </span><span class="s2">'after'</span><span class="s1">) || lastComment</span><span class="s0">;</span>
	              <span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">_util.ensureObject)(node</span><span class="s0">, </span><span class="s2">'raws'</span><span class="s0">, </span><span class="s2">'spaces'</span><span class="s0">, </span><span class="s1">lastAdded)</span><span class="s0">;</span>
	              <span class="s1">node.raws.spaces[lastAdded].after = rawLastComment + content</span><span class="s0">;</span>
	            <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
	              <span class="s0">var </span><span class="s1">lastValue = node[lastAdded] || </span><span class="s2">''</span><span class="s0">;</span>
	              <span class="s0">var </span><span class="s1">rawLastValue = (</span><span class="s3">0</span><span class="s0">, </span><span class="s1">_util.getProp)(node</span><span class="s0">, </span><span class="s2">'raws'</span><span class="s0">, </span><span class="s1">lastAdded) || lastValue</span><span class="s0">;</span>
	              <span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">_util.ensureObject)(node</span><span class="s0">, </span><span class="s2">'raws'</span><span class="s1">)</span><span class="s0">;</span>
	              <span class="s1">node.raws[lastAdded] = rawLastValue + content</span><span class="s0">;</span>
	            <span class="s1">}</span>
	          <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
	            <span class="s1">commentBefore = commentBefore + content</span><span class="s0">;</span>
	          <span class="s1">}</span>

	          <span class="s0">break;</span>

	        <span class="s0">default</span><span class="s1">:</span>
	          <span class="s0">return this</span><span class="s1">.error(</span><span class="s2">&quot;Unexpected </span><span class="s0">\&quot;</span><span class="s2">&quot; </span><span class="s1">+ content + </span><span class="s2">&quot;</span><span class="s0">\&quot; </span><span class="s2">found.&quot;</span><span class="s0">, </span><span class="s1">{</span>
	            <span class="s1">index: token[_tokenize.FIELDS.START_POS]</span>
	          <span class="s1">})</span><span class="s0">;</span>
	      <span class="s1">}</span>

	      <span class="s1">pos++</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s1">unescapeProp(node</span><span class="s0">, </span><span class="s2">&quot;attribute&quot;</span><span class="s1">)</span><span class="s0">;</span>
	    <span class="s1">unescapeProp(node</span><span class="s0">, </span><span class="s2">&quot;namespace&quot;</span><span class="s1">)</span><span class="s0">;</span>
	    <span class="s0">this</span><span class="s1">.newNode(</span><span class="s0">new </span><span class="s1">_attribute[</span><span class="s2">&quot;default&quot;</span><span class="s1">](node))</span><span class="s0">;</span>
	    <span class="s0">this</span><span class="s1">.position++</span><span class="s0">;</span>
	  <span class="s1">}</span>
	  <span class="s5">/**</span>
	   <span class="s5">* return a node containing meaningless garbage up to (but not including) the specified token position.</span>
	   <span class="s5">* if the token position is negative, all remaining tokens are consumed.</span>
	   <span class="s5">*</span>
	   <span class="s5">* This returns an array containing a single string node if all whitespace,</span>
	   <span class="s5">* otherwise an array of comment nodes with space before and after.</span>
	   <span class="s5">*</span>
	   <span class="s5">* These tokens are not added to the current selector, the caller can add them or use them to amend</span>
	   <span class="s5">* a previous node's space metadata.</span>
	   <span class="s5">*</span>
	   <span class="s5">* In lossy mode, this returns only comments.</span>
	   <span class="s5">*/</span>
	  <span class="s0">;</span>

	  <span class="s1">_proto.parseWhitespaceEquivalentTokens = </span><span class="s0">function </span><span class="s1">parseWhitespaceEquivalentTokens(stopPosition) {</span>
	    <span class="s0">if </span><span class="s1">(stopPosition &lt; </span><span class="s3">0</span><span class="s1">) {</span>
	      <span class="s1">stopPosition = </span><span class="s0">this</span><span class="s1">.tokens.length</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">var </span><span class="s1">startPosition = </span><span class="s0">this</span><span class="s1">.position</span><span class="s0">;</span>
	    <span class="s0">var </span><span class="s1">nodes = []</span><span class="s0">;</span>
	    <span class="s0">var </span><span class="s1">space = </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
	    <span class="s0">var </span><span class="s1">lastComment = undefined</span><span class="s0">;</span>

	    <span class="s0">do </span><span class="s1">{</span>
	      <span class="s0">if </span><span class="s1">(WHITESPACE_TOKENS[</span><span class="s0">this</span><span class="s1">.currToken[_tokenize.FIELDS.TYPE]]) {</span>
	        <span class="s0">if </span><span class="s1">(!</span><span class="s0">this</span><span class="s1">.options.lossy) {</span>
	          <span class="s1">space += </span><span class="s0">this</span><span class="s1">.content()</span><span class="s0">;</span>
	        <span class="s1">}</span>
	      <span class="s1">} </span><span class="s0">else if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.currToken[_tokenize.FIELDS.TYPE] === tokens.comment) {</span>
	        <span class="s0">var </span><span class="s1">spaces = {}</span><span class="s0">;</span>

	        <span class="s0">if </span><span class="s1">(space) {</span>
	          <span class="s1">spaces.before = space</span><span class="s0">;</span>
	          <span class="s1">space = </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
	        <span class="s1">}</span>

	        <span class="s1">lastComment = </span><span class="s0">new </span><span class="s1">_comment[</span><span class="s2">&quot;default&quot;</span><span class="s1">]({</span>
	          <span class="s1">value: </span><span class="s0">this</span><span class="s1">.content()</span><span class="s0">,</span>
	          <span class="s1">source: getTokenSource(</span><span class="s0">this</span><span class="s1">.currToken)</span><span class="s0">,</span>
	          <span class="s1">sourceIndex: </span><span class="s0">this</span><span class="s1">.currToken[_tokenize.FIELDS.START_POS]</span><span class="s0">,</span>
	          <span class="s1">spaces: spaces</span>
	        <span class="s1">})</span><span class="s0">;</span>
	        <span class="s1">nodes.push(lastComment)</span><span class="s0">;</span>
	      <span class="s1">}</span>
	    <span class="s1">} </span><span class="s0">while </span><span class="s1">(++</span><span class="s0">this</span><span class="s1">.position &lt; stopPosition)</span><span class="s0">;</span>

	    <span class="s0">if </span><span class="s1">(space) {</span>
	      <span class="s0">if </span><span class="s1">(lastComment) {</span>
	        <span class="s1">lastComment.spaces.after = space</span><span class="s0">;</span>
	      <span class="s1">} </span><span class="s0">else if </span><span class="s1">(!</span><span class="s0">this</span><span class="s1">.options.lossy) {</span>
	        <span class="s0">var </span><span class="s1">firstToken = </span><span class="s0">this</span><span class="s1">.tokens[startPosition]</span><span class="s0">;</span>
	        <span class="s0">var </span><span class="s1">lastToken = </span><span class="s0">this</span><span class="s1">.tokens[</span><span class="s0">this</span><span class="s1">.position - </span><span class="s3">1</span><span class="s1">]</span><span class="s0">;</span>
	        <span class="s1">nodes.push(</span><span class="s0">new </span><span class="s1">_string[</span><span class="s2">&quot;default&quot;</span><span class="s1">]({</span>
	          <span class="s1">value: </span><span class="s2">''</span><span class="s0">,</span>
	          <span class="s1">source: getSource(firstToken[_tokenize.FIELDS.START_LINE]</span><span class="s0">, </span><span class="s1">firstToken[_tokenize.FIELDS.START_COL]</span><span class="s0">, </span><span class="s1">lastToken[_tokenize.FIELDS.END_LINE]</span><span class="s0">, </span><span class="s1">lastToken[_tokenize.FIELDS.END_COL])</span><span class="s0">,</span>
	          <span class="s1">sourceIndex: firstToken[_tokenize.FIELDS.START_POS]</span><span class="s0">,</span>
	          <span class="s1">spaces: {</span>
	            <span class="s1">before: space</span><span class="s0">,</span>
	            <span class="s1">after: </span><span class="s2">''</span>
	          <span class="s1">}</span>
	        <span class="s1">}))</span><span class="s0">;</span>
	      <span class="s1">}</span>
	    <span class="s1">}</span>

	    <span class="s0">return </span><span class="s1">nodes</span><span class="s0">;</span>
	  <span class="s1">}</span>
	  <span class="s5">/**</span>
	   <span class="s5">* </span>
	   <span class="s5">* </span><span class="s6">@param </span><span class="s5">{*} nodes </span>
	   <span class="s5">*/</span>
	  <span class="s0">;</span>

	  <span class="s1">_proto.convertWhitespaceNodesToSpace = </span><span class="s0">function </span><span class="s1">convertWhitespaceNodesToSpace(nodes</span><span class="s0">, </span><span class="s1">requiredSpace) {</span>
	    <span class="s0">var </span><span class="s1">_this2 = </span><span class="s0">this;</span>

	    <span class="s0">if </span><span class="s1">(requiredSpace === </span><span class="s0">void </span><span class="s3">0</span><span class="s1">) {</span>
	      <span class="s1">requiredSpace = </span><span class="s0">false;</span>
	    <span class="s1">}</span>

	    <span class="s0">var </span><span class="s1">space = </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
	    <span class="s0">var </span><span class="s1">rawSpace = </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
	    <span class="s1">nodes.forEach(</span><span class="s0">function </span><span class="s1">(n) {</span>
	      <span class="s0">var </span><span class="s1">spaceBefore = _this2.lossySpace(n.spaces.before</span><span class="s0">, </span><span class="s1">requiredSpace)</span><span class="s0">;</span>

	      <span class="s0">var </span><span class="s1">rawSpaceBefore = _this2.lossySpace(n.rawSpaceBefore</span><span class="s0">, </span><span class="s1">requiredSpace)</span><span class="s0">;</span>

	      <span class="s1">space += spaceBefore + _this2.lossySpace(n.spaces.after</span><span class="s0">, </span><span class="s1">requiredSpace &amp;&amp; spaceBefore.length === </span><span class="s3">0</span><span class="s1">)</span><span class="s0">;</span>
	      <span class="s1">rawSpace += spaceBefore + n.value + _this2.lossySpace(n.rawSpaceAfter</span><span class="s0">, </span><span class="s1">requiredSpace &amp;&amp; rawSpaceBefore.length === </span><span class="s3">0</span><span class="s1">)</span><span class="s0">;</span>
	    <span class="s1">})</span><span class="s0">;</span>

	    <span class="s0">if </span><span class="s1">(rawSpace === space) {</span>
	      <span class="s1">rawSpace = undefined</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">var </span><span class="s1">result = {</span>
	      <span class="s1">space: space</span><span class="s0">,</span>
	      <span class="s1">rawSpace: rawSpace</span>
	    <span class="s1">}</span><span class="s0">;</span>
	    <span class="s0">return </span><span class="s1">result</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.isNamedCombinator = </span><span class="s0">function </span><span class="s1">isNamedCombinator(position) {</span>
	    <span class="s0">if </span><span class="s1">(position === </span><span class="s0">void </span><span class="s3">0</span><span class="s1">) {</span>
	      <span class="s1">position = </span><span class="s0">this</span><span class="s1">.position</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">return this</span><span class="s1">.tokens[position + </span><span class="s3">0</span><span class="s1">] &amp;&amp; </span><span class="s0">this</span><span class="s1">.tokens[position + </span><span class="s3">0</span><span class="s1">][_tokenize.FIELDS.TYPE] === tokens.slash &amp;&amp; </span><span class="s0">this</span><span class="s1">.tokens[position + </span><span class="s3">1</span><span class="s1">] &amp;&amp; </span><span class="s0">this</span><span class="s1">.tokens[position + </span><span class="s3">1</span><span class="s1">][_tokenize.FIELDS.TYPE] === tokens.word &amp;&amp; </span><span class="s0">this</span><span class="s1">.tokens[position + </span><span class="s3">2</span><span class="s1">] &amp;&amp; </span><span class="s0">this</span><span class="s1">.tokens[position + </span><span class="s3">2</span><span class="s1">][_tokenize.FIELDS.TYPE] === tokens.slash</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.namedCombinator = </span><span class="s0">function </span><span class="s1">namedCombinator() {</span>
	    <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.isNamedCombinator()) {</span>
	      <span class="s0">var </span><span class="s1">nameRaw = </span><span class="s0">this</span><span class="s1">.content(</span><span class="s0">this</span><span class="s1">.tokens[</span><span class="s0">this</span><span class="s1">.position + </span><span class="s3">1</span><span class="s1">])</span><span class="s0">;</span>
	      <span class="s0">var </span><span class="s1">name = (</span><span class="s3">0</span><span class="s0">, </span><span class="s1">_util.unesc)(nameRaw).toLowerCase()</span><span class="s0">;</span>
	      <span class="s0">var </span><span class="s1">raws = {}</span><span class="s0">;</span>

	      <span class="s0">if </span><span class="s1">(name !== nameRaw) {</span>
	        <span class="s1">raws.value = </span><span class="s2">&quot;/&quot; </span><span class="s1">+ nameRaw + </span><span class="s2">&quot;/&quot;</span><span class="s0">;</span>
	      <span class="s1">}</span>

	      <span class="s0">var </span><span class="s1">node = </span><span class="s0">new </span><span class="s1">_combinator[</span><span class="s2">&quot;default&quot;</span><span class="s1">]({</span>
	        <span class="s1">value: </span><span class="s2">&quot;/&quot; </span><span class="s1">+ name + </span><span class="s2">&quot;/&quot;</span><span class="s0">,</span>
	        <span class="s1">source: getSource(</span><span class="s0">this</span><span class="s1">.currToken[_tokenize.FIELDS.START_LINE]</span><span class="s0">, this</span><span class="s1">.currToken[_tokenize.FIELDS.START_COL]</span><span class="s0">, this</span><span class="s1">.tokens[</span><span class="s0">this</span><span class="s1">.position + </span><span class="s3">2</span><span class="s1">][_tokenize.FIELDS.END_LINE]</span><span class="s0">, this</span><span class="s1">.tokens[</span><span class="s0">this</span><span class="s1">.position + </span><span class="s3">2</span><span class="s1">][_tokenize.FIELDS.END_COL])</span><span class="s0">,</span>
	        <span class="s1">sourceIndex: </span><span class="s0">this</span><span class="s1">.currToken[_tokenize.FIELDS.START_POS]</span><span class="s0">,</span>
	        <span class="s1">raws: raws</span>
	      <span class="s1">})</span><span class="s0">;</span>
	      <span class="s0">this</span><span class="s1">.position = </span><span class="s0">this</span><span class="s1">.position + </span><span class="s3">3</span><span class="s0">;</span>
	      <span class="s0">return </span><span class="s1">node</span><span class="s0">;</span>
	    <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
	      <span class="s0">this</span><span class="s1">.unexpected()</span><span class="s0">;</span>
	    <span class="s1">}</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.combinator = </span><span class="s0">function </span><span class="s1">combinator() {</span>
	    <span class="s0">var </span><span class="s1">_this3 = </span><span class="s0">this;</span>

	    <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.content() === </span><span class="s2">'|'</span><span class="s1">) {</span>
	      <span class="s0">return this</span><span class="s1">.namespace()</span><span class="s0">;</span>
	    <span class="s1">} </span><span class="s4">// We need to decide between a space that's a descendant combinator and meaningless whitespace at the end of a selector.</span>


	    <span class="s0">var </span><span class="s1">nextSigTokenPos = </span><span class="s0">this</span><span class="s1">.locateNextMeaningfulToken(</span><span class="s0">this</span><span class="s1">.position)</span><span class="s0">;</span>

	    <span class="s0">if </span><span class="s1">(nextSigTokenPos &lt; </span><span class="s3">0 </span><span class="s1">|| </span><span class="s0">this</span><span class="s1">.tokens[nextSigTokenPos][_tokenize.FIELDS.TYPE] === tokens.comma) {</span>
	      <span class="s0">var </span><span class="s1">nodes = </span><span class="s0">this</span><span class="s1">.parseWhitespaceEquivalentTokens(nextSigTokenPos)</span><span class="s0">;</span>

	      <span class="s0">if </span><span class="s1">(nodes.length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
	        <span class="s0">var </span><span class="s1">last = </span><span class="s0">this</span><span class="s1">.current.last</span><span class="s0">;</span>

	        <span class="s0">if </span><span class="s1">(last) {</span>
	          <span class="s0">var </span><span class="s1">_this$convertWhitespa = </span><span class="s0">this</span><span class="s1">.convertWhitespaceNodesToSpace(nodes)</span><span class="s0">,</span>
	              <span class="s1">space = _this$convertWhitespa.space</span><span class="s0">,</span>
	              <span class="s1">rawSpace = _this$convertWhitespa.rawSpace</span><span class="s0">;</span>

	          <span class="s0">if </span><span class="s1">(rawSpace !== undefined) {</span>
	            <span class="s1">last.rawSpaceAfter += rawSpace</span><span class="s0">;</span>
	          <span class="s1">}</span>

	          <span class="s1">last.spaces.after += space</span><span class="s0">;</span>
	        <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
	          <span class="s1">nodes.forEach(</span><span class="s0">function </span><span class="s1">(n) {</span>
	            <span class="s0">return </span><span class="s1">_this3.newNode(n)</span><span class="s0">;</span>
	          <span class="s1">})</span><span class="s0">;</span>
	        <span class="s1">}</span>
	      <span class="s1">}</span>

	      <span class="s0">return;</span>
	    <span class="s1">}</span>

	    <span class="s0">var </span><span class="s1">firstToken = </span><span class="s0">this</span><span class="s1">.currToken</span><span class="s0">;</span>
	    <span class="s0">var </span><span class="s1">spaceOrDescendantSelectorNodes = undefined</span><span class="s0">;</span>

	    <span class="s0">if </span><span class="s1">(nextSigTokenPos &gt; </span><span class="s0">this</span><span class="s1">.position) {</span>
	      <span class="s1">spaceOrDescendantSelectorNodes = </span><span class="s0">this</span><span class="s1">.parseWhitespaceEquivalentTokens(nextSigTokenPos)</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">var </span><span class="s1">node</span><span class="s0">;</span>

	    <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.isNamedCombinator()) {</span>
	      <span class="s1">node = </span><span class="s0">this</span><span class="s1">.namedCombinator()</span><span class="s0">;</span>
	    <span class="s1">} </span><span class="s0">else if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.currToken[_tokenize.FIELDS.TYPE] === tokens.combinator) {</span>
	      <span class="s1">node = </span><span class="s0">new </span><span class="s1">_combinator[</span><span class="s2">&quot;default&quot;</span><span class="s1">]({</span>
	        <span class="s1">value: </span><span class="s0">this</span><span class="s1">.content()</span><span class="s0">,</span>
	        <span class="s1">source: getTokenSource(</span><span class="s0">this</span><span class="s1">.currToken)</span><span class="s0">,</span>
	        <span class="s1">sourceIndex: </span><span class="s0">this</span><span class="s1">.currToken[_tokenize.FIELDS.START_POS]</span>
	      <span class="s1">})</span><span class="s0">;</span>
	      <span class="s0">this</span><span class="s1">.position++</span><span class="s0">;</span>
	    <span class="s1">} </span><span class="s0">else if </span><span class="s1">(WHITESPACE_TOKENS[</span><span class="s0">this</span><span class="s1">.currToken[_tokenize.FIELDS.TYPE]]) </span><span class="s0">; else if </span><span class="s1">(!spaceOrDescendantSelectorNodes) {</span>
	      <span class="s0">this</span><span class="s1">.unexpected()</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">if </span><span class="s1">(node) {</span>
	      <span class="s0">if </span><span class="s1">(spaceOrDescendantSelectorNodes) {</span>
	        <span class="s0">var </span><span class="s1">_this$convertWhitespa2 = </span><span class="s0">this</span><span class="s1">.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes)</span><span class="s0">,</span>
	            <span class="s1">_space = _this$convertWhitespa2.space</span><span class="s0">,</span>
	            <span class="s1">_rawSpace = _this$convertWhitespa2.rawSpace</span><span class="s0">;</span>

	        <span class="s1">node.spaces.before = _space</span><span class="s0">;</span>
	        <span class="s1">node.rawSpaceBefore = _rawSpace</span><span class="s0">;</span>
	      <span class="s1">}</span>
	    <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
	      <span class="s4">// descendant combinator</span>
	      <span class="s0">var </span><span class="s1">_this$convertWhitespa3 = </span><span class="s0">this</span><span class="s1">.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes</span><span class="s0">, true</span><span class="s1">)</span><span class="s0">,</span>
	          <span class="s1">_space2 = _this$convertWhitespa3.space</span><span class="s0">,</span>
	          <span class="s1">_rawSpace2 = _this$convertWhitespa3.rawSpace</span><span class="s0">;</span>

	      <span class="s0">if </span><span class="s1">(!_rawSpace2) {</span>
	        <span class="s1">_rawSpace2 = _space2</span><span class="s0">;</span>
	      <span class="s1">}</span>

	      <span class="s0">var </span><span class="s1">spaces = {}</span><span class="s0">;</span>
	      <span class="s0">var </span><span class="s1">raws = {</span>
	        <span class="s1">spaces: {}</span>
	      <span class="s1">}</span><span class="s0">;</span>

	      <span class="s0">if </span><span class="s1">(_space2.endsWith(</span><span class="s2">' '</span><span class="s1">) &amp;&amp; _rawSpace2.endsWith(</span><span class="s2">' '</span><span class="s1">)) {</span>
	        <span class="s1">spaces.before = _space2.slice(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">_space2.length - </span><span class="s3">1</span><span class="s1">)</span><span class="s0">;</span>
	        <span class="s1">raws.spaces.before = _rawSpace2.slice(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">_rawSpace2.length - </span><span class="s3">1</span><span class="s1">)</span><span class="s0">;</span>
	      <span class="s1">} </span><span class="s0">else if </span><span class="s1">(_space2.startsWith(</span><span class="s2">' '</span><span class="s1">) &amp;&amp; _rawSpace2.startsWith(</span><span class="s2">' '</span><span class="s1">)) {</span>
	        <span class="s1">spaces.after = _space2.slice(</span><span class="s3">1</span><span class="s1">)</span><span class="s0">;</span>
	        <span class="s1">raws.spaces.after = _rawSpace2.slice(</span><span class="s3">1</span><span class="s1">)</span><span class="s0">;</span>
	      <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
	        <span class="s1">raws.value = _rawSpace2</span><span class="s0">;</span>
	      <span class="s1">}</span>

	      <span class="s1">node = </span><span class="s0">new </span><span class="s1">_combinator[</span><span class="s2">&quot;default&quot;</span><span class="s1">]({</span>
	        <span class="s1">value: </span><span class="s2">' '</span><span class="s0">,</span>
	        <span class="s1">source: getTokenSourceSpan(firstToken</span><span class="s0">, this</span><span class="s1">.tokens[</span><span class="s0">this</span><span class="s1">.position - </span><span class="s3">1</span><span class="s1">])</span><span class="s0">,</span>
	        <span class="s1">sourceIndex: firstToken[_tokenize.FIELDS.START_POS]</span><span class="s0">,</span>
	        <span class="s1">spaces: spaces</span><span class="s0">,</span>
	        <span class="s1">raws: raws</span>
	      <span class="s1">})</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.currToken &amp;&amp; </span><span class="s0">this</span><span class="s1">.currToken[_tokenize.FIELDS.TYPE] === tokens.space) {</span>
	      <span class="s1">node.spaces.after = </span><span class="s0">this</span><span class="s1">.optionalSpace(</span><span class="s0">this</span><span class="s1">.content())</span><span class="s0">;</span>
	      <span class="s0">this</span><span class="s1">.position++</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">return this</span><span class="s1">.newNode(node)</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.comma = </span><span class="s0">function </span><span class="s1">comma() {</span>
	    <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.position === </span><span class="s0">this</span><span class="s1">.tokens.length - </span><span class="s3">1</span><span class="s1">) {</span>
	      <span class="s0">this</span><span class="s1">.root.trailingComma = </span><span class="s0">true;</span>
	      <span class="s0">this</span><span class="s1">.position++</span><span class="s0">;</span>
	      <span class="s0">return;</span>
	    <span class="s1">}</span>

	    <span class="s0">this</span><span class="s1">.current._inferEndPosition()</span><span class="s0">;</span>

	    <span class="s0">var </span><span class="s1">selector = </span><span class="s0">new </span><span class="s1">_selector[</span><span class="s2">&quot;default&quot;</span><span class="s1">]({</span>
	      <span class="s1">source: {</span>
	        <span class="s1">start: tokenStart(</span><span class="s0">this</span><span class="s1">.tokens[</span><span class="s0">this</span><span class="s1">.position + </span><span class="s3">1</span><span class="s1">])</span>
	      <span class="s1">}</span>
	    <span class="s1">})</span><span class="s0">;</span>
	    <span class="s0">this</span><span class="s1">.current.parent.append(selector)</span><span class="s0">;</span>
	    <span class="s0">this</span><span class="s1">.current = selector</span><span class="s0">;</span>
	    <span class="s0">this</span><span class="s1">.position++</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.comment = </span><span class="s0">function </span><span class="s1">comment() {</span>
	    <span class="s0">var </span><span class="s1">current = </span><span class="s0">this</span><span class="s1">.currToken</span><span class="s0">;</span>
	    <span class="s0">this</span><span class="s1">.newNode(</span><span class="s0">new </span><span class="s1">_comment[</span><span class="s2">&quot;default&quot;</span><span class="s1">]({</span>
	      <span class="s1">value: </span><span class="s0">this</span><span class="s1">.content()</span><span class="s0">,</span>
	      <span class="s1">source: getTokenSource(current)</span><span class="s0">,</span>
	      <span class="s1">sourceIndex: current[_tokenize.FIELDS.START_POS]</span>
	    <span class="s1">}))</span><span class="s0">;</span>
	    <span class="s0">this</span><span class="s1">.position++</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.error = </span><span class="s0">function </span><span class="s1">error(message</span><span class="s0">, </span><span class="s1">opts) {</span>
	    <span class="s0">throw this</span><span class="s1">.root.error(message</span><span class="s0">, </span><span class="s1">opts)</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.missingBackslash = </span><span class="s0">function </span><span class="s1">missingBackslash() {</span>
	    <span class="s0">return this</span><span class="s1">.error(</span><span class="s2">'Expected a backslash preceding the semicolon.'</span><span class="s0">, </span><span class="s1">{</span>
	      <span class="s1">index: </span><span class="s0">this</span><span class="s1">.currToken[_tokenize.FIELDS.START_POS]</span>
	    <span class="s1">})</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.missingParenthesis = </span><span class="s0">function </span><span class="s1">missingParenthesis() {</span>
	    <span class="s0">return this</span><span class="s1">.expected(</span><span class="s2">'opening parenthesis'</span><span class="s0">, this</span><span class="s1">.currToken[_tokenize.FIELDS.START_POS])</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.missingSquareBracket = </span><span class="s0">function </span><span class="s1">missingSquareBracket() {</span>
	    <span class="s0">return this</span><span class="s1">.expected(</span><span class="s2">'opening square bracket'</span><span class="s0">, this</span><span class="s1">.currToken[_tokenize.FIELDS.START_POS])</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.unexpected = </span><span class="s0">function </span><span class="s1">unexpected() {</span>
	    <span class="s0">return this</span><span class="s1">.error(</span><span class="s2">&quot;Unexpected '&quot; </span><span class="s1">+ </span><span class="s0">this</span><span class="s1">.content() + </span><span class="s2">&quot;'. Escaping special characters with </span><span class="s0">\\ </span><span class="s2">may help.&quot;</span><span class="s0">, this</span><span class="s1">.currToken[_tokenize.FIELDS.START_POS])</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.namespace = </span><span class="s0">function </span><span class="s1">namespace() {</span>
	    <span class="s0">var </span><span class="s1">before = </span><span class="s0">this</span><span class="s1">.prevToken &amp;&amp; </span><span class="s0">this</span><span class="s1">.content(</span><span class="s0">this</span><span class="s1">.prevToken) || </span><span class="s0">true;</span>

	    <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.nextToken[_tokenize.FIELDS.TYPE] === tokens.word) {</span>
	      <span class="s0">this</span><span class="s1">.position++</span><span class="s0">;</span>
	      <span class="s0">return this</span><span class="s1">.word(before)</span><span class="s0">;</span>
	    <span class="s1">} </span><span class="s0">else if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.nextToken[_tokenize.FIELDS.TYPE] === tokens.asterisk) {</span>
	      <span class="s0">this</span><span class="s1">.position++</span><span class="s0">;</span>
	      <span class="s0">return this</span><span class="s1">.universal(before)</span><span class="s0">;</span>
	    <span class="s1">}</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.nesting = </span><span class="s0">function </span><span class="s1">nesting() {</span>
	    <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.nextToken) {</span>
	      <span class="s0">var </span><span class="s1">nextContent = </span><span class="s0">this</span><span class="s1">.content(</span><span class="s0">this</span><span class="s1">.nextToken)</span><span class="s0">;</span>

	      <span class="s0">if </span><span class="s1">(nextContent === </span><span class="s2">&quot;|&quot;</span><span class="s1">) {</span>
	        <span class="s0">this</span><span class="s1">.position++</span><span class="s0">;</span>
	        <span class="s0">return;</span>
	      <span class="s1">}</span>
	    <span class="s1">}</span>

	    <span class="s0">var </span><span class="s1">current = </span><span class="s0">this</span><span class="s1">.currToken</span><span class="s0">;</span>
	    <span class="s0">this</span><span class="s1">.newNode(</span><span class="s0">new </span><span class="s1">_nesting[</span><span class="s2">&quot;default&quot;</span><span class="s1">]({</span>
	      <span class="s1">value: </span><span class="s0">this</span><span class="s1">.content()</span><span class="s0">,</span>
	      <span class="s1">source: getTokenSource(current)</span><span class="s0">,</span>
	      <span class="s1">sourceIndex: current[_tokenize.FIELDS.START_POS]</span>
	    <span class="s1">}))</span><span class="s0">;</span>
	    <span class="s0">this</span><span class="s1">.position++</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.parentheses = </span><span class="s0">function </span><span class="s1">parentheses() {</span>
	    <span class="s0">var </span><span class="s1">last = </span><span class="s0">this</span><span class="s1">.current.last</span><span class="s0">;</span>
	    <span class="s0">var </span><span class="s1">unbalanced = </span><span class="s3">1</span><span class="s0">;</span>
	    <span class="s0">this</span><span class="s1">.position++</span><span class="s0">;</span>

	    <span class="s0">if </span><span class="s1">(last &amp;&amp; last.type === types$1.PSEUDO) {</span>
	      <span class="s0">var </span><span class="s1">selector = </span><span class="s0">new </span><span class="s1">_selector[</span><span class="s2">&quot;default&quot;</span><span class="s1">]({</span>
	        <span class="s1">source: {</span>
	          <span class="s1">start: tokenStart(</span><span class="s0">this</span><span class="s1">.tokens[</span><span class="s0">this</span><span class="s1">.position - </span><span class="s3">1</span><span class="s1">])</span>
	        <span class="s1">}</span>
	      <span class="s1">})</span><span class="s0">;</span>
	      <span class="s0">var </span><span class="s1">cache = </span><span class="s0">this</span><span class="s1">.current</span><span class="s0">;</span>
	      <span class="s1">last.append(selector)</span><span class="s0">;</span>
	      <span class="s0">this</span><span class="s1">.current = selector</span><span class="s0">;</span>

	      <span class="s0">while </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.position &lt; </span><span class="s0">this</span><span class="s1">.tokens.length &amp;&amp; unbalanced) {</span>
	        <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {</span>
	          <span class="s1">unbalanced++</span><span class="s0">;</span>
	        <span class="s1">}</span>

	        <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {</span>
	          <span class="s1">unbalanced--</span><span class="s0">;</span>
	        <span class="s1">}</span>

	        <span class="s0">if </span><span class="s1">(unbalanced) {</span>
	          <span class="s0">this</span><span class="s1">.parse()</span><span class="s0">;</span>
	        <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
	          <span class="s0">this</span><span class="s1">.current.source.end = tokenEnd(</span><span class="s0">this</span><span class="s1">.currToken)</span><span class="s0">;</span>
	          <span class="s0">this</span><span class="s1">.current.parent.source.end = tokenEnd(</span><span class="s0">this</span><span class="s1">.currToken)</span><span class="s0">;</span>
	          <span class="s0">this</span><span class="s1">.position++</span><span class="s0">;</span>
	        <span class="s1">}</span>
	      <span class="s1">}</span>

	      <span class="s0">this</span><span class="s1">.current = cache</span><span class="s0">;</span>
	    <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
	      <span class="s4">// I think this case should be an error. It's used to implement a basic parse of media queries</span>
	      <span class="s4">// but I don't think it's a good idea.</span>
	      <span class="s0">var </span><span class="s1">parenStart = </span><span class="s0">this</span><span class="s1">.currToken</span><span class="s0">;</span>
	      <span class="s0">var </span><span class="s1">parenValue = </span><span class="s2">&quot;(&quot;</span><span class="s0">;</span>
	      <span class="s0">var </span><span class="s1">parenEnd</span><span class="s0">;</span>

	      <span class="s0">while </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.position &lt; </span><span class="s0">this</span><span class="s1">.tokens.length &amp;&amp; unbalanced) {</span>
	        <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {</span>
	          <span class="s1">unbalanced++</span><span class="s0">;</span>
	        <span class="s1">}</span>

	        <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {</span>
	          <span class="s1">unbalanced--</span><span class="s0">;</span>
	        <span class="s1">}</span>

	        <span class="s1">parenEnd = </span><span class="s0">this</span><span class="s1">.currToken</span><span class="s0">;</span>
	        <span class="s1">parenValue += </span><span class="s0">this</span><span class="s1">.parseParenthesisToken(</span><span class="s0">this</span><span class="s1">.currToken)</span><span class="s0">;</span>
	        <span class="s0">this</span><span class="s1">.position++</span><span class="s0">;</span>
	      <span class="s1">}</span>

	      <span class="s0">if </span><span class="s1">(last) {</span>
	        <span class="s1">last.appendToPropertyAndEscape(</span><span class="s2">&quot;value&quot;</span><span class="s0">, </span><span class="s1">parenValue</span><span class="s0">, </span><span class="s1">parenValue)</span><span class="s0">;</span>
	      <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
	        <span class="s0">this</span><span class="s1">.newNode(</span><span class="s0">new </span><span class="s1">_string[</span><span class="s2">&quot;default&quot;</span><span class="s1">]({</span>
	          <span class="s1">value: parenValue</span><span class="s0">,</span>
	          <span class="s1">source: getSource(parenStart[_tokenize.FIELDS.START_LINE]</span><span class="s0">, </span><span class="s1">parenStart[_tokenize.FIELDS.START_COL]</span><span class="s0">, </span><span class="s1">parenEnd[_tokenize.FIELDS.END_LINE]</span><span class="s0">, </span><span class="s1">parenEnd[_tokenize.FIELDS.END_COL])</span><span class="s0">,</span>
	          <span class="s1">sourceIndex: parenStart[_tokenize.FIELDS.START_POS]</span>
	        <span class="s1">}))</span><span class="s0">;</span>
	      <span class="s1">}</span>
	    <span class="s1">}</span>

	    <span class="s0">if </span><span class="s1">(unbalanced) {</span>
	      <span class="s0">return this</span><span class="s1">.expected(</span><span class="s2">'closing parenthesis'</span><span class="s0">, this</span><span class="s1">.currToken[_tokenize.FIELDS.START_POS])</span><span class="s0">;</span>
	    <span class="s1">}</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.pseudo = </span><span class="s0">function </span><span class="s1">pseudo() {</span>
	    <span class="s0">var </span><span class="s1">_this4 = </span><span class="s0">this;</span>

	    <span class="s0">var </span><span class="s1">pseudoStr = </span><span class="s2">''</span><span class="s0">;</span>
	    <span class="s0">var </span><span class="s1">startingToken = </span><span class="s0">this</span><span class="s1">.currToken</span><span class="s0">;</span>

	    <span class="s0">while </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.currToken &amp;&amp; </span><span class="s0">this</span><span class="s1">.currToken[_tokenize.FIELDS.TYPE] === tokens.colon) {</span>
	      <span class="s1">pseudoStr += </span><span class="s0">this</span><span class="s1">.content()</span><span class="s0">;</span>
	      <span class="s0">this</span><span class="s1">.position++</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">if </span><span class="s1">(!</span><span class="s0">this</span><span class="s1">.currToken) {</span>
	      <span class="s0">return this</span><span class="s1">.expected([</span><span class="s2">'pseudo-class'</span><span class="s0">, </span><span class="s2">'pseudo-element'</span><span class="s1">]</span><span class="s0">, this</span><span class="s1">.position - </span><span class="s3">1</span><span class="s1">)</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.currToken[_tokenize.FIELDS.TYPE] === tokens.word) {</span>
	      <span class="s0">this</span><span class="s1">.splitWord(</span><span class="s0">false, function </span><span class="s1">(first</span><span class="s0">, </span><span class="s1">length) {</span>
	        <span class="s1">pseudoStr += first</span><span class="s0">;</span>

	        <span class="s1">_this4.newNode(</span><span class="s0">new </span><span class="s1">_pseudo[</span><span class="s2">&quot;default&quot;</span><span class="s1">]({</span>
	          <span class="s1">value: pseudoStr</span><span class="s0">,</span>
	          <span class="s1">source: getTokenSourceSpan(startingToken</span><span class="s0">, </span><span class="s1">_this4.currToken)</span><span class="s0">,</span>
	          <span class="s1">sourceIndex: startingToken[_tokenize.FIELDS.START_POS]</span>
	        <span class="s1">}))</span><span class="s0">;</span>

	        <span class="s0">if </span><span class="s1">(length &gt; </span><span class="s3">1 </span><span class="s1">&amp;&amp; _this4.nextToken &amp;&amp; _this4.nextToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {</span>
	          <span class="s1">_this4.error(</span><span class="s2">'Misplaced parenthesis.'</span><span class="s0">, </span><span class="s1">{</span>
	            <span class="s1">index: _this4.nextToken[_tokenize.FIELDS.START_POS]</span>
	          <span class="s1">})</span><span class="s0">;</span>
	        <span class="s1">}</span>
	      <span class="s1">})</span><span class="s0">;</span>
	    <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
	      <span class="s0">return this</span><span class="s1">.expected([</span><span class="s2">'pseudo-class'</span><span class="s0">, </span><span class="s2">'pseudo-element'</span><span class="s1">]</span><span class="s0">, this</span><span class="s1">.currToken[_tokenize.FIELDS.START_POS])</span><span class="s0">;</span>
	    <span class="s1">}</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.space = </span><span class="s0">function </span><span class="s1">space() {</span>
	    <span class="s0">var </span><span class="s1">content = </span><span class="s0">this</span><span class="s1">.content()</span><span class="s0">; </span><span class="s4">// Handle space before and after the selector</span>

	    <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.position === </span><span class="s3">0 </span><span class="s1">|| </span><span class="s0">this</span><span class="s1">.prevToken[_tokenize.FIELDS.TYPE] === tokens.comma || </span><span class="s0">this</span><span class="s1">.prevToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis || </span><span class="s0">this</span><span class="s1">.current.nodes.every(</span><span class="s0">function </span><span class="s1">(node) {</span>
	      <span class="s0">return </span><span class="s1">node.type === </span><span class="s2">'comment'</span><span class="s0">;</span>
	    <span class="s1">})) {</span>
	      <span class="s0">this</span><span class="s1">.spaces = </span><span class="s0">this</span><span class="s1">.optionalSpace(content)</span><span class="s0">;</span>
	      <span class="s0">this</span><span class="s1">.position++</span><span class="s0">;</span>
	    <span class="s1">} </span><span class="s0">else if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.position === </span><span class="s0">this</span><span class="s1">.tokens.length - </span><span class="s3">1 </span><span class="s1">|| </span><span class="s0">this</span><span class="s1">.nextToken[_tokenize.FIELDS.TYPE] === tokens.comma || </span><span class="s0">this</span><span class="s1">.nextToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {</span>
	      <span class="s0">this</span><span class="s1">.current.last.spaces.after = </span><span class="s0">this</span><span class="s1">.optionalSpace(content)</span><span class="s0">;</span>
	      <span class="s0">this</span><span class="s1">.position++</span><span class="s0">;</span>
	    <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
	      <span class="s0">this</span><span class="s1">.combinator()</span><span class="s0">;</span>
	    <span class="s1">}</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.string = </span><span class="s0">function </span><span class="s1">string() {</span>
	    <span class="s0">var </span><span class="s1">current = </span><span class="s0">this</span><span class="s1">.currToken</span><span class="s0">;</span>
	    <span class="s0">this</span><span class="s1">.newNode(</span><span class="s0">new </span><span class="s1">_string[</span><span class="s2">&quot;default&quot;</span><span class="s1">]({</span>
	      <span class="s1">value: </span><span class="s0">this</span><span class="s1">.content()</span><span class="s0">,</span>
	      <span class="s1">source: getTokenSource(current)</span><span class="s0">,</span>
	      <span class="s1">sourceIndex: current[_tokenize.FIELDS.START_POS]</span>
	    <span class="s1">}))</span><span class="s0">;</span>
	    <span class="s0">this</span><span class="s1">.position++</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.universal = </span><span class="s0">function </span><span class="s1">universal(namespace) {</span>
	    <span class="s0">var </span><span class="s1">nextToken = </span><span class="s0">this</span><span class="s1">.nextToken</span><span class="s0">;</span>

	    <span class="s0">if </span><span class="s1">(nextToken &amp;&amp; </span><span class="s0">this</span><span class="s1">.content(nextToken) === </span><span class="s2">'|'</span><span class="s1">) {</span>
	      <span class="s0">this</span><span class="s1">.position++</span><span class="s0">;</span>
	      <span class="s0">return this</span><span class="s1">.namespace()</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">var </span><span class="s1">current = </span><span class="s0">this</span><span class="s1">.currToken</span><span class="s0">;</span>
	    <span class="s0">this</span><span class="s1">.newNode(</span><span class="s0">new </span><span class="s1">_universal[</span><span class="s2">&quot;default&quot;</span><span class="s1">]({</span>
	      <span class="s1">value: </span><span class="s0">this</span><span class="s1">.content()</span><span class="s0">,</span>
	      <span class="s1">source: getTokenSource(current)</span><span class="s0">,</span>
	      <span class="s1">sourceIndex: current[_tokenize.FIELDS.START_POS]</span>
	    <span class="s1">})</span><span class="s0">, </span><span class="s1">namespace)</span><span class="s0">;</span>
	    <span class="s0">this</span><span class="s1">.position++</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.splitWord = </span><span class="s0">function </span><span class="s1">splitWord(namespace</span><span class="s0">, </span><span class="s1">firstCallback) {</span>
	    <span class="s0">var </span><span class="s1">_this5 = </span><span class="s0">this;</span>

	    <span class="s0">var </span><span class="s1">nextToken = </span><span class="s0">this</span><span class="s1">.nextToken</span><span class="s0">;</span>
	    <span class="s0">var </span><span class="s1">word = </span><span class="s0">this</span><span class="s1">.content()</span><span class="s0">;</span>

	    <span class="s0">while </span><span class="s1">(nextToken &amp;&amp; ~[tokens.dollar</span><span class="s0">, </span><span class="s1">tokens.caret</span><span class="s0">, </span><span class="s1">tokens.equals</span><span class="s0">, </span><span class="s1">tokens.word].indexOf(nextToken[_tokenize.FIELDS.TYPE])) {</span>
	      <span class="s0">this</span><span class="s1">.position++</span><span class="s0">;</span>
	      <span class="s0">var </span><span class="s1">current = </span><span class="s0">this</span><span class="s1">.content()</span><span class="s0">;</span>
	      <span class="s1">word += current</span><span class="s0">;</span>

	      <span class="s0">if </span><span class="s1">(current.lastIndexOf(</span><span class="s2">'</span><span class="s0">\\</span><span class="s2">'</span><span class="s1">) === current.length - </span><span class="s3">1</span><span class="s1">) {</span>
	        <span class="s0">var </span><span class="s1">next = </span><span class="s0">this</span><span class="s1">.nextToken</span><span class="s0">;</span>

	        <span class="s0">if </span><span class="s1">(next &amp;&amp; next[_tokenize.FIELDS.TYPE] === tokens.space) {</span>
	          <span class="s1">word += </span><span class="s0">this</span><span class="s1">.requiredSpace(</span><span class="s0">this</span><span class="s1">.content(next))</span><span class="s0">;</span>
	          <span class="s0">this</span><span class="s1">.position++</span><span class="s0">;</span>
	        <span class="s1">}</span>
	      <span class="s1">}</span>

	      <span class="s1">nextToken = </span><span class="s0">this</span><span class="s1">.nextToken</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">var </span><span class="s1">hasClass = indexesOf(word</span><span class="s0">, </span><span class="s2">'.'</span><span class="s1">).filter(</span><span class="s0">function </span><span class="s1">(i) {</span>
	      <span class="s4">// Allow escaped dot within class name</span>
	      <span class="s0">var </span><span class="s1">escapedDot = word[i - </span><span class="s3">1</span><span class="s1">] === </span><span class="s2">'</span><span class="s0">\\</span><span class="s2">'</span><span class="s0">; </span><span class="s4">// Allow decimal numbers percent in @keyframes</span>

	      <span class="s0">var </span><span class="s1">isKeyframesPercent = </span><span class="s3">/^\d+\.\d+%$/</span><span class="s1">.test(word)</span><span class="s0">;</span>
	      <span class="s0">return </span><span class="s1">!escapedDot &amp;&amp; !isKeyframesPercent</span><span class="s0">;</span>
	    <span class="s1">})</span><span class="s0">;</span>
	    <span class="s0">var </span><span class="s1">hasId = indexesOf(word</span><span class="s0">, </span><span class="s2">'#'</span><span class="s1">).filter(</span><span class="s0">function </span><span class="s1">(i) {</span>
	      <span class="s0">return </span><span class="s1">word[i - </span><span class="s3">1</span><span class="s1">] !== </span><span class="s2">'</span><span class="s0">\\</span><span class="s2">'</span><span class="s0">;</span>
	    <span class="s1">})</span><span class="s0">; </span><span class="s4">// Eliminate Sass interpolations from the list of id indexes</span>

	    <span class="s0">var </span><span class="s1">interpolations = indexesOf(word</span><span class="s0">, </span><span class="s2">'#{'</span><span class="s1">)</span><span class="s0">;</span>

	    <span class="s0">if </span><span class="s1">(interpolations.length) {</span>
	      <span class="s1">hasId = hasId.filter(</span><span class="s0">function </span><span class="s1">(hashIndex) {</span>
	        <span class="s0">return </span><span class="s1">!~interpolations.indexOf(hashIndex)</span><span class="s0">;</span>
	      <span class="s1">})</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">var </span><span class="s1">indices = (</span><span class="s3">0</span><span class="s0">, </span><span class="s1">_sortAscending[</span><span class="s2">&quot;default&quot;</span><span class="s1">])(uniqs([</span><span class="s3">0</span><span class="s1">].concat(hasClass</span><span class="s0">, </span><span class="s1">hasId)))</span><span class="s0">;</span>
	    <span class="s1">indices.forEach(</span><span class="s0">function </span><span class="s1">(ind</span><span class="s0">, </span><span class="s1">i) {</span>
	      <span class="s0">var </span><span class="s1">index = indices[i + </span><span class="s3">1</span><span class="s1">] || word.length</span><span class="s0">;</span>
	      <span class="s0">var </span><span class="s1">value = word.slice(ind</span><span class="s0">, </span><span class="s1">index)</span><span class="s0">;</span>

	      <span class="s0">if </span><span class="s1">(i === </span><span class="s3">0 </span><span class="s1">&amp;&amp; firstCallback) {</span>
	        <span class="s0">return </span><span class="s1">firstCallback.call(_this5</span><span class="s0">, </span><span class="s1">value</span><span class="s0">, </span><span class="s1">indices.length)</span><span class="s0">;</span>
	      <span class="s1">}</span>

	      <span class="s0">var </span><span class="s1">node</span><span class="s0">;</span>
	      <span class="s0">var </span><span class="s1">current = _this5.currToken</span><span class="s0">;</span>
	      <span class="s0">var </span><span class="s1">sourceIndex = current[_tokenize.FIELDS.START_POS] + indices[i]</span><span class="s0">;</span>
	      <span class="s0">var </span><span class="s1">source = getSource(current[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">current[</span><span class="s3">2</span><span class="s1">] + ind</span><span class="s0">, </span><span class="s1">current[</span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">current[</span><span class="s3">2</span><span class="s1">] + (index - </span><span class="s3">1</span><span class="s1">))</span><span class="s0">;</span>

	      <span class="s0">if </span><span class="s1">(~hasClass.indexOf(ind)) {</span>
	        <span class="s0">var </span><span class="s1">classNameOpts = {</span>
	          <span class="s1">value: value.slice(</span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
	          <span class="s1">source: source</span><span class="s0">,</span>
	          <span class="s1">sourceIndex: sourceIndex</span>
	        <span class="s1">}</span><span class="s0">;</span>
	        <span class="s1">node = </span><span class="s0">new </span><span class="s1">_className[</span><span class="s2">&quot;default&quot;</span><span class="s1">](unescapeProp(classNameOpts</span><span class="s0">, </span><span class="s2">&quot;value&quot;</span><span class="s1">))</span><span class="s0">;</span>
	      <span class="s1">} </span><span class="s0">else if </span><span class="s1">(~hasId.indexOf(ind)) {</span>
	        <span class="s0">var </span><span class="s1">idOpts = {</span>
	          <span class="s1">value: value.slice(</span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
	          <span class="s1">source: source</span><span class="s0">,</span>
	          <span class="s1">sourceIndex: sourceIndex</span>
	        <span class="s1">}</span><span class="s0">;</span>
	        <span class="s1">node = </span><span class="s0">new </span><span class="s1">_id[</span><span class="s2">&quot;default&quot;</span><span class="s1">](unescapeProp(idOpts</span><span class="s0">, </span><span class="s2">&quot;value&quot;</span><span class="s1">))</span><span class="s0">;</span>
	      <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
	        <span class="s0">var </span><span class="s1">tagOpts = {</span>
	          <span class="s1">value: value</span><span class="s0">,</span>
	          <span class="s1">source: source</span><span class="s0">,</span>
	          <span class="s1">sourceIndex: sourceIndex</span>
	        <span class="s1">}</span><span class="s0">;</span>
	        <span class="s1">unescapeProp(tagOpts</span><span class="s0">, </span><span class="s2">&quot;value&quot;</span><span class="s1">)</span><span class="s0">;</span>
	        <span class="s1">node = </span><span class="s0">new </span><span class="s1">_tag[</span><span class="s2">&quot;default&quot;</span><span class="s1">](tagOpts)</span><span class="s0">;</span>
	      <span class="s1">}</span>

	      <span class="s1">_this5.newNode(node</span><span class="s0">, </span><span class="s1">namespace)</span><span class="s0">; </span><span class="s4">// Ensure that the namespace is used only once</span>


	      <span class="s1">namespace = </span><span class="s0">null;</span>
	    <span class="s1">})</span><span class="s0">;</span>
	    <span class="s0">this</span><span class="s1">.position++</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.word = </span><span class="s0">function </span><span class="s1">word(namespace) {</span>
	    <span class="s0">var </span><span class="s1">nextToken = </span><span class="s0">this</span><span class="s1">.nextToken</span><span class="s0">;</span>

	    <span class="s0">if </span><span class="s1">(nextToken &amp;&amp; </span><span class="s0">this</span><span class="s1">.content(nextToken) === </span><span class="s2">'|'</span><span class="s1">) {</span>
	      <span class="s0">this</span><span class="s1">.position++</span><span class="s0">;</span>
	      <span class="s0">return this</span><span class="s1">.namespace()</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">return this</span><span class="s1">.splitWord(namespace)</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.loop = </span><span class="s0">function </span><span class="s1">loop() {</span>
	    <span class="s0">while </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.position &lt; </span><span class="s0">this</span><span class="s1">.tokens.length) {</span>
	      <span class="s0">this</span><span class="s1">.parse(</span><span class="s0">true</span><span class="s1">)</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">this</span><span class="s1">.current._inferEndPosition()</span><span class="s0">;</span>

	    <span class="s0">return this</span><span class="s1">.root</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.parse = </span><span class="s0">function </span><span class="s1">parse(throwOnParenthesis) {</span>
	    <span class="s0">switch </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.currToken[_tokenize.FIELDS.TYPE]) {</span>
	      <span class="s0">case </span><span class="s1">tokens.space:</span>
	        <span class="s0">this</span><span class="s1">.space()</span><span class="s0">;</span>
	        <span class="s0">break;</span>

	      <span class="s0">case </span><span class="s1">tokens.comment:</span>
	        <span class="s0">this</span><span class="s1">.comment()</span><span class="s0">;</span>
	        <span class="s0">break;</span>

	      <span class="s0">case </span><span class="s1">tokens.openParenthesis:</span>
	        <span class="s0">this</span><span class="s1">.parentheses()</span><span class="s0">;</span>
	        <span class="s0">break;</span>

	      <span class="s0">case </span><span class="s1">tokens.closeParenthesis:</span>
	        <span class="s0">if </span><span class="s1">(throwOnParenthesis) {</span>
	          <span class="s0">this</span><span class="s1">.missingParenthesis()</span><span class="s0">;</span>
	        <span class="s1">}</span>

	        <span class="s0">break;</span>

	      <span class="s0">case </span><span class="s1">tokens.openSquare:</span>
	        <span class="s0">this</span><span class="s1">.attribute()</span><span class="s0">;</span>
	        <span class="s0">break;</span>

	      <span class="s0">case </span><span class="s1">tokens.dollar:</span>
	      <span class="s0">case </span><span class="s1">tokens.caret:</span>
	      <span class="s0">case </span><span class="s1">tokens.equals:</span>
	      <span class="s0">case </span><span class="s1">tokens.word:</span>
	        <span class="s0">this</span><span class="s1">.word()</span><span class="s0">;</span>
	        <span class="s0">break;</span>

	      <span class="s0">case </span><span class="s1">tokens.colon:</span>
	        <span class="s0">this</span><span class="s1">.pseudo()</span><span class="s0">;</span>
	        <span class="s0">break;</span>

	      <span class="s0">case </span><span class="s1">tokens.comma:</span>
	        <span class="s0">this</span><span class="s1">.comma()</span><span class="s0">;</span>
	        <span class="s0">break;</span>

	      <span class="s0">case </span><span class="s1">tokens.asterisk:</span>
	        <span class="s0">this</span><span class="s1">.universal()</span><span class="s0">;</span>
	        <span class="s0">break;</span>

	      <span class="s0">case </span><span class="s1">tokens.ampersand:</span>
	        <span class="s0">this</span><span class="s1">.nesting()</span><span class="s0">;</span>
	        <span class="s0">break;</span>

	      <span class="s0">case </span><span class="s1">tokens.slash:</span>
	      <span class="s0">case </span><span class="s1">tokens.combinator:</span>
	        <span class="s0">this</span><span class="s1">.combinator()</span><span class="s0">;</span>
	        <span class="s0">break;</span>

	      <span class="s0">case </span><span class="s1">tokens.str:</span>
	        <span class="s0">this</span><span class="s1">.string()</span><span class="s0">;</span>
	        <span class="s0">break;</span>
	      <span class="s4">// These cases throw; no break needed.</span>

	      <span class="s0">case </span><span class="s1">tokens.closeSquare:</span>
	        <span class="s0">this</span><span class="s1">.missingSquareBracket()</span><span class="s0">;</span>

	      <span class="s0">case </span><span class="s1">tokens.semicolon:</span>
	        <span class="s0">this</span><span class="s1">.missingBackslash()</span><span class="s0">;</span>

	      <span class="s0">default</span><span class="s1">:</span>
	        <span class="s0">this</span><span class="s1">.unexpected()</span><span class="s0">;</span>
	    <span class="s1">}</span>
	  <span class="s1">}</span>
	  <span class="s5">/**</span>
	   <span class="s5">* Helpers</span>
	   <span class="s5">*/</span>
	  <span class="s0">;</span>

	  <span class="s1">_proto.expected = </span><span class="s0">function </span><span class="s1">expected(description</span><span class="s0">, </span><span class="s1">index</span><span class="s0">, </span><span class="s1">found) {</span>
	    <span class="s0">if </span><span class="s1">(Array.isArray(description)) {</span>
	      <span class="s0">var </span><span class="s1">last = description.pop()</span><span class="s0">;</span>
	      <span class="s1">description = description.join(</span><span class="s2">', '</span><span class="s1">) + </span><span class="s2">&quot; or &quot; </span><span class="s1">+ last</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">var </span><span class="s1">an = </span><span class="s3">/^[aeiou]/</span><span class="s1">.test(description[</span><span class="s3">0</span><span class="s1">]) ? </span><span class="s2">'an' </span><span class="s1">: </span><span class="s2">'a'</span><span class="s0">;</span>

	    <span class="s0">if </span><span class="s1">(!found) {</span>
	      <span class="s0">return this</span><span class="s1">.error(</span><span class="s2">&quot;Expected &quot; </span><span class="s1">+ an + </span><span class="s2">&quot; &quot; </span><span class="s1">+ description + </span><span class="s2">&quot;.&quot;</span><span class="s0">, </span><span class="s1">{</span>
	        <span class="s1">index: index</span>
	      <span class="s1">})</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">return this</span><span class="s1">.error(</span><span class="s2">&quot;Expected &quot; </span><span class="s1">+ an + </span><span class="s2">&quot; &quot; </span><span class="s1">+ description + </span><span class="s2">&quot;, found </span><span class="s0">\&quot;</span><span class="s2">&quot; </span><span class="s1">+ found + </span><span class="s2">&quot;</span><span class="s0">\&quot; </span><span class="s2">instead.&quot;</span><span class="s0">, </span><span class="s1">{</span>
	      <span class="s1">index: index</span>
	    <span class="s1">})</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.requiredSpace = </span><span class="s0">function </span><span class="s1">requiredSpace(space) {</span>
	    <span class="s0">return this</span><span class="s1">.options.lossy ? </span><span class="s2">' ' </span><span class="s1">: space</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.optionalSpace = </span><span class="s0">function </span><span class="s1">optionalSpace(space) {</span>
	    <span class="s0">return this</span><span class="s1">.options.lossy ? </span><span class="s2">'' </span><span class="s1">: space</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.lossySpace = </span><span class="s0">function </span><span class="s1">lossySpace(space</span><span class="s0">, </span><span class="s1">required) {</span>
	    <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.options.lossy) {</span>
	      <span class="s0">return </span><span class="s1">required ? </span><span class="s2">' ' </span><span class="s1">: </span><span class="s2">''</span><span class="s0">;</span>
	    <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
	      <span class="s0">return </span><span class="s1">space</span><span class="s0">;</span>
	    <span class="s1">}</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.parseParenthesisToken = </span><span class="s0">function </span><span class="s1">parseParenthesisToken(token) {</span>
	    <span class="s0">var </span><span class="s1">content = </span><span class="s0">this</span><span class="s1">.content(token)</span><span class="s0">;</span>

	    <span class="s0">if </span><span class="s1">(token[_tokenize.FIELDS.TYPE] === tokens.space) {</span>
	      <span class="s0">return this</span><span class="s1">.requiredSpace(content)</span><span class="s0">;</span>
	    <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
	      <span class="s0">return </span><span class="s1">content</span><span class="s0">;</span>
	    <span class="s1">}</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.newNode = </span><span class="s0">function </span><span class="s1">newNode(node</span><span class="s0">, </span><span class="s1">namespace) {</span>
	    <span class="s0">if </span><span class="s1">(namespace) {</span>
	      <span class="s0">if </span><span class="s1">(</span><span class="s3">/^ +$/</span><span class="s1">.test(namespace)) {</span>
	        <span class="s0">if </span><span class="s1">(!</span><span class="s0">this</span><span class="s1">.options.lossy) {</span>
	          <span class="s0">this</span><span class="s1">.spaces = (</span><span class="s0">this</span><span class="s1">.spaces || </span><span class="s2">''</span><span class="s1">) + namespace</span><span class="s0">;</span>
	        <span class="s1">}</span>

	        <span class="s1">namespace = </span><span class="s0">true;</span>
	      <span class="s1">}</span>

	      <span class="s1">node.namespace = namespace</span><span class="s0">;</span>
	      <span class="s1">unescapeProp(node</span><span class="s0">, </span><span class="s2">&quot;namespace&quot;</span><span class="s1">)</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.spaces) {</span>
	      <span class="s1">node.spaces.before = </span><span class="s0">this</span><span class="s1">.spaces</span><span class="s0">;</span>
	      <span class="s0">this</span><span class="s1">.spaces = </span><span class="s2">''</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">return this</span><span class="s1">.current.append(node)</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto.content = </span><span class="s0">function </span><span class="s1">content(token) {</span>
	    <span class="s0">if </span><span class="s1">(token === </span><span class="s0">void </span><span class="s3">0</span><span class="s1">) {</span>
	      <span class="s1">token = </span><span class="s0">this</span><span class="s1">.currToken</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">return this</span><span class="s1">.css.slice(token[_tokenize.FIELDS.START_POS]</span><span class="s0">, </span><span class="s1">token[_tokenize.FIELDS.END_POS])</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s5">/**</span>
	   <span class="s5">* returns the index of the next non-whitespace, non-comment token.</span>
	   <span class="s5">* returns -1 if no meaningful token is found.</span>
	   <span class="s5">*/</span>
	  <span class="s1">_proto.locateNextMeaningfulToken = </span><span class="s0">function </span><span class="s1">locateNextMeaningfulToken(startPosition) {</span>
	    <span class="s0">if </span><span class="s1">(startPosition === </span><span class="s0">void </span><span class="s3">0</span><span class="s1">) {</span>
	      <span class="s1">startPosition = </span><span class="s0">this</span><span class="s1">.position + </span><span class="s3">1</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">var </span><span class="s1">searchPosition = startPosition</span><span class="s0">;</span>

	    <span class="s0">while </span><span class="s1">(searchPosition &lt; </span><span class="s0">this</span><span class="s1">.tokens.length) {</span>
	      <span class="s0">if </span><span class="s1">(WHITESPACE_EQUIV_TOKENS[</span><span class="s0">this</span><span class="s1">.tokens[searchPosition][_tokenize.FIELDS.TYPE]]) {</span>
	        <span class="s1">searchPosition++</span><span class="s0">;</span>
	        <span class="s0">continue;</span>
	      <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
	        <span class="s0">return </span><span class="s1">searchPosition</span><span class="s0">;</span>
	      <span class="s1">}</span>
	    <span class="s1">}</span>

	    <span class="s0">return </span><span class="s1">-</span><span class="s3">1</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_createClass(Parser</span><span class="s0">, </span><span class="s1">[{</span>
	    <span class="s1">key: </span><span class="s2">&quot;currToken&quot;</span><span class="s0">,</span>
	    <span class="s1">get: </span><span class="s0">function </span><span class="s1">get() {</span>
	      <span class="s0">return this</span><span class="s1">.tokens[</span><span class="s0">this</span><span class="s1">.position]</span><span class="s0">;</span>
	    <span class="s1">}</span>
	  <span class="s1">}</span><span class="s0">, </span><span class="s1">{</span>
	    <span class="s1">key: </span><span class="s2">&quot;nextToken&quot;</span><span class="s0">,</span>
	    <span class="s1">get: </span><span class="s0">function </span><span class="s1">get() {</span>
	      <span class="s0">return this</span><span class="s1">.tokens[</span><span class="s0">this</span><span class="s1">.position + </span><span class="s3">1</span><span class="s1">]</span><span class="s0">;</span>
	    <span class="s1">}</span>
	  <span class="s1">}</span><span class="s0">, </span><span class="s1">{</span>
	    <span class="s1">key: </span><span class="s2">&quot;prevToken&quot;</span><span class="s0">,</span>
	    <span class="s1">get: </span><span class="s0">function </span><span class="s1">get() {</span>
	      <span class="s0">return this</span><span class="s1">.tokens[</span><span class="s0">this</span><span class="s1">.position - </span><span class="s3">1</span><span class="s1">]</span><span class="s0">;</span>
	    <span class="s1">}</span>
	  <span class="s1">}])</span><span class="s0">;</span>

	  <span class="s0">return </span><span class="s1">Parser</span><span class="s0">;</span>
	<span class="s1">}()</span><span class="s0">;</span>

	<span class="s1">exports[</span><span class="s2">&quot;default&quot;</span><span class="s1">] = Parser</span><span class="s0">;</span>
	<span class="s1">module.exports = exports.default</span><span class="s0">;</span>
<span class="s1">} (parser</span><span class="s0">, </span><span class="s1">parserExports))</span><span class="s0">;</span>

<span class="s1">(</span><span class="s0">function </span><span class="s1">(module</span><span class="s0">, </span><span class="s1">exports) {</span>

	<span class="s1">exports.__esModule = </span><span class="s0">true;</span>
	<span class="s1">exports[</span><span class="s2">&quot;default&quot;</span><span class="s1">] = </span><span class="s0">void </span><span class="s3">0</span><span class="s0">;</span>

	<span class="s0">var </span><span class="s1">_parser = _interopRequireDefault(parserExports)</span><span class="s0">;</span>

	<span class="s0">function </span><span class="s1">_interopRequireDefault(obj) { </span><span class="s0">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : { </span><span class="s2">&quot;default&quot;</span><span class="s1">: obj }</span><span class="s0">; </span><span class="s1">}</span>

	<span class="s0">var </span><span class="s1">Processor = </span><span class="s4">/*#__PURE__*/</span><span class="s0">function </span><span class="s1">() {</span>
	  <span class="s0">function </span><span class="s1">Processor(func</span><span class="s0">, </span><span class="s1">options) {</span>
	    <span class="s0">this</span><span class="s1">.func = func || </span><span class="s0">function </span><span class="s1">noop() {}</span><span class="s0">;</span>

	    <span class="s0">this</span><span class="s1">.funcRes = </span><span class="s0">null;</span>
	    <span class="s0">this</span><span class="s1">.options = options</span><span class="s0">;</span>
	  <span class="s1">}</span>

	  <span class="s0">var </span><span class="s1">_proto = Processor.prototype</span><span class="s0">;</span>

	  <span class="s1">_proto._shouldUpdateSelector = </span><span class="s0">function </span><span class="s1">_shouldUpdateSelector(rule</span><span class="s0">, </span><span class="s1">options) {</span>
	    <span class="s0">if </span><span class="s1">(options === </span><span class="s0">void </span><span class="s3">0</span><span class="s1">) {</span>
	      <span class="s1">options = {}</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">var </span><span class="s1">merged = Object.assign({}</span><span class="s0">, this</span><span class="s1">.options</span><span class="s0">, </span><span class="s1">options)</span><span class="s0">;</span>

	    <span class="s0">if </span><span class="s1">(merged.updateSelector === </span><span class="s0">false</span><span class="s1">) {</span>
	      <span class="s0">return false;</span>
	    <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
	      <span class="s0">return typeof </span><span class="s1">rule !== </span><span class="s2">&quot;string&quot;</span><span class="s0">;</span>
	    <span class="s1">}</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto._isLossy = </span><span class="s0">function </span><span class="s1">_isLossy(options) {</span>
	    <span class="s0">if </span><span class="s1">(options === </span><span class="s0">void </span><span class="s3">0</span><span class="s1">) {</span>
	      <span class="s1">options = {}</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">var </span><span class="s1">merged = Object.assign({}</span><span class="s0">, this</span><span class="s1">.options</span><span class="s0">, </span><span class="s1">options)</span><span class="s0">;</span>

	    <span class="s0">if </span><span class="s1">(merged.lossless === </span><span class="s0">false</span><span class="s1">) {</span>
	      <span class="s0">return true;</span>
	    <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
	      <span class="s0">return false;</span>
	    <span class="s1">}</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto._root = </span><span class="s0">function </span><span class="s1">_root(rule</span><span class="s0">, </span><span class="s1">options) {</span>
	    <span class="s0">if </span><span class="s1">(options === </span><span class="s0">void </span><span class="s3">0</span><span class="s1">) {</span>
	      <span class="s1">options = {}</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">var </span><span class="s1">parser = </span><span class="s0">new </span><span class="s1">_parser[</span><span class="s2">&quot;default&quot;</span><span class="s1">](rule</span><span class="s0">, this</span><span class="s1">._parseOptions(options))</span><span class="s0">;</span>
	    <span class="s0">return </span><span class="s1">parser.root</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto._parseOptions = </span><span class="s0">function </span><span class="s1">_parseOptions(options) {</span>
	    <span class="s0">return </span><span class="s1">{</span>
	      <span class="s1">lossy: </span><span class="s0">this</span><span class="s1">._isLossy(options)</span>
	    <span class="s1">}</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto._run = </span><span class="s0">function </span><span class="s1">_run(rule</span><span class="s0">, </span><span class="s1">options) {</span>
	    <span class="s0">var </span><span class="s1">_this = </span><span class="s0">this;</span>

	    <span class="s0">if </span><span class="s1">(options === </span><span class="s0">void </span><span class="s3">0</span><span class="s1">) {</span>
	      <span class="s1">options = {}</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">return new </span><span class="s1">Promise(</span><span class="s0">function </span><span class="s1">(resolve</span><span class="s0">, </span><span class="s1">reject) {</span>
	      <span class="s0">try </span><span class="s1">{</span>
	        <span class="s0">var </span><span class="s1">root = _this._root(rule</span><span class="s0">, </span><span class="s1">options)</span><span class="s0">;</span>

	        <span class="s1">Promise.resolve(_this.func(root)).then(</span><span class="s0">function </span><span class="s1">(transform) {</span>
	          <span class="s0">var </span><span class="s1">string = undefined</span><span class="s0">;</span>

	          <span class="s0">if </span><span class="s1">(_this._shouldUpdateSelector(rule</span><span class="s0">, </span><span class="s1">options)) {</span>
	            <span class="s1">string = root.toString()</span><span class="s0">;</span>
	            <span class="s1">rule.selector = string</span><span class="s0">;</span>
	          <span class="s1">}</span>

	          <span class="s0">return </span><span class="s1">{</span>
	            <span class="s1">transform: transform</span><span class="s0">,</span>
	            <span class="s1">root: root</span><span class="s0">,</span>
	            <span class="s1">string: string</span>
	          <span class="s1">}</span><span class="s0">;</span>
	        <span class="s1">}).then(resolve</span><span class="s0">, </span><span class="s1">reject)</span><span class="s0">;</span>
	      <span class="s1">} </span><span class="s0">catch </span><span class="s1">(e) {</span>
	        <span class="s1">reject(e)</span><span class="s0">;</span>
	        <span class="s0">return;</span>
	      <span class="s1">}</span>
	    <span class="s1">})</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s1">_proto._runSync = </span><span class="s0">function </span><span class="s1">_runSync(rule</span><span class="s0">, </span><span class="s1">options) {</span>
	    <span class="s0">if </span><span class="s1">(options === </span><span class="s0">void </span><span class="s3">0</span><span class="s1">) {</span>
	      <span class="s1">options = {}</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">var </span><span class="s1">root = </span><span class="s0">this</span><span class="s1">._root(rule</span><span class="s0">, </span><span class="s1">options)</span><span class="s0">;</span>

	    <span class="s0">var </span><span class="s1">transform = </span><span class="s0">this</span><span class="s1">.func(root)</span><span class="s0">;</span>

	    <span class="s0">if </span><span class="s1">(transform &amp;&amp; </span><span class="s0">typeof </span><span class="s1">transform.then === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
	      <span class="s0">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Selector processor returned a promise to a synchronous call.&quot;</span><span class="s1">)</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">var </span><span class="s1">string = undefined</span><span class="s0">;</span>

	    <span class="s0">if </span><span class="s1">(options.updateSelector &amp;&amp; </span><span class="s0">typeof </span><span class="s1">rule !== </span><span class="s2">&quot;string&quot;</span><span class="s1">) {</span>
	      <span class="s1">string = root.toString()</span><span class="s0">;</span>
	      <span class="s1">rule.selector = string</span><span class="s0">;</span>
	    <span class="s1">}</span>

	    <span class="s0">return </span><span class="s1">{</span>
	      <span class="s1">transform: transform</span><span class="s0">,</span>
	      <span class="s1">root: root</span><span class="s0">,</span>
	      <span class="s1">string: string</span>
	    <span class="s1">}</span><span class="s0">;</span>
	  <span class="s1">}</span>
	  <span class="s5">/**</span>
	   <span class="s5">* Process rule into a selector AST.</span>
	   <span class="s5">*</span>
	   <span class="s5">* </span><span class="s6">@param </span><span class="s5">rule {postcss.Rule | string} The css selector to be processed</span>
	   <span class="s5">* </span><span class="s6">@param </span><span class="s5">options The options for processing</span>
	   <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{Promise&lt;parser.Root&gt;} The AST of the selector after processing it.</span>
	   <span class="s5">*/</span>
	  <span class="s0">;</span>

	  <span class="s1">_proto.ast = </span><span class="s0">function </span><span class="s1">ast(rule</span><span class="s0">, </span><span class="s1">options) {</span>
	    <span class="s0">return this</span><span class="s1">._run(rule</span><span class="s0">, </span><span class="s1">options).then(</span><span class="s0">function </span><span class="s1">(result) {</span>
	      <span class="s0">return </span><span class="s1">result.root</span><span class="s0">;</span>
	    <span class="s1">})</span><span class="s0">;</span>
	  <span class="s1">}</span>
	  <span class="s5">/**</span>
	   <span class="s5">* Process rule into a selector AST synchronously.</span>
	   <span class="s5">*</span>
	   <span class="s5">* </span><span class="s6">@param </span><span class="s5">rule {postcss.Rule | string} The css selector to be processed</span>
	   <span class="s5">* </span><span class="s6">@param </span><span class="s5">options The options for processing</span>
	   <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{parser.Root} The AST of the selector after processing it.</span>
	   <span class="s5">*/</span>
	  <span class="s0">;</span>

	  <span class="s1">_proto.astSync = </span><span class="s0">function </span><span class="s1">astSync(rule</span><span class="s0">, </span><span class="s1">options) {</span>
	    <span class="s0">return this</span><span class="s1">._runSync(rule</span><span class="s0">, </span><span class="s1">options).root</span><span class="s0">;</span>
	  <span class="s1">}</span>
	  <span class="s5">/**</span>
	   <span class="s5">* Process a selector into a transformed value asynchronously</span>
	   <span class="s5">*</span>
	   <span class="s5">* </span><span class="s6">@param </span><span class="s5">rule {postcss.Rule | string} The css selector to be processed</span>
	   <span class="s5">* </span><span class="s6">@param </span><span class="s5">options The options for processing</span>
	   <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{Promise&lt;any&gt;} The value returned by the processor.</span>
	   <span class="s5">*/</span>
	  <span class="s0">;</span>

	  <span class="s1">_proto.transform = </span><span class="s0">function </span><span class="s1">transform(rule</span><span class="s0">, </span><span class="s1">options) {</span>
	    <span class="s0">return this</span><span class="s1">._run(rule</span><span class="s0">, </span><span class="s1">options).then(</span><span class="s0">function </span><span class="s1">(result) {</span>
	      <span class="s0">return </span><span class="s1">result.transform</span><span class="s0">;</span>
	    <span class="s1">})</span><span class="s0">;</span>
	  <span class="s1">}</span>
	  <span class="s5">/**</span>
	   <span class="s5">* Process a selector into a transformed value synchronously.</span>
	   <span class="s5">*</span>
	   <span class="s5">* </span><span class="s6">@param </span><span class="s5">rule {postcss.Rule | string} The css selector to be processed</span>
	   <span class="s5">* </span><span class="s6">@param </span><span class="s5">options The options for processing</span>
	   <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{any} The value returned by the processor.</span>
	   <span class="s5">*/</span>
	  <span class="s0">;</span>

	  <span class="s1">_proto.transformSync = </span><span class="s0">function </span><span class="s1">transformSync(rule</span><span class="s0">, </span><span class="s1">options) {</span>
	    <span class="s0">return this</span><span class="s1">._runSync(rule</span><span class="s0">, </span><span class="s1">options).transform</span><span class="s0">;</span>
	  <span class="s1">}</span>
	  <span class="s5">/**</span>
	   <span class="s5">* Process a selector into a new selector string asynchronously.</span>
	   <span class="s5">*</span>
	   <span class="s5">* </span><span class="s6">@param </span><span class="s5">rule {postcss.Rule | string} The css selector to be processed</span>
	   <span class="s5">* </span><span class="s6">@param </span><span class="s5">options The options for processing</span>
	   <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{string} the selector after processing.</span>
	   <span class="s5">*/</span>
	  <span class="s0">;</span>

	  <span class="s1">_proto.process = </span><span class="s0">function </span><span class="s1">process(rule</span><span class="s0">, </span><span class="s1">options) {</span>
	    <span class="s0">return this</span><span class="s1">._run(rule</span><span class="s0">, </span><span class="s1">options).then(</span><span class="s0">function </span><span class="s1">(result) {</span>
	      <span class="s0">return </span><span class="s1">result.string || result.root.toString()</span><span class="s0">;</span>
	    <span class="s1">})</span><span class="s0">;</span>
	  <span class="s1">}</span>
	  <span class="s5">/**</span>
	   <span class="s5">* Process a selector into a new selector string synchronously.</span>
	   <span class="s5">*</span>
	   <span class="s5">* </span><span class="s6">@param </span><span class="s5">rule {postcss.Rule | string} The css selector to be processed</span>
	   <span class="s5">* </span><span class="s6">@param </span><span class="s5">options The options for processing</span>
	   <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{string} the selector after processing.</span>
	   <span class="s5">*/</span>
	  <span class="s0">;</span>

	  <span class="s1">_proto.processSync = </span><span class="s0">function </span><span class="s1">processSync(rule</span><span class="s0">, </span><span class="s1">options) {</span>
	    <span class="s0">var </span><span class="s1">result = </span><span class="s0">this</span><span class="s1">._runSync(rule</span><span class="s0">, </span><span class="s1">options)</span><span class="s0">;</span>

	    <span class="s0">return </span><span class="s1">result.string || result.root.toString()</span><span class="s0">;</span>
	  <span class="s1">}</span><span class="s0">;</span>

	  <span class="s0">return </span><span class="s1">Processor</span><span class="s0">;</span>
	<span class="s1">}()</span><span class="s0">;</span>

	<span class="s1">exports[</span><span class="s2">&quot;default&quot;</span><span class="s1">] = Processor</span><span class="s0">;</span>
	<span class="s1">module.exports = exports.default</span><span class="s0">;</span>
<span class="s1">} (processor</span><span class="s0">, </span><span class="s1">processorExports))</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">selectors = {}</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">constructors = {}</span><span class="s0">;</span>

<span class="s1">constructors.__esModule = </span><span class="s0">true;</span>
<span class="s1">constructors.universal = constructors.tag = constructors.string = constructors.selector = constructors.root = constructors.pseudo = constructors.nesting = constructors.id = constructors.comment = constructors.combinator = constructors.className = constructors.attribute = </span><span class="s0">void </span><span class="s3">0</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">_attribute = _interopRequireDefault$2(attribute$1)</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">_className = _interopRequireDefault$2(classNameExports)</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">_combinator = _interopRequireDefault$2(combinatorExports)</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">_comment = _interopRequireDefault$2(commentExports)</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">_id = _interopRequireDefault$2(idExports)</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">_nesting = _interopRequireDefault$2(nestingExports)</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">_pseudo = _interopRequireDefault$2(pseudoExports)</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">_root = _interopRequireDefault$2(rootExports)</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">_selector = _interopRequireDefault$2(selectorExports)</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">_string = _interopRequireDefault$2(stringExports)</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">_tag = _interopRequireDefault$2(tagExports)</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">_universal = _interopRequireDefault$2(universalExports)</span><span class="s0">;</span>

<span class="s0">function </span><span class="s1">_interopRequireDefault$2(obj) { </span><span class="s0">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : { </span><span class="s2">&quot;default&quot;</span><span class="s1">: obj }</span><span class="s0">; </span><span class="s1">}</span>

<span class="s0">var </span><span class="s1">attribute = </span><span class="s0">function </span><span class="s1">attribute(opts) {</span>
  <span class="s0">return new </span><span class="s1">_attribute[</span><span class="s2">&quot;default&quot;</span><span class="s1">](opts)</span><span class="s0">;</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s1">constructors.attribute = attribute</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">className = </span><span class="s0">function </span><span class="s1">className(opts) {</span>
  <span class="s0">return new </span><span class="s1">_className[</span><span class="s2">&quot;default&quot;</span><span class="s1">](opts)</span><span class="s0">;</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s1">constructors.className = className</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">combinator = </span><span class="s0">function </span><span class="s1">combinator(opts) {</span>
  <span class="s0">return new </span><span class="s1">_combinator[</span><span class="s2">&quot;default&quot;</span><span class="s1">](opts)</span><span class="s0">;</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s1">constructors.combinator = combinator</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">comment = </span><span class="s0">function </span><span class="s1">comment(opts) {</span>
  <span class="s0">return new </span><span class="s1">_comment[</span><span class="s2">&quot;default&quot;</span><span class="s1">](opts)</span><span class="s0">;</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s1">constructors.comment = comment</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">id = </span><span class="s0">function </span><span class="s1">id(opts) {</span>
  <span class="s0">return new </span><span class="s1">_id[</span><span class="s2">&quot;default&quot;</span><span class="s1">](opts)</span><span class="s0">;</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s1">constructors.id = id</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">nesting = </span><span class="s0">function </span><span class="s1">nesting(opts) {</span>
  <span class="s0">return new </span><span class="s1">_nesting[</span><span class="s2">&quot;default&quot;</span><span class="s1">](opts)</span><span class="s0">;</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s1">constructors.nesting = nesting</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">pseudo = </span><span class="s0">function </span><span class="s1">pseudo(opts) {</span>
  <span class="s0">return new </span><span class="s1">_pseudo[</span><span class="s2">&quot;default&quot;</span><span class="s1">](opts)</span><span class="s0">;</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s1">constructors.pseudo = pseudo</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">root = </span><span class="s0">function </span><span class="s1">root(opts) {</span>
  <span class="s0">return new </span><span class="s1">_root[</span><span class="s2">&quot;default&quot;</span><span class="s1">](opts)</span><span class="s0">;</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s1">constructors.root = root</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">selector = </span><span class="s0">function </span><span class="s1">selector(opts) {</span>
  <span class="s0">return new </span><span class="s1">_selector[</span><span class="s2">&quot;default&quot;</span><span class="s1">](opts)</span><span class="s0">;</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s1">constructors.selector = selector</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">string = </span><span class="s0">function </span><span class="s1">string(opts) {</span>
  <span class="s0">return new </span><span class="s1">_string[</span><span class="s2">&quot;default&quot;</span><span class="s1">](opts)</span><span class="s0">;</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s1">constructors.string = string</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">tag = </span><span class="s0">function </span><span class="s1">tag(opts) {</span>
  <span class="s0">return new </span><span class="s1">_tag[</span><span class="s2">&quot;default&quot;</span><span class="s1">](opts)</span><span class="s0">;</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s1">constructors.tag = tag</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">universal = </span><span class="s0">function </span><span class="s1">universal(opts) {</span>
  <span class="s0">return new </span><span class="s1">_universal[</span><span class="s2">&quot;default&quot;</span><span class="s1">](opts)</span><span class="s0">;</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s1">constructors.universal = universal</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">guards = {}</span><span class="s0">;</span>

<span class="s1">guards.__esModule = </span><span class="s0">true;</span>
<span class="s1">guards.isNode = isNode</span><span class="s0">;</span>
<span class="s1">guards.isPseudoElement = isPseudoElement</span><span class="s0">;</span>
<span class="s1">guards.isPseudoClass = isPseudoClass</span><span class="s0">;</span>
<span class="s1">guards.isContainer = isContainer</span><span class="s0">;</span>
<span class="s1">guards.isNamespace = isNamespace</span><span class="s0">;</span>
<span class="s1">guards.isUniversal = guards.isTag = guards.isString = guards.isSelector = guards.isRoot = guards.isPseudo = guards.isNesting = guards.isIdentifier = guards.isComment = guards.isCombinator = guards.isClassName = guards.isAttribute = </span><span class="s0">void </span><span class="s3">0</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">_types = types</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">_IS_TYPE</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">IS_TYPE = (_IS_TYPE = {}</span><span class="s0">, </span><span class="s1">_IS_TYPE[_types.ATTRIBUTE] = </span><span class="s0">true, </span><span class="s1">_IS_TYPE[_types.CLASS] = </span><span class="s0">true, </span><span class="s1">_IS_TYPE[_types.COMBINATOR] = </span><span class="s0">true, </span><span class="s1">_IS_TYPE[_types.COMMENT] = </span><span class="s0">true, </span><span class="s1">_IS_TYPE[_types.ID] = </span><span class="s0">true, </span><span class="s1">_IS_TYPE[_types.NESTING] = </span><span class="s0">true, </span><span class="s1">_IS_TYPE[_types.PSEUDO] = </span><span class="s0">true, </span><span class="s1">_IS_TYPE[_types.ROOT] = </span><span class="s0">true, </span><span class="s1">_IS_TYPE[_types.SELECTOR] = </span><span class="s0">true, </span><span class="s1">_IS_TYPE[_types.STRING] = </span><span class="s0">true, </span><span class="s1">_IS_TYPE[_types.TAG] = </span><span class="s0">true, </span><span class="s1">_IS_TYPE[_types.UNIVERSAL] = </span><span class="s0">true, </span><span class="s1">_IS_TYPE)</span><span class="s0">;</span>

<span class="s0">function </span><span class="s1">isNode(node) {</span>
  <span class="s0">return typeof </span><span class="s1">node === </span><span class="s2">&quot;object&quot; </span><span class="s1">&amp;&amp; IS_TYPE[node.type]</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">isNodeType(type</span><span class="s0">, </span><span class="s1">node) {</span>
  <span class="s0">return </span><span class="s1">isNode(node) &amp;&amp; node.type === type</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">var </span><span class="s1">isAttribute = isNodeType.bind(</span><span class="s0">null, </span><span class="s1">_types.ATTRIBUTE)</span><span class="s0">;</span>
<span class="s1">guards.isAttribute = isAttribute</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">isClassName = isNodeType.bind(</span><span class="s0">null, </span><span class="s1">_types.CLASS)</span><span class="s0">;</span>
<span class="s1">guards.isClassName = isClassName</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">isCombinator = isNodeType.bind(</span><span class="s0">null, </span><span class="s1">_types.COMBINATOR)</span><span class="s0">;</span>
<span class="s1">guards.isCombinator = isCombinator</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">isComment = isNodeType.bind(</span><span class="s0">null, </span><span class="s1">_types.COMMENT)</span><span class="s0">;</span>
<span class="s1">guards.isComment = isComment</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">isIdentifier = isNodeType.bind(</span><span class="s0">null, </span><span class="s1">_types.ID)</span><span class="s0">;</span>
<span class="s1">guards.isIdentifier = isIdentifier</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">isNesting = isNodeType.bind(</span><span class="s0">null, </span><span class="s1">_types.NESTING)</span><span class="s0">;</span>
<span class="s1">guards.isNesting = isNesting</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">isPseudo = isNodeType.bind(</span><span class="s0">null, </span><span class="s1">_types.PSEUDO)</span><span class="s0">;</span>
<span class="s1">guards.isPseudo = isPseudo</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">isRoot = isNodeType.bind(</span><span class="s0">null, </span><span class="s1">_types.ROOT)</span><span class="s0">;</span>
<span class="s1">guards.isRoot = isRoot</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">isSelector = isNodeType.bind(</span><span class="s0">null, </span><span class="s1">_types.SELECTOR)</span><span class="s0">;</span>
<span class="s1">guards.isSelector = isSelector</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">isString = isNodeType.bind(</span><span class="s0">null, </span><span class="s1">_types.STRING)</span><span class="s0">;</span>
<span class="s1">guards.isString = isString</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">isTag = isNodeType.bind(</span><span class="s0">null, </span><span class="s1">_types.TAG)</span><span class="s0">;</span>
<span class="s1">guards.isTag = isTag</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">isUniversal = isNodeType.bind(</span><span class="s0">null, </span><span class="s1">_types.UNIVERSAL)</span><span class="s0">;</span>
<span class="s1">guards.isUniversal = isUniversal</span><span class="s0">;</span>

<span class="s0">function </span><span class="s1">isPseudoElement(node) {</span>
  <span class="s0">return </span><span class="s1">isPseudo(node) &amp;&amp; node.value &amp;&amp; (node.value.startsWith(</span><span class="s2">&quot;::&quot;</span><span class="s1">) || node.value.toLowerCase() === </span><span class="s2">&quot;:before&quot; </span><span class="s1">|| node.value.toLowerCase() === </span><span class="s2">&quot;:after&quot; </span><span class="s1">|| node.value.toLowerCase() === </span><span class="s2">&quot;:first-letter&quot; </span><span class="s1">|| node.value.toLowerCase() === </span><span class="s2">&quot;:first-line&quot;</span><span class="s1">)</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">isPseudoClass(node) {</span>
  <span class="s0">return </span><span class="s1">isPseudo(node) &amp;&amp; !isPseudoElement(node)</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">isContainer(node) {</span>
  <span class="s0">return </span><span class="s1">!!(isNode(node) &amp;&amp; node.walk)</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">isNamespace(node) {</span>
  <span class="s0">return </span><span class="s1">isAttribute(node) || isTag(node)</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s1">(</span><span class="s0">function </span><span class="s1">(exports) {</span>

	<span class="s1">exports.__esModule = </span><span class="s0">true;</span>

	<span class="s0">var </span><span class="s1">_types = types</span><span class="s0">;</span>

	<span class="s1">Object.keys(_types).forEach(</span><span class="s0">function </span><span class="s1">(key) {</span>
	  <span class="s0">if </span><span class="s1">(key === </span><span class="s2">&quot;default&quot; </span><span class="s1">|| key === </span><span class="s2">&quot;__esModule&quot;</span><span class="s1">) </span><span class="s0">return;</span>
	  <span class="s0">if </span><span class="s1">(key </span><span class="s0">in </span><span class="s1">exports &amp;&amp; exports[key] === _types[key]) </span><span class="s0">return;</span>
	  <span class="s1">exports[key] = _types[key]</span><span class="s0">;</span>
	<span class="s1">})</span><span class="s0">;</span>

	<span class="s0">var </span><span class="s1">_constructors = constructors</span><span class="s0">;</span>

	<span class="s1">Object.keys(_constructors).forEach(</span><span class="s0">function </span><span class="s1">(key) {</span>
	  <span class="s0">if </span><span class="s1">(key === </span><span class="s2">&quot;default&quot; </span><span class="s1">|| key === </span><span class="s2">&quot;__esModule&quot;</span><span class="s1">) </span><span class="s0">return;</span>
	  <span class="s0">if </span><span class="s1">(key </span><span class="s0">in </span><span class="s1">exports &amp;&amp; exports[key] === _constructors[key]) </span><span class="s0">return;</span>
	  <span class="s1">exports[key] = _constructors[key]</span><span class="s0">;</span>
	<span class="s1">})</span><span class="s0">;</span>

	<span class="s0">var </span><span class="s1">_guards = guards</span><span class="s0">;</span>

	<span class="s1">Object.keys(_guards).forEach(</span><span class="s0">function </span><span class="s1">(key) {</span>
	  <span class="s0">if </span><span class="s1">(key === </span><span class="s2">&quot;default&quot; </span><span class="s1">|| key === </span><span class="s2">&quot;__esModule&quot;</span><span class="s1">) </span><span class="s0">return;</span>
	  <span class="s0">if </span><span class="s1">(key </span><span class="s0">in </span><span class="s1">exports &amp;&amp; exports[key] === _guards[key]) </span><span class="s0">return;</span>
	  <span class="s1">exports[key] = _guards[key]</span><span class="s0">;</span>
	<span class="s1">})</span><span class="s0">;</span>
<span class="s1">} (selectors))</span><span class="s0">;</span>

<span class="s1">(</span><span class="s0">function </span><span class="s1">(module</span><span class="s0">, </span><span class="s1">exports) {</span>

	<span class="s1">exports.__esModule = </span><span class="s0">true;</span>
	<span class="s1">exports[</span><span class="s2">&quot;default&quot;</span><span class="s1">] = </span><span class="s0">void </span><span class="s3">0</span><span class="s0">;</span>

	<span class="s0">var </span><span class="s1">_processor = _interopRequireDefault(processorExports)</span><span class="s0">;</span>

	<span class="s0">var </span><span class="s1">selectors$1 = _interopRequireWildcard(selectors)</span><span class="s0">;</span>

	<span class="s0">function </span><span class="s1">_getRequireWildcardCache() { </span><span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">WeakMap !== </span><span class="s2">&quot;function&quot;</span><span class="s1">) </span><span class="s0">return null; var </span><span class="s1">cache = </span><span class="s0">new </span><span class="s1">WeakMap()</span><span class="s0">; </span><span class="s1">_getRequireWildcardCache = </span><span class="s0">function </span><span class="s1">_getRequireWildcardCache() { </span><span class="s0">return </span><span class="s1">cache</span><span class="s0">; </span><span class="s1">}</span><span class="s0">; return </span><span class="s1">cache</span><span class="s0">; </span><span class="s1">}</span>

	<span class="s0">function </span><span class="s1">_interopRequireWildcard(obj) { </span><span class="s0">if </span><span class="s1">(obj &amp;&amp; obj.__esModule) { </span><span class="s0">return </span><span class="s1">obj</span><span class="s0">; </span><span class="s1">} </span><span class="s0">if </span><span class="s1">(obj === </span><span class="s0">null </span><span class="s1">|| </span><span class="s0">typeof </span><span class="s1">obj !== </span><span class="s2">&quot;object&quot; </span><span class="s1">&amp;&amp; </span><span class="s0">typeof </span><span class="s1">obj !== </span><span class="s2">&quot;function&quot;</span><span class="s1">) { </span><span class="s0">return </span><span class="s1">{ </span><span class="s2">&quot;default&quot;</span><span class="s1">: obj }</span><span class="s0">; </span><span class="s1">} </span><span class="s0">var </span><span class="s1">cache = _getRequireWildcardCache()</span><span class="s0">; if </span><span class="s1">(cache &amp;&amp; cache.has(obj)) { </span><span class="s0">return </span><span class="s1">cache.get(obj)</span><span class="s0">; </span><span class="s1">} </span><span class="s0">var </span><span class="s1">newObj = {}</span><span class="s0">; var </span><span class="s1">hasPropertyDescriptor = Object.defineProperty &amp;&amp; Object.getOwnPropertyDescriptor</span><span class="s0">; for </span><span class="s1">(</span><span class="s0">var </span><span class="s1">key </span><span class="s0">in </span><span class="s1">obj) { </span><span class="s0">if </span><span class="s1">(Object.prototype.hasOwnProperty.call(obj</span><span class="s0">, </span><span class="s1">key)) { </span><span class="s0">var </span><span class="s1">desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj</span><span class="s0">, </span><span class="s1">key) : </span><span class="s0">null; if </span><span class="s1">(desc &amp;&amp; (desc.get || desc.set)) { Object.defineProperty(newObj</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">desc)</span><span class="s0">; </span><span class="s1">} </span><span class="s0">else </span><span class="s1">{ newObj[key] = obj[key]</span><span class="s0">; </span><span class="s1">} } } newObj[</span><span class="s2">&quot;default&quot;</span><span class="s1">] = obj</span><span class="s0">; if </span><span class="s1">(cache) { cache.set(obj</span><span class="s0">, </span><span class="s1">newObj)</span><span class="s0">; </span><span class="s1">} </span><span class="s0">return </span><span class="s1">newObj</span><span class="s0">; </span><span class="s1">}</span>

	<span class="s0">function </span><span class="s1">_interopRequireDefault(obj) { </span><span class="s0">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : { </span><span class="s2">&quot;default&quot;</span><span class="s1">: obj }</span><span class="s0">; </span><span class="s1">}</span>

	<span class="s0">var </span><span class="s1">parser = </span><span class="s0">function </span><span class="s1">parser(processor) {</span>
	  <span class="s0">return new </span><span class="s1">_processor[</span><span class="s2">&quot;default&quot;</span><span class="s1">](processor)</span><span class="s0">;</span>
	<span class="s1">}</span><span class="s0">;</span>

	<span class="s1">Object.assign(parser</span><span class="s0">, </span><span class="s1">selectors$1)</span><span class="s0">;</span>
	<span class="s0">delete </span><span class="s1">parser.__esModule</span><span class="s0">;</span>
	<span class="s0">var </span><span class="s1">_default = parser</span><span class="s0">;</span>
	<span class="s1">exports[</span><span class="s2">&quot;default&quot;</span><span class="s1">] = _default</span><span class="s0">;</span>
	<span class="s1">module.exports = exports.default</span><span class="s0">;</span>
<span class="s1">} (dist</span><span class="s0">, </span><span class="s1">distExports))</span><span class="s0">;</span>

<span class="s0">const </span><span class="s1">selectorParser$1 = distExports</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">valueParser = lib</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">{ extractICSS } = src$4</span><span class="s0">;</span>

<span class="s0">const </span><span class="s1">isSpacing = (node) =&gt; node.type === </span><span class="s2">&quot;combinator&quot; </span><span class="s1">&amp;&amp; node.value === </span><span class="s2">&quot; &quot;</span><span class="s0">;</span>

<span class="s0">function </span><span class="s1">normalizeNodeArray(nodes) {</span>
  <span class="s0">const </span><span class="s1">array = []</span><span class="s0">;</span>

  <span class="s1">nodes.forEach((x) =&gt; {</span>
    <span class="s0">if </span><span class="s1">(Array.isArray(x)) {</span>
      <span class="s1">normalizeNodeArray(x).forEach((item) =&gt; {</span>
        <span class="s1">array.push(item)</span><span class="s0">;</span>
      <span class="s1">})</span><span class="s0">;</span>
    <span class="s1">} </span><span class="s0">else if </span><span class="s1">(x) {</span>
      <span class="s1">array.push(x)</span><span class="s0">;</span>
    <span class="s1">}</span>
  <span class="s1">})</span><span class="s0">;</span>

  <span class="s0">if </span><span class="s1">(array.length &gt; </span><span class="s3">0 </span><span class="s1">&amp;&amp; isSpacing(array[array.length - </span><span class="s3">1</span><span class="s1">])) {</span>
    <span class="s1">array.pop()</span><span class="s0">;</span>
  <span class="s1">}</span>
  <span class="s0">return </span><span class="s1">array</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">localizeNode(rule</span><span class="s0">, </span><span class="s1">mode</span><span class="s0">, </span><span class="s1">localAliasMap) {</span>
  <span class="s0">const </span><span class="s1">transform = (node</span><span class="s0">, </span><span class="s1">context) =&gt; {</span>
    <span class="s0">if </span><span class="s1">(context.ignoreNextSpacing &amp;&amp; !isSpacing(node)) {</span>
      <span class="s0">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Missing whitespace after &quot; </span><span class="s1">+ context.ignoreNextSpacing)</span><span class="s0">;</span>
    <span class="s1">}</span>

    <span class="s0">if </span><span class="s1">(context.enforceNoSpacing &amp;&amp; isSpacing(node)) {</span>
      <span class="s0">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Missing whitespace before &quot; </span><span class="s1">+ context.enforceNoSpacing)</span><span class="s0">;</span>
    <span class="s1">}</span>

    <span class="s0">let </span><span class="s1">newNodes</span><span class="s0">;</span>

    <span class="s0">switch </span><span class="s1">(node.type) {</span>
      <span class="s0">case </span><span class="s2">&quot;root&quot;</span><span class="s1">: {</span>
        <span class="s0">let </span><span class="s1">resultingGlobal</span><span class="s0">;</span>

        <span class="s1">context.hasPureGlobals = </span><span class="s0">false;</span>

        <span class="s1">newNodes = node.nodes.map((n) =&gt; {</span>
          <span class="s0">const </span><span class="s1">nContext = {</span>
            <span class="s1">global: context.global</span><span class="s0">,</span>
            <span class="s1">lastWasSpacing: </span><span class="s0">true,</span>
            <span class="s1">hasLocals: </span><span class="s0">false,</span>
            <span class="s1">explicit: </span><span class="s0">false,</span>
          <span class="s1">}</span><span class="s0">;</span>

          <span class="s1">n = transform(n</span><span class="s0">, </span><span class="s1">nContext)</span><span class="s0">;</span>

          <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">resultingGlobal === </span><span class="s2">&quot;undefined&quot;</span><span class="s1">) {</span>
            <span class="s1">resultingGlobal = nContext.global</span><span class="s0">;</span>
          <span class="s1">} </span><span class="s0">else if </span><span class="s1">(resultingGlobal !== nContext.global) {</span>
            <span class="s0">throw new </span><span class="s1">Error(</span>
              <span class="s2">'Inconsistent rule global/local result in rule &quot;' </span><span class="s1">+</span>
                <span class="s1">node +</span>
                <span class="s2">'&quot; (multiple selectors must result in the same mode for the rule)'</span>
            <span class="s1">)</span><span class="s0">;</span>
          <span class="s1">}</span>

          <span class="s0">if </span><span class="s1">(!nContext.hasLocals) {</span>
            <span class="s1">context.hasPureGlobals = </span><span class="s0">true;</span>
          <span class="s1">}</span>

          <span class="s0">return </span><span class="s1">n</span><span class="s0">;</span>
        <span class="s1">})</span><span class="s0">;</span>

        <span class="s1">context.global = resultingGlobal</span><span class="s0">;</span>

        <span class="s1">node.nodes = normalizeNodeArray(newNodes)</span><span class="s0">;</span>
        <span class="s0">break;</span>
      <span class="s1">}</span>
      <span class="s0">case </span><span class="s2">&quot;selector&quot;</span><span class="s1">: {</span>
        <span class="s1">newNodes = node.map((childNode) =&gt; transform(childNode</span><span class="s0">, </span><span class="s1">context))</span><span class="s0">;</span>

        <span class="s1">node = node.clone()</span><span class="s0">;</span>
        <span class="s1">node.nodes = normalizeNodeArray(newNodes)</span><span class="s0">;</span>
        <span class="s0">break;</span>
      <span class="s1">}</span>
      <span class="s0">case </span><span class="s2">&quot;combinator&quot;</span><span class="s1">: {</span>
        <span class="s0">if </span><span class="s1">(isSpacing(node)) {</span>
          <span class="s0">if </span><span class="s1">(context.ignoreNextSpacing) {</span>
            <span class="s1">context.ignoreNextSpacing = </span><span class="s0">false;</span>
            <span class="s1">context.lastWasSpacing = </span><span class="s0">false;</span>
            <span class="s1">context.enforceNoSpacing = </span><span class="s0">false;</span>
            <span class="s0">return null;</span>
          <span class="s1">}</span>
          <span class="s1">context.lastWasSpacing = </span><span class="s0">true;</span>
          <span class="s0">return </span><span class="s1">node</span><span class="s0">;</span>
        <span class="s1">}</span>
        <span class="s0">break;</span>
      <span class="s1">}</span>
      <span class="s0">case </span><span class="s2">&quot;pseudo&quot;</span><span class="s1">: {</span>
        <span class="s0">let </span><span class="s1">childContext</span><span class="s0">;</span>
        <span class="s0">const </span><span class="s1">isNested = !!node.length</span><span class="s0">;</span>
        <span class="s0">const </span><span class="s1">isScoped = node.value === </span><span class="s2">&quot;:local&quot; </span><span class="s1">|| node.value === </span><span class="s2">&quot;:global&quot;</span><span class="s0">;</span>
        <span class="s0">const </span><span class="s1">isImportExport =</span>
          <span class="s1">node.value === </span><span class="s2">&quot;:import&quot; </span><span class="s1">|| node.value === </span><span class="s2">&quot;:export&quot;</span><span class="s0">;</span>

        <span class="s0">if </span><span class="s1">(isImportExport) {</span>
          <span class="s1">context.hasLocals = </span><span class="s0">true;</span>
          <span class="s4">// :local(.foo)</span>
        <span class="s1">} </span><span class="s0">else if </span><span class="s1">(isNested) {</span>
          <span class="s0">if </span><span class="s1">(isScoped) {</span>
            <span class="s0">if </span><span class="s1">(node.nodes.length === </span><span class="s3">0</span><span class="s1">) {</span>
              <span class="s0">throw new </span><span class="s1">Error(</span><span class="s2">`</span><span class="s1">${node.value}</span><span class="s2">() can't be empty`</span><span class="s1">)</span><span class="s0">;</span>
            <span class="s1">}</span>

            <span class="s0">if </span><span class="s1">(context.inside) {</span>
              <span class="s0">throw new </span><span class="s1">Error(</span>
                <span class="s2">`A </span><span class="s1">${node.value} </span><span class="s2">is not allowed inside of a </span><span class="s1">${context.inside}</span><span class="s2">(...)`</span>
              <span class="s1">)</span><span class="s0">;</span>
            <span class="s1">}</span>

            <span class="s1">childContext = {</span>
              <span class="s1">global: node.value === </span><span class="s2">&quot;:global&quot;</span><span class="s0">,</span>
              <span class="s1">inside: node.value</span><span class="s0">,</span>
              <span class="s1">hasLocals: </span><span class="s0">false,</span>
              <span class="s1">explicit: </span><span class="s0">true,</span>
            <span class="s1">}</span><span class="s0">;</span>

            <span class="s1">newNodes = node</span>
              <span class="s1">.map((childNode) =&gt; transform(childNode</span><span class="s0">, </span><span class="s1">childContext))</span>
              <span class="s1">.reduce((acc</span><span class="s0">, </span><span class="s1">next) =&gt; acc.concat(next.nodes)</span><span class="s0">, </span><span class="s1">[])</span><span class="s0">;</span>

            <span class="s0">if </span><span class="s1">(newNodes.length) {</span>
              <span class="s0">const </span><span class="s1">{ before</span><span class="s0">, </span><span class="s1">after } = node.spaces</span><span class="s0">;</span>

              <span class="s0">const </span><span class="s1">first = newNodes[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">;</span>
              <span class="s0">const </span><span class="s1">last = newNodes[newNodes.length - </span><span class="s3">1</span><span class="s1">]</span><span class="s0">;</span>

              <span class="s1">first.spaces = { before</span><span class="s0">, </span><span class="s1">after: first.spaces.after }</span><span class="s0">;</span>
              <span class="s1">last.spaces = { before: last.spaces.before</span><span class="s0">, </span><span class="s1">after }</span><span class="s0">;</span>
            <span class="s1">}</span>

            <span class="s1">node = newNodes</span><span class="s0">;</span>

            <span class="s0">break;</span>
          <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
            <span class="s1">childContext = {</span>
              <span class="s1">global: context.global</span><span class="s0">,</span>
              <span class="s1">inside: context.inside</span><span class="s0">,</span>
              <span class="s1">lastWasSpacing: </span><span class="s0">true,</span>
              <span class="s1">hasLocals: </span><span class="s0">false,</span>
              <span class="s1">explicit: context.explicit</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">;</span>
            <span class="s1">newNodes = node.map((childNode) =&gt;</span>
              <span class="s1">transform(childNode</span><span class="s0">, </span><span class="s1">childContext)</span>
            <span class="s1">)</span><span class="s0">;</span>

            <span class="s1">node = node.clone()</span><span class="s0">;</span>
            <span class="s1">node.nodes = normalizeNodeArray(newNodes)</span><span class="s0">;</span>

            <span class="s0">if </span><span class="s1">(childContext.hasLocals) {</span>
              <span class="s1">context.hasLocals = </span><span class="s0">true;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
          <span class="s0">break;</span>

          <span class="s4">//:local .foo .bar</span>
        <span class="s1">} </span><span class="s0">else if </span><span class="s1">(isScoped) {</span>
          <span class="s0">if </span><span class="s1">(context.inside) {</span>
            <span class="s0">throw new </span><span class="s1">Error(</span>
              <span class="s2">`A </span><span class="s1">${node.value} </span><span class="s2">is not allowed inside of a </span><span class="s1">${context.inside}</span><span class="s2">(...)`</span>
            <span class="s1">)</span><span class="s0">;</span>
          <span class="s1">}</span>

          <span class="s0">const </span><span class="s1">addBackSpacing = !!node.spaces.before</span><span class="s0">;</span>

          <span class="s1">context.ignoreNextSpacing = context.lastWasSpacing</span>
            <span class="s1">? node.value</span>
            <span class="s1">: </span><span class="s0">false;</span>

          <span class="s1">context.enforceNoSpacing = context.lastWasSpacing</span>
            <span class="s1">? </span><span class="s0">false</span>
            <span class="s1">: node.value</span><span class="s0">;</span>

          <span class="s1">context.global = node.value === </span><span class="s2">&quot;:global&quot;</span><span class="s0">;</span>
          <span class="s1">context.explicit = </span><span class="s0">true;</span>

          <span class="s4">// because this node has spacing that is lost when we remove it</span>
          <span class="s4">// we make up for it by adding an extra combinator in since adding</span>
          <span class="s4">// spacing on the parent selector doesn't work</span>
          <span class="s0">return </span><span class="s1">addBackSpacing</span>
            <span class="s1">? selectorParser$1.combinator({ value: </span><span class="s2">&quot; &quot; </span><span class="s1">})</span>
            <span class="s1">: </span><span class="s0">null;</span>
        <span class="s1">}</span>
        <span class="s0">break;</span>
      <span class="s1">}</span>
      <span class="s0">case </span><span class="s2">&quot;id&quot;</span><span class="s1">:</span>
      <span class="s0">case </span><span class="s2">&quot;class&quot;</span><span class="s1">: {</span>
        <span class="s0">if </span><span class="s1">(!node.value) {</span>
          <span class="s0">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Invalid class or id selector syntax&quot;</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s1">}</span>

        <span class="s0">if </span><span class="s1">(context.global) {</span>
          <span class="s0">break;</span>
        <span class="s1">}</span>

        <span class="s0">const </span><span class="s1">isImportedValue = localAliasMap.has(node.value)</span><span class="s0">;</span>
        <span class="s0">const </span><span class="s1">isImportedWithExplicitScope = isImportedValue &amp;&amp; context.explicit</span><span class="s0">;</span>

        <span class="s0">if </span><span class="s1">(!isImportedValue || isImportedWithExplicitScope) {</span>
          <span class="s0">const </span><span class="s1">innerNode = node.clone()</span><span class="s0">;</span>
          <span class="s1">innerNode.spaces = { before: </span><span class="s2">&quot;&quot;</span><span class="s0">, </span><span class="s1">after: </span><span class="s2">&quot;&quot; </span><span class="s1">}</span><span class="s0">;</span>

          <span class="s1">node = selectorParser$1.pseudo({</span>
            <span class="s1">value: </span><span class="s2">&quot;:local&quot;</span><span class="s0">,</span>
            <span class="s1">nodes: [innerNode]</span><span class="s0">,</span>
            <span class="s1">spaces: node.spaces</span><span class="s0">,</span>
          <span class="s1">})</span><span class="s0">;</span>

          <span class="s1">context.hasLocals = </span><span class="s0">true;</span>
        <span class="s1">}</span>

        <span class="s0">break;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">context.lastWasSpacing = </span><span class="s0">false;</span>
    <span class="s1">context.ignoreNextSpacing = </span><span class="s0">false;</span>
    <span class="s1">context.enforceNoSpacing = </span><span class="s0">false;</span>

    <span class="s0">return </span><span class="s1">node</span><span class="s0">;</span>
  <span class="s1">}</span><span class="s0">;</span>

  <span class="s0">const </span><span class="s1">rootContext = {</span>
    <span class="s1">global: mode === </span><span class="s2">&quot;global&quot;</span><span class="s0">,</span>
    <span class="s1">hasPureGlobals: </span><span class="s0">false,</span>
  <span class="s1">}</span><span class="s0">;</span>

  <span class="s1">rootContext.selector = selectorParser$1((root) =&gt; {</span>
    <span class="s1">transform(root</span><span class="s0">, </span><span class="s1">rootContext)</span><span class="s0">;</span>
  <span class="s1">}).processSync(rule</span><span class="s0">, </span><span class="s1">{ updateSelector: </span><span class="s0">false, </span><span class="s1">lossless: </span><span class="s0">true </span><span class="s1">})</span><span class="s0">;</span>

  <span class="s0">return </span><span class="s1">rootContext</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">localizeDeclNode(node</span><span class="s0">, </span><span class="s1">context) {</span>
  <span class="s0">switch </span><span class="s1">(node.type) {</span>
    <span class="s0">case </span><span class="s2">&quot;word&quot;</span><span class="s1">:</span>
      <span class="s0">if </span><span class="s1">(context.localizeNextItem) {</span>
        <span class="s0">if </span><span class="s1">(!context.localAliasMap.has(node.value)) {</span>
          <span class="s1">node.value = </span><span class="s2">&quot;:local(&quot; </span><span class="s1">+ node.value + </span><span class="s2">&quot;)&quot;</span><span class="s0">;</span>
          <span class="s1">context.localizeNextItem = </span><span class="s0">false;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s0">break;</span>

    <span class="s0">case </span><span class="s2">&quot;function&quot;</span><span class="s1">:</span>
      <span class="s0">if </span><span class="s1">(</span>
        <span class="s1">context.options &amp;&amp;</span>
        <span class="s1">context.options.rewriteUrl &amp;&amp;</span>
        <span class="s1">node.value.toLowerCase() === </span><span class="s2">&quot;url&quot;</span>
      <span class="s1">) {</span>
        <span class="s1">node.nodes.map((nestedNode) =&gt; {</span>
          <span class="s0">if </span><span class="s1">(nestedNode.type !== </span><span class="s2">&quot;string&quot; </span><span class="s1">&amp;&amp; nestedNode.type !== </span><span class="s2">&quot;word&quot;</span><span class="s1">) {</span>
            <span class="s0">return;</span>
          <span class="s1">}</span>

          <span class="s0">let </span><span class="s1">newUrl = context.options.rewriteUrl(</span>
            <span class="s1">context.global</span><span class="s0">,</span>
            <span class="s1">nestedNode.value</span>
          <span class="s1">)</span><span class="s0">;</span>

          <span class="s0">switch </span><span class="s1">(nestedNode.type) {</span>
            <span class="s0">case </span><span class="s2">&quot;string&quot;</span><span class="s1">:</span>
              <span class="s0">if </span><span class="s1">(nestedNode.quote === </span><span class="s2">&quot;'&quot;</span><span class="s1">) {</span>
                <span class="s1">newUrl = newUrl.replace(</span><span class="s3">/(\\)/g</span><span class="s0">, </span><span class="s2">&quot;</span><span class="s0">\\</span><span class="s2">$1&quot;</span><span class="s1">).replace(</span><span class="s3">/'/g</span><span class="s0">, </span><span class="s2">&quot;</span><span class="s0">\\</span><span class="s2">'&quot;</span><span class="s1">)</span><span class="s0">;</span>
              <span class="s1">}</span>

              <span class="s0">if </span><span class="s1">(nestedNode.quote === </span><span class="s2">'&quot;'</span><span class="s1">) {</span>
                <span class="s1">newUrl = newUrl.replace(</span><span class="s3">/(\\)/g</span><span class="s0">, </span><span class="s2">&quot;</span><span class="s0">\\</span><span class="s2">$1&quot;</span><span class="s1">).replace(</span><span class="s3">/&quot;/g</span><span class="s0">, </span><span class="s2">'</span><span class="s0">\\</span><span class="s2">&quot;'</span><span class="s1">)</span><span class="s0">;</span>
              <span class="s1">}</span>

              <span class="s0">break;</span>
            <span class="s0">case </span><span class="s2">&quot;word&quot;</span><span class="s1">:</span>
              <span class="s1">newUrl = newUrl.replace(</span><span class="s3">/(&quot;|'|\)|\\)/g</span><span class="s0">, </span><span class="s2">&quot;</span><span class="s0">\\</span><span class="s2">$1&quot;</span><span class="s1">)</span><span class="s0">;</span>
              <span class="s0">break;</span>
          <span class="s1">}</span>

          <span class="s1">nestedNode.value = newUrl</span><span class="s0">;</span>
        <span class="s1">})</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">break;</span>
  <span class="s1">}</span>
  <span class="s0">return </span><span class="s1">node</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">isWordAFunctionArgument(wordNode</span><span class="s0">, </span><span class="s1">functionNode) {</span>
  <span class="s0">return </span><span class="s1">functionNode</span>
    <span class="s1">? functionNode.nodes.some(</span>
        <span class="s1">(functionNodeChild) =&gt;</span>
          <span class="s1">functionNodeChild.sourceIndex === wordNode.sourceIndex</span>
      <span class="s1">)</span>
    <span class="s1">: </span><span class="s0">false;</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">localizeDeclarationValues(localize</span><span class="s0">, </span><span class="s1">declaration</span><span class="s0">, </span><span class="s1">context) {</span>
  <span class="s0">const </span><span class="s1">valueNodes = valueParser(declaration.value)</span><span class="s0">;</span>

  <span class="s1">valueNodes.walk((node</span><span class="s0">, </span><span class="s1">index</span><span class="s0">, </span><span class="s1">nodes) =&gt; {</span>
    <span class="s0">const </span><span class="s1">subContext = {</span>
      <span class="s1">options: context.options</span><span class="s0">,</span>
      <span class="s1">global: context.global</span><span class="s0">,</span>
      <span class="s1">localizeNextItem: localize &amp;&amp; !context.global</span><span class="s0">,</span>
      <span class="s1">localAliasMap: context.localAliasMap</span><span class="s0">,</span>
    <span class="s1">}</span><span class="s0">;</span>
    <span class="s1">nodes[index] = localizeDeclNode(node</span><span class="s0">, </span><span class="s1">subContext)</span><span class="s0">;</span>
  <span class="s1">})</span><span class="s0">;</span>

  <span class="s1">declaration.value = valueNodes.toString()</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">localizeDeclaration(declaration</span><span class="s0">, </span><span class="s1">context) {</span>
  <span class="s0">const </span><span class="s1">isAnimation = </span><span class="s3">/animation$/i</span><span class="s1">.test(declaration.prop)</span><span class="s0">;</span>

  <span class="s0">if </span><span class="s1">(isAnimation) {</span>
    <span class="s0">const </span><span class="s1">validIdent = </span><span class="s3">/^-?[_a-z][_a-z0-9-]*$/i</span><span class="s0">;</span>

    <span class="s4">/* 
    The spec defines some keywords that you can use to describe properties such as the timing 
    function. These are still valid animation names, so as long as there is a property that accepts 
    a keyword, it is given priority. Only when all the properties that can take a keyword are 
    exhausted can the animation name be set to the keyword. I.e. 
   
    animation: infinite infinite; 
   
    The animation will repeat an infinite number of times from the first argument, and will have an 
    animation name of infinite from the second. 
    */</span>
    <span class="s0">const </span><span class="s1">animationKeywords = {</span>
      <span class="s1">$alternate: </span><span class="s3">1</span><span class="s0">,</span>
      <span class="s2">&quot;$alternate-reverse&quot;</span><span class="s1">: </span><span class="s3">1</span><span class="s0">,</span>
      <span class="s1">$backwards: </span><span class="s3">1</span><span class="s0">,</span>
      <span class="s1">$both: </span><span class="s3">1</span><span class="s0">,</span>
      <span class="s1">$ease: </span><span class="s3">1</span><span class="s0">,</span>
      <span class="s2">&quot;$ease-in&quot;</span><span class="s1">: </span><span class="s3">1</span><span class="s0">,</span>
      <span class="s2">&quot;$ease-in-out&quot;</span><span class="s1">: </span><span class="s3">1</span><span class="s0">,</span>
      <span class="s2">&quot;$ease-out&quot;</span><span class="s1">: </span><span class="s3">1</span><span class="s0">,</span>
      <span class="s1">$forwards: </span><span class="s3">1</span><span class="s0">,</span>
      <span class="s1">$infinite: </span><span class="s3">1</span><span class="s0">,</span>
      <span class="s1">$linear: </span><span class="s3">1</span><span class="s0">,</span>
      <span class="s1">$none: Infinity</span><span class="s0">, </span><span class="s4">// No matter how many times you write none, it will never be an animation name</span>
      <span class="s1">$normal: </span><span class="s3">1</span><span class="s0">,</span>
      <span class="s1">$paused: </span><span class="s3">1</span><span class="s0">,</span>
      <span class="s1">$reverse: </span><span class="s3">1</span><span class="s0">,</span>
      <span class="s1">$running: </span><span class="s3">1</span><span class="s0">,</span>
      <span class="s2">&quot;$step-end&quot;</span><span class="s1">: </span><span class="s3">1</span><span class="s0">,</span>
      <span class="s2">&quot;$step-start&quot;</span><span class="s1">: </span><span class="s3">1</span><span class="s0">,</span>
      <span class="s1">$initial: Infinity</span><span class="s0">,</span>
      <span class="s1">$inherit: Infinity</span><span class="s0">,</span>
      <span class="s1">$unset: Infinity</span><span class="s0">,</span>
    <span class="s1">}</span><span class="s0">;</span>
    <span class="s0">let </span><span class="s1">parsedAnimationKeywords = {}</span><span class="s0">;</span>
    <span class="s0">let </span><span class="s1">stepsFunctionNode = </span><span class="s0">null;</span>
    <span class="s0">const </span><span class="s1">valueNodes = valueParser(declaration.value).walk((node) =&gt; {</span>
      <span class="s4">/* If div-token appeared (represents as comma ','), a possibility of an animation-keywords should be reflesh. */</span>
      <span class="s0">if </span><span class="s1">(node.type === </span><span class="s2">&quot;div&quot;</span><span class="s1">) {</span>
        <span class="s1">parsedAnimationKeywords = {}</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">if </span><span class="s1">(node.type === </span><span class="s2">&quot;function&quot; </span><span class="s1">&amp;&amp; node.value.toLowerCase() === </span><span class="s2">&quot;steps&quot;</span><span class="s1">) {</span>
        <span class="s1">stepsFunctionNode = node</span><span class="s0">;</span>
      <span class="s1">}</span>
      <span class="s0">const </span><span class="s1">value =</span>
        <span class="s1">node.type === </span><span class="s2">&quot;word&quot; </span><span class="s1">&amp;&amp;</span>
        <span class="s1">!isWordAFunctionArgument(node</span><span class="s0">, </span><span class="s1">stepsFunctionNode)</span>
          <span class="s1">? node.value.toLowerCase()</span>
          <span class="s1">: </span><span class="s0">null;</span>

      <span class="s0">let </span><span class="s1">shouldParseAnimationName = </span><span class="s0">false;</span>

      <span class="s0">if </span><span class="s1">(value &amp;&amp; validIdent.test(value)) {</span>
        <span class="s0">if </span><span class="s1">(</span><span class="s2">&quot;$&quot; </span><span class="s1">+ value </span><span class="s0">in </span><span class="s1">animationKeywords) {</span>
          <span class="s1">parsedAnimationKeywords[</span><span class="s2">&quot;$&quot; </span><span class="s1">+ value] =</span>
            <span class="s2">&quot;$&quot; </span><span class="s1">+ value </span><span class="s0">in </span><span class="s1">parsedAnimationKeywords</span>
              <span class="s1">? parsedAnimationKeywords[</span><span class="s2">&quot;$&quot; </span><span class="s1">+ value] + </span><span class="s3">1</span>
              <span class="s1">: </span><span class="s3">0</span><span class="s0">;</span>

          <span class="s1">shouldParseAnimationName =</span>
            <span class="s1">parsedAnimationKeywords[</span><span class="s2">&quot;$&quot; </span><span class="s1">+ value] &gt;=</span>
            <span class="s1">animationKeywords[</span><span class="s2">&quot;$&quot; </span><span class="s1">+ value]</span><span class="s0">;</span>
        <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
          <span class="s1">shouldParseAnimationName = </span><span class="s0">true;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s0">const </span><span class="s1">subContext = {</span>
        <span class="s1">options: context.options</span><span class="s0">,</span>
        <span class="s1">global: context.global</span><span class="s0">,</span>
        <span class="s1">localizeNextItem: shouldParseAnimationName &amp;&amp; !context.global</span><span class="s0">,</span>
        <span class="s1">localAliasMap: context.localAliasMap</span><span class="s0">,</span>
      <span class="s1">}</span><span class="s0">;</span>
      <span class="s0">return </span><span class="s1">localizeDeclNode(node</span><span class="s0">, </span><span class="s1">subContext)</span><span class="s0">;</span>
    <span class="s1">})</span><span class="s0">;</span>

    <span class="s1">declaration.value = valueNodes.toString()</span><span class="s0">;</span>

    <span class="s0">return;</span>
  <span class="s1">}</span>

  <span class="s0">const </span><span class="s1">isAnimationName = </span><span class="s3">/animation(-name)?$/i</span><span class="s1">.test(declaration.prop)</span><span class="s0">;</span>

  <span class="s0">if </span><span class="s1">(isAnimationName) {</span>
    <span class="s0">return </span><span class="s1">localizeDeclarationValues(</span><span class="s0">true, </span><span class="s1">declaration</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
  <span class="s1">}</span>

  <span class="s0">const </span><span class="s1">hasUrl = </span><span class="s3">/url\(/i</span><span class="s1">.test(declaration.value)</span><span class="s0">;</span>

  <span class="s0">if </span><span class="s1">(hasUrl) {</span>
    <span class="s0">return </span><span class="s1">localizeDeclarationValues(</span><span class="s0">false, </span><span class="s1">declaration</span><span class="s0">, </span><span class="s1">context)</span><span class="s0">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">src$2.exports = (options = {}) =&gt; {</span>
  <span class="s0">if </span><span class="s1">(</span>
    <span class="s1">options &amp;&amp;</span>
    <span class="s1">options.mode &amp;&amp;</span>
    <span class="s1">options.mode !== </span><span class="s2">&quot;global&quot; </span><span class="s1">&amp;&amp;</span>
    <span class="s1">options.mode !== </span><span class="s2">&quot;local&quot; </span><span class="s1">&amp;&amp;</span>
    <span class="s1">options.mode !== </span><span class="s2">&quot;pure&quot;</span>
  <span class="s1">) {</span>
    <span class="s0">throw new </span><span class="s1">Error(</span>
      <span class="s2">'options.mode must be either &quot;global&quot;, &quot;local&quot; or &quot;pure&quot; (default &quot;local&quot;)'</span>
    <span class="s1">)</span><span class="s0">;</span>
  <span class="s1">}</span>

  <span class="s0">const </span><span class="s1">pureMode = options &amp;&amp; options.mode === </span><span class="s2">&quot;pure&quot;</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">globalMode = options &amp;&amp; options.mode === </span><span class="s2">&quot;global&quot;</span><span class="s0">;</span>

  <span class="s0">return </span><span class="s1">{</span>
    <span class="s1">postcssPlugin: </span><span class="s2">&quot;postcss-modules-local-by-default&quot;</span><span class="s0">,</span>
    <span class="s1">prepare() {</span>
      <span class="s0">const </span><span class="s1">localAliasMap = </span><span class="s0">new </span><span class="s1">Map()</span><span class="s0">;</span>

      <span class="s0">return </span><span class="s1">{</span>
        <span class="s1">Once(root) {</span>
          <span class="s0">const </span><span class="s1">{ icssImports } = extractICSS(root</span><span class="s0">, false</span><span class="s1">)</span><span class="s0">;</span>

          <span class="s1">Object.keys(icssImports).forEach((key) =&gt; {</span>
            <span class="s1">Object.keys(icssImports[key]).forEach((prop) =&gt; {</span>
              <span class="s1">localAliasMap.set(prop</span><span class="s0">, </span><span class="s1">icssImports[key][prop])</span><span class="s0">;</span>
            <span class="s1">})</span><span class="s0">;</span>
          <span class="s1">})</span><span class="s0">;</span>

          <span class="s1">root.walkAtRules((atRule) =&gt; {</span>
            <span class="s0">if </span><span class="s1">(</span><span class="s3">/keyframes$/i</span><span class="s1">.test(atRule.name)) {</span>
              <span class="s0">const </span><span class="s1">globalMatch = </span><span class="s3">/^\s*:global\s*\((.+)\)\s*$/</span><span class="s1">.exec(</span>
                <span class="s1">atRule.params</span>
              <span class="s1">)</span><span class="s0">;</span>
              <span class="s0">const </span><span class="s1">localMatch = </span><span class="s3">/^\s*:local\s*\((.+)\)\s*$/</span><span class="s1">.exec(</span>
                <span class="s1">atRule.params</span>
              <span class="s1">)</span><span class="s0">;</span>

              <span class="s0">let </span><span class="s1">globalKeyframes = globalMode</span><span class="s0">;</span>

              <span class="s0">if </span><span class="s1">(globalMatch) {</span>
                <span class="s0">if </span><span class="s1">(pureMode) {</span>
                  <span class="s0">throw </span><span class="s1">atRule.error(</span>
                    <span class="s2">&quot;@keyframes :global(...) is not allowed in pure mode&quot;</span>
                  <span class="s1">)</span><span class="s0">;</span>
                <span class="s1">}</span>
                <span class="s1">atRule.params = globalMatch[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">;</span>
                <span class="s1">globalKeyframes = </span><span class="s0">true;</span>
              <span class="s1">} </span><span class="s0">else if </span><span class="s1">(localMatch) {</span>
                <span class="s1">atRule.params = localMatch[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">;</span>
                <span class="s1">globalKeyframes = </span><span class="s0">false;</span>
              <span class="s1">} </span><span class="s0">else if </span><span class="s1">(!globalMode) {</span>
                <span class="s0">if </span><span class="s1">(atRule.params &amp;&amp; !localAliasMap.has(atRule.params)) {</span>
                  <span class="s1">atRule.params = </span><span class="s2">&quot;:local(&quot; </span><span class="s1">+ atRule.params + </span><span class="s2">&quot;)&quot;</span><span class="s0">;</span>
                <span class="s1">}</span>
              <span class="s1">}</span>

              <span class="s1">atRule.walkDecls((declaration) =&gt; {</span>
                <span class="s1">localizeDeclaration(declaration</span><span class="s0">, </span><span class="s1">{</span>
                  <span class="s1">localAliasMap</span><span class="s0">,</span>
                  <span class="s1">options: options</span><span class="s0">,</span>
                  <span class="s1">global: globalKeyframes</span><span class="s0">,</span>
                <span class="s1">})</span><span class="s0">;</span>
              <span class="s1">})</span><span class="s0">;</span>
            <span class="s1">} </span><span class="s0">else if </span><span class="s1">(atRule.nodes) {</span>
              <span class="s1">atRule.nodes.forEach((declaration) =&gt; {</span>
                <span class="s0">if </span><span class="s1">(declaration.type === </span><span class="s2">&quot;decl&quot;</span><span class="s1">) {</span>
                  <span class="s1">localizeDeclaration(declaration</span><span class="s0">, </span><span class="s1">{</span>
                    <span class="s1">localAliasMap</span><span class="s0">,</span>
                    <span class="s1">options: options</span><span class="s0">,</span>
                    <span class="s1">global: globalMode</span><span class="s0">,</span>
                  <span class="s1">})</span><span class="s0">;</span>
                <span class="s1">}</span>
              <span class="s1">})</span><span class="s0">;</span>
            <span class="s1">}</span>
          <span class="s1">})</span><span class="s0">;</span>

          <span class="s1">root.walkRules((rule) =&gt; {</span>
            <span class="s0">if </span><span class="s1">(</span>
              <span class="s1">rule.parent &amp;&amp;</span>
              <span class="s1">rule.parent.type === </span><span class="s2">&quot;atrule&quot; </span><span class="s1">&amp;&amp;</span>
              <span class="s3">/keyframes$/i</span><span class="s1">.test(rule.parent.name)</span>
            <span class="s1">) {</span>
              <span class="s4">// ignore keyframe rules</span>
              <span class="s0">return;</span>
            <span class="s1">}</span>

            <span class="s0">const </span><span class="s1">context = localizeNode(rule</span><span class="s0">, </span><span class="s1">options.mode</span><span class="s0">, </span><span class="s1">localAliasMap)</span><span class="s0">;</span>

            <span class="s1">context.options = options</span><span class="s0">;</span>
            <span class="s1">context.localAliasMap = localAliasMap</span><span class="s0">;</span>

            <span class="s0">if </span><span class="s1">(pureMode &amp;&amp; context.hasPureGlobals) {</span>
              <span class="s0">throw </span><span class="s1">rule.error(</span>
                <span class="s2">'Selector &quot;' </span><span class="s1">+</span>
                  <span class="s1">rule.selector +</span>
                  <span class="s2">'&quot; is not pure ' </span><span class="s1">+</span>
                  <span class="s2">&quot;(pure selectors must contain at least one local class or id)&quot;</span>
              <span class="s1">)</span><span class="s0">;</span>
            <span class="s1">}</span>

            <span class="s1">rule.selector = context.selector</span><span class="s0">;</span>

            <span class="s4">// Less-syntax mixins parse as rules with no nodes</span>
            <span class="s0">if </span><span class="s1">(rule.nodes) {</span>
              <span class="s1">rule.nodes.forEach((declaration) =&gt;</span>
                <span class="s1">localizeDeclaration(declaration</span><span class="s0">, </span><span class="s1">context)</span>
              <span class="s1">)</span><span class="s0">;</span>
            <span class="s1">}</span>
          <span class="s1">})</span><span class="s0">;</span>
        <span class="s1">}</span><span class="s0">,</span>
      <span class="s1">}</span><span class="s0">;</span>
    <span class="s1">}</span><span class="s0">,</span>
  <span class="s1">}</span><span class="s0">;</span>
<span class="s1">}</span><span class="s0">;</span>
<span class="s1">srcExports$1.postcss = </span><span class="s0">true;</span>

<span class="s0">const </span><span class="s1">selectorParser = distExports</span><span class="s0">;</span>

<span class="s0">const </span><span class="s1">hasOwnProperty = Object.prototype.hasOwnProperty</span><span class="s0">;</span>

<span class="s0">function </span><span class="s1">getSingleLocalNamesForComposes(root) {</span>
  <span class="s0">return </span><span class="s1">root.nodes.map((node) =&gt; {</span>
    <span class="s0">if </span><span class="s1">(node.type !== </span><span class="s2">&quot;selector&quot; </span><span class="s1">|| node.nodes.length !== </span><span class="s3">1</span><span class="s1">) {</span>
      <span class="s0">throw new </span><span class="s1">Error(</span>
        <span class="s2">`composition is only allowed when selector is single :local class name not in &quot;</span><span class="s1">${root}</span><span class="s2">&quot;`</span>
      <span class="s1">)</span><span class="s0">;</span>
    <span class="s1">}</span>

    <span class="s1">node = node.nodes[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">;</span>

    <span class="s0">if </span><span class="s1">(</span>
      <span class="s1">node.type !== </span><span class="s2">&quot;pseudo&quot; </span><span class="s1">||</span>
      <span class="s1">node.value !== </span><span class="s2">&quot;:local&quot; </span><span class="s1">||</span>
      <span class="s1">node.nodes.length !== </span><span class="s3">1</span>
    <span class="s1">) {</span>
      <span class="s0">throw new </span><span class="s1">Error(</span>
        <span class="s2">'composition is only allowed when selector is single :local class name not in &quot;' </span><span class="s1">+</span>
          <span class="s1">root +</span>
          <span class="s2">'&quot;, &quot;' </span><span class="s1">+</span>
          <span class="s1">node +</span>
          <span class="s2">'&quot; is weird'</span>
      <span class="s1">)</span><span class="s0">;</span>
    <span class="s1">}</span>

    <span class="s1">node = node.first</span><span class="s0">;</span>

    <span class="s0">if </span><span class="s1">(node.type !== </span><span class="s2">&quot;selector&quot; </span><span class="s1">|| node.length !== </span><span class="s3">1</span><span class="s1">) {</span>
      <span class="s0">throw new </span><span class="s1">Error(</span>
        <span class="s2">'composition is only allowed when selector is single :local class name not in &quot;' </span><span class="s1">+</span>
          <span class="s1">root +</span>
          <span class="s2">'&quot;, &quot;' </span><span class="s1">+</span>
          <span class="s1">node +</span>
          <span class="s2">'&quot; is weird'</span>
      <span class="s1">)</span><span class="s0">;</span>
    <span class="s1">}</span>

    <span class="s1">node = node.first</span><span class="s0">;</span>

    <span class="s0">if </span><span class="s1">(node.type !== </span><span class="s2">&quot;class&quot;</span><span class="s1">) {</span>
      <span class="s4">// 'id' is not possible, because you can't compose ids</span>
      <span class="s0">throw new </span><span class="s1">Error(</span>
        <span class="s2">'composition is only allowed when selector is single :local class name not in &quot;' </span><span class="s1">+</span>
          <span class="s1">root +</span>
          <span class="s2">'&quot;, &quot;' </span><span class="s1">+</span>
          <span class="s1">node +</span>
          <span class="s2">'&quot; is weird'</span>
      <span class="s1">)</span><span class="s0">;</span>
    <span class="s1">}</span>

    <span class="s0">return </span><span class="s1">node.value</span><span class="s0">;</span>
  <span class="s1">})</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">const </span><span class="s1">whitespace = </span><span class="s2">&quot;[</span><span class="s0">\\</span><span class="s2">x20</span><span class="s0">\\</span><span class="s2">t</span><span class="s0">\\</span><span class="s2">r</span><span class="s0">\\</span><span class="s2">n</span><span class="s0">\\</span><span class="s2">f]&quot;</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">unescapeRegExp = </span><span class="s0">new </span><span class="s1">RegExp(</span>
  <span class="s2">&quot;</span><span class="s0">\\\\</span><span class="s2">([</span><span class="s0">\\</span><span class="s2">da-f]{1,6}&quot; </span><span class="s1">+ whitespace + </span><span class="s2">&quot;?|(&quot; </span><span class="s1">+ whitespace + </span><span class="s2">&quot;)|.)&quot;</span><span class="s0">,</span>
  <span class="s2">&quot;ig&quot;</span>
<span class="s1">)</span><span class="s0">;</span>

<span class="s0">function </span><span class="s1">unescape(str) {</span>
  <span class="s0">return </span><span class="s1">str.replace(unescapeRegExp</span><span class="s0">, </span><span class="s1">(_</span><span class="s0">, </span><span class="s1">escaped</span><span class="s0">, </span><span class="s1">escapedWhitespace) =&gt; {</span>
    <span class="s0">const </span><span class="s1">high = </span><span class="s2">&quot;0x&quot; </span><span class="s1">+ escaped - </span><span class="s3">0x10000</span><span class="s0">;</span>

    <span class="s4">// NaN means non-codepoint</span>
    <span class="s4">// Workaround erroneous numeric interpretation of +&quot;0x&quot;</span>
    <span class="s0">return </span><span class="s1">high !== high || escapedWhitespace</span>
      <span class="s1">? escaped</span>
      <span class="s1">: high &lt; </span><span class="s3">0</span>
      <span class="s1">? </span><span class="s4">// BMP codepoint</span>
        <span class="s1">String.fromCharCode(high + </span><span class="s3">0x10000</span><span class="s1">)</span>
      <span class="s1">: </span><span class="s4">// Supplemental Plane codepoint (surrogate pair)</span>
        <span class="s1">String.fromCharCode((high &gt;&gt; </span><span class="s3">10</span><span class="s1">) | </span><span class="s3">0xd800</span><span class="s0">, </span><span class="s1">(high &amp; </span><span class="s3">0x3ff</span><span class="s1">) | </span><span class="s3">0xdc00</span><span class="s1">)</span><span class="s0">;</span>
  <span class="s1">})</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">const </span><span class="s1">plugin = (options = {}) =&gt; {</span>
  <span class="s0">const </span><span class="s1">generateScopedName =</span>
    <span class="s1">(options &amp;&amp; options.generateScopedName) || plugin.generateScopedName</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">generateExportEntry =</span>
    <span class="s1">(options &amp;&amp; options.generateExportEntry) || plugin.generateExportEntry</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">exportGlobals = options &amp;&amp; options.exportGlobals</span><span class="s0">;</span>

  <span class="s0">return </span><span class="s1">{</span>
    <span class="s1">postcssPlugin: </span><span class="s2">&quot;postcss-modules-scope&quot;</span><span class="s0">,</span>
    <span class="s1">Once(root</span><span class="s0">, </span><span class="s1">{ rule }) {</span>
      <span class="s0">const </span><span class="s1">exports = Object.create(</span><span class="s0">null</span><span class="s1">)</span><span class="s0">;</span>

      <span class="s0">function </span><span class="s1">exportScopedName(name</span><span class="s0">, </span><span class="s1">rawName) {</span>
        <span class="s0">const </span><span class="s1">scopedName = generateScopedName(</span>
          <span class="s1">rawName ? rawName : name</span><span class="s0">,</span>
          <span class="s1">root.source.input.from</span><span class="s0">,</span>
          <span class="s1">root.source.input.css</span>
        <span class="s1">)</span><span class="s0">;</span>
        <span class="s0">const </span><span class="s1">exportEntry = generateExportEntry(</span>
          <span class="s1">rawName ? rawName : name</span><span class="s0">,</span>
          <span class="s1">scopedName</span><span class="s0">,</span>
          <span class="s1">root.source.input.from</span><span class="s0">,</span>
          <span class="s1">root.source.input.css</span>
        <span class="s1">)</span><span class="s0">;</span>
        <span class="s0">const </span><span class="s1">{ key</span><span class="s0">, </span><span class="s1">value } = exportEntry</span><span class="s0">;</span>

        <span class="s1">exports[key] = exports[key] || []</span><span class="s0">;</span>

        <span class="s0">if </span><span class="s1">(exports[key].indexOf(value) &lt; </span><span class="s3">0</span><span class="s1">) {</span>
          <span class="s1">exports[key].push(value)</span><span class="s0">;</span>
        <span class="s1">}</span>

        <span class="s0">return </span><span class="s1">scopedName</span><span class="s0">;</span>
      <span class="s1">}</span>

      <span class="s0">function </span><span class="s1">localizeNode(node) {</span>
        <span class="s0">switch </span><span class="s1">(node.type) {</span>
          <span class="s0">case </span><span class="s2">&quot;selector&quot;</span><span class="s1">:</span>
            <span class="s1">node.nodes = node.map(localizeNode)</span><span class="s0">;</span>
            <span class="s0">return </span><span class="s1">node</span><span class="s0">;</span>
          <span class="s0">case </span><span class="s2">&quot;class&quot;</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">selectorParser.className({</span>
              <span class="s1">value: exportScopedName(</span>
                <span class="s1">node.value</span><span class="s0">,</span>
                <span class="s1">node.raws &amp;&amp; node.raws.value ? node.raws.value : </span><span class="s0">null</span>
              <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">})</span><span class="s0">;</span>
          <span class="s0">case </span><span class="s2">&quot;id&quot;</span><span class="s1">: {</span>
            <span class="s0">return </span><span class="s1">selectorParser.id({</span>
              <span class="s1">value: exportScopedName(</span>
                <span class="s1">node.value</span><span class="s0">,</span>
                <span class="s1">node.raws &amp;&amp; node.raws.value ? node.raws.value : </span><span class="s0">null</span>
              <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">})</span><span class="s0">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s0">throw new </span><span class="s1">Error(</span>
          <span class="s2">`</span><span class="s1">${node.type} </span><span class="s2">(&quot;</span><span class="s1">${node}</span><span class="s2">&quot;) is not allowed in a :local block`</span>
        <span class="s1">)</span><span class="s0">;</span>
      <span class="s1">}</span>

      <span class="s0">function </span><span class="s1">traverseNode(node) {</span>
        <span class="s0">switch </span><span class="s1">(node.type) {</span>
          <span class="s0">case </span><span class="s2">&quot;pseudo&quot;</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">(node.value === </span><span class="s2">&quot;:local&quot;</span><span class="s1">) {</span>
              <span class="s0">if </span><span class="s1">(node.nodes.length !== </span><span class="s3">1</span><span class="s1">) {</span>
                <span class="s0">throw new </span><span class="s1">Error(</span><span class="s2">'Unexpected comma (&quot;,&quot;) in :local block'</span><span class="s1">)</span><span class="s0">;</span>
              <span class="s1">}</span>

              <span class="s0">const </span><span class="s1">selector = localizeNode(node.first)</span><span class="s0">;</span>
              <span class="s4">// move the spaces that were around the psuedo selector to the first</span>
              <span class="s4">// non-container node</span>
              <span class="s1">selector.first.spaces = node.spaces</span><span class="s0">;</span>

              <span class="s0">const </span><span class="s1">nextNode = node.next()</span><span class="s0">;</span>

              <span class="s0">if </span><span class="s1">(</span>
                <span class="s1">nextNode &amp;&amp;</span>
                <span class="s1">nextNode.type === </span><span class="s2">&quot;combinator&quot; </span><span class="s1">&amp;&amp;</span>
                <span class="s1">nextNode.value === </span><span class="s2">&quot; &quot; </span><span class="s1">&amp;&amp;</span>
                <span class="s3">/\\[A-F0-9]{1,6}$/</span><span class="s1">.test(selector.last.value)</span>
              <span class="s1">) {</span>
                <span class="s1">selector.last.spaces.after = </span><span class="s2">&quot; &quot;</span><span class="s0">;</span>
              <span class="s1">}</span>

              <span class="s1">node.replaceWith(selector)</span><span class="s0">;</span>

              <span class="s0">return;</span>
            <span class="s1">}</span>
          <span class="s4">/* falls through */</span>
          <span class="s0">case </span><span class="s2">&quot;root&quot;</span><span class="s1">:</span>
          <span class="s0">case </span><span class="s2">&quot;selector&quot;</span><span class="s1">: {</span>
            <span class="s1">node.each(traverseNode)</span><span class="s0">;</span>
            <span class="s0">break;</span>
          <span class="s1">}</span>
          <span class="s0">case </span><span class="s2">&quot;id&quot;</span><span class="s1">:</span>
          <span class="s0">case </span><span class="s2">&quot;class&quot;</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">(exportGlobals) {</span>
              <span class="s1">exports[node.value] = [node.value]</span><span class="s0">;</span>
            <span class="s1">}</span>
            <span class="s0">break;</span>
        <span class="s1">}</span>
        <span class="s0">return </span><span class="s1">node</span><span class="s0">;</span>
      <span class="s1">}</span>

      <span class="s4">// Find any :import and remember imported names</span>
      <span class="s0">const </span><span class="s1">importedNames = {}</span><span class="s0">;</span>

      <span class="s1">root.walkRules(</span><span class="s3">/^:import\(.+\)$/</span><span class="s0">, </span><span class="s1">(rule) =&gt; {</span>
        <span class="s1">rule.walkDecls((decl) =&gt; {</span>
          <span class="s1">importedNames[decl.prop] = </span><span class="s0">true;</span>
        <span class="s1">})</span><span class="s0">;</span>
      <span class="s1">})</span><span class="s0">;</span>

      <span class="s4">// Find any :local selectors</span>
      <span class="s1">root.walkRules((rule) =&gt; {</span>
        <span class="s0">let </span><span class="s1">parsedSelector = selectorParser().astSync(rule)</span><span class="s0">;</span>

        <span class="s1">rule.selector = traverseNode(parsedSelector.clone()).toString()</span><span class="s0">;</span>

        <span class="s1">rule.walkDecls(</span><span class="s3">/composes|compose-with/i</span><span class="s0">, </span><span class="s1">(decl) =&gt; {</span>
          <span class="s0">const </span><span class="s1">localNames = getSingleLocalNamesForComposes(parsedSelector)</span><span class="s0">;</span>
          <span class="s0">const </span><span class="s1">classes = decl.value.split(</span><span class="s3">/\s+/</span><span class="s1">)</span><span class="s0">;</span>

          <span class="s1">classes.forEach((className) =&gt; {</span>
            <span class="s0">const </span><span class="s1">global = </span><span class="s3">/^global\(([^)]+)\)$/</span><span class="s1">.exec(className)</span><span class="s0">;</span>

            <span class="s0">if </span><span class="s1">(global) {</span>
              <span class="s1">localNames.forEach((exportedName) =&gt; {</span>
                <span class="s1">exports[exportedName].push(global[</span><span class="s3">1</span><span class="s1">])</span><span class="s0">;</span>
              <span class="s1">})</span><span class="s0">;</span>
            <span class="s1">} </span><span class="s0">else if </span><span class="s1">(hasOwnProperty.call(importedNames</span><span class="s0">, </span><span class="s1">className)) {</span>
              <span class="s1">localNames.forEach((exportedName) =&gt; {</span>
                <span class="s1">exports[exportedName].push(className)</span><span class="s0">;</span>
              <span class="s1">})</span><span class="s0">;</span>
            <span class="s1">} </span><span class="s0">else if </span><span class="s1">(hasOwnProperty.call(exports</span><span class="s0">, </span><span class="s1">className)) {</span>
              <span class="s1">localNames.forEach((exportedName) =&gt; {</span>
                <span class="s1">exports[className].forEach((item) =&gt; {</span>
                  <span class="s1">exports[exportedName].push(item)</span><span class="s0">;</span>
                <span class="s1">})</span><span class="s0">;</span>
              <span class="s1">})</span><span class="s0">;</span>
            <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
              <span class="s0">throw </span><span class="s1">decl.error(</span>
                <span class="s2">`referenced class name &quot;</span><span class="s1">${className}</span><span class="s2">&quot; in </span><span class="s1">${decl.prop} </span><span class="s2">not found`</span>
              <span class="s1">)</span><span class="s0">;</span>
            <span class="s1">}</span>
          <span class="s1">})</span><span class="s0">;</span>

          <span class="s1">decl.remove()</span><span class="s0">;</span>
        <span class="s1">})</span><span class="s0">;</span>

        <span class="s4">// Find any :local values</span>
        <span class="s1">rule.walkDecls((decl) =&gt; {</span>
          <span class="s0">if </span><span class="s1">(!</span><span class="s3">/:local\s*\((.+?)\)/</span><span class="s1">.test(decl.value)) {</span>
            <span class="s0">return;</span>
          <span class="s1">}</span>

          <span class="s0">let </span><span class="s1">tokens = decl.value.split(</span><span class="s3">/(,|'[^']*'|&quot;[^&quot;]*&quot;)/</span><span class="s1">)</span><span class="s0">;</span>

          <span class="s1">tokens = tokens.map((token</span><span class="s0">, </span><span class="s1">idx) =&gt; {</span>
            <span class="s0">if </span><span class="s1">(idx === </span><span class="s3">0 </span><span class="s1">|| tokens[idx - </span><span class="s3">1</span><span class="s1">] === </span><span class="s2">&quot;,&quot;</span><span class="s1">) {</span>
              <span class="s0">let </span><span class="s1">result = token</span><span class="s0">;</span>

              <span class="s0">const </span><span class="s1">localMatch = </span><span class="s3">/:local\s*\((.+?)\)/</span><span class="s1">.exec(token)</span><span class="s0">;</span>

              <span class="s0">if </span><span class="s1">(localMatch) {</span>
                <span class="s0">const </span><span class="s1">input = localMatch.input</span><span class="s0">;</span>
                <span class="s0">const </span><span class="s1">matchPattern = localMatch[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">;</span>
                <span class="s0">const </span><span class="s1">matchVal = localMatch[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">;</span>
                <span class="s0">const </span><span class="s1">newVal = exportScopedName(matchVal)</span><span class="s0">;</span>

                <span class="s1">result = input.replace(matchPattern</span><span class="s0">, </span><span class="s1">newVal)</span><span class="s0">;</span>
              <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
                <span class="s0">return </span><span class="s1">token</span><span class="s0">;</span>
              <span class="s1">}</span>

              <span class="s0">return </span><span class="s1">result</span><span class="s0">;</span>
            <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
              <span class="s0">return </span><span class="s1">token</span><span class="s0">;</span>
            <span class="s1">}</span>
          <span class="s1">})</span><span class="s0">;</span>

          <span class="s1">decl.value = tokens.join(</span><span class="s2">&quot;&quot;</span><span class="s1">)</span><span class="s0">;</span>
        <span class="s1">})</span><span class="s0">;</span>
      <span class="s1">})</span><span class="s0">;</span>

      <span class="s4">// Find any :local keyframes</span>
      <span class="s1">root.walkAtRules(</span><span class="s3">/keyframes$/i</span><span class="s0">, </span><span class="s1">(atRule) =&gt; {</span>
        <span class="s0">const </span><span class="s1">localMatch = </span><span class="s3">/^\s*:local\s*\((.+?)\)\s*$/</span><span class="s1">.exec(atRule.params)</span><span class="s0">;</span>

        <span class="s0">if </span><span class="s1">(!localMatch) {</span>
          <span class="s0">return;</span>
        <span class="s1">}</span>

        <span class="s1">atRule.params = exportScopedName(localMatch[</span><span class="s3">1</span><span class="s1">])</span><span class="s0">;</span>
      <span class="s1">})</span><span class="s0">;</span>

      <span class="s4">// If we found any :locals, insert an :export rule</span>
      <span class="s0">const </span><span class="s1">exportedNames = Object.keys(exports)</span><span class="s0">;</span>

      <span class="s0">if </span><span class="s1">(exportedNames.length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
        <span class="s0">const </span><span class="s1">exportRule = rule({ selector: </span><span class="s2">&quot;:export&quot; </span><span class="s1">})</span><span class="s0">;</span>

        <span class="s1">exportedNames.forEach((exportedName) =&gt;</span>
          <span class="s1">exportRule.append({</span>
            <span class="s1">prop: exportedName</span><span class="s0">,</span>
            <span class="s1">value: exports[exportedName].join(</span><span class="s2">&quot; &quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">raws: { before: </span><span class="s2">&quot;</span><span class="s0">\n  </span><span class="s2">&quot; </span><span class="s1">}</span><span class="s0">,</span>
          <span class="s1">})</span>
        <span class="s1">)</span><span class="s0">;</span>

        <span class="s1">root.append(exportRule)</span><span class="s0">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span><span class="s0">,</span>
  <span class="s1">}</span><span class="s0">;</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s1">plugin.postcss = </span><span class="s0">true;</span>

<span class="s1">plugin.generateScopedName = </span><span class="s0">function </span><span class="s1">(name</span><span class="s0">, </span><span class="s1">path) {</span>
  <span class="s0">const </span><span class="s1">sanitisedPath = path</span>
    <span class="s1">.replace(</span><span class="s3">/\.[^./\\]+$/</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s1">)</span>
    <span class="s1">.replace(</span><span class="s3">/[\W_]+/g</span><span class="s0">, </span><span class="s2">&quot;_&quot;</span><span class="s1">)</span>
    <span class="s1">.replace(</span><span class="s3">/^_|_$/g</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s1">)</span><span class="s0">;</span>

  <span class="s0">return </span><span class="s2">`_</span><span class="s1">${sanitisedPath}</span><span class="s2">__</span><span class="s1">${name}</span><span class="s2">`</span><span class="s1">.trim()</span><span class="s0">;</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s1">plugin.generateExportEntry = </span><span class="s0">function </span><span class="s1">(name</span><span class="s0">, </span><span class="s1">scopedName) {</span>
  <span class="s0">return </span><span class="s1">{</span>
    <span class="s1">key: unescape(name)</span><span class="s0">,</span>
    <span class="s1">value: unescape(scopedName)</span><span class="s0">,</span>
  <span class="s1">}</span><span class="s0">;</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">src$1 = plugin</span><span class="s0">;</span>

<span class="s0">function </span><span class="s1">hash(str) {</span>
  <span class="s0">var </span><span class="s1">hash = </span><span class="s3">5381</span><span class="s0">,</span>
      <span class="s1">i    = str.length</span><span class="s0">;</span>

  <span class="s0">while</span><span class="s1">(i) {</span>
    <span class="s1">hash = (hash * </span><span class="s3">33</span><span class="s1">) ^ str.charCodeAt(--i)</span><span class="s0">;</span>
  <span class="s1">}</span>

  <span class="s4">/* JavaScript does bitwise operations (like XOR, above) on 32-bit signed 
   * integers. Since we want the results to be always positive, convert the 
   * signed int to an unsigned by doing an unsigned bitshift. */</span>
  <span class="s0">return </span><span class="s1">hash &gt;&gt;&gt; </span><span class="s3">0</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">var </span><span class="s1">stringHash = hash</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">srcExports = {}</span><span class="s0">;</span>
<span class="s0">var </span><span class="s1">src = {</span>
  <span class="s1">get exports(){ </span><span class="s0">return </span><span class="s1">srcExports</span><span class="s0">; </span><span class="s1">}</span><span class="s0">,</span>
  <span class="s1">set exports(v){ srcExports = v</span><span class="s0">; </span><span class="s1">}</span><span class="s0">,</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s0">const </span><span class="s1">ICSSUtils = src$4</span><span class="s0">;</span>

<span class="s0">const </span><span class="s1">matchImports = </span><span class="s3">/^(.+?|\([\s\S]+?\))\s+from\s+(&quot;[^&quot;]*&quot;|'[^']*'|[\w-]+)$/</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">matchValueDefinition = </span><span class="s3">/(?:\s+|^)([\w-]+):?(.*?)$/</span><span class="s0">;</span>
<span class="s0">const </span><span class="s1">matchImport = </span><span class="s3">/^([\w-]+)(?:\s+as\s+([\w-]+))?/</span><span class="s0">;</span>

<span class="s1">src.exports = (options) =&gt; {</span>
  <span class="s0">let </span><span class="s1">importIndex = </span><span class="s3">0</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">createImportedName =</span>
    <span class="s1">(options &amp;&amp; options.createImportedName) ||</span>
    <span class="s1">((importName </span><span class="s4">/*, path*/</span><span class="s1">) =&gt;</span>
      <span class="s2">`i__const_</span><span class="s1">${importName.replace(</span><span class="s3">/\W/g</span><span class="s0">, </span><span class="s2">&quot;_&quot;</span><span class="s1">)}</span><span class="s2">_</span><span class="s1">${importIndex++}</span><span class="s2">`</span><span class="s1">)</span><span class="s0">;</span>

  <span class="s0">return </span><span class="s1">{</span>
    <span class="s1">postcssPlugin: </span><span class="s2">&quot;postcss-modules-values&quot;</span><span class="s0">,</span>
    <span class="s1">prepare(result) {</span>
      <span class="s0">const </span><span class="s1">importAliases = []</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">definitions = {}</span><span class="s0">;</span>

      <span class="s0">return </span><span class="s1">{</span>
        <span class="s1">Once(root</span><span class="s0">, </span><span class="s1">postcss) {</span>
          <span class="s1">root.walkAtRules(</span><span class="s3">/value/i</span><span class="s0">, </span><span class="s1">(atRule) =&gt; {</span>
            <span class="s0">const </span><span class="s1">matches = atRule.params.match(matchImports)</span><span class="s0">;</span>

            <span class="s0">if </span><span class="s1">(matches) {</span>
              <span class="s0">let </span><span class="s1">[</span><span class="s0">, </span><span class="s4">/*match*/ </span><span class="s1">aliases</span><span class="s0">, </span><span class="s1">path] = matches</span><span class="s0">;</span>

              <span class="s4">// We can use constants for path names</span>
              <span class="s0">if </span><span class="s1">(definitions[path]) {</span>
                <span class="s1">path = definitions[path]</span><span class="s0">;</span>
              <span class="s1">}</span>

              <span class="s0">const </span><span class="s1">imports = aliases</span>
                <span class="s1">.replace(</span><span class="s3">/^\(\s*([\s\S]+)\s*\)$/</span><span class="s0">, </span><span class="s2">&quot;$1&quot;</span><span class="s1">)</span>
                <span class="s1">.split(</span><span class="s3">/\s*,\s*/</span><span class="s1">)</span>
                <span class="s1">.map((alias) =&gt; {</span>
                  <span class="s0">const </span><span class="s1">tokens = matchImport.exec(alias)</span><span class="s0">;</span>

                  <span class="s0">if </span><span class="s1">(tokens) {</span>
                    <span class="s0">const </span><span class="s1">[</span><span class="s0">, </span><span class="s4">/*match*/ </span><span class="s1">theirName</span><span class="s0">, </span><span class="s1">myName = theirName] = tokens</span><span class="s0">;</span>
                    <span class="s0">const </span><span class="s1">importedName = createImportedName(myName)</span><span class="s0">;</span>
                    <span class="s1">definitions[myName] = importedName</span><span class="s0">;</span>
                    <span class="s0">return </span><span class="s1">{ theirName</span><span class="s0">, </span><span class="s1">importedName }</span><span class="s0">;</span>
                  <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
                    <span class="s0">throw new </span><span class="s1">Error(</span><span class="s2">`@import statement &quot;</span><span class="s1">${alias}</span><span class="s2">&quot; is invalid!`</span><span class="s1">)</span><span class="s0">;</span>
                  <span class="s1">}</span>
                <span class="s1">})</span><span class="s0">;</span>

              <span class="s1">importAliases.push({ path</span><span class="s0">, </span><span class="s1">imports })</span><span class="s0">;</span>

              <span class="s1">atRule.remove()</span><span class="s0">;</span>

              <span class="s0">return;</span>
            <span class="s1">}</span>

            <span class="s0">if </span><span class="s1">(atRule.params.indexOf(</span><span class="s2">&quot;@value&quot;</span><span class="s1">) !== -</span><span class="s3">1</span><span class="s1">) {</span>
              <span class="s1">result.warn(</span><span class="s2">&quot;Invalid value definition: &quot; </span><span class="s1">+ atRule.params)</span><span class="s0">;</span>
            <span class="s1">}</span>

            <span class="s0">let </span><span class="s1">[</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value] = </span><span class="s2">`</span><span class="s1">${atRule.params}${atRule.raws.between}</span><span class="s2">`</span><span class="s1">.match(</span>
              <span class="s1">matchValueDefinition</span>
            <span class="s1">)</span><span class="s0">;</span>

            <span class="s0">const </span><span class="s1">normalizedValue = value.replace(</span><span class="s3">/\/\*((?!\*\/).*?)\*\//g</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s1">)</span><span class="s0">;</span>

            <span class="s0">if </span><span class="s1">(normalizedValue.length === </span><span class="s3">0</span><span class="s1">) {</span>
              <span class="s1">result.warn(</span><span class="s2">&quot;Invalid value definition: &quot; </span><span class="s1">+ atRule.params)</span><span class="s0">;</span>
              <span class="s1">atRule.remove()</span><span class="s0">;</span>

              <span class="s0">return;</span>
            <span class="s1">}</span>

            <span class="s0">let </span><span class="s1">isOnlySpace = </span><span class="s3">/^\s+$/</span><span class="s1">.test(normalizedValue)</span><span class="s0">;</span>

            <span class="s0">if </span><span class="s1">(!isOnlySpace) {</span>
              <span class="s1">value = value.trim()</span><span class="s0">;</span>
            <span class="s1">}</span>

            <span class="s4">// Add to the definitions, knowing that values can refer to each other</span>
            <span class="s1">definitions[key] = ICSSUtils.replaceValueSymbols(</span>
              <span class="s1">value</span><span class="s0">,</span>
              <span class="s1">definitions</span>
            <span class="s1">)</span><span class="s0">;</span>

            <span class="s1">atRule.remove()</span><span class="s0">;</span>
          <span class="s1">})</span><span class="s0">;</span>

          <span class="s4">/* If we have no definitions, don't continue */</span>
          <span class="s0">if </span><span class="s1">(!Object.keys(definitions).length) {</span>
            <span class="s0">return;</span>
          <span class="s1">}</span>

          <span class="s4">/* Perform replacements */</span>
          <span class="s1">ICSSUtils.replaceSymbols(root</span><span class="s0">, </span><span class="s1">definitions)</span><span class="s0">;</span>

          <span class="s4">/* We want to export anything defined by now, but don't add it to the CSS yet or it well get picked up by the replacement stuff */</span>
          <span class="s0">const </span><span class="s1">exportDeclarations = Object.keys(definitions).map((key) =&gt;</span>
            <span class="s1">postcss.decl({</span>
              <span class="s1">value: definitions[key]</span><span class="s0">,</span>
              <span class="s1">prop: key</span><span class="s0">,</span>
              <span class="s1">raws: { before: </span><span class="s2">&quot;</span><span class="s0">\n  </span><span class="s2">&quot; </span><span class="s1">}</span><span class="s0">,</span>
            <span class="s1">})</span>
          <span class="s1">)</span><span class="s0">;</span>

          <span class="s4">/* Add export rules if any */</span>
          <span class="s0">if </span><span class="s1">(exportDeclarations.length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
            <span class="s0">const </span><span class="s1">exportRule = postcss.rule({</span>
              <span class="s1">selector: </span><span class="s2">&quot;:export&quot;</span><span class="s0">,</span>
              <span class="s1">raws: { after: </span><span class="s2">&quot;</span><span class="s0">\n</span><span class="s2">&quot; </span><span class="s1">}</span><span class="s0">,</span>
            <span class="s1">})</span><span class="s0">;</span>

            <span class="s1">exportRule.append(exportDeclarations)</span><span class="s0">;</span>

            <span class="s1">root.prepend(exportRule)</span><span class="s0">;</span>
          <span class="s1">}</span>

          <span class="s4">/* Add import rules */</span>
          <span class="s1">importAliases.reverse().forEach(({ path</span><span class="s0">, </span><span class="s1">imports }) =&gt; {</span>
            <span class="s0">const </span><span class="s1">importRule = postcss.rule({</span>
              <span class="s1">selector: </span><span class="s2">`:import(</span><span class="s1">${path}</span><span class="s2">)`</span><span class="s0">,</span>
              <span class="s1">raws: { after: </span><span class="s2">&quot;</span><span class="s0">\n</span><span class="s2">&quot; </span><span class="s1">}</span><span class="s0">,</span>
            <span class="s1">})</span><span class="s0">;</span>

            <span class="s1">imports.forEach(({ theirName</span><span class="s0">, </span><span class="s1">importedName }) =&gt; {</span>
              <span class="s1">importRule.append({</span>
                <span class="s1">value: theirName</span><span class="s0">,</span>
                <span class="s1">prop: importedName</span><span class="s0">,</span>
                <span class="s1">raws: { before: </span><span class="s2">&quot;</span><span class="s0">\n  </span><span class="s2">&quot; </span><span class="s1">}</span><span class="s0">,</span>
              <span class="s1">})</span><span class="s0">;</span>
            <span class="s1">})</span><span class="s0">;</span>

            <span class="s1">root.prepend(importRule)</span><span class="s0">;</span>
          <span class="s1">})</span><span class="s0">;</span>
        <span class="s1">}</span><span class="s0">,</span>
      <span class="s1">}</span><span class="s0">;</span>
    <span class="s1">}</span><span class="s0">,</span>
  <span class="s1">}</span><span class="s0">;</span>
<span class="s1">}</span><span class="s0">;</span>

<span class="s1">srcExports.postcss = </span><span class="s0">true;</span>

<span class="s1">Object.defineProperty(scoping</span><span class="s0">, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, </span><span class="s1">{</span>
  <span class="s1">value: </span><span class="s0">true</span>
<span class="s1">})</span><span class="s0">;</span>
<span class="s1">scoping.behaviours = </span><span class="s0">void </span><span class="s3">0</span><span class="s0">;</span>
<span class="s1">scoping.getDefaultPlugins = getDefaultPlugins</span><span class="s0">;</span>
<span class="s1">scoping.getDefaultScopeBehaviour = getDefaultScopeBehaviour</span><span class="s0">;</span>
<span class="s1">scoping.getScopedNameGenerator = getScopedNameGenerator</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">_postcssModulesExtractImports = _interopRequireDefault$1(srcExports$2)</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">_genericNames = _interopRequireDefault$1(genericNames)</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">_postcssModulesLocalByDefault = _interopRequireDefault$1(srcExports$1)</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">_postcssModulesScope = _interopRequireDefault$1(src$1)</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">_stringHash = _interopRequireDefault$1(stringHash)</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">_postcssModulesValues = _interopRequireDefault$1(srcExports)</span><span class="s0">;</span>

<span class="s0">function </span><span class="s1">_interopRequireDefault$1(obj) { </span><span class="s0">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : { </span><span class="s0">default</span><span class="s1">: obj }</span><span class="s0">; </span><span class="s1">}</span>

<span class="s0">const </span><span class="s1">behaviours = {</span>
  <span class="s1">LOCAL: </span><span class="s2">&quot;local&quot;</span><span class="s0">,</span>
  <span class="s1">GLOBAL: </span><span class="s2">&quot;global&quot;</span>
<span class="s1">}</span><span class="s0">;</span>
<span class="s1">scoping.behaviours = behaviours</span><span class="s0">;</span>

<span class="s0">function </span><span class="s1">getDefaultPlugins({</span>
  <span class="s1">behaviour</span><span class="s0">,</span>
  <span class="s1">generateScopedName</span><span class="s0">,</span>
  <span class="s1">exportGlobals</span>
<span class="s1">}) {</span>
  <span class="s0">const </span><span class="s1">scope = (</span><span class="s3">0</span><span class="s0">, </span><span class="s1">_postcssModulesScope.default)({</span>
    <span class="s1">generateScopedName</span><span class="s0">,</span>
    <span class="s1">exportGlobals</span>
  <span class="s1">})</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">plugins = {</span>
    <span class="s1">[behaviours.LOCAL]: [_postcssModulesValues.default</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">_postcssModulesLocalByDefault.default)({</span>
      <span class="s1">mode: </span><span class="s2">&quot;local&quot;</span>
    <span class="s1">})</span><span class="s0">, </span><span class="s1">_postcssModulesExtractImports.default</span><span class="s0">, </span><span class="s1">scope]</span><span class="s0">,</span>
    <span class="s1">[behaviours.GLOBAL]: [_postcssModulesValues.default</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">_postcssModulesLocalByDefault.default)({</span>
      <span class="s1">mode: </span><span class="s2">&quot;global&quot;</span>
    <span class="s1">})</span><span class="s0">, </span><span class="s1">_postcssModulesExtractImports.default</span><span class="s0">, </span><span class="s1">scope]</span>
  <span class="s1">}</span><span class="s0">;</span>
  <span class="s0">return </span><span class="s1">plugins[behaviour]</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">isValidBehaviour(behaviour) {</span>
  <span class="s0">return </span><span class="s1">Object.keys(behaviours).map(key =&gt; behaviours[key]).indexOf(behaviour) &gt; -</span><span class="s3">1</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">getDefaultScopeBehaviour(scopeBehaviour) {</span>
  <span class="s0">return </span><span class="s1">scopeBehaviour &amp;&amp; isValidBehaviour(scopeBehaviour) ? scopeBehaviour : behaviours.LOCAL</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">generateScopedNameDefault(name</span><span class="s0">, </span><span class="s1">filename</span><span class="s0">, </span><span class="s1">css) {</span>
  <span class="s0">const </span><span class="s1">i = css.indexOf(</span><span class="s2">`.</span><span class="s1">${name}</span><span class="s2">`</span><span class="s1">)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">lineNumber = css.substr(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">i).split(</span><span class="s3">/[\r\n]/</span><span class="s1">).length</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">hash = (</span><span class="s3">0</span><span class="s0">, </span><span class="s1">_stringHash.default)(css).toString(</span><span class="s3">36</span><span class="s1">).substr(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)</span><span class="s0">;</span>
  <span class="s0">return </span><span class="s2">`_</span><span class="s1">${name}</span><span class="s2">_</span><span class="s1">${hash}</span><span class="s2">_</span><span class="s1">${lineNumber}</span><span class="s2">`</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">getScopedNameGenerator(generateScopedName</span><span class="s0">, </span><span class="s1">hashPrefix) {</span>
  <span class="s0">const </span><span class="s1">scopedNameGenerator = generateScopedName || generateScopedNameDefault</span><span class="s0">;</span>

  <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">scopedNameGenerator === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
    <span class="s0">return </span><span class="s1">scopedNameGenerator</span><span class="s0">;</span>
  <span class="s1">}</span>

  <span class="s0">return </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">_genericNames.default)(scopedNameGenerator</span><span class="s0">, </span><span class="s1">{</span>
    <span class="s1">context: process.cwd()</span><span class="s0">,</span>
    <span class="s1">hashPrefix: hashPrefix</span>
  <span class="s1">})</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s1">Object.defineProperty(pluginFactory</span><span class="s0">, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, </span><span class="s1">{</span>
  <span class="s1">value: </span><span class="s0">true</span>
<span class="s1">})</span><span class="s0">;</span>
<span class="s1">pluginFactory.makePlugin = makePlugin</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">_postcss = _interopRequireDefault(require$$0)</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">_unquote = _interopRequireDefault(unquote$1)</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">_Parser = _interopRequireDefault(Parser$1)</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">_saveJSON = _interopRequireDefault(saveJSON$1)</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">_localsConvention = localsConvention</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">_FileSystemLoader = _interopRequireDefault(FileSystemLoader$1)</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">_scoping = scoping</span><span class="s0">;</span>

<span class="s0">function </span><span class="s1">_interopRequireDefault(obj) { </span><span class="s0">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : { </span><span class="s0">default</span><span class="s1">: obj }</span><span class="s0">; </span><span class="s1">}</span>

<span class="s0">const </span><span class="s1">PLUGIN_NAME = </span><span class="s2">&quot;postcss-modules&quot;</span><span class="s0">;</span>

<span class="s0">function </span><span class="s1">isGlobalModule(globalModules</span><span class="s0">, </span><span class="s1">inputFile) {</span>
  <span class="s0">return </span><span class="s1">globalModules.some(regex =&gt; inputFile.match(regex))</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">getDefaultPluginsList(opts</span><span class="s0">, </span><span class="s1">inputFile) {</span>
  <span class="s0">const </span><span class="s1">globalModulesList = opts.globalModulePaths || </span><span class="s0">null;</span>
  <span class="s0">const </span><span class="s1">exportGlobals = opts.exportGlobals || </span><span class="s0">false;</span>
  <span class="s0">const </span><span class="s1">defaultBehaviour = (</span><span class="s3">0</span><span class="s0">, </span><span class="s1">_scoping.getDefaultScopeBehaviour)(opts.scopeBehaviour)</span><span class="s0">;</span>
  <span class="s0">const </span><span class="s1">generateScopedName = (</span><span class="s3">0</span><span class="s0">, </span><span class="s1">_scoping.getScopedNameGenerator)(opts.generateScopedName</span><span class="s0">, </span><span class="s1">opts.hashPrefix)</span><span class="s0">;</span>

  <span class="s0">if </span><span class="s1">(globalModulesList &amp;&amp; isGlobalModule(globalModulesList</span><span class="s0">, </span><span class="s1">inputFile)) {</span>
    <span class="s0">return </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">_scoping.getDefaultPlugins)({</span>
      <span class="s1">behaviour: _scoping.behaviours.GLOBAL</span><span class="s0">,</span>
      <span class="s1">generateScopedName</span><span class="s0">,</span>
      <span class="s1">exportGlobals</span>
    <span class="s1">})</span><span class="s0">;</span>
  <span class="s1">}</span>

  <span class="s0">return </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">_scoping.getDefaultPlugins)({</span>
    <span class="s1">behaviour: defaultBehaviour</span><span class="s0">,</span>
    <span class="s1">generateScopedName</span><span class="s0">,</span>
    <span class="s1">exportGlobals</span>
  <span class="s1">})</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">getLoader(opts</span><span class="s0">, </span><span class="s1">plugins) {</span>
  <span class="s0">const </span><span class="s1">root = </span><span class="s0">typeof </span><span class="s1">opts.root === </span><span class="s2">&quot;undefined&quot; </span><span class="s1">? </span><span class="s2">&quot;/&quot; </span><span class="s1">: opts.root</span><span class="s0">;</span>
  <span class="s0">return typeof </span><span class="s1">opts.Loader === </span><span class="s2">&quot;function&quot; </span><span class="s1">? </span><span class="s0">new </span><span class="s1">opts.Loader(root</span><span class="s0">, </span><span class="s1">plugins</span><span class="s0">, </span><span class="s1">opts.resolve) : </span><span class="s0">new </span><span class="s1">_FileSystemLoader.default(root</span><span class="s0">, </span><span class="s1">plugins</span><span class="s0">, </span><span class="s1">opts.resolve)</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">isOurPlugin(plugin) {</span>
  <span class="s0">return </span><span class="s1">plugin.postcssPlugin === PLUGIN_NAME</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">makePlugin(opts) {</span>
  <span class="s0">return </span><span class="s1">{</span>
    <span class="s1">postcssPlugin: PLUGIN_NAME</span><span class="s0">,</span>

    <span class="s1">async OnceExit(css</span><span class="s0">, </span><span class="s1">{</span>
      <span class="s1">result</span>
    <span class="s1">}) {</span>
      <span class="s0">const </span><span class="s1">getJSON = opts.getJSON || _saveJSON.default</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">inputFile = css.source.input.file</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">pluginList = getDefaultPluginsList(opts</span><span class="s0">, </span><span class="s1">inputFile)</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">resultPluginIndex = result.processor.plugins.findIndex(plugin =&gt; isOurPlugin(plugin))</span><span class="s0">;</span>

      <span class="s0">if </span><span class="s1">(resultPluginIndex === -</span><span class="s3">1</span><span class="s1">) {</span>
        <span class="s0">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Plugin missing from options.&quot;</span><span class="s1">)</span><span class="s0">;</span>
      <span class="s1">}</span>

      <span class="s0">const </span><span class="s1">earlierPlugins = result.processor.plugins.slice(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">resultPluginIndex)</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">loaderPlugins = [...earlierPlugins</span><span class="s0">, </span><span class="s1">...pluginList]</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">loader = getLoader(opts</span><span class="s0">, </span><span class="s1">loaderPlugins)</span><span class="s0">;</span>

      <span class="s0">const </span><span class="s1">fetcher = async (file</span><span class="s0">, </span><span class="s1">relativeTo</span><span class="s0">, </span><span class="s1">depTrace) =&gt; {</span>
        <span class="s0">const </span><span class="s1">unquoteFile = (</span><span class="s3">0</span><span class="s0">, </span><span class="s1">_unquote.default)(file)</span><span class="s0">;</span>
        <span class="s0">return </span><span class="s1">loader.fetch.call(loader</span><span class="s0">, </span><span class="s1">unquoteFile</span><span class="s0">, </span><span class="s1">relativeTo</span><span class="s0">, </span><span class="s1">depTrace)</span><span class="s0">;</span>
      <span class="s1">}</span><span class="s0">;</span>

      <span class="s0">const </span><span class="s1">parser = </span><span class="s0">new </span><span class="s1">_Parser.default(fetcher)</span><span class="s0">;</span>
      <span class="s0">await </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">_postcss.default)([...pluginList</span><span class="s0">, </span><span class="s1">parser.plugin()]).process(css</span><span class="s0">, </span><span class="s1">{</span>
        <span class="s1">from: inputFile</span>
      <span class="s1">})</span><span class="s0">;</span>
      <span class="s0">const </span><span class="s1">out = loader.finalSource</span><span class="s0">;</span>
      <span class="s0">if </span><span class="s1">(out) css.prepend(out)</span><span class="s0">;</span>

      <span class="s0">if </span><span class="s1">(opts.localsConvention) {</span>
        <span class="s0">const </span><span class="s1">reducer = (</span><span class="s3">0</span><span class="s0">, </span><span class="s1">_localsConvention.makeLocalsConventionReducer)(opts.localsConvention</span><span class="s0">, </span><span class="s1">inputFile)</span><span class="s0">;</span>
        <span class="s1">parser.exportTokens = Object.entries(parser.exportTokens).reduce(reducer</span><span class="s0">, </span><span class="s1">{})</span><span class="s0">;</span>
      <span class="s1">}</span>

      <span class="s1">result.messages.push({</span>
        <span class="s1">type: </span><span class="s2">&quot;export&quot;</span><span class="s0">,</span>
        <span class="s1">plugin: </span><span class="s2">&quot;postcss-modules&quot;</span><span class="s0">,</span>
        <span class="s1">exportTokens: parser.exportTokens</span>
      <span class="s1">})</span><span class="s0">; </span><span class="s4">// getJSON may return a promise</span>

      <span class="s0">return </span><span class="s1">getJSON(css.source.input.file</span><span class="s0">, </span><span class="s1">parser.exportTokens</span><span class="s0">, </span><span class="s1">result.opts.to)</span><span class="s0">;</span>
    <span class="s1">}</span>

  <span class="s1">}</span><span class="s0">;</span>
<span class="s1">}</span>

<span class="s0">var </span><span class="s1">_fs = require$$0__default</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">_fs2 = fs</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">_pluginFactory = pluginFactory</span><span class="s0">;</span>

<span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">_fs2.setFileSystem)({</span>
  <span class="s1">readFile: _fs.readFile</span><span class="s0">,</span>
  <span class="s1">writeFile: _fs.writeFile</span>
<span class="s1">})</span><span class="s0">;</span>

<span class="s1">build.exports = (opts = {}) =&gt; (</span><span class="s3">0</span><span class="s0">, </span><span class="s1">_pluginFactory.makePlugin)(opts)</span><span class="s0">;</span>

<span class="s0">var </span><span class="s1">postcss = buildExports.postcss = </span><span class="s0">true;</span>

<span class="s0">var </span><span class="s1">index = </span><span class="s4">/*#__PURE__*/</span><span class="s1">_mergeNamespaces({</span>
  <span class="s1">__proto__: </span><span class="s0">null,</span>
  <span class="s1">get </span><span class="s0">default </span><span class="s1">() { </span><span class="s0">return </span><span class="s1">buildExports</span><span class="s0">; </span><span class="s1">}</span><span class="s0">,</span>
  <span class="s1">postcss: postcss</span>
<span class="s1">}</span><span class="s0">, </span><span class="s1">[buildExports])</span><span class="s0">;</span>

<span class="s0">export </span><span class="s1">{ index as i }</span><span class="s0">;</span>
</pre>
</body>
</html>