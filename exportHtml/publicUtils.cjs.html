<html>
<head>
<title>publicUtils.cjs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #6a8759;}
.s1 { color: #cc7832;}
.s2 { color: #a9b7c6;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
.s6 { color: #629755; font-weight: bold; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
publicUtils.cjs</font>
</center></td></tr></table>
<pre><span class="s0">'use strict'</span><span class="s1">;</span>

<span class="s1">var </span><span class="s2">path$3 = require(</span><span class="s0">'node:path'</span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">var </span><span class="s2">node_url = require(</span><span class="s0">'node:url'</span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">var </span><span class="s2">fs$1 = require(</span><span class="s0">'node:fs'</span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">var </span><span class="s2">esbuild = require(</span><span class="s0">'esbuild'</span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">var </span><span class="s2">rollup = require(</span><span class="s0">'rollup'</span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">var </span><span class="s2">os$1 = require(</span><span class="s0">'node:os'</span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">var </span><span class="s2">node_module = require(</span><span class="s0">'node:module'</span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">var </span><span class="s2">require$$0 = require(</span><span class="s0">'tty'</span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">var </span><span class="s2">require$$1 = require(</span><span class="s0">'util'</span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">var </span><span class="s2">require$$0$1 = require(</span><span class="s0">'path'</span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">var </span><span class="s2">require$$0$2 = require(</span><span class="s0">'crypto'</span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">var </span><span class="s2">fs$2 = require(</span><span class="s0">'fs'</span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">var </span><span class="s2">readline = require(</span><span class="s0">'node:readline'</span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">var </span><span class="s2">require$$2 = require(</span><span class="s0">'os'</span><span class="s2">)</span><span class="s1">;</span>

<span class="s1">const </span><span class="s2">{ version: version$2 } = JSON.parse(fs$1.readFileSync(</span><span class="s1">new </span><span class="s2">URL(</span><span class="s0">'../../package.json'</span><span class="s1">, </span><span class="s2">(</span><span class="s1">typeof </span><span class="s2">document === </span><span class="s0">'undefined' </span><span class="s2">? require(</span><span class="s0">'u' </span><span class="s2">+ </span><span class="s0">'rl'</span><span class="s2">).pathToFileURL(__filename).href : (document.currentScript &amp;&amp; document.currentScript.src || </span><span class="s1">new </span><span class="s2">URL(</span><span class="s0">'node-cjs/publicUtils.cjs'</span><span class="s1">, </span><span class="s2">document.baseURI).href)))).toString())</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">VERSION = version$2</span><span class="s1">;</span>
<span class="s3">/**</span>
 <span class="s3">* Prefix for resolved fs paths, since windows paths may not be valid as URLs.</span>
 <span class="s3">*/</span>
<span class="s1">const </span><span class="s2">FS_PREFIX = </span><span class="s0">`/@fs/`</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">VITE_PACKAGE_DIR = path$3.resolve(</span>
<span class="s4">// import.meta.url is `dist/node/constants.js` after bundle</span>
<span class="s2">node_url.fileURLToPath((</span><span class="s1">typeof </span><span class="s2">document === </span><span class="s0">'undefined' </span><span class="s2">? require(</span><span class="s0">'u' </span><span class="s2">+ </span><span class="s0">'rl'</span><span class="s2">).pathToFileURL(__filename).href : (document.currentScript &amp;&amp; document.currentScript.src || </span><span class="s1">new </span><span class="s2">URL(</span><span class="s0">'node-cjs/publicUtils.cjs'</span><span class="s1">, </span><span class="s2">document.baseURI).href)))</span><span class="s1">, </span><span class="s0">'../../..'</span><span class="s2">)</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">CLIENT_ENTRY = path$3.resolve(VITE_PACKAGE_DIR</span><span class="s1">, </span><span class="s0">'dist/client/client.mjs'</span><span class="s2">)</span><span class="s1">;</span>
<span class="s2">path$3.resolve(VITE_PACKAGE_DIR</span><span class="s1">, </span><span class="s0">'dist/client/env.mjs'</span><span class="s2">)</span><span class="s1">;</span>
<span class="s2">path$3.dirname(CLIENT_ENTRY)</span><span class="s1">;</span>

<span class="s1">const </span><span class="s2">chars = </span><span class="s0">'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">intToChar = </span><span class="s1">new </span><span class="s2">Uint8Array(</span><span class="s5">64</span><span class="s2">)</span><span class="s1">; </span><span class="s4">// 64 possible chars.</span>
<span class="s1">const </span><span class="s2">charToInt = </span><span class="s1">new </span><span class="s2">Uint8Array(</span><span class="s5">128</span><span class="s2">)</span><span class="s1">; </span><span class="s4">// z is 122 in ASCII</span>
<span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s5">0</span><span class="s1">; </span><span class="s2">i &lt; chars.length</span><span class="s1">; </span><span class="s2">i++) {</span>
    <span class="s1">const </span><span class="s2">c = chars.charCodeAt(i)</span><span class="s1">;</span>
    <span class="s2">intToChar[i] = c</span><span class="s1">;</span>
    <span class="s2">charToInt[c] = i</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s4">// Matches the scheme of a URL, eg &quot;http://&quot;</span>
<span class="s1">var </span><span class="s2">UrlType</span><span class="s1">;</span>
<span class="s2">(</span><span class="s1">function </span><span class="s2">(UrlType) {</span>
    <span class="s2">UrlType[UrlType[</span><span class="s0">&quot;Empty&quot;</span><span class="s2">] = </span><span class="s5">1</span><span class="s2">] = </span><span class="s0">&quot;Empty&quot;</span><span class="s1">;</span>
    <span class="s2">UrlType[UrlType[</span><span class="s0">&quot;Hash&quot;</span><span class="s2">] = </span><span class="s5">2</span><span class="s2">] = </span><span class="s0">&quot;Hash&quot;</span><span class="s1">;</span>
    <span class="s2">UrlType[UrlType[</span><span class="s0">&quot;Query&quot;</span><span class="s2">] = </span><span class="s5">3</span><span class="s2">] = </span><span class="s0">&quot;Query&quot;</span><span class="s1">;</span>
    <span class="s2">UrlType[UrlType[</span><span class="s0">&quot;RelativePath&quot;</span><span class="s2">] = </span><span class="s5">4</span><span class="s2">] = </span><span class="s0">&quot;RelativePath&quot;</span><span class="s1">;</span>
    <span class="s2">UrlType[UrlType[</span><span class="s0">&quot;AbsolutePath&quot;</span><span class="s2">] = </span><span class="s5">5</span><span class="s2">] = </span><span class="s0">&quot;AbsolutePath&quot;</span><span class="s1">;</span>
    <span class="s2">UrlType[UrlType[</span><span class="s0">&quot;SchemeRelative&quot;</span><span class="s2">] = </span><span class="s5">6</span><span class="s2">] = </span><span class="s0">&quot;SchemeRelative&quot;</span><span class="s1">;</span>
    <span class="s2">UrlType[UrlType[</span><span class="s0">&quot;Absolute&quot;</span><span class="s2">] = </span><span class="s5">7</span><span class="s2">] = </span><span class="s0">&quot;Absolute&quot;</span><span class="s1">;</span>
<span class="s2">})(UrlType || (UrlType = {}))</span><span class="s1">;</span>

<span class="s1">function </span><span class="s2">getDefaultExportFromCjs (x) {</span>
	<span class="s1">return </span><span class="s2">x &amp;&amp; x.__esModule &amp;&amp; Object.prototype.hasOwnProperty.call(x</span><span class="s1">, </span><span class="s0">'default'</span><span class="s2">) ? x[</span><span class="s0">'default'</span><span class="s2">] : x</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s1">var </span><span class="s2">picocolorsExports = {}</span><span class="s1">;</span>
<span class="s1">var </span><span class="s2">picocolors = {</span>
  <span class="s2">get exports(){ </span><span class="s1">return </span><span class="s2">picocolorsExports</span><span class="s1">; </span><span class="s2">}</span><span class="s1">,</span>
  <span class="s2">set exports(v){ picocolorsExports = v</span><span class="s1">; </span><span class="s2">}</span><span class="s1">,</span>
<span class="s2">}</span><span class="s1">;</span>

<span class="s1">let </span><span class="s2">tty = require$$0</span><span class="s1">;</span>

<span class="s1">let </span><span class="s2">isColorSupported =</span>
	<span class="s2">!(</span><span class="s0">&quot;NO_COLOR&quot; </span><span class="s1">in </span><span class="s2">process.env || process.argv.includes(</span><span class="s0">&quot;--no-color&quot;</span><span class="s2">)) &amp;&amp;</span>
	<span class="s2">(</span><span class="s0">&quot;FORCE_COLOR&quot; </span><span class="s1">in </span><span class="s2">process.env ||</span>
		<span class="s2">process.argv.includes(</span><span class="s0">&quot;--color&quot;</span><span class="s2">) ||</span>
		<span class="s2">process.platform === </span><span class="s0">&quot;win32&quot; </span><span class="s2">||</span>
		<span class="s2">(tty.isatty(</span><span class="s5">1</span><span class="s2">) &amp;&amp; process.env.TERM !== </span><span class="s0">&quot;dumb&quot;</span><span class="s2">) ||</span>
		<span class="s0">&quot;CI&quot; </span><span class="s1">in </span><span class="s2">process.env)</span><span class="s1">;</span>

<span class="s1">let </span><span class="s2">formatter =</span>
	<span class="s2">(open</span><span class="s1">, </span><span class="s2">close</span><span class="s1">, </span><span class="s2">replace = open) =&gt;</span>
	<span class="s2">input =&gt; {</span>
		<span class="s1">let </span><span class="s2">string = </span><span class="s0">&quot;&quot; </span><span class="s2">+ input</span><span class="s1">;</span>
		<span class="s1">let </span><span class="s2">index = string.indexOf(close</span><span class="s1">, </span><span class="s2">open.length)</span><span class="s1">;</span>
		<span class="s1">return </span><span class="s2">~index</span>
			<span class="s2">? open + replaceClose(string</span><span class="s1">, </span><span class="s2">close</span><span class="s1">, </span><span class="s2">replace</span><span class="s1">, </span><span class="s2">index) + close</span>
			<span class="s2">: open + string + close</span>
	<span class="s2">}</span><span class="s1">;</span>

<span class="s1">let </span><span class="s2">replaceClose = (string</span><span class="s1">, </span><span class="s2">close</span><span class="s1">, </span><span class="s2">replace</span><span class="s1">, </span><span class="s2">index) =&gt; {</span>
	<span class="s1">let </span><span class="s2">start = string.substring(</span><span class="s5">0</span><span class="s1">, </span><span class="s2">index) + replace</span><span class="s1">;</span>
	<span class="s1">let </span><span class="s2">end = string.substring(index + close.length)</span><span class="s1">;</span>
	<span class="s1">let </span><span class="s2">nextIndex = end.indexOf(close)</span><span class="s1">;</span>
	<span class="s1">return </span><span class="s2">~nextIndex ? start + replaceClose(end</span><span class="s1">, </span><span class="s2">close</span><span class="s1">, </span><span class="s2">replace</span><span class="s1">, </span><span class="s2">nextIndex) : start + end</span>
<span class="s2">}</span><span class="s1">;</span>

<span class="s1">let </span><span class="s2">createColors = (enabled = isColorSupported) =&gt; ({</span>
	<span class="s2">isColorSupported: enabled</span><span class="s1">,</span>
	<span class="s2">reset: enabled ? s =&gt; </span><span class="s0">`</span><span class="s1">\x1b</span><span class="s0">[0m</span><span class="s2">${s}</span><span class="s1">\x1b</span><span class="s0">[0m` </span><span class="s2">: String</span><span class="s1">,</span>
	<span class="s2">bold: enabled ? formatter(</span><span class="s0">&quot;</span><span class="s1">\x1b</span><span class="s0">[1m&quot;</span><span class="s1">, </span><span class="s0">&quot;</span><span class="s1">\x1b</span><span class="s0">[22m&quot;</span><span class="s1">, </span><span class="s0">&quot;</span><span class="s1">\x1b</span><span class="s0">[22m</span><span class="s1">\x1b</span><span class="s0">[1m&quot;</span><span class="s2">) : String</span><span class="s1">,</span>
	<span class="s2">dim: enabled ? formatter(</span><span class="s0">&quot;</span><span class="s1">\x1b</span><span class="s0">[2m&quot;</span><span class="s1">, </span><span class="s0">&quot;</span><span class="s1">\x1b</span><span class="s0">[22m&quot;</span><span class="s1">, </span><span class="s0">&quot;</span><span class="s1">\x1b</span><span class="s0">[22m</span><span class="s1">\x1b</span><span class="s0">[2m&quot;</span><span class="s2">) : String</span><span class="s1">,</span>
	<span class="s2">italic: enabled ? formatter(</span><span class="s0">&quot;</span><span class="s1">\x1b</span><span class="s0">[3m&quot;</span><span class="s1">, </span><span class="s0">&quot;</span><span class="s1">\x1b</span><span class="s0">[23m&quot;</span><span class="s2">) : String</span><span class="s1">,</span>
	<span class="s2">underline: enabled ? formatter(</span><span class="s0">&quot;</span><span class="s1">\x1b</span><span class="s0">[4m&quot;</span><span class="s1">, </span><span class="s0">&quot;</span><span class="s1">\x1b</span><span class="s0">[24m&quot;</span><span class="s2">) : String</span><span class="s1">,</span>
	<span class="s2">inverse: enabled ? formatter(</span><span class="s0">&quot;</span><span class="s1">\x1b</span><span class="s0">[7m&quot;</span><span class="s1">, </span><span class="s0">&quot;</span><span class="s1">\x1b</span><span class="s0">[27m&quot;</span><span class="s2">) : String</span><span class="s1">,</span>
	<span class="s2">hidden: enabled ? formatter(</span><span class="s0">&quot;</span><span class="s1">\x1b</span><span class="s0">[8m&quot;</span><span class="s1">, </span><span class="s0">&quot;</span><span class="s1">\x1b</span><span class="s0">[28m&quot;</span><span class="s2">) : String</span><span class="s1">,</span>
	<span class="s2">strikethrough: enabled ? formatter(</span><span class="s0">&quot;</span><span class="s1">\x1b</span><span class="s0">[9m&quot;</span><span class="s1">, </span><span class="s0">&quot;</span><span class="s1">\x1b</span><span class="s0">[29m&quot;</span><span class="s2">) : String</span><span class="s1">,</span>
	<span class="s2">black: enabled ? formatter(</span><span class="s0">&quot;</span><span class="s1">\x1b</span><span class="s0">[30m&quot;</span><span class="s1">, </span><span class="s0">&quot;</span><span class="s1">\x1b</span><span class="s0">[39m&quot;</span><span class="s2">) : String</span><span class="s1">,</span>
	<span class="s2">red: enabled ? formatter(</span><span class="s0">&quot;</span><span class="s1">\x1b</span><span class="s0">[31m&quot;</span><span class="s1">, </span><span class="s0">&quot;</span><span class="s1">\x1b</span><span class="s0">[39m&quot;</span><span class="s2">) : String</span><span class="s1">,</span>
	<span class="s2">green: enabled ? formatter(</span><span class="s0">&quot;</span><span class="s1">\x1b</span><span class="s0">[32m&quot;</span><span class="s1">, </span><span class="s0">&quot;</span><span class="s1">\x1b</span><span class="s0">[39m&quot;</span><span class="s2">) : String</span><span class="s1">,</span>
	<span class="s2">yellow: enabled ? formatter(</span><span class="s0">&quot;</span><span class="s1">\x1b</span><span class="s0">[33m&quot;</span><span class="s1">, </span><span class="s0">&quot;</span><span class="s1">\x1b</span><span class="s0">[39m&quot;</span><span class="s2">) : String</span><span class="s1">,</span>
	<span class="s2">blue: enabled ? formatter(</span><span class="s0">&quot;</span><span class="s1">\x1b</span><span class="s0">[34m&quot;</span><span class="s1">, </span><span class="s0">&quot;</span><span class="s1">\x1b</span><span class="s0">[39m&quot;</span><span class="s2">) : String</span><span class="s1">,</span>
	<span class="s2">magenta: enabled ? formatter(</span><span class="s0">&quot;</span><span class="s1">\x1b</span><span class="s0">[35m&quot;</span><span class="s1">, </span><span class="s0">&quot;</span><span class="s1">\x1b</span><span class="s0">[39m&quot;</span><span class="s2">) : String</span><span class="s1">,</span>
	<span class="s2">cyan: enabled ? formatter(</span><span class="s0">&quot;</span><span class="s1">\x1b</span><span class="s0">[36m&quot;</span><span class="s1">, </span><span class="s0">&quot;</span><span class="s1">\x1b</span><span class="s0">[39m&quot;</span><span class="s2">) : String</span><span class="s1">,</span>
	<span class="s2">white: enabled ? formatter(</span><span class="s0">&quot;</span><span class="s1">\x1b</span><span class="s0">[37m&quot;</span><span class="s1">, </span><span class="s0">&quot;</span><span class="s1">\x1b</span><span class="s0">[39m&quot;</span><span class="s2">) : String</span><span class="s1">,</span>
	<span class="s2">gray: enabled ? formatter(</span><span class="s0">&quot;</span><span class="s1">\x1b</span><span class="s0">[90m&quot;</span><span class="s1">, </span><span class="s0">&quot;</span><span class="s1">\x1b</span><span class="s0">[39m&quot;</span><span class="s2">) : String</span><span class="s1">,</span>
	<span class="s2">bgBlack: enabled ? formatter(</span><span class="s0">&quot;</span><span class="s1">\x1b</span><span class="s0">[40m&quot;</span><span class="s1">, </span><span class="s0">&quot;</span><span class="s1">\x1b</span><span class="s0">[49m&quot;</span><span class="s2">) : String</span><span class="s1">,</span>
	<span class="s2">bgRed: enabled ? formatter(</span><span class="s0">&quot;</span><span class="s1">\x1b</span><span class="s0">[41m&quot;</span><span class="s1">, </span><span class="s0">&quot;</span><span class="s1">\x1b</span><span class="s0">[49m&quot;</span><span class="s2">) : String</span><span class="s1">,</span>
	<span class="s2">bgGreen: enabled ? formatter(</span><span class="s0">&quot;</span><span class="s1">\x1b</span><span class="s0">[42m&quot;</span><span class="s1">, </span><span class="s0">&quot;</span><span class="s1">\x1b</span><span class="s0">[49m&quot;</span><span class="s2">) : String</span><span class="s1">,</span>
	<span class="s2">bgYellow: enabled ? formatter(</span><span class="s0">&quot;</span><span class="s1">\x1b</span><span class="s0">[43m&quot;</span><span class="s1">, </span><span class="s0">&quot;</span><span class="s1">\x1b</span><span class="s0">[49m&quot;</span><span class="s2">) : String</span><span class="s1">,</span>
	<span class="s2">bgBlue: enabled ? formatter(</span><span class="s0">&quot;</span><span class="s1">\x1b</span><span class="s0">[44m&quot;</span><span class="s1">, </span><span class="s0">&quot;</span><span class="s1">\x1b</span><span class="s0">[49m&quot;</span><span class="s2">) : String</span><span class="s1">,</span>
	<span class="s2">bgMagenta: enabled ? formatter(</span><span class="s0">&quot;</span><span class="s1">\x1b</span><span class="s0">[45m&quot;</span><span class="s1">, </span><span class="s0">&quot;</span><span class="s1">\x1b</span><span class="s0">[49m&quot;</span><span class="s2">) : String</span><span class="s1">,</span>
	<span class="s2">bgCyan: enabled ? formatter(</span><span class="s0">&quot;</span><span class="s1">\x1b</span><span class="s0">[46m&quot;</span><span class="s1">, </span><span class="s0">&quot;</span><span class="s1">\x1b</span><span class="s0">[49m&quot;</span><span class="s2">) : String</span><span class="s1">,</span>
	<span class="s2">bgWhite: enabled ? formatter(</span><span class="s0">&quot;</span><span class="s1">\x1b</span><span class="s0">[47m&quot;</span><span class="s1">, </span><span class="s0">&quot;</span><span class="s1">\x1b</span><span class="s0">[49m&quot;</span><span class="s2">) : String</span><span class="s1">,</span>
<span class="s2">})</span><span class="s1">;</span>

<span class="s2">picocolors.exports = createColors()</span><span class="s1">;</span>
<span class="s2">picocolorsExports.createColors = createColors</span><span class="s1">;</span>

<span class="s1">var </span><span class="s2">srcExports = {}</span><span class="s1">;</span>
<span class="s1">var </span><span class="s2">src = {</span>
  <span class="s2">get exports(){ </span><span class="s1">return </span><span class="s2">srcExports</span><span class="s1">; </span><span class="s2">}</span><span class="s1">,</span>
  <span class="s2">set exports(v){ srcExports = v</span><span class="s1">; </span><span class="s2">}</span><span class="s1">,</span>
<span class="s2">}</span><span class="s1">;</span>

<span class="s1">var </span><span class="s2">browserExports = {}</span><span class="s1">;</span>
<span class="s1">var </span><span class="s2">browser = {</span>
  <span class="s2">get exports(){ </span><span class="s1">return </span><span class="s2">browserExports</span><span class="s1">; </span><span class="s2">}</span><span class="s1">,</span>
  <span class="s2">set exports(v){ browserExports = v</span><span class="s1">; </span><span class="s2">}</span><span class="s1">,</span>
<span class="s2">}</span><span class="s1">;</span>

<span class="s3">/**</span>
 <span class="s3">* Helpers.</span>
 <span class="s3">*/</span>

<span class="s1">var </span><span class="s2">ms</span><span class="s1">;</span>
<span class="s1">var </span><span class="s2">hasRequiredMs</span><span class="s1">;</span>

<span class="s1">function </span><span class="s2">requireMs () {</span>
	<span class="s1">if </span><span class="s2">(hasRequiredMs) </span><span class="s1">return </span><span class="s2">ms</span><span class="s1">;</span>
	<span class="s2">hasRequiredMs = </span><span class="s5">1</span><span class="s1">;</span>
	<span class="s1">var </span><span class="s2">s = </span><span class="s5">1000</span><span class="s1">;</span>
	<span class="s1">var </span><span class="s2">m = s * </span><span class="s5">60</span><span class="s1">;</span>
	<span class="s1">var </span><span class="s2">h = m * </span><span class="s5">60</span><span class="s1">;</span>
	<span class="s1">var </span><span class="s2">d = h * </span><span class="s5">24</span><span class="s1">;</span>
	<span class="s1">var </span><span class="s2">w = d * </span><span class="s5">7</span><span class="s1">;</span>
	<span class="s1">var </span><span class="s2">y = d * </span><span class="s5">365.25</span><span class="s1">;</span>

	<span class="s3">/**</span>
	 <span class="s3">* Parse or format the given `val`.</span>
	 <span class="s3">*</span>
	 <span class="s3">* Options:</span>
	 <span class="s3">*</span>
	 <span class="s3">*  - `long` verbose formatting [false]</span>
	 <span class="s3">*</span>
	 <span class="s3">* </span><span class="s6">@param </span><span class="s3">{String|Number} val</span>
	 <span class="s3">* </span><span class="s6">@param </span><span class="s3">{Object} [options]</span>
	 <span class="s3">* </span><span class="s6">@throws </span><span class="s3">{Error} throw an error if val is not a non-empty string or a number</span>
	 <span class="s3">* </span><span class="s6">@return </span><span class="s3">{String|Number}</span>
	 <span class="s3">* </span><span class="s6">@api </span><span class="s3">public</span>
	 <span class="s3">*/</span>

	<span class="s2">ms = </span><span class="s1">function</span><span class="s2">(val</span><span class="s1">, </span><span class="s2">options) {</span>
	  <span class="s2">options = options || {}</span><span class="s1">;</span>
	  <span class="s1">var </span><span class="s2">type = </span><span class="s1">typeof </span><span class="s2">val</span><span class="s1">;</span>
	  <span class="s1">if </span><span class="s2">(type === </span><span class="s0">'string' </span><span class="s2">&amp;&amp; val.length &gt; </span><span class="s5">0</span><span class="s2">) {</span>
	    <span class="s1">return </span><span class="s2">parse(val)</span><span class="s1">;</span>
	  <span class="s2">} </span><span class="s1">else if </span><span class="s2">(type === </span><span class="s0">'number' </span><span class="s2">&amp;&amp; isFinite(val)) {</span>
	    <span class="s1">return </span><span class="s2">options.long ? fmtLong(val) : fmtShort(val)</span><span class="s1">;</span>
	  <span class="s2">}</span>
	  <span class="s1">throw new </span><span class="s2">Error(</span>
	    <span class="s0">'val is not a non-empty string or a valid number. val=' </span><span class="s2">+</span>
	      <span class="s2">JSON.stringify(val)</span>
	  <span class="s2">)</span><span class="s1">;</span>
	<span class="s2">}</span><span class="s1">;</span>

	<span class="s3">/**</span>
	 <span class="s3">* Parse the given `str` and return milliseconds.</span>
	 <span class="s3">*</span>
	 <span class="s3">* </span><span class="s6">@param </span><span class="s3">{String} str</span>
	 <span class="s3">* </span><span class="s6">@return </span><span class="s3">{Number}</span>
	 <span class="s3">* </span><span class="s6">@api </span><span class="s3">private</span>
	 <span class="s3">*/</span>

	<span class="s1">function </span><span class="s2">parse(str) {</span>
	  <span class="s2">str = String(str)</span><span class="s1">;</span>
	  <span class="s1">if </span><span class="s2">(str.length &gt; </span><span class="s5">100</span><span class="s2">) {</span>
	    <span class="s1">return;</span>
	  <span class="s2">}</span>
	  <span class="s1">var </span><span class="s2">match = </span><span class="s5">/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i</span><span class="s2">.exec(</span>
	    <span class="s2">str</span>
	  <span class="s2">)</span><span class="s1">;</span>
	  <span class="s1">if </span><span class="s2">(!match) {</span>
	    <span class="s1">return;</span>
	  <span class="s2">}</span>
	  <span class="s1">var </span><span class="s2">n = parseFloat(match[</span><span class="s5">1</span><span class="s2">])</span><span class="s1">;</span>
	  <span class="s1">var </span><span class="s2">type = (match[</span><span class="s5">2</span><span class="s2">] || </span><span class="s0">'ms'</span><span class="s2">).toLowerCase()</span><span class="s1">;</span>
	  <span class="s1">switch </span><span class="s2">(type) {</span>
	    <span class="s1">case </span><span class="s0">'years'</span><span class="s2">:</span>
	    <span class="s1">case </span><span class="s0">'year'</span><span class="s2">:</span>
	    <span class="s1">case </span><span class="s0">'yrs'</span><span class="s2">:</span>
	    <span class="s1">case </span><span class="s0">'yr'</span><span class="s2">:</span>
	    <span class="s1">case </span><span class="s0">'y'</span><span class="s2">:</span>
	      <span class="s1">return </span><span class="s2">n * y</span><span class="s1">;</span>
	    <span class="s1">case </span><span class="s0">'weeks'</span><span class="s2">:</span>
	    <span class="s1">case </span><span class="s0">'week'</span><span class="s2">:</span>
	    <span class="s1">case </span><span class="s0">'w'</span><span class="s2">:</span>
	      <span class="s1">return </span><span class="s2">n * w</span><span class="s1">;</span>
	    <span class="s1">case </span><span class="s0">'days'</span><span class="s2">:</span>
	    <span class="s1">case </span><span class="s0">'day'</span><span class="s2">:</span>
	    <span class="s1">case </span><span class="s0">'d'</span><span class="s2">:</span>
	      <span class="s1">return </span><span class="s2">n * d</span><span class="s1">;</span>
	    <span class="s1">case </span><span class="s0">'hours'</span><span class="s2">:</span>
	    <span class="s1">case </span><span class="s0">'hour'</span><span class="s2">:</span>
	    <span class="s1">case </span><span class="s0">'hrs'</span><span class="s2">:</span>
	    <span class="s1">case </span><span class="s0">'hr'</span><span class="s2">:</span>
	    <span class="s1">case </span><span class="s0">'h'</span><span class="s2">:</span>
	      <span class="s1">return </span><span class="s2">n * h</span><span class="s1">;</span>
	    <span class="s1">case </span><span class="s0">'minutes'</span><span class="s2">:</span>
	    <span class="s1">case </span><span class="s0">'minute'</span><span class="s2">:</span>
	    <span class="s1">case </span><span class="s0">'mins'</span><span class="s2">:</span>
	    <span class="s1">case </span><span class="s0">'min'</span><span class="s2">:</span>
	    <span class="s1">case </span><span class="s0">'m'</span><span class="s2">:</span>
	      <span class="s1">return </span><span class="s2">n * m</span><span class="s1">;</span>
	    <span class="s1">case </span><span class="s0">'seconds'</span><span class="s2">:</span>
	    <span class="s1">case </span><span class="s0">'second'</span><span class="s2">:</span>
	    <span class="s1">case </span><span class="s0">'secs'</span><span class="s2">:</span>
	    <span class="s1">case </span><span class="s0">'sec'</span><span class="s2">:</span>
	    <span class="s1">case </span><span class="s0">'s'</span><span class="s2">:</span>
	      <span class="s1">return </span><span class="s2">n * s</span><span class="s1">;</span>
	    <span class="s1">case </span><span class="s0">'milliseconds'</span><span class="s2">:</span>
	    <span class="s1">case </span><span class="s0">'millisecond'</span><span class="s2">:</span>
	    <span class="s1">case </span><span class="s0">'msecs'</span><span class="s2">:</span>
	    <span class="s1">case </span><span class="s0">'msec'</span><span class="s2">:</span>
	    <span class="s1">case </span><span class="s0">'ms'</span><span class="s2">:</span>
	      <span class="s1">return </span><span class="s2">n</span><span class="s1">;</span>
	    <span class="s1">default</span><span class="s2">:</span>
	      <span class="s1">return </span><span class="s2">undefined</span><span class="s1">;</span>
	  <span class="s2">}</span>
	<span class="s2">}</span>

	<span class="s3">/**</span>
	 <span class="s3">* Short format for `ms`.</span>
	 <span class="s3">*</span>
	 <span class="s3">* </span><span class="s6">@param </span><span class="s3">{Number} ms</span>
	 <span class="s3">* </span><span class="s6">@return </span><span class="s3">{String}</span>
	 <span class="s3">* </span><span class="s6">@api </span><span class="s3">private</span>
	 <span class="s3">*/</span>

	<span class="s1">function </span><span class="s2">fmtShort(ms) {</span>
	  <span class="s1">var </span><span class="s2">msAbs = Math.abs(ms)</span><span class="s1">;</span>
	  <span class="s1">if </span><span class="s2">(msAbs &gt;= d) {</span>
	    <span class="s1">return </span><span class="s2">Math.round(ms / d) + </span><span class="s0">'d'</span><span class="s1">;</span>
	  <span class="s2">}</span>
	  <span class="s1">if </span><span class="s2">(msAbs &gt;= h) {</span>
	    <span class="s1">return </span><span class="s2">Math.round(ms / h) + </span><span class="s0">'h'</span><span class="s1">;</span>
	  <span class="s2">}</span>
	  <span class="s1">if </span><span class="s2">(msAbs &gt;= m) {</span>
	    <span class="s1">return </span><span class="s2">Math.round(ms / m) + </span><span class="s0">'m'</span><span class="s1">;</span>
	  <span class="s2">}</span>
	  <span class="s1">if </span><span class="s2">(msAbs &gt;= s) {</span>
	    <span class="s1">return </span><span class="s2">Math.round(ms / s) + </span><span class="s0">'s'</span><span class="s1">;</span>
	  <span class="s2">}</span>
	  <span class="s1">return </span><span class="s2">ms + </span><span class="s0">'ms'</span><span class="s1">;</span>
	<span class="s2">}</span>

	<span class="s3">/**</span>
	 <span class="s3">* Long format for `ms`.</span>
	 <span class="s3">*</span>
	 <span class="s3">* </span><span class="s6">@param </span><span class="s3">{Number} ms</span>
	 <span class="s3">* </span><span class="s6">@return </span><span class="s3">{String}</span>
	 <span class="s3">* </span><span class="s6">@api </span><span class="s3">private</span>
	 <span class="s3">*/</span>

	<span class="s1">function </span><span class="s2">fmtLong(ms) {</span>
	  <span class="s1">var </span><span class="s2">msAbs = Math.abs(ms)</span><span class="s1">;</span>
	  <span class="s1">if </span><span class="s2">(msAbs &gt;= d) {</span>
	    <span class="s1">return </span><span class="s2">plural(ms</span><span class="s1">, </span><span class="s2">msAbs</span><span class="s1">, </span><span class="s2">d</span><span class="s1">, </span><span class="s0">'day'</span><span class="s2">)</span><span class="s1">;</span>
	  <span class="s2">}</span>
	  <span class="s1">if </span><span class="s2">(msAbs &gt;= h) {</span>
	    <span class="s1">return </span><span class="s2">plural(ms</span><span class="s1">, </span><span class="s2">msAbs</span><span class="s1">, </span><span class="s2">h</span><span class="s1">, </span><span class="s0">'hour'</span><span class="s2">)</span><span class="s1">;</span>
	  <span class="s2">}</span>
	  <span class="s1">if </span><span class="s2">(msAbs &gt;= m) {</span>
	    <span class="s1">return </span><span class="s2">plural(ms</span><span class="s1">, </span><span class="s2">msAbs</span><span class="s1">, </span><span class="s2">m</span><span class="s1">, </span><span class="s0">'minute'</span><span class="s2">)</span><span class="s1">;</span>
	  <span class="s2">}</span>
	  <span class="s1">if </span><span class="s2">(msAbs &gt;= s) {</span>
	    <span class="s1">return </span><span class="s2">plural(ms</span><span class="s1">, </span><span class="s2">msAbs</span><span class="s1">, </span><span class="s2">s</span><span class="s1">, </span><span class="s0">'second'</span><span class="s2">)</span><span class="s1">;</span>
	  <span class="s2">}</span>
	  <span class="s1">return </span><span class="s2">ms + </span><span class="s0">' ms'</span><span class="s1">;</span>
	<span class="s2">}</span>

	<span class="s3">/**</span>
	 <span class="s3">* Pluralization helper.</span>
	 <span class="s3">*/</span>

	<span class="s1">function </span><span class="s2">plural(ms</span><span class="s1">, </span><span class="s2">msAbs</span><span class="s1">, </span><span class="s2">n</span><span class="s1">, </span><span class="s2">name) {</span>
	  <span class="s1">var </span><span class="s2">isPlural = msAbs &gt;= n * </span><span class="s5">1.5</span><span class="s1">;</span>
	  <span class="s1">return </span><span class="s2">Math.round(ms / n) + </span><span class="s0">' ' </span><span class="s2">+ name + (isPlural ? </span><span class="s0">'s' </span><span class="s2">: </span><span class="s0">''</span><span class="s2">)</span><span class="s1">;</span>
	<span class="s2">}</span>
	<span class="s1">return </span><span class="s2">ms</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s1">var </span><span class="s2">common</span><span class="s1">;</span>
<span class="s1">var </span><span class="s2">hasRequiredCommon</span><span class="s1">;</span>

<span class="s1">function </span><span class="s2">requireCommon () {</span>
	<span class="s1">if </span><span class="s2">(hasRequiredCommon) </span><span class="s1">return </span><span class="s2">common</span><span class="s1">;</span>
	<span class="s2">hasRequiredCommon = </span><span class="s5">1</span><span class="s1">;</span>
	<span class="s3">/**</span>
	 <span class="s3">* This is the common logic for both the Node.js and web browser</span>
	 <span class="s3">* implementations of `debug()`.</span>
	 <span class="s3">*/</span>

	<span class="s1">function </span><span class="s2">setup(env) {</span>
		<span class="s2">createDebug.debug = createDebug</span><span class="s1">;</span>
		<span class="s2">createDebug.default = createDebug</span><span class="s1">;</span>
		<span class="s2">createDebug.coerce = coerce</span><span class="s1">;</span>
		<span class="s2">createDebug.disable = disable</span><span class="s1">;</span>
		<span class="s2">createDebug.enable = enable</span><span class="s1">;</span>
		<span class="s2">createDebug.enabled = enabled</span><span class="s1">;</span>
		<span class="s2">createDebug.humanize = requireMs()</span><span class="s1">;</span>
		<span class="s2">createDebug.destroy = destroy</span><span class="s1">;</span>

		<span class="s2">Object.keys(env).forEach(key =&gt; {</span>
			<span class="s2">createDebug[key] = env[key]</span><span class="s1">;</span>
		<span class="s2">})</span><span class="s1">;</span>

		<span class="s3">/**</span>
		<span class="s3">* The currently active debug mode names, and names to skip.</span>
		<span class="s3">*/</span>

		<span class="s2">createDebug.names = []</span><span class="s1">;</span>
		<span class="s2">createDebug.skips = []</span><span class="s1">;</span>

		<span class="s3">/**</span>
		<span class="s3">* Map of special &quot;%n&quot; handling functions, for the debug &quot;format&quot; argument.</span>
		<span class="s3">*</span>
		<span class="s3">* Valid key names are a single, lower or upper-case letter, i.e. &quot;n&quot; and &quot;N&quot;.</span>
		<span class="s3">*/</span>
		<span class="s2">createDebug.formatters = {}</span><span class="s1">;</span>

		<span class="s3">/**</span>
		<span class="s3">* Selects a color for a debug namespace</span>
		<span class="s3">* </span><span class="s6">@param </span><span class="s3">{String} namespace The namespace string for the debug instance to be colored</span>
		<span class="s3">* </span><span class="s6">@return </span><span class="s3">{Number|String} An ANSI color code for the given namespace</span>
		<span class="s3">* </span><span class="s6">@api </span><span class="s3">private</span>
		<span class="s3">*/</span>
		<span class="s1">function </span><span class="s2">selectColor(namespace) {</span>
			<span class="s1">let </span><span class="s2">hash = </span><span class="s5">0</span><span class="s1">;</span>

			<span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s5">0</span><span class="s1">; </span><span class="s2">i &lt; namespace.length</span><span class="s1">; </span><span class="s2">i++) {</span>
				<span class="s2">hash = ((hash &lt;&lt; </span><span class="s5">5</span><span class="s2">) - hash) + namespace.charCodeAt(i)</span><span class="s1">;</span>
				<span class="s2">hash |= </span><span class="s5">0</span><span class="s1">; </span><span class="s4">// Convert to 32bit integer</span>
			<span class="s2">}</span>

			<span class="s1">return </span><span class="s2">createDebug.colors[Math.abs(hash) % createDebug.colors.length]</span><span class="s1">;</span>
		<span class="s2">}</span>
		<span class="s2">createDebug.selectColor = selectColor</span><span class="s1">;</span>

		<span class="s3">/**</span>
		<span class="s3">* Create a debugger with the given `namespace`.</span>
		<span class="s3">*</span>
		<span class="s3">* </span><span class="s6">@param </span><span class="s3">{String} namespace</span>
		<span class="s3">* </span><span class="s6">@return </span><span class="s3">{Function}</span>
		<span class="s3">* </span><span class="s6">@api </span><span class="s3">public</span>
		<span class="s3">*/</span>
		<span class="s1">function </span><span class="s2">createDebug(namespace) {</span>
			<span class="s1">let </span><span class="s2">prevTime</span><span class="s1">;</span>
			<span class="s1">let </span><span class="s2">enableOverride = </span><span class="s1">null;</span>
			<span class="s1">let </span><span class="s2">namespacesCache</span><span class="s1">;</span>
			<span class="s1">let </span><span class="s2">enabledCache</span><span class="s1">;</span>

			<span class="s1">function </span><span class="s2">debug(...args) {</span>
				<span class="s4">// Disabled?</span>
				<span class="s1">if </span><span class="s2">(!debug.enabled) {</span>
					<span class="s1">return;</span>
				<span class="s2">}</span>

				<span class="s1">const </span><span class="s2">self = debug</span><span class="s1">;</span>

				<span class="s4">// Set `diff` timestamp</span>
				<span class="s1">const </span><span class="s2">curr = Number(</span><span class="s1">new </span><span class="s2">Date())</span><span class="s1">;</span>
				<span class="s1">const </span><span class="s2">ms = curr - (prevTime || curr)</span><span class="s1">;</span>
				<span class="s2">self.diff = ms</span><span class="s1">;</span>
				<span class="s2">self.prev = prevTime</span><span class="s1">;</span>
				<span class="s2">self.curr = curr</span><span class="s1">;</span>
				<span class="s2">prevTime = curr</span><span class="s1">;</span>

				<span class="s2">args[</span><span class="s5">0</span><span class="s2">] = createDebug.coerce(args[</span><span class="s5">0</span><span class="s2">])</span><span class="s1">;</span>

				<span class="s1">if </span><span class="s2">(</span><span class="s1">typeof </span><span class="s2">args[</span><span class="s5">0</span><span class="s2">] !== </span><span class="s0">'string'</span><span class="s2">) {</span>
					<span class="s4">// Anything else let's inspect with %O</span>
					<span class="s2">args.unshift(</span><span class="s0">'%O'</span><span class="s2">)</span><span class="s1">;</span>
				<span class="s2">}</span>

				<span class="s4">// Apply any `formatters` transformations</span>
				<span class="s1">let </span><span class="s2">index = </span><span class="s5">0</span><span class="s1">;</span>
				<span class="s2">args[</span><span class="s5">0</span><span class="s2">] = args[</span><span class="s5">0</span><span class="s2">].replace(</span><span class="s5">/%([a-zA-Z%])/g</span><span class="s1">, </span><span class="s2">(match</span><span class="s1">, </span><span class="s2">format) =&gt; {</span>
					<span class="s4">// If we encounter an escaped % then don't increase the array index</span>
					<span class="s1">if </span><span class="s2">(match === </span><span class="s0">'%%'</span><span class="s2">) {</span>
						<span class="s1">return </span><span class="s0">'%'</span><span class="s1">;</span>
					<span class="s2">}</span>
					<span class="s2">index++</span><span class="s1">;</span>
					<span class="s1">const </span><span class="s2">formatter = createDebug.formatters[format]</span><span class="s1">;</span>
					<span class="s1">if </span><span class="s2">(</span><span class="s1">typeof </span><span class="s2">formatter === </span><span class="s0">'function'</span><span class="s2">) {</span>
						<span class="s1">const </span><span class="s2">val = args[index]</span><span class="s1">;</span>
						<span class="s2">match = formatter.call(self</span><span class="s1">, </span><span class="s2">val)</span><span class="s1">;</span>

						<span class="s4">// Now we need to remove `args[index]` since it's inlined in the `format`</span>
						<span class="s2">args.splice(index</span><span class="s1">, </span><span class="s5">1</span><span class="s2">)</span><span class="s1">;</span>
						<span class="s2">index--</span><span class="s1">;</span>
					<span class="s2">}</span>
					<span class="s1">return </span><span class="s2">match</span><span class="s1">;</span>
				<span class="s2">})</span><span class="s1">;</span>

				<span class="s4">// Apply env-specific formatting (colors, etc.)</span>
				<span class="s2">createDebug.formatArgs.call(self</span><span class="s1">, </span><span class="s2">args)</span><span class="s1">;</span>

				<span class="s1">const </span><span class="s2">logFn = self.log || createDebug.log</span><span class="s1">;</span>
				<span class="s2">logFn.apply(self</span><span class="s1">, </span><span class="s2">args)</span><span class="s1">;</span>
			<span class="s2">}</span>

			<span class="s2">debug.namespace = namespace</span><span class="s1">;</span>
			<span class="s2">debug.useColors = createDebug.useColors()</span><span class="s1">;</span>
			<span class="s2">debug.color = createDebug.selectColor(namespace)</span><span class="s1">;</span>
			<span class="s2">debug.extend = extend</span><span class="s1">;</span>
			<span class="s2">debug.destroy = createDebug.destroy</span><span class="s1">; </span><span class="s4">// XXX Temporary. Will be removed in the next major release.</span>

			<span class="s2">Object.defineProperty(debug</span><span class="s1">, </span><span class="s0">'enabled'</span><span class="s1">, </span><span class="s2">{</span>
				<span class="s2">enumerable: </span><span class="s1">true,</span>
				<span class="s2">configurable: </span><span class="s1">false,</span>
				<span class="s2">get: () =&gt; {</span>
					<span class="s1">if </span><span class="s2">(enableOverride !== </span><span class="s1">null</span><span class="s2">) {</span>
						<span class="s1">return </span><span class="s2">enableOverride</span><span class="s1">;</span>
					<span class="s2">}</span>
					<span class="s1">if </span><span class="s2">(namespacesCache !== createDebug.namespaces) {</span>
						<span class="s2">namespacesCache = createDebug.namespaces</span><span class="s1">;</span>
						<span class="s2">enabledCache = createDebug.enabled(namespace)</span><span class="s1">;</span>
					<span class="s2">}</span>

					<span class="s1">return </span><span class="s2">enabledCache</span><span class="s1">;</span>
				<span class="s2">}</span><span class="s1">,</span>
				<span class="s2">set: v =&gt; {</span>
					<span class="s2">enableOverride = v</span><span class="s1">;</span>
				<span class="s2">}</span>
			<span class="s2">})</span><span class="s1">;</span>

			<span class="s4">// Env-specific initialization logic for debug instances</span>
			<span class="s1">if </span><span class="s2">(</span><span class="s1">typeof </span><span class="s2">createDebug.init === </span><span class="s0">'function'</span><span class="s2">) {</span>
				<span class="s2">createDebug.init(debug)</span><span class="s1">;</span>
			<span class="s2">}</span>

			<span class="s1">return </span><span class="s2">debug</span><span class="s1">;</span>
		<span class="s2">}</span>

		<span class="s1">function </span><span class="s2">extend(namespace</span><span class="s1">, </span><span class="s2">delimiter) {</span>
			<span class="s1">const </span><span class="s2">newDebug = createDebug(</span><span class="s1">this</span><span class="s2">.namespace + (</span><span class="s1">typeof </span><span class="s2">delimiter === </span><span class="s0">'undefined' </span><span class="s2">? </span><span class="s0">':' </span><span class="s2">: delimiter) + namespace)</span><span class="s1">;</span>
			<span class="s2">newDebug.log = </span><span class="s1">this</span><span class="s2">.log</span><span class="s1">;</span>
			<span class="s1">return </span><span class="s2">newDebug</span><span class="s1">;</span>
		<span class="s2">}</span>

		<span class="s3">/**</span>
		<span class="s3">* Enables a debug mode by namespaces. This can include modes</span>
		<span class="s3">* separated by a colon and wildcards.</span>
		<span class="s3">*</span>
		<span class="s3">* </span><span class="s6">@param </span><span class="s3">{String} namespaces</span>
		<span class="s3">* </span><span class="s6">@api </span><span class="s3">public</span>
		<span class="s3">*/</span>
		<span class="s1">function </span><span class="s2">enable(namespaces) {</span>
			<span class="s2">createDebug.save(namespaces)</span><span class="s1">;</span>
			<span class="s2">createDebug.namespaces = namespaces</span><span class="s1">;</span>

			<span class="s2">createDebug.names = []</span><span class="s1">;</span>
			<span class="s2">createDebug.skips = []</span><span class="s1">;</span>

			<span class="s1">let </span><span class="s2">i</span><span class="s1">;</span>
			<span class="s1">const </span><span class="s2">split = (</span><span class="s1">typeof </span><span class="s2">namespaces === </span><span class="s0">'string' </span><span class="s2">? namespaces : </span><span class="s0">''</span><span class="s2">).split(</span><span class="s5">/[\s,]+/</span><span class="s2">)</span><span class="s1">;</span>
			<span class="s1">const </span><span class="s2">len = split.length</span><span class="s1">;</span>

			<span class="s1">for </span><span class="s2">(i = </span><span class="s5">0</span><span class="s1">; </span><span class="s2">i &lt; len</span><span class="s1">; </span><span class="s2">i++) {</span>
				<span class="s1">if </span><span class="s2">(!split[i]) {</span>
					<span class="s4">// ignore empty strings</span>
					<span class="s1">continue;</span>
				<span class="s2">}</span>

				<span class="s2">namespaces = split[i].replace(</span><span class="s5">/\*/g</span><span class="s1">, </span><span class="s0">'.*?'</span><span class="s2">)</span><span class="s1">;</span>

				<span class="s1">if </span><span class="s2">(namespaces[</span><span class="s5">0</span><span class="s2">] === </span><span class="s0">'-'</span><span class="s2">) {</span>
					<span class="s2">createDebug.skips.push(</span><span class="s1">new </span><span class="s2">RegExp(</span><span class="s0">'^' </span><span class="s2">+ namespaces.slice(</span><span class="s5">1</span><span class="s2">) + </span><span class="s0">'$'</span><span class="s2">))</span><span class="s1">;</span>
				<span class="s2">} </span><span class="s1">else </span><span class="s2">{</span>
					<span class="s2">createDebug.names.push(</span><span class="s1">new </span><span class="s2">RegExp(</span><span class="s0">'^' </span><span class="s2">+ namespaces + </span><span class="s0">'$'</span><span class="s2">))</span><span class="s1">;</span>
				<span class="s2">}</span>
			<span class="s2">}</span>
		<span class="s2">}</span>

		<span class="s3">/**</span>
		<span class="s3">* Disable debug output.</span>
		<span class="s3">*</span>
		<span class="s3">* </span><span class="s6">@return </span><span class="s3">{String} namespaces</span>
		<span class="s3">* </span><span class="s6">@api </span><span class="s3">public</span>
		<span class="s3">*/</span>
		<span class="s1">function </span><span class="s2">disable() {</span>
			<span class="s1">const </span><span class="s2">namespaces = [</span>
				<span class="s2">...createDebug.names.map(toNamespace)</span><span class="s1">,</span>
				<span class="s2">...createDebug.skips.map(toNamespace).map(namespace =&gt; </span><span class="s0">'-' </span><span class="s2">+ namespace)</span>
			<span class="s2">].join(</span><span class="s0">','</span><span class="s2">)</span><span class="s1">;</span>
			<span class="s2">createDebug.enable(</span><span class="s0">''</span><span class="s2">)</span><span class="s1">;</span>
			<span class="s1">return </span><span class="s2">namespaces</span><span class="s1">;</span>
		<span class="s2">}</span>

		<span class="s3">/**</span>
		<span class="s3">* Returns true if the given mode name is enabled, false otherwise.</span>
		<span class="s3">*</span>
		<span class="s3">* </span><span class="s6">@param </span><span class="s3">{String} name</span>
		<span class="s3">* </span><span class="s6">@return </span><span class="s3">{Boolean}</span>
		<span class="s3">* </span><span class="s6">@api </span><span class="s3">public</span>
		<span class="s3">*/</span>
		<span class="s1">function </span><span class="s2">enabled(name) {</span>
			<span class="s1">if </span><span class="s2">(name[name.length - </span><span class="s5">1</span><span class="s2">] === </span><span class="s0">'*'</span><span class="s2">) {</span>
				<span class="s1">return true;</span>
			<span class="s2">}</span>

			<span class="s1">let </span><span class="s2">i</span><span class="s1">;</span>
			<span class="s1">let </span><span class="s2">len</span><span class="s1">;</span>

			<span class="s1">for </span><span class="s2">(i = </span><span class="s5">0</span><span class="s1">, </span><span class="s2">len = createDebug.skips.length</span><span class="s1">; </span><span class="s2">i &lt; len</span><span class="s1">; </span><span class="s2">i++) {</span>
				<span class="s1">if </span><span class="s2">(createDebug.skips[i].test(name)) {</span>
					<span class="s1">return false;</span>
				<span class="s2">}</span>
			<span class="s2">}</span>

			<span class="s1">for </span><span class="s2">(i = </span><span class="s5">0</span><span class="s1">, </span><span class="s2">len = createDebug.names.length</span><span class="s1">; </span><span class="s2">i &lt; len</span><span class="s1">; </span><span class="s2">i++) {</span>
				<span class="s1">if </span><span class="s2">(createDebug.names[i].test(name)) {</span>
					<span class="s1">return true;</span>
				<span class="s2">}</span>
			<span class="s2">}</span>

			<span class="s1">return false;</span>
		<span class="s2">}</span>

		<span class="s3">/**</span>
		<span class="s3">* Convert regexp to namespace</span>
		<span class="s3">*</span>
		<span class="s3">* </span><span class="s6">@param </span><span class="s3">{RegExp} regxep</span>
		<span class="s3">* </span><span class="s6">@return </span><span class="s3">{String} namespace</span>
		<span class="s3">* </span><span class="s6">@api </span><span class="s3">private</span>
		<span class="s3">*/</span>
		<span class="s1">function </span><span class="s2">toNamespace(regexp) {</span>
			<span class="s1">return </span><span class="s2">regexp.toString()</span>
				<span class="s2">.substring(</span><span class="s5">2</span><span class="s1">, </span><span class="s2">regexp.toString().length - </span><span class="s5">2</span><span class="s2">)</span>
				<span class="s2">.replace(</span><span class="s5">/\.\*\?$/</span><span class="s1">, </span><span class="s0">'*'</span><span class="s2">)</span><span class="s1">;</span>
		<span class="s2">}</span>

		<span class="s3">/**</span>
		<span class="s3">* Coerce `val`.</span>
		<span class="s3">*</span>
		<span class="s3">* </span><span class="s6">@param </span><span class="s3">{Mixed} val</span>
		<span class="s3">* </span><span class="s6">@return </span><span class="s3">{Mixed}</span>
		<span class="s3">* </span><span class="s6">@api </span><span class="s3">private</span>
		<span class="s3">*/</span>
		<span class="s1">function </span><span class="s2">coerce(val) {</span>
			<span class="s1">if </span><span class="s2">(val </span><span class="s1">instanceof </span><span class="s2">Error) {</span>
				<span class="s1">return </span><span class="s2">val.stack || val.message</span><span class="s1">;</span>
			<span class="s2">}</span>
			<span class="s1">return </span><span class="s2">val</span><span class="s1">;</span>
		<span class="s2">}</span>

		<span class="s3">/**</span>
		<span class="s3">* XXX DO NOT USE. This is a temporary stub function.</span>
		<span class="s3">* XXX It WILL be removed in the next major release.</span>
		<span class="s3">*/</span>
		<span class="s1">function </span><span class="s2">destroy() {</span>
			<span class="s2">console.warn(</span><span class="s0">'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'</span><span class="s2">)</span><span class="s1">;</span>
		<span class="s2">}</span>

		<span class="s2">createDebug.enable(createDebug.load())</span><span class="s1">;</span>

		<span class="s1">return </span><span class="s2">createDebug</span><span class="s1">;</span>
	<span class="s2">}</span>

	<span class="s2">common = setup</span><span class="s1">;</span>
	<span class="s1">return </span><span class="s2">common</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s4">/* eslint-env browser */</span>

<span class="s1">var </span><span class="s2">hasRequiredBrowser</span><span class="s1">;</span>

<span class="s1">function </span><span class="s2">requireBrowser () {</span>
	<span class="s1">if </span><span class="s2">(hasRequiredBrowser) </span><span class="s1">return </span><span class="s2">browserExports</span><span class="s1">;</span>
	<span class="s2">hasRequiredBrowser = </span><span class="s5">1</span><span class="s1">;</span>
	<span class="s2">(</span><span class="s1">function </span><span class="s2">(module</span><span class="s1">, </span><span class="s2">exports) {</span>
		<span class="s3">/**</span>
		 <span class="s3">* This is the web browser implementation of `debug()`.</span>
		 <span class="s3">*/</span>

		<span class="s2">exports.formatArgs = formatArgs</span><span class="s1">;</span>
		<span class="s2">exports.save = save</span><span class="s1">;</span>
		<span class="s2">exports.load = load</span><span class="s1">;</span>
		<span class="s2">exports.useColors = useColors</span><span class="s1">;</span>
		<span class="s2">exports.storage = localstorage()</span><span class="s1">;</span>
		<span class="s2">exports.destroy = (() =&gt; {</span>
			<span class="s1">let </span><span class="s2">warned = </span><span class="s1">false;</span>

			<span class="s1">return </span><span class="s2">() =&gt; {</span>
				<span class="s1">if </span><span class="s2">(!warned) {</span>
					<span class="s2">warned = </span><span class="s1">true;</span>
					<span class="s2">console.warn(</span><span class="s0">'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'</span><span class="s2">)</span><span class="s1">;</span>
				<span class="s2">}</span>
			<span class="s2">}</span><span class="s1">;</span>
		<span class="s2">})()</span><span class="s1">;</span>

		<span class="s3">/**</span>
		 <span class="s3">* Colors.</span>
		 <span class="s3">*/</span>

		<span class="s2">exports.colors = [</span>
			<span class="s0">'#0000CC'</span><span class="s1">,</span>
			<span class="s0">'#0000FF'</span><span class="s1">,</span>
			<span class="s0">'#0033CC'</span><span class="s1">,</span>
			<span class="s0">'#0033FF'</span><span class="s1">,</span>
			<span class="s0">'#0066CC'</span><span class="s1">,</span>
			<span class="s0">'#0066FF'</span><span class="s1">,</span>
			<span class="s0">'#0099CC'</span><span class="s1">,</span>
			<span class="s0">'#0099FF'</span><span class="s1">,</span>
			<span class="s0">'#00CC00'</span><span class="s1">,</span>
			<span class="s0">'#00CC33'</span><span class="s1">,</span>
			<span class="s0">'#00CC66'</span><span class="s1">,</span>
			<span class="s0">'#00CC99'</span><span class="s1">,</span>
			<span class="s0">'#00CCCC'</span><span class="s1">,</span>
			<span class="s0">'#00CCFF'</span><span class="s1">,</span>
			<span class="s0">'#3300CC'</span><span class="s1">,</span>
			<span class="s0">'#3300FF'</span><span class="s1">,</span>
			<span class="s0">'#3333CC'</span><span class="s1">,</span>
			<span class="s0">'#3333FF'</span><span class="s1">,</span>
			<span class="s0">'#3366CC'</span><span class="s1">,</span>
			<span class="s0">'#3366FF'</span><span class="s1">,</span>
			<span class="s0">'#3399CC'</span><span class="s1">,</span>
			<span class="s0">'#3399FF'</span><span class="s1">,</span>
			<span class="s0">'#33CC00'</span><span class="s1">,</span>
			<span class="s0">'#33CC33'</span><span class="s1">,</span>
			<span class="s0">'#33CC66'</span><span class="s1">,</span>
			<span class="s0">'#33CC99'</span><span class="s1">,</span>
			<span class="s0">'#33CCCC'</span><span class="s1">,</span>
			<span class="s0">'#33CCFF'</span><span class="s1">,</span>
			<span class="s0">'#6600CC'</span><span class="s1">,</span>
			<span class="s0">'#6600FF'</span><span class="s1">,</span>
			<span class="s0">'#6633CC'</span><span class="s1">,</span>
			<span class="s0">'#6633FF'</span><span class="s1">,</span>
			<span class="s0">'#66CC00'</span><span class="s1">,</span>
			<span class="s0">'#66CC33'</span><span class="s1">,</span>
			<span class="s0">'#9900CC'</span><span class="s1">,</span>
			<span class="s0">'#9900FF'</span><span class="s1">,</span>
			<span class="s0">'#9933CC'</span><span class="s1">,</span>
			<span class="s0">'#9933FF'</span><span class="s1">,</span>
			<span class="s0">'#99CC00'</span><span class="s1">,</span>
			<span class="s0">'#99CC33'</span><span class="s1">,</span>
			<span class="s0">'#CC0000'</span><span class="s1">,</span>
			<span class="s0">'#CC0033'</span><span class="s1">,</span>
			<span class="s0">'#CC0066'</span><span class="s1">,</span>
			<span class="s0">'#CC0099'</span><span class="s1">,</span>
			<span class="s0">'#CC00CC'</span><span class="s1">,</span>
			<span class="s0">'#CC00FF'</span><span class="s1">,</span>
			<span class="s0">'#CC3300'</span><span class="s1">,</span>
			<span class="s0">'#CC3333'</span><span class="s1">,</span>
			<span class="s0">'#CC3366'</span><span class="s1">,</span>
			<span class="s0">'#CC3399'</span><span class="s1">,</span>
			<span class="s0">'#CC33CC'</span><span class="s1">,</span>
			<span class="s0">'#CC33FF'</span><span class="s1">,</span>
			<span class="s0">'#CC6600'</span><span class="s1">,</span>
			<span class="s0">'#CC6633'</span><span class="s1">,</span>
			<span class="s0">'#CC9900'</span><span class="s1">,</span>
			<span class="s0">'#CC9933'</span><span class="s1">,</span>
			<span class="s0">'#CCCC00'</span><span class="s1">,</span>
			<span class="s0">'#CCCC33'</span><span class="s1">,</span>
			<span class="s0">'#FF0000'</span><span class="s1">,</span>
			<span class="s0">'#FF0033'</span><span class="s1">,</span>
			<span class="s0">'#FF0066'</span><span class="s1">,</span>
			<span class="s0">'#FF0099'</span><span class="s1">,</span>
			<span class="s0">'#FF00CC'</span><span class="s1">,</span>
			<span class="s0">'#FF00FF'</span><span class="s1">,</span>
			<span class="s0">'#FF3300'</span><span class="s1">,</span>
			<span class="s0">'#FF3333'</span><span class="s1">,</span>
			<span class="s0">'#FF3366'</span><span class="s1">,</span>
			<span class="s0">'#FF3399'</span><span class="s1">,</span>
			<span class="s0">'#FF33CC'</span><span class="s1">,</span>
			<span class="s0">'#FF33FF'</span><span class="s1">,</span>
			<span class="s0">'#FF6600'</span><span class="s1">,</span>
			<span class="s0">'#FF6633'</span><span class="s1">,</span>
			<span class="s0">'#FF9900'</span><span class="s1">,</span>
			<span class="s0">'#FF9933'</span><span class="s1">,</span>
			<span class="s0">'#FFCC00'</span><span class="s1">,</span>
			<span class="s0">'#FFCC33'</span>
		<span class="s2">]</span><span class="s1">;</span>

		<span class="s3">/**</span>
		 <span class="s3">* Currently only WebKit-based Web Inspectors, Firefox &gt;= v31,</span>
		 <span class="s3">* and the Firebug extension (any Firefox version) are known</span>
		 <span class="s3">* to support &quot;%c&quot; CSS customizations.</span>
		 <span class="s3">*</span>
		 <span class="s3">* TODO: add a `localStorage` variable to explicitly enable/disable colors</span>
		 <span class="s3">*/</span>

		<span class="s4">// eslint-disable-next-line complexity</span>
		<span class="s1">function </span><span class="s2">useColors() {</span>
			<span class="s4">// NB: In an Electron preload script, document will be defined but not fully</span>
			<span class="s4">// initialized. Since we know we're in Chrome, we'll just detect this case</span>
			<span class="s4">// explicitly</span>
			<span class="s1">if </span><span class="s2">(</span><span class="s1">typeof </span><span class="s2">window !== </span><span class="s0">'undefined' </span><span class="s2">&amp;&amp; window.process &amp;&amp; (window.process.type === </span><span class="s0">'renderer' </span><span class="s2">|| window.process.__nwjs)) {</span>
				<span class="s1">return true;</span>
			<span class="s2">}</span>

			<span class="s4">// Internet Explorer and Edge do not support colors.</span>
			<span class="s1">if </span><span class="s2">(</span><span class="s1">typeof </span><span class="s2">navigator !== </span><span class="s0">'undefined' </span><span class="s2">&amp;&amp; navigator.userAgent &amp;&amp; navigator.userAgent.toLowerCase().match(</span><span class="s5">/(edge|trident)\/(\d+)/</span><span class="s2">)) {</span>
				<span class="s1">return false;</span>
			<span class="s2">}</span>

			<span class="s4">// Is webkit? http://stackoverflow.com/a/16459606/376773</span>
			<span class="s4">// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632</span>
			<span class="s1">return </span><span class="s2">(</span><span class="s1">typeof </span><span class="s2">document !== </span><span class="s0">'undefined' </span><span class="s2">&amp;&amp; document.documentElement &amp;&amp; document.documentElement.style &amp;&amp; document.documentElement.style.WebkitAppearance) ||</span>
				<span class="s4">// Is firebug? http://stackoverflow.com/a/398120/376773</span>
				<span class="s2">(</span><span class="s1">typeof </span><span class="s2">window !== </span><span class="s0">'undefined' </span><span class="s2">&amp;&amp; window.console &amp;&amp; (window.console.firebug || (window.console.exception &amp;&amp; window.console.table))) ||</span>
				<span class="s4">// Is firefox &gt;= v31?</span>
				<span class="s4">// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages</span>
				<span class="s2">(</span><span class="s1">typeof </span><span class="s2">navigator !== </span><span class="s0">'undefined' </span><span class="s2">&amp;&amp; navigator.userAgent &amp;&amp; navigator.userAgent.toLowerCase().match(</span><span class="s5">/firefox\/(\d+)/</span><span class="s2">) &amp;&amp; parseInt(RegExp.$1</span><span class="s1">, </span><span class="s5">10</span><span class="s2">) &gt;= </span><span class="s5">31</span><span class="s2">) ||</span>
				<span class="s4">// Double check webkit in userAgent just in case we are in a worker</span>
				<span class="s2">(</span><span class="s1">typeof </span><span class="s2">navigator !== </span><span class="s0">'undefined' </span><span class="s2">&amp;&amp; navigator.userAgent &amp;&amp; navigator.userAgent.toLowerCase().match(</span><span class="s5">/applewebkit\/(\d+)/</span><span class="s2">))</span><span class="s1">;</span>
		<span class="s2">}</span>

		<span class="s3">/**</span>
		 <span class="s3">* Colorize log arguments if enabled.</span>
		 <span class="s3">*</span>
		 <span class="s3">* </span><span class="s6">@api </span><span class="s3">public</span>
		 <span class="s3">*/</span>

		<span class="s1">function </span><span class="s2">formatArgs(args) {</span>
			<span class="s2">args[</span><span class="s5">0</span><span class="s2">] = (</span><span class="s1">this</span><span class="s2">.useColors ? </span><span class="s0">'%c' </span><span class="s2">: </span><span class="s0">''</span><span class="s2">) +</span>
				<span class="s1">this</span><span class="s2">.namespace +</span>
				<span class="s2">(</span><span class="s1">this</span><span class="s2">.useColors ? </span><span class="s0">' %c' </span><span class="s2">: </span><span class="s0">' '</span><span class="s2">) +</span>
				<span class="s2">args[</span><span class="s5">0</span><span class="s2">] +</span>
				<span class="s2">(</span><span class="s1">this</span><span class="s2">.useColors ? </span><span class="s0">'%c ' </span><span class="s2">: </span><span class="s0">' '</span><span class="s2">) +</span>
				<span class="s0">'+' </span><span class="s2">+ module.exports.humanize(</span><span class="s1">this</span><span class="s2">.diff)</span><span class="s1">;</span>

			<span class="s1">if </span><span class="s2">(!</span><span class="s1">this</span><span class="s2">.useColors) {</span>
				<span class="s1">return;</span>
			<span class="s2">}</span>

			<span class="s1">const </span><span class="s2">c = </span><span class="s0">'color: ' </span><span class="s2">+ </span><span class="s1">this</span><span class="s2">.color</span><span class="s1">;</span>
			<span class="s2">args.splice(</span><span class="s5">1</span><span class="s1">, </span><span class="s5">0</span><span class="s1">, </span><span class="s2">c</span><span class="s1">, </span><span class="s0">'color: inherit'</span><span class="s2">)</span><span class="s1">;</span>

			<span class="s4">// The final &quot;%c&quot; is somewhat tricky, because there could be other</span>
			<span class="s4">// arguments passed either before or after the %c, so we need to</span>
			<span class="s4">// figure out the correct index to insert the CSS into</span>
			<span class="s1">let </span><span class="s2">index = </span><span class="s5">0</span><span class="s1">;</span>
			<span class="s1">let </span><span class="s2">lastC = </span><span class="s5">0</span><span class="s1">;</span>
			<span class="s2">args[</span><span class="s5">0</span><span class="s2">].replace(</span><span class="s5">/%[a-zA-Z%]/g</span><span class="s1">, </span><span class="s2">match =&gt; {</span>
				<span class="s1">if </span><span class="s2">(match === </span><span class="s0">'%%'</span><span class="s2">) {</span>
					<span class="s1">return;</span>
				<span class="s2">}</span>
				<span class="s2">index++</span><span class="s1">;</span>
				<span class="s1">if </span><span class="s2">(match === </span><span class="s0">'%c'</span><span class="s2">) {</span>
					<span class="s4">// We only are interested in the *last* %c</span>
					<span class="s4">// (the user may have provided their own)</span>
					<span class="s2">lastC = index</span><span class="s1">;</span>
				<span class="s2">}</span>
			<span class="s2">})</span><span class="s1">;</span>

			<span class="s2">args.splice(lastC</span><span class="s1">, </span><span class="s5">0</span><span class="s1">, </span><span class="s2">c)</span><span class="s1">;</span>
		<span class="s2">}</span>

		<span class="s3">/**</span>
		 <span class="s3">* Invokes `console.debug()` when available.</span>
		 <span class="s3">* No-op when `console.debug` is not a &quot;function&quot;.</span>
		 <span class="s3">* If `console.debug` is not available, falls back</span>
		 <span class="s3">* to `console.log`.</span>
		 <span class="s3">*</span>
		 <span class="s3">* </span><span class="s6">@api </span><span class="s3">public</span>
		 <span class="s3">*/</span>
		<span class="s2">exports.log = console.debug || console.log || (() =&gt; {})</span><span class="s1">;</span>

		<span class="s3">/**</span>
		 <span class="s3">* Save `namespaces`.</span>
		 <span class="s3">*</span>
		 <span class="s3">* </span><span class="s6">@param </span><span class="s3">{String} namespaces</span>
		 <span class="s3">* </span><span class="s6">@api </span><span class="s3">private</span>
		 <span class="s3">*/</span>
		<span class="s1">function </span><span class="s2">save(namespaces) {</span>
			<span class="s1">try </span><span class="s2">{</span>
				<span class="s1">if </span><span class="s2">(namespaces) {</span>
					<span class="s2">exports.storage.setItem(</span><span class="s0">'debug'</span><span class="s1">, </span><span class="s2">namespaces)</span><span class="s1">;</span>
				<span class="s2">} </span><span class="s1">else </span><span class="s2">{</span>
					<span class="s2">exports.storage.removeItem(</span><span class="s0">'debug'</span><span class="s2">)</span><span class="s1">;</span>
				<span class="s2">}</span>
			<span class="s2">} </span><span class="s1">catch </span><span class="s2">(error) {</span>
				<span class="s4">// Swallow</span>
				<span class="s4">// XXX (@Qix-) should we be logging these?</span>
			<span class="s2">}</span>
		<span class="s2">}</span>

		<span class="s3">/**</span>
		 <span class="s3">* Load `namespaces`.</span>
		 <span class="s3">*</span>
		 <span class="s3">* </span><span class="s6">@return </span><span class="s3">{String} returns the previously persisted debug modes</span>
		 <span class="s3">* </span><span class="s6">@api </span><span class="s3">private</span>
		 <span class="s3">*/</span>
		<span class="s1">function </span><span class="s2">load() {</span>
			<span class="s1">let </span><span class="s2">r</span><span class="s1">;</span>
			<span class="s1">try </span><span class="s2">{</span>
				<span class="s2">r = exports.storage.getItem(</span><span class="s0">'debug'</span><span class="s2">)</span><span class="s1">;</span>
			<span class="s2">} </span><span class="s1">catch </span><span class="s2">(error) {</span>
				<span class="s4">// Swallow</span>
				<span class="s4">// XXX (@Qix-) should we be logging these?</span>
			<span class="s2">}</span>

			<span class="s4">// If debug isn't set in LS, and we're in Electron, try to load $DEBUG</span>
			<span class="s1">if </span><span class="s2">(!r &amp;&amp; </span><span class="s1">typeof </span><span class="s2">process !== </span><span class="s0">'undefined' </span><span class="s2">&amp;&amp; </span><span class="s0">'env' </span><span class="s1">in </span><span class="s2">process) {</span>
				<span class="s2">r = process.env.DEBUG</span><span class="s1">;</span>
			<span class="s2">}</span>

			<span class="s1">return </span><span class="s2">r</span><span class="s1">;</span>
		<span class="s2">}</span>

		<span class="s3">/**</span>
		 <span class="s3">* Localstorage attempts to return the localstorage.</span>
		 <span class="s3">*</span>
		 <span class="s3">* This is necessary because safari throws</span>
		 <span class="s3">* when a user disables cookies/localstorage</span>
		 <span class="s3">* and you attempt to access it.</span>
		 <span class="s3">*</span>
		 <span class="s3">* </span><span class="s6">@return </span><span class="s3">{LocalStorage}</span>
		 <span class="s3">* </span><span class="s6">@api </span><span class="s3">private</span>
		 <span class="s3">*/</span>

		<span class="s1">function </span><span class="s2">localstorage() {</span>
			<span class="s1">try </span><span class="s2">{</span>
				<span class="s4">// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context</span>
				<span class="s4">// The Browser also has localStorage in the global context.</span>
				<span class="s1">return </span><span class="s2">localStorage</span><span class="s1">;</span>
			<span class="s2">} </span><span class="s1">catch </span><span class="s2">(error) {</span>
				<span class="s4">// Swallow</span>
				<span class="s4">// XXX (@Qix-) should we be logging these?</span>
			<span class="s2">}</span>
		<span class="s2">}</span>

		<span class="s2">module.exports = requireCommon()(exports)</span><span class="s1">;</span>

		<span class="s1">const </span><span class="s2">{formatters} = module.exports</span><span class="s1">;</span>

		<span class="s3">/**</span>
		 <span class="s3">* Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.</span>
		 <span class="s3">*/</span>

		<span class="s2">formatters.j = </span><span class="s1">function </span><span class="s2">(v) {</span>
			<span class="s1">try </span><span class="s2">{</span>
				<span class="s1">return </span><span class="s2">JSON.stringify(v)</span><span class="s1">;</span>
			<span class="s2">} </span><span class="s1">catch </span><span class="s2">(error) {</span>
				<span class="s1">return </span><span class="s0">'[UnexpectedJSONParseError]: ' </span><span class="s2">+ error.message</span><span class="s1">;</span>
			<span class="s2">}</span>
		<span class="s2">}</span><span class="s1">;</span>
<span class="s2">} (browser</span><span class="s1">, </span><span class="s2">browserExports))</span><span class="s1">;</span>
	<span class="s1">return </span><span class="s2">browserExports</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s1">var </span><span class="s2">nodeExports = {}</span><span class="s1">;</span>
<span class="s1">var </span><span class="s2">node = {</span>
  <span class="s2">get exports(){ </span><span class="s1">return </span><span class="s2">nodeExports</span><span class="s1">; </span><span class="s2">}</span><span class="s1">,</span>
  <span class="s2">set exports(v){ nodeExports = v</span><span class="s1">; </span><span class="s2">}</span><span class="s1">,</span>
<span class="s2">}</span><span class="s1">;</span>

<span class="s3">/**</span>
 <span class="s3">* Module dependencies.</span>
 <span class="s3">*/</span>

<span class="s1">var </span><span class="s2">hasRequiredNode</span><span class="s1">;</span>

<span class="s1">function </span><span class="s2">requireNode () {</span>
	<span class="s1">if </span><span class="s2">(hasRequiredNode) </span><span class="s1">return </span><span class="s2">nodeExports</span><span class="s1">;</span>
	<span class="s2">hasRequiredNode = </span><span class="s5">1</span><span class="s1">;</span>
	<span class="s2">(</span><span class="s1">function </span><span class="s2">(module</span><span class="s1">, </span><span class="s2">exports) {</span>
		<span class="s1">const </span><span class="s2">tty = require$$0</span><span class="s1">;</span>
		<span class="s1">const </span><span class="s2">util = require$$1</span><span class="s1">;</span>

		<span class="s3">/**</span>
		 <span class="s3">* This is the Node.js implementation of `debug()`.</span>
		 <span class="s3">*/</span>

		<span class="s2">exports.init = init</span><span class="s1">;</span>
		<span class="s2">exports.log = log</span><span class="s1">;</span>
		<span class="s2">exports.formatArgs = formatArgs</span><span class="s1">;</span>
		<span class="s2">exports.save = save</span><span class="s1">;</span>
		<span class="s2">exports.load = load</span><span class="s1">;</span>
		<span class="s2">exports.useColors = useColors</span><span class="s1">;</span>
		<span class="s2">exports.destroy = util.deprecate(</span>
			<span class="s2">() =&gt; {}</span><span class="s1">,</span>
			<span class="s0">'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'</span>
		<span class="s2">)</span><span class="s1">;</span>

		<span class="s3">/**</span>
		 <span class="s3">* Colors.</span>
		 <span class="s3">*/</span>

		<span class="s2">exports.colors = [</span><span class="s5">6</span><span class="s1">, </span><span class="s5">2</span><span class="s1">, </span><span class="s5">3</span><span class="s1">, </span><span class="s5">4</span><span class="s1">, </span><span class="s5">5</span><span class="s1">, </span><span class="s5">1</span><span class="s2">]</span><span class="s1">;</span>

		<span class="s1">try </span><span class="s2">{</span>
			<span class="s4">// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)</span>
			<span class="s4">// eslint-disable-next-line import/no-extraneous-dependencies</span>
			<span class="s1">const </span><span class="s2">supportsColor = require(</span><span class="s0">'supports-color'</span><span class="s2">)</span><span class="s1">;</span>

			<span class="s1">if </span><span class="s2">(supportsColor &amp;&amp; (supportsColor.stderr || supportsColor).level &gt;= </span><span class="s5">2</span><span class="s2">) {</span>
				<span class="s2">exports.colors = [</span>
					<span class="s5">20</span><span class="s1">,</span>
					<span class="s5">21</span><span class="s1">,</span>
					<span class="s5">26</span><span class="s1">,</span>
					<span class="s5">27</span><span class="s1">,</span>
					<span class="s5">32</span><span class="s1">,</span>
					<span class="s5">33</span><span class="s1">,</span>
					<span class="s5">38</span><span class="s1">,</span>
					<span class="s5">39</span><span class="s1">,</span>
					<span class="s5">40</span><span class="s1">,</span>
					<span class="s5">41</span><span class="s1">,</span>
					<span class="s5">42</span><span class="s1">,</span>
					<span class="s5">43</span><span class="s1">,</span>
					<span class="s5">44</span><span class="s1">,</span>
					<span class="s5">45</span><span class="s1">,</span>
					<span class="s5">56</span><span class="s1">,</span>
					<span class="s5">57</span><span class="s1">,</span>
					<span class="s5">62</span><span class="s1">,</span>
					<span class="s5">63</span><span class="s1">,</span>
					<span class="s5">68</span><span class="s1">,</span>
					<span class="s5">69</span><span class="s1">,</span>
					<span class="s5">74</span><span class="s1">,</span>
					<span class="s5">75</span><span class="s1">,</span>
					<span class="s5">76</span><span class="s1">,</span>
					<span class="s5">77</span><span class="s1">,</span>
					<span class="s5">78</span><span class="s1">,</span>
					<span class="s5">79</span><span class="s1">,</span>
					<span class="s5">80</span><span class="s1">,</span>
					<span class="s5">81</span><span class="s1">,</span>
					<span class="s5">92</span><span class="s1">,</span>
					<span class="s5">93</span><span class="s1">,</span>
					<span class="s5">98</span><span class="s1">,</span>
					<span class="s5">99</span><span class="s1">,</span>
					<span class="s5">112</span><span class="s1">,</span>
					<span class="s5">113</span><span class="s1">,</span>
					<span class="s5">128</span><span class="s1">,</span>
					<span class="s5">129</span><span class="s1">,</span>
					<span class="s5">134</span><span class="s1">,</span>
					<span class="s5">135</span><span class="s1">,</span>
					<span class="s5">148</span><span class="s1">,</span>
					<span class="s5">149</span><span class="s1">,</span>
					<span class="s5">160</span><span class="s1">,</span>
					<span class="s5">161</span><span class="s1">,</span>
					<span class="s5">162</span><span class="s1">,</span>
					<span class="s5">163</span><span class="s1">,</span>
					<span class="s5">164</span><span class="s1">,</span>
					<span class="s5">165</span><span class="s1">,</span>
					<span class="s5">166</span><span class="s1">,</span>
					<span class="s5">167</span><span class="s1">,</span>
					<span class="s5">168</span><span class="s1">,</span>
					<span class="s5">169</span><span class="s1">,</span>
					<span class="s5">170</span><span class="s1">,</span>
					<span class="s5">171</span><span class="s1">,</span>
					<span class="s5">172</span><span class="s1">,</span>
					<span class="s5">173</span><span class="s1">,</span>
					<span class="s5">178</span><span class="s1">,</span>
					<span class="s5">179</span><span class="s1">,</span>
					<span class="s5">184</span><span class="s1">,</span>
					<span class="s5">185</span><span class="s1">,</span>
					<span class="s5">196</span><span class="s1">,</span>
					<span class="s5">197</span><span class="s1">,</span>
					<span class="s5">198</span><span class="s1">,</span>
					<span class="s5">199</span><span class="s1">,</span>
					<span class="s5">200</span><span class="s1">,</span>
					<span class="s5">201</span><span class="s1">,</span>
					<span class="s5">202</span><span class="s1">,</span>
					<span class="s5">203</span><span class="s1">,</span>
					<span class="s5">204</span><span class="s1">,</span>
					<span class="s5">205</span><span class="s1">,</span>
					<span class="s5">206</span><span class="s1">,</span>
					<span class="s5">207</span><span class="s1">,</span>
					<span class="s5">208</span><span class="s1">,</span>
					<span class="s5">209</span><span class="s1">,</span>
					<span class="s5">214</span><span class="s1">,</span>
					<span class="s5">215</span><span class="s1">,</span>
					<span class="s5">220</span><span class="s1">,</span>
					<span class="s5">221</span>
				<span class="s2">]</span><span class="s1">;</span>
			<span class="s2">}</span>
		<span class="s2">} </span><span class="s1">catch </span><span class="s2">(error) {</span>
			<span class="s4">// Swallow - we only care if `supports-color` is available; it doesn't have to be.</span>
		<span class="s2">}</span>

		<span class="s3">/**</span>
		 <span class="s3">* Build up the default `inspectOpts` object from the environment variables.</span>
		 <span class="s3">*</span>
		 <span class="s3">*   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js</span>
		 <span class="s3">*/</span>

		<span class="s2">exports.inspectOpts = Object.keys(process.env).filter(key =&gt; {</span>
			<span class="s1">return </span><span class="s5">/^debug_/i</span><span class="s2">.test(key)</span><span class="s1">;</span>
		<span class="s2">}).reduce((obj</span><span class="s1">, </span><span class="s2">key) =&gt; {</span>
			<span class="s4">// Camel-case</span>
			<span class="s1">const </span><span class="s2">prop = key</span>
				<span class="s2">.substring(</span><span class="s5">6</span><span class="s2">)</span>
				<span class="s2">.toLowerCase()</span>
				<span class="s2">.replace(</span><span class="s5">/_([a-z])/g</span><span class="s1">, </span><span class="s2">(_</span><span class="s1">, </span><span class="s2">k) =&gt; {</span>
					<span class="s1">return </span><span class="s2">k.toUpperCase()</span><span class="s1">;</span>
				<span class="s2">})</span><span class="s1">;</span>

			<span class="s4">// Coerce string value into JS value</span>
			<span class="s1">let </span><span class="s2">val = process.env[key]</span><span class="s1">;</span>
			<span class="s1">if </span><span class="s2">(</span><span class="s5">/^(yes|on|true|enabled)$/i</span><span class="s2">.test(val)) {</span>
				<span class="s2">val = </span><span class="s1">true;</span>
			<span class="s2">} </span><span class="s1">else if </span><span class="s2">(</span><span class="s5">/^(no|off|false|disabled)$/i</span><span class="s2">.test(val)) {</span>
				<span class="s2">val = </span><span class="s1">false;</span>
			<span class="s2">} </span><span class="s1">else if </span><span class="s2">(val === </span><span class="s0">'null'</span><span class="s2">) {</span>
				<span class="s2">val = </span><span class="s1">null;</span>
			<span class="s2">} </span><span class="s1">else </span><span class="s2">{</span>
				<span class="s2">val = Number(val)</span><span class="s1">;</span>
			<span class="s2">}</span>

			<span class="s2">obj[prop] = val</span><span class="s1">;</span>
			<span class="s1">return </span><span class="s2">obj</span><span class="s1">;</span>
		<span class="s2">}</span><span class="s1">, </span><span class="s2">{})</span><span class="s1">;</span>

		<span class="s3">/**</span>
		 <span class="s3">* Is stdout a TTY? Colored output is enabled when `true`.</span>
		 <span class="s3">*/</span>

		<span class="s1">function </span><span class="s2">useColors() {</span>
			<span class="s1">return </span><span class="s0">'colors' </span><span class="s1">in </span><span class="s2">exports.inspectOpts ?</span>
				<span class="s2">Boolean(exports.inspectOpts.colors) :</span>
				<span class="s2">tty.isatty(process.stderr.fd)</span><span class="s1">;</span>
		<span class="s2">}</span>

		<span class="s3">/**</span>
		 <span class="s3">* Adds ANSI color escape codes if enabled.</span>
		 <span class="s3">*</span>
		 <span class="s3">* </span><span class="s6">@api </span><span class="s3">public</span>
		 <span class="s3">*/</span>

		<span class="s1">function </span><span class="s2">formatArgs(args) {</span>
			<span class="s1">const </span><span class="s2">{namespace: name</span><span class="s1">, </span><span class="s2">useColors} = </span><span class="s1">this;</span>

			<span class="s1">if </span><span class="s2">(useColors) {</span>
				<span class="s1">const </span><span class="s2">c = </span><span class="s1">this</span><span class="s2">.color</span><span class="s1">;</span>
				<span class="s1">const </span><span class="s2">colorCode = </span><span class="s0">'</span><span class="s1">\u001B</span><span class="s0">[3' </span><span class="s2">+ (c &lt; </span><span class="s5">8 </span><span class="s2">? c : </span><span class="s0">'8;5;' </span><span class="s2">+ c)</span><span class="s1">;</span>
				<span class="s1">const </span><span class="s2">prefix = </span><span class="s0">`  </span><span class="s2">${colorCode}</span><span class="s0">;1m</span><span class="s2">${name} </span><span class="s1">\u001B</span><span class="s0">[0m`</span><span class="s1">;</span>

				<span class="s2">args[</span><span class="s5">0</span><span class="s2">] = prefix + args[</span><span class="s5">0</span><span class="s2">].split(</span><span class="s0">'</span><span class="s1">\n</span><span class="s0">'</span><span class="s2">).join(</span><span class="s0">'</span><span class="s1">\n</span><span class="s0">' </span><span class="s2">+ prefix)</span><span class="s1">;</span>
				<span class="s2">args.push(colorCode + </span><span class="s0">'m+' </span><span class="s2">+ module.exports.humanize(</span><span class="s1">this</span><span class="s2">.diff) + </span><span class="s0">'</span><span class="s1">\u001B</span><span class="s0">[0m'</span><span class="s2">)</span><span class="s1">;</span>
			<span class="s2">} </span><span class="s1">else </span><span class="s2">{</span>
				<span class="s2">args[</span><span class="s5">0</span><span class="s2">] = getDate() + name + </span><span class="s0">' ' </span><span class="s2">+ args[</span><span class="s5">0</span><span class="s2">]</span><span class="s1">;</span>
			<span class="s2">}</span>
		<span class="s2">}</span>

		<span class="s1">function </span><span class="s2">getDate() {</span>
			<span class="s1">if </span><span class="s2">(exports.inspectOpts.hideDate) {</span>
				<span class="s1">return </span><span class="s0">''</span><span class="s1">;</span>
			<span class="s2">}</span>
			<span class="s1">return new </span><span class="s2">Date().toISOString() + </span><span class="s0">' '</span><span class="s1">;</span>
		<span class="s2">}</span>

		<span class="s3">/**</span>
		 <span class="s3">* Invokes `util.format()` with the specified arguments and writes to stderr.</span>
		 <span class="s3">*/</span>

		<span class="s1">function </span><span class="s2">log(...args) {</span>
			<span class="s1">return </span><span class="s2">process.stderr.write(util.format(...args) + </span><span class="s0">'</span><span class="s1">\n</span><span class="s0">'</span><span class="s2">)</span><span class="s1">;</span>
		<span class="s2">}</span>

		<span class="s3">/**</span>
		 <span class="s3">* Save `namespaces`.</span>
		 <span class="s3">*</span>
		 <span class="s3">* </span><span class="s6">@param </span><span class="s3">{String} namespaces</span>
		 <span class="s3">* </span><span class="s6">@api </span><span class="s3">private</span>
		 <span class="s3">*/</span>
		<span class="s1">function </span><span class="s2">save(namespaces) {</span>
			<span class="s1">if </span><span class="s2">(namespaces) {</span>
				<span class="s2">process.env.DEBUG = namespaces</span><span class="s1">;</span>
			<span class="s2">} </span><span class="s1">else </span><span class="s2">{</span>
				<span class="s4">// If you set a process.env field to null or undefined, it gets cast to the</span>
				<span class="s4">// string 'null' or 'undefined'. Just delete instead.</span>
				<span class="s1">delete </span><span class="s2">process.env.DEBUG</span><span class="s1">;</span>
			<span class="s2">}</span>
		<span class="s2">}</span>

		<span class="s3">/**</span>
		 <span class="s3">* Load `namespaces`.</span>
		 <span class="s3">*</span>
		 <span class="s3">* </span><span class="s6">@return </span><span class="s3">{String} returns the previously persisted debug modes</span>
		 <span class="s3">* </span><span class="s6">@api </span><span class="s3">private</span>
		 <span class="s3">*/</span>

		<span class="s1">function </span><span class="s2">load() {</span>
			<span class="s1">return </span><span class="s2">process.env.DEBUG</span><span class="s1">;</span>
		<span class="s2">}</span>

		<span class="s3">/**</span>
		 <span class="s3">* Init logic for `debug` instances.</span>
		 <span class="s3">*</span>
		 <span class="s3">* Create a new `inspectOpts` object in case `useColors` is set</span>
		 <span class="s3">* differently for a particular `debug` instance.</span>
		 <span class="s3">*/</span>

		<span class="s1">function </span><span class="s2">init(debug) {</span>
			<span class="s2">debug.inspectOpts = {}</span><span class="s1">;</span>

			<span class="s1">const </span><span class="s2">keys = Object.keys(exports.inspectOpts)</span><span class="s1">;</span>
			<span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s5">0</span><span class="s1">; </span><span class="s2">i &lt; keys.length</span><span class="s1">; </span><span class="s2">i++) {</span>
				<span class="s2">debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]]</span><span class="s1">;</span>
			<span class="s2">}</span>
		<span class="s2">}</span>

		<span class="s2">module.exports = requireCommon()(exports)</span><span class="s1">;</span>

		<span class="s1">const </span><span class="s2">{formatters} = module.exports</span><span class="s1">;</span>

		<span class="s3">/**</span>
		 <span class="s3">* Map %o to `util.inspect()`, all on a single line.</span>
		 <span class="s3">*/</span>

		<span class="s2">formatters.o = </span><span class="s1">function </span><span class="s2">(v) {</span>
			<span class="s1">this</span><span class="s2">.inspectOpts.colors = </span><span class="s1">this</span><span class="s2">.useColors</span><span class="s1">;</span>
			<span class="s1">return </span><span class="s2">util.inspect(v</span><span class="s1">, this</span><span class="s2">.inspectOpts)</span>
				<span class="s2">.split(</span><span class="s0">'</span><span class="s1">\n</span><span class="s0">'</span><span class="s2">)</span>
				<span class="s2">.map(str =&gt; str.trim())</span>
				<span class="s2">.join(</span><span class="s0">' '</span><span class="s2">)</span><span class="s1">;</span>
		<span class="s2">}</span><span class="s1">;</span>

		<span class="s3">/**</span>
		 <span class="s3">* Map %O to `util.inspect()`, allowing multiple lines if needed.</span>
		 <span class="s3">*/</span>

		<span class="s2">formatters.O = </span><span class="s1">function </span><span class="s2">(v) {</span>
			<span class="s1">this</span><span class="s2">.inspectOpts.colors = </span><span class="s1">this</span><span class="s2">.useColors</span><span class="s1">;</span>
			<span class="s1">return </span><span class="s2">util.inspect(v</span><span class="s1">, this</span><span class="s2">.inspectOpts)</span><span class="s1">;</span>
		<span class="s2">}</span><span class="s1">;</span>
<span class="s2">} (node</span><span class="s1">, </span><span class="s2">nodeExports))</span><span class="s1">;</span>
	<span class="s1">return </span><span class="s2">nodeExports</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s3">/**</span>
 <span class="s3">* Detect Electron renderer / nwjs process, which is node, but we should</span>
 <span class="s3">* treat as a browser.</span>
 <span class="s3">*/</span>

<span class="s2">(</span><span class="s1">function </span><span class="s2">(module) {</span>
	<span class="s1">if </span><span class="s2">(</span><span class="s1">typeof </span><span class="s2">process === </span><span class="s0">'undefined' </span><span class="s2">|| process.type === </span><span class="s0">'renderer' </span><span class="s2">|| process.browser === </span><span class="s1">true </span><span class="s2">|| process.__nwjs) {</span>
		<span class="s2">module.exports = requireBrowser()</span><span class="s1">;</span>
	<span class="s2">} </span><span class="s1">else </span><span class="s2">{</span>
		<span class="s2">module.exports = requireNode()</span><span class="s1">;</span>
	<span class="s2">}</span>
<span class="s2">} (src))</span><span class="s1">;</span>

<span class="s1">var </span><span class="s2">debug$1 = </span><span class="s4">/*@__PURE__*/</span><span class="s2">getDefaultExportFromCjs(srcExports)</span><span class="s1">;</span>

<span class="s1">var </span><span class="s2">picomatchExports = {}</span><span class="s1">;</span>
<span class="s1">var </span><span class="s2">picomatch$1 = {</span>
  <span class="s2">get exports(){ </span><span class="s1">return </span><span class="s2">picomatchExports</span><span class="s1">; </span><span class="s2">}</span><span class="s1">,</span>
  <span class="s2">set exports(v){ picomatchExports = v</span><span class="s1">; </span><span class="s2">}</span><span class="s1">,</span>
<span class="s2">}</span><span class="s1">;</span>

<span class="s1">var </span><span class="s2">utils$3 = {}</span><span class="s1">;</span>

<span class="s1">const </span><span class="s2">path$2 = require$$0$1</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">WIN_SLASH = </span><span class="s0">'</span><span class="s1">\\\\</span><span class="s0">/'</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">WIN_NO_SLASH = </span><span class="s0">`[^</span><span class="s2">${WIN_SLASH}</span><span class="s0">]`</span><span class="s1">;</span>

<span class="s3">/**</span>
 <span class="s3">* Posix glob regex</span>
 <span class="s3">*/</span>

<span class="s1">const </span><span class="s2">DOT_LITERAL = </span><span class="s0">'</span><span class="s1">\\</span><span class="s0">.'</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">PLUS_LITERAL = </span><span class="s0">'</span><span class="s1">\\</span><span class="s0">+'</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">QMARK_LITERAL = </span><span class="s0">'</span><span class="s1">\\</span><span class="s0">?'</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">SLASH_LITERAL = </span><span class="s0">'</span><span class="s1">\\</span><span class="s0">/'</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">ONE_CHAR = </span><span class="s0">'(?=.)'</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">QMARK = </span><span class="s0">'[^/]'</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">END_ANCHOR = </span><span class="s0">`(?:</span><span class="s2">${SLASH_LITERAL}</span><span class="s0">|$)`</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">START_ANCHOR = </span><span class="s0">`(?:^|</span><span class="s2">${SLASH_LITERAL}</span><span class="s0">)`</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">DOTS_SLASH = </span><span class="s0">`</span><span class="s2">${DOT_LITERAL}</span><span class="s0">{1,2}</span><span class="s2">${END_ANCHOR}</span><span class="s0">`</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">NO_DOT = </span><span class="s0">`(?!</span><span class="s2">${DOT_LITERAL}</span><span class="s0">)`</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">NO_DOTS = </span><span class="s0">`(?!</span><span class="s2">${START_ANCHOR}${DOTS_SLASH}</span><span class="s0">)`</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">NO_DOT_SLASH = </span><span class="s0">`(?!</span><span class="s2">${DOT_LITERAL}</span><span class="s0">{0,1}</span><span class="s2">${END_ANCHOR}</span><span class="s0">)`</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">NO_DOTS_SLASH = </span><span class="s0">`(?!</span><span class="s2">${DOTS_SLASH}</span><span class="s0">)`</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">QMARK_NO_DOT = </span><span class="s0">`[^.</span><span class="s2">${SLASH_LITERAL}</span><span class="s0">]`</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">STAR = </span><span class="s0">`</span><span class="s2">${QMARK}</span><span class="s0">*?`</span><span class="s1">;</span>

<span class="s1">const </span><span class="s2">POSIX_CHARS = {</span>
  <span class="s2">DOT_LITERAL</span><span class="s1">,</span>
  <span class="s2">PLUS_LITERAL</span><span class="s1">,</span>
  <span class="s2">QMARK_LITERAL</span><span class="s1">,</span>
  <span class="s2">SLASH_LITERAL</span><span class="s1">,</span>
  <span class="s2">ONE_CHAR</span><span class="s1">,</span>
  <span class="s2">QMARK</span><span class="s1">,</span>
  <span class="s2">END_ANCHOR</span><span class="s1">,</span>
  <span class="s2">DOTS_SLASH</span><span class="s1">,</span>
  <span class="s2">NO_DOT</span><span class="s1">,</span>
  <span class="s2">NO_DOTS</span><span class="s1">,</span>
  <span class="s2">NO_DOT_SLASH</span><span class="s1">,</span>
  <span class="s2">NO_DOTS_SLASH</span><span class="s1">,</span>
  <span class="s2">QMARK_NO_DOT</span><span class="s1">,</span>
  <span class="s2">STAR</span><span class="s1">,</span>
  <span class="s2">START_ANCHOR</span>
<span class="s2">}</span><span class="s1">;</span>

<span class="s3">/**</span>
 <span class="s3">* Windows glob regex</span>
 <span class="s3">*/</span>

<span class="s1">const </span><span class="s2">WINDOWS_CHARS = {</span>
  <span class="s2">...POSIX_CHARS</span><span class="s1">,</span>

  <span class="s2">SLASH_LITERAL: </span><span class="s0">`[</span><span class="s2">${WIN_SLASH}</span><span class="s0">]`</span><span class="s1">,</span>
  <span class="s2">QMARK: WIN_NO_SLASH</span><span class="s1">,</span>
  <span class="s2">STAR: </span><span class="s0">`</span><span class="s2">${WIN_NO_SLASH}</span><span class="s0">*?`</span><span class="s1">,</span>
  <span class="s2">DOTS_SLASH: </span><span class="s0">`</span><span class="s2">${DOT_LITERAL}</span><span class="s0">{1,2}(?:[</span><span class="s2">${WIN_SLASH}</span><span class="s0">]|$)`</span><span class="s1">,</span>
  <span class="s2">NO_DOT: </span><span class="s0">`(?!</span><span class="s2">${DOT_LITERAL}</span><span class="s0">)`</span><span class="s1">,</span>
  <span class="s2">NO_DOTS: </span><span class="s0">`(?!(?:^|[</span><span class="s2">${WIN_SLASH}</span><span class="s0">])</span><span class="s2">${DOT_LITERAL}</span><span class="s0">{1,2}(?:[</span><span class="s2">${WIN_SLASH}</span><span class="s0">]|$))`</span><span class="s1">,</span>
  <span class="s2">NO_DOT_SLASH: </span><span class="s0">`(?!</span><span class="s2">${DOT_LITERAL}</span><span class="s0">{0,1}(?:[</span><span class="s2">${WIN_SLASH}</span><span class="s0">]|$))`</span><span class="s1">,</span>
  <span class="s2">NO_DOTS_SLASH: </span><span class="s0">`(?!</span><span class="s2">${DOT_LITERAL}</span><span class="s0">{1,2}(?:[</span><span class="s2">${WIN_SLASH}</span><span class="s0">]|$))`</span><span class="s1">,</span>
  <span class="s2">QMARK_NO_DOT: </span><span class="s0">`[^.</span><span class="s2">${WIN_SLASH}</span><span class="s0">]`</span><span class="s1">,</span>
  <span class="s2">START_ANCHOR: </span><span class="s0">`(?:^|[</span><span class="s2">${WIN_SLASH}</span><span class="s0">])`</span><span class="s1">,</span>
  <span class="s2">END_ANCHOR: </span><span class="s0">`(?:[</span><span class="s2">${WIN_SLASH}</span><span class="s0">]|$)`</span>
<span class="s2">}</span><span class="s1">;</span>

<span class="s3">/**</span>
 <span class="s3">* POSIX Bracket Regex</span>
 <span class="s3">*/</span>

<span class="s1">const </span><span class="s2">POSIX_REGEX_SOURCE$1 = {</span>
  <span class="s2">alnum: </span><span class="s0">'a-zA-Z0-9'</span><span class="s1">,</span>
  <span class="s2">alpha: </span><span class="s0">'a-zA-Z'</span><span class="s1">,</span>
  <span class="s2">ascii: </span><span class="s0">'</span><span class="s1">\\</span><span class="s0">x00-</span><span class="s1">\\</span><span class="s0">x7F'</span><span class="s1">,</span>
  <span class="s2">blank: </span><span class="s0">' </span><span class="s1">\\</span><span class="s0">t'</span><span class="s1">,</span>
  <span class="s2">cntrl: </span><span class="s0">'</span><span class="s1">\\</span><span class="s0">x00-</span><span class="s1">\\</span><span class="s0">x1F</span><span class="s1">\\</span><span class="s0">x7F'</span><span class="s1">,</span>
  <span class="s2">digit: </span><span class="s0">'0-9'</span><span class="s1">,</span>
  <span class="s2">graph: </span><span class="s0">'</span><span class="s1">\\</span><span class="s0">x21-</span><span class="s1">\\</span><span class="s0">x7E'</span><span class="s1">,</span>
  <span class="s2">lower: </span><span class="s0">'a-z'</span><span class="s1">,</span>
  <span class="s2">print: </span><span class="s0">'</span><span class="s1">\\</span><span class="s0">x20-</span><span class="s1">\\</span><span class="s0">x7E '</span><span class="s1">,</span>
  <span class="s2">punct: </span><span class="s0">'</span><span class="s1">\\</span><span class="s0">-!&quot;#$%&amp;</span><span class="s1">\'</span><span class="s0">()</span><span class="s1">\\</span><span class="s0">*+,./:;&lt;=&gt;?@[</span><span class="s1">\\</span><span class="s0">]^_`{|}~'</span><span class="s1">,</span>
  <span class="s2">space: </span><span class="s0">' </span><span class="s1">\\</span><span class="s0">t</span><span class="s1">\\</span><span class="s0">r</span><span class="s1">\\</span><span class="s0">n</span><span class="s1">\\</span><span class="s0">v</span><span class="s1">\\</span><span class="s0">f'</span><span class="s1">,</span>
  <span class="s2">upper: </span><span class="s0">'A-Z'</span><span class="s1">,</span>
  <span class="s2">word: </span><span class="s0">'A-Za-z0-9_'</span><span class="s1">,</span>
  <span class="s2">xdigit: </span><span class="s0">'A-Fa-f0-9'</span>
<span class="s2">}</span><span class="s1">;</span>

<span class="s1">var </span><span class="s2">constants$2 = {</span>
  <span class="s2">MAX_LENGTH: </span><span class="s5">1024 </span><span class="s2">* </span><span class="s5">64</span><span class="s1">,</span>
  <span class="s2">POSIX_REGEX_SOURCE: POSIX_REGEX_SOURCE$1</span><span class="s1">,</span>

  <span class="s4">// regular expressions</span>
  <span class="s2">REGEX_BACKSLASH: </span><span class="s5">/\\(?![*+?^${}(|)[\]])/g</span><span class="s1">,</span>
  <span class="s2">REGEX_NON_SPECIAL_CHARS: </span><span class="s5">/^[^@![\].,$*+?^{}()|\\/]+/</span><span class="s1">,</span>
  <span class="s2">REGEX_SPECIAL_CHARS: </span><span class="s5">/[-*+?.^${}(|)[\]]/</span><span class="s1">,</span>
  <span class="s2">REGEX_SPECIAL_CHARS_BACKREF: </span><span class="s5">/(\\?)((\W)(\3*))/g</span><span class="s1">,</span>
  <span class="s2">REGEX_SPECIAL_CHARS_GLOBAL: </span><span class="s5">/([-*+?.^${}(|)[\]])/g</span><span class="s1">,</span>
  <span class="s2">REGEX_REMOVE_BACKSLASH: </span><span class="s5">/(?:\[.*?[^\\]\]|\\(?=.))/g</span><span class="s1">,</span>

  <span class="s4">// Replace globs with equivalent patterns to reduce parsing time.</span>
  <span class="s2">REPLACEMENTS: {</span>
    <span class="s0">'***'</span><span class="s2">: </span><span class="s0">'*'</span><span class="s1">,</span>
    <span class="s0">'**/**'</span><span class="s2">: </span><span class="s0">'**'</span><span class="s1">,</span>
    <span class="s0">'**/**/**'</span><span class="s2">: </span><span class="s0">'**'</span>
  <span class="s2">}</span><span class="s1">,</span>

  <span class="s4">// Digits</span>
  <span class="s2">CHAR_0: </span><span class="s5">48</span><span class="s1">, </span><span class="s4">/* 0 */</span>
  <span class="s2">CHAR_9: </span><span class="s5">57</span><span class="s1">, </span><span class="s4">/* 9 */</span>

  <span class="s4">// Alphabet chars.</span>
  <span class="s2">CHAR_UPPERCASE_A: </span><span class="s5">65</span><span class="s1">, </span><span class="s4">/* A */</span>
  <span class="s2">CHAR_LOWERCASE_A: </span><span class="s5">97</span><span class="s1">, </span><span class="s4">/* a */</span>
  <span class="s2">CHAR_UPPERCASE_Z: </span><span class="s5">90</span><span class="s1">, </span><span class="s4">/* Z */</span>
  <span class="s2">CHAR_LOWERCASE_Z: </span><span class="s5">122</span><span class="s1">, </span><span class="s4">/* z */</span>

  <span class="s2">CHAR_LEFT_PARENTHESES: </span><span class="s5">40</span><span class="s1">, </span><span class="s4">/* ( */</span>
  <span class="s2">CHAR_RIGHT_PARENTHESES: </span><span class="s5">41</span><span class="s1">, </span><span class="s4">/* ) */</span>

  <span class="s2">CHAR_ASTERISK: </span><span class="s5">42</span><span class="s1">, </span><span class="s4">/* * */</span>

  <span class="s4">// Non-alphabetic chars.</span>
  <span class="s2">CHAR_AMPERSAND: </span><span class="s5">38</span><span class="s1">, </span><span class="s4">/* &amp; */</span>
  <span class="s2">CHAR_AT: </span><span class="s5">64</span><span class="s1">, </span><span class="s4">/* @ */</span>
  <span class="s2">CHAR_BACKWARD_SLASH: </span><span class="s5">92</span><span class="s1">, </span><span class="s4">/* \ */</span>
  <span class="s2">CHAR_CARRIAGE_RETURN: </span><span class="s5">13</span><span class="s1">, </span><span class="s4">/* \r */</span>
  <span class="s2">CHAR_CIRCUMFLEX_ACCENT: </span><span class="s5">94</span><span class="s1">, </span><span class="s4">/* ^ */</span>
  <span class="s2">CHAR_COLON: </span><span class="s5">58</span><span class="s1">, </span><span class="s4">/* : */</span>
  <span class="s2">CHAR_COMMA: </span><span class="s5">44</span><span class="s1">, </span><span class="s4">/* , */</span>
  <span class="s2">CHAR_DOT: </span><span class="s5">46</span><span class="s1">, </span><span class="s4">/* . */</span>
  <span class="s2">CHAR_DOUBLE_QUOTE: </span><span class="s5">34</span><span class="s1">, </span><span class="s4">/* &quot; */</span>
  <span class="s2">CHAR_EQUAL: </span><span class="s5">61</span><span class="s1">, </span><span class="s4">/* = */</span>
  <span class="s2">CHAR_EXCLAMATION_MARK: </span><span class="s5">33</span><span class="s1">, </span><span class="s4">/* ! */</span>
  <span class="s2">CHAR_FORM_FEED: </span><span class="s5">12</span><span class="s1">, </span><span class="s4">/* \f */</span>
  <span class="s2">CHAR_FORWARD_SLASH: </span><span class="s5">47</span><span class="s1">, </span><span class="s4">/* / */</span>
  <span class="s2">CHAR_GRAVE_ACCENT: </span><span class="s5">96</span><span class="s1">, </span><span class="s4">/* ` */</span>
  <span class="s2">CHAR_HASH: </span><span class="s5">35</span><span class="s1">, </span><span class="s4">/* # */</span>
  <span class="s2">CHAR_HYPHEN_MINUS: </span><span class="s5">45</span><span class="s1">, </span><span class="s4">/* - */</span>
  <span class="s2">CHAR_LEFT_ANGLE_BRACKET: </span><span class="s5">60</span><span class="s1">, </span><span class="s4">/* &lt; */</span>
  <span class="s2">CHAR_LEFT_CURLY_BRACE: </span><span class="s5">123</span><span class="s1">, </span><span class="s4">/* { */</span>
  <span class="s2">CHAR_LEFT_SQUARE_BRACKET: </span><span class="s5">91</span><span class="s1">, </span><span class="s4">/* [ */</span>
  <span class="s2">CHAR_LINE_FEED: </span><span class="s5">10</span><span class="s1">, </span><span class="s4">/* \n */</span>
  <span class="s2">CHAR_NO_BREAK_SPACE: </span><span class="s5">160</span><span class="s1">, </span><span class="s4">/* \u00A0 */</span>
  <span class="s2">CHAR_PERCENT: </span><span class="s5">37</span><span class="s1">, </span><span class="s4">/* % */</span>
  <span class="s2">CHAR_PLUS: </span><span class="s5">43</span><span class="s1">, </span><span class="s4">/* + */</span>
  <span class="s2">CHAR_QUESTION_MARK: </span><span class="s5">63</span><span class="s1">, </span><span class="s4">/* ? */</span>
  <span class="s2">CHAR_RIGHT_ANGLE_BRACKET: </span><span class="s5">62</span><span class="s1">, </span><span class="s4">/* &gt; */</span>
  <span class="s2">CHAR_RIGHT_CURLY_BRACE: </span><span class="s5">125</span><span class="s1">, </span><span class="s4">/* } */</span>
  <span class="s2">CHAR_RIGHT_SQUARE_BRACKET: </span><span class="s5">93</span><span class="s1">, </span><span class="s4">/* ] */</span>
  <span class="s2">CHAR_SEMICOLON: </span><span class="s5">59</span><span class="s1">, </span><span class="s4">/* ; */</span>
  <span class="s2">CHAR_SINGLE_QUOTE: </span><span class="s5">39</span><span class="s1">, </span><span class="s4">/* ' */</span>
  <span class="s2">CHAR_SPACE: </span><span class="s5">32</span><span class="s1">, </span><span class="s4">/*   */</span>
  <span class="s2">CHAR_TAB: </span><span class="s5">9</span><span class="s1">, </span><span class="s4">/* \t */</span>
  <span class="s2">CHAR_UNDERSCORE: </span><span class="s5">95</span><span class="s1">, </span><span class="s4">/* _ */</span>
  <span class="s2">CHAR_VERTICAL_LINE: </span><span class="s5">124</span><span class="s1">, </span><span class="s4">/* | */</span>
  <span class="s2">CHAR_ZERO_WIDTH_NOBREAK_SPACE: </span><span class="s5">65279</span><span class="s1">, </span><span class="s4">/* \uFEFF */</span>

  <span class="s2">SEP: path$2.sep</span><span class="s1">,</span>

  <span class="s3">/**</span>
   <span class="s3">* Create EXTGLOB_CHARS</span>
   <span class="s3">*/</span>

  <span class="s2">extglobChars(chars) {</span>
    <span class="s1">return </span><span class="s2">{</span>
      <span class="s0">'!'</span><span class="s2">: { type: </span><span class="s0">'negate'</span><span class="s1">, </span><span class="s2">open: </span><span class="s0">'(?:(?!(?:'</span><span class="s1">, </span><span class="s2">close: </span><span class="s0">`))</span><span class="s2">${chars.STAR}</span><span class="s0">)` </span><span class="s2">}</span><span class="s1">,</span>
      <span class="s0">'?'</span><span class="s2">: { type: </span><span class="s0">'qmark'</span><span class="s1">, </span><span class="s2">open: </span><span class="s0">'(?:'</span><span class="s1">, </span><span class="s2">close: </span><span class="s0">')?' </span><span class="s2">}</span><span class="s1">,</span>
      <span class="s0">'+'</span><span class="s2">: { type: </span><span class="s0">'plus'</span><span class="s1">, </span><span class="s2">open: </span><span class="s0">'(?:'</span><span class="s1">, </span><span class="s2">close: </span><span class="s0">')+' </span><span class="s2">}</span><span class="s1">,</span>
      <span class="s0">'*'</span><span class="s2">: { type: </span><span class="s0">'star'</span><span class="s1">, </span><span class="s2">open: </span><span class="s0">'(?:'</span><span class="s1">, </span><span class="s2">close: </span><span class="s0">')*' </span><span class="s2">}</span><span class="s1">,</span>
      <span class="s0">'@'</span><span class="s2">: { type: </span><span class="s0">'at'</span><span class="s1">, </span><span class="s2">open: </span><span class="s0">'(?:'</span><span class="s1">, </span><span class="s2">close: </span><span class="s0">')' </span><span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
  <span class="s2">}</span><span class="s1">,</span>

  <span class="s3">/**</span>
   <span class="s3">* Create GLOB_CHARS</span>
   <span class="s3">*/</span>

  <span class="s2">globChars(win32) {</span>
    <span class="s1">return </span><span class="s2">win32 === </span><span class="s1">true </span><span class="s2">? WINDOWS_CHARS : POSIX_CHARS</span><span class="s1">;</span>
  <span class="s2">}</span>
<span class="s2">}</span><span class="s1">;</span>

<span class="s2">(</span><span class="s1">function </span><span class="s2">(exports) {</span>

	<span class="s1">const </span><span class="s2">path = require$$0$1</span><span class="s1">;</span>
	<span class="s1">const </span><span class="s2">win32 = process.platform === </span><span class="s0">'win32'</span><span class="s1">;</span>
	<span class="s1">const </span><span class="s2">{</span>
	  <span class="s2">REGEX_BACKSLASH</span><span class="s1">,</span>
	  <span class="s2">REGEX_REMOVE_BACKSLASH</span><span class="s1">,</span>
	  <span class="s2">REGEX_SPECIAL_CHARS</span><span class="s1">,</span>
	  <span class="s2">REGEX_SPECIAL_CHARS_GLOBAL</span>
	<span class="s2">} = constants$2</span><span class="s1">;</span>

	<span class="s2">exports.isObject = val =&gt; val !== </span><span class="s1">null </span><span class="s2">&amp;&amp; </span><span class="s1">typeof </span><span class="s2">val === </span><span class="s0">'object' </span><span class="s2">&amp;&amp; !Array.isArray(val)</span><span class="s1">;</span>
	<span class="s2">exports.hasRegexChars = str =&gt; REGEX_SPECIAL_CHARS.test(str)</span><span class="s1">;</span>
	<span class="s2">exports.isRegexChar = str =&gt; str.length === </span><span class="s5">1 </span><span class="s2">&amp;&amp; exports.hasRegexChars(str)</span><span class="s1">;</span>
	<span class="s2">exports.escapeRegex = str =&gt; str.replace(REGEX_SPECIAL_CHARS_GLOBAL</span><span class="s1">, </span><span class="s0">'</span><span class="s1">\\</span><span class="s0">$1'</span><span class="s2">)</span><span class="s1">;</span>
	<span class="s2">exports.toPosixSlashes = str =&gt; str.replace(REGEX_BACKSLASH</span><span class="s1">, </span><span class="s0">'/'</span><span class="s2">)</span><span class="s1">;</span>

	<span class="s2">exports.removeBackslashes = str =&gt; {</span>
	  <span class="s1">return </span><span class="s2">str.replace(REGEX_REMOVE_BACKSLASH</span><span class="s1">, </span><span class="s2">match =&gt; {</span>
	    <span class="s1">return </span><span class="s2">match === </span><span class="s0">'</span><span class="s1">\\</span><span class="s0">' </span><span class="s2">? </span><span class="s0">'' </span><span class="s2">: match</span><span class="s1">;</span>
	  <span class="s2">})</span><span class="s1">;</span>
	<span class="s2">}</span><span class="s1">;</span>

	<span class="s2">exports.supportsLookbehinds = () =&gt; {</span>
	  <span class="s1">const </span><span class="s2">segs = process.version.slice(</span><span class="s5">1</span><span class="s2">).split(</span><span class="s0">'.'</span><span class="s2">).map(Number)</span><span class="s1">;</span>
	  <span class="s1">if </span><span class="s2">(segs.length === </span><span class="s5">3 </span><span class="s2">&amp;&amp; segs[</span><span class="s5">0</span><span class="s2">] &gt;= </span><span class="s5">9 </span><span class="s2">|| (segs[</span><span class="s5">0</span><span class="s2">] === </span><span class="s5">8 </span><span class="s2">&amp;&amp; segs[</span><span class="s5">1</span><span class="s2">] &gt;= </span><span class="s5">10</span><span class="s2">)) {</span>
	    <span class="s1">return true;</span>
	  <span class="s2">}</span>
	  <span class="s1">return false;</span>
	<span class="s2">}</span><span class="s1">;</span>

	<span class="s2">exports.isWindows = options =&gt; {</span>
	  <span class="s1">if </span><span class="s2">(options &amp;&amp; </span><span class="s1">typeof </span><span class="s2">options.windows === </span><span class="s0">'boolean'</span><span class="s2">) {</span>
	    <span class="s1">return </span><span class="s2">options.windows</span><span class="s1">;</span>
	  <span class="s2">}</span>
	  <span class="s1">return </span><span class="s2">win32 === </span><span class="s1">true </span><span class="s2">|| path.sep === </span><span class="s0">'</span><span class="s1">\\</span><span class="s0">'</span><span class="s1">;</span>
	<span class="s2">}</span><span class="s1">;</span>

	<span class="s2">exports.escapeLast = (input</span><span class="s1">, </span><span class="s2">char</span><span class="s1">, </span><span class="s2">lastIdx) =&gt; {</span>
	  <span class="s1">const </span><span class="s2">idx = input.lastIndexOf(char</span><span class="s1">, </span><span class="s2">lastIdx)</span><span class="s1">;</span>
	  <span class="s1">if </span><span class="s2">(idx === -</span><span class="s5">1</span><span class="s2">) </span><span class="s1">return </span><span class="s2">input</span><span class="s1">;</span>
	  <span class="s1">if </span><span class="s2">(input[idx - </span><span class="s5">1</span><span class="s2">] === </span><span class="s0">'</span><span class="s1">\\</span><span class="s0">'</span><span class="s2">) </span><span class="s1">return </span><span class="s2">exports.escapeLast(input</span><span class="s1">, </span><span class="s2">char</span><span class="s1">, </span><span class="s2">idx - </span><span class="s5">1</span><span class="s2">)</span><span class="s1">;</span>
	  <span class="s1">return </span><span class="s0">`</span><span class="s2">${input.slice(</span><span class="s5">0</span><span class="s1">, </span><span class="s2">idx)}</span><span class="s1">\\</span><span class="s2">${input.slice(idx)}</span><span class="s0">`</span><span class="s1">;</span>
	<span class="s2">}</span><span class="s1">;</span>

	<span class="s2">exports.removePrefix = (input</span><span class="s1">, </span><span class="s2">state = {}) =&gt; {</span>
	  <span class="s1">let </span><span class="s2">output = input</span><span class="s1">;</span>
	  <span class="s1">if </span><span class="s2">(output.startsWith(</span><span class="s0">'./'</span><span class="s2">)) {</span>
	    <span class="s2">output = output.slice(</span><span class="s5">2</span><span class="s2">)</span><span class="s1">;</span>
	    <span class="s2">state.prefix = </span><span class="s0">'./'</span><span class="s1">;</span>
	  <span class="s2">}</span>
	  <span class="s1">return </span><span class="s2">output</span><span class="s1">;</span>
	<span class="s2">}</span><span class="s1">;</span>

	<span class="s2">exports.wrapOutput = (input</span><span class="s1">, </span><span class="s2">state = {}</span><span class="s1">, </span><span class="s2">options = {}) =&gt; {</span>
	  <span class="s1">const </span><span class="s2">prepend = options.contains ? </span><span class="s0">'' </span><span class="s2">: </span><span class="s0">'^'</span><span class="s1">;</span>
	  <span class="s1">const </span><span class="s2">append = options.contains ? </span><span class="s0">'' </span><span class="s2">: </span><span class="s0">'$'</span><span class="s1">;</span>

	  <span class="s1">let </span><span class="s2">output = </span><span class="s0">`</span><span class="s2">${prepend}</span><span class="s0">(?:</span><span class="s2">${input}</span><span class="s0">)</span><span class="s2">${append}</span><span class="s0">`</span><span class="s1">;</span>
	  <span class="s1">if </span><span class="s2">(state.negated === </span><span class="s1">true</span><span class="s2">) {</span>
	    <span class="s2">output = </span><span class="s0">`(?:^(?!</span><span class="s2">${output}</span><span class="s0">).*$)`</span><span class="s1">;</span>
	  <span class="s2">}</span>
	  <span class="s1">return </span><span class="s2">output</span><span class="s1">;</span>
	<span class="s2">}</span><span class="s1">;</span>
<span class="s2">} (utils$3))</span><span class="s1">;</span>

<span class="s1">const </span><span class="s2">utils$2 = utils$3</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">{</span>
  <span class="s2">CHAR_ASTERISK</span><span class="s1">,             </span><span class="s4">/* * */</span>
  <span class="s2">CHAR_AT</span><span class="s1">,                   </span><span class="s4">/* @ */</span>
  <span class="s2">CHAR_BACKWARD_SLASH</span><span class="s1">,       </span><span class="s4">/* \ */</span>
  <span class="s2">CHAR_COMMA</span><span class="s1">,                </span><span class="s4">/* , */</span>
  <span class="s2">CHAR_DOT</span><span class="s1">,                  </span><span class="s4">/* . */</span>
  <span class="s2">CHAR_EXCLAMATION_MARK</span><span class="s1">,     </span><span class="s4">/* ! */</span>
  <span class="s2">CHAR_FORWARD_SLASH</span><span class="s1">,        </span><span class="s4">/* / */</span>
  <span class="s2">CHAR_LEFT_CURLY_BRACE</span><span class="s1">,     </span><span class="s4">/* { */</span>
  <span class="s2">CHAR_LEFT_PARENTHESES</span><span class="s1">,     </span><span class="s4">/* ( */</span>
  <span class="s2">CHAR_LEFT_SQUARE_BRACKET</span><span class="s1">,  </span><span class="s4">/* [ */</span>
  <span class="s2">CHAR_PLUS</span><span class="s1">,                 </span><span class="s4">/* + */</span>
  <span class="s2">CHAR_QUESTION_MARK</span><span class="s1">,        </span><span class="s4">/* ? */</span>
  <span class="s2">CHAR_RIGHT_CURLY_BRACE</span><span class="s1">,    </span><span class="s4">/* } */</span>
  <span class="s2">CHAR_RIGHT_PARENTHESES</span><span class="s1">,    </span><span class="s4">/* ) */</span>
  <span class="s2">CHAR_RIGHT_SQUARE_BRACKET  </span><span class="s4">/* ] */</span>
<span class="s2">} = constants$2</span><span class="s1">;</span>

<span class="s1">const </span><span class="s2">isPathSeparator = code =&gt; {</span>
  <span class="s1">return </span><span class="s2">code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH</span><span class="s1">;</span>
<span class="s2">}</span><span class="s1">;</span>

<span class="s1">const </span><span class="s2">depth = token =&gt; {</span>
  <span class="s1">if </span><span class="s2">(token.isPrefix !== </span><span class="s1">true</span><span class="s2">) {</span>
    <span class="s2">token.depth = token.isGlobstar ? Infinity : </span><span class="s5">1</span><span class="s1">;</span>
  <span class="s2">}</span>
<span class="s2">}</span><span class="s1">;</span>

<span class="s3">/**</span>
 <span class="s3">* Quickly scans a glob pattern and returns an object with a handful of</span>
 <span class="s3">* useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),</span>
 <span class="s3">* `glob` (the actual pattern), `negated` (true if the path starts with `!` but not</span>
 <span class="s3">* with `!(`) and `negatedExtglob` (true if the path starts with `!(`).</span>
 <span class="s3">*</span>
 <span class="s3">* ```js</span>
 <span class="s3">* const pm = require('picomatch');</span>
 <span class="s3">* console.log(pm.scan('foo/bar/*.js'));</span>
 <span class="s3">* { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }</span>
 <span class="s3">* ```</span>
 <span class="s3">* </span><span class="s6">@param </span><span class="s3">{String} `str`</span>
 <span class="s3">* </span><span class="s6">@param </span><span class="s3">{Object} `options`</span>
 <span class="s3">* </span><span class="s6">@return </span><span class="s3">{Object} Returns an object with tokens and regex source string.</span>
 <span class="s3">* </span><span class="s6">@api </span><span class="s3">public</span>
 <span class="s3">*/</span>

<span class="s1">const </span><span class="s2">scan$1 = (input</span><span class="s1">, </span><span class="s2">options) =&gt; {</span>
  <span class="s1">const </span><span class="s2">opts = options || {}</span><span class="s1">;</span>

  <span class="s1">const </span><span class="s2">length = input.length - </span><span class="s5">1</span><span class="s1">;</span>
  <span class="s1">const </span><span class="s2">scanToEnd = opts.parts === </span><span class="s1">true </span><span class="s2">|| opts.scanToEnd === </span><span class="s1">true;</span>
  <span class="s1">const </span><span class="s2">slashes = []</span><span class="s1">;</span>
  <span class="s1">const </span><span class="s2">tokens = []</span><span class="s1">;</span>
  <span class="s1">const </span><span class="s2">parts = []</span><span class="s1">;</span>

  <span class="s1">let </span><span class="s2">str = input</span><span class="s1">;</span>
  <span class="s1">let </span><span class="s2">index = -</span><span class="s5">1</span><span class="s1">;</span>
  <span class="s1">let </span><span class="s2">start = </span><span class="s5">0</span><span class="s1">;</span>
  <span class="s1">let </span><span class="s2">lastIndex = </span><span class="s5">0</span><span class="s1">;</span>
  <span class="s1">let </span><span class="s2">isBrace = </span><span class="s1">false;</span>
  <span class="s1">let </span><span class="s2">isBracket = </span><span class="s1">false;</span>
  <span class="s1">let </span><span class="s2">isGlob = </span><span class="s1">false;</span>
  <span class="s1">let </span><span class="s2">isExtglob = </span><span class="s1">false;</span>
  <span class="s1">let </span><span class="s2">isGlobstar = </span><span class="s1">false;</span>
  <span class="s1">let </span><span class="s2">braceEscaped = </span><span class="s1">false;</span>
  <span class="s1">let </span><span class="s2">backslashes = </span><span class="s1">false;</span>
  <span class="s1">let </span><span class="s2">negated = </span><span class="s1">false;</span>
  <span class="s1">let </span><span class="s2">negatedExtglob = </span><span class="s1">false;</span>
  <span class="s1">let </span><span class="s2">finished = </span><span class="s1">false;</span>
  <span class="s1">let </span><span class="s2">braces = </span><span class="s5">0</span><span class="s1">;</span>
  <span class="s1">let </span><span class="s2">prev</span><span class="s1">;</span>
  <span class="s1">let </span><span class="s2">code</span><span class="s1">;</span>
  <span class="s1">let </span><span class="s2">token = { value: </span><span class="s0">''</span><span class="s1">, </span><span class="s2">depth: </span><span class="s5">0</span><span class="s1">, </span><span class="s2">isGlob: </span><span class="s1">false </span><span class="s2">}</span><span class="s1">;</span>

  <span class="s1">const </span><span class="s2">eos = () =&gt; index &gt;= length</span><span class="s1">;</span>
  <span class="s1">const </span><span class="s2">peek = () =&gt; str.charCodeAt(index + </span><span class="s5">1</span><span class="s2">)</span><span class="s1">;</span>
  <span class="s1">const </span><span class="s2">advance = () =&gt; {</span>
    <span class="s2">prev = code</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">str.charCodeAt(++index)</span><span class="s1">;</span>
  <span class="s2">}</span><span class="s1">;</span>

  <span class="s1">while </span><span class="s2">(index &lt; length) {</span>
    <span class="s2">code = advance()</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">next</span><span class="s1">;</span>

    <span class="s1">if </span><span class="s2">(code === CHAR_BACKWARD_SLASH) {</span>
      <span class="s2">backslashes = token.backslashes = </span><span class="s1">true;</span>
      <span class="s2">code = advance()</span><span class="s1">;</span>

      <span class="s1">if </span><span class="s2">(code === CHAR_LEFT_CURLY_BRACE) {</span>
        <span class="s2">braceEscaped = </span><span class="s1">true;</span>
      <span class="s2">}</span>
      <span class="s1">continue;</span>
    <span class="s2">}</span>

    <span class="s1">if </span><span class="s2">(braceEscaped === </span><span class="s1">true </span><span class="s2">|| code === CHAR_LEFT_CURLY_BRACE) {</span>
      <span class="s2">braces++</span><span class="s1">;</span>

      <span class="s1">while </span><span class="s2">(eos() !== </span><span class="s1">true </span><span class="s2">&amp;&amp; (code = advance())) {</span>
        <span class="s1">if </span><span class="s2">(code === CHAR_BACKWARD_SLASH) {</span>
          <span class="s2">backslashes = token.backslashes = </span><span class="s1">true;</span>
          <span class="s2">advance()</span><span class="s1">;</span>
          <span class="s1">continue;</span>
        <span class="s2">}</span>

        <span class="s1">if </span><span class="s2">(code === CHAR_LEFT_CURLY_BRACE) {</span>
          <span class="s2">braces++</span><span class="s1">;</span>
          <span class="s1">continue;</span>
        <span class="s2">}</span>

        <span class="s1">if </span><span class="s2">(braceEscaped !== </span><span class="s1">true </span><span class="s2">&amp;&amp; code === CHAR_DOT &amp;&amp; (code = advance()) === CHAR_DOT) {</span>
          <span class="s2">isBrace = token.isBrace = </span><span class="s1">true;</span>
          <span class="s2">isGlob = token.isGlob = </span><span class="s1">true;</span>
          <span class="s2">finished = </span><span class="s1">true;</span>

          <span class="s1">if </span><span class="s2">(scanToEnd === </span><span class="s1">true</span><span class="s2">) {</span>
            <span class="s1">continue;</span>
          <span class="s2">}</span>

          <span class="s1">break;</span>
        <span class="s2">}</span>

        <span class="s1">if </span><span class="s2">(braceEscaped !== </span><span class="s1">true </span><span class="s2">&amp;&amp; code === CHAR_COMMA) {</span>
          <span class="s2">isBrace = token.isBrace = </span><span class="s1">true;</span>
          <span class="s2">isGlob = token.isGlob = </span><span class="s1">true;</span>
          <span class="s2">finished = </span><span class="s1">true;</span>

          <span class="s1">if </span><span class="s2">(scanToEnd === </span><span class="s1">true</span><span class="s2">) {</span>
            <span class="s1">continue;</span>
          <span class="s2">}</span>

          <span class="s1">break;</span>
        <span class="s2">}</span>

        <span class="s1">if </span><span class="s2">(code === CHAR_RIGHT_CURLY_BRACE) {</span>
          <span class="s2">braces--</span><span class="s1">;</span>

          <span class="s1">if </span><span class="s2">(braces === </span><span class="s5">0</span><span class="s2">) {</span>
            <span class="s2">braceEscaped = </span><span class="s1">false;</span>
            <span class="s2">isBrace = token.isBrace = </span><span class="s1">true;</span>
            <span class="s2">finished = </span><span class="s1">true;</span>
            <span class="s1">break;</span>
          <span class="s2">}</span>
        <span class="s2">}</span>
      <span class="s2">}</span>

      <span class="s1">if </span><span class="s2">(scanToEnd === </span><span class="s1">true</span><span class="s2">) {</span>
        <span class="s1">continue;</span>
      <span class="s2">}</span>

      <span class="s1">break;</span>
    <span class="s2">}</span>

    <span class="s1">if </span><span class="s2">(code === CHAR_FORWARD_SLASH) {</span>
      <span class="s2">slashes.push(index)</span><span class="s1">;</span>
      <span class="s2">tokens.push(token)</span><span class="s1">;</span>
      <span class="s2">token = { value: </span><span class="s0">''</span><span class="s1">, </span><span class="s2">depth: </span><span class="s5">0</span><span class="s1">, </span><span class="s2">isGlob: </span><span class="s1">false </span><span class="s2">}</span><span class="s1">;</span>

      <span class="s1">if </span><span class="s2">(finished === </span><span class="s1">true</span><span class="s2">) </span><span class="s1">continue;</span>
      <span class="s1">if </span><span class="s2">(prev === CHAR_DOT &amp;&amp; index === (start + </span><span class="s5">1</span><span class="s2">)) {</span>
        <span class="s2">start += </span><span class="s5">2</span><span class="s1">;</span>
        <span class="s1">continue;</span>
      <span class="s2">}</span>

      <span class="s2">lastIndex = index + </span><span class="s5">1</span><span class="s1">;</span>
      <span class="s1">continue;</span>
    <span class="s2">}</span>

    <span class="s1">if </span><span class="s2">(opts.noext !== </span><span class="s1">true</span><span class="s2">) {</span>
      <span class="s1">const </span><span class="s2">isExtglobChar = code === CHAR_PLUS</span>
        <span class="s2">|| code === CHAR_AT</span>
        <span class="s2">|| code === CHAR_ASTERISK</span>
        <span class="s2">|| code === CHAR_QUESTION_MARK</span>
        <span class="s2">|| code === CHAR_EXCLAMATION_MARK</span><span class="s1">;</span>

      <span class="s1">if </span><span class="s2">(isExtglobChar === </span><span class="s1">true </span><span class="s2">&amp;&amp; peek() === CHAR_LEFT_PARENTHESES) {</span>
        <span class="s2">isGlob = token.isGlob = </span><span class="s1">true;</span>
        <span class="s2">isExtglob = token.isExtglob = </span><span class="s1">true;</span>
        <span class="s2">finished = </span><span class="s1">true;</span>
        <span class="s1">if </span><span class="s2">(code === CHAR_EXCLAMATION_MARK &amp;&amp; index === start) {</span>
          <span class="s2">negatedExtglob = </span><span class="s1">true;</span>
        <span class="s2">}</span>

        <span class="s1">if </span><span class="s2">(scanToEnd === </span><span class="s1">true</span><span class="s2">) {</span>
          <span class="s1">while </span><span class="s2">(eos() !== </span><span class="s1">true </span><span class="s2">&amp;&amp; (code = advance())) {</span>
            <span class="s1">if </span><span class="s2">(code === CHAR_BACKWARD_SLASH) {</span>
              <span class="s2">backslashes = token.backslashes = </span><span class="s1">true;</span>
              <span class="s2">code = advance()</span><span class="s1">;</span>
              <span class="s1">continue;</span>
            <span class="s2">}</span>

            <span class="s1">if </span><span class="s2">(code === CHAR_RIGHT_PARENTHESES) {</span>
              <span class="s2">isGlob = token.isGlob = </span><span class="s1">true;</span>
              <span class="s2">finished = </span><span class="s1">true;</span>
              <span class="s1">break;</span>
            <span class="s2">}</span>
          <span class="s2">}</span>
          <span class="s1">continue;</span>
        <span class="s2">}</span>
        <span class="s1">break;</span>
      <span class="s2">}</span>
    <span class="s2">}</span>

    <span class="s1">if </span><span class="s2">(code === CHAR_ASTERISK) {</span>
      <span class="s1">if </span><span class="s2">(prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = </span><span class="s1">true;</span>
      <span class="s2">isGlob = token.isGlob = </span><span class="s1">true;</span>
      <span class="s2">finished = </span><span class="s1">true;</span>

      <span class="s1">if </span><span class="s2">(scanToEnd === </span><span class="s1">true</span><span class="s2">) {</span>
        <span class="s1">continue;</span>
      <span class="s2">}</span>
      <span class="s1">break;</span>
    <span class="s2">}</span>

    <span class="s1">if </span><span class="s2">(code === CHAR_QUESTION_MARK) {</span>
      <span class="s2">isGlob = token.isGlob = </span><span class="s1">true;</span>
      <span class="s2">finished = </span><span class="s1">true;</span>

      <span class="s1">if </span><span class="s2">(scanToEnd === </span><span class="s1">true</span><span class="s2">) {</span>
        <span class="s1">continue;</span>
      <span class="s2">}</span>
      <span class="s1">break;</span>
    <span class="s2">}</span>

    <span class="s1">if </span><span class="s2">(code === CHAR_LEFT_SQUARE_BRACKET) {</span>
      <span class="s1">while </span><span class="s2">(eos() !== </span><span class="s1">true </span><span class="s2">&amp;&amp; (next = advance())) {</span>
        <span class="s1">if </span><span class="s2">(next === CHAR_BACKWARD_SLASH) {</span>
          <span class="s2">backslashes = token.backslashes = </span><span class="s1">true;</span>
          <span class="s2">advance()</span><span class="s1">;</span>
          <span class="s1">continue;</span>
        <span class="s2">}</span>

        <span class="s1">if </span><span class="s2">(next === CHAR_RIGHT_SQUARE_BRACKET) {</span>
          <span class="s2">isBracket = token.isBracket = </span><span class="s1">true;</span>
          <span class="s2">isGlob = token.isGlob = </span><span class="s1">true;</span>
          <span class="s2">finished = </span><span class="s1">true;</span>
          <span class="s1">break;</span>
        <span class="s2">}</span>
      <span class="s2">}</span>

      <span class="s1">if </span><span class="s2">(scanToEnd === </span><span class="s1">true</span><span class="s2">) {</span>
        <span class="s1">continue;</span>
      <span class="s2">}</span>

      <span class="s1">break;</span>
    <span class="s2">}</span>

    <span class="s1">if </span><span class="s2">(opts.nonegate !== </span><span class="s1">true </span><span class="s2">&amp;&amp; code === CHAR_EXCLAMATION_MARK &amp;&amp; index === start) {</span>
      <span class="s2">negated = token.negated = </span><span class="s1">true;</span>
      <span class="s2">start++</span><span class="s1">;</span>
      <span class="s1">continue;</span>
    <span class="s2">}</span>

    <span class="s1">if </span><span class="s2">(opts.noparen !== </span><span class="s1">true </span><span class="s2">&amp;&amp; code === CHAR_LEFT_PARENTHESES) {</span>
      <span class="s2">isGlob = token.isGlob = </span><span class="s1">true;</span>

      <span class="s1">if </span><span class="s2">(scanToEnd === </span><span class="s1">true</span><span class="s2">) {</span>
        <span class="s1">while </span><span class="s2">(eos() !== </span><span class="s1">true </span><span class="s2">&amp;&amp; (code = advance())) {</span>
          <span class="s1">if </span><span class="s2">(code === CHAR_LEFT_PARENTHESES) {</span>
            <span class="s2">backslashes = token.backslashes = </span><span class="s1">true;</span>
            <span class="s2">code = advance()</span><span class="s1">;</span>
            <span class="s1">continue;</span>
          <span class="s2">}</span>

          <span class="s1">if </span><span class="s2">(code === CHAR_RIGHT_PARENTHESES) {</span>
            <span class="s2">finished = </span><span class="s1">true;</span>
            <span class="s1">break;</span>
          <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">continue;</span>
      <span class="s2">}</span>
      <span class="s1">break;</span>
    <span class="s2">}</span>

    <span class="s1">if </span><span class="s2">(isGlob === </span><span class="s1">true</span><span class="s2">) {</span>
      <span class="s2">finished = </span><span class="s1">true;</span>

      <span class="s1">if </span><span class="s2">(scanToEnd === </span><span class="s1">true</span><span class="s2">) {</span>
        <span class="s1">continue;</span>
      <span class="s2">}</span>

      <span class="s1">break;</span>
    <span class="s2">}</span>
  <span class="s2">}</span>

  <span class="s1">if </span><span class="s2">(opts.noext === </span><span class="s1">true</span><span class="s2">) {</span>
    <span class="s2">isExtglob = </span><span class="s1">false;</span>
    <span class="s2">isGlob = </span><span class="s1">false;</span>
  <span class="s2">}</span>

  <span class="s1">let </span><span class="s2">base = str</span><span class="s1">;</span>
  <span class="s1">let </span><span class="s2">prefix = </span><span class="s0">''</span><span class="s1">;</span>
  <span class="s1">let </span><span class="s2">glob = </span><span class="s0">''</span><span class="s1">;</span>

  <span class="s1">if </span><span class="s2">(start &gt; </span><span class="s5">0</span><span class="s2">) {</span>
    <span class="s2">prefix = str.slice(</span><span class="s5">0</span><span class="s1">, </span><span class="s2">start)</span><span class="s1">;</span>
    <span class="s2">str = str.slice(start)</span><span class="s1">;</span>
    <span class="s2">lastIndex -= start</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s1">if </span><span class="s2">(base &amp;&amp; isGlob === </span><span class="s1">true </span><span class="s2">&amp;&amp; lastIndex &gt; </span><span class="s5">0</span><span class="s2">) {</span>
    <span class="s2">base = str.slice(</span><span class="s5">0</span><span class="s1">, </span><span class="s2">lastIndex)</span><span class="s1">;</span>
    <span class="s2">glob = str.slice(lastIndex)</span><span class="s1">;</span>
  <span class="s2">} </span><span class="s1">else if </span><span class="s2">(isGlob === </span><span class="s1">true</span><span class="s2">) {</span>
    <span class="s2">base = </span><span class="s0">''</span><span class="s1">;</span>
    <span class="s2">glob = str</span><span class="s1">;</span>
  <span class="s2">} </span><span class="s1">else </span><span class="s2">{</span>
    <span class="s2">base = str</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s1">if </span><span class="s2">(base &amp;&amp; base !== </span><span class="s0">'' </span><span class="s2">&amp;&amp; base !== </span><span class="s0">'/' </span><span class="s2">&amp;&amp; base !== str) {</span>
    <span class="s1">if </span><span class="s2">(isPathSeparator(base.charCodeAt(base.length - </span><span class="s5">1</span><span class="s2">))) {</span>
      <span class="s2">base = base.slice(</span><span class="s5">0</span><span class="s1">, </span><span class="s2">-</span><span class="s5">1</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
  <span class="s2">}</span>

  <span class="s1">if </span><span class="s2">(opts.unescape === </span><span class="s1">true</span><span class="s2">) {</span>
    <span class="s1">if </span><span class="s2">(glob) glob = utils$2.removeBackslashes(glob)</span><span class="s1">;</span>

    <span class="s1">if </span><span class="s2">(base &amp;&amp; backslashes === </span><span class="s1">true</span><span class="s2">) {</span>
      <span class="s2">base = utils$2.removeBackslashes(base)</span><span class="s1">;</span>
    <span class="s2">}</span>
  <span class="s2">}</span>

  <span class="s1">const </span><span class="s2">state = {</span>
    <span class="s2">prefix</span><span class="s1">,</span>
    <span class="s2">input</span><span class="s1">,</span>
    <span class="s2">start</span><span class="s1">,</span>
    <span class="s2">base</span><span class="s1">,</span>
    <span class="s2">glob</span><span class="s1">,</span>
    <span class="s2">isBrace</span><span class="s1">,</span>
    <span class="s2">isBracket</span><span class="s1">,</span>
    <span class="s2">isGlob</span><span class="s1">,</span>
    <span class="s2">isExtglob</span><span class="s1">,</span>
    <span class="s2">isGlobstar</span><span class="s1">,</span>
    <span class="s2">negated</span><span class="s1">,</span>
    <span class="s2">negatedExtglob</span>
  <span class="s2">}</span><span class="s1">;</span>

  <span class="s1">if </span><span class="s2">(opts.tokens === </span><span class="s1">true</span><span class="s2">) {</span>
    <span class="s2">state.maxDepth = </span><span class="s5">0</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(!isPathSeparator(code)) {</span>
      <span class="s2">tokens.push(token)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s2">state.tokens = tokens</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s1">if </span><span class="s2">(opts.parts === </span><span class="s1">true </span><span class="s2">|| opts.tokens === </span><span class="s1">true</span><span class="s2">) {</span>
    <span class="s1">let </span><span class="s2">prevIndex</span><span class="s1">;</span>

    <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">idx = </span><span class="s5">0</span><span class="s1">; </span><span class="s2">idx &lt; slashes.length</span><span class="s1">; </span><span class="s2">idx++) {</span>
      <span class="s1">const </span><span class="s2">n = prevIndex ? prevIndex + </span><span class="s5">1 </span><span class="s2">: start</span><span class="s1">;</span>
      <span class="s1">const </span><span class="s2">i = slashes[idx]</span><span class="s1">;</span>
      <span class="s1">const </span><span class="s2">value = input.slice(n</span><span class="s1">, </span><span class="s2">i)</span><span class="s1">;</span>
      <span class="s1">if </span><span class="s2">(opts.tokens) {</span>
        <span class="s1">if </span><span class="s2">(idx === </span><span class="s5">0 </span><span class="s2">&amp;&amp; start !== </span><span class="s5">0</span><span class="s2">) {</span>
          <span class="s2">tokens[idx].isPrefix = </span><span class="s1">true;</span>
          <span class="s2">tokens[idx].value = prefix</span><span class="s1">;</span>
        <span class="s2">} </span><span class="s1">else </span><span class="s2">{</span>
          <span class="s2">tokens[idx].value = value</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s2">depth(tokens[idx])</span><span class="s1">;</span>
        <span class="s2">state.maxDepth += tokens[idx].depth</span><span class="s1">;</span>
      <span class="s2">}</span>
      <span class="s1">if </span><span class="s2">(idx !== </span><span class="s5">0 </span><span class="s2">|| value !== </span><span class="s0">''</span><span class="s2">) {</span>
        <span class="s2">parts.push(value)</span><span class="s1">;</span>
      <span class="s2">}</span>
      <span class="s2">prevIndex = i</span><span class="s1">;</span>
    <span class="s2">}</span>

    <span class="s1">if </span><span class="s2">(prevIndex &amp;&amp; prevIndex + </span><span class="s5">1 </span><span class="s2">&lt; input.length) {</span>
      <span class="s1">const </span><span class="s2">value = input.slice(prevIndex + </span><span class="s5">1</span><span class="s2">)</span><span class="s1">;</span>
      <span class="s2">parts.push(value)</span><span class="s1">;</span>

      <span class="s1">if </span><span class="s2">(opts.tokens) {</span>
        <span class="s2">tokens[tokens.length - </span><span class="s5">1</span><span class="s2">].value = value</span><span class="s1">;</span>
        <span class="s2">depth(tokens[tokens.length - </span><span class="s5">1</span><span class="s2">])</span><span class="s1">;</span>
        <span class="s2">state.maxDepth += tokens[tokens.length - </span><span class="s5">1</span><span class="s2">].depth</span><span class="s1">;</span>
      <span class="s2">}</span>
    <span class="s2">}</span>

    <span class="s2">state.slashes = slashes</span><span class="s1">;</span>
    <span class="s2">state.parts = parts</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s1">return </span><span class="s2">state</span><span class="s1">;</span>
<span class="s2">}</span><span class="s1">;</span>

<span class="s1">var </span><span class="s2">scan_1 = scan$1</span><span class="s1">;</span>

<span class="s1">const </span><span class="s2">constants$1 = constants$2</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">utils$1 = utils$3</span><span class="s1">;</span>

<span class="s3">/**</span>
 <span class="s3">* Constants</span>
 <span class="s3">*/</span>

<span class="s1">const </span><span class="s2">{</span>
  <span class="s2">MAX_LENGTH</span><span class="s1">,</span>
  <span class="s2">POSIX_REGEX_SOURCE</span><span class="s1">,</span>
  <span class="s2">REGEX_NON_SPECIAL_CHARS</span><span class="s1">,</span>
  <span class="s2">REGEX_SPECIAL_CHARS_BACKREF</span><span class="s1">,</span>
  <span class="s2">REPLACEMENTS</span>
<span class="s2">} = constants$1</span><span class="s1">;</span>

<span class="s3">/**</span>
 <span class="s3">* Helpers</span>
 <span class="s3">*/</span>

<span class="s1">const </span><span class="s2">expandRange = (args</span><span class="s1">, </span><span class="s2">options) =&gt; {</span>
  <span class="s1">if </span><span class="s2">(</span><span class="s1">typeof </span><span class="s2">options.expandRange === </span><span class="s0">'function'</span><span class="s2">) {</span>
    <span class="s1">return </span><span class="s2">options.expandRange(...args</span><span class="s1">, </span><span class="s2">options)</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s2">args.sort()</span><span class="s1">;</span>
  <span class="s1">const </span><span class="s2">value = </span><span class="s0">`[</span><span class="s2">${args.join(</span><span class="s0">'-'</span><span class="s2">)}</span><span class="s0">]`</span><span class="s1">;</span>

  <span class="s1">return </span><span class="s2">value</span><span class="s1">;</span>
<span class="s2">}</span><span class="s1">;</span>

<span class="s3">/**</span>
 <span class="s3">* Create the message for a syntax error</span>
 <span class="s3">*/</span>

<span class="s1">const </span><span class="s2">syntaxError = (type</span><span class="s1">, </span><span class="s2">char) =&gt; {</span>
  <span class="s1">return </span><span class="s0">`Missing </span><span class="s2">${type}</span><span class="s0">: &quot;</span><span class="s2">${char}</span><span class="s0">&quot; - use &quot;</span><span class="s1">\\\\</span><span class="s2">${char}</span><span class="s0">&quot; to match literal characters`</span><span class="s1">;</span>
<span class="s2">}</span><span class="s1">;</span>

<span class="s3">/**</span>
 <span class="s3">* Parse the given input string.</span>
 <span class="s3">* </span><span class="s6">@param </span><span class="s3">{String} input</span>
 <span class="s3">* </span><span class="s6">@param </span><span class="s3">{Object} options</span>
 <span class="s3">* </span><span class="s6">@return </span><span class="s3">{Object}</span>
 <span class="s3">*/</span>

<span class="s1">const </span><span class="s2">parse$2 = (input</span><span class="s1">, </span><span class="s2">options) =&gt; {</span>
  <span class="s1">if </span><span class="s2">(</span><span class="s1">typeof </span><span class="s2">input !== </span><span class="s0">'string'</span><span class="s2">) {</span>
    <span class="s1">throw new </span><span class="s2">TypeError(</span><span class="s0">'Expected a string'</span><span class="s2">)</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s2">input = REPLACEMENTS[input] || input</span><span class="s1">;</span>

  <span class="s1">const </span><span class="s2">opts = { ...options }</span><span class="s1">;</span>
  <span class="s1">const </span><span class="s2">max = </span><span class="s1">typeof </span><span class="s2">opts.maxLength === </span><span class="s0">'number' </span><span class="s2">? Math.min(MAX_LENGTH</span><span class="s1">, </span><span class="s2">opts.maxLength) : MAX_LENGTH</span><span class="s1">;</span>

  <span class="s1">let </span><span class="s2">len = input.length</span><span class="s1">;</span>
  <span class="s1">if </span><span class="s2">(len &gt; max) {</span>
    <span class="s1">throw new </span><span class="s2">SyntaxError(</span><span class="s0">`Input length: </span><span class="s2">${len}</span><span class="s0">, exceeds maximum allowed length: </span><span class="s2">${max}</span><span class="s0">`</span><span class="s2">)</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s1">const </span><span class="s2">bos = { type: </span><span class="s0">'bos'</span><span class="s1">, </span><span class="s2">value: </span><span class="s0">''</span><span class="s1">, </span><span class="s2">output: opts.prepend || </span><span class="s0">'' </span><span class="s2">}</span><span class="s1">;</span>
  <span class="s1">const </span><span class="s2">tokens = [bos]</span><span class="s1">;</span>

  <span class="s1">const </span><span class="s2">capture = opts.capture ? </span><span class="s0">'' </span><span class="s2">: </span><span class="s0">'?:'</span><span class="s1">;</span>
  <span class="s1">const </span><span class="s2">win32 = utils$1.isWindows(options)</span><span class="s1">;</span>

  <span class="s4">// create constants based on platform, for windows or posix</span>
  <span class="s1">const </span><span class="s2">PLATFORM_CHARS = constants$1.globChars(win32)</span><span class="s1">;</span>
  <span class="s1">const </span><span class="s2">EXTGLOB_CHARS = constants$1.extglobChars(PLATFORM_CHARS)</span><span class="s1">;</span>

  <span class="s1">const </span><span class="s2">{</span>
    <span class="s2">DOT_LITERAL</span><span class="s1">,</span>
    <span class="s2">PLUS_LITERAL</span><span class="s1">,</span>
    <span class="s2">SLASH_LITERAL</span><span class="s1">,</span>
    <span class="s2">ONE_CHAR</span><span class="s1">,</span>
    <span class="s2">DOTS_SLASH</span><span class="s1">,</span>
    <span class="s2">NO_DOT</span><span class="s1">,</span>
    <span class="s2">NO_DOT_SLASH</span><span class="s1">,</span>
    <span class="s2">NO_DOTS_SLASH</span><span class="s1">,</span>
    <span class="s2">QMARK</span><span class="s1">,</span>
    <span class="s2">QMARK_NO_DOT</span><span class="s1">,</span>
    <span class="s2">STAR</span><span class="s1">,</span>
    <span class="s2">START_ANCHOR</span>
  <span class="s2">} = PLATFORM_CHARS</span><span class="s1">;</span>

  <span class="s1">const </span><span class="s2">globstar = opts =&gt; {</span>
    <span class="s1">return </span><span class="s0">`(</span><span class="s2">${capture}</span><span class="s0">(?:(?!</span><span class="s2">${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}</span><span class="s0">).)*?)`</span><span class="s1">;</span>
  <span class="s2">}</span><span class="s1">;</span>

  <span class="s1">const </span><span class="s2">nodot = opts.dot ? </span><span class="s0">'' </span><span class="s2">: NO_DOT</span><span class="s1">;</span>
  <span class="s1">const </span><span class="s2">qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT</span><span class="s1">;</span>
  <span class="s1">let </span><span class="s2">star = opts.bash === </span><span class="s1">true </span><span class="s2">? globstar(opts) : STAR</span><span class="s1">;</span>

  <span class="s1">if </span><span class="s2">(opts.capture) {</span>
    <span class="s2">star = </span><span class="s0">`(</span><span class="s2">${star}</span><span class="s0">)`</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s4">// minimatch options support</span>
  <span class="s1">if </span><span class="s2">(</span><span class="s1">typeof </span><span class="s2">opts.noext === </span><span class="s0">'boolean'</span><span class="s2">) {</span>
    <span class="s2">opts.noextglob = opts.noext</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s1">const </span><span class="s2">state = {</span>
    <span class="s2">input</span><span class="s1">,</span>
    <span class="s2">index: -</span><span class="s5">1</span><span class="s1">,</span>
    <span class="s2">start: </span><span class="s5">0</span><span class="s1">,</span>
    <span class="s2">dot: opts.dot === </span><span class="s1">true,</span>
    <span class="s2">consumed: </span><span class="s0">''</span><span class="s1">,</span>
    <span class="s2">output: </span><span class="s0">''</span><span class="s1">,</span>
    <span class="s2">prefix: </span><span class="s0">''</span><span class="s1">,</span>
    <span class="s2">backtrack: </span><span class="s1">false,</span>
    <span class="s2">negated: </span><span class="s1">false,</span>
    <span class="s2">brackets: </span><span class="s5">0</span><span class="s1">,</span>
    <span class="s2">braces: </span><span class="s5">0</span><span class="s1">,</span>
    <span class="s2">parens: </span><span class="s5">0</span><span class="s1">,</span>
    <span class="s2">quotes: </span><span class="s5">0</span><span class="s1">,</span>
    <span class="s2">globstar: </span><span class="s1">false,</span>
    <span class="s2">tokens</span>
  <span class="s2">}</span><span class="s1">;</span>

  <span class="s2">input = utils$1.removePrefix(input</span><span class="s1">, </span><span class="s2">state)</span><span class="s1">;</span>
  <span class="s2">len = input.length</span><span class="s1">;</span>

  <span class="s1">const </span><span class="s2">extglobs = []</span><span class="s1">;</span>
  <span class="s1">const </span><span class="s2">braces = []</span><span class="s1">;</span>
  <span class="s1">const </span><span class="s2">stack = []</span><span class="s1">;</span>
  <span class="s1">let </span><span class="s2">prev = bos</span><span class="s1">;</span>
  <span class="s1">let </span><span class="s2">value</span><span class="s1">;</span>

  <span class="s3">/**</span>
   <span class="s3">* Tokenizing helpers</span>
   <span class="s3">*/</span>

  <span class="s1">const </span><span class="s2">eos = () =&gt; state.index === len - </span><span class="s5">1</span><span class="s1">;</span>
  <span class="s1">const </span><span class="s2">peek = state.peek = (n = </span><span class="s5">1</span><span class="s2">) =&gt; input[state.index + n]</span><span class="s1">;</span>
  <span class="s1">const </span><span class="s2">advance = state.advance = () =&gt; input[++state.index] || </span><span class="s0">''</span><span class="s1">;</span>
  <span class="s1">const </span><span class="s2">remaining = () =&gt; input.slice(state.index + </span><span class="s5">1</span><span class="s2">)</span><span class="s1">;</span>
  <span class="s1">const </span><span class="s2">consume = (value = </span><span class="s0">''</span><span class="s1">, </span><span class="s2">num = </span><span class="s5">0</span><span class="s2">) =&gt; {</span>
    <span class="s2">state.consumed += value</span><span class="s1">;</span>
    <span class="s2">state.index += num</span><span class="s1">;</span>
  <span class="s2">}</span><span class="s1">;</span>

  <span class="s1">const </span><span class="s2">append = token =&gt; {</span>
    <span class="s2">state.output += token.output != </span><span class="s1">null </span><span class="s2">? token.output : token.value</span><span class="s1">;</span>
    <span class="s2">consume(token.value)</span><span class="s1">;</span>
  <span class="s2">}</span><span class="s1">;</span>

  <span class="s1">const </span><span class="s2">negate = () =&gt; {</span>
    <span class="s1">let </span><span class="s2">count = </span><span class="s5">1</span><span class="s1">;</span>

    <span class="s1">while </span><span class="s2">(peek() === </span><span class="s0">'!' </span><span class="s2">&amp;&amp; (peek(</span><span class="s5">2</span><span class="s2">) !== </span><span class="s0">'(' </span><span class="s2">|| peek(</span><span class="s5">3</span><span class="s2">) === </span><span class="s0">'?'</span><span class="s2">)) {</span>
      <span class="s2">advance()</span><span class="s1">;</span>
      <span class="s2">state.start++</span><span class="s1">;</span>
      <span class="s2">count++</span><span class="s1">;</span>
    <span class="s2">}</span>

    <span class="s1">if </span><span class="s2">(count % </span><span class="s5">2 </span><span class="s2">=== </span><span class="s5">0</span><span class="s2">) {</span>
      <span class="s1">return false;</span>
    <span class="s2">}</span>

    <span class="s2">state.negated = </span><span class="s1">true;</span>
    <span class="s2">state.start++</span><span class="s1">;</span>
    <span class="s1">return true;</span>
  <span class="s2">}</span><span class="s1">;</span>

  <span class="s1">const </span><span class="s2">increment = type =&gt; {</span>
    <span class="s2">state[type]++</span><span class="s1">;</span>
    <span class="s2">stack.push(type)</span><span class="s1">;</span>
  <span class="s2">}</span><span class="s1">;</span>

  <span class="s1">const </span><span class="s2">decrement = type =&gt; {</span>
    <span class="s2">state[type]--</span><span class="s1">;</span>
    <span class="s2">stack.pop()</span><span class="s1">;</span>
  <span class="s2">}</span><span class="s1">;</span>

  <span class="s3">/**</span>
   <span class="s3">* Push tokens onto the tokens array. This helper speeds up</span>
   <span class="s3">* tokenizing by 1) helping us avoid backtracking as much as possible,</span>
   <span class="s3">* and 2) helping us avoid creating extra tokens when consecutive</span>
   <span class="s3">* characters are plain text. This improves performance and simplifies</span>
   <span class="s3">* lookbehinds.</span>
   <span class="s3">*/</span>

  <span class="s1">const </span><span class="s2">push = tok =&gt; {</span>
    <span class="s1">if </span><span class="s2">(prev.type === </span><span class="s0">'globstar'</span><span class="s2">) {</span>
      <span class="s1">const </span><span class="s2">isBrace = state.braces &gt; </span><span class="s5">0 </span><span class="s2">&amp;&amp; (tok.type === </span><span class="s0">'comma' </span><span class="s2">|| tok.type === </span><span class="s0">'brace'</span><span class="s2">)</span><span class="s1">;</span>
      <span class="s1">const </span><span class="s2">isExtglob = tok.extglob === </span><span class="s1">true </span><span class="s2">|| (extglobs.length &amp;&amp; (tok.type === </span><span class="s0">'pipe' </span><span class="s2">|| tok.type === </span><span class="s0">'paren'</span><span class="s2">))</span><span class="s1">;</span>

      <span class="s1">if </span><span class="s2">(tok.type !== </span><span class="s0">'slash' </span><span class="s2">&amp;&amp; tok.type !== </span><span class="s0">'paren' </span><span class="s2">&amp;&amp; !isBrace &amp;&amp; !isExtglob) {</span>
        <span class="s2">state.output = state.output.slice(</span><span class="s5">0</span><span class="s1">, </span><span class="s2">-prev.output.length)</span><span class="s1">;</span>
        <span class="s2">prev.type = </span><span class="s0">'star'</span><span class="s1">;</span>
        <span class="s2">prev.value = </span><span class="s0">'*'</span><span class="s1">;</span>
        <span class="s2">prev.output = star</span><span class="s1">;</span>
        <span class="s2">state.output += prev.output</span><span class="s1">;</span>
      <span class="s2">}</span>
    <span class="s2">}</span>

    <span class="s1">if </span><span class="s2">(extglobs.length &amp;&amp; tok.type !== </span><span class="s0">'paren'</span><span class="s2">) {</span>
      <span class="s2">extglobs[extglobs.length - </span><span class="s5">1</span><span class="s2">].inner += tok.value</span><span class="s1">;</span>
    <span class="s2">}</span>

    <span class="s1">if </span><span class="s2">(tok.value || tok.output) append(tok)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(prev &amp;&amp; prev.type === </span><span class="s0">'text' </span><span class="s2">&amp;&amp; tok.type === </span><span class="s0">'text'</span><span class="s2">) {</span>
      <span class="s2">prev.value += tok.value</span><span class="s1">;</span>
      <span class="s2">prev.output = (prev.output || </span><span class="s0">''</span><span class="s2">) + tok.value</span><span class="s1">;</span>
      <span class="s1">return;</span>
    <span class="s2">}</span>

    <span class="s2">tok.prev = prev</span><span class="s1">;</span>
    <span class="s2">tokens.push(tok)</span><span class="s1">;</span>
    <span class="s2">prev = tok</span><span class="s1">;</span>
  <span class="s2">}</span><span class="s1">;</span>

  <span class="s1">const </span><span class="s2">extglobOpen = (type</span><span class="s1">, </span><span class="s2">value) =&gt; {</span>
    <span class="s1">const </span><span class="s2">token = { ...EXTGLOB_CHARS[value]</span><span class="s1">, </span><span class="s2">conditions: </span><span class="s5">1</span><span class="s1">, </span><span class="s2">inner: </span><span class="s0">'' </span><span class="s2">}</span><span class="s1">;</span>

    <span class="s2">token.prev = prev</span><span class="s1">;</span>
    <span class="s2">token.parens = state.parens</span><span class="s1">;</span>
    <span class="s2">token.output = state.output</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">output = (opts.capture ? </span><span class="s0">'(' </span><span class="s2">: </span><span class="s0">''</span><span class="s2">) + token.open</span><span class="s1">;</span>

    <span class="s2">increment(</span><span class="s0">'parens'</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">push({ type</span><span class="s1">, </span><span class="s2">value</span><span class="s1">, </span><span class="s2">output: state.output ? </span><span class="s0">'' </span><span class="s2">: ONE_CHAR })</span><span class="s1">;</span>
    <span class="s2">push({ type: </span><span class="s0">'paren'</span><span class="s1">, </span><span class="s2">extglob: </span><span class="s1">true, </span><span class="s2">value: advance()</span><span class="s1">, </span><span class="s2">output })</span><span class="s1">;</span>
    <span class="s2">extglobs.push(token)</span><span class="s1">;</span>
  <span class="s2">}</span><span class="s1">;</span>

  <span class="s1">const </span><span class="s2">extglobClose = token =&gt; {</span>
    <span class="s1">let </span><span class="s2">output = token.close + (opts.capture ? </span><span class="s0">')' </span><span class="s2">: </span><span class="s0">''</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">rest</span><span class="s1">;</span>

    <span class="s1">if </span><span class="s2">(token.type === </span><span class="s0">'negate'</span><span class="s2">) {</span>
      <span class="s1">let </span><span class="s2">extglobStar = star</span><span class="s1">;</span>

      <span class="s1">if </span><span class="s2">(token.inner &amp;&amp; token.inner.length &gt; </span><span class="s5">1 </span><span class="s2">&amp;&amp; token.inner.includes(</span><span class="s0">'/'</span><span class="s2">)) {</span>
        <span class="s2">extglobStar = globstar(opts)</span><span class="s1">;</span>
      <span class="s2">}</span>

      <span class="s1">if </span><span class="s2">(extglobStar !== star || eos() || </span><span class="s5">/^\)+$/</span><span class="s2">.test(remaining())) {</span>
        <span class="s2">output = token.close = </span><span class="s0">`)$))</span><span class="s2">${extglobStar}</span><span class="s0">`</span><span class="s1">;</span>
      <span class="s2">}</span>

      <span class="s1">if </span><span class="s2">(token.inner.includes(</span><span class="s0">'*'</span><span class="s2">) &amp;&amp; (rest = remaining()) &amp;&amp; </span><span class="s5">/^\.[^\\/.]+$/</span><span class="s2">.test(rest)) {</span>
        <span class="s4">// Any non-magical string (`.ts`) or even nested expression (`.{ts,tsx}`) can follow after the closing parenthesis.</span>
        <span class="s4">// In this case, we need to parse the string and use it in the output of the original pattern.</span>
        <span class="s4">// Suitable patterns: `/!(*.d).ts`, `/!(*.d).{ts,tsx}`, `**/!(*-dbg).@(js)`.</span>
        <span class="s4">//</span>
        <span class="s4">// Disabling the `fastpaths` option due to a problem with parsing strings as `.ts` in the pattern like `**/!(*.d).ts`.</span>
        <span class="s1">const </span><span class="s2">expression = parse$2(rest</span><span class="s1">, </span><span class="s2">{ ...options</span><span class="s1">, </span><span class="s2">fastpaths: </span><span class="s1">false </span><span class="s2">}).output</span><span class="s1">;</span>

        <span class="s2">output = token.close = </span><span class="s0">`)</span><span class="s2">${expression}</span><span class="s0">)</span><span class="s2">${extglobStar}</span><span class="s0">)`</span><span class="s1">;</span>
      <span class="s2">}</span>

      <span class="s1">if </span><span class="s2">(token.prev.type === </span><span class="s0">'bos'</span><span class="s2">) {</span>
        <span class="s2">state.negatedExtglob = </span><span class="s1">true;</span>
      <span class="s2">}</span>
    <span class="s2">}</span>

    <span class="s2">push({ type: </span><span class="s0">'paren'</span><span class="s1">, </span><span class="s2">extglob: </span><span class="s1">true, </span><span class="s2">value</span><span class="s1">, </span><span class="s2">output })</span><span class="s1">;</span>
    <span class="s2">decrement(</span><span class="s0">'parens'</span><span class="s2">)</span><span class="s1">;</span>
  <span class="s2">}</span><span class="s1">;</span>

  <span class="s3">/**</span>
   <span class="s3">* Fast paths</span>
   <span class="s3">*/</span>

  <span class="s1">if </span><span class="s2">(opts.fastpaths !== </span><span class="s1">false </span><span class="s2">&amp;&amp; !</span><span class="s5">/(^[*!]|[/()[\]{}&quot;])/</span><span class="s2">.test(input)) {</span>
    <span class="s1">let </span><span class="s2">backslashes = </span><span class="s1">false;</span>

    <span class="s1">let </span><span class="s2">output = input.replace(REGEX_SPECIAL_CHARS_BACKREF</span><span class="s1">, </span><span class="s2">(m</span><span class="s1">, </span><span class="s2">esc</span><span class="s1">, </span><span class="s2">chars</span><span class="s1">, </span><span class="s2">first</span><span class="s1">, </span><span class="s2">rest</span><span class="s1">, </span><span class="s2">index) =&gt; {</span>
      <span class="s1">if </span><span class="s2">(first === </span><span class="s0">'</span><span class="s1">\\</span><span class="s0">'</span><span class="s2">) {</span>
        <span class="s2">backslashes = </span><span class="s1">true;</span>
        <span class="s1">return </span><span class="s2">m</span><span class="s1">;</span>
      <span class="s2">}</span>

      <span class="s1">if </span><span class="s2">(first === </span><span class="s0">'?'</span><span class="s2">) {</span>
        <span class="s1">if </span><span class="s2">(esc) {</span>
          <span class="s1">return </span><span class="s2">esc + first + (rest ? QMARK.repeat(rest.length) : </span><span class="s0">''</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(index === </span><span class="s5">0</span><span class="s2">) {</span>
          <span class="s1">return </span><span class="s2">qmarkNoDot + (rest ? QMARK.repeat(rest.length) : </span><span class="s0">''</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">return </span><span class="s2">QMARK.repeat(chars.length)</span><span class="s1">;</span>
      <span class="s2">}</span>

      <span class="s1">if </span><span class="s2">(first === </span><span class="s0">'.'</span><span class="s2">) {</span>
        <span class="s1">return </span><span class="s2">DOT_LITERAL.repeat(chars.length)</span><span class="s1">;</span>
      <span class="s2">}</span>

      <span class="s1">if </span><span class="s2">(first === </span><span class="s0">'*'</span><span class="s2">) {</span>
        <span class="s1">if </span><span class="s2">(esc) {</span>
          <span class="s1">return </span><span class="s2">esc + first + (rest ? star : </span><span class="s0">''</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s1">return </span><span class="s2">star</span><span class="s1">;</span>
      <span class="s2">}</span>
      <span class="s1">return </span><span class="s2">esc ? m : </span><span class="s0">`</span><span class="s1">\\</span><span class="s2">${m}</span><span class="s0">`</span><span class="s1">;</span>
    <span class="s2">})</span><span class="s1">;</span>

    <span class="s1">if </span><span class="s2">(backslashes === </span><span class="s1">true</span><span class="s2">) {</span>
      <span class="s1">if </span><span class="s2">(opts.unescape === </span><span class="s1">true</span><span class="s2">) {</span>
        <span class="s2">output = output.replace(</span><span class="s5">/\\/g</span><span class="s1">, </span><span class="s0">''</span><span class="s2">)</span><span class="s1">;</span>
      <span class="s2">} </span><span class="s1">else </span><span class="s2">{</span>
        <span class="s2">output = output.replace(</span><span class="s5">/\\+/g</span><span class="s1">, </span><span class="s2">m =&gt; {</span>
          <span class="s1">return </span><span class="s2">m.length % </span><span class="s5">2 </span><span class="s2">=== </span><span class="s5">0 </span><span class="s2">? </span><span class="s0">'</span><span class="s1">\\\\</span><span class="s0">' </span><span class="s2">: (m ? </span><span class="s0">'</span><span class="s1">\\</span><span class="s0">' </span><span class="s2">: </span><span class="s0">''</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">})</span><span class="s1">;</span>
      <span class="s2">}</span>
    <span class="s2">}</span>

    <span class="s1">if </span><span class="s2">(output === input &amp;&amp; opts.contains === </span><span class="s1">true</span><span class="s2">) {</span>
      <span class="s2">state.output = input</span><span class="s1">;</span>
      <span class="s1">return </span><span class="s2">state</span><span class="s1">;</span>
    <span class="s2">}</span>

    <span class="s2">state.output = utils$1.wrapOutput(output</span><span class="s1">, </span><span class="s2">state</span><span class="s1">, </span><span class="s2">options)</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">state</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Tokenize input until we reach end-of-string</span>
   <span class="s3">*/</span>

  <span class="s1">while </span><span class="s2">(!eos()) {</span>
    <span class="s2">value = advance()</span><span class="s1">;</span>

    <span class="s1">if </span><span class="s2">(value === </span><span class="s0">'</span><span class="s1">\u0000</span><span class="s0">'</span><span class="s2">) {</span>
      <span class="s1">continue;</span>
    <span class="s2">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Escaped characters</span>
     <span class="s3">*/</span>

    <span class="s1">if </span><span class="s2">(value === </span><span class="s0">'</span><span class="s1">\\</span><span class="s0">'</span><span class="s2">) {</span>
      <span class="s1">const </span><span class="s2">next = peek()</span><span class="s1">;</span>

      <span class="s1">if </span><span class="s2">(next === </span><span class="s0">'/' </span><span class="s2">&amp;&amp; opts.bash !== </span><span class="s1">true</span><span class="s2">) {</span>
        <span class="s1">continue;</span>
      <span class="s2">}</span>

      <span class="s1">if </span><span class="s2">(next === </span><span class="s0">'.' </span><span class="s2">|| next === </span><span class="s0">';'</span><span class="s2">) {</span>
        <span class="s1">continue;</span>
      <span class="s2">}</span>

      <span class="s1">if </span><span class="s2">(!next) {</span>
        <span class="s2">value += </span><span class="s0">'</span><span class="s1">\\</span><span class="s0">'</span><span class="s1">;</span>
        <span class="s2">push({ type: </span><span class="s0">'text'</span><span class="s1">, </span><span class="s2">value })</span><span class="s1">;</span>
        <span class="s1">continue;</span>
      <span class="s2">}</span>

      <span class="s4">// collapse slashes to reduce potential for exploits</span>
      <span class="s1">const </span><span class="s2">match = </span><span class="s5">/^\\+/</span><span class="s2">.exec(remaining())</span><span class="s1">;</span>
      <span class="s1">let </span><span class="s2">slashes = </span><span class="s5">0</span><span class="s1">;</span>

      <span class="s1">if </span><span class="s2">(match &amp;&amp; match[</span><span class="s5">0</span><span class="s2">].length &gt; </span><span class="s5">2</span><span class="s2">) {</span>
        <span class="s2">slashes = match[</span><span class="s5">0</span><span class="s2">].length</span><span class="s1">;</span>
        <span class="s2">state.index += slashes</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(slashes % </span><span class="s5">2 </span><span class="s2">!== </span><span class="s5">0</span><span class="s2">) {</span>
          <span class="s2">value += </span><span class="s0">'</span><span class="s1">\\</span><span class="s0">'</span><span class="s1">;</span>
        <span class="s2">}</span>
      <span class="s2">}</span>

      <span class="s1">if </span><span class="s2">(opts.unescape === </span><span class="s1">true</span><span class="s2">) {</span>
        <span class="s2">value = advance()</span><span class="s1">;</span>
      <span class="s2">} </span><span class="s1">else </span><span class="s2">{</span>
        <span class="s2">value += advance()</span><span class="s1">;</span>
      <span class="s2">}</span>

      <span class="s1">if </span><span class="s2">(state.brackets === </span><span class="s5">0</span><span class="s2">) {</span>
        <span class="s2">push({ type: </span><span class="s0">'text'</span><span class="s1">, </span><span class="s2">value })</span><span class="s1">;</span>
        <span class="s1">continue;</span>
      <span class="s2">}</span>
    <span class="s2">}</span>

    <span class="s3">/**</span>
     <span class="s3">* If we're inside a regex character class, continue</span>
     <span class="s3">* until we reach the closing bracket.</span>
     <span class="s3">*/</span>

    <span class="s1">if </span><span class="s2">(state.brackets &gt; </span><span class="s5">0 </span><span class="s2">&amp;&amp; (value !== </span><span class="s0">']' </span><span class="s2">|| prev.value === </span><span class="s0">'[' </span><span class="s2">|| prev.value === </span><span class="s0">'[^'</span><span class="s2">)) {</span>
      <span class="s1">if </span><span class="s2">(opts.posix !== </span><span class="s1">false </span><span class="s2">&amp;&amp; value === </span><span class="s0">':'</span><span class="s2">) {</span>
        <span class="s1">const </span><span class="s2">inner = prev.value.slice(</span><span class="s5">1</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(inner.includes(</span><span class="s0">'['</span><span class="s2">)) {</span>
          <span class="s2">prev.posix = </span><span class="s1">true;</span>

          <span class="s1">if </span><span class="s2">(inner.includes(</span><span class="s0">':'</span><span class="s2">)) {</span>
            <span class="s1">const </span><span class="s2">idx = prev.value.lastIndexOf(</span><span class="s0">'['</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">pre = prev.value.slice(</span><span class="s5">0</span><span class="s1">, </span><span class="s2">idx)</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">rest = prev.value.slice(idx + </span><span class="s5">2</span><span class="s2">)</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">posix = POSIX_REGEX_SOURCE[rest]</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(posix) {</span>
              <span class="s2">prev.value = pre + posix</span><span class="s1">;</span>
              <span class="s2">state.backtrack = </span><span class="s1">true;</span>
              <span class="s2">advance()</span><span class="s1">;</span>

              <span class="s1">if </span><span class="s2">(!bos.output &amp;&amp; tokens.indexOf(prev) === </span><span class="s5">1</span><span class="s2">) {</span>
                <span class="s2">bos.output = ONE_CHAR</span><span class="s1">;</span>
              <span class="s2">}</span>
              <span class="s1">continue;</span>
            <span class="s2">}</span>
          <span class="s2">}</span>
        <span class="s2">}</span>
      <span class="s2">}</span>

      <span class="s1">if </span><span class="s2">((value === </span><span class="s0">'[' </span><span class="s2">&amp;&amp; peek() !== </span><span class="s0">':'</span><span class="s2">) || (value === </span><span class="s0">'-' </span><span class="s2">&amp;&amp; peek() === </span><span class="s0">']'</span><span class="s2">)) {</span>
        <span class="s2">value = </span><span class="s0">`</span><span class="s1">\\</span><span class="s2">${value}</span><span class="s0">`</span><span class="s1">;</span>
      <span class="s2">}</span>

      <span class="s1">if </span><span class="s2">(value === </span><span class="s0">']' </span><span class="s2">&amp;&amp; (prev.value === </span><span class="s0">'[' </span><span class="s2">|| prev.value === </span><span class="s0">'[^'</span><span class="s2">)) {</span>
        <span class="s2">value = </span><span class="s0">`</span><span class="s1">\\</span><span class="s2">${value}</span><span class="s0">`</span><span class="s1">;</span>
      <span class="s2">}</span>

      <span class="s1">if </span><span class="s2">(opts.posix === </span><span class="s1">true </span><span class="s2">&amp;&amp; value === </span><span class="s0">'!' </span><span class="s2">&amp;&amp; prev.value === </span><span class="s0">'['</span><span class="s2">) {</span>
        <span class="s2">value = </span><span class="s0">'^'</span><span class="s1">;</span>
      <span class="s2">}</span>

      <span class="s2">prev.value += value</span><span class="s1">;</span>
      <span class="s2">append({ value })</span><span class="s1">;</span>
      <span class="s1">continue;</span>
    <span class="s2">}</span>

    <span class="s3">/**</span>
     <span class="s3">* If we're inside a quoted string, continue</span>
     <span class="s3">* until we reach the closing double quote.</span>
     <span class="s3">*/</span>

    <span class="s1">if </span><span class="s2">(state.quotes === </span><span class="s5">1 </span><span class="s2">&amp;&amp; value !== </span><span class="s0">'&quot;'</span><span class="s2">) {</span>
      <span class="s2">value = utils$1.escapeRegex(value)</span><span class="s1">;</span>
      <span class="s2">prev.value += value</span><span class="s1">;</span>
      <span class="s2">append({ value })</span><span class="s1">;</span>
      <span class="s1">continue;</span>
    <span class="s2">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Double quotes</span>
     <span class="s3">*/</span>

    <span class="s1">if </span><span class="s2">(value === </span><span class="s0">'&quot;'</span><span class="s2">) {</span>
      <span class="s2">state.quotes = state.quotes === </span><span class="s5">1 </span><span class="s2">? </span><span class="s5">0 </span><span class="s2">: </span><span class="s5">1</span><span class="s1">;</span>
      <span class="s1">if </span><span class="s2">(opts.keepQuotes === </span><span class="s1">true</span><span class="s2">) {</span>
        <span class="s2">push({ type: </span><span class="s0">'text'</span><span class="s1">, </span><span class="s2">value })</span><span class="s1">;</span>
      <span class="s2">}</span>
      <span class="s1">continue;</span>
    <span class="s2">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Parentheses</span>
     <span class="s3">*/</span>

    <span class="s1">if </span><span class="s2">(value === </span><span class="s0">'('</span><span class="s2">) {</span>
      <span class="s2">increment(</span><span class="s0">'parens'</span><span class="s2">)</span><span class="s1">;</span>
      <span class="s2">push({ type: </span><span class="s0">'paren'</span><span class="s1">, </span><span class="s2">value })</span><span class="s1">;</span>
      <span class="s1">continue;</span>
    <span class="s2">}</span>

    <span class="s1">if </span><span class="s2">(value === </span><span class="s0">')'</span><span class="s2">) {</span>
      <span class="s1">if </span><span class="s2">(state.parens === </span><span class="s5">0 </span><span class="s2">&amp;&amp; opts.strictBrackets === </span><span class="s1">true</span><span class="s2">) {</span>
        <span class="s1">throw new </span><span class="s2">SyntaxError(syntaxError(</span><span class="s0">'opening'</span><span class="s1">, </span><span class="s0">'('</span><span class="s2">))</span><span class="s1">;</span>
      <span class="s2">}</span>

      <span class="s1">const </span><span class="s2">extglob = extglobs[extglobs.length - </span><span class="s5">1</span><span class="s2">]</span><span class="s1">;</span>
      <span class="s1">if </span><span class="s2">(extglob &amp;&amp; state.parens === extglob.parens + </span><span class="s5">1</span><span class="s2">) {</span>
        <span class="s2">extglobClose(extglobs.pop())</span><span class="s1">;</span>
        <span class="s1">continue;</span>
      <span class="s2">}</span>

      <span class="s2">push({ type: </span><span class="s0">'paren'</span><span class="s1">, </span><span class="s2">value</span><span class="s1">, </span><span class="s2">output: state.parens ? </span><span class="s0">')' </span><span class="s2">: </span><span class="s0">'</span><span class="s1">\\</span><span class="s0">)' </span><span class="s2">})</span><span class="s1">;</span>
      <span class="s2">decrement(</span><span class="s0">'parens'</span><span class="s2">)</span><span class="s1">;</span>
      <span class="s1">continue;</span>
    <span class="s2">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Square brackets</span>
     <span class="s3">*/</span>

    <span class="s1">if </span><span class="s2">(value === </span><span class="s0">'['</span><span class="s2">) {</span>
      <span class="s1">if </span><span class="s2">(opts.nobracket === </span><span class="s1">true </span><span class="s2">|| !remaining().includes(</span><span class="s0">']'</span><span class="s2">)) {</span>
        <span class="s1">if </span><span class="s2">(opts.nobracket !== </span><span class="s1">true </span><span class="s2">&amp;&amp; opts.strictBrackets === </span><span class="s1">true</span><span class="s2">) {</span>
          <span class="s1">throw new </span><span class="s2">SyntaxError(syntaxError(</span><span class="s0">'closing'</span><span class="s1">, </span><span class="s0">']'</span><span class="s2">))</span><span class="s1">;</span>
        <span class="s2">}</span>

        <span class="s2">value = </span><span class="s0">`</span><span class="s1">\\</span><span class="s2">${value}</span><span class="s0">`</span><span class="s1">;</span>
      <span class="s2">} </span><span class="s1">else </span><span class="s2">{</span>
        <span class="s2">increment(</span><span class="s0">'brackets'</span><span class="s2">)</span><span class="s1">;</span>
      <span class="s2">}</span>

      <span class="s2">push({ type: </span><span class="s0">'bracket'</span><span class="s1">, </span><span class="s2">value })</span><span class="s1">;</span>
      <span class="s1">continue;</span>
    <span class="s2">}</span>

    <span class="s1">if </span><span class="s2">(value === </span><span class="s0">']'</span><span class="s2">) {</span>
      <span class="s1">if </span><span class="s2">(opts.nobracket === </span><span class="s1">true </span><span class="s2">|| (prev &amp;&amp; prev.type === </span><span class="s0">'bracket' </span><span class="s2">&amp;&amp; prev.value.length === </span><span class="s5">1</span><span class="s2">)) {</span>
        <span class="s2">push({ type: </span><span class="s0">'text'</span><span class="s1">, </span><span class="s2">value</span><span class="s1">, </span><span class="s2">output: </span><span class="s0">`</span><span class="s1">\\</span><span class="s2">${value}</span><span class="s0">` </span><span class="s2">})</span><span class="s1">;</span>
        <span class="s1">continue;</span>
      <span class="s2">}</span>

      <span class="s1">if </span><span class="s2">(state.brackets === </span><span class="s5">0</span><span class="s2">) {</span>
        <span class="s1">if </span><span class="s2">(opts.strictBrackets === </span><span class="s1">true</span><span class="s2">) {</span>
          <span class="s1">throw new </span><span class="s2">SyntaxError(syntaxError(</span><span class="s0">'opening'</span><span class="s1">, </span><span class="s0">'['</span><span class="s2">))</span><span class="s1">;</span>
        <span class="s2">}</span>

        <span class="s2">push({ type: </span><span class="s0">'text'</span><span class="s1">, </span><span class="s2">value</span><span class="s1">, </span><span class="s2">output: </span><span class="s0">`</span><span class="s1">\\</span><span class="s2">${value}</span><span class="s0">` </span><span class="s2">})</span><span class="s1">;</span>
        <span class="s1">continue;</span>
      <span class="s2">}</span>

      <span class="s2">decrement(</span><span class="s0">'brackets'</span><span class="s2">)</span><span class="s1">;</span>

      <span class="s1">const </span><span class="s2">prevValue = prev.value.slice(</span><span class="s5">1</span><span class="s2">)</span><span class="s1">;</span>
      <span class="s1">if </span><span class="s2">(prev.posix !== </span><span class="s1">true </span><span class="s2">&amp;&amp; prevValue[</span><span class="s5">0</span><span class="s2">] === </span><span class="s0">'^' </span><span class="s2">&amp;&amp; !prevValue.includes(</span><span class="s0">'/'</span><span class="s2">)) {</span>
        <span class="s2">value = </span><span class="s0">`/</span><span class="s2">${value}</span><span class="s0">`</span><span class="s1">;</span>
      <span class="s2">}</span>

      <span class="s2">prev.value += value</span><span class="s1">;</span>
      <span class="s2">append({ value })</span><span class="s1">;</span>

      <span class="s4">// when literal brackets are explicitly disabled</span>
      <span class="s4">// assume we should match with a regex character class</span>
      <span class="s1">if </span><span class="s2">(opts.literalBrackets === </span><span class="s1">false </span><span class="s2">|| utils$1.hasRegexChars(prevValue)) {</span>
        <span class="s1">continue;</span>
      <span class="s2">}</span>

      <span class="s1">const </span><span class="s2">escaped = utils$1.escapeRegex(prev.value)</span><span class="s1">;</span>
      <span class="s2">state.output = state.output.slice(</span><span class="s5">0</span><span class="s1">, </span><span class="s2">-prev.value.length)</span><span class="s1">;</span>

      <span class="s4">// when literal brackets are explicitly enabled</span>
      <span class="s4">// assume we should escape the brackets to match literal characters</span>
      <span class="s1">if </span><span class="s2">(opts.literalBrackets === </span><span class="s1">true</span><span class="s2">) {</span>
        <span class="s2">state.output += escaped</span><span class="s1">;</span>
        <span class="s2">prev.value = escaped</span><span class="s1">;</span>
        <span class="s1">continue;</span>
      <span class="s2">}</span>

      <span class="s4">// when the user specifies nothing, try to match both</span>
      <span class="s2">prev.value = </span><span class="s0">`(</span><span class="s2">${capture}${escaped}</span><span class="s0">|</span><span class="s2">${prev.value}</span><span class="s0">)`</span><span class="s1">;</span>
      <span class="s2">state.output += prev.value</span><span class="s1">;</span>
      <span class="s1">continue;</span>
    <span class="s2">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Braces</span>
     <span class="s3">*/</span>

    <span class="s1">if </span><span class="s2">(value === </span><span class="s0">'{' </span><span class="s2">&amp;&amp; opts.nobrace !== </span><span class="s1">true</span><span class="s2">) {</span>
      <span class="s2">increment(</span><span class="s0">'braces'</span><span class="s2">)</span><span class="s1">;</span>

      <span class="s1">const </span><span class="s2">open = {</span>
        <span class="s2">type: </span><span class="s0">'brace'</span><span class="s1">,</span>
        <span class="s2">value</span><span class="s1">,</span>
        <span class="s2">output: </span><span class="s0">'('</span><span class="s1">,</span>
        <span class="s2">outputIndex: state.output.length</span><span class="s1">,</span>
        <span class="s2">tokensIndex: state.tokens.length</span>
      <span class="s2">}</span><span class="s1">;</span>

      <span class="s2">braces.push(open)</span><span class="s1">;</span>
      <span class="s2">push(open)</span><span class="s1">;</span>
      <span class="s1">continue;</span>
    <span class="s2">}</span>

    <span class="s1">if </span><span class="s2">(value === </span><span class="s0">'}'</span><span class="s2">) {</span>
      <span class="s1">const </span><span class="s2">brace = braces[braces.length - </span><span class="s5">1</span><span class="s2">]</span><span class="s1">;</span>

      <span class="s1">if </span><span class="s2">(opts.nobrace === </span><span class="s1">true </span><span class="s2">|| !brace) {</span>
        <span class="s2">push({ type: </span><span class="s0">'text'</span><span class="s1">, </span><span class="s2">value</span><span class="s1">, </span><span class="s2">output: value })</span><span class="s1">;</span>
        <span class="s1">continue;</span>
      <span class="s2">}</span>

      <span class="s1">let </span><span class="s2">output = </span><span class="s0">')'</span><span class="s1">;</span>

      <span class="s1">if </span><span class="s2">(brace.dots === </span><span class="s1">true</span><span class="s2">) {</span>
        <span class="s1">const </span><span class="s2">arr = tokens.slice()</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">range = []</span><span class="s1">;</span>

        <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = arr.length - </span><span class="s5">1</span><span class="s1">; </span><span class="s2">i &gt;= </span><span class="s5">0</span><span class="s1">; </span><span class="s2">i--) {</span>
          <span class="s2">tokens.pop()</span><span class="s1">;</span>
          <span class="s1">if </span><span class="s2">(arr[i].type === </span><span class="s0">'brace'</span><span class="s2">) {</span>
            <span class="s1">break;</span>
          <span class="s2">}</span>
          <span class="s1">if </span><span class="s2">(arr[i].type !== </span><span class="s0">'dots'</span><span class="s2">) {</span>
            <span class="s2">range.unshift(arr[i].value)</span><span class="s1">;</span>
          <span class="s2">}</span>
        <span class="s2">}</span>

        <span class="s2">output = expandRange(range</span><span class="s1">, </span><span class="s2">opts)</span><span class="s1">;</span>
        <span class="s2">state.backtrack = </span><span class="s1">true;</span>
      <span class="s2">}</span>

      <span class="s1">if </span><span class="s2">(brace.comma !== </span><span class="s1">true </span><span class="s2">&amp;&amp; brace.dots !== </span><span class="s1">true</span><span class="s2">) {</span>
        <span class="s1">const </span><span class="s2">out = state.output.slice(</span><span class="s5">0</span><span class="s1">, </span><span class="s2">brace.outputIndex)</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">toks = state.tokens.slice(brace.tokensIndex)</span><span class="s1">;</span>
        <span class="s2">brace.value = brace.output = </span><span class="s0">'</span><span class="s1">\\</span><span class="s0">{'</span><span class="s1">;</span>
        <span class="s2">value = output = </span><span class="s0">'</span><span class="s1">\\</span><span class="s0">}'</span><span class="s1">;</span>
        <span class="s2">state.output = out</span><span class="s1">;</span>
        <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">t of toks) {</span>
          <span class="s2">state.output += (t.output || t.value)</span><span class="s1">;</span>
        <span class="s2">}</span>
      <span class="s2">}</span>

      <span class="s2">push({ type: </span><span class="s0">'brace'</span><span class="s1">, </span><span class="s2">value</span><span class="s1">, </span><span class="s2">output })</span><span class="s1">;</span>
      <span class="s2">decrement(</span><span class="s0">'braces'</span><span class="s2">)</span><span class="s1">;</span>
      <span class="s2">braces.pop()</span><span class="s1">;</span>
      <span class="s1">continue;</span>
    <span class="s2">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Pipes</span>
     <span class="s3">*/</span>

    <span class="s1">if </span><span class="s2">(value === </span><span class="s0">'|'</span><span class="s2">) {</span>
      <span class="s1">if </span><span class="s2">(extglobs.length &gt; </span><span class="s5">0</span><span class="s2">) {</span>
        <span class="s2">extglobs[extglobs.length - </span><span class="s5">1</span><span class="s2">].conditions++</span><span class="s1">;</span>
      <span class="s2">}</span>
      <span class="s2">push({ type: </span><span class="s0">'text'</span><span class="s1">, </span><span class="s2">value })</span><span class="s1">;</span>
      <span class="s1">continue;</span>
    <span class="s2">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Commas</span>
     <span class="s3">*/</span>

    <span class="s1">if </span><span class="s2">(value === </span><span class="s0">','</span><span class="s2">) {</span>
      <span class="s1">let </span><span class="s2">output = value</span><span class="s1">;</span>

      <span class="s1">const </span><span class="s2">brace = braces[braces.length - </span><span class="s5">1</span><span class="s2">]</span><span class="s1">;</span>
      <span class="s1">if </span><span class="s2">(brace &amp;&amp; stack[stack.length - </span><span class="s5">1</span><span class="s2">] === </span><span class="s0">'braces'</span><span class="s2">) {</span>
        <span class="s2">brace.comma = </span><span class="s1">true;</span>
        <span class="s2">output = </span><span class="s0">'|'</span><span class="s1">;</span>
      <span class="s2">}</span>

      <span class="s2">push({ type: </span><span class="s0">'comma'</span><span class="s1">, </span><span class="s2">value</span><span class="s1">, </span><span class="s2">output })</span><span class="s1">;</span>
      <span class="s1">continue;</span>
    <span class="s2">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Slashes</span>
     <span class="s3">*/</span>

    <span class="s1">if </span><span class="s2">(value === </span><span class="s0">'/'</span><span class="s2">) {</span>
      <span class="s4">// if the beginning of the glob is &quot;./&quot;, advance the start</span>
      <span class="s4">// to the current index, and don't add the &quot;./&quot; characters</span>
      <span class="s4">// to the state. This greatly simplifies lookbehinds when</span>
      <span class="s4">// checking for BOS characters like &quot;!&quot; and &quot;.&quot; (not &quot;./&quot;)</span>
      <span class="s1">if </span><span class="s2">(prev.type === </span><span class="s0">'dot' </span><span class="s2">&amp;&amp; state.index === state.start + </span><span class="s5">1</span><span class="s2">) {</span>
        <span class="s2">state.start = state.index + </span><span class="s5">1</span><span class="s1">;</span>
        <span class="s2">state.consumed = </span><span class="s0">''</span><span class="s1">;</span>
        <span class="s2">state.output = </span><span class="s0">''</span><span class="s1">;</span>
        <span class="s2">tokens.pop()</span><span class="s1">;</span>
        <span class="s2">prev = bos</span><span class="s1">; </span><span class="s4">// reset &quot;prev&quot; to the first token</span>
        <span class="s1">continue;</span>
      <span class="s2">}</span>

      <span class="s2">push({ type: </span><span class="s0">'slash'</span><span class="s1">, </span><span class="s2">value</span><span class="s1">, </span><span class="s2">output: SLASH_LITERAL })</span><span class="s1">;</span>
      <span class="s1">continue;</span>
    <span class="s2">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Dots</span>
     <span class="s3">*/</span>

    <span class="s1">if </span><span class="s2">(value === </span><span class="s0">'.'</span><span class="s2">) {</span>
      <span class="s1">if </span><span class="s2">(state.braces &gt; </span><span class="s5">0 </span><span class="s2">&amp;&amp; prev.type === </span><span class="s0">'dot'</span><span class="s2">) {</span>
        <span class="s1">if </span><span class="s2">(prev.value === </span><span class="s0">'.'</span><span class="s2">) prev.output = DOT_LITERAL</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">brace = braces[braces.length - </span><span class="s5">1</span><span class="s2">]</span><span class="s1">;</span>
        <span class="s2">prev.type = </span><span class="s0">'dots'</span><span class="s1">;</span>
        <span class="s2">prev.output += value</span><span class="s1">;</span>
        <span class="s2">prev.value += value</span><span class="s1">;</span>
        <span class="s2">brace.dots = </span><span class="s1">true;</span>
        <span class="s1">continue;</span>
      <span class="s2">}</span>

      <span class="s1">if </span><span class="s2">((state.braces + state.parens) === </span><span class="s5">0 </span><span class="s2">&amp;&amp; prev.type !== </span><span class="s0">'bos' </span><span class="s2">&amp;&amp; prev.type !== </span><span class="s0">'slash'</span><span class="s2">) {</span>
        <span class="s2">push({ type: </span><span class="s0">'text'</span><span class="s1">, </span><span class="s2">value</span><span class="s1">, </span><span class="s2">output: DOT_LITERAL })</span><span class="s1">;</span>
        <span class="s1">continue;</span>
      <span class="s2">}</span>

      <span class="s2">push({ type: </span><span class="s0">'dot'</span><span class="s1">, </span><span class="s2">value</span><span class="s1">, </span><span class="s2">output: DOT_LITERAL })</span><span class="s1">;</span>
      <span class="s1">continue;</span>
    <span class="s2">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Question marks</span>
     <span class="s3">*/</span>

    <span class="s1">if </span><span class="s2">(value === </span><span class="s0">'?'</span><span class="s2">) {</span>
      <span class="s1">const </span><span class="s2">isGroup = prev &amp;&amp; prev.value === </span><span class="s0">'('</span><span class="s1">;</span>
      <span class="s1">if </span><span class="s2">(!isGroup &amp;&amp; opts.noextglob !== </span><span class="s1">true </span><span class="s2">&amp;&amp; peek() === </span><span class="s0">'(' </span><span class="s2">&amp;&amp; peek(</span><span class="s5">2</span><span class="s2">) !== </span><span class="s0">'?'</span><span class="s2">) {</span>
        <span class="s2">extglobOpen(</span><span class="s0">'qmark'</span><span class="s1">, </span><span class="s2">value)</span><span class="s1">;</span>
        <span class="s1">continue;</span>
      <span class="s2">}</span>

      <span class="s1">if </span><span class="s2">(prev &amp;&amp; prev.type === </span><span class="s0">'paren'</span><span class="s2">) {</span>
        <span class="s1">const </span><span class="s2">next = peek()</span><span class="s1">;</span>
        <span class="s1">let </span><span class="s2">output = value</span><span class="s1">;</span>

        <span class="s1">if </span><span class="s2">(next === </span><span class="s0">'&lt;' </span><span class="s2">&amp;&amp; !utils$1.supportsLookbehinds()) {</span>
          <span class="s1">throw new </span><span class="s2">Error(</span><span class="s0">'Node.js v10 or higher is required for regex lookbehinds'</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">}</span>

        <span class="s1">if </span><span class="s2">((prev.value === </span><span class="s0">'(' </span><span class="s2">&amp;&amp; !</span><span class="s5">/[!=&lt;:]/</span><span class="s2">.test(next)) || (next === </span><span class="s0">'&lt;' </span><span class="s2">&amp;&amp; !</span><span class="s5">/&lt;([!=]|\w+&gt;)/</span><span class="s2">.test(remaining()))) {</span>
          <span class="s2">output = </span><span class="s0">`</span><span class="s1">\\</span><span class="s2">${value}</span><span class="s0">`</span><span class="s1">;</span>
        <span class="s2">}</span>

        <span class="s2">push({ type: </span><span class="s0">'text'</span><span class="s1">, </span><span class="s2">value</span><span class="s1">, </span><span class="s2">output })</span><span class="s1">;</span>
        <span class="s1">continue;</span>
      <span class="s2">}</span>

      <span class="s1">if </span><span class="s2">(opts.dot !== </span><span class="s1">true </span><span class="s2">&amp;&amp; (prev.type === </span><span class="s0">'slash' </span><span class="s2">|| prev.type === </span><span class="s0">'bos'</span><span class="s2">)) {</span>
        <span class="s2">push({ type: </span><span class="s0">'qmark'</span><span class="s1">, </span><span class="s2">value</span><span class="s1">, </span><span class="s2">output: QMARK_NO_DOT })</span><span class="s1">;</span>
        <span class="s1">continue;</span>
      <span class="s2">}</span>

      <span class="s2">push({ type: </span><span class="s0">'qmark'</span><span class="s1">, </span><span class="s2">value</span><span class="s1">, </span><span class="s2">output: QMARK })</span><span class="s1">;</span>
      <span class="s1">continue;</span>
    <span class="s2">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Exclamation</span>
     <span class="s3">*/</span>

    <span class="s1">if </span><span class="s2">(value === </span><span class="s0">'!'</span><span class="s2">) {</span>
      <span class="s1">if </span><span class="s2">(opts.noextglob !== </span><span class="s1">true </span><span class="s2">&amp;&amp; peek() === </span><span class="s0">'('</span><span class="s2">) {</span>
        <span class="s1">if </span><span class="s2">(peek(</span><span class="s5">2</span><span class="s2">) !== </span><span class="s0">'?' </span><span class="s2">|| !</span><span class="s5">/[!=&lt;:]/</span><span class="s2">.test(peek(</span><span class="s5">3</span><span class="s2">))) {</span>
          <span class="s2">extglobOpen(</span><span class="s0">'negate'</span><span class="s1">, </span><span class="s2">value)</span><span class="s1">;</span>
          <span class="s1">continue;</span>
        <span class="s2">}</span>
      <span class="s2">}</span>

      <span class="s1">if </span><span class="s2">(opts.nonegate !== </span><span class="s1">true </span><span class="s2">&amp;&amp; state.index === </span><span class="s5">0</span><span class="s2">) {</span>
        <span class="s2">negate()</span><span class="s1">;</span>
        <span class="s1">continue;</span>
      <span class="s2">}</span>
    <span class="s2">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Plus</span>
     <span class="s3">*/</span>

    <span class="s1">if </span><span class="s2">(value === </span><span class="s0">'+'</span><span class="s2">) {</span>
      <span class="s1">if </span><span class="s2">(opts.noextglob !== </span><span class="s1">true </span><span class="s2">&amp;&amp; peek() === </span><span class="s0">'(' </span><span class="s2">&amp;&amp; peek(</span><span class="s5">2</span><span class="s2">) !== </span><span class="s0">'?'</span><span class="s2">) {</span>
        <span class="s2">extglobOpen(</span><span class="s0">'plus'</span><span class="s1">, </span><span class="s2">value)</span><span class="s1">;</span>
        <span class="s1">continue;</span>
      <span class="s2">}</span>

      <span class="s1">if </span><span class="s2">((prev &amp;&amp; prev.value === </span><span class="s0">'('</span><span class="s2">) || opts.regex === </span><span class="s1">false</span><span class="s2">) {</span>
        <span class="s2">push({ type: </span><span class="s0">'plus'</span><span class="s1">, </span><span class="s2">value</span><span class="s1">, </span><span class="s2">output: PLUS_LITERAL })</span><span class="s1">;</span>
        <span class="s1">continue;</span>
      <span class="s2">}</span>

      <span class="s1">if </span><span class="s2">((prev &amp;&amp; (prev.type === </span><span class="s0">'bracket' </span><span class="s2">|| prev.type === </span><span class="s0">'paren' </span><span class="s2">|| prev.type === </span><span class="s0">'brace'</span><span class="s2">)) || state.parens &gt; </span><span class="s5">0</span><span class="s2">) {</span>
        <span class="s2">push({ type: </span><span class="s0">'plus'</span><span class="s1">, </span><span class="s2">value })</span><span class="s1">;</span>
        <span class="s1">continue;</span>
      <span class="s2">}</span>

      <span class="s2">push({ type: </span><span class="s0">'plus'</span><span class="s1">, </span><span class="s2">value: PLUS_LITERAL })</span><span class="s1">;</span>
      <span class="s1">continue;</span>
    <span class="s2">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Plain text</span>
     <span class="s3">*/</span>

    <span class="s1">if </span><span class="s2">(value === </span><span class="s0">'@'</span><span class="s2">) {</span>
      <span class="s1">if </span><span class="s2">(opts.noextglob !== </span><span class="s1">true </span><span class="s2">&amp;&amp; peek() === </span><span class="s0">'(' </span><span class="s2">&amp;&amp; peek(</span><span class="s5">2</span><span class="s2">) !== </span><span class="s0">'?'</span><span class="s2">) {</span>
        <span class="s2">push({ type: </span><span class="s0">'at'</span><span class="s1">, </span><span class="s2">extglob: </span><span class="s1">true, </span><span class="s2">value</span><span class="s1">, </span><span class="s2">output: </span><span class="s0">'' </span><span class="s2">})</span><span class="s1">;</span>
        <span class="s1">continue;</span>
      <span class="s2">}</span>

      <span class="s2">push({ type: </span><span class="s0">'text'</span><span class="s1">, </span><span class="s2">value })</span><span class="s1">;</span>
      <span class="s1">continue;</span>
    <span class="s2">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Plain text</span>
     <span class="s3">*/</span>

    <span class="s1">if </span><span class="s2">(value !== </span><span class="s0">'*'</span><span class="s2">) {</span>
      <span class="s1">if </span><span class="s2">(value === </span><span class="s0">'$' </span><span class="s2">|| value === </span><span class="s0">'^'</span><span class="s2">) {</span>
        <span class="s2">value = </span><span class="s0">`</span><span class="s1">\\</span><span class="s2">${value}</span><span class="s0">`</span><span class="s1">;</span>
      <span class="s2">}</span>

      <span class="s1">const </span><span class="s2">match = REGEX_NON_SPECIAL_CHARS.exec(remaining())</span><span class="s1">;</span>
      <span class="s1">if </span><span class="s2">(match) {</span>
        <span class="s2">value += match[</span><span class="s5">0</span><span class="s2">]</span><span class="s1">;</span>
        <span class="s2">state.index += match[</span><span class="s5">0</span><span class="s2">].length</span><span class="s1">;</span>
      <span class="s2">}</span>

      <span class="s2">push({ type: </span><span class="s0">'text'</span><span class="s1">, </span><span class="s2">value })</span><span class="s1">;</span>
      <span class="s1">continue;</span>
    <span class="s2">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Stars</span>
     <span class="s3">*/</span>

    <span class="s1">if </span><span class="s2">(prev &amp;&amp; (prev.type === </span><span class="s0">'globstar' </span><span class="s2">|| prev.star === </span><span class="s1">true</span><span class="s2">)) {</span>
      <span class="s2">prev.type = </span><span class="s0">'star'</span><span class="s1">;</span>
      <span class="s2">prev.star = </span><span class="s1">true;</span>
      <span class="s2">prev.value += value</span><span class="s1">;</span>
      <span class="s2">prev.output = star</span><span class="s1">;</span>
      <span class="s2">state.backtrack = </span><span class="s1">true;</span>
      <span class="s2">state.globstar = </span><span class="s1">true;</span>
      <span class="s2">consume(value)</span><span class="s1">;</span>
      <span class="s1">continue;</span>
    <span class="s2">}</span>

    <span class="s1">let </span><span class="s2">rest = remaining()</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(opts.noextglob !== </span><span class="s1">true </span><span class="s2">&amp;&amp; </span><span class="s5">/^\([^?]/</span><span class="s2">.test(rest)) {</span>
      <span class="s2">extglobOpen(</span><span class="s0">'star'</span><span class="s1">, </span><span class="s2">value)</span><span class="s1">;</span>
      <span class="s1">continue;</span>
    <span class="s2">}</span>

    <span class="s1">if </span><span class="s2">(prev.type === </span><span class="s0">'star'</span><span class="s2">) {</span>
      <span class="s1">if </span><span class="s2">(opts.noglobstar === </span><span class="s1">true</span><span class="s2">) {</span>
        <span class="s2">consume(value)</span><span class="s1">;</span>
        <span class="s1">continue;</span>
      <span class="s2">}</span>

      <span class="s1">const </span><span class="s2">prior = prev.prev</span><span class="s1">;</span>
      <span class="s1">const </span><span class="s2">before = prior.prev</span><span class="s1">;</span>
      <span class="s1">const </span><span class="s2">isStart = prior.type === </span><span class="s0">'slash' </span><span class="s2">|| prior.type === </span><span class="s0">'bos'</span><span class="s1">;</span>
      <span class="s1">const </span><span class="s2">afterStar = before &amp;&amp; (before.type === </span><span class="s0">'star' </span><span class="s2">|| before.type === </span><span class="s0">'globstar'</span><span class="s2">)</span><span class="s1">;</span>

      <span class="s1">if </span><span class="s2">(opts.bash === </span><span class="s1">true </span><span class="s2">&amp;&amp; (!isStart || (rest[</span><span class="s5">0</span><span class="s2">] &amp;&amp; rest[</span><span class="s5">0</span><span class="s2">] !== </span><span class="s0">'/'</span><span class="s2">))) {</span>
        <span class="s2">push({ type: </span><span class="s0">'star'</span><span class="s1">, </span><span class="s2">value</span><span class="s1">, </span><span class="s2">output: </span><span class="s0">'' </span><span class="s2">})</span><span class="s1">;</span>
        <span class="s1">continue;</span>
      <span class="s2">}</span>

      <span class="s1">const </span><span class="s2">isBrace = state.braces &gt; </span><span class="s5">0 </span><span class="s2">&amp;&amp; (prior.type === </span><span class="s0">'comma' </span><span class="s2">|| prior.type === </span><span class="s0">'brace'</span><span class="s2">)</span><span class="s1">;</span>
      <span class="s1">const </span><span class="s2">isExtglob = extglobs.length &amp;&amp; (prior.type === </span><span class="s0">'pipe' </span><span class="s2">|| prior.type === </span><span class="s0">'paren'</span><span class="s2">)</span><span class="s1">;</span>
      <span class="s1">if </span><span class="s2">(!isStart &amp;&amp; prior.type !== </span><span class="s0">'paren' </span><span class="s2">&amp;&amp; !isBrace &amp;&amp; !isExtglob) {</span>
        <span class="s2">push({ type: </span><span class="s0">'star'</span><span class="s1">, </span><span class="s2">value</span><span class="s1">, </span><span class="s2">output: </span><span class="s0">'' </span><span class="s2">})</span><span class="s1">;</span>
        <span class="s1">continue;</span>
      <span class="s2">}</span>

      <span class="s4">// strip consecutive `/**/`</span>
      <span class="s1">while </span><span class="s2">(rest.slice(</span><span class="s5">0</span><span class="s1">, </span><span class="s5">3</span><span class="s2">) === </span><span class="s0">'/**'</span><span class="s2">) {</span>
        <span class="s1">const </span><span class="s2">after = input[state.index + </span><span class="s5">4</span><span class="s2">]</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(after &amp;&amp; after !== </span><span class="s0">'/'</span><span class="s2">) {</span>
          <span class="s1">break;</span>
        <span class="s2">}</span>
        <span class="s2">rest = rest.slice(</span><span class="s5">3</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">consume(</span><span class="s0">'/**'</span><span class="s1">, </span><span class="s5">3</span><span class="s2">)</span><span class="s1">;</span>
      <span class="s2">}</span>

      <span class="s1">if </span><span class="s2">(prior.type === </span><span class="s0">'bos' </span><span class="s2">&amp;&amp; eos()) {</span>
        <span class="s2">prev.type = </span><span class="s0">'globstar'</span><span class="s1">;</span>
        <span class="s2">prev.value += value</span><span class="s1">;</span>
        <span class="s2">prev.output = globstar(opts)</span><span class="s1">;</span>
        <span class="s2">state.output = prev.output</span><span class="s1">;</span>
        <span class="s2">state.globstar = </span><span class="s1">true;</span>
        <span class="s2">consume(value)</span><span class="s1">;</span>
        <span class="s1">continue;</span>
      <span class="s2">}</span>

      <span class="s1">if </span><span class="s2">(prior.type === </span><span class="s0">'slash' </span><span class="s2">&amp;&amp; prior.prev.type !== </span><span class="s0">'bos' </span><span class="s2">&amp;&amp; !afterStar &amp;&amp; eos()) {</span>
        <span class="s2">state.output = state.output.slice(</span><span class="s5">0</span><span class="s1">, </span><span class="s2">-(prior.output + prev.output).length)</span><span class="s1">;</span>
        <span class="s2">prior.output = </span><span class="s0">`(?:</span><span class="s2">${prior.output}</span><span class="s0">`</span><span class="s1">;</span>

        <span class="s2">prev.type = </span><span class="s0">'globstar'</span><span class="s1">;</span>
        <span class="s2">prev.output = globstar(opts) + (opts.strictSlashes ? </span><span class="s0">')' </span><span class="s2">: </span><span class="s0">'|$)'</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">prev.value += value</span><span class="s1">;</span>
        <span class="s2">state.globstar = </span><span class="s1">true;</span>
        <span class="s2">state.output += prior.output + prev.output</span><span class="s1">;</span>
        <span class="s2">consume(value)</span><span class="s1">;</span>
        <span class="s1">continue;</span>
      <span class="s2">}</span>

      <span class="s1">if </span><span class="s2">(prior.type === </span><span class="s0">'slash' </span><span class="s2">&amp;&amp; prior.prev.type !== </span><span class="s0">'bos' </span><span class="s2">&amp;&amp; rest[</span><span class="s5">0</span><span class="s2">] === </span><span class="s0">'/'</span><span class="s2">) {</span>
        <span class="s1">const </span><span class="s2">end = rest[</span><span class="s5">1</span><span class="s2">] !== </span><span class="s1">void </span><span class="s5">0 </span><span class="s2">? </span><span class="s0">'|$' </span><span class="s2">: </span><span class="s0">''</span><span class="s1">;</span>

        <span class="s2">state.output = state.output.slice(</span><span class="s5">0</span><span class="s1">, </span><span class="s2">-(prior.output + prev.output).length)</span><span class="s1">;</span>
        <span class="s2">prior.output = </span><span class="s0">`(?:</span><span class="s2">${prior.output}</span><span class="s0">`</span><span class="s1">;</span>

        <span class="s2">prev.type = </span><span class="s0">'globstar'</span><span class="s1">;</span>
        <span class="s2">prev.output = </span><span class="s0">`</span><span class="s2">${globstar(opts)}${SLASH_LITERAL}</span><span class="s0">|</span><span class="s2">${SLASH_LITERAL}${end}</span><span class="s0">)`</span><span class="s1">;</span>
        <span class="s2">prev.value += value</span><span class="s1">;</span>

        <span class="s2">state.output += prior.output + prev.output</span><span class="s1">;</span>
        <span class="s2">state.globstar = </span><span class="s1">true;</span>

        <span class="s2">consume(value + advance())</span><span class="s1">;</span>

        <span class="s2">push({ type: </span><span class="s0">'slash'</span><span class="s1">, </span><span class="s2">value: </span><span class="s0">'/'</span><span class="s1">, </span><span class="s2">output: </span><span class="s0">'' </span><span class="s2">})</span><span class="s1">;</span>
        <span class="s1">continue;</span>
      <span class="s2">}</span>

      <span class="s1">if </span><span class="s2">(prior.type === </span><span class="s0">'bos' </span><span class="s2">&amp;&amp; rest[</span><span class="s5">0</span><span class="s2">] === </span><span class="s0">'/'</span><span class="s2">) {</span>
        <span class="s2">prev.type = </span><span class="s0">'globstar'</span><span class="s1">;</span>
        <span class="s2">prev.value += value</span><span class="s1">;</span>
        <span class="s2">prev.output = </span><span class="s0">`(?:^|</span><span class="s2">${SLASH_LITERAL}</span><span class="s0">|</span><span class="s2">${globstar(opts)}${SLASH_LITERAL}</span><span class="s0">)`</span><span class="s1">;</span>
        <span class="s2">state.output = prev.output</span><span class="s1">;</span>
        <span class="s2">state.globstar = </span><span class="s1">true;</span>
        <span class="s2">consume(value + advance())</span><span class="s1">;</span>
        <span class="s2">push({ type: </span><span class="s0">'slash'</span><span class="s1">, </span><span class="s2">value: </span><span class="s0">'/'</span><span class="s1">, </span><span class="s2">output: </span><span class="s0">'' </span><span class="s2">})</span><span class="s1">;</span>
        <span class="s1">continue;</span>
      <span class="s2">}</span>

      <span class="s4">// remove single star from output</span>
      <span class="s2">state.output = state.output.slice(</span><span class="s5">0</span><span class="s1">, </span><span class="s2">-prev.output.length)</span><span class="s1">;</span>

      <span class="s4">// reset previous token to globstar</span>
      <span class="s2">prev.type = </span><span class="s0">'globstar'</span><span class="s1">;</span>
      <span class="s2">prev.output = globstar(opts)</span><span class="s1">;</span>
      <span class="s2">prev.value += value</span><span class="s1">;</span>

      <span class="s4">// reset output with globstar</span>
      <span class="s2">state.output += prev.output</span><span class="s1">;</span>
      <span class="s2">state.globstar = </span><span class="s1">true;</span>
      <span class="s2">consume(value)</span><span class="s1">;</span>
      <span class="s1">continue;</span>
    <span class="s2">}</span>

    <span class="s1">const </span><span class="s2">token = { type: </span><span class="s0">'star'</span><span class="s1">, </span><span class="s2">value</span><span class="s1">, </span><span class="s2">output: star }</span><span class="s1">;</span>

    <span class="s1">if </span><span class="s2">(opts.bash === </span><span class="s1">true</span><span class="s2">) {</span>
      <span class="s2">token.output = </span><span class="s0">'.*?'</span><span class="s1">;</span>
      <span class="s1">if </span><span class="s2">(prev.type === </span><span class="s0">'bos' </span><span class="s2">|| prev.type === </span><span class="s0">'slash'</span><span class="s2">) {</span>
        <span class="s2">token.output = nodot + token.output</span><span class="s1">;</span>
      <span class="s2">}</span>
      <span class="s2">push(token)</span><span class="s1">;</span>
      <span class="s1">continue;</span>
    <span class="s2">}</span>

    <span class="s1">if </span><span class="s2">(prev &amp;&amp; (prev.type === </span><span class="s0">'bracket' </span><span class="s2">|| prev.type === </span><span class="s0">'paren'</span><span class="s2">) &amp;&amp; opts.regex === </span><span class="s1">true</span><span class="s2">) {</span>
      <span class="s2">token.output = value</span><span class="s1">;</span>
      <span class="s2">push(token)</span><span class="s1">;</span>
      <span class="s1">continue;</span>
    <span class="s2">}</span>

    <span class="s1">if </span><span class="s2">(state.index === state.start || prev.type === </span><span class="s0">'slash' </span><span class="s2">|| prev.type === </span><span class="s0">'dot'</span><span class="s2">) {</span>
      <span class="s1">if </span><span class="s2">(prev.type === </span><span class="s0">'dot'</span><span class="s2">) {</span>
        <span class="s2">state.output += NO_DOT_SLASH</span><span class="s1">;</span>
        <span class="s2">prev.output += NO_DOT_SLASH</span><span class="s1">;</span>

      <span class="s2">} </span><span class="s1">else if </span><span class="s2">(opts.dot === </span><span class="s1">true</span><span class="s2">) {</span>
        <span class="s2">state.output += NO_DOTS_SLASH</span><span class="s1">;</span>
        <span class="s2">prev.output += NO_DOTS_SLASH</span><span class="s1">;</span>

      <span class="s2">} </span><span class="s1">else </span><span class="s2">{</span>
        <span class="s2">state.output += nodot</span><span class="s1">;</span>
        <span class="s2">prev.output += nodot</span><span class="s1">;</span>
      <span class="s2">}</span>

      <span class="s1">if </span><span class="s2">(peek() !== </span><span class="s0">'*'</span><span class="s2">) {</span>
        <span class="s2">state.output += ONE_CHAR</span><span class="s1">;</span>
        <span class="s2">prev.output += ONE_CHAR</span><span class="s1">;</span>
      <span class="s2">}</span>
    <span class="s2">}</span>

    <span class="s2">push(token)</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s1">while </span><span class="s2">(state.brackets &gt; </span><span class="s5">0</span><span class="s2">) {</span>
    <span class="s1">if </span><span class="s2">(opts.strictBrackets === </span><span class="s1">true</span><span class="s2">) </span><span class="s1">throw new </span><span class="s2">SyntaxError(syntaxError(</span><span class="s0">'closing'</span><span class="s1">, </span><span class="s0">']'</span><span class="s2">))</span><span class="s1">;</span>
    <span class="s2">state.output = utils$1.escapeLast(state.output</span><span class="s1">, </span><span class="s0">'['</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">decrement(</span><span class="s0">'brackets'</span><span class="s2">)</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s1">while </span><span class="s2">(state.parens &gt; </span><span class="s5">0</span><span class="s2">) {</span>
    <span class="s1">if </span><span class="s2">(opts.strictBrackets === </span><span class="s1">true</span><span class="s2">) </span><span class="s1">throw new </span><span class="s2">SyntaxError(syntaxError(</span><span class="s0">'closing'</span><span class="s1">, </span><span class="s0">')'</span><span class="s2">))</span><span class="s1">;</span>
    <span class="s2">state.output = utils$1.escapeLast(state.output</span><span class="s1">, </span><span class="s0">'('</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">decrement(</span><span class="s0">'parens'</span><span class="s2">)</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s1">while </span><span class="s2">(state.braces &gt; </span><span class="s5">0</span><span class="s2">) {</span>
    <span class="s1">if </span><span class="s2">(opts.strictBrackets === </span><span class="s1">true</span><span class="s2">) </span><span class="s1">throw new </span><span class="s2">SyntaxError(syntaxError(</span><span class="s0">'closing'</span><span class="s1">, </span><span class="s0">'}'</span><span class="s2">))</span><span class="s1">;</span>
    <span class="s2">state.output = utils$1.escapeLast(state.output</span><span class="s1">, </span><span class="s0">'{'</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">decrement(</span><span class="s0">'braces'</span><span class="s2">)</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s1">if </span><span class="s2">(opts.strictSlashes !== </span><span class="s1">true </span><span class="s2">&amp;&amp; (prev.type === </span><span class="s0">'star' </span><span class="s2">|| prev.type === </span><span class="s0">'bracket'</span><span class="s2">)) {</span>
    <span class="s2">push({ type: </span><span class="s0">'maybe_slash'</span><span class="s1">, </span><span class="s2">value: </span><span class="s0">''</span><span class="s1">, </span><span class="s2">output: </span><span class="s0">`</span><span class="s2">${SLASH_LITERAL}</span><span class="s0">?` </span><span class="s2">})</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s4">// rebuild the output if we had to backtrack at any point</span>
  <span class="s1">if </span><span class="s2">(state.backtrack === </span><span class="s1">true</span><span class="s2">) {</span>
    <span class="s2">state.output = </span><span class="s0">''</span><span class="s1">;</span>

    <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">token of state.tokens) {</span>
      <span class="s2">state.output += token.output != </span><span class="s1">null </span><span class="s2">? token.output : token.value</span><span class="s1">;</span>

      <span class="s1">if </span><span class="s2">(token.suffix) {</span>
        <span class="s2">state.output += token.suffix</span><span class="s1">;</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
  <span class="s2">}</span>

  <span class="s1">return </span><span class="s2">state</span><span class="s1">;</span>
<span class="s2">}</span><span class="s1">;</span>

<span class="s3">/**</span>
 <span class="s3">* Fast paths for creating regular expressions for common glob patterns.</span>
 <span class="s3">* This can significantly speed up processing and has very little downside</span>
 <span class="s3">* impact when none of the fast paths match.</span>
 <span class="s3">*/</span>

<span class="s2">parse$2.fastpaths = (input</span><span class="s1">, </span><span class="s2">options) =&gt; {</span>
  <span class="s1">const </span><span class="s2">opts = { ...options }</span><span class="s1">;</span>
  <span class="s1">const </span><span class="s2">max = </span><span class="s1">typeof </span><span class="s2">opts.maxLength === </span><span class="s0">'number' </span><span class="s2">? Math.min(MAX_LENGTH</span><span class="s1">, </span><span class="s2">opts.maxLength) : MAX_LENGTH</span><span class="s1">;</span>
  <span class="s1">const </span><span class="s2">len = input.length</span><span class="s1">;</span>
  <span class="s1">if </span><span class="s2">(len &gt; max) {</span>
    <span class="s1">throw new </span><span class="s2">SyntaxError(</span><span class="s0">`Input length: </span><span class="s2">${len}</span><span class="s0">, exceeds maximum allowed length: </span><span class="s2">${max}</span><span class="s0">`</span><span class="s2">)</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s2">input = REPLACEMENTS[input] || input</span><span class="s1">;</span>
  <span class="s1">const </span><span class="s2">win32 = utils$1.isWindows(options)</span><span class="s1">;</span>

  <span class="s4">// create constants based on platform, for windows or posix</span>
  <span class="s1">const </span><span class="s2">{</span>
    <span class="s2">DOT_LITERAL</span><span class="s1">,</span>
    <span class="s2">SLASH_LITERAL</span><span class="s1">,</span>
    <span class="s2">ONE_CHAR</span><span class="s1">,</span>
    <span class="s2">DOTS_SLASH</span><span class="s1">,</span>
    <span class="s2">NO_DOT</span><span class="s1">,</span>
    <span class="s2">NO_DOTS</span><span class="s1">,</span>
    <span class="s2">NO_DOTS_SLASH</span><span class="s1">,</span>
    <span class="s2">STAR</span><span class="s1">,</span>
    <span class="s2">START_ANCHOR</span>
  <span class="s2">} = constants$1.globChars(win32)</span><span class="s1">;</span>

  <span class="s1">const </span><span class="s2">nodot = opts.dot ? NO_DOTS : NO_DOT</span><span class="s1">;</span>
  <span class="s1">const </span><span class="s2">slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT</span><span class="s1">;</span>
  <span class="s1">const </span><span class="s2">capture = opts.capture ? </span><span class="s0">'' </span><span class="s2">: </span><span class="s0">'?:'</span><span class="s1">;</span>
  <span class="s1">const </span><span class="s2">state = { negated: </span><span class="s1">false, </span><span class="s2">prefix: </span><span class="s0">'' </span><span class="s2">}</span><span class="s1">;</span>
  <span class="s1">let </span><span class="s2">star = opts.bash === </span><span class="s1">true </span><span class="s2">? </span><span class="s0">'.*?' </span><span class="s2">: STAR</span><span class="s1">;</span>

  <span class="s1">if </span><span class="s2">(opts.capture) {</span>
    <span class="s2">star = </span><span class="s0">`(</span><span class="s2">${star}</span><span class="s0">)`</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s1">const </span><span class="s2">globstar = opts =&gt; {</span>
    <span class="s1">if </span><span class="s2">(opts.noglobstar === </span><span class="s1">true</span><span class="s2">) </span><span class="s1">return </span><span class="s2">star</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s0">`(</span><span class="s2">${capture}</span><span class="s0">(?:(?!</span><span class="s2">${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}</span><span class="s0">).)*?)`</span><span class="s1">;</span>
  <span class="s2">}</span><span class="s1">;</span>

  <span class="s1">const </span><span class="s2">create = str =&gt; {</span>
    <span class="s1">switch </span><span class="s2">(str) {</span>
      <span class="s1">case </span><span class="s0">'*'</span><span class="s2">:</span>
        <span class="s1">return </span><span class="s0">`</span><span class="s2">${nodot}${ONE_CHAR}${star}</span><span class="s0">`</span><span class="s1">;</span>

      <span class="s1">case </span><span class="s0">'.*'</span><span class="s2">:</span>
        <span class="s1">return </span><span class="s0">`</span><span class="s2">${DOT_LITERAL}${ONE_CHAR}${star}</span><span class="s0">`</span><span class="s1">;</span>

      <span class="s1">case </span><span class="s0">'*.*'</span><span class="s2">:</span>
        <span class="s1">return </span><span class="s0">`</span><span class="s2">${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}</span><span class="s0">`</span><span class="s1">;</span>

      <span class="s1">case </span><span class="s0">'*/*'</span><span class="s2">:</span>
        <span class="s1">return </span><span class="s0">`</span><span class="s2">${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}</span><span class="s0">`</span><span class="s1">;</span>

      <span class="s1">case </span><span class="s0">'**'</span><span class="s2">:</span>
        <span class="s1">return </span><span class="s2">nodot + globstar(opts)</span><span class="s1">;</span>

      <span class="s1">case </span><span class="s0">'**/*'</span><span class="s2">:</span>
        <span class="s1">return </span><span class="s0">`(?:</span><span class="s2">${nodot}${globstar(opts)}${SLASH_LITERAL}</span><span class="s0">)?</span><span class="s2">${slashDot}${ONE_CHAR}${star}</span><span class="s0">`</span><span class="s1">;</span>

      <span class="s1">case </span><span class="s0">'**/*.*'</span><span class="s2">:</span>
        <span class="s1">return </span><span class="s0">`(?:</span><span class="s2">${nodot}${globstar(opts)}${SLASH_LITERAL}</span><span class="s0">)?</span><span class="s2">${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}</span><span class="s0">`</span><span class="s1">;</span>

      <span class="s1">case </span><span class="s0">'**/.*'</span><span class="s2">:</span>
        <span class="s1">return </span><span class="s0">`(?:</span><span class="s2">${nodot}${globstar(opts)}${SLASH_LITERAL}</span><span class="s0">)?</span><span class="s2">${DOT_LITERAL}${ONE_CHAR}${star}</span><span class="s0">`</span><span class="s1">;</span>

      <span class="s1">default</span><span class="s2">: {</span>
        <span class="s1">const </span><span class="s2">match = </span><span class="s5">/^(.*?)\.(\w+)$/</span><span class="s2">.exec(str)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(!match) </span><span class="s1">return;</span>

        <span class="s1">const </span><span class="s2">source = create(match[</span><span class="s5">1</span><span class="s2">])</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(!source) </span><span class="s1">return;</span>

        <span class="s1">return </span><span class="s2">source + DOT_LITERAL + match[</span><span class="s5">2</span><span class="s2">]</span><span class="s1">;</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
  <span class="s2">}</span><span class="s1">;</span>

  <span class="s1">const </span><span class="s2">output = utils$1.removePrefix(input</span><span class="s1">, </span><span class="s2">state)</span><span class="s1">;</span>
  <span class="s1">let </span><span class="s2">source = create(output)</span><span class="s1">;</span>

  <span class="s1">if </span><span class="s2">(source &amp;&amp; opts.strictSlashes !== </span><span class="s1">true</span><span class="s2">) {</span>
    <span class="s2">source += </span><span class="s0">`</span><span class="s2">${SLASH_LITERAL}</span><span class="s0">?`</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s1">return </span><span class="s2">source</span><span class="s1">;</span>
<span class="s2">}</span><span class="s1">;</span>

<span class="s1">var </span><span class="s2">parse_1$1 = parse$2</span><span class="s1">;</span>

<span class="s1">const </span><span class="s2">path$1 = require$$0$1</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">scan = scan_1</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">parse$1 = parse_1$1</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">utils = utils$3</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">constants = constants$2</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">isObject$1 = val =&gt; val &amp;&amp; </span><span class="s1">typeof </span><span class="s2">val === </span><span class="s0">'object' </span><span class="s2">&amp;&amp; !Array.isArray(val)</span><span class="s1">;</span>

<span class="s3">/**</span>
 <span class="s3">* Creates a matcher function from one or more glob patterns. The</span>
 <span class="s3">* returned function takes a string to match as its first argument,</span>
 <span class="s3">* and returns true if the string is a match. The returned matcher</span>
 <span class="s3">* function also takes a boolean as the second argument that, when true,</span>
 <span class="s3">* returns an object with additional information.</span>
 <span class="s3">*</span>
 <span class="s3">* ```js</span>
 <span class="s3">* const picomatch = require('picomatch');</span>
 <span class="s3">* // picomatch(glob[, options]);</span>
 <span class="s3">*</span>
 <span class="s3">* const isMatch = picomatch('*.!(*a)');</span>
 <span class="s3">* console.log(isMatch('a.a')); //=&gt; false</span>
 <span class="s3">* console.log(isMatch('a.b')); //=&gt; true</span>
 <span class="s3">* ```</span>
 <span class="s3">* </span><span class="s6">@name </span><span class="s3">picomatch</span>
 <span class="s3">* </span><span class="s6">@param </span><span class="s3">{String|Array} `globs` One or more glob patterns.</span>
 <span class="s3">* </span><span class="s6">@param </span><span class="s3">{Object=} `options`</span>
 <span class="s3">* </span><span class="s6">@return </span><span class="s3">{Function=} Returns a matcher function.</span>
 <span class="s3">* </span><span class="s6">@api </span><span class="s3">public</span>
 <span class="s3">*/</span>

<span class="s1">const </span><span class="s2">picomatch = (glob</span><span class="s1">, </span><span class="s2">options</span><span class="s1">, </span><span class="s2">returnState = </span><span class="s1">false</span><span class="s2">) =&gt; {</span>
  <span class="s1">if </span><span class="s2">(Array.isArray(glob)) {</span>
    <span class="s1">const </span><span class="s2">fns = glob.map(input =&gt; picomatch(input</span><span class="s1">, </span><span class="s2">options</span><span class="s1">, </span><span class="s2">returnState))</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">arrayMatcher = str =&gt; {</span>
      <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">isMatch of fns) {</span>
        <span class="s1">const </span><span class="s2">state = isMatch(str)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(state) </span><span class="s1">return </span><span class="s2">state</span><span class="s1">;</span>
      <span class="s2">}</span>
      <span class="s1">return false;</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">arrayMatcher</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s1">const </span><span class="s2">isState = isObject$1(glob) &amp;&amp; glob.tokens &amp;&amp; glob.input</span><span class="s1">;</span>

  <span class="s1">if </span><span class="s2">(glob === </span><span class="s0">'' </span><span class="s2">|| (</span><span class="s1">typeof </span><span class="s2">glob !== </span><span class="s0">'string' </span><span class="s2">&amp;&amp; !isState)) {</span>
    <span class="s1">throw new </span><span class="s2">TypeError(</span><span class="s0">'Expected pattern to be a non-empty string'</span><span class="s2">)</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s1">const </span><span class="s2">opts = options || {}</span><span class="s1">;</span>
  <span class="s1">const </span><span class="s2">posix = utils.isWindows(options)</span><span class="s1">;</span>
  <span class="s1">const </span><span class="s2">regex = isState</span>
    <span class="s2">? picomatch.compileRe(glob</span><span class="s1">, </span><span class="s2">options)</span>
    <span class="s2">: picomatch.makeRe(glob</span><span class="s1">, </span><span class="s2">options</span><span class="s1">, false, true</span><span class="s2">)</span><span class="s1">;</span>

  <span class="s1">const </span><span class="s2">state = regex.state</span><span class="s1">;</span>
  <span class="s1">delete </span><span class="s2">regex.state</span><span class="s1">;</span>

  <span class="s1">let </span><span class="s2">isIgnored = () =&gt; </span><span class="s1">false;</span>
  <span class="s1">if </span><span class="s2">(opts.ignore) {</span>
    <span class="s1">const </span><span class="s2">ignoreOpts = { ...options</span><span class="s1">, </span><span class="s2">ignore: </span><span class="s1">null, </span><span class="s2">onMatch: </span><span class="s1">null, </span><span class="s2">onResult: </span><span class="s1">null </span><span class="s2">}</span><span class="s1">;</span>
    <span class="s2">isIgnored = picomatch(opts.ignore</span><span class="s1">, </span><span class="s2">ignoreOpts</span><span class="s1">, </span><span class="s2">returnState)</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s1">const </span><span class="s2">matcher = (input</span><span class="s1">, </span><span class="s2">returnObject = </span><span class="s1">false</span><span class="s2">) =&gt; {</span>
    <span class="s1">const </span><span class="s2">{ isMatch</span><span class="s1">, </span><span class="s2">match</span><span class="s1">, </span><span class="s2">output } = picomatch.test(input</span><span class="s1">, </span><span class="s2">regex</span><span class="s1">, </span><span class="s2">options</span><span class="s1">, </span><span class="s2">{ glob</span><span class="s1">, </span><span class="s2">posix })</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">result = { glob</span><span class="s1">, </span><span class="s2">state</span><span class="s1">, </span><span class="s2">regex</span><span class="s1">, </span><span class="s2">posix</span><span class="s1">, </span><span class="s2">input</span><span class="s1">, </span><span class="s2">output</span><span class="s1">, </span><span class="s2">match</span><span class="s1">, </span><span class="s2">isMatch }</span><span class="s1">;</span>

    <span class="s1">if </span><span class="s2">(</span><span class="s1">typeof </span><span class="s2">opts.onResult === </span><span class="s0">'function'</span><span class="s2">) {</span>
      <span class="s2">opts.onResult(result)</span><span class="s1">;</span>
    <span class="s2">}</span>

    <span class="s1">if </span><span class="s2">(isMatch === </span><span class="s1">false</span><span class="s2">) {</span>
      <span class="s2">result.isMatch = </span><span class="s1">false;</span>
      <span class="s1">return </span><span class="s2">returnObject ? result : </span><span class="s1">false;</span>
    <span class="s2">}</span>

    <span class="s1">if </span><span class="s2">(isIgnored(input)) {</span>
      <span class="s1">if </span><span class="s2">(</span><span class="s1">typeof </span><span class="s2">opts.onIgnore === </span><span class="s0">'function'</span><span class="s2">) {</span>
        <span class="s2">opts.onIgnore(result)</span><span class="s1">;</span>
      <span class="s2">}</span>
      <span class="s2">result.isMatch = </span><span class="s1">false;</span>
      <span class="s1">return </span><span class="s2">returnObject ? result : </span><span class="s1">false;</span>
    <span class="s2">}</span>

    <span class="s1">if </span><span class="s2">(</span><span class="s1">typeof </span><span class="s2">opts.onMatch === </span><span class="s0">'function'</span><span class="s2">) {</span>
      <span class="s2">opts.onMatch(result)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">returnObject ? result : </span><span class="s1">true;</span>
  <span class="s2">}</span><span class="s1">;</span>

  <span class="s1">if </span><span class="s2">(returnState) {</span>
    <span class="s2">matcher.state = state</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s1">return </span><span class="s2">matcher</span><span class="s1">;</span>
<span class="s2">}</span><span class="s1">;</span>

<span class="s3">/**</span>
 <span class="s3">* Test `input` with the given `regex`. This is used by the main</span>
 <span class="s3">* `picomatch()` function to test the input string.</span>
 <span class="s3">*</span>
 <span class="s3">* ```js</span>
 <span class="s3">* const picomatch = require('picomatch');</span>
 <span class="s3">* // picomatch.test(input, regex[, options]);</span>
 <span class="s3">*</span>
 <span class="s3">* console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\/([^/]*?))$/));</span>
 <span class="s3">* // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }</span>
 <span class="s3">* ```</span>
 <span class="s3">* </span><span class="s6">@param </span><span class="s3">{String} `input` String to test.</span>
 <span class="s3">* </span><span class="s6">@param </span><span class="s3">{RegExp} `regex`</span>
 <span class="s3">* </span><span class="s6">@return </span><span class="s3">{Object} Returns an object with matching info.</span>
 <span class="s3">* </span><span class="s6">@api </span><span class="s3">public</span>
 <span class="s3">*/</span>

<span class="s2">picomatch.test = (input</span><span class="s1">, </span><span class="s2">regex</span><span class="s1">, </span><span class="s2">options</span><span class="s1">, </span><span class="s2">{ glob</span><span class="s1">, </span><span class="s2">posix } = {}) =&gt; {</span>
  <span class="s1">if </span><span class="s2">(</span><span class="s1">typeof </span><span class="s2">input !== </span><span class="s0">'string'</span><span class="s2">) {</span>
    <span class="s1">throw new </span><span class="s2">TypeError(</span><span class="s0">'Expected input to be a string'</span><span class="s2">)</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s1">if </span><span class="s2">(input === </span><span class="s0">''</span><span class="s2">) {</span>
    <span class="s1">return </span><span class="s2">{ isMatch: </span><span class="s1">false, </span><span class="s2">output: </span><span class="s0">'' </span><span class="s2">}</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s1">const </span><span class="s2">opts = options || {}</span><span class="s1">;</span>
  <span class="s1">const </span><span class="s2">format = opts.format || (posix ? utils.toPosixSlashes : </span><span class="s1">null</span><span class="s2">)</span><span class="s1">;</span>
  <span class="s1">let </span><span class="s2">match = input === glob</span><span class="s1">;</span>
  <span class="s1">let </span><span class="s2">output = (match &amp;&amp; format) ? format(input) : input</span><span class="s1">;</span>

  <span class="s1">if </span><span class="s2">(match === </span><span class="s1">false</span><span class="s2">) {</span>
    <span class="s2">output = format ? format(input) : input</span><span class="s1">;</span>
    <span class="s2">match = output === glob</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s1">if </span><span class="s2">(match === </span><span class="s1">false </span><span class="s2">|| opts.capture === </span><span class="s1">true</span><span class="s2">) {</span>
    <span class="s1">if </span><span class="s2">(opts.matchBase === </span><span class="s1">true </span><span class="s2">|| opts.basename === </span><span class="s1">true</span><span class="s2">) {</span>
      <span class="s2">match = picomatch.matchBase(input</span><span class="s1">, </span><span class="s2">regex</span><span class="s1">, </span><span class="s2">options</span><span class="s1">, </span><span class="s2">posix)</span><span class="s1">;</span>
    <span class="s2">} </span><span class="s1">else </span><span class="s2">{</span>
      <span class="s2">match = regex.exec(output)</span><span class="s1">;</span>
    <span class="s2">}</span>
  <span class="s2">}</span>

  <span class="s1">return </span><span class="s2">{ isMatch: Boolean(match)</span><span class="s1">, </span><span class="s2">match</span><span class="s1">, </span><span class="s2">output }</span><span class="s1">;</span>
<span class="s2">}</span><span class="s1">;</span>

<span class="s3">/**</span>
 <span class="s3">* Match the basename of a filepath.</span>
 <span class="s3">*</span>
 <span class="s3">* ```js</span>
 <span class="s3">* const picomatch = require('picomatch');</span>
 <span class="s3">* // picomatch.matchBase(input, glob[, options]);</span>
 <span class="s3">* console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true</span>
 <span class="s3">* ```</span>
 <span class="s3">* </span><span class="s6">@param </span><span class="s3">{String} `input` String to test.</span>
 <span class="s3">* </span><span class="s6">@param </span><span class="s3">{RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).</span>
 <span class="s3">* </span><span class="s6">@return </span><span class="s3">{Boolean}</span>
 <span class="s3">* </span><span class="s6">@api </span><span class="s3">public</span>
 <span class="s3">*/</span>

<span class="s2">picomatch.matchBase = (input</span><span class="s1">, </span><span class="s2">glob</span><span class="s1">, </span><span class="s2">options</span><span class="s1">, </span><span class="s2">posix = utils.isWindows(options)) =&gt; {</span>
  <span class="s1">const </span><span class="s2">regex = glob </span><span class="s1">instanceof </span><span class="s2">RegExp ? glob : picomatch.makeRe(glob</span><span class="s1">, </span><span class="s2">options)</span><span class="s1">;</span>
  <span class="s1">return </span><span class="s2">regex.test(path$1.basename(input))</span><span class="s1">;</span>
<span class="s2">}</span><span class="s1">;</span>

<span class="s3">/**</span>
 <span class="s3">* Returns true if **any** of the given glob `patterns` match the specified `string`.</span>
 <span class="s3">*</span>
 <span class="s3">* ```js</span>
 <span class="s3">* const picomatch = require('picomatch');</span>
 <span class="s3">* // picomatch.isMatch(string, patterns[, options]);</span>
 <span class="s3">*</span>
 <span class="s3">* console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=&gt; true</span>
 <span class="s3">* console.log(picomatch.isMatch('a.a', 'b.*')); //=&gt; false</span>
 <span class="s3">* ```</span>
 <span class="s3">* </span><span class="s6">@param </span><span class="s3">{String|Array} str The string to test.</span>
 <span class="s3">* </span><span class="s6">@param </span><span class="s3">{String|Array} patterns One or more glob patterns to use for matching.</span>
 <span class="s3">* </span><span class="s6">@param </span><span class="s3">{Object} [options] See available [options](#options).</span>
 <span class="s3">* </span><span class="s6">@return </span><span class="s3">{Boolean} Returns true if any patterns match `str`</span>
 <span class="s3">* </span><span class="s6">@api </span><span class="s3">public</span>
 <span class="s3">*/</span>

<span class="s2">picomatch.isMatch = (str</span><span class="s1">, </span><span class="s2">patterns</span><span class="s1">, </span><span class="s2">options) =&gt; picomatch(patterns</span><span class="s1">, </span><span class="s2">options)(str)</span><span class="s1">;</span>

<span class="s3">/**</span>
 <span class="s3">* Parse a glob pattern to create the source string for a regular</span>
 <span class="s3">* expression.</span>
 <span class="s3">*</span>
 <span class="s3">* ```js</span>
 <span class="s3">* const picomatch = require('picomatch');</span>
 <span class="s3">* const result = picomatch.parse(pattern[, options]);</span>
 <span class="s3">* ```</span>
 <span class="s3">* </span><span class="s6">@param </span><span class="s3">{String} `pattern`</span>
 <span class="s3">* </span><span class="s6">@param </span><span class="s3">{Object} `options`</span>
 <span class="s3">* </span><span class="s6">@return </span><span class="s3">{Object} Returns an object with useful properties and output to be used as a regex source string.</span>
 <span class="s3">* </span><span class="s6">@api </span><span class="s3">public</span>
 <span class="s3">*/</span>

<span class="s2">picomatch.parse = (pattern</span><span class="s1">, </span><span class="s2">options) =&gt; {</span>
  <span class="s1">if </span><span class="s2">(Array.isArray(pattern)) </span><span class="s1">return </span><span class="s2">pattern.map(p =&gt; picomatch.parse(p</span><span class="s1">, </span><span class="s2">options))</span><span class="s1">;</span>
  <span class="s1">return </span><span class="s2">parse$1(pattern</span><span class="s1">, </span><span class="s2">{ ...options</span><span class="s1">, </span><span class="s2">fastpaths: </span><span class="s1">false </span><span class="s2">})</span><span class="s1">;</span>
<span class="s2">}</span><span class="s1">;</span>

<span class="s3">/**</span>
 <span class="s3">* Scan a glob pattern to separate the pattern into segments.</span>
 <span class="s3">*</span>
 <span class="s3">* ```js</span>
 <span class="s3">* const picomatch = require('picomatch');</span>
 <span class="s3">* // picomatch.scan(input[, options]);</span>
 <span class="s3">*</span>
 <span class="s3">* const result = picomatch.scan('!./foo/*.js');</span>
 <span class="s3">* console.log(result);</span>
 <span class="s3">* { prefix: '!./',</span>
 <span class="s3">*   input: '!./foo/*.js',</span>
 <span class="s3">*   start: 3,</span>
 <span class="s3">*   base: 'foo',</span>
 <span class="s3">*   glob: '*.js',</span>
 <span class="s3">*   isBrace: false,</span>
 <span class="s3">*   isBracket: false,</span>
 <span class="s3">*   isGlob: true,</span>
 <span class="s3">*   isExtglob: false,</span>
 <span class="s3">*   isGlobstar: false,</span>
 <span class="s3">*   negated: true }</span>
 <span class="s3">* ```</span>
 <span class="s3">* </span><span class="s6">@param </span><span class="s3">{String} `input` Glob pattern to scan.</span>
 <span class="s3">* </span><span class="s6">@param </span><span class="s3">{Object} `options`</span>
 <span class="s3">* </span><span class="s6">@return </span><span class="s3">{Object} Returns an object with</span>
 <span class="s3">* </span><span class="s6">@api </span><span class="s3">public</span>
 <span class="s3">*/</span>

<span class="s2">picomatch.scan = (input</span><span class="s1">, </span><span class="s2">options) =&gt; scan(input</span><span class="s1">, </span><span class="s2">options)</span><span class="s1">;</span>

<span class="s3">/**</span>
 <span class="s3">* Compile a regular expression from the `state` object returned by the</span>
 <span class="s3">* [parse()](#parse) method.</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s6">@param </span><span class="s3">{Object} `state`</span>
 <span class="s3">* </span><span class="s6">@param </span><span class="s3">{Object} `options`</span>
 <span class="s3">* </span><span class="s6">@param </span><span class="s3">{Boolean} `returnOutput` Intended for implementors, this argument allows you to return the raw output from the parser.</span>
 <span class="s3">* </span><span class="s6">@param </span><span class="s3">{Boolean} `returnState` Adds the state to a `state` property on the returned regex. Useful for implementors and debugging.</span>
 <span class="s3">* </span><span class="s6">@return </span><span class="s3">{RegExp}</span>
 <span class="s3">* </span><span class="s6">@api </span><span class="s3">public</span>
 <span class="s3">*/</span>

<span class="s2">picomatch.compileRe = (state</span><span class="s1">, </span><span class="s2">options</span><span class="s1">, </span><span class="s2">returnOutput = </span><span class="s1">false, </span><span class="s2">returnState = </span><span class="s1">false</span><span class="s2">) =&gt; {</span>
  <span class="s1">if </span><span class="s2">(returnOutput === </span><span class="s1">true</span><span class="s2">) {</span>
    <span class="s1">return </span><span class="s2">state.output</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s1">const </span><span class="s2">opts = options || {}</span><span class="s1">;</span>
  <span class="s1">const </span><span class="s2">prepend = opts.contains ? </span><span class="s0">'' </span><span class="s2">: </span><span class="s0">'^'</span><span class="s1">;</span>
  <span class="s1">const </span><span class="s2">append = opts.contains ? </span><span class="s0">'' </span><span class="s2">: </span><span class="s0">'$'</span><span class="s1">;</span>

  <span class="s1">let </span><span class="s2">source = </span><span class="s0">`</span><span class="s2">${prepend}</span><span class="s0">(?:</span><span class="s2">${state.output}</span><span class="s0">)</span><span class="s2">${append}</span><span class="s0">`</span><span class="s1">;</span>
  <span class="s1">if </span><span class="s2">(state &amp;&amp; state.negated === </span><span class="s1">true</span><span class="s2">) {</span>
    <span class="s2">source = </span><span class="s0">`^(?!</span><span class="s2">${source}</span><span class="s0">).*$`</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s1">const </span><span class="s2">regex = picomatch.toRegex(source</span><span class="s1">, </span><span class="s2">options)</span><span class="s1">;</span>
  <span class="s1">if </span><span class="s2">(returnState === </span><span class="s1">true</span><span class="s2">) {</span>
    <span class="s2">regex.state = state</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s1">return </span><span class="s2">regex</span><span class="s1">;</span>
<span class="s2">}</span><span class="s1">;</span>

<span class="s3">/**</span>
 <span class="s3">* Create a regular expression from a parsed glob pattern.</span>
 <span class="s3">*</span>
 <span class="s3">* ```js</span>
 <span class="s3">* const picomatch = require('picomatch');</span>
 <span class="s3">* const state = picomatch.parse('*.js');</span>
 <span class="s3">* // picomatch.compileRe(state[, options]);</span>
 <span class="s3">*</span>
 <span class="s3">* console.log(picomatch.compileRe(state));</span>
 <span class="s3">* //=&gt; /^(?:(?!\.)(?=.)[^/]*?\.js)$/</span>
 <span class="s3">* ```</span>
 <span class="s3">* </span><span class="s6">@param </span><span class="s3">{String} `state` The object returned from the `.parse` method.</span>
 <span class="s3">* </span><span class="s6">@param </span><span class="s3">{Object} `options`</span>
 <span class="s3">* </span><span class="s6">@param </span><span class="s3">{Boolean} `returnOutput` Implementors may use this argument to return the compiled output, instead of a regular expression. This is not exposed on the options to prevent end-users from mutating the result.</span>
 <span class="s3">* </span><span class="s6">@param </span><span class="s3">{Boolean} `returnState` Implementors may use this argument to return the state from the parsed glob with the returned regular expression.</span>
 <span class="s3">* </span><span class="s6">@return </span><span class="s3">{RegExp} Returns a regex created from the given pattern.</span>
 <span class="s3">* </span><span class="s6">@api </span><span class="s3">public</span>
 <span class="s3">*/</span>

<span class="s2">picomatch.makeRe = (input</span><span class="s1">, </span><span class="s2">options = {}</span><span class="s1">, </span><span class="s2">returnOutput = </span><span class="s1">false, </span><span class="s2">returnState = </span><span class="s1">false</span><span class="s2">) =&gt; {</span>
  <span class="s1">if </span><span class="s2">(!input || </span><span class="s1">typeof </span><span class="s2">input !== </span><span class="s0">'string'</span><span class="s2">) {</span>
    <span class="s1">throw new </span><span class="s2">TypeError(</span><span class="s0">'Expected a non-empty string'</span><span class="s2">)</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s1">let </span><span class="s2">parsed = { negated: </span><span class="s1">false, </span><span class="s2">fastpaths: </span><span class="s1">true </span><span class="s2">}</span><span class="s1">;</span>

  <span class="s1">if </span><span class="s2">(options.fastpaths !== </span><span class="s1">false </span><span class="s2">&amp;&amp; (input[</span><span class="s5">0</span><span class="s2">] === </span><span class="s0">'.' </span><span class="s2">|| input[</span><span class="s5">0</span><span class="s2">] === </span><span class="s0">'*'</span><span class="s2">)) {</span>
    <span class="s2">parsed.output = parse$1.fastpaths(input</span><span class="s1">, </span><span class="s2">options)</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s1">if </span><span class="s2">(!parsed.output) {</span>
    <span class="s2">parsed = parse$1(input</span><span class="s1">, </span><span class="s2">options)</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s1">return </span><span class="s2">picomatch.compileRe(parsed</span><span class="s1">, </span><span class="s2">options</span><span class="s1">, </span><span class="s2">returnOutput</span><span class="s1">, </span><span class="s2">returnState)</span><span class="s1">;</span>
<span class="s2">}</span><span class="s1">;</span>

<span class="s3">/**</span>
 <span class="s3">* Create a regular expression from the given regex source string.</span>
 <span class="s3">*</span>
 <span class="s3">* ```js</span>
 <span class="s3">* const picomatch = require('picomatch');</span>
 <span class="s3">* // picomatch.toRegex(source[, options]);</span>
 <span class="s3">*</span>
 <span class="s3">* const { output } = picomatch.parse('*.js');</span>
 <span class="s3">* console.log(picomatch.toRegex(output));</span>
 <span class="s3">* //=&gt; /^(?:(?!\.)(?=.)[^/]*?\.js)$/</span>
 <span class="s3">* ```</span>
 <span class="s3">* </span><span class="s6">@param </span><span class="s3">{String} `source` Regular expression source string.</span>
 <span class="s3">* </span><span class="s6">@param </span><span class="s3">{Object} `options`</span>
 <span class="s3">* </span><span class="s6">@return </span><span class="s3">{RegExp}</span>
 <span class="s3">* </span><span class="s6">@api </span><span class="s3">public</span>
 <span class="s3">*/</span>

<span class="s2">picomatch.toRegex = (source</span><span class="s1">, </span><span class="s2">options) =&gt; {</span>
  <span class="s1">try </span><span class="s2">{</span>
    <span class="s1">const </span><span class="s2">opts = options || {}</span><span class="s1">;</span>
    <span class="s1">return new </span><span class="s2">RegExp(source</span><span class="s1">, </span><span class="s2">opts.flags || (opts.nocase ? </span><span class="s0">'i' </span><span class="s2">: </span><span class="s0">''</span><span class="s2">))</span><span class="s1">;</span>
  <span class="s2">} </span><span class="s1">catch </span><span class="s2">(err) {</span>
    <span class="s1">if </span><span class="s2">(options &amp;&amp; options.debug === </span><span class="s1">true</span><span class="s2">) </span><span class="s1">throw </span><span class="s2">err</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s5">/$^/</span><span class="s1">;</span>
  <span class="s2">}</span>
<span class="s2">}</span><span class="s1">;</span>

<span class="s3">/**</span>
 <span class="s3">* Picomatch constants.</span>
 <span class="s3">* </span><span class="s6">@return </span><span class="s3">{Object}</span>
 <span class="s3">*/</span>

<span class="s2">picomatch.constants = constants</span><span class="s1">;</span>

<span class="s3">/**</span>
 <span class="s3">* Expose &quot;picomatch&quot;</span>
 <span class="s3">*/</span>

<span class="s1">var </span><span class="s2">picomatch_1 = picomatch</span><span class="s1">;</span>

<span class="s2">(</span><span class="s1">function </span><span class="s2">(module) {</span>

	<span class="s2">module.exports = picomatch_1</span><span class="s1">;</span>
<span class="s2">} (picomatch$1))</span><span class="s1">;</span>

<span class="s1">var </span><span class="s2">pm = </span><span class="s4">/*@__PURE__*/</span><span class="s2">getDefaultExportFromCjs(picomatchExports)</span><span class="s1">;</span>

<span class="s4">// Helper since Typescript can't detect readonly arrays with Array.isArray</span>
<span class="s1">function </span><span class="s2">isArray(arg) {</span>
    <span class="s1">return </span><span class="s2">Array.isArray(arg)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">ensureArray(thing) {</span>
    <span class="s1">if </span><span class="s2">(isArray(thing))</span>
        <span class="s1">return </span><span class="s2">thing</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(thing == </span><span class="s1">null</span><span class="s2">)</span>
        <span class="s1">return </span><span class="s2">[]</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">[thing]</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s1">const </span><span class="s2">normalizePath$1 = </span><span class="s1">function </span><span class="s2">normalizePath(filename) {</span>
    <span class="s1">return </span><span class="s2">filename.split(require$$0$1.win32.sep).join(require$$0$1.posix.sep)</span><span class="s1">;</span>
<span class="s2">}</span><span class="s1">;</span>

<span class="s1">function </span><span class="s2">getMatcherString(id</span><span class="s1">, </span><span class="s2">resolutionBase) {</span>
    <span class="s1">if </span><span class="s2">(resolutionBase === </span><span class="s1">false </span><span class="s2">|| require$$0$1.isAbsolute(id) || id.startsWith(</span><span class="s0">'*'</span><span class="s2">)) {</span>
        <span class="s1">return </span><span class="s2">normalizePath$1(id)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s4">// resolve('') is valid and will default to process.cwd()</span>
    <span class="s1">const </span><span class="s2">basePath = normalizePath$1(require$$0$1.resolve(resolutionBase || </span><span class="s0">''</span><span class="s2">))</span>
        <span class="s4">// escape all possible (posix + win) path characters that might interfere with regex</span>
        <span class="s2">.replace(</span><span class="s5">/[-^$*+?.()|[\]{}]/g</span><span class="s1">, </span><span class="s0">'</span><span class="s1">\\</span><span class="s0">$&amp;'</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s4">// Note that we use posix.join because:</span>
    <span class="s4">// 1. the basePath has been normalized to use /</span>
    <span class="s4">// 2. the incoming glob (id) matcher, also uses /</span>
    <span class="s4">// otherwise Node will force backslash (\) on windows</span>
    <span class="s1">return </span><span class="s2">require$$0$1.posix.join(basePath</span><span class="s1">, </span><span class="s2">normalizePath$1(id))</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">const </span><span class="s2">createFilter$1 = </span><span class="s1">function </span><span class="s2">createFilter(include</span><span class="s1">, </span><span class="s2">exclude</span><span class="s1">, </span><span class="s2">options) {</span>
    <span class="s1">const </span><span class="s2">resolutionBase = options &amp;&amp; options.resolve</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">getMatcher = (id) =&gt; id </span><span class="s1">instanceof </span><span class="s2">RegExp</span>
        <span class="s2">? id</span>
        <span class="s2">: {</span>
            <span class="s2">test: (what) =&gt; {</span>
                <span class="s4">// this refactor is a tad overly verbose but makes for easy debugging</span>
                <span class="s1">const </span><span class="s2">pattern = getMatcherString(id</span><span class="s1">, </span><span class="s2">resolutionBase)</span><span class="s1">;</span>
                <span class="s1">const </span><span class="s2">fn = pm(pattern</span><span class="s1">, </span><span class="s2">{ dot: </span><span class="s1">true </span><span class="s2">})</span><span class="s1">;</span>
                <span class="s1">const </span><span class="s2">result = fn(what)</span><span class="s1">;</span>
                <span class="s1">return </span><span class="s2">result</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">includeMatchers = ensureArray(include).map(getMatcher)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">excludeMatchers = ensureArray(exclude).map(getMatcher)</span><span class="s1">;</span>
    <span class="s1">return function </span><span class="s2">result(id) {</span>
        <span class="s1">if </span><span class="s2">(</span><span class="s1">typeof </span><span class="s2">id !== </span><span class="s0">'string'</span><span class="s2">)</span>
            <span class="s1">return false;</span>
        <span class="s1">if </span><span class="s2">(</span><span class="s5">/\0/</span><span class="s2">.test(id))</span>
            <span class="s1">return false;</span>
        <span class="s1">const </span><span class="s2">pathId = normalizePath$1(id)</span><span class="s1">;</span>
        <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s5">0</span><span class="s1">; </span><span class="s2">i &lt; excludeMatchers.length</span><span class="s1">; </span><span class="s2">++i) {</span>
            <span class="s1">const </span><span class="s2">matcher = excludeMatchers[i]</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(matcher.test(pathId))</span>
                <span class="s1">return false;</span>
        <span class="s2">}</span>
        <span class="s1">for </span><span class="s2">(</span><span class="s1">let </span><span class="s2">i = </span><span class="s5">0</span><span class="s1">; </span><span class="s2">i &lt; includeMatchers.length</span><span class="s1">; </span><span class="s2">++i) {</span>
            <span class="s1">const </span><span class="s2">matcher = includeMatchers[i]</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(matcher.test(pathId))</span>
                <span class="s1">return true;</span>
        <span class="s2">}</span>
        <span class="s1">return </span><span class="s2">!includeMatchers.length</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span><span class="s1">;</span>

<span class="s1">const </span><span class="s2">reservedWords = </span><span class="s0">'break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield enum await implements package protected static interface private public'</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">builtins = </span><span class="s0">'arguments Infinity NaN undefined null true false eval uneval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Symbol Error EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError Number Math Date String RegExp Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array Map Set WeakMap WeakSet SIMD ArrayBuffer DataView JSON Promise Generator GeneratorFunction Reflect Proxy Intl'</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">forbiddenIdentifiers = </span><span class="s1">new </span><span class="s2">Set(</span><span class="s0">`</span><span class="s2">${reservedWords} ${builtins}</span><span class="s0">`</span><span class="s2">.split(</span><span class="s0">' '</span><span class="s2">))</span><span class="s1">;</span>
<span class="s2">forbiddenIdentifiers.add(</span><span class="s0">''</span><span class="s2">)</span><span class="s1">;</span>

<span class="s1">if </span><span class="s2">(process.versions.pnp) {</span>
    <span class="s1">try </span><span class="s2">{</span>
        <span class="s2">node_module.createRequire((</span><span class="s1">typeof </span><span class="s2">document === </span><span class="s0">'undefined' </span><span class="s2">? require(</span><span class="s0">'u' </span><span class="s2">+ </span><span class="s0">'rl'</span><span class="s2">).pathToFileURL(__filename).href : (document.currentScript &amp;&amp; document.currentScript.src || </span><span class="s1">new </span><span class="s2">URL(</span><span class="s0">'node-cjs/publicUtils.cjs'</span><span class="s1">, </span><span class="s2">document.baseURI).href)))(</span><span class="s0">'pnpapi'</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">catch </span><span class="s2">{ }</span>
<span class="s2">}</span>

<span class="s1">const </span><span class="s2">createFilter = createFilter$1</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">windowsSlashRE = </span><span class="s5">/\\/g</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">slash(p) {</span>
    <span class="s1">return </span><span class="s2">p.replace(windowsSlashRE</span><span class="s1">, </span><span class="s0">'/'</span><span class="s2">)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">isInNodeModules(id) {</span>
    <span class="s1">return </span><span class="s2">id.includes(</span><span class="s0">'node_modules'</span><span class="s2">)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s4">// TODO: use import()</span>
<span class="s1">const </span><span class="s2">_require = node_module.createRequire((</span><span class="s1">typeof </span><span class="s2">document === </span><span class="s0">'undefined' </span><span class="s2">? require(</span><span class="s0">'u' </span><span class="s2">+ </span><span class="s0">'rl'</span><span class="s2">).pathToFileURL(__filename).href : (document.currentScript &amp;&amp; document.currentScript.src || </span><span class="s1">new </span><span class="s2">URL(</span><span class="s0">'node-cjs/publicUtils.cjs'</span><span class="s1">, </span><span class="s2">document.baseURI).href)))</span><span class="s1">;</span>
<span class="s4">// set in bin/vite.js</span>
<span class="s1">const </span><span class="s2">filter = process.env.VITE_DEBUG_FILTER</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">DEBUG = process.env.DEBUG</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">createDebugger(namespace</span><span class="s1">, </span><span class="s2">options = {}) {</span>
    <span class="s1">const </span><span class="s2">log = debug$1(namespace)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">{ onlyWhenFocused } = options</span><span class="s1">;</span>
    <span class="s1">let </span><span class="s2">enabled = log.enabled</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(enabled &amp;&amp; onlyWhenFocused) {</span>
        <span class="s1">const </span><span class="s2">ns = </span><span class="s1">typeof </span><span class="s2">onlyWhenFocused === </span><span class="s0">'string' </span><span class="s2">? onlyWhenFocused : namespace</span><span class="s1">;</span>
        <span class="s2">enabled = !!DEBUG?.includes(ns)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(enabled) {</span>
        <span class="s1">return </span><span class="s2">(...args) =&gt; {</span>
            <span class="s1">if </span><span class="s2">(!filter || args.some((a) =&gt; a?.includes(filter))) {</span>
                <span class="s2">log(...args)</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">testCaseInsensitiveFS() {</span>
    <span class="s1">if </span><span class="s2">(!CLIENT_ENTRY.endsWith(</span><span class="s0">'client.mjs'</span><span class="s2">)) {</span>
        <span class="s1">throw new </span><span class="s2">Error(</span><span class="s0">`cannot test case insensitive FS, CLIENT_ENTRY const doesn't contain client.mjs`</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(!fs$1.existsSync(CLIENT_ENTRY)) {</span>
        <span class="s1">throw new </span><span class="s2">Error(</span><span class="s0">'cannot test case insensitive FS, CLIENT_ENTRY does not point to an existing file: ' </span><span class="s2">+</span>
            <span class="s2">CLIENT_ENTRY)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">fs$1.existsSync(CLIENT_ENTRY.replace(</span><span class="s0">'client.mjs'</span><span class="s1">, </span><span class="s0">'cLiEnT.mjs'</span><span class="s2">))</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">const </span><span class="s2">isCaseInsensitiveFS = testCaseInsensitiveFS()</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">isWindows = os$1.platform() === </span><span class="s0">'win32'</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">VOLUME_RE = </span><span class="s5">/^[A-Z]:/i</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">normalizePath(id) {</span>
    <span class="s1">return </span><span class="s2">path$3.posix.normalize(isWindows ? slash(id) : id)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">fsPathFromId(id) {</span>
    <span class="s1">const </span><span class="s2">fsPath = normalizePath(id.startsWith(FS_PREFIX) ? id.slice(FS_PREFIX.length) : id)</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">fsPath[</span><span class="s5">0</span><span class="s2">] === </span><span class="s0">'/' </span><span class="s2">|| fsPath.match(VOLUME_RE) ? fsPath : </span><span class="s0">`/</span><span class="s2">${fsPath}</span><span class="s0">`</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">fsPathFromUrl(url) {</span>
    <span class="s1">return </span><span class="s2">fsPathFromId(cleanUrl(url))</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s3">/**</span>
 <span class="s3">* Check if dir is a parent of file</span>
 <span class="s3">*</span>
 <span class="s3">* Warning: parameters are not validated, only works with normalized absolute paths</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s6">@param </span><span class="s3">dir - normalized absolute path</span>
 <span class="s3">* </span><span class="s6">@param </span><span class="s3">file - normalized absolute path</span>
 <span class="s3">* </span><span class="s6">@returns </span><span class="s3">true if dir is a parent of file</span>
 <span class="s3">*/</span>
<span class="s1">function </span><span class="s2">isParentDirectory(dir</span><span class="s1">, </span><span class="s2">file) {</span>
    <span class="s1">if </span><span class="s2">(dir[dir.length - </span><span class="s5">1</span><span class="s2">] !== </span><span class="s0">'/'</span><span class="s2">) {</span>
        <span class="s2">dir = </span><span class="s0">`</span><span class="s2">${dir}</span><span class="s0">/`</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">(file.startsWith(dir) ||</span>
        <span class="s2">(isCaseInsensitiveFS &amp;&amp; file.toLowerCase().startsWith(dir.toLowerCase())))</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">const </span><span class="s2">postfixRE = </span><span class="s5">/[?#].*$/s</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">cleanUrl(url) {</span>
    <span class="s1">return </span><span class="s2">url.replace(postfixRE</span><span class="s1">, </span><span class="s0">''</span><span class="s2">)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">isObject(value) {</span>
    <span class="s1">return </span><span class="s2">Object.prototype.toString.call(value) === </span><span class="s0">'[object Object]'</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">tryStatSync(file) {</span>
    <span class="s1">try </span><span class="s2">{</span>
        <span class="s1">return </span><span class="s2">fs$1.statSync(file</span><span class="s1">, </span><span class="s2">{ throwIfNoEntry: </span><span class="s1">false </span><span class="s2">})</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">catch </span><span class="s2">{</span>
        <span class="s4">// Ignore errors</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">isFileReadable(filename) {</span>
    <span class="s1">try </span><span class="s2">{</span>
        <span class="s4">// The &quot;throwIfNoEntry&quot; is a performance optimization for cases where the file does not exist</span>
        <span class="s1">if </span><span class="s2">(!fs$1.statSync(filename</span><span class="s1">, </span><span class="s2">{ throwIfNoEntry: </span><span class="s1">false </span><span class="s2">})) {</span>
            <span class="s1">return false;</span>
        <span class="s2">}</span>
        <span class="s4">// Check if current process has read permission to the file</span>
        <span class="s2">fs$1.accessSync(filename</span><span class="s1">, </span><span class="s2">fs$1.constants.R_OK)</span><span class="s1">;</span>
        <span class="s1">return true;</span>
    <span class="s2">}</span>
    <span class="s1">catch </span><span class="s2">{</span>
        <span class="s1">return false;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">arraify(target) {</span>
    <span class="s1">return </span><span class="s2">Array.isArray(target) ? target : [target]</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s4">// @ts-expect-error jest only exists when running Jest</span>
<span class="s1">const </span><span class="s2">usingDynamicImport = </span><span class="s1">typeof </span><span class="s2">jest === </span><span class="s0">'undefined'</span><span class="s1">;</span>
<span class="s3">/**</span>
 <span class="s3">* Dynamically import files. It will make sure it's not being compiled away by TS/Rollup.</span>
 <span class="s3">*</span>
 <span class="s3">* As a temporary workaround for Jest's lack of stable ESM support, we fallback to require</span>
 <span class="s3">* if we're in a Jest environment.</span>
 <span class="s3">* See https://github.com/vitejs/vite/pull/5197#issuecomment-938054077</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s6">@param </span><span class="s3">file File path to import.</span>
 <span class="s3">*/</span>
<span class="s2">usingDynamicImport</span>
    <span class="s2">? </span><span class="s1">new </span><span class="s2">Function(</span><span class="s0">'file'</span><span class="s1">, </span><span class="s0">'return import(file)'</span><span class="s2">)</span>
    <span class="s2">: _require</span><span class="s1">;</span>
<span class="s2">path$3.dirname(node_url.fileURLToPath((</span><span class="s1">typeof </span><span class="s2">document === </span><span class="s0">'undefined' </span><span class="s2">? require(</span><span class="s0">'u' </span><span class="s2">+ </span><span class="s0">'rl'</span><span class="s2">).pathToFileURL(__filename).href : (document.currentScript &amp;&amp; document.currentScript.src || </span><span class="s1">new </span><span class="s2">URL(</span><span class="s0">'node-cjs/publicUtils.cjs'</span><span class="s1">, </span><span class="s2">document.baseURI).href))))</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">mergeConfigRecursively(defaults</span><span class="s1">, </span><span class="s2">overrides</span><span class="s1">, </span><span class="s2">rootPath) {</span>
    <span class="s1">const </span><span class="s2">merged = { ...defaults }</span><span class="s1">;</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">key </span><span class="s1">in </span><span class="s2">overrides) {</span>
        <span class="s1">const </span><span class="s2">value = overrides[key]</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(value == </span><span class="s1">null</span><span class="s2">) {</span>
            <span class="s1">continue;</span>
        <span class="s2">}</span>
        <span class="s1">const </span><span class="s2">existing = merged[key]</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(existing == </span><span class="s1">null</span><span class="s2">) {</span>
            <span class="s2">merged[key] = value</span><span class="s1">;</span>
            <span class="s1">continue;</span>
        <span class="s2">}</span>
        <span class="s4">// fields that require special handling</span>
        <span class="s1">if </span><span class="s2">(key === </span><span class="s0">'alias' </span><span class="s2">&amp;&amp; (rootPath === </span><span class="s0">'resolve' </span><span class="s2">|| rootPath === </span><span class="s0">''</span><span class="s2">)) {</span>
            <span class="s2">merged[key] = mergeAlias(existing</span><span class="s1">, </span><span class="s2">value)</span><span class="s1">;</span>
            <span class="s1">continue;</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(key === </span><span class="s0">'assetsInclude' </span><span class="s2">&amp;&amp; rootPath === </span><span class="s0">''</span><span class="s2">) {</span>
            <span class="s2">merged[key] = [].concat(existing</span><span class="s1">, </span><span class="s2">value)</span><span class="s1">;</span>
            <span class="s1">continue;</span>
        <span class="s2">}</span>
        <span class="s1">else if </span><span class="s2">(key === </span><span class="s0">'noExternal' </span><span class="s2">&amp;&amp;</span>
            <span class="s2">rootPath === </span><span class="s0">'ssr' </span><span class="s2">&amp;&amp;</span>
            <span class="s2">(existing === </span><span class="s1">true </span><span class="s2">|| value === </span><span class="s1">true</span><span class="s2">)) {</span>
            <span class="s2">merged[key] = </span><span class="s1">true;</span>
            <span class="s1">continue;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(Array.isArray(existing) || Array.isArray(value)) {</span>
            <span class="s2">merged[key] = [...arraify(existing ?? [])</span><span class="s1">, </span><span class="s2">...arraify(value ?? [])]</span><span class="s1">;</span>
            <span class="s1">continue;</span>
        <span class="s2">}</span>
        <span class="s1">if </span><span class="s2">(isObject(existing) &amp;&amp; isObject(value)) {</span>
            <span class="s2">merged[key] = mergeConfigRecursively(existing</span><span class="s1">, </span><span class="s2">value</span><span class="s1">, </span><span class="s2">rootPath ? </span><span class="s0">`</span><span class="s2">${rootPath}</span><span class="s0">.</span><span class="s2">${key}</span><span class="s0">` </span><span class="s2">: key)</span><span class="s1">;</span>
            <span class="s1">continue;</span>
        <span class="s2">}</span>
        <span class="s2">merged[key] = value</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">merged</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">mergeConfig(defaults</span><span class="s1">, </span><span class="s2">overrides</span><span class="s1">, </span><span class="s2">isRoot = </span><span class="s1">true</span><span class="s2">) {</span>
    <span class="s1">return </span><span class="s2">mergeConfigRecursively(defaults</span><span class="s1">, </span><span class="s2">overrides</span><span class="s1">, </span><span class="s2">isRoot ? </span><span class="s0">'' </span><span class="s2">: </span><span class="s0">'.'</span><span class="s2">)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">mergeAlias(a</span><span class="s1">, </span><span class="s2">b) {</span>
    <span class="s1">if </span><span class="s2">(!a)</span>
        <span class="s1">return </span><span class="s2">b</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(!b)</span>
        <span class="s1">return </span><span class="s2">a</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(isObject(a) &amp;&amp; isObject(b)) {</span>
        <span class="s1">return </span><span class="s2">{ ...a</span><span class="s1">, </span><span class="s2">...b }</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s4">// the order is flipped because the alias is resolved from top-down,</span>
    <span class="s4">// where the later should have higher priority</span>
    <span class="s1">return </span><span class="s2">[...normalizeAlias(b)</span><span class="s1">, </span><span class="s2">...normalizeAlias(a)]</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">normalizeAlias(o = []) {</span>
    <span class="s1">return </span><span class="s2">Array.isArray(o)</span>
        <span class="s2">? o.map(normalizeSingleAlias)</span>
        <span class="s2">: Object.keys(o).map((find) =&gt; normalizeSingleAlias({</span>
            <span class="s2">find</span><span class="s1">,</span>
            <span class="s2">replacement: o[find]</span><span class="s1">,</span>
        <span class="s2">}))</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s4">// https://github.com/vitejs/vite/issues/1363</span>
<span class="s4">// work around https://github.com/rollup/plugins/issues/759</span>
<span class="s1">function </span><span class="s2">normalizeSingleAlias({ find</span><span class="s1">, </span><span class="s2">replacement</span><span class="s1">, </span><span class="s2">customResolver</span><span class="s1">, </span><span class="s2">}) {</span>
    <span class="s1">if </span><span class="s2">(</span><span class="s1">typeof </span><span class="s2">find === </span><span class="s0">'string' </span><span class="s2">&amp;&amp;</span>
        <span class="s2">find[find.length - </span><span class="s5">1</span><span class="s2">] === </span><span class="s0">'/' </span><span class="s2">&amp;&amp;</span>
        <span class="s2">replacement[replacement.length - </span><span class="s5">1</span><span class="s2">] === </span><span class="s0">'/'</span><span class="s2">) {</span>
        <span class="s2">find = find.slice(</span><span class="s5">0</span><span class="s1">, </span><span class="s2">find.length - </span><span class="s5">1</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">replacement = replacement.slice(</span><span class="s5">0</span><span class="s1">, </span><span class="s2">replacement.length - </span><span class="s5">1</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">alias = {</span>
        <span class="s2">find</span><span class="s1">,</span>
        <span class="s2">replacement</span><span class="s1">,</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(customResolver) {</span>
        <span class="s2">alias.customResolver = customResolver</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">alias</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s4">// This file will be built for both ESM and CJS. Avoid relying on other modules as possible.</span>
<span class="s4">// copy from constants.ts</span>
<span class="s1">const </span><span class="s2">CSS_LANGS_RE = </span>
<span class="s4">// eslint-disable-next-line regexp/no-unused-capturing-group</span>
<span class="s5">/\.(css|less|sass|scss|styl|stylus|pcss|postcss|sss)(?:$|\?)/</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">isCSSRequest = (request) =&gt; CSS_LANGS_RE.test(request)</span><span class="s1">;</span>
<span class="s4">// Use splitVendorChunkPlugin() to get the same manualChunks strategy as Vite 2.7</span>
<span class="s4">// We don't recommend using this strategy as a general solution moving forward</span>
<span class="s4">// splitVendorChunk is a simple index/vendor strategy that was used in Vite</span>
<span class="s4">// until v2.8. It is exposed to let people continue to use it in case it was</span>
<span class="s4">// working well for their setups.</span>
<span class="s4">// The cache needs to be reset on buildStart for watch mode to work correctly</span>
<span class="s4">// Don't use this manualChunks strategy for ssr, lib mode, and 'umd' or 'iife'</span>
<span class="s1">class </span><span class="s2">SplitVendorChunkCache {</span>
    <span class="s2">constructor() {</span>
        <span class="s1">this</span><span class="s2">.cache = </span><span class="s1">new </span><span class="s2">Map()</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s2">reset() {</span>
        <span class="s1">this</span><span class="s2">.cache = </span><span class="s1">new </span><span class="s2">Map()</span><span class="s1">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">splitVendorChunk(options = {}) {</span>
    <span class="s1">const </span><span class="s2">cache = options.cache ?? </span><span class="s1">new </span><span class="s2">SplitVendorChunkCache()</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">(id</span><span class="s1">, </span><span class="s2">{ getModuleInfo }) =&gt; {</span>
        <span class="s1">if </span><span class="s2">(isInNodeModules(id) &amp;&amp;</span>
            <span class="s2">!isCSSRequest(id) &amp;&amp;</span>
            <span class="s2">staticImportedByEntry(id</span><span class="s1">, </span><span class="s2">getModuleInfo</span><span class="s1">, </span><span class="s2">cache.cache)) {</span>
            <span class="s1">return </span><span class="s0">'vendor'</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">staticImportedByEntry(id</span><span class="s1">, </span><span class="s2">getModuleInfo</span><span class="s1">, </span><span class="s2">cache</span><span class="s1">, </span><span class="s2">importStack = []) {</span>
    <span class="s1">if </span><span class="s2">(cache.has(id)) {</span>
        <span class="s1">return </span><span class="s2">cache.get(id)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(importStack.includes(id)) {</span>
        <span class="s4">// circular deps!</span>
        <span class="s2">cache.set(id</span><span class="s1">, false</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s1">return false;</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">mod = getModuleInfo(id)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(!mod) {</span>
        <span class="s2">cache.set(id</span><span class="s1">, false</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s1">return false;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(mod.isEntry) {</span>
        <span class="s2">cache.set(id</span><span class="s1">, true</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s1">return true;</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">someImporterIs = mod.importers.some((importer) =&gt; staticImportedByEntry(importer</span><span class="s1">, </span><span class="s2">getModuleInfo</span><span class="s1">, </span><span class="s2">cache</span><span class="s1">, </span><span class="s2">importStack.concat(id)))</span><span class="s1">;</span>
    <span class="s2">cache.set(id</span><span class="s1">, </span><span class="s2">someImporterIs)</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">someImporterIs</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">splitVendorChunkPlugin() {</span>
    <span class="s1">const </span><span class="s2">caches = []</span><span class="s1">;</span>
    <span class="s1">function </span><span class="s2">createSplitVendorChunk(output</span><span class="s1">, </span><span class="s2">config) {</span>
        <span class="s1">const </span><span class="s2">cache = </span><span class="s1">new </span><span class="s2">SplitVendorChunkCache()</span><span class="s1">;</span>
        <span class="s2">caches.push(cache)</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">build = config.build ?? {}</span><span class="s1">;</span>
        <span class="s1">const </span><span class="s2">format = output?.format</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(!build.ssr &amp;&amp; !build.lib &amp;&amp; format !== </span><span class="s0">'umd' </span><span class="s2">&amp;&amp; format !== </span><span class="s0">'iife'</span><span class="s2">) {</span>
            <span class="s1">return </span><span class="s2">splitVendorChunk({ cache })</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">{</span>
        <span class="s2">name: </span><span class="s0">'vite:split-vendor-chunk'</span><span class="s1">,</span>
        <span class="s2">config(config) {</span>
            <span class="s1">let </span><span class="s2">outputs = config?.build?.rollupOptions?.output</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(outputs) {</span>
                <span class="s2">outputs = Array.isArray(outputs) ? outputs : [outputs]</span><span class="s1">;</span>
                <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">output of outputs) {</span>
                    <span class="s1">const </span><span class="s2">viteManualChunks = createSplitVendorChunk(output</span><span class="s1">, </span><span class="s2">config)</span><span class="s1">;</span>
                    <span class="s1">if </span><span class="s2">(viteManualChunks) {</span>
                        <span class="s1">if </span><span class="s2">(output.manualChunks) {</span>
                            <span class="s1">if </span><span class="s2">(</span><span class="s1">typeof </span><span class="s2">output.manualChunks === </span><span class="s0">'function'</span><span class="s2">) {</span>
                                <span class="s1">const </span><span class="s2">userManualChunks = output.manualChunks</span><span class="s1">;</span>
                                <span class="s2">output.manualChunks = (id</span><span class="s1">, </span><span class="s2">api) =&gt; {</span>
                                    <span class="s1">return </span><span class="s2">userManualChunks(id</span><span class="s1">, </span><span class="s2">api) ?? viteManualChunks(id</span><span class="s1">, </span><span class="s2">api)</span><span class="s1">;</span>
                                <span class="s2">}</span><span class="s1">;</span>
                            <span class="s2">}</span>
                            <span class="s4">// else, leave the object form of manualChunks untouched, as</span>
                            <span class="s4">// we can't safely replicate rollup handling.</span>
                        <span class="s2">}</span>
                        <span class="s1">else </span><span class="s2">{</span>
                            <span class="s2">output.manualChunks = viteManualChunks</span><span class="s1">;</span>
                        <span class="s2">}</span>
                    <span class="s2">}</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s1">return </span><span class="s2">{</span>
                    <span class="s2">build: {</span>
                        <span class="s2">rollupOptions: {</span>
                            <span class="s2">output: {</span>
                                <span class="s2">manualChunks: createSplitVendorChunk({}</span><span class="s1">, </span><span class="s2">config)</span><span class="s1">,</span>
                            <span class="s2">}</span><span class="s1">,</span>
                        <span class="s2">}</span><span class="s1">,</span>
                    <span class="s2">}</span><span class="s1">,</span>
                <span class="s2">}</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span><span class="s1">,</span>
        <span class="s2">buildStart() {</span>
            <span class="s2">caches.forEach((cache) =&gt; cache.reset())</span><span class="s1">;</span>
        <span class="s2">}</span><span class="s1">,</span>
    <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s4">/*! 
 * etag 
 * Copyright(c) 2014-2016 Douglas Christopher Wilson 
 * MIT Licensed 
 */</span>

<span class="s3">/**</span>
 <span class="s3">* Module exports.</span>
 <span class="s3">* </span><span class="s6">@public</span>
 <span class="s3">*/</span>

<span class="s1">var </span><span class="s2">etag_1 = etag</span><span class="s1">;</span>

<span class="s3">/**</span>
 <span class="s3">* Module dependencies.</span>
 <span class="s3">* </span><span class="s6">@private</span>
 <span class="s3">*/</span>

<span class="s1">var </span><span class="s2">crypto = require$$0$2</span><span class="s1">;</span>
<span class="s1">var </span><span class="s2">Stats = fs$2.Stats</span><span class="s1">;</span>

<span class="s3">/**</span>
 <span class="s3">* Module variables.</span>
 <span class="s3">* </span><span class="s6">@private</span>
 <span class="s3">*/</span>

<span class="s1">var </span><span class="s2">toString = Object.prototype.toString</span><span class="s1">;</span>

<span class="s3">/**</span>
 <span class="s3">* Generate an entity tag.</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s6">@param </span><span class="s3">{Buffer|string} entity</span>
 <span class="s3">* </span><span class="s6">@return </span><span class="s3">{string}</span>
 <span class="s3">* </span><span class="s6">@private</span>
 <span class="s3">*/</span>

<span class="s1">function </span><span class="s2">entitytag (entity) {</span>
  <span class="s1">if </span><span class="s2">(entity.length === </span><span class="s5">0</span><span class="s2">) {</span>
    <span class="s4">// fast-path empty</span>
    <span class="s1">return </span><span class="s0">'&quot;0-2jmj7l5rSw0yVb/vlWAYkK/YBwk&quot;'</span>
  <span class="s2">}</span>

  <span class="s4">// compute hash of entity</span>
  <span class="s1">var </span><span class="s2">hash = crypto</span>
    <span class="s2">.createHash(</span><span class="s0">'sha1'</span><span class="s2">)</span>
    <span class="s2">.update(entity</span><span class="s1">, </span><span class="s0">'utf8'</span><span class="s2">)</span>
    <span class="s2">.digest(</span><span class="s0">'base64'</span><span class="s2">)</span>
    <span class="s2">.substring(</span><span class="s5">0</span><span class="s1">, </span><span class="s5">27</span><span class="s2">)</span><span class="s1">;</span>

  <span class="s4">// compute length of entity</span>
  <span class="s1">var </span><span class="s2">len = </span><span class="s1">typeof </span><span class="s2">entity === </span><span class="s0">'string'</span>
    <span class="s2">? Buffer.byteLength(entity</span><span class="s1">, </span><span class="s0">'utf8'</span><span class="s2">)</span>
    <span class="s2">: entity.length</span><span class="s1">;</span>

  <span class="s1">return </span><span class="s0">'&quot;' </span><span class="s2">+ len.toString(</span><span class="s5">16</span><span class="s2">) + </span><span class="s0">'-' </span><span class="s2">+ hash + </span><span class="s0">'&quot;'</span>
<span class="s2">}</span>

<span class="s3">/**</span>
 <span class="s3">* Create a simple ETag.</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s6">@param </span><span class="s3">{string|Buffer|Stats} entity</span>
 <span class="s3">* </span><span class="s6">@param </span><span class="s3">{object} [options]</span>
 <span class="s3">* </span><span class="s6">@param </span><span class="s3">{boolean} [options.weak]</span>
 <span class="s3">* </span><span class="s6">@return </span><span class="s3">{String}</span>
 <span class="s3">* </span><span class="s6">@public</span>
 <span class="s3">*/</span>

<span class="s1">function </span><span class="s2">etag (entity</span><span class="s1">, </span><span class="s2">options) {</span>
  <span class="s1">if </span><span class="s2">(entity == </span><span class="s1">null</span><span class="s2">) {</span>
    <span class="s1">throw new </span><span class="s2">TypeError(</span><span class="s0">'argument entity is required'</span><span class="s2">)</span>
  <span class="s2">}</span>

  <span class="s4">// support fs.Stats object</span>
  <span class="s1">var </span><span class="s2">isStats = isstats(entity)</span><span class="s1">;</span>
  <span class="s1">var </span><span class="s2">weak = options &amp;&amp; </span><span class="s1">typeof </span><span class="s2">options.weak === </span><span class="s0">'boolean'</span>
    <span class="s2">? options.weak</span>
    <span class="s2">: isStats</span><span class="s1">;</span>

  <span class="s4">// validate argument</span>
  <span class="s1">if </span><span class="s2">(!isStats &amp;&amp; </span><span class="s1">typeof </span><span class="s2">entity !== </span><span class="s0">'string' </span><span class="s2">&amp;&amp; !Buffer.isBuffer(entity)) {</span>
    <span class="s1">throw new </span><span class="s2">TypeError(</span><span class="s0">'argument entity must be string, Buffer, or fs.Stats'</span><span class="s2">)</span>
  <span class="s2">}</span>

  <span class="s4">// generate entity tag</span>
  <span class="s1">var </span><span class="s2">tag = isStats</span>
    <span class="s2">? stattag(entity)</span>
    <span class="s2">: entitytag(entity)</span><span class="s1">;</span>

  <span class="s1">return </span><span class="s2">weak</span>
    <span class="s2">? </span><span class="s0">'W/' </span><span class="s2">+ tag</span>
    <span class="s2">: tag</span>
<span class="s2">}</span>

<span class="s3">/**</span>
 <span class="s3">* Determine if object is a Stats object.</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s6">@param </span><span class="s3">{object} obj</span>
 <span class="s3">* </span><span class="s6">@return </span><span class="s3">{boolean}</span>
 <span class="s3">* </span><span class="s6">@api </span><span class="s3">private</span>
 <span class="s3">*/</span>

<span class="s1">function </span><span class="s2">isstats (obj) {</span>
  <span class="s4">// genuine fs.Stats</span>
  <span class="s1">if </span><span class="s2">(</span><span class="s1">typeof </span><span class="s2">Stats === </span><span class="s0">'function' </span><span class="s2">&amp;&amp; obj </span><span class="s1">instanceof </span><span class="s2">Stats) {</span>
    <span class="s1">return true</span>
  <span class="s2">}</span>

  <span class="s4">// quack quack</span>
  <span class="s1">return </span><span class="s2">obj &amp;&amp; </span><span class="s1">typeof </span><span class="s2">obj === </span><span class="s0">'object' </span><span class="s2">&amp;&amp;</span>
    <span class="s0">'ctime' </span><span class="s1">in </span><span class="s2">obj &amp;&amp; toString.call(obj.ctime) === </span><span class="s0">'[object Date]' </span><span class="s2">&amp;&amp;</span>
    <span class="s0">'mtime' </span><span class="s1">in </span><span class="s2">obj &amp;&amp; toString.call(obj.mtime) === </span><span class="s0">'[object Date]' </span><span class="s2">&amp;&amp;</span>
    <span class="s0">'ino' </span><span class="s1">in </span><span class="s2">obj &amp;&amp; </span><span class="s1">typeof </span><span class="s2">obj.ino === </span><span class="s0">'number' </span><span class="s2">&amp;&amp;</span>
    <span class="s0">'size' </span><span class="s1">in </span><span class="s2">obj &amp;&amp; </span><span class="s1">typeof </span><span class="s2">obj.size === </span><span class="s0">'number'</span>
<span class="s2">}</span>

<span class="s3">/**</span>
 <span class="s3">* Generate a tag for a stat.</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s6">@param </span><span class="s3">{object} stat</span>
 <span class="s3">* </span><span class="s6">@return </span><span class="s3">{string}</span>
 <span class="s3">* </span><span class="s6">@private</span>
 <span class="s3">*/</span>

<span class="s1">function </span><span class="s2">stattag (stat) {</span>
  <span class="s1">var </span><span class="s2">mtime = stat.mtime.getTime().toString(</span><span class="s5">16</span><span class="s2">)</span><span class="s1">;</span>
  <span class="s1">var </span><span class="s2">size = stat.size.toString(</span><span class="s5">16</span><span class="s2">)</span><span class="s1">;</span>

  <span class="s1">return </span><span class="s0">'&quot;' </span><span class="s2">+ size + </span><span class="s0">'-' </span><span class="s2">+ mtime + </span><span class="s0">'&quot;'</span>
<span class="s2">}</span>

<span class="s1">const </span><span class="s2">debug = createDebugger(</span><span class="s0">'vite:sourcemap'</span><span class="s1">, </span><span class="s2">{</span>
    <span class="s2">onlyWhenFocused: </span><span class="s1">true,</span>
<span class="s2">})</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">genSourceMapUrl(map) {</span>
    <span class="s1">if </span><span class="s2">(</span><span class="s1">typeof </span><span class="s2">map !== </span><span class="s0">'string'</span><span class="s2">) {</span>
        <span class="s2">map = JSON.stringify(map)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s0">`data:application/json;base64,</span><span class="s2">${Buffer.from(map).toString(</span><span class="s0">'base64'</span><span class="s2">)}</span><span class="s0">`</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">getCodeWithSourcemap(type</span><span class="s1">, </span><span class="s2">code</span><span class="s1">, </span><span class="s2">map) {</span>
    <span class="s1">if </span><span class="s2">(debug) {</span>
        <span class="s2">code += </span><span class="s0">`</span><span class="s1">\n</span><span class="s0">/*</span><span class="s2">${JSON.stringify(map</span><span class="s1">, null, </span><span class="s5">2</span><span class="s2">).replace(</span><span class="s5">/\*\//g</span><span class="s1">, </span><span class="s0">'*</span><span class="s1">\\</span><span class="s0">/'</span><span class="s2">)}</span><span class="s0">*/</span><span class="s1">\n</span><span class="s0">`</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(type === </span><span class="s0">'js'</span><span class="s2">) {</span>
        <span class="s2">code += </span><span class="s0">`</span><span class="s1">\n</span><span class="s0">//# sourceMappingURL=</span><span class="s2">${genSourceMapUrl(map)}</span><span class="s0">`</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">else if </span><span class="s2">(type === </span><span class="s0">'css'</span><span class="s2">) {</span>
        <span class="s2">code += </span><span class="s0">`</span><span class="s1">\n</span><span class="s0">/*# sourceMappingURL=</span><span class="s2">${genSourceMapUrl(map)} </span><span class="s0">*/`</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">code</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s1">const </span><span class="s2">alias = {</span>
    <span class="s2">js: </span><span class="s0">'application/javascript'</span><span class="s1">,</span>
    <span class="s2">css: </span><span class="s0">'text/css'</span><span class="s1">,</span>
    <span class="s2">html: </span><span class="s0">'text/html'</span><span class="s1">,</span>
    <span class="s2">json: </span><span class="s0">'application/json'</span><span class="s1">,</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">send(req</span><span class="s1">, </span><span class="s2">res</span><span class="s1">, </span><span class="s2">content</span><span class="s1">, </span><span class="s2">type</span><span class="s1">, </span><span class="s2">options) {</span>
    <span class="s1">const </span><span class="s2">{ etag = etag_1(content</span><span class="s1">, </span><span class="s2">{ weak: </span><span class="s1">true </span><span class="s2">})</span><span class="s1">, </span><span class="s2">cacheControl = </span><span class="s0">'no-cache'</span><span class="s1">, </span><span class="s2">headers</span><span class="s1">, </span><span class="s2">map</span><span class="s1">, </span><span class="s2">} = options</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(res.writableEnded) {</span>
        <span class="s1">return;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(req.headers[</span><span class="s0">'if-none-match'</span><span class="s2">] === etag) {</span>
        <span class="s2">res.statusCode = </span><span class="s5">304</span><span class="s1">;</span>
        <span class="s2">res.end()</span><span class="s1">;</span>
        <span class="s1">return;</span>
    <span class="s2">}</span>
    <span class="s2">res.setHeader(</span><span class="s0">'Content-Type'</span><span class="s1">, </span><span class="s2">alias[type] || type)</span><span class="s1">;</span>
    <span class="s2">res.setHeader(</span><span class="s0">'Cache-Control'</span><span class="s1">, </span><span class="s2">cacheControl)</span><span class="s1">;</span>
    <span class="s2">res.setHeader(</span><span class="s0">'Etag'</span><span class="s1">, </span><span class="s2">etag)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(headers) {</span>
        <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">name </span><span class="s1">in </span><span class="s2">headers) {</span>
            <span class="s2">res.setHeader(name</span><span class="s1">, </span><span class="s2">headers[name])</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s4">// inject source map reference</span>
    <span class="s1">if </span><span class="s2">(map &amp;&amp; map.mappings) {</span>
        <span class="s1">if </span><span class="s2">(type === </span><span class="s0">'js' </span><span class="s2">|| type === </span><span class="s0">'css'</span><span class="s2">) {</span>
            <span class="s2">content = getCodeWithSourcemap(type</span><span class="s1">, </span><span class="s2">content.toString()</span><span class="s1">, </span><span class="s2">map)</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s2">res.statusCode = </span><span class="s5">200</span><span class="s1">;</span>
    <span class="s2">res.end(content)</span><span class="s1">;</span>
    <span class="s1">return;</span>
<span class="s2">}</span>

<span class="s4">/* eslint no-console: 0 */</span>
<span class="s1">const </span><span class="s2">LogLevels = {</span>
    <span class="s2">silent: </span><span class="s5">0</span><span class="s1">,</span>
    <span class="s2">error: </span><span class="s5">1</span><span class="s1">,</span>
    <span class="s2">warn: </span><span class="s5">2</span><span class="s1">,</span>
    <span class="s2">info: </span><span class="s5">3</span><span class="s1">,</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s1">let </span><span class="s2">lastType</span><span class="s1">;</span>
<span class="s1">let </span><span class="s2">lastMsg</span><span class="s1">;</span>
<span class="s1">let </span><span class="s2">sameCount = </span><span class="s5">0</span><span class="s1">;</span>
<span class="s1">function </span><span class="s2">clearScreen() {</span>
    <span class="s1">const </span><span class="s2">repeatCount = process.stdout.rows - </span><span class="s5">2</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">blank = repeatCount &gt; </span><span class="s5">0 </span><span class="s2">? </span><span class="s0">'</span><span class="s1">\n</span><span class="s0">'</span><span class="s2">.repeat(repeatCount) : </span><span class="s0">''</span><span class="s1">;</span>
    <span class="s2">console.log(blank)</span><span class="s1">;</span>
    <span class="s2">readline.cursorTo(process.stdout</span><span class="s1">, </span><span class="s5">0</span><span class="s1">, </span><span class="s5">0</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">readline.clearScreenDown(process.stdout)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">createLogger(level = </span><span class="s0">'info'</span><span class="s1">, </span><span class="s2">options = {}) {</span>
    <span class="s1">if </span><span class="s2">(options.customLogger) {</span>
        <span class="s1">return </span><span class="s2">options.customLogger</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">loggedErrors = </span><span class="s1">new </span><span class="s2">WeakSet()</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">{ prefix = </span><span class="s0">'[vite]'</span><span class="s1">, </span><span class="s2">allowClearScreen = </span><span class="s1">true </span><span class="s2">} = options</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">thresh = LogLevels[level]</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">canClearScreen = allowClearScreen &amp;&amp; process.stdout.isTTY &amp;&amp; !process.env.CI</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">clear = canClearScreen ? clearScreen : () =&gt; { }</span><span class="s1">;</span>
    <span class="s1">function </span><span class="s2">output(type</span><span class="s1">, </span><span class="s2">msg</span><span class="s1">, </span><span class="s2">options = {}) {</span>
        <span class="s1">if </span><span class="s2">(thresh &gt;= LogLevels[type]) {</span>
            <span class="s1">const </span><span class="s2">method = type === </span><span class="s0">'info' </span><span class="s2">? </span><span class="s0">'log' </span><span class="s2">: type</span><span class="s1">;</span>
            <span class="s1">const </span><span class="s2">format = () =&gt; {</span>
                <span class="s1">if </span><span class="s2">(options.timestamp) {</span>
                    <span class="s1">const </span><span class="s2">tag = type === </span><span class="s0">'info'</span>
                        <span class="s2">? picocolorsExports.cyan(picocolorsExports.bold(prefix))</span>
                        <span class="s2">: type === </span><span class="s0">'warn'</span>
                            <span class="s2">? picocolorsExports.yellow(picocolorsExports.bold(prefix))</span>
                            <span class="s2">: picocolorsExports.red(picocolorsExports.bold(prefix))</span><span class="s1">;</span>
                    <span class="s1">return </span><span class="s0">`</span><span class="s2">${picocolorsExports.dim(</span><span class="s1">new </span><span class="s2">Date().toLocaleTimeString())} ${tag} ${msg}</span><span class="s0">`</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s1">return </span><span class="s2">msg</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span><span class="s1">;</span>
            <span class="s1">if </span><span class="s2">(options.error) {</span>
                <span class="s2">loggedErrors.add(options.error)</span><span class="s1">;</span>
            <span class="s2">}</span>
            <span class="s1">if </span><span class="s2">(canClearScreen) {</span>
                <span class="s1">if </span><span class="s2">(type === lastType &amp;&amp; msg === lastMsg) {</span>
                    <span class="s2">sameCount++</span><span class="s1">;</span>
                    <span class="s2">clear()</span><span class="s1">;</span>
                    <span class="s2">console[method](format()</span><span class="s1">, </span><span class="s2">picocolorsExports.yellow(</span><span class="s0">`(x</span><span class="s2">${sameCount + </span><span class="s5">1</span><span class="s2">}</span><span class="s0">)`</span><span class="s2">))</span><span class="s1">;</span>
                <span class="s2">}</span>
                <span class="s1">else </span><span class="s2">{</span>
                    <span class="s2">sameCount = </span><span class="s5">0</span><span class="s1">;</span>
                    <span class="s2">lastMsg = msg</span><span class="s1">;</span>
                    <span class="s2">lastType = type</span><span class="s1">;</span>
                    <span class="s1">if </span><span class="s2">(options.clear) {</span>
                        <span class="s2">clear()</span><span class="s1">;</span>
                    <span class="s2">}</span>
                    <span class="s2">console[method](format())</span><span class="s1">;</span>
                <span class="s2">}</span>
            <span class="s2">}</span>
            <span class="s1">else </span><span class="s2">{</span>
                <span class="s2">console[method](format())</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">warnedMessages = </span><span class="s1">new </span><span class="s2">Set()</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">logger = {</span>
        <span class="s2">hasWarned: </span><span class="s1">false,</span>
        <span class="s2">info(msg</span><span class="s1">, </span><span class="s2">opts) {</span>
            <span class="s2">output(</span><span class="s0">'info'</span><span class="s1">, </span><span class="s2">msg</span><span class="s1">, </span><span class="s2">opts)</span><span class="s1">;</span>
        <span class="s2">}</span><span class="s1">,</span>
        <span class="s2">warn(msg</span><span class="s1">, </span><span class="s2">opts) {</span>
            <span class="s2">logger.hasWarned = </span><span class="s1">true;</span>
            <span class="s2">output(</span><span class="s0">'warn'</span><span class="s1">, </span><span class="s2">msg</span><span class="s1">, </span><span class="s2">opts)</span><span class="s1">;</span>
        <span class="s2">}</span><span class="s1">,</span>
        <span class="s2">warnOnce(msg</span><span class="s1">, </span><span class="s2">opts) {</span>
            <span class="s1">if </span><span class="s2">(warnedMessages.has(msg))</span>
                <span class="s1">return;</span>
            <span class="s2">logger.hasWarned = </span><span class="s1">true;</span>
            <span class="s2">output(</span><span class="s0">'warn'</span><span class="s1">, </span><span class="s2">msg</span><span class="s1">, </span><span class="s2">opts)</span><span class="s1">;</span>
            <span class="s2">warnedMessages.add(msg)</span><span class="s1">;</span>
        <span class="s2">}</span><span class="s1">,</span>
        <span class="s2">error(msg</span><span class="s1">, </span><span class="s2">opts) {</span>
            <span class="s2">logger.hasWarned = </span><span class="s1">true;</span>
            <span class="s2">output(</span><span class="s0">'error'</span><span class="s1">, </span><span class="s2">msg</span><span class="s1">, </span><span class="s2">opts)</span><span class="s1">;</span>
        <span class="s2">}</span><span class="s1">,</span>
        <span class="s2">clearScreen(type) {</span>
            <span class="s1">if </span><span class="s2">(thresh &gt;= LogLevels[type]) {</span>
                <span class="s2">clear()</span><span class="s1">;</span>
            <span class="s2">}</span>
        <span class="s2">}</span><span class="s1">,</span>
        <span class="s2">hasErrorLogged(error) {</span>
            <span class="s1">return </span><span class="s2">loggedErrors.has(error)</span><span class="s1">;</span>
        <span class="s2">}</span><span class="s1">,</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">logger</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s4">// https://github.com/vitejs/vite/issues/2820#issuecomment-812495079</span>
<span class="s1">const </span><span class="s2">ROOT_FILES = [</span>
    <span class="s4">// '.git',</span>
    <span class="s4">// https://pnpm.io/workspaces/</span>
    <span class="s0">'pnpm-workspace.yaml'</span><span class="s1">,</span>
    <span class="s4">// https://rushjs.io/pages/advanced/config_files/</span>
    <span class="s4">// 'rush.json',</span>
    <span class="s4">// https://nx.dev/latest/react/getting-started/nx-setup</span>
    <span class="s4">// 'workspace.json',</span>
    <span class="s4">// 'nx.json',</span>
    <span class="s4">// https://github.com/lerna/lerna#lernajson</span>
    <span class="s0">'lerna.json'</span><span class="s1">,</span>
<span class="s2">]</span><span class="s1">;</span>
<span class="s4">// npm: https://docs.npmjs.com/cli/v7/using-npm/workspaces#installing-workspaces</span>
<span class="s4">// yarn: https://classic.yarnpkg.com/en/docs/workspaces/#toc-how-to-use-it</span>
<span class="s1">function </span><span class="s2">hasWorkspacePackageJSON(root) {</span>
    <span class="s1">const </span><span class="s2">path = path$3.join(root</span><span class="s1">, </span><span class="s0">'package.json'</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(!isFileReadable(path)) {</span>
        <span class="s1">return false;</span>
    <span class="s2">}</span>
    <span class="s1">const </span><span class="s2">content = JSON.parse(fs$1.readFileSync(path</span><span class="s1">, </span><span class="s0">'utf-8'</span><span class="s2">)) || {}</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">!!content.workspaces</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">hasRootFile(root) {</span>
    <span class="s1">return </span><span class="s2">ROOT_FILES.some((file) =&gt; fs$1.existsSync(path$3.join(root</span><span class="s1">, </span><span class="s2">file)))</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">hasPackageJSON(root) {</span>
    <span class="s1">const </span><span class="s2">path = path$3.join(root</span><span class="s1">, </span><span class="s0">'package.json'</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">fs$1.existsSync(path)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s3">/**</span>
 <span class="s3">* Search up for the nearest `package.json`</span>
 <span class="s3">*/</span>
<span class="s1">function </span><span class="s2">searchForPackageRoot(current</span><span class="s1">, </span><span class="s2">root = current) {</span>
    <span class="s1">if </span><span class="s2">(hasPackageJSON(current))</span>
        <span class="s1">return </span><span class="s2">current</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">dir = path$3.dirname(current)</span><span class="s1">;</span>
    <span class="s4">// reach the fs root</span>
    <span class="s1">if </span><span class="s2">(!dir || dir === current)</span>
        <span class="s1">return </span><span class="s2">root</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">searchForPackageRoot(dir</span><span class="s1">, </span><span class="s2">root)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s3">/**</span>
 <span class="s3">* Search up for the nearest workspace root</span>
 <span class="s3">*/</span>
<span class="s1">function </span><span class="s2">searchForWorkspaceRoot(current</span><span class="s1">, </span><span class="s2">root = searchForPackageRoot(current)) {</span>
    <span class="s1">if </span><span class="s2">(hasRootFile(current))</span>
        <span class="s1">return </span><span class="s2">current</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(hasWorkspacePackageJSON(current))</span>
        <span class="s1">return </span><span class="s2">current</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">dir = path$3.dirname(current)</span><span class="s1">;</span>
    <span class="s4">// reach the fs root</span>
    <span class="s1">if </span><span class="s2">(!dir || dir === current)</span>
        <span class="s1">return </span><span class="s2">root</span><span class="s1">;</span>
    <span class="s1">return </span><span class="s2">searchForWorkspaceRoot(dir</span><span class="s1">, </span><span class="s2">root)</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s3">/**</span>
 <span class="s3">* Check if the url is allowed to be served, via the `server.fs` config.</span>
 <span class="s3">*/</span>
<span class="s1">function </span><span class="s2">isFileServingAllowed(url</span><span class="s1">, </span><span class="s2">server) {</span>
    <span class="s1">if </span><span class="s2">(!server.config.server.fs.strict)</span>
        <span class="s1">return true;</span>
    <span class="s1">const </span><span class="s2">file = fsPathFromUrl(url)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(server._fsDenyGlob(file))</span>
        <span class="s1">return false;</span>
    <span class="s1">if </span><span class="s2">(server.moduleGraph.safeModulesPath.has(file))</span>
        <span class="s1">return true;</span>
    <span class="s1">if </span><span class="s2">(server.config.server.fs.allow.some((dir) =&gt; isParentDirectory(dir</span><span class="s1">, </span><span class="s2">file)))</span>
        <span class="s1">return true;</span>
    <span class="s1">return false;</span>
<span class="s2">}</span>

<span class="s1">var </span><span class="s2">mainExports = {}</span><span class="s1">;</span>
<span class="s1">var </span><span class="s2">main$1 = {</span>
  <span class="s2">get exports(){ </span><span class="s1">return </span><span class="s2">mainExports</span><span class="s1">; </span><span class="s2">}</span><span class="s1">,</span>
  <span class="s2">set exports(v){ mainExports = v</span><span class="s1">; </span><span class="s2">}</span><span class="s1">,</span>
<span class="s2">}</span><span class="s1">;</span>

<span class="s1">var </span><span class="s2">name = </span><span class="s0">&quot;dotenv&quot;</span><span class="s1">;</span>
<span class="s1">var </span><span class="s2">version$1 = </span><span class="s0">&quot;16.0.3&quot;</span><span class="s1">;</span>
<span class="s1">var </span><span class="s2">description = </span><span class="s0">&quot;Loads environment variables from .env file&quot;</span><span class="s1">;</span>
<span class="s1">var </span><span class="s2">main = </span><span class="s0">&quot;lib/main.js&quot;</span><span class="s1">;</span>
<span class="s1">var </span><span class="s2">types = </span><span class="s0">&quot;lib/main.d.ts&quot;</span><span class="s1">;</span>
<span class="s1">var </span><span class="s2">exports$1 = {</span>
	<span class="s0">&quot;.&quot;</span><span class="s2">: {</span>
		<span class="s2">require: </span><span class="s0">&quot;./lib/main.js&quot;</span><span class="s1">,</span>
		<span class="s2">types: </span><span class="s0">&quot;./lib/main.d.ts&quot;</span><span class="s1">,</span>
		<span class="s0">&quot;default&quot;</span><span class="s2">: </span><span class="s0">&quot;./lib/main.js&quot;</span>
	<span class="s2">}</span><span class="s1">,</span>
	<span class="s0">&quot;./config&quot;</span><span class="s2">: </span><span class="s0">&quot;./config.js&quot;</span><span class="s1">,</span>
	<span class="s0">&quot;./config.js&quot;</span><span class="s2">: </span><span class="s0">&quot;./config.js&quot;</span><span class="s1">,</span>
	<span class="s0">&quot;./lib/env-options&quot;</span><span class="s2">: </span><span class="s0">&quot;./lib/env-options.js&quot;</span><span class="s1">,</span>
	<span class="s0">&quot;./lib/env-options.js&quot;</span><span class="s2">: </span><span class="s0">&quot;./lib/env-options.js&quot;</span><span class="s1">,</span>
	<span class="s0">&quot;./lib/cli-options&quot;</span><span class="s2">: </span><span class="s0">&quot;./lib/cli-options.js&quot;</span><span class="s1">,</span>
	<span class="s0">&quot;./lib/cli-options.js&quot;</span><span class="s2">: </span><span class="s0">&quot;./lib/cli-options.js&quot;</span><span class="s1">,</span>
	<span class="s0">&quot;./package.json&quot;</span><span class="s2">: </span><span class="s0">&quot;./package.json&quot;</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s1">var </span><span class="s2">scripts = {</span>
	<span class="s0">&quot;dts-check&quot;</span><span class="s2">: </span><span class="s0">&quot;tsc --project tests/types/tsconfig.json&quot;</span><span class="s1">,</span>
	<span class="s2">lint: </span><span class="s0">&quot;standard&quot;</span><span class="s1">,</span>
	<span class="s0">&quot;lint-readme&quot;</span><span class="s2">: </span><span class="s0">&quot;standard-markdown&quot;</span><span class="s1">,</span>
	<span class="s2">pretest: </span><span class="s0">&quot;npm run lint &amp;&amp; npm run dts-check&quot;</span><span class="s1">,</span>
	<span class="s2">test: </span><span class="s0">&quot;tap tests/*.js --100 -Rspec&quot;</span><span class="s1">,</span>
	<span class="s2">prerelease: </span><span class="s0">&quot;npm test&quot;</span><span class="s1">,</span>
	<span class="s2">release: </span><span class="s0">&quot;standard-version&quot;</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s1">var </span><span class="s2">repository = {</span>
	<span class="s2">type: </span><span class="s0">&quot;git&quot;</span><span class="s1">,</span>
	<span class="s2">url: </span><span class="s0">&quot;git://github.com/motdotla/dotenv.git&quot;</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s1">var </span><span class="s2">keywords = [</span>
	<span class="s0">&quot;dotenv&quot;</span><span class="s1">,</span>
	<span class="s0">&quot;env&quot;</span><span class="s1">,</span>
	<span class="s0">&quot;.env&quot;</span><span class="s1">,</span>
	<span class="s0">&quot;environment&quot;</span><span class="s1">,</span>
	<span class="s0">&quot;variables&quot;</span><span class="s1">,</span>
	<span class="s0">&quot;config&quot;</span><span class="s1">,</span>
	<span class="s0">&quot;settings&quot;</span>
<span class="s2">]</span><span class="s1">;</span>
<span class="s1">var </span><span class="s2">readmeFilename = </span><span class="s0">&quot;README.md&quot;</span><span class="s1">;</span>
<span class="s1">var </span><span class="s2">license = </span><span class="s0">&quot;BSD-2-Clause&quot;</span><span class="s1">;</span>
<span class="s1">var </span><span class="s2">devDependencies = {</span>
	<span class="s0">&quot;@types/node&quot;</span><span class="s2">: </span><span class="s0">&quot;^17.0.9&quot;</span><span class="s1">,</span>
	<span class="s2">decache: </span><span class="s0">&quot;^4.6.1&quot;</span><span class="s1">,</span>
	<span class="s2">dtslint: </span><span class="s0">&quot;^3.7.0&quot;</span><span class="s1">,</span>
	<span class="s2">sinon: </span><span class="s0">&quot;^12.0.1&quot;</span><span class="s1">,</span>
	<span class="s2">standard: </span><span class="s0">&quot;^16.0.4&quot;</span><span class="s1">,</span>
	<span class="s0">&quot;standard-markdown&quot;</span><span class="s2">: </span><span class="s0">&quot;^7.1.0&quot;</span><span class="s1">,</span>
	<span class="s0">&quot;standard-version&quot;</span><span class="s2">: </span><span class="s0">&quot;^9.3.2&quot;</span><span class="s1">,</span>
	<span class="s2">tap: </span><span class="s0">&quot;^15.1.6&quot;</span><span class="s1">,</span>
	<span class="s2">tar: </span><span class="s0">&quot;^6.1.11&quot;</span><span class="s1">,</span>
	<span class="s2">typescript: </span><span class="s0">&quot;^4.5.4&quot;</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s1">var </span><span class="s2">engines = {</span>
	<span class="s2">node: </span><span class="s0">&quot;&gt;=12&quot;</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s1">var </span><span class="s2">require$$3 = {</span>
	<span class="s2">name: name</span><span class="s1">,</span>
	<span class="s2">version: version$1</span><span class="s1">,</span>
	<span class="s2">description: description</span><span class="s1">,</span>
	<span class="s2">main: main</span><span class="s1">,</span>
	<span class="s2">types: types</span><span class="s1">,</span>
	<span class="s2">exports: exports$1</span><span class="s1">,</span>
	<span class="s2">scripts: scripts</span><span class="s1">,</span>
	<span class="s2">repository: repository</span><span class="s1">,</span>
	<span class="s2">keywords: keywords</span><span class="s1">,</span>
	<span class="s2">readmeFilename: readmeFilename</span><span class="s1">,</span>
	<span class="s2">license: license</span><span class="s1">,</span>
	<span class="s2">devDependencies: devDependencies</span><span class="s1">,</span>
	<span class="s2">engines: engines</span>
<span class="s2">}</span><span class="s1">;</span>

<span class="s1">const </span><span class="s2">fs = fs$2</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">path = require$$0$1</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">os = require$$2</span><span class="s1">;</span>
<span class="s1">const </span><span class="s2">packageJson = require$$3</span><span class="s1">;</span>

<span class="s1">const </span><span class="s2">version = packageJson.version</span><span class="s1">;</span>

<span class="s1">const </span><span class="s2">LINE = </span><span class="s5">/(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*&quot;(?:\\&quot;|[^&quot;])*&quot;|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg</span><span class="s1">;</span>

<span class="s4">// Parser src into an Object</span>
<span class="s1">function </span><span class="s2">parse (src) {</span>
  <span class="s1">const </span><span class="s2">obj = {}</span><span class="s1">;</span>

  <span class="s4">// Convert buffer to string</span>
  <span class="s1">let </span><span class="s2">lines = src.toString()</span><span class="s1">;</span>

  <span class="s4">// Convert line breaks to same format</span>
  <span class="s2">lines = lines.replace(</span><span class="s5">/\r\n?/mg</span><span class="s1">, </span><span class="s0">'</span><span class="s1">\n</span><span class="s0">'</span><span class="s2">)</span><span class="s1">;</span>

  <span class="s1">let </span><span class="s2">match</span><span class="s1">;</span>
  <span class="s1">while </span><span class="s2">((match = LINE.exec(lines)) != </span><span class="s1">null</span><span class="s2">) {</span>
    <span class="s1">const </span><span class="s2">key = match[</span><span class="s5">1</span><span class="s2">]</span><span class="s1">;</span>

    <span class="s4">// Default undefined or null to empty string</span>
    <span class="s1">let </span><span class="s2">value = (match[</span><span class="s5">2</span><span class="s2">] || </span><span class="s0">''</span><span class="s2">)</span><span class="s1">;</span>

    <span class="s4">// Remove whitespace</span>
    <span class="s2">value = value.trim()</span><span class="s1">;</span>

    <span class="s4">// Check if double quoted</span>
    <span class="s1">const </span><span class="s2">maybeQuote = value[</span><span class="s5">0</span><span class="s2">]</span><span class="s1">;</span>

    <span class="s4">// Remove surrounding quotes</span>
    <span class="s2">value = value.replace(</span><span class="s5">/^(['&quot;`])([\s\S]*)\1$/mg</span><span class="s1">, </span><span class="s0">'$2'</span><span class="s2">)</span><span class="s1">;</span>

    <span class="s4">// Expand newlines if double quoted</span>
    <span class="s1">if </span><span class="s2">(maybeQuote === </span><span class="s0">'&quot;'</span><span class="s2">) {</span>
      <span class="s2">value = value.replace(</span><span class="s5">/\\n/g</span><span class="s1">, </span><span class="s0">'</span><span class="s1">\n</span><span class="s0">'</span><span class="s2">)</span><span class="s1">;</span>
      <span class="s2">value = value.replace(</span><span class="s5">/\\r/g</span><span class="s1">, </span><span class="s0">'</span><span class="s1">\r</span><span class="s0">'</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>

    <span class="s4">// Add to object</span>
    <span class="s2">obj[key] = value</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s1">return </span><span class="s2">obj</span>
<span class="s2">}</span>

<span class="s1">function </span><span class="s2">_log (message) {</span>
  <span class="s2">console.log(</span><span class="s0">`[dotenv@</span><span class="s2">${version}</span><span class="s0">][DEBUG] </span><span class="s2">${message}</span><span class="s0">`</span><span class="s2">)</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s1">function </span><span class="s2">_resolveHome (envPath) {</span>
  <span class="s1">return </span><span class="s2">envPath[</span><span class="s5">0</span><span class="s2">] === </span><span class="s0">'~' </span><span class="s2">? path.join(os.homedir()</span><span class="s1">, </span><span class="s2">envPath.slice(</span><span class="s5">1</span><span class="s2">)) : envPath</span>
<span class="s2">}</span>

<span class="s4">// Populates process.env from .env file</span>
<span class="s1">function </span><span class="s2">config (options) {</span>
  <span class="s1">let </span><span class="s2">dotenvPath = path.resolve(process.cwd()</span><span class="s1">, </span><span class="s0">'.env'</span><span class="s2">)</span><span class="s1">;</span>
  <span class="s1">let </span><span class="s2">encoding = </span><span class="s0">'utf8'</span><span class="s1">;</span>
  <span class="s1">const </span><span class="s2">debug = Boolean(options &amp;&amp; options.debug)</span><span class="s1">;</span>
  <span class="s1">const </span><span class="s2">override = Boolean(options &amp;&amp; options.override)</span><span class="s1">;</span>

  <span class="s1">if </span><span class="s2">(options) {</span>
    <span class="s1">if </span><span class="s2">(options.path != </span><span class="s1">null</span><span class="s2">) {</span>
      <span class="s2">dotenvPath = _resolveHome(options.path)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(options.encoding != </span><span class="s1">null</span><span class="s2">) {</span>
      <span class="s2">encoding = options.encoding</span><span class="s1">;</span>
    <span class="s2">}</span>
  <span class="s2">}</span>

  <span class="s1">try </span><span class="s2">{</span>
    <span class="s4">// Specifying an encoding returns a string instead of a buffer</span>
    <span class="s1">const </span><span class="s2">parsed = DotenvModule.parse(fs.readFileSync(dotenvPath</span><span class="s1">, </span><span class="s2">{ encoding }))</span><span class="s1">;</span>

    <span class="s2">Object.keys(parsed).forEach(</span><span class="s1">function </span><span class="s2">(key) {</span>
      <span class="s1">if </span><span class="s2">(!Object.prototype.hasOwnProperty.call(process.env</span><span class="s1">, </span><span class="s2">key)) {</span>
        <span class="s2">process.env[key] = parsed[key]</span><span class="s1">;</span>
      <span class="s2">} </span><span class="s1">else </span><span class="s2">{</span>
        <span class="s1">if </span><span class="s2">(override === </span><span class="s1">true</span><span class="s2">) {</span>
          <span class="s2">process.env[key] = parsed[key]</span><span class="s1">;</span>
        <span class="s2">}</span>

        <span class="s1">if </span><span class="s2">(debug) {</span>
          <span class="s1">if </span><span class="s2">(override === </span><span class="s1">true</span><span class="s2">) {</span>
            <span class="s2">_log(</span><span class="s0">`&quot;</span><span class="s2">${key}</span><span class="s0">&quot; is already defined in </span><span class="s1">\`</span><span class="s0">process.env</span><span class="s1">\` </span><span class="s0">and WAS overwritten`</span><span class="s2">)</span><span class="s1">;</span>
          <span class="s2">} </span><span class="s1">else </span><span class="s2">{</span>
            <span class="s2">_log(</span><span class="s0">`&quot;</span><span class="s2">${key}</span><span class="s0">&quot; is already defined in </span><span class="s1">\`</span><span class="s0">process.env</span><span class="s1">\` </span><span class="s0">and was NOT overwritten`</span><span class="s2">)</span><span class="s1">;</span>
          <span class="s2">}</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
    <span class="s2">})</span><span class="s1">;</span>

    <span class="s1">return </span><span class="s2">{ parsed }</span>
  <span class="s2">} </span><span class="s1">catch </span><span class="s2">(e) {</span>
    <span class="s1">if </span><span class="s2">(debug) {</span>
      <span class="s2">_log(</span><span class="s0">`Failed to load </span><span class="s2">${dotenvPath} ${e.message}</span><span class="s0">`</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>

    <span class="s1">return </span><span class="s2">{ error: e }</span>
  <span class="s2">}</span>
<span class="s2">}</span>

<span class="s1">const </span><span class="s2">DotenvModule = {</span>
  <span class="s2">config</span><span class="s1">,</span>
  <span class="s2">parse</span>
<span class="s2">}</span><span class="s1">;</span>

<span class="s2">mainExports.config = DotenvModule.config</span><span class="s1">;</span>
<span class="s1">var </span><span class="s2">parse_1 = mainExports.parse = DotenvModule.parse</span><span class="s1">;</span>
<span class="s2">main$1.exports = DotenvModule</span><span class="s1">;</span>

<span class="s1">function </span><span class="s2">_interpolate (envValue</span><span class="s1">, </span><span class="s2">environment</span><span class="s1">, </span><span class="s2">config) {</span>
  <span class="s1">const </span><span class="s2">matches = envValue.match(</span><span class="s5">/(.?\${*[\w]*(?::-[\w/]*)?}*)/g</span><span class="s2">) || []</span><span class="s1">;</span>

  <span class="s1">return </span><span class="s2">matches.reduce(</span><span class="s1">function </span><span class="s2">(newEnv</span><span class="s1">, </span><span class="s2">match</span><span class="s1">, </span><span class="s2">index) {</span>
    <span class="s1">const </span><span class="s2">parts = </span><span class="s5">/(.?)\${*([\w]*(?::-[\w/]*)?)?}*/g</span><span class="s2">.exec(match)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(!parts || parts.length === </span><span class="s5">0</span><span class="s2">) {</span>
      <span class="s1">return </span><span class="s2">newEnv</span>
    <span class="s2">}</span>

    <span class="s1">const </span><span class="s2">prefix = parts[</span><span class="s5">1</span><span class="s2">]</span><span class="s1">;</span>

    <span class="s1">let </span><span class="s2">value</span><span class="s1">, </span><span class="s2">replacePart</span><span class="s1">;</span>

    <span class="s1">if </span><span class="s2">(prefix === </span><span class="s0">'</span><span class="s1">\\</span><span class="s0">'</span><span class="s2">) {</span>
      <span class="s2">replacePart = parts[</span><span class="s5">0</span><span class="s2">]</span><span class="s1">;</span>
      <span class="s2">value = replacePart.replace(</span><span class="s0">'</span><span class="s1">\\</span><span class="s0">$'</span><span class="s1">, </span><span class="s0">'$'</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">} </span><span class="s1">else </span><span class="s2">{</span>
      <span class="s4">// PATCH: compatible with env variables ended with unescaped $</span>
      <span class="s1">if</span><span class="s2">(!parts[</span><span class="s5">2</span><span class="s2">]) {</span>
        <span class="s1">return </span><span class="s2">newEnv</span>
      <span class="s2">}</span>
      <span class="s1">const </span><span class="s2">keyParts = parts[</span><span class="s5">2</span><span class="s2">].split(</span><span class="s0">':-'</span><span class="s2">)</span><span class="s1">;</span>
      <span class="s1">const </span><span class="s2">key = keyParts[</span><span class="s5">0</span><span class="s2">]</span><span class="s1">;</span>
      <span class="s2">replacePart = parts[</span><span class="s5">0</span><span class="s2">].substring(prefix.length)</span><span class="s1">;</span>
      <span class="s4">// process.env value 'wins' over .env file's value</span>
      <span class="s2">value = Object.prototype.hasOwnProperty.call(environment</span><span class="s1">, </span><span class="s2">key)</span>
        <span class="s2">? environment[key]</span>
        <span class="s2">: (config.parsed[key] || keyParts[</span><span class="s5">1</span><span class="s2">] || </span><span class="s0">''</span><span class="s2">)</span><span class="s1">;</span>

      <span class="s4">// If the value is found, remove nested expansions.</span>
      <span class="s1">if </span><span class="s2">(keyParts.length &gt; </span><span class="s5">1 </span><span class="s2">&amp;&amp; value) {</span>
        <span class="s1">const </span><span class="s2">replaceNested = matches[index + </span><span class="s5">1</span><span class="s2">]</span><span class="s1">;</span>
        <span class="s2">matches[index + </span><span class="s5">1</span><span class="s2">] = </span><span class="s0">''</span><span class="s1">;</span>

        <span class="s2">newEnv = newEnv.replace(replaceNested</span><span class="s1">, </span><span class="s0">''</span><span class="s2">)</span><span class="s1">;</span>
      <span class="s2">}</span>
      <span class="s4">// Resolve recursive interpolations</span>
      <span class="s2">value = _interpolate(value</span><span class="s1">, </span><span class="s2">environment</span><span class="s1">, </span><span class="s2">config)</span><span class="s1">;</span>
    <span class="s2">}</span>

    <span class="s1">return </span><span class="s2">newEnv.replace(replacePart</span><span class="s1">, </span><span class="s2">value)</span>
  <span class="s2">}</span><span class="s1">, </span><span class="s2">envValue)</span>
<span class="s2">}</span>

<span class="s1">function </span><span class="s2">expand (config) {</span>
  <span class="s4">// if ignoring process.env, use a blank object</span>
  <span class="s1">const </span><span class="s2">environment = config.ignoreProcessEnv ? {} : process.env</span><span class="s1">;</span>

  <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">configKey </span><span class="s1">in </span><span class="s2">config.parsed) {</span>
    <span class="s1">const </span><span class="s2">value = Object.prototype.hasOwnProperty.call(environment</span><span class="s1">, </span><span class="s2">configKey) ? environment[configKey] : config.parsed[configKey]</span><span class="s1">;</span>

    <span class="s2">config.parsed[configKey] = _interpolate(value</span><span class="s1">, </span><span class="s2">environment</span><span class="s1">, </span><span class="s2">config)</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s4">// PATCH: don't write to process.env</span>
  <span class="s4">// for (const processKey in config.parsed) {</span>
  <span class="s4">//   environment[processKey] = config.parsed[processKey]</span>
  <span class="s4">// }</span>

  <span class="s1">return </span><span class="s2">config</span>
<span class="s2">}</span>

<span class="s1">var </span><span class="s2">expand_1 = expand</span><span class="s1">;</span>

<span class="s1">function </span><span class="s2">loadEnv(mode</span><span class="s1">, </span><span class="s2">envDir</span><span class="s1">, </span><span class="s2">prefixes = </span><span class="s0">'VITE_'</span><span class="s2">) {</span>
    <span class="s1">if </span><span class="s2">(mode === </span><span class="s0">'local'</span><span class="s2">) {</span>
        <span class="s1">throw new </span><span class="s2">Error(</span><span class="s0">`&quot;local&quot; cannot be used as a mode name because it conflicts with ` </span><span class="s2">+</span>
            <span class="s0">`the .local postfix for .env files.`</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s2">prefixes = arraify(prefixes)</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">env = {}</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">envFiles = [</span>
        <span class="s3">/** default file */ </span><span class="s0">`.env`</span><span class="s1">,</span>
        <span class="s3">/** local file */ </span><span class="s0">`.env.local`</span><span class="s1">,</span>
        <span class="s3">/** mode file */ </span><span class="s0">`.env.</span><span class="s2">${mode}</span><span class="s0">`</span><span class="s1">,</span>
        <span class="s3">/** mode local file */ </span><span class="s0">`.env.</span><span class="s2">${mode}</span><span class="s0">.local`</span><span class="s1">,</span>
    <span class="s2">]</span><span class="s1">;</span>
    <span class="s1">const </span><span class="s2">parsed = Object.fromEntries(envFiles.flatMap((file) =&gt; {</span>
        <span class="s1">const </span><span class="s2">filePath = path$3.join(envDir</span><span class="s1">, </span><span class="s2">file)</span><span class="s1">;</span>
        <span class="s1">if </span><span class="s2">(!tryStatSync(filePath)?.isFile())</span>
            <span class="s1">return </span><span class="s2">[]</span><span class="s1">;</span>
        <span class="s1">return </span><span class="s2">Object.entries(parse_1(fs$1.readFileSync(filePath)))</span><span class="s1">;</span>
    <span class="s2">}))</span><span class="s1">;</span>
    <span class="s4">// test NODE_ENV override before expand as otherwise process.env.NODE_ENV would override this</span>
    <span class="s1">if </span><span class="s2">(parsed.NODE_ENV &amp;&amp; process.env.VITE_USER_NODE_ENV === undefined) {</span>
        <span class="s2">process.env.VITE_USER_NODE_ENV = parsed.NODE_ENV</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s4">// support BROWSER and BROWSER_ARGS env variables</span>
    <span class="s1">if </span><span class="s2">(parsed.BROWSER &amp;&amp; process.env.BROWSER === undefined) {</span>
        <span class="s2">process.env.BROWSER = parsed.BROWSER</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">if </span><span class="s2">(parsed.BROWSER_ARGS &amp;&amp; process.env.BROWSER_ARGS === undefined) {</span>
        <span class="s2">process.env.BROWSER_ARGS = parsed.BROWSER_ARGS</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s4">// let environment variables use each other</span>
    <span class="s4">// `expand` patched in patches/dotenv-expand@9.0.0.patch</span>
    <span class="s2">expand_1({ parsed })</span><span class="s1">;</span>
    <span class="s4">// only keys that start with prefix are exposed to client</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">[key</span><span class="s1">, </span><span class="s2">value] of Object.entries(parsed)) {</span>
        <span class="s1">if </span><span class="s2">(prefixes.some((prefix) =&gt; key.startsWith(prefix))) {</span>
            <span class="s2">env[key] = value</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s4">// check if there are actual env variables starting with VITE_*</span>
    <span class="s4">// these are typically provided inline and should be prioritized</span>
    <span class="s1">for </span><span class="s2">(</span><span class="s1">const </span><span class="s2">key </span><span class="s1">in </span><span class="s2">process.env) {</span>
        <span class="s1">if </span><span class="s2">(prefixes.some((prefix) =&gt; key.startsWith(prefix))) {</span>
            <span class="s2">env[key] = process.env[key]</span><span class="s1">;</span>
        <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">env</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s1">function </span><span class="s2">resolveEnvPrefix({ envPrefix = </span><span class="s0">'VITE_'</span><span class="s1">, </span><span class="s2">}) {</span>
    <span class="s2">envPrefix = arraify(envPrefix)</span><span class="s1">;</span>
    <span class="s1">if </span><span class="s2">(envPrefix.some((prefix) =&gt; prefix === </span><span class="s0">''</span><span class="s2">)) {</span>
        <span class="s1">throw new </span><span class="s2">Error(</span><span class="s0">`envPrefix option contains value '', which could lead unexpected exposure of sensitive information.`</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
    <span class="s1">return </span><span class="s2">envPrefix</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s2">exports.esbuildVersion = esbuild.version</span><span class="s1">;</span>
<span class="s2">exports.rollupVersion = rollup.VERSION</span><span class="s1">;</span>
<span class="s2">exports.createFilter = createFilter</span><span class="s1">;</span>
<span class="s2">exports.createLogger = createLogger</span><span class="s1">;</span>
<span class="s2">exports.isCSSRequest = isCSSRequest</span><span class="s1">;</span>
<span class="s2">exports.isFileServingAllowed = isFileServingAllowed</span><span class="s1">;</span>
<span class="s2">exports.loadEnv = loadEnv</span><span class="s1">;</span>
<span class="s2">exports.mergeAlias = mergeAlias</span><span class="s1">;</span>
<span class="s2">exports.mergeConfig = mergeConfig</span><span class="s1">;</span>
<span class="s2">exports.normalizePath = normalizePath</span><span class="s1">;</span>
<span class="s2">exports.resolveEnvPrefix = resolveEnvPrefix</span><span class="s1">;</span>
<span class="s2">exports.searchForWorkspaceRoot = searchForWorkspaceRoot</span><span class="s1">;</span>
<span class="s2">exports.send = send</span><span class="s1">;</span>
<span class="s2">exports.splitVendorChunk = splitVendorChunk</span><span class="s1">;</span>
<span class="s2">exports.splitVendorChunkPlugin = splitVendorChunkPlugin</span><span class="s1">;</span>
<span class="s2">exports.version = VERSION</span><span class="s1">;</span>
</pre>
</body>
</html>